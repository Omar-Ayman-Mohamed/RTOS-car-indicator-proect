
RTOS_2023.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000655a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000002c  00800060  0000655a  000065ee  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000006a7  0080008c  0080008c  0000661a  2**0
                  ALLOC
  3 .stab         000093cc  00000000  00000000  0000661c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000057c8  00000000  00000000  0000f9e8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 9a 03 	jmp	0x734	; 0x734 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea e5       	ldi	r30, 0x5A	; 90
      68:	f5 e6       	ldi	r31, 0x65	; 101
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 38       	cpi	r26, 0x8C	; 140
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	ac e8       	ldi	r26, 0x8C	; 140
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 33       	cpi	r26, 0x33	; 51
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 3f 31 	call	0x627e	; 0x627e <main>
      8a:	0c 94 ab 32 	jmp	0x6556	; 0x6556 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <pvPortMalloc+0x6>
      98:	00 d0       	rcall	.+0      	; 0x9a <pvPortMalloc+0x8>
      9a:	cd b7       	in	r28, 0x3d	; 61
      9c:	de b7       	in	r29, 0x3e	; 62
      9e:	9c 83       	std	Y+4, r25	; 0x04
      a0:	8b 83       	std	Y+3, r24	; 0x03
    void * pvReturn = NULL;
      a2:	1a 82       	std	Y+2, r1	; 0x02
      a4:	19 82       	std	Y+1, r1	; 0x01
                }
            }
        }
    #endif

    vTaskSuspendAll();
      a6:	0e 94 44 1b 	call	0x3688	; 0x3688 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
      aa:	80 91 8e 00 	lds	r24, 0x008E
      ae:	90 91 8f 00 	lds	r25, 0x008F
      b2:	00 97       	sbiw	r24, 0x00	; 0
      b4:	31 f4       	brne	.+12     	; 0xc2 <pvPortMalloc+0x30>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
      b6:	80 e9       	ldi	r24, 0x90	; 144
      b8:	90 e0       	ldi	r25, 0x00	; 0
      ba:	90 93 8f 00 	sts	0x008F, r25
      be:	80 93 8e 00 	sts	0x008E, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
      c2:	8b 81       	ldd	r24, Y+3	; 0x03
      c4:	9c 81       	ldd	r25, Y+4	; 0x04
      c6:	00 97       	sbiw	r24, 0x00	; 0
      c8:	99 f1       	breq	.+102    	; 0x130 <pvPortMalloc+0x9e>
      ca:	80 91 8c 00 	lds	r24, 0x008C
      ce:	90 91 8d 00 	lds	r25, 0x008D
      d2:	2b 81       	ldd	r18, Y+3	; 0x03
      d4:	3c 81       	ldd	r19, Y+4	; 0x04
      d6:	82 0f       	add	r24, r18
      d8:	93 1f       	adc	r25, r19
      da:	25 e0       	ldi	r18, 0x05	; 5
      dc:	8b 3d       	cpi	r24, 0xDB	; 219
      de:	92 07       	cpc	r25, r18
      e0:	38 f5       	brcc	.+78     	; 0x130 <pvPortMalloc+0x9e>
      e2:	20 91 8c 00 	lds	r18, 0x008C
      e6:	30 91 8d 00 	lds	r19, 0x008D
      ea:	8b 81       	ldd	r24, Y+3	; 0x03
      ec:	9c 81       	ldd	r25, Y+4	; 0x04
      ee:	28 0f       	add	r18, r24
      f0:	39 1f       	adc	r19, r25
      f2:	80 91 8c 00 	lds	r24, 0x008C
      f6:	90 91 8d 00 	lds	r25, 0x008D
      fa:	82 17       	cp	r24, r18
      fc:	93 07       	cpc	r25, r19
      fe:	c0 f4       	brcc	.+48     	; 0x130 <pvPortMalloc+0x9e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
     100:	20 91 8e 00 	lds	r18, 0x008E
     104:	30 91 8f 00 	lds	r19, 0x008F
     108:	80 91 8c 00 	lds	r24, 0x008C
     10c:	90 91 8d 00 	lds	r25, 0x008D
     110:	82 0f       	add	r24, r18
     112:	93 1f       	adc	r25, r19
     114:	9a 83       	std	Y+2, r25	; 0x02
     116:	89 83       	std	Y+1, r24	; 0x01
            xNextFreeByte += xWantedSize;
     118:	20 91 8c 00 	lds	r18, 0x008C
     11c:	30 91 8d 00 	lds	r19, 0x008D
     120:	8b 81       	ldd	r24, Y+3	; 0x03
     122:	9c 81       	ldd	r25, Y+4	; 0x04
     124:	82 0f       	add	r24, r18
     126:	93 1f       	adc	r25, r19
     128:	90 93 8d 00 	sts	0x008D, r25
     12c:	80 93 8c 00 	sts	0x008C, r24
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
     130:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
     134:	89 81       	ldd	r24, Y+1	; 0x01
     136:	9a 81       	ldd	r25, Y+2	; 0x02
}
     138:	0f 90       	pop	r0
     13a:	0f 90       	pop	r0
     13c:	0f 90       	pop	r0
     13e:	0f 90       	pop	r0
     140:	cf 91       	pop	r28
     142:	df 91       	pop	r29
     144:	08 95       	ret

00000146 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
     146:	df 93       	push	r29
     148:	cf 93       	push	r28
     14a:	00 d0       	rcall	.+0      	; 0x14c <vPortFree+0x6>
     14c:	cd b7       	in	r28, 0x3d	; 61
     14e:	de b7       	in	r29, 0x3e	; 62
     150:	9a 83       	std	Y+2, r25	; 0x02
     152:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
     154:	0f 90       	pop	r0
     156:	0f 90       	pop	r0
     158:	cf 91       	pop	r28
     15a:	df 91       	pop	r29
     15c:	08 95       	ret

0000015e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     15e:	df 93       	push	r29
     160:	cf 93       	push	r28
     162:	cd b7       	in	r28, 0x3d	; 61
     164:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
     166:	10 92 8d 00 	sts	0x008D, r1
     16a:	10 92 8c 00 	sts	0x008C, r1
}
     16e:	cf 91       	pop	r28
     170:	df 91       	pop	r29
     172:	08 95       	ret

00000174 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     174:	df 93       	push	r29
     176:	cf 93       	push	r28
     178:	cd b7       	in	r28, 0x3d	; 61
     17a:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     17c:	20 91 8c 00 	lds	r18, 0x008C
     180:	30 91 8d 00 	lds	r19, 0x008D
     184:	8b ed       	ldi	r24, 0xDB	; 219
     186:	95 e0       	ldi	r25, 0x05	; 5
     188:	82 1b       	sub	r24, r18
     18a:	93 0b       	sbc	r25, r19
}
     18c:	cf 91       	pop	r28
     18e:	df 91       	pop	r29
     190:	08 95       	ret

00000192 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     192:	df 93       	push	r29
     194:	cf 93       	push	r28
     196:	cd b7       	in	r28, 0x3d	; 61
     198:	de b7       	in	r29, 0x3e	; 62
     19a:	28 97       	sbiw	r28, 0x08	; 8
     19c:	0f b6       	in	r0, 0x3f	; 63
     19e:	f8 94       	cli
     1a0:	de bf       	out	0x3e, r29	; 62
     1a2:	0f be       	out	0x3f, r0	; 63
     1a4:	cd bf       	out	0x3d, r28	; 61
     1a6:	9c 83       	std	Y+4, r25	; 0x04
     1a8:	8b 83       	std	Y+3, r24	; 0x03
     1aa:	7e 83       	std	Y+6, r23	; 0x06
     1ac:	6d 83       	std	Y+5, r22	; 0x05
     1ae:	58 87       	std	Y+8, r21	; 0x08
     1b0:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     1b2:	eb 81       	ldd	r30, Y+3	; 0x03
     1b4:	fc 81       	ldd	r31, Y+4	; 0x04
     1b6:	81 e1       	ldi	r24, 0x11	; 17
     1b8:	80 83       	st	Z, r24
	pxTopOfStack--;
     1ba:	8b 81       	ldd	r24, Y+3	; 0x03
     1bc:	9c 81       	ldd	r25, Y+4	; 0x04
     1be:	01 97       	sbiw	r24, 0x01	; 1
     1c0:	9c 83       	std	Y+4, r25	; 0x04
     1c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     1c4:	eb 81       	ldd	r30, Y+3	; 0x03
     1c6:	fc 81       	ldd	r31, Y+4	; 0x04
     1c8:	82 e2       	ldi	r24, 0x22	; 34
     1ca:	80 83       	st	Z, r24
	pxTopOfStack--;
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	01 97       	sbiw	r24, 0x01	; 1
     1d2:	9c 83       	std	Y+4, r25	; 0x04
     1d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     1d6:	eb 81       	ldd	r30, Y+3	; 0x03
     1d8:	fc 81       	ldd	r31, Y+4	; 0x04
     1da:	83 e3       	ldi	r24, 0x33	; 51
     1dc:	80 83       	st	Z, r24
	pxTopOfStack--;
     1de:	8b 81       	ldd	r24, Y+3	; 0x03
     1e0:	9c 81       	ldd	r25, Y+4	; 0x04
     1e2:	01 97       	sbiw	r24, 0x01	; 1
     1e4:	9c 83       	std	Y+4, r25	; 0x04
     1e6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     1e8:	8d 81       	ldd	r24, Y+5	; 0x05
     1ea:	9e 81       	ldd	r25, Y+6	; 0x06
     1ec:	9a 83       	std	Y+2, r25	; 0x02
     1ee:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     1f0:	89 81       	ldd	r24, Y+1	; 0x01
     1f2:	eb 81       	ldd	r30, Y+3	; 0x03
     1f4:	fc 81       	ldd	r31, Y+4	; 0x04
     1f6:	80 83       	st	Z, r24
	pxTopOfStack--;
     1f8:	8b 81       	ldd	r24, Y+3	; 0x03
     1fa:	9c 81       	ldd	r25, Y+4	; 0x04
     1fc:	01 97       	sbiw	r24, 0x01	; 1
     1fe:	9c 83       	std	Y+4, r25	; 0x04
     200:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     202:	89 81       	ldd	r24, Y+1	; 0x01
     204:	9a 81       	ldd	r25, Y+2	; 0x02
     206:	89 2f       	mov	r24, r25
     208:	99 27       	eor	r25, r25
     20a:	9a 83       	std	Y+2, r25	; 0x02
     20c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     20e:	89 81       	ldd	r24, Y+1	; 0x01
     210:	eb 81       	ldd	r30, Y+3	; 0x03
     212:	fc 81       	ldd	r31, Y+4	; 0x04
     214:	80 83       	st	Z, r24
	pxTopOfStack--;
     216:	8b 81       	ldd	r24, Y+3	; 0x03
     218:	9c 81       	ldd	r25, Y+4	; 0x04
     21a:	01 97       	sbiw	r24, 0x01	; 1
     21c:	9c 83       	std	Y+4, r25	; 0x04
     21e:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     220:	eb 81       	ldd	r30, Y+3	; 0x03
     222:	fc 81       	ldd	r31, Y+4	; 0x04
     224:	10 82       	st	Z, r1
	pxTopOfStack--;
     226:	8b 81       	ldd	r24, Y+3	; 0x03
     228:	9c 81       	ldd	r25, Y+4	; 0x04
     22a:	01 97       	sbiw	r24, 0x01	; 1
     22c:	9c 83       	std	Y+4, r25	; 0x04
     22e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     230:	eb 81       	ldd	r30, Y+3	; 0x03
     232:	fc 81       	ldd	r31, Y+4	; 0x04
     234:	80 e8       	ldi	r24, 0x80	; 128
     236:	80 83       	st	Z, r24
	pxTopOfStack--;
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	01 97       	sbiw	r24, 0x01	; 1
     23e:	9c 83       	std	Y+4, r25	; 0x04
     240:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     242:	eb 81       	ldd	r30, Y+3	; 0x03
     244:	fc 81       	ldd	r31, Y+4	; 0x04
     246:	10 82       	st	Z, r1
	pxTopOfStack--;
     248:	8b 81       	ldd	r24, Y+3	; 0x03
     24a:	9c 81       	ldd	r25, Y+4	; 0x04
     24c:	01 97       	sbiw	r24, 0x01	; 1
     24e:	9c 83       	std	Y+4, r25	; 0x04
     250:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     252:	eb 81       	ldd	r30, Y+3	; 0x03
     254:	fc 81       	ldd	r31, Y+4	; 0x04
     256:	82 e0       	ldi	r24, 0x02	; 2
     258:	80 83       	st	Z, r24
	pxTopOfStack--;
     25a:	8b 81       	ldd	r24, Y+3	; 0x03
     25c:	9c 81       	ldd	r25, Y+4	; 0x04
     25e:	01 97       	sbiw	r24, 0x01	; 1
     260:	9c 83       	std	Y+4, r25	; 0x04
     262:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     264:	eb 81       	ldd	r30, Y+3	; 0x03
     266:	fc 81       	ldd	r31, Y+4	; 0x04
     268:	83 e0       	ldi	r24, 0x03	; 3
     26a:	80 83       	st	Z, r24
	pxTopOfStack--;
     26c:	8b 81       	ldd	r24, Y+3	; 0x03
     26e:	9c 81       	ldd	r25, Y+4	; 0x04
     270:	01 97       	sbiw	r24, 0x01	; 1
     272:	9c 83       	std	Y+4, r25	; 0x04
     274:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     276:	eb 81       	ldd	r30, Y+3	; 0x03
     278:	fc 81       	ldd	r31, Y+4	; 0x04
     27a:	84 e0       	ldi	r24, 0x04	; 4
     27c:	80 83       	st	Z, r24
	pxTopOfStack--;
     27e:	8b 81       	ldd	r24, Y+3	; 0x03
     280:	9c 81       	ldd	r25, Y+4	; 0x04
     282:	01 97       	sbiw	r24, 0x01	; 1
     284:	9c 83       	std	Y+4, r25	; 0x04
     286:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     288:	eb 81       	ldd	r30, Y+3	; 0x03
     28a:	fc 81       	ldd	r31, Y+4	; 0x04
     28c:	85 e0       	ldi	r24, 0x05	; 5
     28e:	80 83       	st	Z, r24
	pxTopOfStack--;
     290:	8b 81       	ldd	r24, Y+3	; 0x03
     292:	9c 81       	ldd	r25, Y+4	; 0x04
     294:	01 97       	sbiw	r24, 0x01	; 1
     296:	9c 83       	std	Y+4, r25	; 0x04
     298:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     29a:	eb 81       	ldd	r30, Y+3	; 0x03
     29c:	fc 81       	ldd	r31, Y+4	; 0x04
     29e:	86 e0       	ldi	r24, 0x06	; 6
     2a0:	80 83       	st	Z, r24
	pxTopOfStack--;
     2a2:	8b 81       	ldd	r24, Y+3	; 0x03
     2a4:	9c 81       	ldd	r25, Y+4	; 0x04
     2a6:	01 97       	sbiw	r24, 0x01	; 1
     2a8:	9c 83       	std	Y+4, r25	; 0x04
     2aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     2ac:	eb 81       	ldd	r30, Y+3	; 0x03
     2ae:	fc 81       	ldd	r31, Y+4	; 0x04
     2b0:	87 e0       	ldi	r24, 0x07	; 7
     2b2:	80 83       	st	Z, r24
	pxTopOfStack--;
     2b4:	8b 81       	ldd	r24, Y+3	; 0x03
     2b6:	9c 81       	ldd	r25, Y+4	; 0x04
     2b8:	01 97       	sbiw	r24, 0x01	; 1
     2ba:	9c 83       	std	Y+4, r25	; 0x04
     2bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     2be:	eb 81       	ldd	r30, Y+3	; 0x03
     2c0:	fc 81       	ldd	r31, Y+4	; 0x04
     2c2:	88 e0       	ldi	r24, 0x08	; 8
     2c4:	80 83       	st	Z, r24
	pxTopOfStack--;
     2c6:	8b 81       	ldd	r24, Y+3	; 0x03
     2c8:	9c 81       	ldd	r25, Y+4	; 0x04
     2ca:	01 97       	sbiw	r24, 0x01	; 1
     2cc:	9c 83       	std	Y+4, r25	; 0x04
     2ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     2d0:	eb 81       	ldd	r30, Y+3	; 0x03
     2d2:	fc 81       	ldd	r31, Y+4	; 0x04
     2d4:	89 e0       	ldi	r24, 0x09	; 9
     2d6:	80 83       	st	Z, r24
	pxTopOfStack--;
     2d8:	8b 81       	ldd	r24, Y+3	; 0x03
     2da:	9c 81       	ldd	r25, Y+4	; 0x04
     2dc:	01 97       	sbiw	r24, 0x01	; 1
     2de:	9c 83       	std	Y+4, r25	; 0x04
     2e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     2e2:	eb 81       	ldd	r30, Y+3	; 0x03
     2e4:	fc 81       	ldd	r31, Y+4	; 0x04
     2e6:	80 e1       	ldi	r24, 0x10	; 16
     2e8:	80 83       	st	Z, r24
	pxTopOfStack--;
     2ea:	8b 81       	ldd	r24, Y+3	; 0x03
     2ec:	9c 81       	ldd	r25, Y+4	; 0x04
     2ee:	01 97       	sbiw	r24, 0x01	; 1
     2f0:	9c 83       	std	Y+4, r25	; 0x04
     2f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     2f4:	eb 81       	ldd	r30, Y+3	; 0x03
     2f6:	fc 81       	ldd	r31, Y+4	; 0x04
     2f8:	81 e1       	ldi	r24, 0x11	; 17
     2fa:	80 83       	st	Z, r24
	pxTopOfStack--;
     2fc:	8b 81       	ldd	r24, Y+3	; 0x03
     2fe:	9c 81       	ldd	r25, Y+4	; 0x04
     300:	01 97       	sbiw	r24, 0x01	; 1
     302:	9c 83       	std	Y+4, r25	; 0x04
     304:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     306:	eb 81       	ldd	r30, Y+3	; 0x03
     308:	fc 81       	ldd	r31, Y+4	; 0x04
     30a:	82 e1       	ldi	r24, 0x12	; 18
     30c:	80 83       	st	Z, r24
	pxTopOfStack--;
     30e:	8b 81       	ldd	r24, Y+3	; 0x03
     310:	9c 81       	ldd	r25, Y+4	; 0x04
     312:	01 97       	sbiw	r24, 0x01	; 1
     314:	9c 83       	std	Y+4, r25	; 0x04
     316:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     318:	eb 81       	ldd	r30, Y+3	; 0x03
     31a:	fc 81       	ldd	r31, Y+4	; 0x04
     31c:	83 e1       	ldi	r24, 0x13	; 19
     31e:	80 83       	st	Z, r24
	pxTopOfStack--;
     320:	8b 81       	ldd	r24, Y+3	; 0x03
     322:	9c 81       	ldd	r25, Y+4	; 0x04
     324:	01 97       	sbiw	r24, 0x01	; 1
     326:	9c 83       	std	Y+4, r25	; 0x04
     328:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     32a:	eb 81       	ldd	r30, Y+3	; 0x03
     32c:	fc 81       	ldd	r31, Y+4	; 0x04
     32e:	84 e1       	ldi	r24, 0x14	; 20
     330:	80 83       	st	Z, r24
	pxTopOfStack--;
     332:	8b 81       	ldd	r24, Y+3	; 0x03
     334:	9c 81       	ldd	r25, Y+4	; 0x04
     336:	01 97       	sbiw	r24, 0x01	; 1
     338:	9c 83       	std	Y+4, r25	; 0x04
     33a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     33c:	eb 81       	ldd	r30, Y+3	; 0x03
     33e:	fc 81       	ldd	r31, Y+4	; 0x04
     340:	85 e1       	ldi	r24, 0x15	; 21
     342:	80 83       	st	Z, r24
	pxTopOfStack--;
     344:	8b 81       	ldd	r24, Y+3	; 0x03
     346:	9c 81       	ldd	r25, Y+4	; 0x04
     348:	01 97       	sbiw	r24, 0x01	; 1
     34a:	9c 83       	std	Y+4, r25	; 0x04
     34c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     34e:	eb 81       	ldd	r30, Y+3	; 0x03
     350:	fc 81       	ldd	r31, Y+4	; 0x04
     352:	86 e1       	ldi	r24, 0x16	; 22
     354:	80 83       	st	Z, r24
	pxTopOfStack--;
     356:	8b 81       	ldd	r24, Y+3	; 0x03
     358:	9c 81       	ldd	r25, Y+4	; 0x04
     35a:	01 97       	sbiw	r24, 0x01	; 1
     35c:	9c 83       	std	Y+4, r25	; 0x04
     35e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     360:	eb 81       	ldd	r30, Y+3	; 0x03
     362:	fc 81       	ldd	r31, Y+4	; 0x04
     364:	87 e1       	ldi	r24, 0x17	; 23
     366:	80 83       	st	Z, r24
	pxTopOfStack--;
     368:	8b 81       	ldd	r24, Y+3	; 0x03
     36a:	9c 81       	ldd	r25, Y+4	; 0x04
     36c:	01 97       	sbiw	r24, 0x01	; 1
     36e:	9c 83       	std	Y+4, r25	; 0x04
     370:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     372:	eb 81       	ldd	r30, Y+3	; 0x03
     374:	fc 81       	ldd	r31, Y+4	; 0x04
     376:	88 e1       	ldi	r24, 0x18	; 24
     378:	80 83       	st	Z, r24
	pxTopOfStack--;
     37a:	8b 81       	ldd	r24, Y+3	; 0x03
     37c:	9c 81       	ldd	r25, Y+4	; 0x04
     37e:	01 97       	sbiw	r24, 0x01	; 1
     380:	9c 83       	std	Y+4, r25	; 0x04
     382:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     384:	eb 81       	ldd	r30, Y+3	; 0x03
     386:	fc 81       	ldd	r31, Y+4	; 0x04
     388:	89 e1       	ldi	r24, 0x19	; 25
     38a:	80 83       	st	Z, r24
	pxTopOfStack--;
     38c:	8b 81       	ldd	r24, Y+3	; 0x03
     38e:	9c 81       	ldd	r25, Y+4	; 0x04
     390:	01 97       	sbiw	r24, 0x01	; 1
     392:	9c 83       	std	Y+4, r25	; 0x04
     394:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     396:	eb 81       	ldd	r30, Y+3	; 0x03
     398:	fc 81       	ldd	r31, Y+4	; 0x04
     39a:	80 e2       	ldi	r24, 0x20	; 32
     39c:	80 83       	st	Z, r24
	pxTopOfStack--;
     39e:	8b 81       	ldd	r24, Y+3	; 0x03
     3a0:	9c 81       	ldd	r25, Y+4	; 0x04
     3a2:	01 97       	sbiw	r24, 0x01	; 1
     3a4:	9c 83       	std	Y+4, r25	; 0x04
     3a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     3a8:	eb 81       	ldd	r30, Y+3	; 0x03
     3aa:	fc 81       	ldd	r31, Y+4	; 0x04
     3ac:	81 e2       	ldi	r24, 0x21	; 33
     3ae:	80 83       	st	Z, r24
	pxTopOfStack--;
     3b0:	8b 81       	ldd	r24, Y+3	; 0x03
     3b2:	9c 81       	ldd	r25, Y+4	; 0x04
     3b4:	01 97       	sbiw	r24, 0x01	; 1
     3b6:	9c 83       	std	Y+4, r25	; 0x04
     3b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     3ba:	eb 81       	ldd	r30, Y+3	; 0x03
     3bc:	fc 81       	ldd	r31, Y+4	; 0x04
     3be:	82 e2       	ldi	r24, 0x22	; 34
     3c0:	80 83       	st	Z, r24
	pxTopOfStack--;
     3c2:	8b 81       	ldd	r24, Y+3	; 0x03
     3c4:	9c 81       	ldd	r25, Y+4	; 0x04
     3c6:	01 97       	sbiw	r24, 0x01	; 1
     3c8:	9c 83       	std	Y+4, r25	; 0x04
     3ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     3cc:	eb 81       	ldd	r30, Y+3	; 0x03
     3ce:	fc 81       	ldd	r31, Y+4	; 0x04
     3d0:	83 e2       	ldi	r24, 0x23	; 35
     3d2:	80 83       	st	Z, r24
	pxTopOfStack--;
     3d4:	8b 81       	ldd	r24, Y+3	; 0x03
     3d6:	9c 81       	ldd	r25, Y+4	; 0x04
     3d8:	01 97       	sbiw	r24, 0x01	; 1
     3da:	9c 83       	std	Y+4, r25	; 0x04
     3dc:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     3de:	8f 81       	ldd	r24, Y+7	; 0x07
     3e0:	98 85       	ldd	r25, Y+8	; 0x08
     3e2:	9a 83       	std	Y+2, r25	; 0x02
     3e4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     3e6:	89 81       	ldd	r24, Y+1	; 0x01
     3e8:	eb 81       	ldd	r30, Y+3	; 0x03
     3ea:	fc 81       	ldd	r31, Y+4	; 0x04
     3ec:	80 83       	st	Z, r24
	pxTopOfStack--;
     3ee:	8b 81       	ldd	r24, Y+3	; 0x03
     3f0:	9c 81       	ldd	r25, Y+4	; 0x04
     3f2:	01 97       	sbiw	r24, 0x01	; 1
     3f4:	9c 83       	std	Y+4, r25	; 0x04
     3f6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     3f8:	89 81       	ldd	r24, Y+1	; 0x01
     3fa:	9a 81       	ldd	r25, Y+2	; 0x02
     3fc:	89 2f       	mov	r24, r25
     3fe:	99 27       	eor	r25, r25
     400:	9a 83       	std	Y+2, r25	; 0x02
     402:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     404:	89 81       	ldd	r24, Y+1	; 0x01
     406:	eb 81       	ldd	r30, Y+3	; 0x03
     408:	fc 81       	ldd	r31, Y+4	; 0x04
     40a:	80 83       	st	Z, r24
	pxTopOfStack--;
     40c:	8b 81       	ldd	r24, Y+3	; 0x03
     40e:	9c 81       	ldd	r25, Y+4	; 0x04
     410:	01 97       	sbiw	r24, 0x01	; 1
     412:	9c 83       	std	Y+4, r25	; 0x04
     414:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     416:	eb 81       	ldd	r30, Y+3	; 0x03
     418:	fc 81       	ldd	r31, Y+4	; 0x04
     41a:	86 e2       	ldi	r24, 0x26	; 38
     41c:	80 83       	st	Z, r24
	pxTopOfStack--;
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	9c 81       	ldd	r25, Y+4	; 0x04
     422:	01 97       	sbiw	r24, 0x01	; 1
     424:	9c 83       	std	Y+4, r25	; 0x04
     426:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     428:	eb 81       	ldd	r30, Y+3	; 0x03
     42a:	fc 81       	ldd	r31, Y+4	; 0x04
     42c:	87 e2       	ldi	r24, 0x27	; 39
     42e:	80 83       	st	Z, r24
	pxTopOfStack--;
     430:	8b 81       	ldd	r24, Y+3	; 0x03
     432:	9c 81       	ldd	r25, Y+4	; 0x04
     434:	01 97       	sbiw	r24, 0x01	; 1
     436:	9c 83       	std	Y+4, r25	; 0x04
     438:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     43a:	eb 81       	ldd	r30, Y+3	; 0x03
     43c:	fc 81       	ldd	r31, Y+4	; 0x04
     43e:	88 e2       	ldi	r24, 0x28	; 40
     440:	80 83       	st	Z, r24
	pxTopOfStack--;
     442:	8b 81       	ldd	r24, Y+3	; 0x03
     444:	9c 81       	ldd	r25, Y+4	; 0x04
     446:	01 97       	sbiw	r24, 0x01	; 1
     448:	9c 83       	std	Y+4, r25	; 0x04
     44a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     44c:	eb 81       	ldd	r30, Y+3	; 0x03
     44e:	fc 81       	ldd	r31, Y+4	; 0x04
     450:	89 e2       	ldi	r24, 0x29	; 41
     452:	80 83       	st	Z, r24
	pxTopOfStack--;
     454:	8b 81       	ldd	r24, Y+3	; 0x03
     456:	9c 81       	ldd	r25, Y+4	; 0x04
     458:	01 97       	sbiw	r24, 0x01	; 1
     45a:	9c 83       	std	Y+4, r25	; 0x04
     45c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     45e:	eb 81       	ldd	r30, Y+3	; 0x03
     460:	fc 81       	ldd	r31, Y+4	; 0x04
     462:	80 e3       	ldi	r24, 0x30	; 48
     464:	80 83       	st	Z, r24
	pxTopOfStack--;
     466:	8b 81       	ldd	r24, Y+3	; 0x03
     468:	9c 81       	ldd	r25, Y+4	; 0x04
     46a:	01 97       	sbiw	r24, 0x01	; 1
     46c:	9c 83       	std	Y+4, r25	; 0x04
     46e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     470:	eb 81       	ldd	r30, Y+3	; 0x03
     472:	fc 81       	ldd	r31, Y+4	; 0x04
     474:	81 e3       	ldi	r24, 0x31	; 49
     476:	80 83       	st	Z, r24
	pxTopOfStack--;
     478:	8b 81       	ldd	r24, Y+3	; 0x03
     47a:	9c 81       	ldd	r25, Y+4	; 0x04
     47c:	01 97       	sbiw	r24, 0x01	; 1
     47e:	9c 83       	std	Y+4, r25	; 0x04
     480:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     482:	8b 81       	ldd	r24, Y+3	; 0x03
     484:	9c 81       	ldd	r25, Y+4	; 0x04
}
     486:	28 96       	adiw	r28, 0x08	; 8
     488:	0f b6       	in	r0, 0x3f	; 63
     48a:	f8 94       	cli
     48c:	de bf       	out	0x3e, r29	; 62
     48e:	0f be       	out	0x3f, r0	; 63
     490:	cd bf       	out	0x3d, r28	; 61
     492:	cf 91       	pop	r28
     494:	df 91       	pop	r29
     496:	08 95       	ret

00000498 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     498:	df 93       	push	r29
     49a:	cf 93       	push	r28
     49c:	cd b7       	in	r28, 0x3d	; 61
     49e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     4a0:	0e 94 3e 03 	call	0x67c	; 0x67c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     4a4:	a0 91 a6 06 	lds	r26, 0x06A6
     4a8:	b0 91 a7 06 	lds	r27, 0x06A7
     4ac:	cd 91       	ld	r28, X+
     4ae:	cd bf       	out	0x3d, r28	; 61
     4b0:	dd 91       	ld	r29, X+
     4b2:	de bf       	out	0x3e, r29	; 62
     4b4:	ff 91       	pop	r31
     4b6:	ef 91       	pop	r30
     4b8:	df 91       	pop	r29
     4ba:	cf 91       	pop	r28
     4bc:	bf 91       	pop	r27
     4be:	af 91       	pop	r26
     4c0:	9f 91       	pop	r25
     4c2:	8f 91       	pop	r24
     4c4:	7f 91       	pop	r23
     4c6:	6f 91       	pop	r22
     4c8:	5f 91       	pop	r21
     4ca:	4f 91       	pop	r20
     4cc:	3f 91       	pop	r19
     4ce:	2f 91       	pop	r18
     4d0:	1f 91       	pop	r17
     4d2:	0f 91       	pop	r16
     4d4:	ff 90       	pop	r15
     4d6:	ef 90       	pop	r14
     4d8:	df 90       	pop	r13
     4da:	cf 90       	pop	r12
     4dc:	bf 90       	pop	r11
     4de:	af 90       	pop	r10
     4e0:	9f 90       	pop	r9
     4e2:	8f 90       	pop	r8
     4e4:	7f 90       	pop	r7
     4e6:	6f 90       	pop	r6
     4e8:	5f 90       	pop	r5
     4ea:	4f 90       	pop	r4
     4ec:	3f 90       	pop	r3
     4ee:	2f 90       	pop	r2
     4f0:	1f 90       	pop	r1
     4f2:	0f 90       	pop	r0
     4f4:	0f be       	out	0x3f, r0	; 63
     4f6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     4f8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     4fa:	81 e0       	ldi	r24, 0x01	; 1
}
     4fc:	cf 91       	pop	r28
     4fe:	df 91       	pop	r29
     500:	08 95       	ret

00000502 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     502:	df 93       	push	r29
     504:	cf 93       	push	r28
     506:	cd b7       	in	r28, 0x3d	; 61
     508:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     50a:	cf 91       	pop	r28
     50c:	df 91       	pop	r29
     50e:	08 95       	ret

00000510 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     510:	0f 92       	push	r0
     512:	0f b6       	in	r0, 0x3f	; 63
     514:	f8 94       	cli
     516:	0f 92       	push	r0
     518:	1f 92       	push	r1
     51a:	11 24       	eor	r1, r1
     51c:	2f 92       	push	r2
     51e:	3f 92       	push	r3
     520:	4f 92       	push	r4
     522:	5f 92       	push	r5
     524:	6f 92       	push	r6
     526:	7f 92       	push	r7
     528:	8f 92       	push	r8
     52a:	9f 92       	push	r9
     52c:	af 92       	push	r10
     52e:	bf 92       	push	r11
     530:	cf 92       	push	r12
     532:	df 92       	push	r13
     534:	ef 92       	push	r14
     536:	ff 92       	push	r15
     538:	0f 93       	push	r16
     53a:	1f 93       	push	r17
     53c:	2f 93       	push	r18
     53e:	3f 93       	push	r19
     540:	4f 93       	push	r20
     542:	5f 93       	push	r21
     544:	6f 93       	push	r22
     546:	7f 93       	push	r23
     548:	8f 93       	push	r24
     54a:	9f 93       	push	r25
     54c:	af 93       	push	r26
     54e:	bf 93       	push	r27
     550:	cf 93       	push	r28
     552:	df 93       	push	r29
     554:	ef 93       	push	r30
     556:	ff 93       	push	r31
     558:	a0 91 a6 06 	lds	r26, 0x06A6
     55c:	b0 91 a7 06 	lds	r27, 0x06A7
     560:	0d b6       	in	r0, 0x3d	; 61
     562:	0d 92       	st	X+, r0
     564:	0e b6       	in	r0, 0x3e	; 62
     566:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     568:	0e 94 b4 1e 	call	0x3d68	; 0x3d68 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     56c:	a0 91 a6 06 	lds	r26, 0x06A6
     570:	b0 91 a7 06 	lds	r27, 0x06A7
     574:	cd 91       	ld	r28, X+
     576:	cd bf       	out	0x3d, r28	; 61
     578:	dd 91       	ld	r29, X+
     57a:	de bf       	out	0x3e, r29	; 62
     57c:	ff 91       	pop	r31
     57e:	ef 91       	pop	r30
     580:	df 91       	pop	r29
     582:	cf 91       	pop	r28
     584:	bf 91       	pop	r27
     586:	af 91       	pop	r26
     588:	9f 91       	pop	r25
     58a:	8f 91       	pop	r24
     58c:	7f 91       	pop	r23
     58e:	6f 91       	pop	r22
     590:	5f 91       	pop	r21
     592:	4f 91       	pop	r20
     594:	3f 91       	pop	r19
     596:	2f 91       	pop	r18
     598:	1f 91       	pop	r17
     59a:	0f 91       	pop	r16
     59c:	ff 90       	pop	r15
     59e:	ef 90       	pop	r14
     5a0:	df 90       	pop	r13
     5a2:	cf 90       	pop	r12
     5a4:	bf 90       	pop	r11
     5a6:	af 90       	pop	r10
     5a8:	9f 90       	pop	r9
     5aa:	8f 90       	pop	r8
     5ac:	7f 90       	pop	r7
     5ae:	6f 90       	pop	r6
     5b0:	5f 90       	pop	r5
     5b2:	4f 90       	pop	r4
     5b4:	3f 90       	pop	r3
     5b6:	2f 90       	pop	r2
     5b8:	1f 90       	pop	r1
     5ba:	0f 90       	pop	r0
     5bc:	0f be       	out	0x3f, r0	; 63
     5be:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5c0:	08 95       	ret

000005c2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     5c2:	0f 92       	push	r0
     5c4:	0f b6       	in	r0, 0x3f	; 63
     5c6:	f8 94       	cli
     5c8:	0f 92       	push	r0
     5ca:	1f 92       	push	r1
     5cc:	11 24       	eor	r1, r1
     5ce:	2f 92       	push	r2
     5d0:	3f 92       	push	r3
     5d2:	4f 92       	push	r4
     5d4:	5f 92       	push	r5
     5d6:	6f 92       	push	r6
     5d8:	7f 92       	push	r7
     5da:	8f 92       	push	r8
     5dc:	9f 92       	push	r9
     5de:	af 92       	push	r10
     5e0:	bf 92       	push	r11
     5e2:	cf 92       	push	r12
     5e4:	df 92       	push	r13
     5e6:	ef 92       	push	r14
     5e8:	ff 92       	push	r15
     5ea:	0f 93       	push	r16
     5ec:	1f 93       	push	r17
     5ee:	2f 93       	push	r18
     5f0:	3f 93       	push	r19
     5f2:	4f 93       	push	r20
     5f4:	5f 93       	push	r21
     5f6:	6f 93       	push	r22
     5f8:	7f 93       	push	r23
     5fa:	8f 93       	push	r24
     5fc:	9f 93       	push	r25
     5fe:	af 93       	push	r26
     600:	bf 93       	push	r27
     602:	cf 93       	push	r28
     604:	df 93       	push	r29
     606:	ef 93       	push	r30
     608:	ff 93       	push	r31
     60a:	a0 91 a6 06 	lds	r26, 0x06A6
     60e:	b0 91 a7 06 	lds	r27, 0x06A7
     612:	0d b6       	in	r0, 0x3d	; 61
     614:	0d 92       	st	X+, r0
     616:	0e b6       	in	r0, 0x3e	; 62
     618:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     61a:	0e 94 1d 1d 	call	0x3a3a	; 0x3a3a <xTaskIncrementTick>
     61e:	88 23       	and	r24, r24
     620:	11 f0       	breq	.+4      	; 0x626 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     622:	0e 94 b4 1e 	call	0x3d68	; 0x3d68 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     626:	a0 91 a6 06 	lds	r26, 0x06A6
     62a:	b0 91 a7 06 	lds	r27, 0x06A7
     62e:	cd 91       	ld	r28, X+
     630:	cd bf       	out	0x3d, r28	; 61
     632:	dd 91       	ld	r29, X+
     634:	de bf       	out	0x3e, r29	; 62
     636:	ff 91       	pop	r31
     638:	ef 91       	pop	r30
     63a:	df 91       	pop	r29
     63c:	cf 91       	pop	r28
     63e:	bf 91       	pop	r27
     640:	af 91       	pop	r26
     642:	9f 91       	pop	r25
     644:	8f 91       	pop	r24
     646:	7f 91       	pop	r23
     648:	6f 91       	pop	r22
     64a:	5f 91       	pop	r21
     64c:	4f 91       	pop	r20
     64e:	3f 91       	pop	r19
     650:	2f 91       	pop	r18
     652:	1f 91       	pop	r17
     654:	0f 91       	pop	r16
     656:	ff 90       	pop	r15
     658:	ef 90       	pop	r14
     65a:	df 90       	pop	r13
     65c:	cf 90       	pop	r12
     65e:	bf 90       	pop	r11
     660:	af 90       	pop	r10
     662:	9f 90       	pop	r9
     664:	8f 90       	pop	r8
     666:	7f 90       	pop	r7
     668:	6f 90       	pop	r6
     66a:	5f 90       	pop	r5
     66c:	4f 90       	pop	r4
     66e:	3f 90       	pop	r3
     670:	2f 90       	pop	r2
     672:	1f 90       	pop	r1
     674:	0f 90       	pop	r0
     676:	0f be       	out	0x3f, r0	; 63
     678:	0f 90       	pop	r0

	asm volatile ( "ret" );
     67a:	08 95       	ret

0000067c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     67c:	df 93       	push	r29
     67e:	cf 93       	push	r28
     680:	00 d0       	rcall	.+0      	; 0x682 <prvSetupTimerInterrupt+0x6>
     682:	00 d0       	rcall	.+0      	; 0x684 <prvSetupTimerInterrupt+0x8>
     684:	00 d0       	rcall	.+0      	; 0x686 <prvSetupTimerInterrupt+0xa>
     686:	cd b7       	in	r28, 0x3d	; 61
     688:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     68a:	80 e4       	ldi	r24, 0x40	; 64
     68c:	9f e1       	ldi	r25, 0x1F	; 31
     68e:	a0 e0       	ldi	r26, 0x00	; 0
     690:	b0 e0       	ldi	r27, 0x00	; 0
     692:	8b 83       	std	Y+3, r24	; 0x03
     694:	9c 83       	std	Y+4, r25	; 0x04
     696:	ad 83       	std	Y+5, r26	; 0x05
     698:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     69a:	8b 81       	ldd	r24, Y+3	; 0x03
     69c:	9c 81       	ldd	r25, Y+4	; 0x04
     69e:	ad 81       	ldd	r26, Y+5	; 0x05
     6a0:	be 81       	ldd	r27, Y+6	; 0x06
     6a2:	68 94       	set
     6a4:	15 f8       	bld	r1, 5
     6a6:	b6 95       	lsr	r27
     6a8:	a7 95       	ror	r26
     6aa:	97 95       	ror	r25
     6ac:	87 95       	ror	r24
     6ae:	16 94       	lsr	r1
     6b0:	d1 f7       	brne	.-12     	; 0x6a6 <prvSetupTimerInterrupt+0x2a>
     6b2:	8b 83       	std	Y+3, r24	; 0x03
     6b4:	9c 83       	std	Y+4, r25	; 0x04
     6b6:	ad 83       	std	Y+5, r26	; 0x05
     6b8:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     6ba:	8b 81       	ldd	r24, Y+3	; 0x03
     6bc:	9c 81       	ldd	r25, Y+4	; 0x04
     6be:	ad 81       	ldd	r26, Y+5	; 0x05
     6c0:	be 81       	ldd	r27, Y+6	; 0x06
     6c2:	01 97       	sbiw	r24, 0x01	; 1
     6c4:	a1 09       	sbc	r26, r1
     6c6:	b1 09       	sbc	r27, r1
     6c8:	8b 83       	std	Y+3, r24	; 0x03
     6ca:	9c 83       	std	Y+4, r25	; 0x04
     6cc:	ad 83       	std	Y+5, r26	; 0x05
     6ce:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     6d0:	8b 81       	ldd	r24, Y+3	; 0x03
     6d2:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     6d4:	8b 81       	ldd	r24, Y+3	; 0x03
     6d6:	9c 81       	ldd	r25, Y+4	; 0x04
     6d8:	ad 81       	ldd	r26, Y+5	; 0x05
     6da:	be 81       	ldd	r27, Y+6	; 0x06
     6dc:	89 2f       	mov	r24, r25
     6de:	9a 2f       	mov	r25, r26
     6e0:	ab 2f       	mov	r26, r27
     6e2:	bb 27       	eor	r27, r27
     6e4:	8b 83       	std	Y+3, r24	; 0x03
     6e6:	9c 83       	std	Y+4, r25	; 0x04
     6e8:	ad 83       	std	Y+5, r26	; 0x05
     6ea:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     6ec:	8b 81       	ldd	r24, Y+3	; 0x03
     6ee:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     6f0:	eb e4       	ldi	r30, 0x4B	; 75
     6f2:	f0 e0       	ldi	r31, 0x00	; 0
     6f4:	8a 81       	ldd	r24, Y+2	; 0x02
     6f6:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     6f8:	ea e4       	ldi	r30, 0x4A	; 74
     6fa:	f0 e0       	ldi	r31, 0x00	; 0
     6fc:	89 81       	ldd	r24, Y+1	; 0x01
     6fe:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     700:	8b e0       	ldi	r24, 0x0B	; 11
     702:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     704:	ee e4       	ldi	r30, 0x4E	; 78
     706:	f0 e0       	ldi	r31, 0x00	; 0
     708:	89 81       	ldd	r24, Y+1	; 0x01
     70a:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     70c:	e9 e5       	ldi	r30, 0x59	; 89
     70e:	f0 e0       	ldi	r31, 0x00	; 0
     710:	80 81       	ld	r24, Z
     712:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     714:	89 81       	ldd	r24, Y+1	; 0x01
     716:	80 61       	ori	r24, 0x10	; 16
     718:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
     71a:	e9 e5       	ldi	r30, 0x59	; 89
     71c:	f0 e0       	ldi	r31, 0x00	; 0
     71e:	89 81       	ldd	r24, Y+1	; 0x01
     720:	80 83       	st	Z, r24
}
     722:	26 96       	adiw	r28, 0x06	; 6
     724:	0f b6       	in	r0, 0x3f	; 63
     726:	f8 94       	cli
     728:	de bf       	out	0x3e, r29	; 62
     72a:	0f be       	out	0x3f, r0	; 63
     72c:	cd bf       	out	0x3d, r28	; 61
     72e:	cf 91       	pop	r28
     730:	df 91       	pop	r29
     732:	08 95       	ret

00000734 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     734:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vPortYieldFromTick>
		asm volatile ( "reti" );
     738:	18 95       	reti

0000073a <DIO_SetPinDir>:


#include "DIO.h"

void DIO_SetPinDir(uint8_t port ,uint8_t pin, uint8_t dir)
{
     73a:	df 93       	push	r29
     73c:	cf 93       	push	r28
     73e:	cd b7       	in	r28, 0x3d	; 61
     740:	de b7       	in	r29, 0x3e	; 62
     742:	2d 97       	sbiw	r28, 0x0d	; 13
     744:	0f b6       	in	r0, 0x3f	; 63
     746:	f8 94       	cli
     748:	de bf       	out	0x3e, r29	; 62
     74a:	0f be       	out	0x3f, r0	; 63
     74c:	cd bf       	out	0x3d, r28	; 61
     74e:	89 83       	std	Y+1, r24	; 0x01
     750:	6a 83       	std	Y+2, r22	; 0x02
     752:	4b 83       	std	Y+3, r20	; 0x03
	switch (port)
     754:	89 81       	ldd	r24, Y+1	; 0x01
     756:	28 2f       	mov	r18, r24
     758:	30 e0       	ldi	r19, 0x00	; 0
     75a:	3d 87       	std	Y+13, r19	; 0x0d
     75c:	2c 87       	std	Y+12, r18	; 0x0c
     75e:	8c 85       	ldd	r24, Y+12	; 0x0c
     760:	9d 85       	ldd	r25, Y+13	; 0x0d
     762:	81 30       	cpi	r24, 0x01	; 1
     764:	91 05       	cpc	r25, r1
     766:	09 f4       	brne	.+2      	; 0x76a <DIO_SetPinDir+0x30>
     768:	44 c0       	rjmp	.+136    	; 0x7f2 <DIO_SetPinDir+0xb8>
     76a:	2c 85       	ldd	r18, Y+12	; 0x0c
     76c:	3d 85       	ldd	r19, Y+13	; 0x0d
     76e:	22 30       	cpi	r18, 0x02	; 2
     770:	31 05       	cpc	r19, r1
     772:	2c f4       	brge	.+10     	; 0x77e <DIO_SetPinDir+0x44>
     774:	8c 85       	ldd	r24, Y+12	; 0x0c
     776:	9d 85       	ldd	r25, Y+13	; 0x0d
     778:	00 97       	sbiw	r24, 0x00	; 0
     77a:	71 f0       	breq	.+28     	; 0x798 <DIO_SetPinDir+0x5e>
     77c:	c2 c0       	rjmp	.+388    	; 0x902 <__stack+0xa3>
     77e:	2c 85       	ldd	r18, Y+12	; 0x0c
     780:	3d 85       	ldd	r19, Y+13	; 0x0d
     782:	22 30       	cpi	r18, 0x02	; 2
     784:	31 05       	cpc	r19, r1
     786:	09 f4       	brne	.+2      	; 0x78a <DIO_SetPinDir+0x50>
     788:	62 c0       	rjmp	.+196    	; 0x84e <DIO_SetPinDir+0x114>
     78a:	8c 85       	ldd	r24, Y+12	; 0x0c
     78c:	9d 85       	ldd	r25, Y+13	; 0x0d
     78e:	83 30       	cpi	r24, 0x03	; 3
     790:	91 05       	cpc	r25, r1
     792:	09 f4       	brne	.+2      	; 0x796 <DIO_SetPinDir+0x5c>
     794:	89 c0       	rjmp	.+274    	; 0x8a8 <__stack+0x49>
     796:	b5 c0       	rjmp	.+362    	; 0x902 <__stack+0xa3>
	{
		case DIO_PORTA:
		(dir == OUTPUT)? (SET_BIT(DDRA,pin)):(CLR_BIT(DDRA,pin));
     798:	8b 81       	ldd	r24, Y+3	; 0x03
     79a:	83 30       	cpi	r24, 0x03	; 3
     79c:	a9 f4       	brne	.+42     	; 0x7c8 <DIO_SetPinDir+0x8e>
     79e:	aa e3       	ldi	r26, 0x3A	; 58
     7a0:	b0 e0       	ldi	r27, 0x00	; 0
     7a2:	ea e3       	ldi	r30, 0x3A	; 58
     7a4:	f0 e0       	ldi	r31, 0x00	; 0
     7a6:	80 81       	ld	r24, Z
     7a8:	48 2f       	mov	r20, r24
     7aa:	8a 81       	ldd	r24, Y+2	; 0x02
     7ac:	28 2f       	mov	r18, r24
     7ae:	30 e0       	ldi	r19, 0x00	; 0
     7b0:	81 e0       	ldi	r24, 0x01	; 1
     7b2:	90 e0       	ldi	r25, 0x00	; 0
     7b4:	02 2e       	mov	r0, r18
     7b6:	02 c0       	rjmp	.+4      	; 0x7bc <DIO_SetPinDir+0x82>
     7b8:	88 0f       	add	r24, r24
     7ba:	99 1f       	adc	r25, r25
     7bc:	0a 94       	dec	r0
     7be:	e2 f7       	brpl	.-8      	; 0x7b8 <DIO_SetPinDir+0x7e>
     7c0:	84 2b       	or	r24, r20
     7c2:	8c 93       	st	X, r24
     7c4:	9c 91       	ld	r25, X
     7c6:	9d c0       	rjmp	.+314    	; 0x902 <__stack+0xa3>
     7c8:	aa e3       	ldi	r26, 0x3A	; 58
     7ca:	b0 e0       	ldi	r27, 0x00	; 0
     7cc:	ea e3       	ldi	r30, 0x3A	; 58
     7ce:	f0 e0       	ldi	r31, 0x00	; 0
     7d0:	80 81       	ld	r24, Z
     7d2:	48 2f       	mov	r20, r24
     7d4:	8a 81       	ldd	r24, Y+2	; 0x02
     7d6:	28 2f       	mov	r18, r24
     7d8:	30 e0       	ldi	r19, 0x00	; 0
     7da:	81 e0       	ldi	r24, 0x01	; 1
     7dc:	90 e0       	ldi	r25, 0x00	; 0
     7de:	02 c0       	rjmp	.+4      	; 0x7e4 <DIO_SetPinDir+0xaa>
     7e0:	88 0f       	add	r24, r24
     7e2:	99 1f       	adc	r25, r25
     7e4:	2a 95       	dec	r18
     7e6:	e2 f7       	brpl	.-8      	; 0x7e0 <DIO_SetPinDir+0xa6>
     7e8:	80 95       	com	r24
     7ea:	84 23       	and	r24, r20
     7ec:	8c 93       	st	X, r24
     7ee:	2c 91       	ld	r18, X
     7f0:	88 c0       	rjmp	.+272    	; 0x902 <__stack+0xa3>
		break;

		case DIO_PORTB:
		(dir == OUTPUT)? (SET_BIT(DDRB,pin)):(CLR_BIT(DDRB,pin));
     7f2:	8b 81       	ldd	r24, Y+3	; 0x03
     7f4:	83 30       	cpi	r24, 0x03	; 3
     7f6:	a9 f4       	brne	.+42     	; 0x822 <DIO_SetPinDir+0xe8>
     7f8:	a7 e3       	ldi	r26, 0x37	; 55
     7fa:	b0 e0       	ldi	r27, 0x00	; 0
     7fc:	e7 e3       	ldi	r30, 0x37	; 55
     7fe:	f0 e0       	ldi	r31, 0x00	; 0
     800:	80 81       	ld	r24, Z
     802:	48 2f       	mov	r20, r24
     804:	8a 81       	ldd	r24, Y+2	; 0x02
     806:	28 2f       	mov	r18, r24
     808:	30 e0       	ldi	r19, 0x00	; 0
     80a:	81 e0       	ldi	r24, 0x01	; 1
     80c:	90 e0       	ldi	r25, 0x00	; 0
     80e:	02 2e       	mov	r0, r18
     810:	02 c0       	rjmp	.+4      	; 0x816 <DIO_SetPinDir+0xdc>
     812:	88 0f       	add	r24, r24
     814:	99 1f       	adc	r25, r25
     816:	0a 94       	dec	r0
     818:	e2 f7       	brpl	.-8      	; 0x812 <DIO_SetPinDir+0xd8>
     81a:	84 2b       	or	r24, r20
     81c:	8c 93       	st	X, r24
     81e:	3c 91       	ld	r19, X
     820:	70 c0       	rjmp	.+224    	; 0x902 <__stack+0xa3>
     822:	a7 e3       	ldi	r26, 0x37	; 55
     824:	b0 e0       	ldi	r27, 0x00	; 0
     826:	e7 e3       	ldi	r30, 0x37	; 55
     828:	f0 e0       	ldi	r31, 0x00	; 0
     82a:	80 81       	ld	r24, Z
     82c:	48 2f       	mov	r20, r24
     82e:	8a 81       	ldd	r24, Y+2	; 0x02
     830:	28 2f       	mov	r18, r24
     832:	30 e0       	ldi	r19, 0x00	; 0
     834:	81 e0       	ldi	r24, 0x01	; 1
     836:	90 e0       	ldi	r25, 0x00	; 0
     838:	02 2e       	mov	r0, r18
     83a:	02 c0       	rjmp	.+4      	; 0x840 <DIO_SetPinDir+0x106>
     83c:	88 0f       	add	r24, r24
     83e:	99 1f       	adc	r25, r25
     840:	0a 94       	dec	r0
     842:	e2 f7       	brpl	.-8      	; 0x83c <DIO_SetPinDir+0x102>
     844:	80 95       	com	r24
     846:	84 23       	and	r24, r20
     848:	8c 93       	st	X, r24
     84a:	8c 91       	ld	r24, X
     84c:	5a c0       	rjmp	.+180    	; 0x902 <__stack+0xa3>
		break;

		case DIO_PORTC:
		(dir == OUTPUT)? (SET_BIT(DDRC,pin)):(CLR_BIT(DDRC,pin));
     84e:	8b 81       	ldd	r24, Y+3	; 0x03
     850:	83 30       	cpi	r24, 0x03	; 3
     852:	a9 f4       	brne	.+42     	; 0x87e <__stack+0x1f>
     854:	a4 e3       	ldi	r26, 0x34	; 52
     856:	b0 e0       	ldi	r27, 0x00	; 0
     858:	e4 e3       	ldi	r30, 0x34	; 52
     85a:	f0 e0       	ldi	r31, 0x00	; 0
     85c:	80 81       	ld	r24, Z
     85e:	48 2f       	mov	r20, r24
     860:	8a 81       	ldd	r24, Y+2	; 0x02
     862:	28 2f       	mov	r18, r24
     864:	30 e0       	ldi	r19, 0x00	; 0
     866:	81 e0       	ldi	r24, 0x01	; 1
     868:	90 e0       	ldi	r25, 0x00	; 0
     86a:	02 2e       	mov	r0, r18
     86c:	02 c0       	rjmp	.+4      	; 0x872 <__stack+0x13>
     86e:	88 0f       	add	r24, r24
     870:	99 1f       	adc	r25, r25
     872:	0a 94       	dec	r0
     874:	e2 f7       	brpl	.-8      	; 0x86e <__stack+0xf>
     876:	84 2b       	or	r24, r20
     878:	8c 93       	st	X, r24
     87a:	9c 91       	ld	r25, X
     87c:	42 c0       	rjmp	.+132    	; 0x902 <__stack+0xa3>
     87e:	a4 e3       	ldi	r26, 0x34	; 52
     880:	b0 e0       	ldi	r27, 0x00	; 0
     882:	e4 e3       	ldi	r30, 0x34	; 52
     884:	f0 e0       	ldi	r31, 0x00	; 0
     886:	80 81       	ld	r24, Z
     888:	48 2f       	mov	r20, r24
     88a:	8a 81       	ldd	r24, Y+2	; 0x02
     88c:	28 2f       	mov	r18, r24
     88e:	30 e0       	ldi	r19, 0x00	; 0
     890:	81 e0       	ldi	r24, 0x01	; 1
     892:	90 e0       	ldi	r25, 0x00	; 0
     894:	02 c0       	rjmp	.+4      	; 0x89a <__stack+0x3b>
     896:	88 0f       	add	r24, r24
     898:	99 1f       	adc	r25, r25
     89a:	2a 95       	dec	r18
     89c:	e2 f7       	brpl	.-8      	; 0x896 <__stack+0x37>
     89e:	80 95       	com	r24
     8a0:	84 23       	and	r24, r20
     8a2:	8c 93       	st	X, r24
     8a4:	2c 91       	ld	r18, X
     8a6:	2d c0       	rjmp	.+90     	; 0x902 <__stack+0xa3>
		break;

		case DIO_PORTD:
		(dir == OUTPUT)? (SET_BIT(DDRD,pin)):(CLR_BIT(DDRD,pin));
     8a8:	8b 81       	ldd	r24, Y+3	; 0x03
     8aa:	83 30       	cpi	r24, 0x03	; 3
     8ac:	a9 f4       	brne	.+42     	; 0x8d8 <__stack+0x79>
     8ae:	a1 e3       	ldi	r26, 0x31	; 49
     8b0:	b0 e0       	ldi	r27, 0x00	; 0
     8b2:	e1 e3       	ldi	r30, 0x31	; 49
     8b4:	f0 e0       	ldi	r31, 0x00	; 0
     8b6:	80 81       	ld	r24, Z
     8b8:	48 2f       	mov	r20, r24
     8ba:	8a 81       	ldd	r24, Y+2	; 0x02
     8bc:	28 2f       	mov	r18, r24
     8be:	30 e0       	ldi	r19, 0x00	; 0
     8c0:	81 e0       	ldi	r24, 0x01	; 1
     8c2:	90 e0       	ldi	r25, 0x00	; 0
     8c4:	02 2e       	mov	r0, r18
     8c6:	02 c0       	rjmp	.+4      	; 0x8cc <__stack+0x6d>
     8c8:	88 0f       	add	r24, r24
     8ca:	99 1f       	adc	r25, r25
     8cc:	0a 94       	dec	r0
     8ce:	e2 f7       	brpl	.-8      	; 0x8c8 <__stack+0x69>
     8d0:	84 2b       	or	r24, r20
     8d2:	8c 93       	st	X, r24
     8d4:	3c 91       	ld	r19, X
     8d6:	15 c0       	rjmp	.+42     	; 0x902 <__stack+0xa3>
     8d8:	a1 e3       	ldi	r26, 0x31	; 49
     8da:	b0 e0       	ldi	r27, 0x00	; 0
     8dc:	e1 e3       	ldi	r30, 0x31	; 49
     8de:	f0 e0       	ldi	r31, 0x00	; 0
     8e0:	80 81       	ld	r24, Z
     8e2:	48 2f       	mov	r20, r24
     8e4:	8a 81       	ldd	r24, Y+2	; 0x02
     8e6:	28 2f       	mov	r18, r24
     8e8:	30 e0       	ldi	r19, 0x00	; 0
     8ea:	81 e0       	ldi	r24, 0x01	; 1
     8ec:	90 e0       	ldi	r25, 0x00	; 0
     8ee:	02 2e       	mov	r0, r18
     8f0:	02 c0       	rjmp	.+4      	; 0x8f6 <__stack+0x97>
     8f2:	88 0f       	add	r24, r24
     8f4:	99 1f       	adc	r25, r25
     8f6:	0a 94       	dec	r0
     8f8:	e2 f7       	brpl	.-8      	; 0x8f2 <__stack+0x93>
     8fa:	80 95       	com	r24
     8fc:	84 23       	and	r24, r20
     8fe:	8c 93       	st	X, r24
     900:	8c 91       	ld	r24, X
		break;
	}
}
     902:	2d 96       	adiw	r28, 0x0d	; 13
     904:	0f b6       	in	r0, 0x3f	; 63
     906:	f8 94       	cli
     908:	de bf       	out	0x3e, r29	; 62
     90a:	0f be       	out	0x3f, r0	; 63
     90c:	cd bf       	out	0x3d, r28	; 61
     90e:	cf 91       	pop	r28
     910:	df 91       	pop	r29
     912:	08 95       	ret

00000914 <DIO_SetPinVal>:


void DIO_SetPinVal(uint8_t port ,uint8_t pin , uint8_t val)
{
     914:	df 93       	push	r29
     916:	cf 93       	push	r28
     918:	cd b7       	in	r28, 0x3d	; 61
     91a:	de b7       	in	r29, 0x3e	; 62
     91c:	2d 97       	sbiw	r28, 0x0d	; 13
     91e:	0f b6       	in	r0, 0x3f	; 63
     920:	f8 94       	cli
     922:	de bf       	out	0x3e, r29	; 62
     924:	0f be       	out	0x3f, r0	; 63
     926:	cd bf       	out	0x3d, r28	; 61
     928:	89 83       	std	Y+1, r24	; 0x01
     92a:	6a 83       	std	Y+2, r22	; 0x02
     92c:	4b 83       	std	Y+3, r20	; 0x03
	switch (port)
     92e:	89 81       	ldd	r24, Y+1	; 0x01
     930:	28 2f       	mov	r18, r24
     932:	30 e0       	ldi	r19, 0x00	; 0
     934:	3d 87       	std	Y+13, r19	; 0x0d
     936:	2c 87       	std	Y+12, r18	; 0x0c
     938:	8c 85       	ldd	r24, Y+12	; 0x0c
     93a:	9d 85       	ldd	r25, Y+13	; 0x0d
     93c:	81 30       	cpi	r24, 0x01	; 1
     93e:	91 05       	cpc	r25, r1
     940:	09 f4       	brne	.+2      	; 0x944 <DIO_SetPinVal+0x30>
     942:	44 c0       	rjmp	.+136    	; 0x9cc <DIO_SetPinVal+0xb8>
     944:	2c 85       	ldd	r18, Y+12	; 0x0c
     946:	3d 85       	ldd	r19, Y+13	; 0x0d
     948:	22 30       	cpi	r18, 0x02	; 2
     94a:	31 05       	cpc	r19, r1
     94c:	2c f4       	brge	.+10     	; 0x958 <DIO_SetPinVal+0x44>
     94e:	8c 85       	ldd	r24, Y+12	; 0x0c
     950:	9d 85       	ldd	r25, Y+13	; 0x0d
     952:	00 97       	sbiw	r24, 0x00	; 0
     954:	71 f0       	breq	.+28     	; 0x972 <DIO_SetPinVal+0x5e>
     956:	c2 c0       	rjmp	.+388    	; 0xadc <DIO_SetPinVal+0x1c8>
     958:	2c 85       	ldd	r18, Y+12	; 0x0c
     95a:	3d 85       	ldd	r19, Y+13	; 0x0d
     95c:	22 30       	cpi	r18, 0x02	; 2
     95e:	31 05       	cpc	r19, r1
     960:	09 f4       	brne	.+2      	; 0x964 <DIO_SetPinVal+0x50>
     962:	62 c0       	rjmp	.+196    	; 0xa28 <DIO_SetPinVal+0x114>
     964:	8c 85       	ldd	r24, Y+12	; 0x0c
     966:	9d 85       	ldd	r25, Y+13	; 0x0d
     968:	83 30       	cpi	r24, 0x03	; 3
     96a:	91 05       	cpc	r25, r1
     96c:	09 f4       	brne	.+2      	; 0x970 <DIO_SetPinVal+0x5c>
     96e:	89 c0       	rjmp	.+274    	; 0xa82 <DIO_SetPinVal+0x16e>
     970:	b5 c0       	rjmp	.+362    	; 0xadc <DIO_SetPinVal+0x1c8>
	{
		case DIO_PORTA:
		(val == HIGH)? (SET_BIT(PORTA,pin)):(CLR_BIT(PORTA,pin));
     972:	8b 81       	ldd	r24, Y+3	; 0x03
     974:	81 30       	cpi	r24, 0x01	; 1
     976:	a9 f4       	brne	.+42     	; 0x9a2 <DIO_SetPinVal+0x8e>
     978:	ab e3       	ldi	r26, 0x3B	; 59
     97a:	b0 e0       	ldi	r27, 0x00	; 0
     97c:	eb e3       	ldi	r30, 0x3B	; 59
     97e:	f0 e0       	ldi	r31, 0x00	; 0
     980:	80 81       	ld	r24, Z
     982:	48 2f       	mov	r20, r24
     984:	8a 81       	ldd	r24, Y+2	; 0x02
     986:	28 2f       	mov	r18, r24
     988:	30 e0       	ldi	r19, 0x00	; 0
     98a:	81 e0       	ldi	r24, 0x01	; 1
     98c:	90 e0       	ldi	r25, 0x00	; 0
     98e:	02 2e       	mov	r0, r18
     990:	02 c0       	rjmp	.+4      	; 0x996 <DIO_SetPinVal+0x82>
     992:	88 0f       	add	r24, r24
     994:	99 1f       	adc	r25, r25
     996:	0a 94       	dec	r0
     998:	e2 f7       	brpl	.-8      	; 0x992 <DIO_SetPinVal+0x7e>
     99a:	84 2b       	or	r24, r20
     99c:	8c 93       	st	X, r24
     99e:	9c 91       	ld	r25, X
     9a0:	9d c0       	rjmp	.+314    	; 0xadc <DIO_SetPinVal+0x1c8>
     9a2:	ab e3       	ldi	r26, 0x3B	; 59
     9a4:	b0 e0       	ldi	r27, 0x00	; 0
     9a6:	eb e3       	ldi	r30, 0x3B	; 59
     9a8:	f0 e0       	ldi	r31, 0x00	; 0
     9aa:	80 81       	ld	r24, Z
     9ac:	48 2f       	mov	r20, r24
     9ae:	8a 81       	ldd	r24, Y+2	; 0x02
     9b0:	28 2f       	mov	r18, r24
     9b2:	30 e0       	ldi	r19, 0x00	; 0
     9b4:	81 e0       	ldi	r24, 0x01	; 1
     9b6:	90 e0       	ldi	r25, 0x00	; 0
     9b8:	02 c0       	rjmp	.+4      	; 0x9be <DIO_SetPinVal+0xaa>
     9ba:	88 0f       	add	r24, r24
     9bc:	99 1f       	adc	r25, r25
     9be:	2a 95       	dec	r18
     9c0:	e2 f7       	brpl	.-8      	; 0x9ba <DIO_SetPinVal+0xa6>
     9c2:	80 95       	com	r24
     9c4:	84 23       	and	r24, r20
     9c6:	8c 93       	st	X, r24
     9c8:	2c 91       	ld	r18, X
     9ca:	88 c0       	rjmp	.+272    	; 0xadc <DIO_SetPinVal+0x1c8>
		break;

		case DIO_PORTB:
		(val == HIGH)? (SET_BIT(PORTB,pin)):(CLR_BIT(PORTB,pin));
     9cc:	8b 81       	ldd	r24, Y+3	; 0x03
     9ce:	81 30       	cpi	r24, 0x01	; 1
     9d0:	a9 f4       	brne	.+42     	; 0x9fc <DIO_SetPinVal+0xe8>
     9d2:	a8 e3       	ldi	r26, 0x38	; 56
     9d4:	b0 e0       	ldi	r27, 0x00	; 0
     9d6:	e8 e3       	ldi	r30, 0x38	; 56
     9d8:	f0 e0       	ldi	r31, 0x00	; 0
     9da:	80 81       	ld	r24, Z
     9dc:	48 2f       	mov	r20, r24
     9de:	8a 81       	ldd	r24, Y+2	; 0x02
     9e0:	28 2f       	mov	r18, r24
     9e2:	30 e0       	ldi	r19, 0x00	; 0
     9e4:	81 e0       	ldi	r24, 0x01	; 1
     9e6:	90 e0       	ldi	r25, 0x00	; 0
     9e8:	02 2e       	mov	r0, r18
     9ea:	02 c0       	rjmp	.+4      	; 0x9f0 <DIO_SetPinVal+0xdc>
     9ec:	88 0f       	add	r24, r24
     9ee:	99 1f       	adc	r25, r25
     9f0:	0a 94       	dec	r0
     9f2:	e2 f7       	brpl	.-8      	; 0x9ec <DIO_SetPinVal+0xd8>
     9f4:	84 2b       	or	r24, r20
     9f6:	8c 93       	st	X, r24
     9f8:	3c 91       	ld	r19, X
     9fa:	70 c0       	rjmp	.+224    	; 0xadc <DIO_SetPinVal+0x1c8>
     9fc:	a8 e3       	ldi	r26, 0x38	; 56
     9fe:	b0 e0       	ldi	r27, 0x00	; 0
     a00:	e8 e3       	ldi	r30, 0x38	; 56
     a02:	f0 e0       	ldi	r31, 0x00	; 0
     a04:	80 81       	ld	r24, Z
     a06:	48 2f       	mov	r20, r24
     a08:	8a 81       	ldd	r24, Y+2	; 0x02
     a0a:	28 2f       	mov	r18, r24
     a0c:	30 e0       	ldi	r19, 0x00	; 0
     a0e:	81 e0       	ldi	r24, 0x01	; 1
     a10:	90 e0       	ldi	r25, 0x00	; 0
     a12:	02 2e       	mov	r0, r18
     a14:	02 c0       	rjmp	.+4      	; 0xa1a <DIO_SetPinVal+0x106>
     a16:	88 0f       	add	r24, r24
     a18:	99 1f       	adc	r25, r25
     a1a:	0a 94       	dec	r0
     a1c:	e2 f7       	brpl	.-8      	; 0xa16 <DIO_SetPinVal+0x102>
     a1e:	80 95       	com	r24
     a20:	84 23       	and	r24, r20
     a22:	8c 93       	st	X, r24
     a24:	8c 91       	ld	r24, X
     a26:	5a c0       	rjmp	.+180    	; 0xadc <DIO_SetPinVal+0x1c8>
		break;

		case DIO_PORTC:
		(val == HIGH)? (SET_BIT(PORTC,pin)):(CLR_BIT(PORTC,pin));
     a28:	8b 81       	ldd	r24, Y+3	; 0x03
     a2a:	81 30       	cpi	r24, 0x01	; 1
     a2c:	a9 f4       	brne	.+42     	; 0xa58 <DIO_SetPinVal+0x144>
     a2e:	a5 e3       	ldi	r26, 0x35	; 53
     a30:	b0 e0       	ldi	r27, 0x00	; 0
     a32:	e5 e3       	ldi	r30, 0x35	; 53
     a34:	f0 e0       	ldi	r31, 0x00	; 0
     a36:	80 81       	ld	r24, Z
     a38:	48 2f       	mov	r20, r24
     a3a:	8a 81       	ldd	r24, Y+2	; 0x02
     a3c:	28 2f       	mov	r18, r24
     a3e:	30 e0       	ldi	r19, 0x00	; 0
     a40:	81 e0       	ldi	r24, 0x01	; 1
     a42:	90 e0       	ldi	r25, 0x00	; 0
     a44:	02 2e       	mov	r0, r18
     a46:	02 c0       	rjmp	.+4      	; 0xa4c <DIO_SetPinVal+0x138>
     a48:	88 0f       	add	r24, r24
     a4a:	99 1f       	adc	r25, r25
     a4c:	0a 94       	dec	r0
     a4e:	e2 f7       	brpl	.-8      	; 0xa48 <DIO_SetPinVal+0x134>
     a50:	84 2b       	or	r24, r20
     a52:	8c 93       	st	X, r24
     a54:	9c 91       	ld	r25, X
     a56:	42 c0       	rjmp	.+132    	; 0xadc <DIO_SetPinVal+0x1c8>
     a58:	a5 e3       	ldi	r26, 0x35	; 53
     a5a:	b0 e0       	ldi	r27, 0x00	; 0
     a5c:	e5 e3       	ldi	r30, 0x35	; 53
     a5e:	f0 e0       	ldi	r31, 0x00	; 0
     a60:	80 81       	ld	r24, Z
     a62:	48 2f       	mov	r20, r24
     a64:	8a 81       	ldd	r24, Y+2	; 0x02
     a66:	28 2f       	mov	r18, r24
     a68:	30 e0       	ldi	r19, 0x00	; 0
     a6a:	81 e0       	ldi	r24, 0x01	; 1
     a6c:	90 e0       	ldi	r25, 0x00	; 0
     a6e:	02 c0       	rjmp	.+4      	; 0xa74 <DIO_SetPinVal+0x160>
     a70:	88 0f       	add	r24, r24
     a72:	99 1f       	adc	r25, r25
     a74:	2a 95       	dec	r18
     a76:	e2 f7       	brpl	.-8      	; 0xa70 <DIO_SetPinVal+0x15c>
     a78:	80 95       	com	r24
     a7a:	84 23       	and	r24, r20
     a7c:	8c 93       	st	X, r24
     a7e:	2c 91       	ld	r18, X
     a80:	2d c0       	rjmp	.+90     	; 0xadc <DIO_SetPinVal+0x1c8>
		break;

		case DIO_PORTD:
		(val == HIGH)? (SET_BIT(PORTD,pin)):(CLR_BIT(PORTD,pin));
     a82:	8b 81       	ldd	r24, Y+3	; 0x03
     a84:	81 30       	cpi	r24, 0x01	; 1
     a86:	a9 f4       	brne	.+42     	; 0xab2 <DIO_SetPinVal+0x19e>
     a88:	a2 e3       	ldi	r26, 0x32	; 50
     a8a:	b0 e0       	ldi	r27, 0x00	; 0
     a8c:	e2 e3       	ldi	r30, 0x32	; 50
     a8e:	f0 e0       	ldi	r31, 0x00	; 0
     a90:	80 81       	ld	r24, Z
     a92:	48 2f       	mov	r20, r24
     a94:	8a 81       	ldd	r24, Y+2	; 0x02
     a96:	28 2f       	mov	r18, r24
     a98:	30 e0       	ldi	r19, 0x00	; 0
     a9a:	81 e0       	ldi	r24, 0x01	; 1
     a9c:	90 e0       	ldi	r25, 0x00	; 0
     a9e:	02 2e       	mov	r0, r18
     aa0:	02 c0       	rjmp	.+4      	; 0xaa6 <DIO_SetPinVal+0x192>
     aa2:	88 0f       	add	r24, r24
     aa4:	99 1f       	adc	r25, r25
     aa6:	0a 94       	dec	r0
     aa8:	e2 f7       	brpl	.-8      	; 0xaa2 <DIO_SetPinVal+0x18e>
     aaa:	84 2b       	or	r24, r20
     aac:	8c 93       	st	X, r24
     aae:	3c 91       	ld	r19, X
     ab0:	15 c0       	rjmp	.+42     	; 0xadc <DIO_SetPinVal+0x1c8>
     ab2:	a2 e3       	ldi	r26, 0x32	; 50
     ab4:	b0 e0       	ldi	r27, 0x00	; 0
     ab6:	e2 e3       	ldi	r30, 0x32	; 50
     ab8:	f0 e0       	ldi	r31, 0x00	; 0
     aba:	80 81       	ld	r24, Z
     abc:	48 2f       	mov	r20, r24
     abe:	8a 81       	ldd	r24, Y+2	; 0x02
     ac0:	28 2f       	mov	r18, r24
     ac2:	30 e0       	ldi	r19, 0x00	; 0
     ac4:	81 e0       	ldi	r24, 0x01	; 1
     ac6:	90 e0       	ldi	r25, 0x00	; 0
     ac8:	02 2e       	mov	r0, r18
     aca:	02 c0       	rjmp	.+4      	; 0xad0 <DIO_SetPinVal+0x1bc>
     acc:	88 0f       	add	r24, r24
     ace:	99 1f       	adc	r25, r25
     ad0:	0a 94       	dec	r0
     ad2:	e2 f7       	brpl	.-8      	; 0xacc <DIO_SetPinVal+0x1b8>
     ad4:	80 95       	com	r24
     ad6:	84 23       	and	r24, r20
     ad8:	8c 93       	st	X, r24
     ada:	8c 91       	ld	r24, X
		break;
	}
}
     adc:	2d 96       	adiw	r28, 0x0d	; 13
     ade:	0f b6       	in	r0, 0x3f	; 63
     ae0:	f8 94       	cli
     ae2:	de bf       	out	0x3e, r29	; 62
     ae4:	0f be       	out	0x3f, r0	; 63
     ae6:	cd bf       	out	0x3d, r28	; 61
     ae8:	cf 91       	pop	r28
     aea:	df 91       	pop	r29
     aec:	08 95       	ret

00000aee <DIO_GetPinVal>:


uint8_t  DIO_GetPinVal(uint8_t port ,uint8_t pin)
{
     aee:	df 93       	push	r29
     af0:	cf 93       	push	r28
     af2:	00 d0       	rcall	.+0      	; 0xaf4 <DIO_GetPinVal+0x6>
     af4:	00 d0       	rcall	.+0      	; 0xaf6 <DIO_GetPinVal+0x8>
     af6:	00 d0       	rcall	.+0      	; 0xaf8 <DIO_GetPinVal+0xa>
     af8:	cd b7       	in	r28, 0x3d	; 61
     afa:	de b7       	in	r29, 0x3e	; 62
     afc:	89 83       	std	Y+1, r24	; 0x01
     afe:	6a 83       	std	Y+2, r22	; 0x02
	switch(port)
     b00:	89 81       	ldd	r24, Y+1	; 0x01
     b02:	28 2f       	mov	r18, r24
     b04:	30 e0       	ldi	r19, 0x00	; 0
     b06:	3d 83       	std	Y+5, r19	; 0x05
     b08:	2c 83       	std	Y+4, r18	; 0x04
     b0a:	4c 81       	ldd	r20, Y+4	; 0x04
     b0c:	5d 81       	ldd	r21, Y+5	; 0x05
     b0e:	41 30       	cpi	r20, 0x01	; 1
     b10:	51 05       	cpc	r21, r1
     b12:	49 f1       	breq	.+82     	; 0xb66 <DIO_GetPinVal+0x78>
     b14:	8c 81       	ldd	r24, Y+4	; 0x04
     b16:	9d 81       	ldd	r25, Y+5	; 0x05
     b18:	82 30       	cpi	r24, 0x02	; 2
     b1a:	91 05       	cpc	r25, r1
     b1c:	34 f4       	brge	.+12     	; 0xb2a <DIO_GetPinVal+0x3c>
     b1e:	2c 81       	ldd	r18, Y+4	; 0x04
     b20:	3d 81       	ldd	r19, Y+5	; 0x05
     b22:	21 15       	cp	r18, r1
     b24:	31 05       	cpc	r19, r1
     b26:	61 f0       	breq	.+24     	; 0xb40 <DIO_GetPinVal+0x52>
     b28:	57 c0       	rjmp	.+174    	; 0xbd8 <DIO_GetPinVal+0xea>
     b2a:	4c 81       	ldd	r20, Y+4	; 0x04
     b2c:	5d 81       	ldd	r21, Y+5	; 0x05
     b2e:	42 30       	cpi	r20, 0x02	; 2
     b30:	51 05       	cpc	r21, r1
     b32:	61 f1       	breq	.+88     	; 0xb8c <DIO_GetPinVal+0x9e>
     b34:	8c 81       	ldd	r24, Y+4	; 0x04
     b36:	9d 81       	ldd	r25, Y+5	; 0x05
     b38:	83 30       	cpi	r24, 0x03	; 3
     b3a:	91 05       	cpc	r25, r1
     b3c:	d1 f1       	breq	.+116    	; 0xbb2 <DIO_GetPinVal+0xc4>
     b3e:	4c c0       	rjmp	.+152    	; 0xbd8 <DIO_GetPinVal+0xea>
	{
		case  DIO_PORTA :
			return GET_BIT(PINA,pin);
     b40:	e9 e3       	ldi	r30, 0x39	; 57
     b42:	f0 e0       	ldi	r31, 0x00	; 0
     b44:	80 81       	ld	r24, Z
     b46:	28 2f       	mov	r18, r24
     b48:	30 e0       	ldi	r19, 0x00	; 0
     b4a:	8a 81       	ldd	r24, Y+2	; 0x02
     b4c:	88 2f       	mov	r24, r24
     b4e:	90 e0       	ldi	r25, 0x00	; 0
     b50:	a9 01       	movw	r20, r18
     b52:	02 c0       	rjmp	.+4      	; 0xb58 <DIO_GetPinVal+0x6a>
     b54:	55 95       	asr	r21
     b56:	47 95       	ror	r20
     b58:	8a 95       	dec	r24
     b5a:	e2 f7       	brpl	.-8      	; 0xb54 <DIO_GetPinVal+0x66>
     b5c:	ca 01       	movw	r24, r20
     b5e:	58 2f       	mov	r21, r24
     b60:	51 70       	andi	r21, 0x01	; 1
     b62:	5b 83       	std	Y+3, r21	; 0x03
     b64:	3a c0       	rjmp	.+116    	; 0xbda <DIO_GetPinVal+0xec>
			break;
		case  DIO_PORTB :
			return GET_BIT(PINB,pin);
     b66:	e6 e3       	ldi	r30, 0x36	; 54
     b68:	f0 e0       	ldi	r31, 0x00	; 0
     b6a:	80 81       	ld	r24, Z
     b6c:	28 2f       	mov	r18, r24
     b6e:	30 e0       	ldi	r19, 0x00	; 0
     b70:	8a 81       	ldd	r24, Y+2	; 0x02
     b72:	88 2f       	mov	r24, r24
     b74:	90 e0       	ldi	r25, 0x00	; 0
     b76:	a9 01       	movw	r20, r18
     b78:	02 c0       	rjmp	.+4      	; 0xb7e <DIO_GetPinVal+0x90>
     b7a:	55 95       	asr	r21
     b7c:	47 95       	ror	r20
     b7e:	8a 95       	dec	r24
     b80:	e2 f7       	brpl	.-8      	; 0xb7a <DIO_GetPinVal+0x8c>
     b82:	ca 01       	movw	r24, r20
     b84:	58 2f       	mov	r21, r24
     b86:	51 70       	andi	r21, 0x01	; 1
     b88:	5b 83       	std	Y+3, r21	; 0x03
     b8a:	27 c0       	rjmp	.+78     	; 0xbda <DIO_GetPinVal+0xec>
			break;
		case  DIO_PORTC :
			return GET_BIT(PINC,pin);
     b8c:	e3 e3       	ldi	r30, 0x33	; 51
     b8e:	f0 e0       	ldi	r31, 0x00	; 0
     b90:	80 81       	ld	r24, Z
     b92:	28 2f       	mov	r18, r24
     b94:	30 e0       	ldi	r19, 0x00	; 0
     b96:	8a 81       	ldd	r24, Y+2	; 0x02
     b98:	88 2f       	mov	r24, r24
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	a9 01       	movw	r20, r18
     b9e:	02 c0       	rjmp	.+4      	; 0xba4 <DIO_GetPinVal+0xb6>
     ba0:	55 95       	asr	r21
     ba2:	47 95       	ror	r20
     ba4:	8a 95       	dec	r24
     ba6:	e2 f7       	brpl	.-8      	; 0xba0 <DIO_GetPinVal+0xb2>
     ba8:	ca 01       	movw	r24, r20
     baa:	58 2f       	mov	r21, r24
     bac:	51 70       	andi	r21, 0x01	; 1
     bae:	5b 83       	std	Y+3, r21	; 0x03
     bb0:	14 c0       	rjmp	.+40     	; 0xbda <DIO_GetPinVal+0xec>
			break;
		case  DIO_PORTD :
			return GET_BIT(PIND,pin);
     bb2:	e0 e3       	ldi	r30, 0x30	; 48
     bb4:	f0 e0       	ldi	r31, 0x00	; 0
     bb6:	80 81       	ld	r24, Z
     bb8:	28 2f       	mov	r18, r24
     bba:	30 e0       	ldi	r19, 0x00	; 0
     bbc:	8a 81       	ldd	r24, Y+2	; 0x02
     bbe:	88 2f       	mov	r24, r24
     bc0:	90 e0       	ldi	r25, 0x00	; 0
     bc2:	a9 01       	movw	r20, r18
     bc4:	02 c0       	rjmp	.+4      	; 0xbca <DIO_GetPinVal+0xdc>
     bc6:	55 95       	asr	r21
     bc8:	47 95       	ror	r20
     bca:	8a 95       	dec	r24
     bcc:	e2 f7       	brpl	.-8      	; 0xbc6 <DIO_GetPinVal+0xd8>
     bce:	ca 01       	movw	r24, r20
     bd0:	58 2f       	mov	r21, r24
     bd2:	51 70       	andi	r21, 0x01	; 1
     bd4:	5b 83       	std	Y+3, r21	; 0x03
     bd6:	01 c0       	rjmp	.+2      	; 0xbda <DIO_GetPinVal+0xec>
     bd8:	02 c0       	rjmp	.+4      	; 0xbde <DIO_GetPinVal+0xf0>
			break;
	}
}
     bda:	8b 81       	ldd	r24, Y+3	; 0x03
     bdc:	8e 83       	std	Y+6, r24	; 0x06
     bde:	8e 81       	ldd	r24, Y+6	; 0x06
     be0:	26 96       	adiw	r28, 0x06	; 6
     be2:	0f b6       	in	r0, 0x3f	; 63
     be4:	f8 94       	cli
     be6:	de bf       	out	0x3e, r29	; 62
     be8:	0f be       	out	0x3f, r0	; 63
     bea:	cd bf       	out	0x3d, r28	; 61
     bec:	cf 91       	pop	r28
     bee:	df 91       	pop	r29
     bf0:	08 95       	ret

00000bf2 <DIO_TogPinVal>:


void  DIO_TogPinVal(uint8_t port ,uint8_t pin)
{
     bf2:	df 93       	push	r29
     bf4:	cf 93       	push	r28
     bf6:	00 d0       	rcall	.+0      	; 0xbf8 <DIO_TogPinVal+0x6>
     bf8:	00 d0       	rcall	.+0      	; 0xbfa <DIO_TogPinVal+0x8>
     bfa:	cd b7       	in	r28, 0x3d	; 61
     bfc:	de b7       	in	r29, 0x3e	; 62
     bfe:	89 83       	std	Y+1, r24	; 0x01
     c00:	6a 83       	std	Y+2, r22	; 0x02
	switch(port)
     c02:	89 81       	ldd	r24, Y+1	; 0x01
     c04:	28 2f       	mov	r18, r24
     c06:	30 e0       	ldi	r19, 0x00	; 0
     c08:	3c 83       	std	Y+4, r19	; 0x04
     c0a:	2b 83       	std	Y+3, r18	; 0x03
     c0c:	8b 81       	ldd	r24, Y+3	; 0x03
     c0e:	9c 81       	ldd	r25, Y+4	; 0x04
     c10:	81 30       	cpi	r24, 0x01	; 1
     c12:	91 05       	cpc	r25, r1
     c14:	49 f1       	breq	.+82     	; 0xc68 <DIO_TogPinVal+0x76>
     c16:	2b 81       	ldd	r18, Y+3	; 0x03
     c18:	3c 81       	ldd	r19, Y+4	; 0x04
     c1a:	22 30       	cpi	r18, 0x02	; 2
     c1c:	31 05       	cpc	r19, r1
     c1e:	2c f4       	brge	.+10     	; 0xc2a <DIO_TogPinVal+0x38>
     c20:	8b 81       	ldd	r24, Y+3	; 0x03
     c22:	9c 81       	ldd	r25, Y+4	; 0x04
     c24:	00 97       	sbiw	r24, 0x00	; 0
     c26:	61 f0       	breq	.+24     	; 0xc40 <DIO_TogPinVal+0x4e>
     c28:	5a c0       	rjmp	.+180    	; 0xcde <DIO_TogPinVal+0xec>
     c2a:	2b 81       	ldd	r18, Y+3	; 0x03
     c2c:	3c 81       	ldd	r19, Y+4	; 0x04
     c2e:	22 30       	cpi	r18, 0x02	; 2
     c30:	31 05       	cpc	r19, r1
     c32:	71 f1       	breq	.+92     	; 0xc90 <DIO_TogPinVal+0x9e>
     c34:	8b 81       	ldd	r24, Y+3	; 0x03
     c36:	9c 81       	ldd	r25, Y+4	; 0x04
     c38:	83 30       	cpi	r24, 0x03	; 3
     c3a:	91 05       	cpc	r25, r1
     c3c:	e9 f1       	breq	.+122    	; 0xcb8 <DIO_TogPinVal+0xc6>
     c3e:	4f c0       	rjmp	.+158    	; 0xcde <DIO_TogPinVal+0xec>
	{
		case  DIO_PORTA :	TOG_BIT(PORTA,pin);
     c40:	ab e3       	ldi	r26, 0x3B	; 59
     c42:	b0 e0       	ldi	r27, 0x00	; 0
     c44:	eb e3       	ldi	r30, 0x3B	; 59
     c46:	f0 e0       	ldi	r31, 0x00	; 0
     c48:	80 81       	ld	r24, Z
     c4a:	48 2f       	mov	r20, r24
     c4c:	8a 81       	ldd	r24, Y+2	; 0x02
     c4e:	28 2f       	mov	r18, r24
     c50:	30 e0       	ldi	r19, 0x00	; 0
     c52:	81 e0       	ldi	r24, 0x01	; 1
     c54:	90 e0       	ldi	r25, 0x00	; 0
     c56:	02 2e       	mov	r0, r18
     c58:	02 c0       	rjmp	.+4      	; 0xc5e <DIO_TogPinVal+0x6c>
     c5a:	88 0f       	add	r24, r24
     c5c:	99 1f       	adc	r25, r25
     c5e:	0a 94       	dec	r0
     c60:	e2 f7       	brpl	.-8      	; 0xc5a <DIO_TogPinVal+0x68>
     c62:	84 27       	eor	r24, r20
     c64:	8c 93       	st	X, r24
     c66:	3b c0       	rjmp	.+118    	; 0xcde <DIO_TogPinVal+0xec>
		break;
		case  DIO_PORTB :   TOG_BIT(PORTB,pin);
     c68:	a8 e3       	ldi	r26, 0x38	; 56
     c6a:	b0 e0       	ldi	r27, 0x00	; 0
     c6c:	e8 e3       	ldi	r30, 0x38	; 56
     c6e:	f0 e0       	ldi	r31, 0x00	; 0
     c70:	80 81       	ld	r24, Z
     c72:	48 2f       	mov	r20, r24
     c74:	8a 81       	ldd	r24, Y+2	; 0x02
     c76:	28 2f       	mov	r18, r24
     c78:	30 e0       	ldi	r19, 0x00	; 0
     c7a:	81 e0       	ldi	r24, 0x01	; 1
     c7c:	90 e0       	ldi	r25, 0x00	; 0
     c7e:	02 2e       	mov	r0, r18
     c80:	02 c0       	rjmp	.+4      	; 0xc86 <DIO_TogPinVal+0x94>
     c82:	88 0f       	add	r24, r24
     c84:	99 1f       	adc	r25, r25
     c86:	0a 94       	dec	r0
     c88:	e2 f7       	brpl	.-8      	; 0xc82 <DIO_TogPinVal+0x90>
     c8a:	84 27       	eor	r24, r20
     c8c:	8c 93       	st	X, r24
     c8e:	27 c0       	rjmp	.+78     	; 0xcde <DIO_TogPinVal+0xec>
		break;
		case  DIO_PORTC :   TOG_BIT(PORTC,pin);
     c90:	a5 e3       	ldi	r26, 0x35	; 53
     c92:	b0 e0       	ldi	r27, 0x00	; 0
     c94:	e5 e3       	ldi	r30, 0x35	; 53
     c96:	f0 e0       	ldi	r31, 0x00	; 0
     c98:	80 81       	ld	r24, Z
     c9a:	48 2f       	mov	r20, r24
     c9c:	8a 81       	ldd	r24, Y+2	; 0x02
     c9e:	28 2f       	mov	r18, r24
     ca0:	30 e0       	ldi	r19, 0x00	; 0
     ca2:	81 e0       	ldi	r24, 0x01	; 1
     ca4:	90 e0       	ldi	r25, 0x00	; 0
     ca6:	02 2e       	mov	r0, r18
     ca8:	02 c0       	rjmp	.+4      	; 0xcae <DIO_TogPinVal+0xbc>
     caa:	88 0f       	add	r24, r24
     cac:	99 1f       	adc	r25, r25
     cae:	0a 94       	dec	r0
     cb0:	e2 f7       	brpl	.-8      	; 0xcaa <DIO_TogPinVal+0xb8>
     cb2:	84 27       	eor	r24, r20
     cb4:	8c 93       	st	X, r24
     cb6:	13 c0       	rjmp	.+38     	; 0xcde <DIO_TogPinVal+0xec>
		break;
		case  DIO_PORTD :   TOG_BIT(PORTD,pin);
     cb8:	a2 e3       	ldi	r26, 0x32	; 50
     cba:	b0 e0       	ldi	r27, 0x00	; 0
     cbc:	e2 e3       	ldi	r30, 0x32	; 50
     cbe:	f0 e0       	ldi	r31, 0x00	; 0
     cc0:	80 81       	ld	r24, Z
     cc2:	48 2f       	mov	r20, r24
     cc4:	8a 81       	ldd	r24, Y+2	; 0x02
     cc6:	28 2f       	mov	r18, r24
     cc8:	30 e0       	ldi	r19, 0x00	; 0
     cca:	81 e0       	ldi	r24, 0x01	; 1
     ccc:	90 e0       	ldi	r25, 0x00	; 0
     cce:	02 2e       	mov	r0, r18
     cd0:	02 c0       	rjmp	.+4      	; 0xcd6 <DIO_TogPinVal+0xe4>
     cd2:	88 0f       	add	r24, r24
     cd4:	99 1f       	adc	r25, r25
     cd6:	0a 94       	dec	r0
     cd8:	e2 f7       	brpl	.-8      	; 0xcd2 <DIO_TogPinVal+0xe0>
     cda:	84 27       	eor	r24, r20
     cdc:	8c 93       	st	X, r24
		break;
	}
}
     cde:	0f 90       	pop	r0
     ce0:	0f 90       	pop	r0
     ce2:	0f 90       	pop	r0
     ce4:	0f 90       	pop	r0
     ce6:	cf 91       	pop	r28
     ce8:	df 91       	pop	r29
     cea:	08 95       	ret

00000cec <PWM_INIT>:
 *  Created on: Feb 11, 2023
 *      Author: wario
 */

#include"PWM.h"
void PWM_INIT(void){
     cec:	df 93       	push	r29
     cee:	cf 93       	push	r28
     cf0:	cd b7       	in	r28, 0x3d	; 61
     cf2:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTB ,Pin3, OUTPUT);
     cf4:	81 e0       	ldi	r24, 0x01	; 1
     cf6:	63 e0       	ldi	r22, 0x03	; 3
     cf8:	43 e0       	ldi	r20, 0x03	; 3
     cfa:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	DIO_SetPinDir(DIO_PORTD ,Pin7, OUTPUT);
     cfe:	83 e0       	ldi	r24, 0x03	; 3
     d00:	67 e0       	ldi	r22, 0x07	; 7
     d02:	43 e0       	ldi	r20, 0x03	; 3
     d04:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
}
     d08:	cf 91       	pop	r28
     d0a:	df 91       	pop	r29
     d0c:	08 95       	ret

00000d0e <Start_PWM1>:
void Start_PWM1(void){
     d0e:	df 93       	push	r29
     d10:	cf 93       	push	r28
     d12:	cd b7       	in	r28, 0x3d	; 61
     d14:	de b7       	in	r29, 0x3e	; 62
	TCCR0 = (1<<WGM00) | (1<<WGM01) | (1<<COM01) | (1<<CS00);
     d16:	e3 e5       	ldi	r30, 0x53	; 83
     d18:	f0 e0       	ldi	r31, 0x00	; 0
     d1a:	89 e6       	ldi	r24, 0x69	; 105
     d1c:	80 83       	st	Z, r24
	OCR0 = 204;
     d1e:	ec e5       	ldi	r30, 0x5C	; 92
     d20:	f0 e0       	ldi	r31, 0x00	; 0
     d22:	8c ec       	ldi	r24, 0xCC	; 204
     d24:	80 83       	st	Z, r24
}
     d26:	cf 91       	pop	r28
     d28:	df 91       	pop	r29
     d2a:	08 95       	ret

00000d2c <Start_PWM2>:
void Start_PWM2(void){
     d2c:	df 93       	push	r29
     d2e:	cf 93       	push	r28
     d30:	cd b7       	in	r28, 0x3d	; 61
     d32:	de b7       	in	r29, 0x3e	; 62
	TCCR2 = (1<<WGM20) | (1<<WGM21) | (1<<COM21) | (1<<CS20);
     d34:	e5 e4       	ldi	r30, 0x45	; 69
     d36:	f0 e0       	ldi	r31, 0x00	; 0
     d38:	89 e6       	ldi	r24, 0x69	; 105
     d3a:	80 83       	st	Z, r24
	OCR2 = 204;
     d3c:	e3 e4       	ldi	r30, 0x43	; 67
     d3e:	f0 e0       	ldi	r31, 0x00	; 0
     d40:	8c ec       	ldi	r24, 0xCC	; 204
     d42:	80 83       	st	Z, r24
}
     d44:	cf 91       	pop	r28
     d46:	df 91       	pop	r29
     d48:	08 95       	ret

00000d4a <Stop_PWM1>:
void Stop_PWM1(void){
     d4a:	df 93       	push	r29
     d4c:	cf 93       	push	r28
     d4e:	cd b7       	in	r28, 0x3d	; 61
     d50:	de b7       	in	r29, 0x3e	; 62
	TCCR0 &=~ (1<<COM01);
     d52:	a3 e5       	ldi	r26, 0x53	; 83
     d54:	b0 e0       	ldi	r27, 0x00	; 0
     d56:	e3 e5       	ldi	r30, 0x53	; 83
     d58:	f0 e0       	ldi	r31, 0x00	; 0
     d5a:	80 81       	ld	r24, Z
     d5c:	8f 7d       	andi	r24, 0xDF	; 223
     d5e:	8c 93       	st	X, r24
	TCCR0 &=~ (1<<CS00);
     d60:	a3 e5       	ldi	r26, 0x53	; 83
     d62:	b0 e0       	ldi	r27, 0x00	; 0
     d64:	e3 e5       	ldi	r30, 0x53	; 83
     d66:	f0 e0       	ldi	r31, 0x00	; 0
     d68:	80 81       	ld	r24, Z
     d6a:	8e 7f       	andi	r24, 0xFE	; 254
     d6c:	8c 93       	st	X, r24
}
     d6e:	cf 91       	pop	r28
     d70:	df 91       	pop	r29
     d72:	08 95       	ret

00000d74 <Stop_PWM2>:
void Stop_PWM2(void){
     d74:	df 93       	push	r29
     d76:	cf 93       	push	r28
     d78:	cd b7       	in	r28, 0x3d	; 61
     d7a:	de b7       	in	r29, 0x3e	; 62
	TCCR2 &=~ (1<<COM21);
     d7c:	a5 e4       	ldi	r26, 0x45	; 69
     d7e:	b0 e0       	ldi	r27, 0x00	; 0
     d80:	e5 e4       	ldi	r30, 0x45	; 69
     d82:	f0 e0       	ldi	r31, 0x00	; 0
     d84:	80 81       	ld	r24, Z
     d86:	8f 7d       	andi	r24, 0xDF	; 223
     d88:	8c 93       	st	X, r24
	TCCR2 &=~ (1<<CS20);
     d8a:	a5 e4       	ldi	r26, 0x45	; 69
     d8c:	b0 e0       	ldi	r27, 0x00	; 0
     d8e:	e5 e4       	ldi	r30, 0x45	; 69
     d90:	f0 e0       	ldi	r31, 0x00	; 0
     d92:	80 81       	ld	r24, Z
     d94:	8e 7f       	andi	r24, 0xFE	; 254
     d96:	8c 93       	st	X, r24
}
     d98:	cf 91       	pop	r28
     d9a:	df 91       	pop	r29
     d9c:	08 95       	ret

00000d9e <READ_IGNITON>:
 *
 *  Created on: Feb 11, 2023
 *      Author: wario
 */
#include "Btn_Handler.h"
uint8_t READ_IGNITON(void){
     d9e:	df 93       	push	r29
     da0:	cf 93       	push	r28
     da2:	0f 92       	push	r0
     da4:	cd b7       	in	r28, 0x3d	; 61
     da6:	de b7       	in	r29, 0x3e	; 62

	DIO_SetPinDir(DIO_PORTA ,Pin0, INPUT);
     da8:	80 e0       	ldi	r24, 0x00	; 0
     daa:	60 e0       	ldi	r22, 0x00	; 0
     dac:	42 e0       	ldi	r20, 0x02	; 2
     dae:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	uint8_t IGNITION_data = DIO_GetPinVal(DIO_PORTA ,Pin0) ;
     db2:	80 e0       	ldi	r24, 0x00	; 0
     db4:	60 e0       	ldi	r22, 0x00	; 0
     db6:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_GetPinVal>
     dba:	89 83       	std	Y+1, r24	; 0x01
	return IGNITION_data;
     dbc:	89 81       	ldd	r24, Y+1	; 0x01
}
     dbe:	0f 90       	pop	r0
     dc0:	cf 91       	pop	r28
     dc2:	df 91       	pop	r29
     dc4:	08 95       	ret

00000dc6 <READ_HAZARD_Button>:
uint8_t READ_HAZARD_Button(void){
     dc6:	df 93       	push	r29
     dc8:	cf 93       	push	r28
     dca:	0f 92       	push	r0
     dcc:	cd b7       	in	r28, 0x3d	; 61
     dce:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTA ,Pin1, INPUT);
     dd0:	80 e0       	ldi	r24, 0x00	; 0
     dd2:	61 e0       	ldi	r22, 0x01	; 1
     dd4:	42 e0       	ldi	r20, 0x02	; 2
     dd6:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	uint8_t HAZARD_data = DIO_GetPinVal(DIO_PORTA ,Pin1) ;
     dda:	80 e0       	ldi	r24, 0x00	; 0
     ddc:	61 e0       	ldi	r22, 0x01	; 1
     dde:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_GetPinVal>
     de2:	89 83       	std	Y+1, r24	; 0x01
	 return pressed ;
	 }else{
	 return unpressed;
	 }
	 */
	return HAZARD_data;
     de4:	89 81       	ldd	r24, Y+1	; 0x01
}
     de6:	0f 90       	pop	r0
     de8:	cf 91       	pop	r28
     dea:	df 91       	pop	r29
     dec:	08 95       	ret

00000dee <READ_RIGHT_Button>:
uint8_t READ_RIGHT_Button(void){
     dee:	df 93       	push	r29
     df0:	cf 93       	push	r28
     df2:	0f 92       	push	r0
     df4:	cd b7       	in	r28, 0x3d	; 61
     df6:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTA ,Pin2, INPUT);
     df8:	80 e0       	ldi	r24, 0x00	; 0
     dfa:	62 e0       	ldi	r22, 0x02	; 2
     dfc:	42 e0       	ldi	r20, 0x02	; 2
     dfe:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	uint8_t right_data  = DIO_GetPinVal(DIO_PORTA ,Pin2) ;
     e02:	80 e0       	ldi	r24, 0x00	; 0
     e04:	62 e0       	ldi	r22, 0x02	; 2
     e06:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_GetPinVal>
     e0a:	89 83       	std	Y+1, r24	; 0x01
	return right_data ;
     e0c:	89 81       	ldd	r24, Y+1	; 0x01
}
     e0e:	0f 90       	pop	r0
     e10:	cf 91       	pop	r28
     e12:	df 91       	pop	r29
     e14:	08 95       	ret

00000e16 <READ_LEFT_Button>:
uint8_t READ_LEFT_Button(void){
     e16:	df 93       	push	r29
     e18:	cf 93       	push	r28
     e1a:	0f 92       	push	r0
     e1c:	cd b7       	in	r28, 0x3d	; 61
     e1e:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTA ,Pin3, INPUT);
     e20:	80 e0       	ldi	r24, 0x00	; 0
     e22:	63 e0       	ldi	r22, 0x03	; 3
     e24:	42 e0       	ldi	r20, 0x02	; 2
     e26:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	uint8_t right_data  = DIO_GetPinVal(DIO_PORTA ,Pin3) ;
     e2a:	80 e0       	ldi	r24, 0x00	; 0
     e2c:	63 e0       	ldi	r22, 0x03	; 3
     e2e:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_GetPinVal>
     e32:	89 83       	std	Y+1, r24	; 0x01
	return right_data;
     e34:	89 81       	ldd	r24, Y+1	; 0x01

}
     e36:	0f 90       	pop	r0
     e38:	cf 91       	pop	r28
     e3a:	df 91       	pop	r29
     e3c:	08 95       	ret

00000e3e <vBlink_Right>:
 */

#include"LED.h"
#include"PWM.h"

void vBlink_Right(char led_mode ){
     e3e:	df 93       	push	r29
     e40:	cf 93       	push	r28
     e42:	0f 92       	push	r0
     e44:	cd b7       	in	r28, 0x3d	; 61
     e46:	de b7       	in	r29, 0x3e	; 62
     e48:	89 83       	std	Y+1, r24	; 0x01

		if(led_mode){
     e4a:	89 81       	ldd	r24, Y+1	; 0x01
     e4c:	88 23       	and	r24, r24
     e4e:	19 f0       	breq	.+6      	; 0xe56 <vBlink_Right+0x18>
			Start_PWM1();
     e50:	0e 94 87 06 	call	0xd0e	; 0xd0e <Start_PWM1>
     e54:	02 c0       	rjmp	.+4      	; 0xe5a <vBlink_Right+0x1c>

		}else{
			Stop_PWM1();
     e56:	0e 94 a5 06 	call	0xd4a	; 0xd4a <Stop_PWM1>

	}


}
     e5a:	0f 90       	pop	r0
     e5c:	cf 91       	pop	r28
     e5e:	df 91       	pop	r29
     e60:	08 95       	ret

00000e62 <Blink_LEFT>:

void Blink_LEFT(char led_mode){
     e62:	df 93       	push	r29
     e64:	cf 93       	push	r28
     e66:	0f 92       	push	r0
     e68:	cd b7       	in	r28, 0x3d	; 61
     e6a:	de b7       	in	r29, 0x3e	; 62
     e6c:	89 83       	std	Y+1, r24	; 0x01
		if(led_mode){
     e6e:	89 81       	ldd	r24, Y+1	; 0x01
     e70:	88 23       	and	r24, r24
     e72:	19 f0       	breq	.+6      	; 0xe7a <Blink_LEFT+0x18>
			Start_PWM2();
     e74:	0e 94 96 06 	call	0xd2c	; 0xd2c <Start_PWM2>
     e78:	02 c0       	rjmp	.+4      	; 0xe7e <Blink_LEFT+0x1c>
		}else{
			Stop_PWM2();
     e7a:	0e 94 ba 06 	call	0xd74	; 0xd74 <Stop_PWM2>

		}

}
     e7e:	0f 90       	pop	r0
     e80:	cf 91       	pop	r28
     e82:	df 91       	pop	r29
     e84:	08 95       	ret

00000e86 <xCoRoutineCreate>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode,
                                 UBaseType_t uxPriority,
                                 UBaseType_t uxIndex )
    {
     e86:	df 93       	push	r29
     e88:	cf 93       	push	r28
     e8a:	cd b7       	in	r28, 0x3d	; 61
     e8c:	de b7       	in	r29, 0x3e	; 62
     e8e:	27 97       	sbiw	r28, 0x07	; 7
     e90:	0f b6       	in	r0, 0x3f	; 63
     e92:	f8 94       	cli
     e94:	de bf       	out	0x3e, r29	; 62
     e96:	0f be       	out	0x3f, r0	; 63
     e98:	cd bf       	out	0x3d, r28	; 61
     e9a:	9d 83       	std	Y+5, r25	; 0x05
     e9c:	8c 83       	std	Y+4, r24	; 0x04
     e9e:	6e 83       	std	Y+6, r22	; 0x06
     ea0:	4f 83       	std	Y+7, r20	; 0x07
        BaseType_t xReturn;
        CRCB_t * pxCoRoutine;

        /* Allocate the memory that will store the co-routine control block. */
        pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     ea2:	8a e1       	ldi	r24, 0x1A	; 26
     ea4:	90 e0       	ldi	r25, 0x00	; 0
     ea6:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     eaa:	9a 83       	std	Y+2, r25	; 0x02
     eac:	89 83       	std	Y+1, r24	; 0x01

        if( pxCoRoutine )
     eae:	89 81       	ldd	r24, Y+1	; 0x01
     eb0:	9a 81       	ldd	r25, Y+2	; 0x02
     eb2:	00 97       	sbiw	r24, 0x00	; 0
     eb4:	09 f4       	brne	.+2      	; 0xeb8 <xCoRoutineCreate+0x32>
     eb6:	6f c0       	rjmp	.+222    	; 0xf96 <xCoRoutineCreate+0x110>
        {
            /* If pxCurrentCoRoutine is NULL then this is the first co-routine to
            * be created and the co-routine data structures need initialising. */
            if( pxCurrentCoRoutine == NULL )
     eb8:	80 91 70 06 	lds	r24, 0x0670
     ebc:	90 91 71 06 	lds	r25, 0x0671
     ec0:	00 97       	sbiw	r24, 0x00	; 0
     ec2:	41 f4       	brne	.+16     	; 0xed4 <xCoRoutineCreate+0x4e>
            {
                pxCurrentCoRoutine = pxCoRoutine;
     ec4:	89 81       	ldd	r24, Y+1	; 0x01
     ec6:	9a 81       	ldd	r25, Y+2	; 0x02
     ec8:	90 93 71 06 	sts	0x0671, r25
     ecc:	80 93 70 06 	sts	0x0670, r24
                prvInitialiseCoRoutineLists();
     ed0:	0e 94 b1 09 	call	0x1362	; 0x1362 <prvInitialiseCoRoutineLists>
            }

            /* Check the priority is within limits. */
            if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     ed4:	8e 81       	ldd	r24, Y+6	; 0x06
     ed6:	82 30       	cpi	r24, 0x02	; 2
     ed8:	10 f0       	brcs	.+4      	; 0xede <xCoRoutineCreate+0x58>
            {
                uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     eda:	81 e0       	ldi	r24, 0x01	; 1
     edc:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Fill out the co-routine control block from the function parameters. */
            pxCoRoutine->uxState = corINITIAL_STATE;
     ede:	e9 81       	ldd	r30, Y+1	; 0x01
     ee0:	fa 81       	ldd	r31, Y+2	; 0x02
     ee2:	11 8e       	std	Z+25, r1	; 0x19
     ee4:	10 8e       	std	Z+24, r1	; 0x18
            pxCoRoutine->uxPriority = uxPriority;
     ee6:	e9 81       	ldd	r30, Y+1	; 0x01
     ee8:	fa 81       	ldd	r31, Y+2	; 0x02
     eea:	8e 81       	ldd	r24, Y+6	; 0x06
     eec:	86 8b       	std	Z+22, r24	; 0x16
            pxCoRoutine->uxIndex = uxIndex;
     eee:	e9 81       	ldd	r30, Y+1	; 0x01
     ef0:	fa 81       	ldd	r31, Y+2	; 0x02
     ef2:	8f 81       	ldd	r24, Y+7	; 0x07
     ef4:	87 8b       	std	Z+23, r24	; 0x17
            pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     ef6:	e9 81       	ldd	r30, Y+1	; 0x01
     ef8:	fa 81       	ldd	r31, Y+2	; 0x02
     efa:	8c 81       	ldd	r24, Y+4	; 0x04
     efc:	9d 81       	ldd	r25, Y+5	; 0x05
     efe:	91 83       	std	Z+1, r25	; 0x01
     f00:	80 83       	st	Z, r24

            /* Initialise all the other co-routine control block parameters. */
            vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     f02:	89 81       	ldd	r24, Y+1	; 0x01
     f04:	9a 81       	ldd	r25, Y+2	; 0x02
     f06:	02 96       	adiw	r24, 0x02	; 2
     f08:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <vListInitialiseItem>
            vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     f0c:	89 81       	ldd	r24, Y+1	; 0x01
     f0e:	9a 81       	ldd	r25, Y+2	; 0x02
     f10:	0c 96       	adiw	r24, 0x0c	; 12
     f12:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <vListInitialiseItem>

            /* Set the co-routine control block as a link back from the ListItem_t.
             * This is so we can get back to the containing CRCB from a generic item
             * in a list. */
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     f16:	e9 81       	ldd	r30, Y+1	; 0x01
     f18:	fa 81       	ldd	r31, Y+2	; 0x02
     f1a:	89 81       	ldd	r24, Y+1	; 0x01
     f1c:	9a 81       	ldd	r25, Y+2	; 0x02
     f1e:	91 87       	std	Z+9, r25	; 0x09
     f20:	80 87       	std	Z+8, r24	; 0x08
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     f22:	e9 81       	ldd	r30, Y+1	; 0x01
     f24:	fa 81       	ldd	r31, Y+2	; 0x02
     f26:	89 81       	ldd	r24, Y+1	; 0x01
     f28:	9a 81       	ldd	r25, Y+2	; 0x02
     f2a:	93 8b       	std	Z+19, r25	; 0x13
     f2c:	82 8b       	std	Z+18, r24	; 0x12

            /* Event lists are always in priority order. */
            listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     f2e:	8e 81       	ldd	r24, Y+6	; 0x06
     f30:	28 2f       	mov	r18, r24
     f32:	30 e0       	ldi	r19, 0x00	; 0
     f34:	82 e0       	ldi	r24, 0x02	; 2
     f36:	90 e0       	ldi	r25, 0x00	; 0
     f38:	82 1b       	sub	r24, r18
     f3a:	93 0b       	sbc	r25, r19
     f3c:	e9 81       	ldd	r30, Y+1	; 0x01
     f3e:	fa 81       	ldd	r31, Y+2	; 0x02
     f40:	95 87       	std	Z+13, r25	; 0x0d
     f42:	84 87       	std	Z+12, r24	; 0x0c

            /* Now the co-routine has been initialised it can be added to the ready
             * list at the correct priority. */
            prvAddCoRoutineToReadyQueue( pxCoRoutine );
     f44:	e9 81       	ldd	r30, Y+1	; 0x01
     f46:	fa 81       	ldd	r31, Y+2	; 0x02
     f48:	96 89       	ldd	r25, Z+22	; 0x16
     f4a:	80 91 72 06 	lds	r24, 0x0672
     f4e:	89 17       	cp	r24, r25
     f50:	28 f4       	brcc	.+10     	; 0xf5c <xCoRoutineCreate+0xd6>
     f52:	e9 81       	ldd	r30, Y+1	; 0x01
     f54:	fa 81       	ldd	r31, Y+2	; 0x02
     f56:	86 89       	ldd	r24, Z+22	; 0x16
     f58:	80 93 72 06 	sts	0x0672, r24
     f5c:	e9 81       	ldd	r30, Y+1	; 0x01
     f5e:	fa 81       	ldd	r31, Y+2	; 0x02
     f60:	86 89       	ldd	r24, Z+22	; 0x16
     f62:	28 2f       	mov	r18, r24
     f64:	30 e0       	ldi	r19, 0x00	; 0
     f66:	c9 01       	movw	r24, r18
     f68:	88 0f       	add	r24, r24
     f6a:	99 1f       	adc	r25, r25
     f6c:	88 0f       	add	r24, r24
     f6e:	99 1f       	adc	r25, r25
     f70:	88 0f       	add	r24, r24
     f72:	99 1f       	adc	r25, r25
     f74:	82 0f       	add	r24, r18
     f76:	93 1f       	adc	r25, r19
     f78:	ac 01       	movw	r20, r24
     f7a:	47 58       	subi	r20, 0x87	; 135
     f7c:	59 4f       	sbci	r21, 0xF9	; 249
     f7e:	89 81       	ldd	r24, Y+1	; 0x01
     f80:	9a 81       	ldd	r25, Y+2	; 0x02
     f82:	9c 01       	movw	r18, r24
     f84:	2e 5f       	subi	r18, 0xFE	; 254
     f86:	3f 4f       	sbci	r19, 0xFF	; 255
     f88:	ca 01       	movw	r24, r20
     f8a:	b9 01       	movw	r22, r18
     f8c:	0e 94 a1 0d 	call	0x1b42	; 0x1b42 <vListInsertEnd>

            xReturn = pdPASS;
     f90:	81 e0       	ldi	r24, 0x01	; 1
     f92:	8b 83       	std	Y+3, r24	; 0x03
     f94:	02 c0       	rjmp	.+4      	; 0xf9a <xCoRoutineCreate+0x114>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     f96:	8f ef       	ldi	r24, 0xFF	; 255
     f98:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
     f9a:	8b 81       	ldd	r24, Y+3	; 0x03
    }
     f9c:	27 96       	adiw	r28, 0x07	; 7
     f9e:	0f b6       	in	r0, 0x3f	; 63
     fa0:	f8 94       	cli
     fa2:	de bf       	out	0x3e, r29	; 62
     fa4:	0f be       	out	0x3f, r0	; 63
     fa6:	cd bf       	out	0x3d, r28	; 61
     fa8:	cf 91       	pop	r28
     faa:	df 91       	pop	r29
     fac:	08 95       	ret

00000fae <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

    void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay,
                                     List_t * pxEventList )
    {
     fae:	df 93       	push	r29
     fb0:	cf 93       	push	r28
     fb2:	00 d0       	rcall	.+0      	; 0xfb4 <vCoRoutineAddToDelayedList+0x6>
     fb4:	00 d0       	rcall	.+0      	; 0xfb6 <vCoRoutineAddToDelayedList+0x8>
     fb6:	00 d0       	rcall	.+0      	; 0xfb8 <vCoRoutineAddToDelayedList+0xa>
     fb8:	cd b7       	in	r28, 0x3d	; 61
     fba:	de b7       	in	r29, 0x3e	; 62
     fbc:	9c 83       	std	Y+4, r25	; 0x04
     fbe:	8b 83       	std	Y+3, r24	; 0x03
     fc0:	7e 83       	std	Y+6, r23	; 0x06
     fc2:	6d 83       	std	Y+5, r22	; 0x05
        TickType_t xTimeToWake;

        /* Calculate the time to wake - this may overflow but this is
         * not a problem. */
        xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     fc4:	20 91 73 06 	lds	r18, 0x0673
     fc8:	30 91 74 06 	lds	r19, 0x0674
     fcc:	8b 81       	ldd	r24, Y+3	; 0x03
     fce:	9c 81       	ldd	r25, Y+4	; 0x04
     fd0:	82 0f       	add	r24, r18
     fd2:	93 1f       	adc	r25, r19
     fd4:	9a 83       	std	Y+2, r25	; 0x02
     fd6:	89 83       	std	Y+1, r24	; 0x01

        /* We must remove ourselves from the ready list before adding
         * ourselves to the blocked list as the same list item is used for
         * both lists. */
        ( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     fd8:	80 91 70 06 	lds	r24, 0x0670
     fdc:	90 91 71 06 	lds	r25, 0x0671
     fe0:	02 96       	adiw	r24, 0x02	; 2
     fe2:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <uxListRemove>

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     fe6:	e0 91 70 06 	lds	r30, 0x0670
     fea:	f0 91 71 06 	lds	r31, 0x0671
     fee:	89 81       	ldd	r24, Y+1	; 0x01
     ff0:	9a 81       	ldd	r25, Y+2	; 0x02
     ff2:	93 83       	std	Z+3, r25	; 0x03
     ff4:	82 83       	std	Z+2, r24	; 0x02

        if( xTimeToWake < xCoRoutineTickCount )
     ff6:	20 91 73 06 	lds	r18, 0x0673
     ffa:	30 91 74 06 	lds	r19, 0x0674
     ffe:	89 81       	ldd	r24, Y+1	; 0x01
    1000:	9a 81       	ldd	r25, Y+2	; 0x02
    1002:	82 17       	cp	r24, r18
    1004:	93 07       	cpc	r25, r19
    1006:	70 f4       	brcc	.+28     	; 0x1024 <vCoRoutineAddToDelayedList+0x76>
        {
            /* Wake time has overflowed.  Place this item in the
             * overflow list. */
            vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1008:	80 91 6e 06 	lds	r24, 0x066E
    100c:	90 91 6f 06 	lds	r25, 0x066F
    1010:	20 91 70 06 	lds	r18, 0x0670
    1014:	30 91 71 06 	lds	r19, 0x0671
    1018:	2e 5f       	subi	r18, 0xFE	; 254
    101a:	3f 4f       	sbci	r19, 0xFF	; 255
    101c:	b9 01       	movw	r22, r18
    101e:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <vListInsert>
    1022:	0d c0       	rjmp	.+26     	; 0x103e <vCoRoutineAddToDelayedList+0x90>
        }
        else
        {
            /* The wake time has not overflowed, so we can use the
             * current block list. */
            vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1024:	80 91 6c 06 	lds	r24, 0x066C
    1028:	90 91 6d 06 	lds	r25, 0x066D
    102c:	20 91 70 06 	lds	r18, 0x0670
    1030:	30 91 71 06 	lds	r19, 0x0671
    1034:	2e 5f       	subi	r18, 0xFE	; 254
    1036:	3f 4f       	sbci	r19, 0xFF	; 255
    1038:	b9 01       	movw	r22, r18
    103a:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <vListInsert>
        }

        if( pxEventList )
    103e:	8d 81       	ldd	r24, Y+5	; 0x05
    1040:	9e 81       	ldd	r25, Y+6	; 0x06
    1042:	00 97       	sbiw	r24, 0x00	; 0
    1044:	61 f0       	breq	.+24     	; 0x105e <vCoRoutineAddToDelayedList+0xb0>
        {
            /* Also add the co-routine to an event list.  If this is done then the
             * function must be called with interrupts disabled. */
            vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1046:	80 91 70 06 	lds	r24, 0x0670
    104a:	90 91 71 06 	lds	r25, 0x0671
    104e:	9c 01       	movw	r18, r24
    1050:	24 5f       	subi	r18, 0xF4	; 244
    1052:	3f 4f       	sbci	r19, 0xFF	; 255
    1054:	8d 81       	ldd	r24, Y+5	; 0x05
    1056:	9e 81       	ldd	r25, Y+6	; 0x06
    1058:	b9 01       	movw	r22, r18
    105a:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <vListInsert>
        }
    }
    105e:	26 96       	adiw	r28, 0x06	; 6
    1060:	0f b6       	in	r0, 0x3f	; 63
    1062:	f8 94       	cli
    1064:	de bf       	out	0x3e, r29	; 62
    1066:	0f be       	out	0x3f, r0	; 63
    1068:	cd bf       	out	0x3d, r28	; 61
    106a:	cf 91       	pop	r28
    106c:	df 91       	pop	r29
    106e:	08 95       	ret

00001070 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

    static void prvCheckPendingReadyList( void )
    {
    1070:	df 93       	push	r29
    1072:	cf 93       	push	r28
    1074:	00 d0       	rcall	.+0      	; 0x1076 <prvCheckPendingReadyList+0x6>
    1076:	cd b7       	in	r28, 0x3d	; 61
    1078:	de b7       	in	r29, 0x3e	; 62
    107a:	3a c0       	rjmp	.+116    	; 0x10f0 <prvCheckPendingReadyList+0x80>
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
        {
            CRCB_t * pxUnblockedCRCB;

            /* The pending ready list can be accessed by an ISR. */
            portDISABLE_INTERRUPTS();
    107c:	f8 94       	cli
            {
                pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyCoRoutineList ) );
    107e:	e0 91 a2 06 	lds	r30, 0x06A2
    1082:	f0 91 a3 06 	lds	r31, 0x06A3
    1086:	86 81       	ldd	r24, Z+6	; 0x06
    1088:	97 81       	ldd	r25, Z+7	; 0x07
    108a:	9a 83       	std	Y+2, r25	; 0x02
    108c:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    108e:	89 81       	ldd	r24, Y+1	; 0x01
    1090:	9a 81       	ldd	r25, Y+2	; 0x02
    1092:	0c 96       	adiw	r24, 0x0c	; 12
    1094:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <uxListRemove>
            }
            portENABLE_INTERRUPTS();
    1098:	78 94       	sei

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    109a:	89 81       	ldd	r24, Y+1	; 0x01
    109c:	9a 81       	ldd	r25, Y+2	; 0x02
    109e:	02 96       	adiw	r24, 0x02	; 2
    10a0:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <uxListRemove>
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    10a4:	e9 81       	ldd	r30, Y+1	; 0x01
    10a6:	fa 81       	ldd	r31, Y+2	; 0x02
    10a8:	96 89       	ldd	r25, Z+22	; 0x16
    10aa:	80 91 72 06 	lds	r24, 0x0672
    10ae:	89 17       	cp	r24, r25
    10b0:	28 f4       	brcc	.+10     	; 0x10bc <prvCheckPendingReadyList+0x4c>
    10b2:	e9 81       	ldd	r30, Y+1	; 0x01
    10b4:	fa 81       	ldd	r31, Y+2	; 0x02
    10b6:	86 89       	ldd	r24, Z+22	; 0x16
    10b8:	80 93 72 06 	sts	0x0672, r24
    10bc:	e9 81       	ldd	r30, Y+1	; 0x01
    10be:	fa 81       	ldd	r31, Y+2	; 0x02
    10c0:	86 89       	ldd	r24, Z+22	; 0x16
    10c2:	28 2f       	mov	r18, r24
    10c4:	30 e0       	ldi	r19, 0x00	; 0
    10c6:	c9 01       	movw	r24, r18
    10c8:	88 0f       	add	r24, r24
    10ca:	99 1f       	adc	r25, r25
    10cc:	88 0f       	add	r24, r24
    10ce:	99 1f       	adc	r25, r25
    10d0:	88 0f       	add	r24, r24
    10d2:	99 1f       	adc	r25, r25
    10d4:	82 0f       	add	r24, r18
    10d6:	93 1f       	adc	r25, r19
    10d8:	ac 01       	movw	r20, r24
    10da:	47 58       	subi	r20, 0x87	; 135
    10dc:	59 4f       	sbci	r21, 0xF9	; 249
    10de:	89 81       	ldd	r24, Y+1	; 0x01
    10e0:	9a 81       	ldd	r25, Y+2	; 0x02
    10e2:	9c 01       	movw	r18, r24
    10e4:	2e 5f       	subi	r18, 0xFE	; 254
    10e6:	3f 4f       	sbci	r19, 0xFF	; 255
    10e8:	ca 01       	movw	r24, r20
    10ea:	b9 01       	movw	r22, r18
    10ec:	0e 94 a1 0d 	call	0x1b42	; 0x1b42 <vListInsertEnd>
    static void prvCheckPendingReadyList( void )
    {
        /* Are there any co-routines waiting to get moved to the ready list?  These
         * are co-routines that have been readied by an ISR.  The ISR cannot access
         * the ready lists itself. */
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    10f0:	80 91 9d 06 	lds	r24, 0x069D
    10f4:	88 23       	and	r24, r24
    10f6:	09 f0       	breq	.+2      	; 0x10fa <prvCheckPendingReadyList+0x8a>
    10f8:	c1 cf       	rjmp	.-126    	; 0x107c <prvCheckPendingReadyList+0xc>
            portENABLE_INTERRUPTS();

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
        }
    }
    10fa:	0f 90       	pop	r0
    10fc:	0f 90       	pop	r0
    10fe:	cf 91       	pop	r28
    1100:	df 91       	pop	r29
    1102:	08 95       	ret

00001104 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

    static void prvCheckDelayedList( void )
    {
    1104:	df 93       	push	r29
    1106:	cf 93       	push	r28
    1108:	00 d0       	rcall	.+0      	; 0x110a <prvCheckDelayedList+0x6>
    110a:	00 d0       	rcall	.+0      	; 0x110c <prvCheckDelayedList+0x8>
    110c:	cd b7       	in	r28, 0x3d	; 61
    110e:	de b7       	in	r29, 0x3e	; 62
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1110:	0e 94 a0 1c 	call	0x3940	; 0x3940 <xTaskGetTickCount>
    1114:	20 91 75 06 	lds	r18, 0x0675
    1118:	30 91 76 06 	lds	r19, 0x0676
    111c:	82 1b       	sub	r24, r18
    111e:	93 0b       	sbc	r25, r19
    1120:	90 93 78 06 	sts	0x0678, r25
    1124:	80 93 77 06 	sts	0x0677, r24
    1128:	85 c0       	rjmp	.+266    	; 0x1234 <prvCheckDelayedList+0x130>

        while( xPassedTicks )
        {
            xCoRoutineTickCount++;
    112a:	80 91 73 06 	lds	r24, 0x0673
    112e:	90 91 74 06 	lds	r25, 0x0674
    1132:	01 96       	adiw	r24, 0x01	; 1
    1134:	90 93 74 06 	sts	0x0674, r25
    1138:	80 93 73 06 	sts	0x0673, r24
            xPassedTicks--;
    113c:	80 91 77 06 	lds	r24, 0x0677
    1140:	90 91 78 06 	lds	r25, 0x0678
    1144:	01 97       	sbiw	r24, 0x01	; 1
    1146:	90 93 78 06 	sts	0x0678, r25
    114a:	80 93 77 06 	sts	0x0677, r24

            /* If the tick count has overflowed we need to swap the ready lists. */
            if( xCoRoutineTickCount == 0 )
    114e:	80 91 73 06 	lds	r24, 0x0673
    1152:	90 91 74 06 	lds	r25, 0x0674
    1156:	00 97       	sbiw	r24, 0x00	; 0
    1158:	09 f0       	breq	.+2      	; 0x115c <prvCheckDelayedList+0x58>
    115a:	64 c0       	rjmp	.+200    	; 0x1224 <prvCheckDelayedList+0x120>
            {
                List_t * pxTemp;

                /* Tick count has overflowed so we need to swap the delay lists.  If there are
                 * any items in pxDelayedCoRoutineList here then there is an error! */
                pxTemp = pxDelayedCoRoutineList;
    115c:	80 91 6c 06 	lds	r24, 0x066C
    1160:	90 91 6d 06 	lds	r25, 0x066D
    1164:	9a 83       	std	Y+2, r25	; 0x02
    1166:	89 83       	std	Y+1, r24	; 0x01
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1168:	80 91 6e 06 	lds	r24, 0x066E
    116c:	90 91 6f 06 	lds	r25, 0x066F
    1170:	90 93 6d 06 	sts	0x066D, r25
    1174:	80 93 6c 06 	sts	0x066C, r24
                pxOverflowDelayedCoRoutineList = pxTemp;
    1178:	89 81       	ldd	r24, Y+1	; 0x01
    117a:	9a 81       	ldd	r25, Y+2	; 0x02
    117c:	90 93 6f 06 	sts	0x066F, r25
    1180:	80 93 6e 06 	sts	0x066E, r24
    1184:	4f c0       	rjmp	.+158    	; 0x1224 <prvCheckDelayedList+0x120>
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
            {
                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1186:	e0 91 6c 06 	lds	r30, 0x066C
    118a:	f0 91 6d 06 	lds	r31, 0x066D
    118e:	05 80       	ldd	r0, Z+5	; 0x05
    1190:	f6 81       	ldd	r31, Z+6	; 0x06
    1192:	e0 2d       	mov	r30, r0
    1194:	86 81       	ldd	r24, Z+6	; 0x06
    1196:	97 81       	ldd	r25, Z+7	; 0x07
    1198:	9c 83       	std	Y+4, r25	; 0x04
    119a:	8b 83       	std	Y+3, r24	; 0x03

                if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    119c:	eb 81       	ldd	r30, Y+3	; 0x03
    119e:	fc 81       	ldd	r31, Y+4	; 0x04
    11a0:	22 81       	ldd	r18, Z+2	; 0x02
    11a2:	33 81       	ldd	r19, Z+3	; 0x03
    11a4:	80 91 73 06 	lds	r24, 0x0673
    11a8:	90 91 74 06 	lds	r25, 0x0674
    11ac:	82 17       	cp	r24, r18
    11ae:	93 07       	cpc	r25, r19
    11b0:	08 f4       	brcc	.+2      	; 0x11b4 <prvCheckDelayedList+0xb0>
    11b2:	40 c0       	rjmp	.+128    	; 0x1234 <prvCheckDelayedList+0x130>
                {
                    /* Timeout not yet expired. */
                    break;
                }

                portDISABLE_INTERRUPTS();
    11b4:	f8 94       	cli
                    /* The event could have occurred just before this critical
                     *  section.  If this is the case then the generic list item will
                     *  have been moved to the pending ready list and the following
                     *  line is still valid.  Also the pvContainer parameter will have
                     *  been set to NULL so the following lines are also valid. */
                    ( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    11b6:	8b 81       	ldd	r24, Y+3	; 0x03
    11b8:	9c 81       	ldd	r25, Y+4	; 0x04
    11ba:	02 96       	adiw	r24, 0x02	; 2
    11bc:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <uxListRemove>

                    /* Is the co-routine waiting on an event also? */
                    if( pxCRCB->xEventListItem.pxContainer )
    11c0:	eb 81       	ldd	r30, Y+3	; 0x03
    11c2:	fc 81       	ldd	r31, Y+4	; 0x04
    11c4:	84 89       	ldd	r24, Z+20	; 0x14
    11c6:	95 89       	ldd	r25, Z+21	; 0x15
    11c8:	00 97       	sbiw	r24, 0x00	; 0
    11ca:	29 f0       	breq	.+10     	; 0x11d6 <prvCheckDelayedList+0xd2>
                    {
                        ( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    11cc:	8b 81       	ldd	r24, Y+3	; 0x03
    11ce:	9c 81       	ldd	r25, Y+4	; 0x04
    11d0:	0c 96       	adiw	r24, 0x0c	; 12
    11d2:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <uxListRemove>
                    }
                }
                portENABLE_INTERRUPTS();
    11d6:	78 94       	sei

                prvAddCoRoutineToReadyQueue( pxCRCB );
    11d8:	eb 81       	ldd	r30, Y+3	; 0x03
    11da:	fc 81       	ldd	r31, Y+4	; 0x04
    11dc:	96 89       	ldd	r25, Z+22	; 0x16
    11de:	80 91 72 06 	lds	r24, 0x0672
    11e2:	89 17       	cp	r24, r25
    11e4:	28 f4       	brcc	.+10     	; 0x11f0 <prvCheckDelayedList+0xec>
    11e6:	eb 81       	ldd	r30, Y+3	; 0x03
    11e8:	fc 81       	ldd	r31, Y+4	; 0x04
    11ea:	86 89       	ldd	r24, Z+22	; 0x16
    11ec:	80 93 72 06 	sts	0x0672, r24
    11f0:	eb 81       	ldd	r30, Y+3	; 0x03
    11f2:	fc 81       	ldd	r31, Y+4	; 0x04
    11f4:	86 89       	ldd	r24, Z+22	; 0x16
    11f6:	28 2f       	mov	r18, r24
    11f8:	30 e0       	ldi	r19, 0x00	; 0
    11fa:	c9 01       	movw	r24, r18
    11fc:	88 0f       	add	r24, r24
    11fe:	99 1f       	adc	r25, r25
    1200:	88 0f       	add	r24, r24
    1202:	99 1f       	adc	r25, r25
    1204:	88 0f       	add	r24, r24
    1206:	99 1f       	adc	r25, r25
    1208:	82 0f       	add	r24, r18
    120a:	93 1f       	adc	r25, r19
    120c:	ac 01       	movw	r20, r24
    120e:	47 58       	subi	r20, 0x87	; 135
    1210:	59 4f       	sbci	r21, 0xF9	; 249
    1212:	8b 81       	ldd	r24, Y+3	; 0x03
    1214:	9c 81       	ldd	r25, Y+4	; 0x04
    1216:	9c 01       	movw	r18, r24
    1218:	2e 5f       	subi	r18, 0xFE	; 254
    121a:	3f 4f       	sbci	r19, 0xFF	; 255
    121c:	ca 01       	movw	r24, r20
    121e:	b9 01       	movw	r22, r18
    1220:	0e 94 a1 0d 	call	0x1b42	; 0x1b42 <vListInsertEnd>
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
                pxOverflowDelayedCoRoutineList = pxTemp;
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1224:	e0 91 6c 06 	lds	r30, 0x066C
    1228:	f0 91 6d 06 	lds	r31, 0x066D
    122c:	80 81       	ld	r24, Z
    122e:	88 23       	and	r24, r24
    1230:	09 f0       	breq	.+2      	; 0x1234 <prvCheckDelayedList+0x130>
    1232:	a9 cf       	rjmp	.-174    	; 0x1186 <prvCheckDelayedList+0x82>
    {
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;

        while( xPassedTicks )
    1234:	80 91 77 06 	lds	r24, 0x0677
    1238:	90 91 78 06 	lds	r25, 0x0678
    123c:	00 97       	sbiw	r24, 0x00	; 0
    123e:	09 f0       	breq	.+2      	; 0x1242 <prvCheckDelayedList+0x13e>
    1240:	74 cf       	rjmp	.-280    	; 0x112a <prvCheckDelayedList+0x26>

                prvAddCoRoutineToReadyQueue( pxCRCB );
            }
        }

        xLastTickCount = xCoRoutineTickCount;
    1242:	80 91 73 06 	lds	r24, 0x0673
    1246:	90 91 74 06 	lds	r25, 0x0674
    124a:	90 93 76 06 	sts	0x0676, r25
    124e:	80 93 75 06 	sts	0x0675, r24
    }
    1252:	0f 90       	pop	r0
    1254:	0f 90       	pop	r0
    1256:	0f 90       	pop	r0
    1258:	0f 90       	pop	r0
    125a:	cf 91       	pop	r28
    125c:	df 91       	pop	r29
    125e:	08 95       	ret

00001260 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

    void vCoRoutineSchedule( void )
    {
    1260:	df 93       	push	r29
    1262:	cf 93       	push	r28
    1264:	00 d0       	rcall	.+0      	; 0x1266 <vCoRoutineSchedule+0x6>
    1266:	cd b7       	in	r28, 0x3d	; 61
    1268:	de b7       	in	r29, 0x3e	; 62
        /* Only run a co-routine after prvInitialiseCoRoutineLists() has been
         * called.  prvInitialiseCoRoutineLists() is called automatically when a
         * co-routine is created. */
        if( pxDelayedCoRoutineList != NULL )
    126a:	80 91 6c 06 	lds	r24, 0x066C
    126e:	90 91 6d 06 	lds	r25, 0x066D
    1272:	00 97       	sbiw	r24, 0x00	; 0
    1274:	09 f4       	brne	.+2      	; 0x1278 <vCoRoutineSchedule+0x18>
    1276:	70 c0       	rjmp	.+224    	; 0x1358 <vCoRoutineSchedule+0xf8>
        {
            /* See if any co-routines readied by events need moving to the ready lists. */
            prvCheckPendingReadyList();
    1278:	0e 94 38 08 	call	0x1070	; 0x1070 <prvCheckPendingReadyList>

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();
    127c:	0e 94 82 08 	call	0x1104	; 0x1104 <prvCheckDelayedList>
    1280:	0a c0       	rjmp	.+20     	; 0x1296 <vCoRoutineSchedule+0x36>

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
            {
                if( uxTopCoRoutineReadyPriority == 0 )
    1282:	80 91 72 06 	lds	r24, 0x0672
    1286:	88 23       	and	r24, r24
    1288:	09 f4       	brne	.+2      	; 0x128c <vCoRoutineSchedule+0x2c>
    128a:	66 c0       	rjmp	.+204    	; 0x1358 <vCoRoutineSchedule+0xf8>
                {
                    /* No more co-routines to check. */
                    return;
                }

                --uxTopCoRoutineReadyPriority;
    128c:	80 91 72 06 	lds	r24, 0x0672
    1290:	81 50       	subi	r24, 0x01	; 1
    1292:	80 93 72 06 	sts	0x0672, r24

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1296:	80 91 72 06 	lds	r24, 0x0672
    129a:	28 2f       	mov	r18, r24
    129c:	30 e0       	ldi	r19, 0x00	; 0
    129e:	c9 01       	movw	r24, r18
    12a0:	88 0f       	add	r24, r24
    12a2:	99 1f       	adc	r25, r25
    12a4:	88 0f       	add	r24, r24
    12a6:	99 1f       	adc	r25, r25
    12a8:	88 0f       	add	r24, r24
    12aa:	99 1f       	adc	r25, r25
    12ac:	82 0f       	add	r24, r18
    12ae:	93 1f       	adc	r25, r19
    12b0:	fc 01       	movw	r30, r24
    12b2:	e7 58       	subi	r30, 0x87	; 135
    12b4:	f9 4f       	sbci	r31, 0xF9	; 249
    12b6:	80 81       	ld	r24, Z
    12b8:	88 23       	and	r24, r24
    12ba:	19 f3       	breq	.-58     	; 0x1282 <vCoRoutineSchedule+0x22>
                --uxTopCoRoutineReadyPriority;
            }

            /* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
             * of the same priority get an equal share of the processor time. */
            listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    12bc:	80 91 72 06 	lds	r24, 0x0672
    12c0:	28 2f       	mov	r18, r24
    12c2:	30 e0       	ldi	r19, 0x00	; 0
    12c4:	c9 01       	movw	r24, r18
    12c6:	88 0f       	add	r24, r24
    12c8:	99 1f       	adc	r25, r25
    12ca:	88 0f       	add	r24, r24
    12cc:	99 1f       	adc	r25, r25
    12ce:	88 0f       	add	r24, r24
    12d0:	99 1f       	adc	r25, r25
    12d2:	82 0f       	add	r24, r18
    12d4:	93 1f       	adc	r25, r19
    12d6:	87 58       	subi	r24, 0x87	; 135
    12d8:	99 4f       	sbci	r25, 0xF9	; 249
    12da:	9a 83       	std	Y+2, r25	; 0x02
    12dc:	89 83       	std	Y+1, r24	; 0x01
    12de:	e9 81       	ldd	r30, Y+1	; 0x01
    12e0:	fa 81       	ldd	r31, Y+2	; 0x02
    12e2:	01 80       	ldd	r0, Z+1	; 0x01
    12e4:	f2 81       	ldd	r31, Z+2	; 0x02
    12e6:	e0 2d       	mov	r30, r0
    12e8:	82 81       	ldd	r24, Z+2	; 0x02
    12ea:	93 81       	ldd	r25, Z+3	; 0x03
    12ec:	e9 81       	ldd	r30, Y+1	; 0x01
    12ee:	fa 81       	ldd	r31, Y+2	; 0x02
    12f0:	92 83       	std	Z+2, r25	; 0x02
    12f2:	81 83       	std	Z+1, r24	; 0x01
    12f4:	e9 81       	ldd	r30, Y+1	; 0x01
    12f6:	fa 81       	ldd	r31, Y+2	; 0x02
    12f8:	21 81       	ldd	r18, Z+1	; 0x01
    12fa:	32 81       	ldd	r19, Z+2	; 0x02
    12fc:	89 81       	ldd	r24, Y+1	; 0x01
    12fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1300:	03 96       	adiw	r24, 0x03	; 3
    1302:	28 17       	cp	r18, r24
    1304:	39 07       	cpc	r19, r25
    1306:	59 f4       	brne	.+22     	; 0x131e <vCoRoutineSchedule+0xbe>
    1308:	e9 81       	ldd	r30, Y+1	; 0x01
    130a:	fa 81       	ldd	r31, Y+2	; 0x02
    130c:	01 80       	ldd	r0, Z+1	; 0x01
    130e:	f2 81       	ldd	r31, Z+2	; 0x02
    1310:	e0 2d       	mov	r30, r0
    1312:	82 81       	ldd	r24, Z+2	; 0x02
    1314:	93 81       	ldd	r25, Z+3	; 0x03
    1316:	e9 81       	ldd	r30, Y+1	; 0x01
    1318:	fa 81       	ldd	r31, Y+2	; 0x02
    131a:	92 83       	std	Z+2, r25	; 0x02
    131c:	81 83       	std	Z+1, r24	; 0x01
    131e:	e9 81       	ldd	r30, Y+1	; 0x01
    1320:	fa 81       	ldd	r31, Y+2	; 0x02
    1322:	01 80       	ldd	r0, Z+1	; 0x01
    1324:	f2 81       	ldd	r31, Z+2	; 0x02
    1326:	e0 2d       	mov	r30, r0
    1328:	86 81       	ldd	r24, Z+6	; 0x06
    132a:	97 81       	ldd	r25, Z+7	; 0x07
    132c:	90 93 71 06 	sts	0x0671, r25
    1330:	80 93 70 06 	sts	0x0670, r24

            /* Call the co-routine. */
            ( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1334:	e0 91 70 06 	lds	r30, 0x0670
    1338:	f0 91 71 06 	lds	r31, 0x0671
    133c:	40 81       	ld	r20, Z
    133e:	51 81       	ldd	r21, Z+1	; 0x01
    1340:	80 91 70 06 	lds	r24, 0x0670
    1344:	90 91 71 06 	lds	r25, 0x0671
    1348:	e0 91 70 06 	lds	r30, 0x0670
    134c:	f0 91 71 06 	lds	r31, 0x0671
    1350:	27 89       	ldd	r18, Z+23	; 0x17
    1352:	62 2f       	mov	r22, r18
    1354:	fa 01       	movw	r30, r20
    1356:	09 95       	icall
        }
    }
    1358:	0f 90       	pop	r0
    135a:	0f 90       	pop	r0
    135c:	cf 91       	pop	r28
    135e:	df 91       	pop	r29
    1360:	08 95       	ret

00001362 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

    static void prvInitialiseCoRoutineLists( void )
    {
    1362:	df 93       	push	r29
    1364:	cf 93       	push	r28
    1366:	0f 92       	push	r0
    1368:	cd b7       	in	r28, 0x3d	; 61
    136a:	de b7       	in	r29, 0x3e	; 62
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    136c:	19 82       	std	Y+1, r1	; 0x01
    136e:	13 c0       	rjmp	.+38     	; 0x1396 <prvInitialiseCoRoutineLists+0x34>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1370:	89 81       	ldd	r24, Y+1	; 0x01
    1372:	28 2f       	mov	r18, r24
    1374:	30 e0       	ldi	r19, 0x00	; 0
    1376:	c9 01       	movw	r24, r18
    1378:	88 0f       	add	r24, r24
    137a:	99 1f       	adc	r25, r25
    137c:	88 0f       	add	r24, r24
    137e:	99 1f       	adc	r25, r25
    1380:	88 0f       	add	r24, r24
    1382:	99 1f       	adc	r25, r25
    1384:	82 0f       	add	r24, r18
    1386:	93 1f       	adc	r25, r19
    1388:	87 58       	subi	r24, 0x87	; 135
    138a:	99 4f       	sbci	r25, 0xF9	; 249
    138c:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInitialise>

    static void prvInitialiseCoRoutineLists( void )
    {
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1390:	89 81       	ldd	r24, Y+1	; 0x01
    1392:	8f 5f       	subi	r24, 0xFF	; 255
    1394:	89 83       	std	Y+1, r24	; 0x01
    1396:	89 81       	ldd	r24, Y+1	; 0x01
    1398:	82 30       	cpi	r24, 0x02	; 2
    139a:	50 f3       	brcs	.-44     	; 0x1370 <prvInitialiseCoRoutineLists+0xe>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
        }

        vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    139c:	8b e8       	ldi	r24, 0x8B	; 139
    139e:	96 e0       	ldi	r25, 0x06	; 6
    13a0:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInitialise>
        vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    13a4:	84 e9       	ldi	r24, 0x94	; 148
    13a6:	96 e0       	ldi	r25, 0x06	; 6
    13a8:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInitialise>
        vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    13ac:	8d e9       	ldi	r24, 0x9D	; 157
    13ae:	96 e0       	ldi	r25, 0x06	; 6
    13b0:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInitialise>

        /* Start with pxDelayedCoRoutineList using list1 and the
         * pxOverflowDelayedCoRoutineList using list2. */
        pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    13b4:	8b e8       	ldi	r24, 0x8B	; 139
    13b6:	96 e0       	ldi	r25, 0x06	; 6
    13b8:	90 93 6d 06 	sts	0x066D, r25
    13bc:	80 93 6c 06 	sts	0x066C, r24
        pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    13c0:	84 e9       	ldi	r24, 0x94	; 148
    13c2:	96 e0       	ldi	r25, 0x06	; 6
    13c4:	90 93 6f 06 	sts	0x066F, r25
    13c8:	80 93 6e 06 	sts	0x066E, r24
    }
    13cc:	0f 90       	pop	r0
    13ce:	cf 91       	pop	r28
    13d0:	df 91       	pop	r29
    13d2:	08 95       	ret

000013d4 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineRemoveFromEventList( const List_t * pxEventList )
    {
    13d4:	df 93       	push	r29
    13d6:	cf 93       	push	r28
    13d8:	00 d0       	rcall	.+0      	; 0x13da <xCoRoutineRemoveFromEventList+0x6>
    13da:	00 d0       	rcall	.+0      	; 0x13dc <xCoRoutineRemoveFromEventList+0x8>
    13dc:	0f 92       	push	r0
    13de:	cd b7       	in	r28, 0x3d	; 61
    13e0:	de b7       	in	r29, 0x3e	; 62
    13e2:	9d 83       	std	Y+5, r25	; 0x05
    13e4:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;

        /* This function is called from within an interrupt.  It can only access
         * event lists and the pending ready list.  This function assumes that a
         * check has already been made to ensure pxEventList is not empty. */
        pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    13e6:	ec 81       	ldd	r30, Y+4	; 0x04
    13e8:	fd 81       	ldd	r31, Y+5	; 0x05
    13ea:	05 80       	ldd	r0, Z+5	; 0x05
    13ec:	f6 81       	ldd	r31, Z+6	; 0x06
    13ee:	e0 2d       	mov	r30, r0
    13f0:	86 81       	ldd	r24, Z+6	; 0x06
    13f2:	97 81       	ldd	r25, Z+7	; 0x07
    13f4:	9b 83       	std	Y+3, r25	; 0x03
    13f6:	8a 83       	std	Y+2, r24	; 0x02
        ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    13f8:	8a 81       	ldd	r24, Y+2	; 0x02
    13fa:	9b 81       	ldd	r25, Y+3	; 0x03
    13fc:	0c 96       	adiw	r24, 0x0c	; 12
    13fe:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <uxListRemove>
        vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1402:	8a 81       	ldd	r24, Y+2	; 0x02
    1404:	9b 81       	ldd	r25, Y+3	; 0x03
    1406:	9c 01       	movw	r18, r24
    1408:	24 5f       	subi	r18, 0xF4	; 244
    140a:	3f 4f       	sbci	r19, 0xFF	; 255
    140c:	8d e9       	ldi	r24, 0x9D	; 157
    140e:	96 e0       	ldi	r25, 0x06	; 6
    1410:	b9 01       	movw	r22, r18
    1412:	0e 94 a1 0d 	call	0x1b42	; 0x1b42 <vListInsertEnd>

        if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    1416:	ea 81       	ldd	r30, Y+2	; 0x02
    1418:	fb 81       	ldd	r31, Y+3	; 0x03
    141a:	96 89       	ldd	r25, Z+22	; 0x16
    141c:	e0 91 70 06 	lds	r30, 0x0670
    1420:	f0 91 71 06 	lds	r31, 0x0671
    1424:	86 89       	ldd	r24, Z+22	; 0x16
    1426:	98 17       	cp	r25, r24
    1428:	18 f0       	brcs	.+6      	; 0x1430 <xCoRoutineRemoveFromEventList+0x5c>
        {
            xReturn = pdTRUE;
    142a:	81 e0       	ldi	r24, 0x01	; 1
    142c:	89 83       	std	Y+1, r24	; 0x01
    142e:	01 c0       	rjmp	.+2      	; 0x1432 <xCoRoutineRemoveFromEventList+0x5e>
        }
        else
        {
            xReturn = pdFALSE;
    1430:	19 82       	std	Y+1, r1	; 0x01
        }

        return xReturn;
    1432:	89 81       	ldd	r24, Y+1	; 0x01
    }
    1434:	0f 90       	pop	r0
    1436:	0f 90       	pop	r0
    1438:	0f 90       	pop	r0
    143a:	0f 90       	pop	r0
    143c:	0f 90       	pop	r0
    143e:	cf 91       	pop	r28
    1440:	df 91       	pop	r29
    1442:	08 95       	ret

00001444 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    1444:	df 93       	push	r29
    1446:	cf 93       	push	r28
    1448:	00 d0       	rcall	.+0      	; 0x144a <xEventGroupCreate+0x6>
    144a:	cd b7       	in	r28, 0x3d	; 61
    144c:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    144e:	8b e0       	ldi	r24, 0x0B	; 11
    1450:	90 e0       	ldi	r25, 0x00	; 0
    1452:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    1456:	9a 83       	std	Y+2, r25	; 0x02
    1458:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
    145a:	89 81       	ldd	r24, Y+1	; 0x01
    145c:	9a 81       	ldd	r25, Y+2	; 0x02
    145e:	00 97       	sbiw	r24, 0x00	; 0
    1460:	49 f0       	breq	.+18     	; 0x1474 <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
    1462:	e9 81       	ldd	r30, Y+1	; 0x01
    1464:	fa 81       	ldd	r31, Y+2	; 0x02
    1466:	11 82       	std	Z+1, r1	; 0x01
    1468:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    146a:	89 81       	ldd	r24, Y+1	; 0x01
    146c:	9a 81       	ldd	r25, Y+2	; 0x02
    146e:	02 96       	adiw	r24, 0x02	; 2
    1470:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    1474:	89 81       	ldd	r24, Y+1	; 0x01
    1476:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    1478:	0f 90       	pop	r0
    147a:	0f 90       	pop	r0
    147c:	cf 91       	pop	r28
    147e:	df 91       	pop	r29
    1480:	08 95       	ret

00001482 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    1482:	df 93       	push	r29
    1484:	cf 93       	push	r28
    1486:	cd b7       	in	r28, 0x3d	; 61
    1488:	de b7       	in	r29, 0x3e	; 62
    148a:	60 97       	sbiw	r28, 0x10	; 16
    148c:	0f b6       	in	r0, 0x3f	; 63
    148e:	f8 94       	cli
    1490:	de bf       	out	0x3e, r29	; 62
    1492:	0f be       	out	0x3f, r0	; 63
    1494:	cd bf       	out	0x3d, r28	; 61
    1496:	9a 87       	std	Y+10, r25	; 0x0a
    1498:	89 87       	std	Y+9, r24	; 0x09
    149a:	7c 87       	std	Y+12, r23	; 0x0c
    149c:	6b 87       	std	Y+11, r22	; 0x0b
    149e:	5e 87       	std	Y+14, r21	; 0x0e
    14a0:	4d 87       	std	Y+13, r20	; 0x0d
    14a2:	38 8b       	std	Y+16, r19	; 0x10
    14a4:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    14a6:	89 85       	ldd	r24, Y+9	; 0x09
    14a8:	9a 85       	ldd	r25, Y+10	; 0x0a
    14aa:	9c 83       	std	Y+4, r25	; 0x04
    14ac:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    14ae:	19 82       	std	Y+1, r1	; 0x01
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    14b0:	0e 94 44 1b 	call	0x3688	; 0x3688 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    14b4:	eb 81       	ldd	r30, Y+3	; 0x03
    14b6:	fc 81       	ldd	r31, Y+4	; 0x04
    14b8:	80 81       	ld	r24, Z
    14ba:	91 81       	ldd	r25, Z+1	; 0x01
    14bc:	98 87       	std	Y+8, r25	; 0x08
    14be:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    14c0:	89 85       	ldd	r24, Y+9	; 0x09
    14c2:	9a 85       	ldd	r25, Y+10	; 0x0a
    14c4:	2b 85       	ldd	r18, Y+11	; 0x0b
    14c6:	3c 85       	ldd	r19, Y+12	; 0x0c
    14c8:	b9 01       	movw	r22, r18
    14ca:	0e 94 18 0c 	call	0x1830	; 0x1830 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    14ce:	2f 81       	ldd	r18, Y+7	; 0x07
    14d0:	38 85       	ldd	r19, Y+8	; 0x08
    14d2:	8b 85       	ldd	r24, Y+11	; 0x0b
    14d4:	9c 85       	ldd	r25, Y+12	; 0x0c
    14d6:	28 2b       	or	r18, r24
    14d8:	39 2b       	or	r19, r25
    14da:	8d 85       	ldd	r24, Y+13	; 0x0d
    14dc:	9e 85       	ldd	r25, Y+14	; 0x0e
    14de:	28 23       	and	r18, r24
    14e0:	39 23       	and	r19, r25
    14e2:	8d 85       	ldd	r24, Y+13	; 0x0d
    14e4:	9e 85       	ldd	r25, Y+14	; 0x0e
    14e6:	28 17       	cp	r18, r24
    14e8:	39 07       	cpc	r19, r25
    14ea:	c9 f4       	brne	.+50     	; 0x151e <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    14ec:	2f 81       	ldd	r18, Y+7	; 0x07
    14ee:	38 85       	ldd	r19, Y+8	; 0x08
    14f0:	8b 85       	ldd	r24, Y+11	; 0x0b
    14f2:	9c 85       	ldd	r25, Y+12	; 0x0c
    14f4:	82 2b       	or	r24, r18
    14f6:	93 2b       	or	r25, r19
    14f8:	9e 83       	std	Y+6, r25	; 0x06
    14fa:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    14fc:	eb 81       	ldd	r30, Y+3	; 0x03
    14fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1500:	20 81       	ld	r18, Z
    1502:	31 81       	ldd	r19, Z+1	; 0x01
    1504:	8d 85       	ldd	r24, Y+13	; 0x0d
    1506:	9e 85       	ldd	r25, Y+14	; 0x0e
    1508:	80 95       	com	r24
    150a:	90 95       	com	r25
    150c:	82 23       	and	r24, r18
    150e:	93 23       	and	r25, r19
    1510:	eb 81       	ldd	r30, Y+3	; 0x03
    1512:	fc 81       	ldd	r31, Y+4	; 0x04
    1514:	91 83       	std	Z+1, r25	; 0x01
    1516:	80 83       	st	Z, r24

            xTicksToWait = 0;
    1518:	18 8a       	std	Y+16, r1	; 0x10
    151a:	1f 86       	std	Y+15, r1	; 0x0f
    151c:	1e c0       	rjmp	.+60     	; 0x155a <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    151e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1520:	98 89       	ldd	r25, Y+16	; 0x10
    1522:	00 97       	sbiw	r24, 0x00	; 0
    1524:	91 f0       	breq	.+36     	; 0x154a <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    1526:	8b 81       	ldd	r24, Y+3	; 0x03
    1528:	9c 81       	ldd	r25, Y+4	; 0x04
    152a:	bc 01       	movw	r22, r24
    152c:	6e 5f       	subi	r22, 0xFE	; 254
    152e:	7f 4f       	sbci	r23, 0xFF	; 255
    1530:	8d 85       	ldd	r24, Y+13	; 0x0d
    1532:	9e 85       	ldd	r25, Y+14	; 0x0e
    1534:	9c 01       	movw	r18, r24
    1536:	35 60       	ori	r19, 0x05	; 5
    1538:	4f 85       	ldd	r20, Y+15	; 0x0f
    153a:	58 89       	ldd	r21, Y+16	; 0x10
    153c:	cb 01       	movw	r24, r22
    153e:	b9 01       	movw	r22, r18
    1540:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    1544:	1e 82       	std	Y+6, r1	; 0x06
    1546:	1d 82       	std	Y+5, r1	; 0x05
    1548:	08 c0       	rjmp	.+16     	; 0x155a <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    154a:	eb 81       	ldd	r30, Y+3	; 0x03
    154c:	fc 81       	ldd	r31, Y+4	; 0x04
    154e:	80 81       	ld	r24, Z
    1550:	91 81       	ldd	r25, Z+1	; 0x01
    1552:	9e 83       	std	Y+6, r25	; 0x06
    1554:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
    1556:	81 e0       	ldi	r24, 0x01	; 1
    1558:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    155a:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>
    155e:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
    1560:	8f 85       	ldd	r24, Y+15	; 0x0f
    1562:	98 89       	ldd	r25, Y+16	; 0x10
    1564:	00 97       	sbiw	r24, 0x00	; 0
    1566:	09 f4       	brne	.+2      	; 0x156a <xEventGroupSync+0xe8>
    1568:	3a c0       	rjmp	.+116    	; 0x15de <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
    156a:	8a 81       	ldd	r24, Y+2	; 0x02
    156c:	88 23       	and	r24, r24
    156e:	11 f4       	brne	.+4      	; 0x1574 <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
    1570:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1574:	0e 94 d1 23 	call	0x47a2	; 0x47a2 <uxTaskResetEventItemValue>
    1578:	9e 83       	std	Y+6, r25	; 0x06
    157a:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    157c:	8d 81       	ldd	r24, Y+5	; 0x05
    157e:	9e 81       	ldd	r25, Y+6	; 0x06
    1580:	80 70       	andi	r24, 0x00	; 0
    1582:	92 70       	andi	r25, 0x02	; 2
    1584:	00 97       	sbiw	r24, 0x00	; 0
    1586:	31 f5       	brne	.+76     	; 0x15d4 <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    1588:	0f b6       	in	r0, 0x3f	; 63
    158a:	f8 94       	cli
    158c:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    158e:	eb 81       	ldd	r30, Y+3	; 0x03
    1590:	fc 81       	ldd	r31, Y+4	; 0x04
    1592:	80 81       	ld	r24, Z
    1594:	91 81       	ldd	r25, Z+1	; 0x01
    1596:	9e 83       	std	Y+6, r25	; 0x06
    1598:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    159a:	2d 81       	ldd	r18, Y+5	; 0x05
    159c:	3e 81       	ldd	r19, Y+6	; 0x06
    159e:	8d 85       	ldd	r24, Y+13	; 0x0d
    15a0:	9e 85       	ldd	r25, Y+14	; 0x0e
    15a2:	28 23       	and	r18, r24
    15a4:	39 23       	and	r19, r25
    15a6:	8d 85       	ldd	r24, Y+13	; 0x0d
    15a8:	9e 85       	ldd	r25, Y+14	; 0x0e
    15aa:	28 17       	cp	r18, r24
    15ac:	39 07       	cpc	r19, r25
    15ae:	71 f4       	brne	.+28     	; 0x15cc <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    15b0:	eb 81       	ldd	r30, Y+3	; 0x03
    15b2:	fc 81       	ldd	r31, Y+4	; 0x04
    15b4:	20 81       	ld	r18, Z
    15b6:	31 81       	ldd	r19, Z+1	; 0x01
    15b8:	8d 85       	ldd	r24, Y+13	; 0x0d
    15ba:	9e 85       	ldd	r25, Y+14	; 0x0e
    15bc:	80 95       	com	r24
    15be:	90 95       	com	r25
    15c0:	82 23       	and	r24, r18
    15c2:	93 23       	and	r25, r19
    15c4:	eb 81       	ldd	r30, Y+3	; 0x03
    15c6:	fc 81       	ldd	r31, Y+4	; 0x04
    15c8:	91 83       	std	Z+1, r25	; 0x01
    15ca:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    15cc:	0f 90       	pop	r0
    15ce:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
    15d0:	81 e0       	ldi	r24, 0x01	; 1
    15d2:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    15d4:	8d 81       	ldd	r24, Y+5	; 0x05
    15d6:	9e 81       	ldd	r25, Y+6	; 0x06
    15d8:	90 70       	andi	r25, 0x00	; 0
    15da:	9e 83       	std	Y+6, r25	; 0x06
    15dc:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    15de:	8d 81       	ldd	r24, Y+5	; 0x05
    15e0:	9e 81       	ldd	r25, Y+6	; 0x06
}
    15e2:	60 96       	adiw	r28, 0x10	; 16
    15e4:	0f b6       	in	r0, 0x3f	; 63
    15e6:	f8 94       	cli
    15e8:	de bf       	out	0x3e, r29	; 62
    15ea:	0f be       	out	0x3f, r0	; 63
    15ec:	cd bf       	out	0x3d, r28	; 61
    15ee:	cf 91       	pop	r28
    15f0:	df 91       	pop	r29
    15f2:	08 95       	ret

000015f4 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    15f4:	0f 93       	push	r16
    15f6:	1f 93       	push	r17
    15f8:	df 93       	push	r29
    15fa:	cf 93       	push	r28
    15fc:	cd b7       	in	r28, 0x3d	; 61
    15fe:	de b7       	in	r29, 0x3e	; 62
    1600:	63 97       	sbiw	r28, 0x13	; 19
    1602:	0f b6       	in	r0, 0x3f	; 63
    1604:	f8 94       	cli
    1606:	de bf       	out	0x3e, r29	; 62
    1608:	0f be       	out	0x3f, r0	; 63
    160a:	cd bf       	out	0x3d, r28	; 61
    160c:	9d 87       	std	Y+13, r25	; 0x0d
    160e:	8c 87       	std	Y+12, r24	; 0x0c
    1610:	7f 87       	std	Y+15, r23	; 0x0f
    1612:	6e 87       	std	Y+14, r22	; 0x0e
    1614:	48 8b       	std	Y+16, r20	; 0x10
    1616:	29 8b       	std	Y+17, r18	; 0x11
    1618:	1b 8b       	std	Y+19, r17	; 0x13
    161a:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
    161c:	8c 85       	ldd	r24, Y+12	; 0x0c
    161e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1620:	9b 87       	std	Y+11, r25	; 0x0b
    1622:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
    1624:	1f 82       	std	Y+7, r1	; 0x07
    1626:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    1628:	1b 82       	std	Y+3, r1	; 0x03
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    162a:	0e 94 44 1b 	call	0x3688	; 0x3688 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    162e:	ea 85       	ldd	r30, Y+10	; 0x0a
    1630:	fb 85       	ldd	r31, Y+11	; 0x0b
    1632:	80 81       	ld	r24, Z
    1634:	91 81       	ldd	r25, Z+1	; 0x01
    1636:	9a 83       	std	Y+2, r25	; 0x02
    1638:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    163a:	89 81       	ldd	r24, Y+1	; 0x01
    163c:	9a 81       	ldd	r25, Y+2	; 0x02
    163e:	2e 85       	ldd	r18, Y+14	; 0x0e
    1640:	3f 85       	ldd	r19, Y+15	; 0x0f
    1642:	b9 01       	movw	r22, r18
    1644:	49 89       	ldd	r20, Y+17	; 0x11
    1646:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <prvTestWaitCondition>
    164a:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
    164c:	8d 81       	ldd	r24, Y+5	; 0x05
    164e:	88 23       	and	r24, r24
    1650:	c1 f0       	breq	.+48     	; 0x1682 <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    1652:	89 81       	ldd	r24, Y+1	; 0x01
    1654:	9a 81       	ldd	r25, Y+2	; 0x02
    1656:	99 87       	std	Y+9, r25	; 0x09
    1658:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
    165a:	1b 8a       	std	Y+19, r1	; 0x13
    165c:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    165e:	88 89       	ldd	r24, Y+16	; 0x10
    1660:	88 23       	and	r24, r24
    1662:	e9 f1       	breq	.+122    	; 0x16de <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1664:	ea 85       	ldd	r30, Y+10	; 0x0a
    1666:	fb 85       	ldd	r31, Y+11	; 0x0b
    1668:	20 81       	ld	r18, Z
    166a:	31 81       	ldd	r19, Z+1	; 0x01
    166c:	8e 85       	ldd	r24, Y+14	; 0x0e
    166e:	9f 85       	ldd	r25, Y+15	; 0x0f
    1670:	80 95       	com	r24
    1672:	90 95       	com	r25
    1674:	82 23       	and	r24, r18
    1676:	93 23       	and	r25, r19
    1678:	ea 85       	ldd	r30, Y+10	; 0x0a
    167a:	fb 85       	ldd	r31, Y+11	; 0x0b
    167c:	91 83       	std	Z+1, r25	; 0x01
    167e:	80 83       	st	Z, r24
    1680:	2e c0       	rjmp	.+92     	; 0x16de <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    1682:	8a 89       	ldd	r24, Y+18	; 0x12
    1684:	9b 89       	ldd	r25, Y+19	; 0x13
    1686:	00 97       	sbiw	r24, 0x00	; 0
    1688:	39 f4       	brne	.+14     	; 0x1698 <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    168a:	89 81       	ldd	r24, Y+1	; 0x01
    168c:	9a 81       	ldd	r25, Y+2	; 0x02
    168e:	99 87       	std	Y+9, r25	; 0x09
    1690:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
    1692:	81 e0       	ldi	r24, 0x01	; 1
    1694:	8b 83       	std	Y+3, r24	; 0x03
    1696:	23 c0       	rjmp	.+70     	; 0x16de <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    1698:	88 89       	ldd	r24, Y+16	; 0x10
    169a:	88 23       	and	r24, r24
    169c:	29 f0       	breq	.+10     	; 0x16a8 <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    169e:	8e 81       	ldd	r24, Y+6	; 0x06
    16a0:	9f 81       	ldd	r25, Y+7	; 0x07
    16a2:	91 60       	ori	r25, 0x01	; 1
    16a4:	9f 83       	std	Y+7, r25	; 0x07
    16a6:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    16a8:	89 89       	ldd	r24, Y+17	; 0x11
    16aa:	88 23       	and	r24, r24
    16ac:	29 f0       	breq	.+10     	; 0x16b8 <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    16ae:	8e 81       	ldd	r24, Y+6	; 0x06
    16b0:	9f 81       	ldd	r25, Y+7	; 0x07
    16b2:	94 60       	ori	r25, 0x04	; 4
    16b4:	9f 83       	std	Y+7, r25	; 0x07
    16b6:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    16b8:	8a 85       	ldd	r24, Y+10	; 0x0a
    16ba:	9b 85       	ldd	r25, Y+11	; 0x0b
    16bc:	bc 01       	movw	r22, r24
    16be:	6e 5f       	subi	r22, 0xFE	; 254
    16c0:	7f 4f       	sbci	r23, 0xFF	; 255
    16c2:	2e 85       	ldd	r18, Y+14	; 0x0e
    16c4:	3f 85       	ldd	r19, Y+15	; 0x0f
    16c6:	8e 81       	ldd	r24, Y+6	; 0x06
    16c8:	9f 81       	ldd	r25, Y+7	; 0x07
    16ca:	28 2b       	or	r18, r24
    16cc:	39 2b       	or	r19, r25
    16ce:	4a 89       	ldd	r20, Y+18	; 0x12
    16d0:	5b 89       	ldd	r21, Y+19	; 0x13
    16d2:	cb 01       	movw	r24, r22
    16d4:	b9 01       	movw	r22, r18
    16d6:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    16da:	19 86       	std	Y+9, r1	; 0x09
    16dc:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    16de:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>
    16e2:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
    16e4:	8a 89       	ldd	r24, Y+18	; 0x12
    16e6:	9b 89       	ldd	r25, Y+19	; 0x13
    16e8:	00 97       	sbiw	r24, 0x00	; 0
    16ea:	09 f4       	brne	.+2      	; 0x16ee <xEventGroupWaitBits+0xfa>
    16ec:	3c c0       	rjmp	.+120    	; 0x1766 <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
    16ee:	8c 81       	ldd	r24, Y+4	; 0x04
    16f0:	88 23       	and	r24, r24
    16f2:	11 f4       	brne	.+4      	; 0x16f8 <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
    16f4:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    16f8:	0e 94 d1 23 	call	0x47a2	; 0x47a2 <uxTaskResetEventItemValue>
    16fc:	99 87       	std	Y+9, r25	; 0x09
    16fe:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1700:	88 85       	ldd	r24, Y+8	; 0x08
    1702:	99 85       	ldd	r25, Y+9	; 0x09
    1704:	80 70       	andi	r24, 0x00	; 0
    1706:	92 70       	andi	r25, 0x02	; 2
    1708:	00 97       	sbiw	r24, 0x00	; 0
    170a:	41 f5       	brne	.+80     	; 0x175c <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
    170c:	0f b6       	in	r0, 0x3f	; 63
    170e:	f8 94       	cli
    1710:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1712:	ea 85       	ldd	r30, Y+10	; 0x0a
    1714:	fb 85       	ldd	r31, Y+11	; 0x0b
    1716:	80 81       	ld	r24, Z
    1718:	91 81       	ldd	r25, Z+1	; 0x01
    171a:	99 87       	std	Y+9, r25	; 0x09
    171c:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    171e:	88 85       	ldd	r24, Y+8	; 0x08
    1720:	99 85       	ldd	r25, Y+9	; 0x09
    1722:	2e 85       	ldd	r18, Y+14	; 0x0e
    1724:	3f 85       	ldd	r19, Y+15	; 0x0f
    1726:	b9 01       	movw	r22, r18
    1728:	49 89       	ldd	r20, Y+17	; 0x11
    172a:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <prvTestWaitCondition>
    172e:	88 23       	and	r24, r24
    1730:	89 f0       	breq	.+34     	; 0x1754 <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
    1732:	88 89       	ldd	r24, Y+16	; 0x10
    1734:	88 23       	and	r24, r24
    1736:	71 f0       	breq	.+28     	; 0x1754 <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1738:	ea 85       	ldd	r30, Y+10	; 0x0a
    173a:	fb 85       	ldd	r31, Y+11	; 0x0b
    173c:	20 81       	ld	r18, Z
    173e:	31 81       	ldd	r19, Z+1	; 0x01
    1740:	8e 85       	ldd	r24, Y+14	; 0x0e
    1742:	9f 85       	ldd	r25, Y+15	; 0x0f
    1744:	80 95       	com	r24
    1746:	90 95       	com	r25
    1748:	82 23       	and	r24, r18
    174a:	93 23       	and	r25, r19
    174c:	ea 85       	ldd	r30, Y+10	; 0x0a
    174e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1750:	91 83       	std	Z+1, r25	; 0x01
    1752:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    1754:	81 e0       	ldi	r24, 0x01	; 1
    1756:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    1758:	0f 90       	pop	r0
    175a:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    175c:	88 85       	ldd	r24, Y+8	; 0x08
    175e:	99 85       	ldd	r25, Y+9	; 0x09
    1760:	90 70       	andi	r25, 0x00	; 0
    1762:	99 87       	std	Y+9, r25	; 0x09
    1764:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    1766:	88 85       	ldd	r24, Y+8	; 0x08
    1768:	99 85       	ldd	r25, Y+9	; 0x09
}
    176a:	63 96       	adiw	r28, 0x13	; 19
    176c:	0f b6       	in	r0, 0x3f	; 63
    176e:	f8 94       	cli
    1770:	de bf       	out	0x3e, r29	; 62
    1772:	0f be       	out	0x3f, r0	; 63
    1774:	cd bf       	out	0x3d, r28	; 61
    1776:	cf 91       	pop	r28
    1778:	df 91       	pop	r29
    177a:	1f 91       	pop	r17
    177c:	0f 91       	pop	r16
    177e:	08 95       	ret

00001780 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    1780:	df 93       	push	r29
    1782:	cf 93       	push	r28
    1784:	cd b7       	in	r28, 0x3d	; 61
    1786:	de b7       	in	r29, 0x3e	; 62
    1788:	28 97       	sbiw	r28, 0x08	; 8
    178a:	0f b6       	in	r0, 0x3f	; 63
    178c:	f8 94       	cli
    178e:	de bf       	out	0x3e, r29	; 62
    1790:	0f be       	out	0x3f, r0	; 63
    1792:	cd bf       	out	0x3d, r28	; 61
    1794:	9e 83       	std	Y+6, r25	; 0x06
    1796:	8d 83       	std	Y+5, r24	; 0x05
    1798:	78 87       	std	Y+8, r23	; 0x08
    179a:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    179c:	8d 81       	ldd	r24, Y+5	; 0x05
    179e:	9e 81       	ldd	r25, Y+6	; 0x06
    17a0:	9c 83       	std	Y+4, r25	; 0x04
    17a2:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    17a4:	0f b6       	in	r0, 0x3f	; 63
    17a6:	f8 94       	cli
    17a8:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    17aa:	eb 81       	ldd	r30, Y+3	; 0x03
    17ac:	fc 81       	ldd	r31, Y+4	; 0x04
    17ae:	80 81       	ld	r24, Z
    17b0:	91 81       	ldd	r25, Z+1	; 0x01
    17b2:	9a 83       	std	Y+2, r25	; 0x02
    17b4:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    17b6:	eb 81       	ldd	r30, Y+3	; 0x03
    17b8:	fc 81       	ldd	r31, Y+4	; 0x04
    17ba:	20 81       	ld	r18, Z
    17bc:	31 81       	ldd	r19, Z+1	; 0x01
    17be:	8f 81       	ldd	r24, Y+7	; 0x07
    17c0:	98 85       	ldd	r25, Y+8	; 0x08
    17c2:	80 95       	com	r24
    17c4:	90 95       	com	r25
    17c6:	82 23       	and	r24, r18
    17c8:	93 23       	and	r25, r19
    17ca:	eb 81       	ldd	r30, Y+3	; 0x03
    17cc:	fc 81       	ldd	r31, Y+4	; 0x04
    17ce:	91 83       	std	Z+1, r25	; 0x01
    17d0:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    17d2:	0f 90       	pop	r0
    17d4:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    17d6:	89 81       	ldd	r24, Y+1	; 0x01
    17d8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    17da:	28 96       	adiw	r28, 0x08	; 8
    17dc:	0f b6       	in	r0, 0x3f	; 63
    17de:	f8 94       	cli
    17e0:	de bf       	out	0x3e, r29	; 62
    17e2:	0f be       	out	0x3f, r0	; 63
    17e4:	cd bf       	out	0x3d, r28	; 61
    17e6:	cf 91       	pop	r28
    17e8:	df 91       	pop	r29
    17ea:	08 95       	ret

000017ec <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    17ec:	df 93       	push	r29
    17ee:	cf 93       	push	r28
    17f0:	cd b7       	in	r28, 0x3d	; 61
    17f2:	de b7       	in	r29, 0x3e	; 62
    17f4:	27 97       	sbiw	r28, 0x07	; 7
    17f6:	0f b6       	in	r0, 0x3f	; 63
    17f8:	f8 94       	cli
    17fa:	de bf       	out	0x3e, r29	; 62
    17fc:	0f be       	out	0x3f, r0	; 63
    17fe:	cd bf       	out	0x3d, r28	; 61
    1800:	9f 83       	std	Y+7, r25	; 0x07
    1802:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    1804:	8e 81       	ldd	r24, Y+6	; 0x06
    1806:	9f 81       	ldd	r25, Y+7	; 0x07
    1808:	9c 83       	std	Y+4, r25	; 0x04
    180a:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    180c:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    180e:	eb 81       	ldd	r30, Y+3	; 0x03
    1810:	fc 81       	ldd	r31, Y+4	; 0x04
    1812:	80 81       	ld	r24, Z
    1814:	91 81       	ldd	r25, Z+1	; 0x01
    1816:	9a 83       	std	Y+2, r25	; 0x02
    1818:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    181a:	89 81       	ldd	r24, Y+1	; 0x01
    181c:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    181e:	27 96       	adiw	r28, 0x07	; 7
    1820:	0f b6       	in	r0, 0x3f	; 63
    1822:	f8 94       	cli
    1824:	de bf       	out	0x3e, r29	; 62
    1826:	0f be       	out	0x3f, r0	; 63
    1828:	cd bf       	out	0x3d, r28	; 61
    182a:	cf 91       	pop	r28
    182c:	df 91       	pop	r29
    182e:	08 95       	ret

00001830 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    1830:	df 93       	push	r29
    1832:	cf 93       	push	r28
    1834:	cd b7       	in	r28, 0x3d	; 61
    1836:	de b7       	in	r29, 0x3e	; 62
    1838:	65 97       	sbiw	r28, 0x15	; 21
    183a:	0f b6       	in	r0, 0x3f	; 63
    183c:	f8 94       	cli
    183e:	de bf       	out	0x3e, r29	; 62
    1840:	0f be       	out	0x3f, r0	; 63
    1842:	cd bf       	out	0x3d, r28	; 61
    1844:	9b 8b       	std	Y+19, r25	; 0x13
    1846:	8a 8b       	std	Y+18, r24	; 0x12
    1848:	7d 8b       	std	Y+21, r23	; 0x15
    184a:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    184c:	19 86       	std	Y+9, r1	; 0x09
    184e:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    1850:	8a 89       	ldd	r24, Y+18	; 0x12
    1852:	9b 89       	ldd	r25, Y+19	; 0x13
    1854:	9b 83       	std	Y+3, r25	; 0x03
    1856:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    1858:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    185a:	8a 81       	ldd	r24, Y+2	; 0x02
    185c:	9b 81       	ldd	r25, Y+3	; 0x03
    185e:	02 96       	adiw	r24, 0x02	; 2
    1860:	9b 87       	std	Y+11, r25	; 0x0b
    1862:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1864:	8a 85       	ldd	r24, Y+10	; 0x0a
    1866:	9b 85       	ldd	r25, Y+11	; 0x0b
    1868:	03 96       	adiw	r24, 0x03	; 3
    186a:	9d 87       	std	Y+13, r25	; 0x0d
    186c:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    186e:	0e 94 44 1b 	call	0x3688	; 0x3688 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    1872:	ea 85       	ldd	r30, Y+10	; 0x0a
    1874:	fb 85       	ldd	r31, Y+11	; 0x0b
    1876:	85 81       	ldd	r24, Z+5	; 0x05
    1878:	96 81       	ldd	r25, Z+6	; 0x06
    187a:	99 8b       	std	Y+17, r25	; 0x11
    187c:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    187e:	ea 81       	ldd	r30, Y+2	; 0x02
    1880:	fb 81       	ldd	r31, Y+3	; 0x03
    1882:	20 81       	ld	r18, Z
    1884:	31 81       	ldd	r19, Z+1	; 0x01
    1886:	8c 89       	ldd	r24, Y+20	; 0x14
    1888:	9d 89       	ldd	r25, Y+21	; 0x15
    188a:	82 2b       	or	r24, r18
    188c:	93 2b       	or	r25, r19
    188e:	ea 81       	ldd	r30, Y+2	; 0x02
    1890:	fb 81       	ldd	r31, Y+3	; 0x03
    1892:	91 83       	std	Z+1, r25	; 0x01
    1894:	80 83       	st	Z, r24
    1896:	59 c0       	rjmp	.+178    	; 0x194a <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    1898:	e8 89       	ldd	r30, Y+16	; 0x10
    189a:	f9 89       	ldd	r31, Y+17	; 0x11
    189c:	82 81       	ldd	r24, Z+2	; 0x02
    189e:	93 81       	ldd	r25, Z+3	; 0x03
    18a0:	9f 87       	std	Y+15, r25	; 0x0f
    18a2:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    18a4:	e8 89       	ldd	r30, Y+16	; 0x10
    18a6:	f9 89       	ldd	r31, Y+17	; 0x11
    18a8:	80 81       	ld	r24, Z
    18aa:	91 81       	ldd	r25, Z+1	; 0x01
    18ac:	9f 83       	std	Y+7, r25	; 0x07
    18ae:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    18b0:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    18b2:	8e 81       	ldd	r24, Y+6	; 0x06
    18b4:	9f 81       	ldd	r25, Y+7	; 0x07
    18b6:	80 70       	andi	r24, 0x00	; 0
    18b8:	9d 83       	std	Y+5, r25	; 0x05
    18ba:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    18bc:	8e 81       	ldd	r24, Y+6	; 0x06
    18be:	9f 81       	ldd	r25, Y+7	; 0x07
    18c0:	90 70       	andi	r25, 0x00	; 0
    18c2:	9f 83       	std	Y+7, r25	; 0x07
    18c4:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    18c6:	8c 81       	ldd	r24, Y+4	; 0x04
    18c8:	9d 81       	ldd	r25, Y+5	; 0x05
    18ca:	80 70       	andi	r24, 0x00	; 0
    18cc:	94 70       	andi	r25, 0x04	; 4
    18ce:	00 97       	sbiw	r24, 0x00	; 0
    18d0:	69 f4       	brne	.+26     	; 0x18ec <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    18d2:	ea 81       	ldd	r30, Y+2	; 0x02
    18d4:	fb 81       	ldd	r31, Y+3	; 0x03
    18d6:	20 81       	ld	r18, Z
    18d8:	31 81       	ldd	r19, Z+1	; 0x01
    18da:	8e 81       	ldd	r24, Y+6	; 0x06
    18dc:	9f 81       	ldd	r25, Y+7	; 0x07
    18de:	82 23       	and	r24, r18
    18e0:	93 23       	and	r25, r19
    18e2:	00 97       	sbiw	r24, 0x00	; 0
    18e4:	91 f0       	breq	.+36     	; 0x190a <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    18e6:	81 e0       	ldi	r24, 0x01	; 1
    18e8:	89 83       	std	Y+1, r24	; 0x01
    18ea:	0f c0       	rjmp	.+30     	; 0x190a <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    18ec:	ea 81       	ldd	r30, Y+2	; 0x02
    18ee:	fb 81       	ldd	r31, Y+3	; 0x03
    18f0:	20 81       	ld	r18, Z
    18f2:	31 81       	ldd	r19, Z+1	; 0x01
    18f4:	8e 81       	ldd	r24, Y+6	; 0x06
    18f6:	9f 81       	ldd	r25, Y+7	; 0x07
    18f8:	28 23       	and	r18, r24
    18fa:	39 23       	and	r19, r25
    18fc:	8e 81       	ldd	r24, Y+6	; 0x06
    18fe:	9f 81       	ldd	r25, Y+7	; 0x07
    1900:	28 17       	cp	r18, r24
    1902:	39 07       	cpc	r19, r25
    1904:	11 f4       	brne	.+4      	; 0x190a <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    1906:	81 e0       	ldi	r24, 0x01	; 1
    1908:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    190a:	89 81       	ldd	r24, Y+1	; 0x01
    190c:	88 23       	and	r24, r24
    190e:	c9 f0       	breq	.+50     	; 0x1942 <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1910:	8c 81       	ldd	r24, Y+4	; 0x04
    1912:	9d 81       	ldd	r25, Y+5	; 0x05
    1914:	80 70       	andi	r24, 0x00	; 0
    1916:	91 70       	andi	r25, 0x01	; 1
    1918:	00 97       	sbiw	r24, 0x00	; 0
    191a:	41 f0       	breq	.+16     	; 0x192c <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    191c:	88 85       	ldd	r24, Y+8	; 0x08
    191e:	99 85       	ldd	r25, Y+9	; 0x09
    1920:	2e 81       	ldd	r18, Y+6	; 0x06
    1922:	3f 81       	ldd	r19, Y+7	; 0x07
    1924:	82 2b       	or	r24, r18
    1926:	93 2b       	or	r25, r19
    1928:	99 87       	std	Y+9, r25	; 0x09
    192a:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    192c:	ea 81       	ldd	r30, Y+2	; 0x02
    192e:	fb 81       	ldd	r31, Y+3	; 0x03
    1930:	80 81       	ld	r24, Z
    1932:	91 81       	ldd	r25, Z+1	; 0x01
    1934:	9c 01       	movw	r18, r24
    1936:	32 60       	ori	r19, 0x02	; 2
    1938:	88 89       	ldd	r24, Y+16	; 0x10
    193a:	99 89       	ldd	r25, Y+17	; 0x11
    193c:	b9 01       	movw	r22, r18
    193e:	0e 94 4e 21 	call	0x429c	; 0x429c <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    1942:	8e 85       	ldd	r24, Y+14	; 0x0e
    1944:	9f 85       	ldd	r25, Y+15	; 0x0f
    1946:	99 8b       	std	Y+17, r25	; 0x11
    1948:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    194a:	28 89       	ldd	r18, Y+16	; 0x10
    194c:	39 89       	ldd	r19, Y+17	; 0x11
    194e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1950:	9d 85       	ldd	r25, Y+13	; 0x0d
    1952:	28 17       	cp	r18, r24
    1954:	39 07       	cpc	r19, r25
    1956:	09 f0       	breq	.+2      	; 0x195a <xEventGroupSetBits+0x12a>
    1958:	9f cf       	rjmp	.-194    	; 0x1898 <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    195a:	ea 81       	ldd	r30, Y+2	; 0x02
    195c:	fb 81       	ldd	r31, Y+3	; 0x03
    195e:	20 81       	ld	r18, Z
    1960:	31 81       	ldd	r19, Z+1	; 0x01
    1962:	88 85       	ldd	r24, Y+8	; 0x08
    1964:	99 85       	ldd	r25, Y+9	; 0x09
    1966:	80 95       	com	r24
    1968:	90 95       	com	r25
    196a:	82 23       	and	r24, r18
    196c:	93 23       	and	r25, r19
    196e:	ea 81       	ldd	r30, Y+2	; 0x02
    1970:	fb 81       	ldd	r31, Y+3	; 0x03
    1972:	91 83       	std	Z+1, r25	; 0x01
    1974:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    1976:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    197a:	ea 81       	ldd	r30, Y+2	; 0x02
    197c:	fb 81       	ldd	r31, Y+3	; 0x03
    197e:	80 81       	ld	r24, Z
    1980:	91 81       	ldd	r25, Z+1	; 0x01
}
    1982:	65 96       	adiw	r28, 0x15	; 21
    1984:	0f b6       	in	r0, 0x3f	; 63
    1986:	f8 94       	cli
    1988:	de bf       	out	0x3e, r29	; 62
    198a:	0f be       	out	0x3f, r0	; 63
    198c:	cd bf       	out	0x3d, r28	; 61
    198e:	cf 91       	pop	r28
    1990:	df 91       	pop	r29
    1992:	08 95       	ret

00001994 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1994:	df 93       	push	r29
    1996:	cf 93       	push	r28
    1998:	00 d0       	rcall	.+0      	; 0x199a <vEventGroupDelete+0x6>
    199a:	00 d0       	rcall	.+0      	; 0x199c <vEventGroupDelete+0x8>
    199c:	00 d0       	rcall	.+0      	; 0x199e <vEventGroupDelete+0xa>
    199e:	cd b7       	in	r28, 0x3d	; 61
    19a0:	de b7       	in	r29, 0x3e	; 62
    19a2:	9e 83       	std	Y+6, r25	; 0x06
    19a4:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    19a6:	8d 81       	ldd	r24, Y+5	; 0x05
    19a8:	9e 81       	ldd	r25, Y+6	; 0x06
    19aa:	9c 83       	std	Y+4, r25	; 0x04
    19ac:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    19ae:	8b 81       	ldd	r24, Y+3	; 0x03
    19b0:	9c 81       	ldd	r25, Y+4	; 0x04
    19b2:	02 96       	adiw	r24, 0x02	; 2
    19b4:	9a 83       	std	Y+2, r25	; 0x02
    19b6:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    19b8:	0e 94 44 1b 	call	0x3688	; 0x3688 <vTaskSuspendAll>
    19bc:	08 c0       	rjmp	.+16     	; 0x19ce <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    19be:	e9 81       	ldd	r30, Y+1	; 0x01
    19c0:	fa 81       	ldd	r31, Y+2	; 0x02
    19c2:	85 81       	ldd	r24, Z+5	; 0x05
    19c4:	96 81       	ldd	r25, Z+6	; 0x06
    19c6:	60 e0       	ldi	r22, 0x00	; 0
    19c8:	72 e0       	ldi	r23, 0x02	; 2
    19ca:	0e 94 4e 21 	call	0x429c	; 0x429c <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    19ce:	e9 81       	ldd	r30, Y+1	; 0x01
    19d0:	fa 81       	ldd	r31, Y+2	; 0x02
    19d2:	80 81       	ld	r24, Z
    19d4:	88 23       	and	r24, r24
    19d6:	99 f7       	brne	.-26     	; 0x19be <vEventGroupDelete+0x2a>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
    19d8:	8b 81       	ldd	r24, Y+3	; 0x03
    19da:	9c 81       	ldd	r25, Y+4	; 0x04
    19dc:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
    19e0:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>
}
    19e4:	26 96       	adiw	r28, 0x06	; 6
    19e6:	0f b6       	in	r0, 0x3f	; 63
    19e8:	f8 94       	cli
    19ea:	de bf       	out	0x3e, r29	; 62
    19ec:	0f be       	out	0x3f, r0	; 63
    19ee:	cd bf       	out	0x3d, r28	; 61
    19f0:	cf 91       	pop	r28
    19f2:	df 91       	pop	r29
    19f4:	08 95       	ret

000019f6 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    19f6:	df 93       	push	r29
    19f8:	cf 93       	push	r28
    19fa:	00 d0       	rcall	.+0      	; 0x19fc <vEventGroupSetBitsCallback+0x6>
    19fc:	00 d0       	rcall	.+0      	; 0x19fe <vEventGroupSetBitsCallback+0x8>
    19fe:	00 d0       	rcall	.+0      	; 0x1a00 <vEventGroupSetBitsCallback+0xa>
    1a00:	cd b7       	in	r28, 0x3d	; 61
    1a02:	de b7       	in	r29, 0x3e	; 62
    1a04:	9a 83       	std	Y+2, r25	; 0x02
    1a06:	89 83       	std	Y+1, r24	; 0x01
    1a08:	4b 83       	std	Y+3, r20	; 0x03
    1a0a:	5c 83       	std	Y+4, r21	; 0x04
    1a0c:	6d 83       	std	Y+5, r22	; 0x05
    1a0e:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1a10:	89 81       	ldd	r24, Y+1	; 0x01
    1a12:	9a 81       	ldd	r25, Y+2	; 0x02
    1a14:	2b 81       	ldd	r18, Y+3	; 0x03
    1a16:	3c 81       	ldd	r19, Y+4	; 0x04
    1a18:	b9 01       	movw	r22, r18
    1a1a:	0e 94 18 0c 	call	0x1830	; 0x1830 <xEventGroupSetBits>
}
    1a1e:	26 96       	adiw	r28, 0x06	; 6
    1a20:	0f b6       	in	r0, 0x3f	; 63
    1a22:	f8 94       	cli
    1a24:	de bf       	out	0x3e, r29	; 62
    1a26:	0f be       	out	0x3f, r0	; 63
    1a28:	cd bf       	out	0x3d, r28	; 61
    1a2a:	cf 91       	pop	r28
    1a2c:	df 91       	pop	r29
    1a2e:	08 95       	ret

00001a30 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    1a30:	df 93       	push	r29
    1a32:	cf 93       	push	r28
    1a34:	00 d0       	rcall	.+0      	; 0x1a36 <vEventGroupClearBitsCallback+0x6>
    1a36:	00 d0       	rcall	.+0      	; 0x1a38 <vEventGroupClearBitsCallback+0x8>
    1a38:	00 d0       	rcall	.+0      	; 0x1a3a <vEventGroupClearBitsCallback+0xa>
    1a3a:	cd b7       	in	r28, 0x3d	; 61
    1a3c:	de b7       	in	r29, 0x3e	; 62
    1a3e:	9a 83       	std	Y+2, r25	; 0x02
    1a40:	89 83       	std	Y+1, r24	; 0x01
    1a42:	4b 83       	std	Y+3, r20	; 0x03
    1a44:	5c 83       	std	Y+4, r21	; 0x04
    1a46:	6d 83       	std	Y+5, r22	; 0x05
    1a48:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1a4a:	89 81       	ldd	r24, Y+1	; 0x01
    1a4c:	9a 81       	ldd	r25, Y+2	; 0x02
    1a4e:	2b 81       	ldd	r18, Y+3	; 0x03
    1a50:	3c 81       	ldd	r19, Y+4	; 0x04
    1a52:	b9 01       	movw	r22, r18
    1a54:	0e 94 c0 0b 	call	0x1780	; 0x1780 <xEventGroupClearBits>
}
    1a58:	26 96       	adiw	r28, 0x06	; 6
    1a5a:	0f b6       	in	r0, 0x3f	; 63
    1a5c:	f8 94       	cli
    1a5e:	de bf       	out	0x3e, r29	; 62
    1a60:	0f be       	out	0x3f, r0	; 63
    1a62:	cd bf       	out	0x3d, r28	; 61
    1a64:	cf 91       	pop	r28
    1a66:	df 91       	pop	r29
    1a68:	08 95       	ret

00001a6a <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    1a6a:	df 93       	push	r29
    1a6c:	cf 93       	push	r28
    1a6e:	00 d0       	rcall	.+0      	; 0x1a70 <prvTestWaitCondition+0x6>
    1a70:	00 d0       	rcall	.+0      	; 0x1a72 <prvTestWaitCondition+0x8>
    1a72:	00 d0       	rcall	.+0      	; 0x1a74 <prvTestWaitCondition+0xa>
    1a74:	cd b7       	in	r28, 0x3d	; 61
    1a76:	de b7       	in	r29, 0x3e	; 62
    1a78:	9b 83       	std	Y+3, r25	; 0x03
    1a7a:	8a 83       	std	Y+2, r24	; 0x02
    1a7c:	7d 83       	std	Y+5, r23	; 0x05
    1a7e:	6c 83       	std	Y+4, r22	; 0x04
    1a80:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    1a82:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    1a84:	8e 81       	ldd	r24, Y+6	; 0x06
    1a86:	88 23       	and	r24, r24
    1a88:	59 f4       	brne	.+22     	; 0x1aa0 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1a8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a8c:	9b 81       	ldd	r25, Y+3	; 0x03
    1a8e:	2c 81       	ldd	r18, Y+4	; 0x04
    1a90:	3d 81       	ldd	r19, Y+5	; 0x05
    1a92:	82 23       	and	r24, r18
    1a94:	93 23       	and	r25, r19
    1a96:	00 97       	sbiw	r24, 0x00	; 0
    1a98:	81 f0       	breq	.+32     	; 0x1aba <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    1a9a:	81 e0       	ldi	r24, 0x01	; 1
    1a9c:	89 83       	std	Y+1, r24	; 0x01
    1a9e:	0d c0       	rjmp	.+26     	; 0x1aba <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1aa0:	2a 81       	ldd	r18, Y+2	; 0x02
    1aa2:	3b 81       	ldd	r19, Y+3	; 0x03
    1aa4:	8c 81       	ldd	r24, Y+4	; 0x04
    1aa6:	9d 81       	ldd	r25, Y+5	; 0x05
    1aa8:	28 23       	and	r18, r24
    1aaa:	39 23       	and	r19, r25
    1aac:	8c 81       	ldd	r24, Y+4	; 0x04
    1aae:	9d 81       	ldd	r25, Y+5	; 0x05
    1ab0:	28 17       	cp	r18, r24
    1ab2:	39 07       	cpc	r19, r25
    1ab4:	11 f4       	brne	.+4      	; 0x1aba <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    1ab6:	81 e0       	ldi	r24, 0x01	; 1
    1ab8:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    1aba:	89 81       	ldd	r24, Y+1	; 0x01
}
    1abc:	26 96       	adiw	r28, 0x06	; 6
    1abe:	0f b6       	in	r0, 0x3f	; 63
    1ac0:	f8 94       	cli
    1ac2:	de bf       	out	0x3e, r29	; 62
    1ac4:	0f be       	out	0x3f, r0	; 63
    1ac6:	cd bf       	out	0x3d, r28	; 61
    1ac8:	cf 91       	pop	r28
    1aca:	df 91       	pop	r29
    1acc:	08 95       	ret

00001ace <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1ace:	df 93       	push	r29
    1ad0:	cf 93       	push	r28
    1ad2:	00 d0       	rcall	.+0      	; 0x1ad4 <vListInitialise+0x6>
    1ad4:	cd b7       	in	r28, 0x3d	; 61
    1ad6:	de b7       	in	r29, 0x3e	; 62
    1ad8:	9a 83       	std	Y+2, r25	; 0x02
    1ada:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1adc:	89 81       	ldd	r24, Y+1	; 0x01
    1ade:	9a 81       	ldd	r25, Y+2	; 0x02
    1ae0:	03 96       	adiw	r24, 0x03	; 3
    1ae2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ae4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ae6:	92 83       	std	Z+2, r25	; 0x02
    1ae8:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    1aea:	e9 81       	ldd	r30, Y+1	; 0x01
    1aec:	fa 81       	ldd	r31, Y+2	; 0x02
    1aee:	8f ef       	ldi	r24, 0xFF	; 255
    1af0:	9f ef       	ldi	r25, 0xFF	; 255
    1af2:	94 83       	std	Z+4, r25	; 0x04
    1af4:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1af6:	89 81       	ldd	r24, Y+1	; 0x01
    1af8:	9a 81       	ldd	r25, Y+2	; 0x02
    1afa:	03 96       	adiw	r24, 0x03	; 3
    1afc:	e9 81       	ldd	r30, Y+1	; 0x01
    1afe:	fa 81       	ldd	r31, Y+2	; 0x02
    1b00:	96 83       	std	Z+6, r25	; 0x06
    1b02:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b04:	89 81       	ldd	r24, Y+1	; 0x01
    1b06:	9a 81       	ldd	r25, Y+2	; 0x02
    1b08:	03 96       	adiw	r24, 0x03	; 3
    1b0a:	e9 81       	ldd	r30, Y+1	; 0x01
    1b0c:	fa 81       	ldd	r31, Y+2	; 0x02
    1b0e:	90 87       	std	Z+8, r25	; 0x08
    1b10:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1b12:	e9 81       	ldd	r30, Y+1	; 0x01
    1b14:	fa 81       	ldd	r31, Y+2	; 0x02
    1b16:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1b18:	0f 90       	pop	r0
    1b1a:	0f 90       	pop	r0
    1b1c:	cf 91       	pop	r28
    1b1e:	df 91       	pop	r29
    1b20:	08 95       	ret

00001b22 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1b22:	df 93       	push	r29
    1b24:	cf 93       	push	r28
    1b26:	00 d0       	rcall	.+0      	; 0x1b28 <vListInitialiseItem+0x6>
    1b28:	cd b7       	in	r28, 0x3d	; 61
    1b2a:	de b7       	in	r29, 0x3e	; 62
    1b2c:	9a 83       	std	Y+2, r25	; 0x02
    1b2e:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    1b30:	e9 81       	ldd	r30, Y+1	; 0x01
    1b32:	fa 81       	ldd	r31, Y+2	; 0x02
    1b34:	11 86       	std	Z+9, r1	; 0x09
    1b36:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1b38:	0f 90       	pop	r0
    1b3a:	0f 90       	pop	r0
    1b3c:	cf 91       	pop	r28
    1b3e:	df 91       	pop	r29
    1b40:	08 95       	ret

00001b42 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    1b42:	df 93       	push	r29
    1b44:	cf 93       	push	r28
    1b46:	00 d0       	rcall	.+0      	; 0x1b48 <vListInsertEnd+0x6>
    1b48:	00 d0       	rcall	.+0      	; 0x1b4a <vListInsertEnd+0x8>
    1b4a:	00 d0       	rcall	.+0      	; 0x1b4c <vListInsertEnd+0xa>
    1b4c:	cd b7       	in	r28, 0x3d	; 61
    1b4e:	de b7       	in	r29, 0x3e	; 62
    1b50:	9c 83       	std	Y+4, r25	; 0x04
    1b52:	8b 83       	std	Y+3, r24	; 0x03
    1b54:	7e 83       	std	Y+6, r23	; 0x06
    1b56:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    1b58:	eb 81       	ldd	r30, Y+3	; 0x03
    1b5a:	fc 81       	ldd	r31, Y+4	; 0x04
    1b5c:	81 81       	ldd	r24, Z+1	; 0x01
    1b5e:	92 81       	ldd	r25, Z+2	; 0x02
    1b60:	9a 83       	std	Y+2, r25	; 0x02
    1b62:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    1b64:	ed 81       	ldd	r30, Y+5	; 0x05
    1b66:	fe 81       	ldd	r31, Y+6	; 0x06
    1b68:	89 81       	ldd	r24, Y+1	; 0x01
    1b6a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b6c:	93 83       	std	Z+3, r25	; 0x03
    1b6e:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1b70:	e9 81       	ldd	r30, Y+1	; 0x01
    1b72:	fa 81       	ldd	r31, Y+2	; 0x02
    1b74:	84 81       	ldd	r24, Z+4	; 0x04
    1b76:	95 81       	ldd	r25, Z+5	; 0x05
    1b78:	ed 81       	ldd	r30, Y+5	; 0x05
    1b7a:	fe 81       	ldd	r31, Y+6	; 0x06
    1b7c:	95 83       	std	Z+5, r25	; 0x05
    1b7e:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1b80:	e9 81       	ldd	r30, Y+1	; 0x01
    1b82:	fa 81       	ldd	r31, Y+2	; 0x02
    1b84:	04 80       	ldd	r0, Z+4	; 0x04
    1b86:	f5 81       	ldd	r31, Z+5	; 0x05
    1b88:	e0 2d       	mov	r30, r0
    1b8a:	8d 81       	ldd	r24, Y+5	; 0x05
    1b8c:	9e 81       	ldd	r25, Y+6	; 0x06
    1b8e:	93 83       	std	Z+3, r25	; 0x03
    1b90:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    1b92:	e9 81       	ldd	r30, Y+1	; 0x01
    1b94:	fa 81       	ldd	r31, Y+2	; 0x02
    1b96:	8d 81       	ldd	r24, Y+5	; 0x05
    1b98:	9e 81       	ldd	r25, Y+6	; 0x06
    1b9a:	95 83       	std	Z+5, r25	; 0x05
    1b9c:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    1b9e:	ed 81       	ldd	r30, Y+5	; 0x05
    1ba0:	fe 81       	ldd	r31, Y+6	; 0x06
    1ba2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ba4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ba6:	91 87       	std	Z+9, r25	; 0x09
    1ba8:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1baa:	eb 81       	ldd	r30, Y+3	; 0x03
    1bac:	fc 81       	ldd	r31, Y+4	; 0x04
    1bae:	80 81       	ld	r24, Z
    1bb0:	8f 5f       	subi	r24, 0xFF	; 255
    1bb2:	eb 81       	ldd	r30, Y+3	; 0x03
    1bb4:	fc 81       	ldd	r31, Y+4	; 0x04
    1bb6:	80 83       	st	Z, r24
}
    1bb8:	26 96       	adiw	r28, 0x06	; 6
    1bba:	0f b6       	in	r0, 0x3f	; 63
    1bbc:	f8 94       	cli
    1bbe:	de bf       	out	0x3e, r29	; 62
    1bc0:	0f be       	out	0x3f, r0	; 63
    1bc2:	cd bf       	out	0x3d, r28	; 61
    1bc4:	cf 91       	pop	r28
    1bc6:	df 91       	pop	r29
    1bc8:	08 95       	ret

00001bca <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    1bca:	df 93       	push	r29
    1bcc:	cf 93       	push	r28
    1bce:	cd b7       	in	r28, 0x3d	; 61
    1bd0:	de b7       	in	r29, 0x3e	; 62
    1bd2:	28 97       	sbiw	r28, 0x08	; 8
    1bd4:	0f b6       	in	r0, 0x3f	; 63
    1bd6:	f8 94       	cli
    1bd8:	de bf       	out	0x3e, r29	; 62
    1bda:	0f be       	out	0x3f, r0	; 63
    1bdc:	cd bf       	out	0x3d, r28	; 61
    1bde:	9e 83       	std	Y+6, r25	; 0x06
    1be0:	8d 83       	std	Y+5, r24	; 0x05
    1be2:	78 87       	std	Y+8, r23	; 0x08
    1be4:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1be6:	ef 81       	ldd	r30, Y+7	; 0x07
    1be8:	f8 85       	ldd	r31, Y+8	; 0x08
    1bea:	80 81       	ld	r24, Z
    1bec:	91 81       	ldd	r25, Z+1	; 0x01
    1bee:	9a 83       	std	Y+2, r25	; 0x02
    1bf0:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1bf2:	89 81       	ldd	r24, Y+1	; 0x01
    1bf4:	9a 81       	ldd	r25, Y+2	; 0x02
    1bf6:	2f ef       	ldi	r18, 0xFF	; 255
    1bf8:	8f 3f       	cpi	r24, 0xFF	; 255
    1bfa:	92 07       	cpc	r25, r18
    1bfc:	39 f4       	brne	.+14     	; 0x1c0c <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1bfe:	ed 81       	ldd	r30, Y+5	; 0x05
    1c00:	fe 81       	ldd	r31, Y+6	; 0x06
    1c02:	87 81       	ldd	r24, Z+7	; 0x07
    1c04:	90 85       	ldd	r25, Z+8	; 0x08
    1c06:	9c 83       	std	Y+4, r25	; 0x04
    1c08:	8b 83       	std	Y+3, r24	; 0x03
    1c0a:	18 c0       	rjmp	.+48     	; 0x1c3c <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1c0c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c0e:	9e 81       	ldd	r25, Y+6	; 0x06
    1c10:	03 96       	adiw	r24, 0x03	; 3
    1c12:	9c 83       	std	Y+4, r25	; 0x04
    1c14:	8b 83       	std	Y+3, r24	; 0x03
    1c16:	06 c0       	rjmp	.+12     	; 0x1c24 <vListInsert+0x5a>
    1c18:	eb 81       	ldd	r30, Y+3	; 0x03
    1c1a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c1c:	82 81       	ldd	r24, Z+2	; 0x02
    1c1e:	93 81       	ldd	r25, Z+3	; 0x03
    1c20:	9c 83       	std	Y+4, r25	; 0x04
    1c22:	8b 83       	std	Y+3, r24	; 0x03
    1c24:	eb 81       	ldd	r30, Y+3	; 0x03
    1c26:	fc 81       	ldd	r31, Y+4	; 0x04
    1c28:	02 80       	ldd	r0, Z+2	; 0x02
    1c2a:	f3 81       	ldd	r31, Z+3	; 0x03
    1c2c:	e0 2d       	mov	r30, r0
    1c2e:	20 81       	ld	r18, Z
    1c30:	31 81       	ldd	r19, Z+1	; 0x01
    1c32:	89 81       	ldd	r24, Y+1	; 0x01
    1c34:	9a 81       	ldd	r25, Y+2	; 0x02
    1c36:	82 17       	cp	r24, r18
    1c38:	93 07       	cpc	r25, r19
    1c3a:	70 f7       	brcc	.-36     	; 0x1c18 <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1c3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1c40:	82 81       	ldd	r24, Z+2	; 0x02
    1c42:	93 81       	ldd	r25, Z+3	; 0x03
    1c44:	ef 81       	ldd	r30, Y+7	; 0x07
    1c46:	f8 85       	ldd	r31, Y+8	; 0x08
    1c48:	93 83       	std	Z+3, r25	; 0x03
    1c4a:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1c4c:	ef 81       	ldd	r30, Y+7	; 0x07
    1c4e:	f8 85       	ldd	r31, Y+8	; 0x08
    1c50:	02 80       	ldd	r0, Z+2	; 0x02
    1c52:	f3 81       	ldd	r31, Z+3	; 0x03
    1c54:	e0 2d       	mov	r30, r0
    1c56:	8f 81       	ldd	r24, Y+7	; 0x07
    1c58:	98 85       	ldd	r25, Y+8	; 0x08
    1c5a:	95 83       	std	Z+5, r25	; 0x05
    1c5c:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1c5e:	ef 81       	ldd	r30, Y+7	; 0x07
    1c60:	f8 85       	ldd	r31, Y+8	; 0x08
    1c62:	8b 81       	ldd	r24, Y+3	; 0x03
    1c64:	9c 81       	ldd	r25, Y+4	; 0x04
    1c66:	95 83       	std	Z+5, r25	; 0x05
    1c68:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    1c6a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c6c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c6e:	8f 81       	ldd	r24, Y+7	; 0x07
    1c70:	98 85       	ldd	r25, Y+8	; 0x08
    1c72:	93 83       	std	Z+3, r25	; 0x03
    1c74:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    1c76:	ef 81       	ldd	r30, Y+7	; 0x07
    1c78:	f8 85       	ldd	r31, Y+8	; 0x08
    1c7a:	8d 81       	ldd	r24, Y+5	; 0x05
    1c7c:	9e 81       	ldd	r25, Y+6	; 0x06
    1c7e:	91 87       	std	Z+9, r25	; 0x09
    1c80:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1c82:	ed 81       	ldd	r30, Y+5	; 0x05
    1c84:	fe 81       	ldd	r31, Y+6	; 0x06
    1c86:	80 81       	ld	r24, Z
    1c88:	8f 5f       	subi	r24, 0xFF	; 255
    1c8a:	ed 81       	ldd	r30, Y+5	; 0x05
    1c8c:	fe 81       	ldd	r31, Y+6	; 0x06
    1c8e:	80 83       	st	Z, r24
}
    1c90:	28 96       	adiw	r28, 0x08	; 8
    1c92:	0f b6       	in	r0, 0x3f	; 63
    1c94:	f8 94       	cli
    1c96:	de bf       	out	0x3e, r29	; 62
    1c98:	0f be       	out	0x3f, r0	; 63
    1c9a:	cd bf       	out	0x3d, r28	; 61
    1c9c:	cf 91       	pop	r28
    1c9e:	df 91       	pop	r29
    1ca0:	08 95       	ret

00001ca2 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1ca2:	df 93       	push	r29
    1ca4:	cf 93       	push	r28
    1ca6:	00 d0       	rcall	.+0      	; 0x1ca8 <uxListRemove+0x6>
    1ca8:	00 d0       	rcall	.+0      	; 0x1caa <uxListRemove+0x8>
    1caa:	cd b7       	in	r28, 0x3d	; 61
    1cac:	de b7       	in	r29, 0x3e	; 62
    1cae:	9c 83       	std	Y+4, r25	; 0x04
    1cb0:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    1cb2:	eb 81       	ldd	r30, Y+3	; 0x03
    1cb4:	fc 81       	ldd	r31, Y+4	; 0x04
    1cb6:	80 85       	ldd	r24, Z+8	; 0x08
    1cb8:	91 85       	ldd	r25, Z+9	; 0x09
    1cba:	9a 83       	std	Y+2, r25	; 0x02
    1cbc:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1cbe:	eb 81       	ldd	r30, Y+3	; 0x03
    1cc0:	fc 81       	ldd	r31, Y+4	; 0x04
    1cc2:	a2 81       	ldd	r26, Z+2	; 0x02
    1cc4:	b3 81       	ldd	r27, Z+3	; 0x03
    1cc6:	eb 81       	ldd	r30, Y+3	; 0x03
    1cc8:	fc 81       	ldd	r31, Y+4	; 0x04
    1cca:	84 81       	ldd	r24, Z+4	; 0x04
    1ccc:	95 81       	ldd	r25, Z+5	; 0x05
    1cce:	15 96       	adiw	r26, 0x05	; 5
    1cd0:	9c 93       	st	X, r25
    1cd2:	8e 93       	st	-X, r24
    1cd4:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1cd6:	eb 81       	ldd	r30, Y+3	; 0x03
    1cd8:	fc 81       	ldd	r31, Y+4	; 0x04
    1cda:	a4 81       	ldd	r26, Z+4	; 0x04
    1cdc:	b5 81       	ldd	r27, Z+5	; 0x05
    1cde:	eb 81       	ldd	r30, Y+3	; 0x03
    1ce0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ce2:	82 81       	ldd	r24, Z+2	; 0x02
    1ce4:	93 81       	ldd	r25, Z+3	; 0x03
    1ce6:	13 96       	adiw	r26, 0x03	; 3
    1ce8:	9c 93       	st	X, r25
    1cea:	8e 93       	st	-X, r24
    1cec:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    1cee:	e9 81       	ldd	r30, Y+1	; 0x01
    1cf0:	fa 81       	ldd	r31, Y+2	; 0x02
    1cf2:	21 81       	ldd	r18, Z+1	; 0x01
    1cf4:	32 81       	ldd	r19, Z+2	; 0x02
    1cf6:	8b 81       	ldd	r24, Y+3	; 0x03
    1cf8:	9c 81       	ldd	r25, Y+4	; 0x04
    1cfa:	28 17       	cp	r18, r24
    1cfc:	39 07       	cpc	r19, r25
    1cfe:	41 f4       	brne	.+16     	; 0x1d10 <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    1d00:	eb 81       	ldd	r30, Y+3	; 0x03
    1d02:	fc 81       	ldd	r31, Y+4	; 0x04
    1d04:	84 81       	ldd	r24, Z+4	; 0x04
    1d06:	95 81       	ldd	r25, Z+5	; 0x05
    1d08:	e9 81       	ldd	r30, Y+1	; 0x01
    1d0a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d0c:	92 83       	std	Z+2, r25	; 0x02
    1d0e:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    1d10:	eb 81       	ldd	r30, Y+3	; 0x03
    1d12:	fc 81       	ldd	r31, Y+4	; 0x04
    1d14:	11 86       	std	Z+9, r1	; 0x09
    1d16:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    1d18:	e9 81       	ldd	r30, Y+1	; 0x01
    1d1a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d1c:	80 81       	ld	r24, Z
    1d1e:	81 50       	subi	r24, 0x01	; 1
    1d20:	e9 81       	ldd	r30, Y+1	; 0x01
    1d22:	fa 81       	ldd	r31, Y+2	; 0x02
    1d24:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    1d26:	e9 81       	ldd	r30, Y+1	; 0x01
    1d28:	fa 81       	ldd	r31, Y+2	; 0x02
    1d2a:	80 81       	ld	r24, Z
}
    1d2c:	0f 90       	pop	r0
    1d2e:	0f 90       	pop	r0
    1d30:	0f 90       	pop	r0
    1d32:	0f 90       	pop	r0
    1d34:	cf 91       	pop	r28
    1d36:	df 91       	pop	r29
    1d38:	08 95       	ret

00001d3a <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    1d3a:	df 93       	push	r29
    1d3c:	cf 93       	push	r28
    1d3e:	00 d0       	rcall	.+0      	; 0x1d40 <xQueueGenericReset+0x6>
    1d40:	00 d0       	rcall	.+0      	; 0x1d42 <xQueueGenericReset+0x8>
    1d42:	00 d0       	rcall	.+0      	; 0x1d44 <xQueueGenericReset+0xa>
    1d44:	cd b7       	in	r28, 0x3d	; 61
    1d46:	de b7       	in	r29, 0x3e	; 62
    1d48:	9d 83       	std	Y+5, r25	; 0x05
    1d4a:	8c 83       	std	Y+4, r24	; 0x04
    1d4c:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    1d4e:	81 e0       	ldi	r24, 0x01	; 1
    1d50:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    1d52:	8c 81       	ldd	r24, Y+4	; 0x04
    1d54:	9d 81       	ldd	r25, Y+5	; 0x05
    1d56:	9a 83       	std	Y+2, r25	; 0x02
    1d58:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    1d5a:	89 81       	ldd	r24, Y+1	; 0x01
    1d5c:	9a 81       	ldd	r25, Y+2	; 0x02
    1d5e:	00 97       	sbiw	r24, 0x00	; 0
    1d60:	09 f4       	brne	.+2      	; 0x1d64 <xQueueGenericReset+0x2a>
    1d62:	8b c0       	rjmp	.+278    	; 0x1e7a <xQueueGenericReset+0x140>
    1d64:	e9 81       	ldd	r30, Y+1	; 0x01
    1d66:	fa 81       	ldd	r31, Y+2	; 0x02
    1d68:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d6a:	88 23       	and	r24, r24
    1d6c:	09 f4       	brne	.+2      	; 0x1d70 <xQueueGenericReset+0x36>
    1d6e:	85 c0       	rjmp	.+266    	; 0x1e7a <xQueueGenericReset+0x140>
    1d70:	e9 81       	ldd	r30, Y+1	; 0x01
    1d72:	fa 81       	ldd	r31, Y+2	; 0x02
    1d74:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d76:	28 2f       	mov	r18, r24
    1d78:	30 e0       	ldi	r19, 0x00	; 0
    1d7a:	8f ef       	ldi	r24, 0xFF	; 255
    1d7c:	9f e7       	ldi	r25, 0x7F	; 127
    1d7e:	b9 01       	movw	r22, r18
    1d80:	0e 94 74 32 	call	0x64e8	; 0x64e8 <__udivmodhi4>
    1d84:	cb 01       	movw	r24, r22
    1d86:	9c 01       	movw	r18, r24
    1d88:	e9 81       	ldd	r30, Y+1	; 0x01
    1d8a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d8c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d8e:	88 2f       	mov	r24, r24
    1d90:	90 e0       	ldi	r25, 0x00	; 0
    1d92:	28 17       	cp	r18, r24
    1d94:	39 07       	cpc	r19, r25
    1d96:	08 f4       	brcc	.+2      	; 0x1d9a <xQueueGenericReset+0x60>
    1d98:	70 c0       	rjmp	.+224    	; 0x1e7a <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    1d9a:	0f b6       	in	r0, 0x3f	; 63
    1d9c:	f8 94       	cli
    1d9e:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1da0:	e9 81       	ldd	r30, Y+1	; 0x01
    1da2:	fa 81       	ldd	r31, Y+2	; 0x02
    1da4:	40 81       	ld	r20, Z
    1da6:	51 81       	ldd	r21, Z+1	; 0x01
    1da8:	e9 81       	ldd	r30, Y+1	; 0x01
    1daa:	fa 81       	ldd	r31, Y+2	; 0x02
    1dac:	83 8d       	ldd	r24, Z+27	; 0x1b
    1dae:	28 2f       	mov	r18, r24
    1db0:	30 e0       	ldi	r19, 0x00	; 0
    1db2:	e9 81       	ldd	r30, Y+1	; 0x01
    1db4:	fa 81       	ldd	r31, Y+2	; 0x02
    1db6:	84 8d       	ldd	r24, Z+28	; 0x1c
    1db8:	88 2f       	mov	r24, r24
    1dba:	90 e0       	ldi	r25, 0x00	; 0
    1dbc:	bc 01       	movw	r22, r24
    1dbe:	26 9f       	mul	r18, r22
    1dc0:	c0 01       	movw	r24, r0
    1dc2:	27 9f       	mul	r18, r23
    1dc4:	90 0d       	add	r25, r0
    1dc6:	36 9f       	mul	r19, r22
    1dc8:	90 0d       	add	r25, r0
    1dca:	11 24       	eor	r1, r1
    1dcc:	84 0f       	add	r24, r20
    1dce:	95 1f       	adc	r25, r21
    1dd0:	e9 81       	ldd	r30, Y+1	; 0x01
    1dd2:	fa 81       	ldd	r31, Y+2	; 0x02
    1dd4:	95 83       	std	Z+5, r25	; 0x05
    1dd6:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1dd8:	e9 81       	ldd	r30, Y+1	; 0x01
    1dda:	fa 81       	ldd	r31, Y+2	; 0x02
    1ddc:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    1dde:	e9 81       	ldd	r30, Y+1	; 0x01
    1de0:	fa 81       	ldd	r31, Y+2	; 0x02
    1de2:	80 81       	ld	r24, Z
    1de4:	91 81       	ldd	r25, Z+1	; 0x01
    1de6:	e9 81       	ldd	r30, Y+1	; 0x01
    1de8:	fa 81       	ldd	r31, Y+2	; 0x02
    1dea:	93 83       	std	Z+3, r25	; 0x03
    1dec:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1dee:	e9 81       	ldd	r30, Y+1	; 0x01
    1df0:	fa 81       	ldd	r31, Y+2	; 0x02
    1df2:	40 81       	ld	r20, Z
    1df4:	51 81       	ldd	r21, Z+1	; 0x01
    1df6:	e9 81       	ldd	r30, Y+1	; 0x01
    1df8:	fa 81       	ldd	r31, Y+2	; 0x02
    1dfa:	83 8d       	ldd	r24, Z+27	; 0x1b
    1dfc:	88 2f       	mov	r24, r24
    1dfe:	90 e0       	ldi	r25, 0x00	; 0
    1e00:	9c 01       	movw	r18, r24
    1e02:	21 50       	subi	r18, 0x01	; 1
    1e04:	30 40       	sbci	r19, 0x00	; 0
    1e06:	e9 81       	ldd	r30, Y+1	; 0x01
    1e08:	fa 81       	ldd	r31, Y+2	; 0x02
    1e0a:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e0c:	88 2f       	mov	r24, r24
    1e0e:	90 e0       	ldi	r25, 0x00	; 0
    1e10:	bc 01       	movw	r22, r24
    1e12:	26 9f       	mul	r18, r22
    1e14:	c0 01       	movw	r24, r0
    1e16:	27 9f       	mul	r18, r23
    1e18:	90 0d       	add	r25, r0
    1e1a:	36 9f       	mul	r19, r22
    1e1c:	90 0d       	add	r25, r0
    1e1e:	11 24       	eor	r1, r1
    1e20:	84 0f       	add	r24, r20
    1e22:	95 1f       	adc	r25, r21
    1e24:	e9 81       	ldd	r30, Y+1	; 0x01
    1e26:	fa 81       	ldd	r31, Y+2	; 0x02
    1e28:	97 83       	std	Z+7, r25	; 0x07
    1e2a:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    1e2c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e2e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e30:	8f ef       	ldi	r24, 0xFF	; 255
    1e32:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    1e34:	e9 81       	ldd	r30, Y+1	; 0x01
    1e36:	fa 81       	ldd	r31, Y+2	; 0x02
    1e38:	8f ef       	ldi	r24, 0xFF	; 255
    1e3a:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    1e3c:	8e 81       	ldd	r24, Y+6	; 0x06
    1e3e:	88 23       	and	r24, r24
    1e40:	79 f4       	brne	.+30     	; 0x1e60 <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e42:	e9 81       	ldd	r30, Y+1	; 0x01
    1e44:	fa 81       	ldd	r31, Y+2	; 0x02
    1e46:	80 85       	ldd	r24, Z+8	; 0x08
    1e48:	88 23       	and	r24, r24
    1e4a:	a1 f0       	breq	.+40     	; 0x1e74 <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e4c:	89 81       	ldd	r24, Y+1	; 0x01
    1e4e:	9a 81       	ldd	r25, Y+2	; 0x02
    1e50:	08 96       	adiw	r24, 0x08	; 8
    1e52:	0e 94 0a 20 	call	0x4014	; 0x4014 <xTaskRemoveFromEventList>
    1e56:	88 23       	and	r24, r24
    1e58:	69 f0       	breq	.+26     	; 0x1e74 <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1e5a:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    1e5e:	0a c0       	rjmp	.+20     	; 0x1e74 <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1e60:	89 81       	ldd	r24, Y+1	; 0x01
    1e62:	9a 81       	ldd	r25, Y+2	; 0x02
    1e64:	08 96       	adiw	r24, 0x08	; 8
    1e66:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1e6a:	89 81       	ldd	r24, Y+1	; 0x01
    1e6c:	9a 81       	ldd	r25, Y+2	; 0x02
    1e6e:	41 96       	adiw	r24, 0x11	; 17
    1e70:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    1e74:	0f 90       	pop	r0
    1e76:	0f be       	out	0x3f, r0	; 63
    1e78:	01 c0       	rjmp	.+2      	; 0x1e7c <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    1e7a:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    1e7c:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1e7e:	26 96       	adiw	r28, 0x06	; 6
    1e80:	0f b6       	in	r0, 0x3f	; 63
    1e82:	f8 94       	cli
    1e84:	de bf       	out	0x3e, r29	; 62
    1e86:	0f be       	out	0x3f, r0	; 63
    1e88:	cd bf       	out	0x3d, r28	; 61
    1e8a:	cf 91       	pop	r28
    1e8c:	df 91       	pop	r29
    1e8e:	08 95       	ret

00001e90 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    1e90:	0f 93       	push	r16
    1e92:	1f 93       	push	r17
    1e94:	df 93       	push	r29
    1e96:	cf 93       	push	r28
    1e98:	cd b7       	in	r28, 0x3d	; 61
    1e9a:	de b7       	in	r29, 0x3e	; 62
    1e9c:	29 97       	sbiw	r28, 0x09	; 9
    1e9e:	0f b6       	in	r0, 0x3f	; 63
    1ea0:	f8 94       	cli
    1ea2:	de bf       	out	0x3e, r29	; 62
    1ea4:	0f be       	out	0x3f, r0	; 63
    1ea6:	cd bf       	out	0x3d, r28	; 61
    1ea8:	8f 83       	std	Y+7, r24	; 0x07
    1eaa:	68 87       	std	Y+8, r22	; 0x08
    1eac:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    1eae:	1e 82       	std	Y+6, r1	; 0x06
    1eb0:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    1eb2:	8f 81       	ldd	r24, Y+7	; 0x07
    1eb4:	88 23       	and	r24, r24
    1eb6:	09 f4       	brne	.+2      	; 0x1eba <xQueueGenericCreate+0x2a>
    1eb8:	52 c0       	rjmp	.+164    	; 0x1f5e <xQueueGenericCreate+0xce>
    1eba:	8f 81       	ldd	r24, Y+7	; 0x07
    1ebc:	28 2f       	mov	r18, r24
    1ebe:	30 e0       	ldi	r19, 0x00	; 0
    1ec0:	8f ef       	ldi	r24, 0xFF	; 255
    1ec2:	9f e7       	ldi	r25, 0x7F	; 127
    1ec4:	b9 01       	movw	r22, r18
    1ec6:	0e 94 74 32 	call	0x64e8	; 0x64e8 <__udivmodhi4>
    1eca:	cb 01       	movw	r24, r22
    1ecc:	9c 01       	movw	r18, r24
    1ece:	88 85       	ldd	r24, Y+8	; 0x08
    1ed0:	88 2f       	mov	r24, r24
    1ed2:	90 e0       	ldi	r25, 0x00	; 0
    1ed4:	28 17       	cp	r18, r24
    1ed6:	39 07       	cpc	r19, r25
    1ed8:	08 f4       	brcc	.+2      	; 0x1edc <xQueueGenericCreate+0x4c>
    1eda:	41 c0       	rjmp	.+130    	; 0x1f5e <xQueueGenericCreate+0xce>
    1edc:	8f 81       	ldd	r24, Y+7	; 0x07
    1ede:	28 2f       	mov	r18, r24
    1ee0:	30 e0       	ldi	r19, 0x00	; 0
    1ee2:	88 85       	ldd	r24, Y+8	; 0x08
    1ee4:	88 2f       	mov	r24, r24
    1ee6:	90 e0       	ldi	r25, 0x00	; 0
    1ee8:	ac 01       	movw	r20, r24
    1eea:	24 9f       	mul	r18, r20
    1eec:	c0 01       	movw	r24, r0
    1eee:	25 9f       	mul	r18, r21
    1ef0:	90 0d       	add	r25, r0
    1ef2:	34 9f       	mul	r19, r20
    1ef4:	90 0d       	add	r25, r0
    1ef6:	11 24       	eor	r1, r1
    1ef8:	5f e7       	ldi	r21, 0x7F	; 127
    1efa:	81 3e       	cpi	r24, 0xE1	; 225
    1efc:	95 07       	cpc	r25, r21
    1efe:	78 f5       	brcc	.+94     	; 0x1f5e <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1f00:	8f 81       	ldd	r24, Y+7	; 0x07
    1f02:	28 2f       	mov	r18, r24
    1f04:	30 e0       	ldi	r19, 0x00	; 0
    1f06:	88 85       	ldd	r24, Y+8	; 0x08
    1f08:	88 2f       	mov	r24, r24
    1f0a:	90 e0       	ldi	r25, 0x00	; 0
    1f0c:	ac 01       	movw	r20, r24
    1f0e:	24 9f       	mul	r18, r20
    1f10:	c0 01       	movw	r24, r0
    1f12:	25 9f       	mul	r18, r21
    1f14:	90 0d       	add	r25, r0
    1f16:	34 9f       	mul	r19, r20
    1f18:	90 0d       	add	r25, r0
    1f1a:	11 24       	eor	r1, r1
    1f1c:	9c 83       	std	Y+4, r25	; 0x04
    1f1e:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1f20:	8b 81       	ldd	r24, Y+3	; 0x03
    1f22:	9c 81       	ldd	r25, Y+4	; 0x04
    1f24:	4f 96       	adiw	r24, 0x1f	; 31
    1f26:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    1f2a:	9e 83       	std	Y+6, r25	; 0x06
    1f2c:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    1f2e:	8d 81       	ldd	r24, Y+5	; 0x05
    1f30:	9e 81       	ldd	r25, Y+6	; 0x06
    1f32:	00 97       	sbiw	r24, 0x00	; 0
    1f34:	a1 f0       	breq	.+40     	; 0x1f5e <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1f36:	8d 81       	ldd	r24, Y+5	; 0x05
    1f38:	9e 81       	ldd	r25, Y+6	; 0x06
    1f3a:	9a 83       	std	Y+2, r25	; 0x02
    1f3c:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1f3e:	89 81       	ldd	r24, Y+1	; 0x01
    1f40:	9a 81       	ldd	r25, Y+2	; 0x02
    1f42:	4f 96       	adiw	r24, 0x1f	; 31
    1f44:	9a 83       	std	Y+2, r25	; 0x02
    1f46:	89 83       	std	Y+1, r24	; 0x01
                         * deleted. */
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
                    }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1f48:	29 81       	ldd	r18, Y+1	; 0x01
    1f4a:	3a 81       	ldd	r19, Y+2	; 0x02
    1f4c:	ed 81       	ldd	r30, Y+5	; 0x05
    1f4e:	fe 81       	ldd	r31, Y+6	; 0x06
    1f50:	8f 81       	ldd	r24, Y+7	; 0x07
    1f52:	68 85       	ldd	r22, Y+8	; 0x08
    1f54:	a9 01       	movw	r20, r18
    1f56:	29 85       	ldd	r18, Y+9	; 0x09
    1f58:	8f 01       	movw	r16, r30
    1f5a:	0e 94 bc 0f 	call	0x1f78	; 0x1f78 <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    1f5e:	8d 81       	ldd	r24, Y+5	; 0x05
    1f60:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    1f62:	29 96       	adiw	r28, 0x09	; 9
    1f64:	0f b6       	in	r0, 0x3f	; 63
    1f66:	f8 94       	cli
    1f68:	de bf       	out	0x3e, r29	; 62
    1f6a:	0f be       	out	0x3f, r0	; 63
    1f6c:	cd bf       	out	0x3d, r28	; 61
    1f6e:	cf 91       	pop	r28
    1f70:	df 91       	pop	r29
    1f72:	1f 91       	pop	r17
    1f74:	0f 91       	pop	r16
    1f76:	08 95       	ret

00001f78 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    1f78:	0f 93       	push	r16
    1f7a:	1f 93       	push	r17
    1f7c:	df 93       	push	r29
    1f7e:	cf 93       	push	r28
    1f80:	cd b7       	in	r28, 0x3d	; 61
    1f82:	de b7       	in	r29, 0x3e	; 62
    1f84:	27 97       	sbiw	r28, 0x07	; 7
    1f86:	0f b6       	in	r0, 0x3f	; 63
    1f88:	f8 94       	cli
    1f8a:	de bf       	out	0x3e, r29	; 62
    1f8c:	0f be       	out	0x3f, r0	; 63
    1f8e:	cd bf       	out	0x3d, r28	; 61
    1f90:	89 83       	std	Y+1, r24	; 0x01
    1f92:	6a 83       	std	Y+2, r22	; 0x02
    1f94:	5c 83       	std	Y+4, r21	; 0x04
    1f96:	4b 83       	std	Y+3, r20	; 0x03
    1f98:	2d 83       	std	Y+5, r18	; 0x05
    1f9a:	1f 83       	std	Y+7, r17	; 0x07
    1f9c:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    1f9e:	8a 81       	ldd	r24, Y+2	; 0x02
    1fa0:	88 23       	and	r24, r24
    1fa2:	39 f4       	brne	.+14     	; 0x1fb2 <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1fa4:	8e 81       	ldd	r24, Y+6	; 0x06
    1fa6:	9f 81       	ldd	r25, Y+7	; 0x07
    1fa8:	ee 81       	ldd	r30, Y+6	; 0x06
    1faa:	ff 81       	ldd	r31, Y+7	; 0x07
    1fac:	91 83       	std	Z+1, r25	; 0x01
    1fae:	80 83       	st	Z, r24
    1fb0:	06 c0       	rjmp	.+12     	; 0x1fbe <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1fb2:	8b 81       	ldd	r24, Y+3	; 0x03
    1fb4:	9c 81       	ldd	r25, Y+4	; 0x04
    1fb6:	ee 81       	ldd	r30, Y+6	; 0x06
    1fb8:	ff 81       	ldd	r31, Y+7	; 0x07
    1fba:	91 83       	std	Z+1, r25	; 0x01
    1fbc:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    1fbe:	ee 81       	ldd	r30, Y+6	; 0x06
    1fc0:	ff 81       	ldd	r31, Y+7	; 0x07
    1fc2:	89 81       	ldd	r24, Y+1	; 0x01
    1fc4:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    1fc6:	ee 81       	ldd	r30, Y+6	; 0x06
    1fc8:	ff 81       	ldd	r31, Y+7	; 0x07
    1fca:	8a 81       	ldd	r24, Y+2	; 0x02
    1fcc:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1fce:	8e 81       	ldd	r24, Y+6	; 0x06
    1fd0:	9f 81       	ldd	r25, Y+7	; 0x07
    1fd2:	61 e0       	ldi	r22, 0x01	; 1
    1fd4:	0e 94 9d 0e 	call	0x1d3a	; 0x1d3a <xQueueGenericReset>
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    1fd8:	27 96       	adiw	r28, 0x07	; 7
    1fda:	0f b6       	in	r0, 0x3f	; 63
    1fdc:	f8 94       	cli
    1fde:	de bf       	out	0x3e, r29	; 62
    1fe0:	0f be       	out	0x3f, r0	; 63
    1fe2:	cd bf       	out	0x3d, r28	; 61
    1fe4:	cf 91       	pop	r28
    1fe6:	df 91       	pop	r29
    1fe8:	1f 91       	pop	r17
    1fea:	0f 91       	pop	r16
    1fec:	08 95       	ret

00001fee <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    1fee:	df 93       	push	r29
    1ff0:	cf 93       	push	r28
    1ff2:	cd b7       	in	r28, 0x3d	; 61
    1ff4:	de b7       	in	r29, 0x3e	; 62
    1ff6:	2f 97       	sbiw	r28, 0x0f	; 15
    1ff8:	0f b6       	in	r0, 0x3f	; 63
    1ffa:	f8 94       	cli
    1ffc:	de bf       	out	0x3e, r29	; 62
    1ffe:	0f be       	out	0x3f, r0	; 63
    2000:	cd bf       	out	0x3d, r28	; 61
    2002:	99 87       	std	Y+9, r25	; 0x09
    2004:	88 87       	std	Y+8, r24	; 0x08
    2006:	7b 87       	std	Y+11, r23	; 0x0b
    2008:	6a 87       	std	Y+10, r22	; 0x0a
    200a:	5d 87       	std	Y+13, r21	; 0x0d
    200c:	4c 87       	std	Y+12, r20	; 0x0c
    200e:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2010:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2012:	88 85       	ldd	r24, Y+8	; 0x08
    2014:	99 85       	ldd	r25, Y+9	; 0x09
    2016:	9a 83       	std	Y+2, r25	; 0x02
    2018:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    201a:	0f b6       	in	r0, 0x3f	; 63
    201c:	f8 94       	cli
    201e:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2020:	e9 81       	ldd	r30, Y+1	; 0x01
    2022:	fa 81       	ldd	r31, Y+2	; 0x02
    2024:	92 8d       	ldd	r25, Z+26	; 0x1a
    2026:	e9 81       	ldd	r30, Y+1	; 0x01
    2028:	fa 81       	ldd	r31, Y+2	; 0x02
    202a:	83 8d       	ldd	r24, Z+27	; 0x1b
    202c:	98 17       	cp	r25, r24
    202e:	18 f0       	brcs	.+6      	; 0x2036 <xQueueGenericSend+0x48>
    2030:	8e 85       	ldd	r24, Y+14	; 0x0e
    2032:	82 30       	cpi	r24, 0x02	; 2
    2034:	11 f5       	brne	.+68     	; 0x207a <xQueueGenericSend+0x8c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2036:	89 81       	ldd	r24, Y+1	; 0x01
    2038:	9a 81       	ldd	r25, Y+2	; 0x02
    203a:	2a 85       	ldd	r18, Y+10	; 0x0a
    203c:	3b 85       	ldd	r19, Y+11	; 0x0b
    203e:	b9 01       	movw	r22, r18
    2040:	4e 85       	ldd	r20, Y+14	; 0x0e
    2042:	0e 94 4d 14 	call	0x289a	; 0x289a <prvCopyDataToQueue>
    2046:	8b 83       	std	Y+3, r24	; 0x03

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2048:	e9 81       	ldd	r30, Y+1	; 0x01
    204a:	fa 81       	ldd	r31, Y+2	; 0x02
    204c:	81 89       	ldd	r24, Z+17	; 0x11
    204e:	88 23       	and	r24, r24
    2050:	51 f0       	breq	.+20     	; 0x2066 <xQueueGenericSend+0x78>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2052:	89 81       	ldd	r24, Y+1	; 0x01
    2054:	9a 81       	ldd	r25, Y+2	; 0x02
    2056:	41 96       	adiw	r24, 0x11	; 17
    2058:	0e 94 0a 20 	call	0x4014	; 0x4014 <xTaskRemoveFromEventList>
    205c:	88 23       	and	r24, r24
    205e:	41 f0       	breq	.+16     	; 0x2070 <xQueueGenericSend+0x82>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    2060:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    2064:	05 c0       	rjmp	.+10     	; 0x2070 <xQueueGenericSend+0x82>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    2066:	8b 81       	ldd	r24, Y+3	; 0x03
    2068:	88 23       	and	r24, r24
    206a:	11 f0       	breq	.+4      	; 0x2070 <xQueueGenericSend+0x82>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    206c:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    2070:	0f 90       	pop	r0
    2072:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2074:	81 e0       	ldi	r24, 0x01	; 1
    2076:	8f 87       	std	Y+15, r24	; 0x0f
    2078:	5c c0       	rjmp	.+184    	; 0x2132 <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    207a:	8c 85       	ldd	r24, Y+12	; 0x0c
    207c:	9d 85       	ldd	r25, Y+13	; 0x0d
    207e:	00 97       	sbiw	r24, 0x00	; 0
    2080:	21 f4       	brne	.+8      	; 0x208a <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2082:	0f 90       	pop	r0
    2084:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    2086:	1f 86       	std	Y+15, r1	; 0x0f
    2088:	54 c0       	rjmp	.+168    	; 0x2132 <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    208a:	8c 81       	ldd	r24, Y+4	; 0x04
    208c:	88 23       	and	r24, r24
    208e:	31 f4       	brne	.+12     	; 0x209c <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2090:	ce 01       	movw	r24, r28
    2092:	05 96       	adiw	r24, 0x05	; 5
    2094:	0e 94 7a 22 	call	0x44f4	; 0x44f4 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2098:	81 e0       	ldi	r24, 0x01	; 1
    209a:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    209c:	0f 90       	pop	r0
    209e:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    20a0:	0e 94 44 1b 	call	0x3688	; 0x3688 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    20a4:	0f b6       	in	r0, 0x3f	; 63
    20a6:	f8 94       	cli
    20a8:	0f 92       	push	r0
    20aa:	e9 81       	ldd	r30, Y+1	; 0x01
    20ac:	fa 81       	ldd	r31, Y+2	; 0x02
    20ae:	85 8d       	ldd	r24, Z+29	; 0x1d
    20b0:	8f 3f       	cpi	r24, 0xFF	; 255
    20b2:	19 f4       	brne	.+6      	; 0x20ba <xQueueGenericSend+0xcc>
    20b4:	e9 81       	ldd	r30, Y+1	; 0x01
    20b6:	fa 81       	ldd	r31, Y+2	; 0x02
    20b8:	15 8e       	std	Z+29, r1	; 0x1d
    20ba:	e9 81       	ldd	r30, Y+1	; 0x01
    20bc:	fa 81       	ldd	r31, Y+2	; 0x02
    20be:	86 8d       	ldd	r24, Z+30	; 0x1e
    20c0:	8f 3f       	cpi	r24, 0xFF	; 255
    20c2:	19 f4       	brne	.+6      	; 0x20ca <xQueueGenericSend+0xdc>
    20c4:	e9 81       	ldd	r30, Y+1	; 0x01
    20c6:	fa 81       	ldd	r31, Y+2	; 0x02
    20c8:	16 8e       	std	Z+30, r1	; 0x1e
    20ca:	0f 90       	pop	r0
    20cc:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    20ce:	ce 01       	movw	r24, r28
    20d0:	05 96       	adiw	r24, 0x05	; 5
    20d2:	9e 01       	movw	r18, r28
    20d4:	24 5f       	subi	r18, 0xF4	; 244
    20d6:	3f 4f       	sbci	r19, 0xFF	; 255
    20d8:	b9 01       	movw	r22, r18
    20da:	0e 94 93 22 	call	0x4526	; 0x4526 <xTaskCheckForTimeOut>
    20de:	88 23       	and	r24, r24
    20e0:	09 f5       	brne	.+66     	; 0x2124 <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    20e2:	89 81       	ldd	r24, Y+1	; 0x01
    20e4:	9a 81       	ldd	r25, Y+2	; 0x02
    20e6:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <prvIsQueueFull>
    20ea:	88 23       	and	r24, r24
    20ec:	a1 f0       	breq	.+40     	; 0x2116 <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    20ee:	89 81       	ldd	r24, Y+1	; 0x01
    20f0:	9a 81       	ldd	r25, Y+2	; 0x02
    20f2:	08 96       	adiw	r24, 0x08	; 8
    20f4:	2c 85       	ldd	r18, Y+12	; 0x0c
    20f6:	3d 85       	ldd	r19, Y+13	; 0x0d
    20f8:	b9 01       	movw	r22, r18
    20fa:	0e 94 21 1f 	call	0x3e42	; 0x3e42 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    20fe:	89 81       	ldd	r24, Y+1	; 0x01
    2100:	9a 81       	ldd	r25, Y+2	; 0x02
    2102:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    2106:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>
    210a:	88 23       	and	r24, r24
    210c:	09 f0       	breq	.+2      	; 0x2110 <xQueueGenericSend+0x122>
    210e:	85 cf       	rjmp	.-246    	; 0x201a <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    2110:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    2114:	82 cf       	rjmp	.-252    	; 0x201a <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    2116:	89 81       	ldd	r24, Y+1	; 0x01
    2118:	9a 81       	ldd	r25, Y+2	; 0x02
    211a:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    211e:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>
    2122:	7b cf       	rjmp	.-266    	; 0x201a <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    2124:	89 81       	ldd	r24, Y+1	; 0x01
    2126:	9a 81       	ldd	r25, Y+2	; 0x02
    2128:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    212c:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    2130:	1f 86       	std	Y+15, r1	; 0x0f
    2132:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    2134:	2f 96       	adiw	r28, 0x0f	; 15
    2136:	0f b6       	in	r0, 0x3f	; 63
    2138:	f8 94       	cli
    213a:	de bf       	out	0x3e, r29	; 62
    213c:	0f be       	out	0x3f, r0	; 63
    213e:	cd bf       	out	0x3d, r28	; 61
    2140:	cf 91       	pop	r28
    2142:	df 91       	pop	r29
    2144:	08 95       	ret

00002146 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    2146:	df 93       	push	r29
    2148:	cf 93       	push	r28
    214a:	cd b7       	in	r28, 0x3d	; 61
    214c:	de b7       	in	r29, 0x3e	; 62
    214e:	2d 97       	sbiw	r28, 0x0d	; 13
    2150:	0f b6       	in	r0, 0x3f	; 63
    2152:	f8 94       	cli
    2154:	de bf       	out	0x3e, r29	; 62
    2156:	0f be       	out	0x3f, r0	; 63
    2158:	cd bf       	out	0x3d, r28	; 61
    215a:	98 87       	std	Y+8, r25	; 0x08
    215c:	8f 83       	std	Y+7, r24	; 0x07
    215e:	7a 87       	std	Y+10, r23	; 0x0a
    2160:	69 87       	std	Y+9, r22	; 0x09
    2162:	5c 87       	std	Y+12, r21	; 0x0c
    2164:	4b 87       	std	Y+11, r20	; 0x0b
    2166:	2d 87       	std	Y+13, r18	; 0x0d
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    2168:	8f 81       	ldd	r24, Y+7	; 0x07
    216a:	98 85       	ldd	r25, Y+8	; 0x08
    216c:	9c 83       	std	Y+4, r25	; 0x04
    216e:	8b 83       	std	Y+3, r24	; 0x03
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2170:	1d 82       	std	Y+5, r1	; 0x05
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2172:	eb 81       	ldd	r30, Y+3	; 0x03
    2174:	fc 81       	ldd	r31, Y+4	; 0x04
    2176:	92 8d       	ldd	r25, Z+26	; 0x1a
    2178:	eb 81       	ldd	r30, Y+3	; 0x03
    217a:	fc 81       	ldd	r31, Y+4	; 0x04
    217c:	83 8d       	ldd	r24, Z+27	; 0x1b
    217e:	98 17       	cp	r25, r24
    2180:	18 f0       	brcs	.+6      	; 0x2188 <xQueueGenericSendFromISR+0x42>
    2182:	8d 85       	ldd	r24, Y+13	; 0x0d
    2184:	82 30       	cpi	r24, 0x02	; 2
    2186:	81 f5       	brne	.+96     	; 0x21e8 <xQueueGenericSendFromISR+0xa2>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    2188:	eb 81       	ldd	r30, Y+3	; 0x03
    218a:	fc 81       	ldd	r31, Y+4	; 0x04
    218c:	86 8d       	ldd	r24, Z+30	; 0x1e
    218e:	8a 83       	std	Y+2, r24	; 0x02
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    2190:	eb 81       	ldd	r30, Y+3	; 0x03
    2192:	fc 81       	ldd	r31, Y+4	; 0x04
    2194:	82 8d       	ldd	r24, Z+26	; 0x1a
    2196:	89 83       	std	Y+1, r24	; 0x01
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2198:	8b 81       	ldd	r24, Y+3	; 0x03
    219a:	9c 81       	ldd	r25, Y+4	; 0x04
    219c:	29 85       	ldd	r18, Y+9	; 0x09
    219e:	3a 85       	ldd	r19, Y+10	; 0x0a
    21a0:	b9 01       	movw	r22, r18
    21a2:	4d 85       	ldd	r20, Y+13	; 0x0d
    21a4:	0e 94 4d 14 	call	0x289a	; 0x289a <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    21a8:	8a 81       	ldd	r24, Y+2	; 0x02
    21aa:	8f 3f       	cpi	r24, 0xFF	; 255
    21ac:	a9 f4       	brne	.+42     	; 0x21d8 <xQueueGenericSendFromISR+0x92>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    21ae:	eb 81       	ldd	r30, Y+3	; 0x03
    21b0:	fc 81       	ldd	r31, Y+4	; 0x04
    21b2:	81 89       	ldd	r24, Z+17	; 0x11
    21b4:	88 23       	and	r24, r24
    21b6:	a9 f0       	breq	.+42     	; 0x21e2 <xQueueGenericSendFromISR+0x9c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    21b8:	8b 81       	ldd	r24, Y+3	; 0x03
    21ba:	9c 81       	ldd	r25, Y+4	; 0x04
    21bc:	41 96       	adiw	r24, 0x11	; 17
    21be:	0e 94 0a 20 	call	0x4014	; 0x4014 <xTaskRemoveFromEventList>
    21c2:	88 23       	and	r24, r24
    21c4:	71 f0       	breq	.+28     	; 0x21e2 <xQueueGenericSendFromISR+0x9c>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    21c6:	8b 85       	ldd	r24, Y+11	; 0x0b
    21c8:	9c 85       	ldd	r25, Y+12	; 0x0c
    21ca:	00 97       	sbiw	r24, 0x00	; 0
    21cc:	51 f0       	breq	.+20     	; 0x21e2 <xQueueGenericSendFromISR+0x9c>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    21ce:	eb 85       	ldd	r30, Y+11	; 0x0b
    21d0:	fc 85       	ldd	r31, Y+12	; 0x0c
    21d2:	81 e0       	ldi	r24, 0x01	; 1
    21d4:	80 83       	st	Z, r24
    21d6:	05 c0       	rjmp	.+10     	; 0x21e2 <xQueueGenericSendFromISR+0x9c>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    21d8:	8a 81       	ldd	r24, Y+2	; 0x02
    21da:	8f 5f       	subi	r24, 0xFF	; 255
    21dc:	eb 81       	ldd	r30, Y+3	; 0x03
    21de:	fc 81       	ldd	r31, Y+4	; 0x04
    21e0:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    21e2:	81 e0       	ldi	r24, 0x01	; 1
    21e4:	8e 83       	std	Y+6, r24	; 0x06
    21e6:	01 c0       	rjmp	.+2      	; 0x21ea <xQueueGenericSendFromISR+0xa4>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    21e8:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    21ea:	8e 81       	ldd	r24, Y+6	; 0x06
}
    21ec:	2d 96       	adiw	r28, 0x0d	; 13
    21ee:	0f b6       	in	r0, 0x3f	; 63
    21f0:	f8 94       	cli
    21f2:	de bf       	out	0x3e, r29	; 62
    21f4:	0f be       	out	0x3f, r0	; 63
    21f6:	cd bf       	out	0x3d, r28	; 61
    21f8:	cf 91       	pop	r28
    21fa:	df 91       	pop	r29
    21fc:	08 95       	ret

000021fe <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    21fe:	df 93       	push	r29
    2200:	cf 93       	push	r28
    2202:	cd b7       	in	r28, 0x3d	; 61
    2204:	de b7       	in	r29, 0x3e	; 62
    2206:	2a 97       	sbiw	r28, 0x0a	; 10
    2208:	0f b6       	in	r0, 0x3f	; 63
    220a:	f8 94       	cli
    220c:	de bf       	out	0x3e, r29	; 62
    220e:	0f be       	out	0x3f, r0	; 63
    2210:	cd bf       	out	0x3d, r28	; 61
    2212:	98 87       	std	Y+8, r25	; 0x08
    2214:	8f 83       	std	Y+7, r24	; 0x07
    2216:	7a 87       	std	Y+10, r23	; 0x0a
    2218:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    221a:	8f 81       	ldd	r24, Y+7	; 0x07
    221c:	98 85       	ldd	r25, Y+8	; 0x08
    221e:	9c 83       	std	Y+4, r25	; 0x04
    2220:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2222:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2224:	eb 81       	ldd	r30, Y+3	; 0x03
    2226:	fc 81       	ldd	r31, Y+4	; 0x04
    2228:	82 8d       	ldd	r24, Z+26	; 0x1a
    222a:	8a 83       	std	Y+2, r24	; 0x02

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    222c:	eb 81       	ldd	r30, Y+3	; 0x03
    222e:	fc 81       	ldd	r31, Y+4	; 0x04
    2230:	93 8d       	ldd	r25, Z+27	; 0x1b
    2232:	8a 81       	ldd	r24, Y+2	; 0x02
    2234:	89 17       	cp	r24, r25
    2236:	48 f5       	brcc	.+82     	; 0x228a <xQueueGiveFromISR+0x8c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    2238:	eb 81       	ldd	r30, Y+3	; 0x03
    223a:	fc 81       	ldd	r31, Y+4	; 0x04
    223c:	86 8d       	ldd	r24, Z+30	; 0x1e
    223e:	89 83       	std	Y+1, r24	; 0x01
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2240:	8a 81       	ldd	r24, Y+2	; 0x02
    2242:	8f 5f       	subi	r24, 0xFF	; 255
    2244:	eb 81       	ldd	r30, Y+3	; 0x03
    2246:	fc 81       	ldd	r31, Y+4	; 0x04
    2248:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    224a:	89 81       	ldd	r24, Y+1	; 0x01
    224c:	8f 3f       	cpi	r24, 0xFF	; 255
    224e:	a9 f4       	brne	.+42     	; 0x227a <xQueueGiveFromISR+0x7c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2250:	eb 81       	ldd	r30, Y+3	; 0x03
    2252:	fc 81       	ldd	r31, Y+4	; 0x04
    2254:	81 89       	ldd	r24, Z+17	; 0x11
    2256:	88 23       	and	r24, r24
    2258:	a9 f0       	breq	.+42     	; 0x2284 <xQueueGiveFromISR+0x86>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    225a:	8b 81       	ldd	r24, Y+3	; 0x03
    225c:	9c 81       	ldd	r25, Y+4	; 0x04
    225e:	41 96       	adiw	r24, 0x11	; 17
    2260:	0e 94 0a 20 	call	0x4014	; 0x4014 <xTaskRemoveFromEventList>
    2264:	88 23       	and	r24, r24
    2266:	71 f0       	breq	.+28     	; 0x2284 <xQueueGiveFromISR+0x86>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    2268:	89 85       	ldd	r24, Y+9	; 0x09
    226a:	9a 85       	ldd	r25, Y+10	; 0x0a
    226c:	00 97       	sbiw	r24, 0x00	; 0
    226e:	51 f0       	breq	.+20     	; 0x2284 <xQueueGiveFromISR+0x86>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    2270:	e9 85       	ldd	r30, Y+9	; 0x09
    2272:	fa 85       	ldd	r31, Y+10	; 0x0a
    2274:	81 e0       	ldi	r24, 0x01	; 1
    2276:	80 83       	st	Z, r24
    2278:	05 c0       	rjmp	.+10     	; 0x2284 <xQueueGiveFromISR+0x86>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    227a:	89 81       	ldd	r24, Y+1	; 0x01
    227c:	8f 5f       	subi	r24, 0xFF	; 255
    227e:	eb 81       	ldd	r30, Y+3	; 0x03
    2280:	fc 81       	ldd	r31, Y+4	; 0x04
    2282:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    2284:	81 e0       	ldi	r24, 0x01	; 1
    2286:	8e 83       	std	Y+6, r24	; 0x06
    2288:	01 c0       	rjmp	.+2      	; 0x228c <xQueueGiveFromISR+0x8e>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    228a:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    228c:	8e 81       	ldd	r24, Y+6	; 0x06
}
    228e:	2a 96       	adiw	r28, 0x0a	; 10
    2290:	0f b6       	in	r0, 0x3f	; 63
    2292:	f8 94       	cli
    2294:	de bf       	out	0x3e, r29	; 62
    2296:	0f be       	out	0x3f, r0	; 63
    2298:	cd bf       	out	0x3d, r28	; 61
    229a:	cf 91       	pop	r28
    229c:	df 91       	pop	r29
    229e:	08 95       	ret

000022a0 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    22a0:	df 93       	push	r29
    22a2:	cf 93       	push	r28
    22a4:	cd b7       	in	r28, 0x3d	; 61
    22a6:	de b7       	in	r29, 0x3e	; 62
    22a8:	2e 97       	sbiw	r28, 0x0e	; 14
    22aa:	0f b6       	in	r0, 0x3f	; 63
    22ac:	f8 94       	cli
    22ae:	de bf       	out	0x3e, r29	; 62
    22b0:	0f be       	out	0x3f, r0	; 63
    22b2:	cd bf       	out	0x3d, r28	; 61
    22b4:	99 87       	std	Y+9, r25	; 0x09
    22b6:	88 87       	std	Y+8, r24	; 0x08
    22b8:	7b 87       	std	Y+11, r23	; 0x0b
    22ba:	6a 87       	std	Y+10, r22	; 0x0a
    22bc:	5d 87       	std	Y+13, r21	; 0x0d
    22be:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    22c0:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    22c2:	88 85       	ldd	r24, Y+8	; 0x08
    22c4:	99 85       	ldd	r25, Y+9	; 0x09
    22c6:	9b 83       	std	Y+3, r25	; 0x03
    22c8:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    22ca:	0f b6       	in	r0, 0x3f	; 63
    22cc:	f8 94       	cli
    22ce:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    22d0:	ea 81       	ldd	r30, Y+2	; 0x02
    22d2:	fb 81       	ldd	r31, Y+3	; 0x03
    22d4:	82 8d       	ldd	r24, Z+26	; 0x1a
    22d6:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    22d8:	89 81       	ldd	r24, Y+1	; 0x01
    22da:	88 23       	and	r24, r24
    22dc:	f9 f0       	breq	.+62     	; 0x231c <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    22de:	8a 81       	ldd	r24, Y+2	; 0x02
    22e0:	9b 81       	ldd	r25, Y+3	; 0x03
    22e2:	2a 85       	ldd	r18, Y+10	; 0x0a
    22e4:	3b 85       	ldd	r19, Y+11	; 0x0b
    22e6:	b9 01       	movw	r22, r18
    22e8:	0e 94 f3 14 	call	0x29e6	; 0x29e6 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    22ec:	89 81       	ldd	r24, Y+1	; 0x01
    22ee:	81 50       	subi	r24, 0x01	; 1
    22f0:	ea 81       	ldd	r30, Y+2	; 0x02
    22f2:	fb 81       	ldd	r31, Y+3	; 0x03
    22f4:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    22f6:	ea 81       	ldd	r30, Y+2	; 0x02
    22f8:	fb 81       	ldd	r31, Y+3	; 0x03
    22fa:	80 85       	ldd	r24, Z+8	; 0x08
    22fc:	88 23       	and	r24, r24
    22fe:	49 f0       	breq	.+18     	; 0x2312 <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2300:	8a 81       	ldd	r24, Y+2	; 0x02
    2302:	9b 81       	ldd	r25, Y+3	; 0x03
    2304:	08 96       	adiw	r24, 0x08	; 8
    2306:	0e 94 0a 20 	call	0x4014	; 0x4014 <xTaskRemoveFromEventList>
    230a:	88 23       	and	r24, r24
    230c:	11 f0       	breq	.+4      	; 0x2312 <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    230e:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2312:	0f 90       	pop	r0
    2314:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2316:	81 e0       	ldi	r24, 0x01	; 1
    2318:	8e 87       	std	Y+14, r24	; 0x0e
    231a:	63 c0       	rjmp	.+198    	; 0x23e2 <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    231c:	8c 85       	ldd	r24, Y+12	; 0x0c
    231e:	9d 85       	ldd	r25, Y+13	; 0x0d
    2320:	00 97       	sbiw	r24, 0x00	; 0
    2322:	21 f4       	brne	.+8      	; 0x232c <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2324:	0f 90       	pop	r0
    2326:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2328:	1e 86       	std	Y+14, r1	; 0x0e
    232a:	5b c0       	rjmp	.+182    	; 0x23e2 <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    232c:	8c 81       	ldd	r24, Y+4	; 0x04
    232e:	88 23       	and	r24, r24
    2330:	31 f4       	brne	.+12     	; 0x233e <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2332:	ce 01       	movw	r24, r28
    2334:	05 96       	adiw	r24, 0x05	; 5
    2336:	0e 94 7a 22 	call	0x44f4	; 0x44f4 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    233a:	81 e0       	ldi	r24, 0x01	; 1
    233c:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    233e:	0f 90       	pop	r0
    2340:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2342:	0e 94 44 1b 	call	0x3688	; 0x3688 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2346:	0f b6       	in	r0, 0x3f	; 63
    2348:	f8 94       	cli
    234a:	0f 92       	push	r0
    234c:	ea 81       	ldd	r30, Y+2	; 0x02
    234e:	fb 81       	ldd	r31, Y+3	; 0x03
    2350:	85 8d       	ldd	r24, Z+29	; 0x1d
    2352:	8f 3f       	cpi	r24, 0xFF	; 255
    2354:	19 f4       	brne	.+6      	; 0x235c <xQueueReceive+0xbc>
    2356:	ea 81       	ldd	r30, Y+2	; 0x02
    2358:	fb 81       	ldd	r31, Y+3	; 0x03
    235a:	15 8e       	std	Z+29, r1	; 0x1d
    235c:	ea 81       	ldd	r30, Y+2	; 0x02
    235e:	fb 81       	ldd	r31, Y+3	; 0x03
    2360:	86 8d       	ldd	r24, Z+30	; 0x1e
    2362:	8f 3f       	cpi	r24, 0xFF	; 255
    2364:	19 f4       	brne	.+6      	; 0x236c <xQueueReceive+0xcc>
    2366:	ea 81       	ldd	r30, Y+2	; 0x02
    2368:	fb 81       	ldd	r31, Y+3	; 0x03
    236a:	16 8e       	std	Z+30, r1	; 0x1e
    236c:	0f 90       	pop	r0
    236e:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2370:	ce 01       	movw	r24, r28
    2372:	05 96       	adiw	r24, 0x05	; 5
    2374:	9e 01       	movw	r18, r28
    2376:	24 5f       	subi	r18, 0xF4	; 244
    2378:	3f 4f       	sbci	r19, 0xFF	; 255
    237a:	b9 01       	movw	r22, r18
    237c:	0e 94 93 22 	call	0x4526	; 0x4526 <xTaskCheckForTimeOut>
    2380:	88 23       	and	r24, r24
    2382:	09 f5       	brne	.+66     	; 0x23c6 <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2384:	8a 81       	ldd	r24, Y+2	; 0x02
    2386:	9b 81       	ldd	r25, Y+3	; 0x03
    2388:	0e 94 8d 15 	call	0x2b1a	; 0x2b1a <prvIsQueueEmpty>
    238c:	88 23       	and	r24, r24
    238e:	a1 f0       	breq	.+40     	; 0x23b8 <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2390:	8a 81       	ldd	r24, Y+2	; 0x02
    2392:	9b 81       	ldd	r25, Y+3	; 0x03
    2394:	41 96       	adiw	r24, 0x11	; 17
    2396:	2c 85       	ldd	r18, Y+12	; 0x0c
    2398:	3d 85       	ldd	r19, Y+13	; 0x0d
    239a:	b9 01       	movw	r22, r18
    239c:	0e 94 21 1f 	call	0x3e42	; 0x3e42 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    23a0:	8a 81       	ldd	r24, Y+2	; 0x02
    23a2:	9b 81       	ldd	r25, Y+3	; 0x03
    23a4:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    23a8:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>
    23ac:	88 23       	and	r24, r24
    23ae:	09 f0       	breq	.+2      	; 0x23b2 <xQueueReceive+0x112>
    23b0:	8c cf       	rjmp	.-232    	; 0x22ca <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    23b2:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    23b6:	89 cf       	rjmp	.-238    	; 0x22ca <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    23b8:	8a 81       	ldd	r24, Y+2	; 0x02
    23ba:	9b 81       	ldd	r25, Y+3	; 0x03
    23bc:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    23c0:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>
    23c4:	82 cf       	rjmp	.-252    	; 0x22ca <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    23c6:	8a 81       	ldd	r24, Y+2	; 0x02
    23c8:	9b 81       	ldd	r25, Y+3	; 0x03
    23ca:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    23ce:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    23d2:	8a 81       	ldd	r24, Y+2	; 0x02
    23d4:	9b 81       	ldd	r25, Y+3	; 0x03
    23d6:	0e 94 8d 15 	call	0x2b1a	; 0x2b1a <prvIsQueueEmpty>
    23da:	88 23       	and	r24, r24
    23dc:	09 f4       	brne	.+2      	; 0x23e0 <xQueueReceive+0x140>
    23de:	75 cf       	rjmp	.-278    	; 0x22ca <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    23e0:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    23e2:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    23e4:	2e 96       	adiw	r28, 0x0e	; 14
    23e6:	0f b6       	in	r0, 0x3f	; 63
    23e8:	f8 94       	cli
    23ea:	de bf       	out	0x3e, r29	; 62
    23ec:	0f be       	out	0x3f, r0	; 63
    23ee:	cd bf       	out	0x3d, r28	; 61
    23f0:	cf 91       	pop	r28
    23f2:	df 91       	pop	r29
    23f4:	08 95       	ret

000023f6 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    23f6:	df 93       	push	r29
    23f8:	cf 93       	push	r28
    23fa:	cd b7       	in	r28, 0x3d	; 61
    23fc:	de b7       	in	r29, 0x3e	; 62
    23fe:	2c 97       	sbiw	r28, 0x0c	; 12
    2400:	0f b6       	in	r0, 0x3f	; 63
    2402:	f8 94       	cli
    2404:	de bf       	out	0x3e, r29	; 62
    2406:	0f be       	out	0x3f, r0	; 63
    2408:	cd bf       	out	0x3d, r28	; 61
    240a:	99 87       	std	Y+9, r25	; 0x09
    240c:	88 87       	std	Y+8, r24	; 0x08
    240e:	7b 87       	std	Y+11, r23	; 0x0b
    2410:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    2412:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2414:	88 85       	ldd	r24, Y+8	; 0x08
    2416:	99 85       	ldd	r25, Y+9	; 0x09
    2418:	9b 83       	std	Y+3, r25	; 0x03
    241a:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    241c:	0f b6       	in	r0, 0x3f	; 63
    241e:	f8 94       	cli
    2420:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2422:	ea 81       	ldd	r30, Y+2	; 0x02
    2424:	fb 81       	ldd	r31, Y+3	; 0x03
    2426:	82 8d       	ldd	r24, Z+26	; 0x1a
    2428:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    242a:	89 81       	ldd	r24, Y+1	; 0x01
    242c:	88 23       	and	r24, r24
    242e:	c1 f0       	breq	.+48     	; 0x2460 <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2430:	89 81       	ldd	r24, Y+1	; 0x01
    2432:	81 50       	subi	r24, 0x01	; 1
    2434:	ea 81       	ldd	r30, Y+2	; 0x02
    2436:	fb 81       	ldd	r31, Y+3	; 0x03
    2438:	82 8f       	std	Z+26, r24	; 0x1a
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    243a:	ea 81       	ldd	r30, Y+2	; 0x02
    243c:	fb 81       	ldd	r31, Y+3	; 0x03
    243e:	80 85       	ldd	r24, Z+8	; 0x08
    2440:	88 23       	and	r24, r24
    2442:	49 f0       	breq	.+18     	; 0x2456 <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2444:	8a 81       	ldd	r24, Y+2	; 0x02
    2446:	9b 81       	ldd	r25, Y+3	; 0x03
    2448:	08 96       	adiw	r24, 0x08	; 8
    244a:	0e 94 0a 20 	call	0x4014	; 0x4014 <xTaskRemoveFromEventList>
    244e:	88 23       	and	r24, r24
    2450:	11 f0       	breq	.+4      	; 0x2456 <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2452:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2456:	0f 90       	pop	r0
    2458:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    245a:	81 e0       	ldi	r24, 0x01	; 1
    245c:	8c 87       	std	Y+12, r24	; 0x0c
    245e:	63 c0       	rjmp	.+198    	; 0x2526 <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2460:	8a 85       	ldd	r24, Y+10	; 0x0a
    2462:	9b 85       	ldd	r25, Y+11	; 0x0b
    2464:	00 97       	sbiw	r24, 0x00	; 0
    2466:	21 f4       	brne	.+8      	; 0x2470 <xQueueSemaphoreTake+0x7a>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    2468:	0f 90       	pop	r0
    246a:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    246c:	1c 86       	std	Y+12, r1	; 0x0c
    246e:	5b c0       	rjmp	.+182    	; 0x2526 <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    2470:	8c 81       	ldd	r24, Y+4	; 0x04
    2472:	88 23       	and	r24, r24
    2474:	31 f4       	brne	.+12     	; 0x2482 <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2476:	ce 01       	movw	r24, r28
    2478:	05 96       	adiw	r24, 0x05	; 5
    247a:	0e 94 7a 22 	call	0x44f4	; 0x44f4 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    247e:	81 e0       	ldi	r24, 0x01	; 1
    2480:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2482:	0f 90       	pop	r0
    2484:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2486:	0e 94 44 1b 	call	0x3688	; 0x3688 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    248a:	0f b6       	in	r0, 0x3f	; 63
    248c:	f8 94       	cli
    248e:	0f 92       	push	r0
    2490:	ea 81       	ldd	r30, Y+2	; 0x02
    2492:	fb 81       	ldd	r31, Y+3	; 0x03
    2494:	85 8d       	ldd	r24, Z+29	; 0x1d
    2496:	8f 3f       	cpi	r24, 0xFF	; 255
    2498:	19 f4       	brne	.+6      	; 0x24a0 <xQueueSemaphoreTake+0xaa>
    249a:	ea 81       	ldd	r30, Y+2	; 0x02
    249c:	fb 81       	ldd	r31, Y+3	; 0x03
    249e:	15 8e       	std	Z+29, r1	; 0x1d
    24a0:	ea 81       	ldd	r30, Y+2	; 0x02
    24a2:	fb 81       	ldd	r31, Y+3	; 0x03
    24a4:	86 8d       	ldd	r24, Z+30	; 0x1e
    24a6:	8f 3f       	cpi	r24, 0xFF	; 255
    24a8:	19 f4       	brne	.+6      	; 0x24b0 <xQueueSemaphoreTake+0xba>
    24aa:	ea 81       	ldd	r30, Y+2	; 0x02
    24ac:	fb 81       	ldd	r31, Y+3	; 0x03
    24ae:	16 8e       	std	Z+30, r1	; 0x1e
    24b0:	0f 90       	pop	r0
    24b2:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    24b4:	ce 01       	movw	r24, r28
    24b6:	05 96       	adiw	r24, 0x05	; 5
    24b8:	9e 01       	movw	r18, r28
    24ba:	26 5f       	subi	r18, 0xF6	; 246
    24bc:	3f 4f       	sbci	r19, 0xFF	; 255
    24be:	b9 01       	movw	r22, r18
    24c0:	0e 94 93 22 	call	0x4526	; 0x4526 <xTaskCheckForTimeOut>
    24c4:	88 23       	and	r24, r24
    24c6:	09 f5       	brne	.+66     	; 0x250a <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    24c8:	8a 81       	ldd	r24, Y+2	; 0x02
    24ca:	9b 81       	ldd	r25, Y+3	; 0x03
    24cc:	0e 94 8d 15 	call	0x2b1a	; 0x2b1a <prvIsQueueEmpty>
    24d0:	88 23       	and	r24, r24
    24d2:	a1 f0       	breq	.+40     	; 0x24fc <xQueueSemaphoreTake+0x106>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    24d4:	8a 81       	ldd	r24, Y+2	; 0x02
    24d6:	9b 81       	ldd	r25, Y+3	; 0x03
    24d8:	41 96       	adiw	r24, 0x11	; 17
    24da:	2a 85       	ldd	r18, Y+10	; 0x0a
    24dc:	3b 85       	ldd	r19, Y+11	; 0x0b
    24de:	b9 01       	movw	r22, r18
    24e0:	0e 94 21 1f 	call	0x3e42	; 0x3e42 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    24e4:	8a 81       	ldd	r24, Y+2	; 0x02
    24e6:	9b 81       	ldd	r25, Y+3	; 0x03
    24e8:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    24ec:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>
    24f0:	88 23       	and	r24, r24
    24f2:	09 f0       	breq	.+2      	; 0x24f6 <xQueueSemaphoreTake+0x100>
    24f4:	93 cf       	rjmp	.-218    	; 0x241c <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    24f6:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    24fa:	90 cf       	rjmp	.-224    	; 0x241c <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    24fc:	8a 81       	ldd	r24, Y+2	; 0x02
    24fe:	9b 81       	ldd	r25, Y+3	; 0x03
    2500:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2504:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>
    2508:	89 cf       	rjmp	.-238    	; 0x241c <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    250a:	8a 81       	ldd	r24, Y+2	; 0x02
    250c:	9b 81       	ldd	r25, Y+3	; 0x03
    250e:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2512:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2516:	8a 81       	ldd	r24, Y+2	; 0x02
    2518:	9b 81       	ldd	r25, Y+3	; 0x03
    251a:	0e 94 8d 15 	call	0x2b1a	; 0x2b1a <prvIsQueueEmpty>
    251e:	88 23       	and	r24, r24
    2520:	09 f4       	brne	.+2      	; 0x2524 <xQueueSemaphoreTake+0x12e>
    2522:	7c cf       	rjmp	.-264    	; 0x241c <xQueueSemaphoreTake+0x26>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2524:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2526:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    2528:	2c 96       	adiw	r28, 0x0c	; 12
    252a:	0f b6       	in	r0, 0x3f	; 63
    252c:	f8 94       	cli
    252e:	de bf       	out	0x3e, r29	; 62
    2530:	0f be       	out	0x3f, r0	; 63
    2532:	cd bf       	out	0x3d, r28	; 61
    2534:	cf 91       	pop	r28
    2536:	df 91       	pop	r29
    2538:	08 95       	ret

0000253a <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    253a:	df 93       	push	r29
    253c:	cf 93       	push	r28
    253e:	cd b7       	in	r28, 0x3d	; 61
    2540:	de b7       	in	r29, 0x3e	; 62
    2542:	60 97       	sbiw	r28, 0x10	; 16
    2544:	0f b6       	in	r0, 0x3f	; 63
    2546:	f8 94       	cli
    2548:	de bf       	out	0x3e, r29	; 62
    254a:	0f be       	out	0x3f, r0	; 63
    254c:	cd bf       	out	0x3d, r28	; 61
    254e:	9b 87       	std	Y+11, r25	; 0x0b
    2550:	8a 87       	std	Y+10, r24	; 0x0a
    2552:	7d 87       	std	Y+13, r23	; 0x0d
    2554:	6c 87       	std	Y+12, r22	; 0x0c
    2556:	5f 87       	std	Y+15, r21	; 0x0f
    2558:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    255a:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    255c:	8a 85       	ldd	r24, Y+10	; 0x0a
    255e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2560:	9b 83       	std	Y+3, r25	; 0x03
    2562:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2564:	0f b6       	in	r0, 0x3f	; 63
    2566:	f8 94       	cli
    2568:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    256a:	ea 81       	ldd	r30, Y+2	; 0x02
    256c:	fb 81       	ldd	r31, Y+3	; 0x03
    256e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2570:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2572:	89 81       	ldd	r24, Y+1	; 0x01
    2574:	88 23       	and	r24, r24
    2576:	31 f1       	breq	.+76     	; 0x25c4 <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2578:	ea 81       	ldd	r30, Y+2	; 0x02
    257a:	fb 81       	ldd	r31, Y+3	; 0x03
    257c:	86 81       	ldd	r24, Z+6	; 0x06
    257e:	97 81       	ldd	r25, Z+7	; 0x07
    2580:	9d 83       	std	Y+5, r25	; 0x05
    2582:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2584:	8a 81       	ldd	r24, Y+2	; 0x02
    2586:	9b 81       	ldd	r25, Y+3	; 0x03
    2588:	2c 85       	ldd	r18, Y+12	; 0x0c
    258a:	3d 85       	ldd	r19, Y+13	; 0x0d
    258c:	b9 01       	movw	r22, r18
    258e:	0e 94 f3 14 	call	0x29e6	; 0x29e6 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2592:	ea 81       	ldd	r30, Y+2	; 0x02
    2594:	fb 81       	ldd	r31, Y+3	; 0x03
    2596:	8c 81       	ldd	r24, Y+4	; 0x04
    2598:	9d 81       	ldd	r25, Y+5	; 0x05
    259a:	97 83       	std	Z+7, r25	; 0x07
    259c:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    259e:	ea 81       	ldd	r30, Y+2	; 0x02
    25a0:	fb 81       	ldd	r31, Y+3	; 0x03
    25a2:	81 89       	ldd	r24, Z+17	; 0x11
    25a4:	88 23       	and	r24, r24
    25a6:	49 f0       	breq	.+18     	; 0x25ba <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    25a8:	8a 81       	ldd	r24, Y+2	; 0x02
    25aa:	9b 81       	ldd	r25, Y+3	; 0x03
    25ac:	41 96       	adiw	r24, 0x11	; 17
    25ae:	0e 94 0a 20 	call	0x4014	; 0x4014 <xTaskRemoveFromEventList>
    25b2:	88 23       	and	r24, r24
    25b4:	11 f0       	breq	.+4      	; 0x25ba <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    25b6:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    25ba:	0f 90       	pop	r0
    25bc:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    25be:	81 e0       	ldi	r24, 0x01	; 1
    25c0:	88 8b       	std	Y+16, r24	; 0x10
    25c2:	63 c0       	rjmp	.+198    	; 0x268a <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    25c4:	8e 85       	ldd	r24, Y+14	; 0x0e
    25c6:	9f 85       	ldd	r25, Y+15	; 0x0f
    25c8:	00 97       	sbiw	r24, 0x00	; 0
    25ca:	21 f4       	brne	.+8      	; 0x25d4 <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    25cc:	0f 90       	pop	r0
    25ce:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    25d0:	18 8a       	std	Y+16, r1	; 0x10
    25d2:	5b c0       	rjmp	.+182    	; 0x268a <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    25d4:	8e 81       	ldd	r24, Y+6	; 0x06
    25d6:	88 23       	and	r24, r24
    25d8:	31 f4       	brne	.+12     	; 0x25e6 <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    25da:	ce 01       	movw	r24, r28
    25dc:	07 96       	adiw	r24, 0x07	; 7
    25de:	0e 94 7a 22 	call	0x44f4	; 0x44f4 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    25e2:	81 e0       	ldi	r24, 0x01	; 1
    25e4:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    25e6:	0f 90       	pop	r0
    25e8:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    25ea:	0e 94 44 1b 	call	0x3688	; 0x3688 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    25ee:	0f b6       	in	r0, 0x3f	; 63
    25f0:	f8 94       	cli
    25f2:	0f 92       	push	r0
    25f4:	ea 81       	ldd	r30, Y+2	; 0x02
    25f6:	fb 81       	ldd	r31, Y+3	; 0x03
    25f8:	85 8d       	ldd	r24, Z+29	; 0x1d
    25fa:	8f 3f       	cpi	r24, 0xFF	; 255
    25fc:	19 f4       	brne	.+6      	; 0x2604 <xQueuePeek+0xca>
    25fe:	ea 81       	ldd	r30, Y+2	; 0x02
    2600:	fb 81       	ldd	r31, Y+3	; 0x03
    2602:	15 8e       	std	Z+29, r1	; 0x1d
    2604:	ea 81       	ldd	r30, Y+2	; 0x02
    2606:	fb 81       	ldd	r31, Y+3	; 0x03
    2608:	86 8d       	ldd	r24, Z+30	; 0x1e
    260a:	8f 3f       	cpi	r24, 0xFF	; 255
    260c:	19 f4       	brne	.+6      	; 0x2614 <xQueuePeek+0xda>
    260e:	ea 81       	ldd	r30, Y+2	; 0x02
    2610:	fb 81       	ldd	r31, Y+3	; 0x03
    2612:	16 8e       	std	Z+30, r1	; 0x1e
    2614:	0f 90       	pop	r0
    2616:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2618:	ce 01       	movw	r24, r28
    261a:	07 96       	adiw	r24, 0x07	; 7
    261c:	9e 01       	movw	r18, r28
    261e:	22 5f       	subi	r18, 0xF2	; 242
    2620:	3f 4f       	sbci	r19, 0xFF	; 255
    2622:	b9 01       	movw	r22, r18
    2624:	0e 94 93 22 	call	0x4526	; 0x4526 <xTaskCheckForTimeOut>
    2628:	88 23       	and	r24, r24
    262a:	09 f5       	brne	.+66     	; 0x266e <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    262c:	8a 81       	ldd	r24, Y+2	; 0x02
    262e:	9b 81       	ldd	r25, Y+3	; 0x03
    2630:	0e 94 8d 15 	call	0x2b1a	; 0x2b1a <prvIsQueueEmpty>
    2634:	88 23       	and	r24, r24
    2636:	a1 f0       	breq	.+40     	; 0x2660 <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2638:	8a 81       	ldd	r24, Y+2	; 0x02
    263a:	9b 81       	ldd	r25, Y+3	; 0x03
    263c:	41 96       	adiw	r24, 0x11	; 17
    263e:	2e 85       	ldd	r18, Y+14	; 0x0e
    2640:	3f 85       	ldd	r19, Y+15	; 0x0f
    2642:	b9 01       	movw	r22, r18
    2644:	0e 94 21 1f 	call	0x3e42	; 0x3e42 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2648:	8a 81       	ldd	r24, Y+2	; 0x02
    264a:	9b 81       	ldd	r25, Y+3	; 0x03
    264c:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2650:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>
    2654:	88 23       	and	r24, r24
    2656:	09 f0       	breq	.+2      	; 0x265a <xQueuePeek+0x120>
    2658:	85 cf       	rjmp	.-246    	; 0x2564 <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    265a:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    265e:	82 cf       	rjmp	.-252    	; 0x2564 <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    2660:	8a 81       	ldd	r24, Y+2	; 0x02
    2662:	9b 81       	ldd	r25, Y+3	; 0x03
    2664:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2668:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>
    266c:	7b cf       	rjmp	.-266    	; 0x2564 <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    266e:	8a 81       	ldd	r24, Y+2	; 0x02
    2670:	9b 81       	ldd	r25, Y+3	; 0x03
    2672:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2676:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    267a:	8a 81       	ldd	r24, Y+2	; 0x02
    267c:	9b 81       	ldd	r25, Y+3	; 0x03
    267e:	0e 94 8d 15 	call	0x2b1a	; 0x2b1a <prvIsQueueEmpty>
    2682:	88 23       	and	r24, r24
    2684:	09 f4       	brne	.+2      	; 0x2688 <xQueuePeek+0x14e>
    2686:	6e cf       	rjmp	.-292    	; 0x2564 <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2688:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    268a:	88 89       	ldd	r24, Y+16	; 0x10
}
    268c:	60 96       	adiw	r28, 0x10	; 16
    268e:	0f b6       	in	r0, 0x3f	; 63
    2690:	f8 94       	cli
    2692:	de bf       	out	0x3e, r29	; 62
    2694:	0f be       	out	0x3f, r0	; 63
    2696:	cd bf       	out	0x3d, r28	; 61
    2698:	cf 91       	pop	r28
    269a:	df 91       	pop	r29
    269c:	08 95       	ret

0000269e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    269e:	df 93       	push	r29
    26a0:	cf 93       	push	r28
    26a2:	cd b7       	in	r28, 0x3d	; 61
    26a4:	de b7       	in	r29, 0x3e	; 62
    26a6:	2c 97       	sbiw	r28, 0x0c	; 12
    26a8:	0f b6       	in	r0, 0x3f	; 63
    26aa:	f8 94       	cli
    26ac:	de bf       	out	0x3e, r29	; 62
    26ae:	0f be       	out	0x3f, r0	; 63
    26b0:	cd bf       	out	0x3d, r28	; 61
    26b2:	98 87       	std	Y+8, r25	; 0x08
    26b4:	8f 83       	std	Y+7, r24	; 0x07
    26b6:	7a 87       	std	Y+10, r23	; 0x0a
    26b8:	69 87       	std	Y+9, r22	; 0x09
    26ba:	5c 87       	std	Y+12, r21	; 0x0c
    26bc:	4b 87       	std	Y+11, r20	; 0x0b
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    26be:	8f 81       	ldd	r24, Y+7	; 0x07
    26c0:	98 85       	ldd	r25, Y+8	; 0x08
    26c2:	9c 83       	std	Y+4, r25	; 0x04
    26c4:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    26c6:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    26c8:	eb 81       	ldd	r30, Y+3	; 0x03
    26ca:	fc 81       	ldd	r31, Y+4	; 0x04
    26cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    26ce:	8a 83       	std	Y+2, r24	; 0x02

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    26d0:	8a 81       	ldd	r24, Y+2	; 0x02
    26d2:	88 23       	and	r24, r24
    26d4:	81 f1       	breq	.+96     	; 0x2736 <xQueueReceiveFromISR+0x98>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    26d6:	eb 81       	ldd	r30, Y+3	; 0x03
    26d8:	fc 81       	ldd	r31, Y+4	; 0x04
    26da:	85 8d       	ldd	r24, Z+29	; 0x1d
    26dc:	89 83       	std	Y+1, r24	; 0x01

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    26de:	8b 81       	ldd	r24, Y+3	; 0x03
    26e0:	9c 81       	ldd	r25, Y+4	; 0x04
    26e2:	29 85       	ldd	r18, Y+9	; 0x09
    26e4:	3a 85       	ldd	r19, Y+10	; 0x0a
    26e6:	b9 01       	movw	r22, r18
    26e8:	0e 94 f3 14 	call	0x29e6	; 0x29e6 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    26ec:	8a 81       	ldd	r24, Y+2	; 0x02
    26ee:	81 50       	subi	r24, 0x01	; 1
    26f0:	eb 81       	ldd	r30, Y+3	; 0x03
    26f2:	fc 81       	ldd	r31, Y+4	; 0x04
    26f4:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    26f6:	89 81       	ldd	r24, Y+1	; 0x01
    26f8:	8f 3f       	cpi	r24, 0xFF	; 255
    26fa:	a9 f4       	brne	.+42     	; 0x2726 <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    26fc:	eb 81       	ldd	r30, Y+3	; 0x03
    26fe:	fc 81       	ldd	r31, Y+4	; 0x04
    2700:	80 85       	ldd	r24, Z+8	; 0x08
    2702:	88 23       	and	r24, r24
    2704:	a9 f0       	breq	.+42     	; 0x2730 <xQueueReceiveFromISR+0x92>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2706:	8b 81       	ldd	r24, Y+3	; 0x03
    2708:	9c 81       	ldd	r25, Y+4	; 0x04
    270a:	08 96       	adiw	r24, 0x08	; 8
    270c:	0e 94 0a 20 	call	0x4014	; 0x4014 <xTaskRemoveFromEventList>
    2710:	88 23       	and	r24, r24
    2712:	71 f0       	breq	.+28     	; 0x2730 <xQueueReceiveFromISR+0x92>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    2714:	8b 85       	ldd	r24, Y+11	; 0x0b
    2716:	9c 85       	ldd	r25, Y+12	; 0x0c
    2718:	00 97       	sbiw	r24, 0x00	; 0
    271a:	51 f0       	breq	.+20     	; 0x2730 <xQueueReceiveFromISR+0x92>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    271c:	eb 85       	ldd	r30, Y+11	; 0x0b
    271e:	fc 85       	ldd	r31, Y+12	; 0x0c
    2720:	81 e0       	ldi	r24, 0x01	; 1
    2722:	80 83       	st	Z, r24
    2724:	05 c0       	rjmp	.+10     	; 0x2730 <xQueueReceiveFromISR+0x92>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2726:	89 81       	ldd	r24, Y+1	; 0x01
    2728:	8f 5f       	subi	r24, 0xFF	; 255
    272a:	eb 81       	ldd	r30, Y+3	; 0x03
    272c:	fc 81       	ldd	r31, Y+4	; 0x04
    272e:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    2730:	81 e0       	ldi	r24, 0x01	; 1
    2732:	8e 83       	std	Y+6, r24	; 0x06
    2734:	01 c0       	rjmp	.+2      	; 0x2738 <xQueueReceiveFromISR+0x9a>
        }
        else
        {
            xReturn = pdFAIL;
    2736:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2738:	8e 81       	ldd	r24, Y+6	; 0x06
}
    273a:	2c 96       	adiw	r28, 0x0c	; 12
    273c:	0f b6       	in	r0, 0x3f	; 63
    273e:	f8 94       	cli
    2740:	de bf       	out	0x3e, r29	; 62
    2742:	0f be       	out	0x3f, r0	; 63
    2744:	cd bf       	out	0x3d, r28	; 61
    2746:	cf 91       	pop	r28
    2748:	df 91       	pop	r29
    274a:	08 95       	ret

0000274c <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    274c:	df 93       	push	r29
    274e:	cf 93       	push	r28
    2750:	cd b7       	in	r28, 0x3d	; 61
    2752:	de b7       	in	r29, 0x3e	; 62
    2754:	2a 97       	sbiw	r28, 0x0a	; 10
    2756:	0f b6       	in	r0, 0x3f	; 63
    2758:	f8 94       	cli
    275a:	de bf       	out	0x3e, r29	; 62
    275c:	0f be       	out	0x3f, r0	; 63
    275e:	cd bf       	out	0x3d, r28	; 61
    2760:	98 87       	std	Y+8, r25	; 0x08
    2762:	8f 83       	std	Y+7, r24	; 0x07
    2764:	7a 87       	std	Y+10, r23	; 0x0a
    2766:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    2768:	8f 81       	ldd	r24, Y+7	; 0x07
    276a:	98 85       	ldd	r25, Y+8	; 0x08
    276c:	9a 83       	std	Y+2, r25	; 0x02
    276e:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2770:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2772:	e9 81       	ldd	r30, Y+1	; 0x01
    2774:	fa 81       	ldd	r31, Y+2	; 0x02
    2776:	82 8d       	ldd	r24, Z+26	; 0x1a
    2778:	88 23       	and	r24, r24
    277a:	b1 f0       	breq	.+44     	; 0x27a8 <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    277c:	e9 81       	ldd	r30, Y+1	; 0x01
    277e:	fa 81       	ldd	r31, Y+2	; 0x02
    2780:	86 81       	ldd	r24, Z+6	; 0x06
    2782:	97 81       	ldd	r25, Z+7	; 0x07
    2784:	9c 83       	std	Y+4, r25	; 0x04
    2786:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2788:	89 81       	ldd	r24, Y+1	; 0x01
    278a:	9a 81       	ldd	r25, Y+2	; 0x02
    278c:	29 85       	ldd	r18, Y+9	; 0x09
    278e:	3a 85       	ldd	r19, Y+10	; 0x0a
    2790:	b9 01       	movw	r22, r18
    2792:	0e 94 f3 14 	call	0x29e6	; 0x29e6 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2796:	e9 81       	ldd	r30, Y+1	; 0x01
    2798:	fa 81       	ldd	r31, Y+2	; 0x02
    279a:	8b 81       	ldd	r24, Y+3	; 0x03
    279c:	9c 81       	ldd	r25, Y+4	; 0x04
    279e:	97 83       	std	Z+7, r25	; 0x07
    27a0:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    27a2:	81 e0       	ldi	r24, 0x01	; 1
    27a4:	8e 83       	std	Y+6, r24	; 0x06
    27a6:	01 c0       	rjmp	.+2      	; 0x27aa <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    27a8:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    27aa:	8e 81       	ldd	r24, Y+6	; 0x06
}
    27ac:	2a 96       	adiw	r28, 0x0a	; 10
    27ae:	0f b6       	in	r0, 0x3f	; 63
    27b0:	f8 94       	cli
    27b2:	de bf       	out	0x3e, r29	; 62
    27b4:	0f be       	out	0x3f, r0	; 63
    27b6:	cd bf       	out	0x3d, r28	; 61
    27b8:	cf 91       	pop	r28
    27ba:	df 91       	pop	r29
    27bc:	08 95       	ret

000027be <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    27be:	df 93       	push	r29
    27c0:	cf 93       	push	r28
    27c2:	00 d0       	rcall	.+0      	; 0x27c4 <uxQueueMessagesWaiting+0x6>
    27c4:	0f 92       	push	r0
    27c6:	cd b7       	in	r28, 0x3d	; 61
    27c8:	de b7       	in	r29, 0x3e	; 62
    27ca:	9b 83       	std	Y+3, r25	; 0x03
    27cc:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    27ce:	0f b6       	in	r0, 0x3f	; 63
    27d0:	f8 94       	cli
    27d2:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    27d4:	ea 81       	ldd	r30, Y+2	; 0x02
    27d6:	fb 81       	ldd	r31, Y+3	; 0x03
    27d8:	82 8d       	ldd	r24, Z+26	; 0x1a
    27da:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    27dc:	0f 90       	pop	r0
    27de:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    27e0:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    27e2:	0f 90       	pop	r0
    27e4:	0f 90       	pop	r0
    27e6:	0f 90       	pop	r0
    27e8:	cf 91       	pop	r28
    27ea:	df 91       	pop	r29
    27ec:	08 95       	ret

000027ee <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    27ee:	df 93       	push	r29
    27f0:	cf 93       	push	r28
    27f2:	00 d0       	rcall	.+0      	; 0x27f4 <uxQueueSpacesAvailable+0x6>
    27f4:	00 d0       	rcall	.+0      	; 0x27f6 <uxQueueSpacesAvailable+0x8>
    27f6:	0f 92       	push	r0
    27f8:	cd b7       	in	r28, 0x3d	; 61
    27fa:	de b7       	in	r29, 0x3e	; 62
    27fc:	9d 83       	std	Y+5, r25	; 0x05
    27fe:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    2800:	8c 81       	ldd	r24, Y+4	; 0x04
    2802:	9d 81       	ldd	r25, Y+5	; 0x05
    2804:	9a 83       	std	Y+2, r25	; 0x02
    2806:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    2808:	0f b6       	in	r0, 0x3f	; 63
    280a:	f8 94       	cli
    280c:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    280e:	e9 81       	ldd	r30, Y+1	; 0x01
    2810:	fa 81       	ldd	r31, Y+2	; 0x02
    2812:	93 8d       	ldd	r25, Z+27	; 0x1b
    2814:	e9 81       	ldd	r30, Y+1	; 0x01
    2816:	fa 81       	ldd	r31, Y+2	; 0x02
    2818:	82 8d       	ldd	r24, Z+26	; 0x1a
    281a:	29 2f       	mov	r18, r25
    281c:	28 1b       	sub	r18, r24
    281e:	82 2f       	mov	r24, r18
    2820:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    2822:	0f 90       	pop	r0
    2824:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2826:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2828:	0f 90       	pop	r0
    282a:	0f 90       	pop	r0
    282c:	0f 90       	pop	r0
    282e:	0f 90       	pop	r0
    2830:	0f 90       	pop	r0
    2832:	cf 91       	pop	r28
    2834:	df 91       	pop	r29
    2836:	08 95       	ret

00002838 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    2838:	df 93       	push	r29
    283a:	cf 93       	push	r28
    283c:	00 d0       	rcall	.+0      	; 0x283e <uxQueueMessagesWaitingFromISR+0x6>
    283e:	00 d0       	rcall	.+0      	; 0x2840 <uxQueueMessagesWaitingFromISR+0x8>
    2840:	0f 92       	push	r0
    2842:	cd b7       	in	r28, 0x3d	; 61
    2844:	de b7       	in	r29, 0x3e	; 62
    2846:	9d 83       	std	Y+5, r25	; 0x05
    2848:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    284a:	8c 81       	ldd	r24, Y+4	; 0x04
    284c:	9d 81       	ldd	r25, Y+5	; 0x05
    284e:	9a 83       	std	Y+2, r25	; 0x02
    2850:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    2852:	e9 81       	ldd	r30, Y+1	; 0x01
    2854:	fa 81       	ldd	r31, Y+2	; 0x02
    2856:	82 8d       	ldd	r24, Z+26	; 0x1a
    2858:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    285a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    285c:	0f 90       	pop	r0
    285e:	0f 90       	pop	r0
    2860:	0f 90       	pop	r0
    2862:	0f 90       	pop	r0
    2864:	0f 90       	pop	r0
    2866:	cf 91       	pop	r28
    2868:	df 91       	pop	r29
    286a:	08 95       	ret

0000286c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    286c:	df 93       	push	r29
    286e:	cf 93       	push	r28
    2870:	00 d0       	rcall	.+0      	; 0x2872 <vQueueDelete+0x6>
    2872:	00 d0       	rcall	.+0      	; 0x2874 <vQueueDelete+0x8>
    2874:	cd b7       	in	r28, 0x3d	; 61
    2876:	de b7       	in	r29, 0x3e	; 62
    2878:	9c 83       	std	Y+4, r25	; 0x04
    287a:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    287c:	8b 81       	ldd	r24, Y+3	; 0x03
    287e:	9c 81       	ldd	r25, Y+4	; 0x04
    2880:	9a 83       	std	Y+2, r25	; 0x02
    2882:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    2884:	89 81       	ldd	r24, Y+1	; 0x01
    2886:	9a 81       	ldd	r25, Y+2	; 0x02
    2888:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    288c:	0f 90       	pop	r0
    288e:	0f 90       	pop	r0
    2890:	0f 90       	pop	r0
    2892:	0f 90       	pop	r0
    2894:	cf 91       	pop	r28
    2896:	df 91       	pop	r29
    2898:	08 95       	ret

0000289a <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    289a:	df 93       	push	r29
    289c:	cf 93       	push	r28
    289e:	cd b7       	in	r28, 0x3d	; 61
    28a0:	de b7       	in	r29, 0x3e	; 62
    28a2:	27 97       	sbiw	r28, 0x07	; 7
    28a4:	0f b6       	in	r0, 0x3f	; 63
    28a6:	f8 94       	cli
    28a8:	de bf       	out	0x3e, r29	; 62
    28aa:	0f be       	out	0x3f, r0	; 63
    28ac:	cd bf       	out	0x3d, r28	; 61
    28ae:	9c 83       	std	Y+4, r25	; 0x04
    28b0:	8b 83       	std	Y+3, r24	; 0x03
    28b2:	7e 83       	std	Y+6, r23	; 0x06
    28b4:	6d 83       	std	Y+5, r22	; 0x05
    28b6:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    28b8:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    28ba:	eb 81       	ldd	r30, Y+3	; 0x03
    28bc:	fc 81       	ldd	r31, Y+4	; 0x04
    28be:	82 8d       	ldd	r24, Z+26	; 0x1a
    28c0:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    28c2:	eb 81       	ldd	r30, Y+3	; 0x03
    28c4:	fc 81       	ldd	r31, Y+4	; 0x04
    28c6:	84 8d       	ldd	r24, Z+28	; 0x1c
    28c8:	88 23       	and	r24, r24
    28ca:	09 f4       	brne	.+2      	; 0x28ce <prvCopyDataToQueue+0x34>
    28cc:	7d c0       	rjmp	.+250    	; 0x29c8 <prvCopyDataToQueue+0x12e>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    28ce:	8f 81       	ldd	r24, Y+7	; 0x07
    28d0:	88 23       	and	r24, r24
    28d2:	99 f5       	brne	.+102    	; 0x293a <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    28d4:	eb 81       	ldd	r30, Y+3	; 0x03
    28d6:	fc 81       	ldd	r31, Y+4	; 0x04
    28d8:	62 81       	ldd	r22, Z+2	; 0x02
    28da:	73 81       	ldd	r23, Z+3	; 0x03
    28dc:	eb 81       	ldd	r30, Y+3	; 0x03
    28de:	fc 81       	ldd	r31, Y+4	; 0x04
    28e0:	84 8d       	ldd	r24, Z+28	; 0x1c
    28e2:	48 2f       	mov	r20, r24
    28e4:	50 e0       	ldi	r21, 0x00	; 0
    28e6:	2d 81       	ldd	r18, Y+5	; 0x05
    28e8:	3e 81       	ldd	r19, Y+6	; 0x06
    28ea:	cb 01       	movw	r24, r22
    28ec:	b9 01       	movw	r22, r18
    28ee:	0e 94 9b 32 	call	0x6536	; 0x6536 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    28f2:	eb 81       	ldd	r30, Y+3	; 0x03
    28f4:	fc 81       	ldd	r31, Y+4	; 0x04
    28f6:	22 81       	ldd	r18, Z+2	; 0x02
    28f8:	33 81       	ldd	r19, Z+3	; 0x03
    28fa:	eb 81       	ldd	r30, Y+3	; 0x03
    28fc:	fc 81       	ldd	r31, Y+4	; 0x04
    28fe:	84 8d       	ldd	r24, Z+28	; 0x1c
    2900:	88 2f       	mov	r24, r24
    2902:	90 e0       	ldi	r25, 0x00	; 0
    2904:	82 0f       	add	r24, r18
    2906:	93 1f       	adc	r25, r19
    2908:	eb 81       	ldd	r30, Y+3	; 0x03
    290a:	fc 81       	ldd	r31, Y+4	; 0x04
    290c:	93 83       	std	Z+3, r25	; 0x03
    290e:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2910:	eb 81       	ldd	r30, Y+3	; 0x03
    2912:	fc 81       	ldd	r31, Y+4	; 0x04
    2914:	22 81       	ldd	r18, Z+2	; 0x02
    2916:	33 81       	ldd	r19, Z+3	; 0x03
    2918:	eb 81       	ldd	r30, Y+3	; 0x03
    291a:	fc 81       	ldd	r31, Y+4	; 0x04
    291c:	84 81       	ldd	r24, Z+4	; 0x04
    291e:	95 81       	ldd	r25, Z+5	; 0x05
    2920:	28 17       	cp	r18, r24
    2922:	39 07       	cpc	r19, r25
    2924:	08 f4       	brcc	.+2      	; 0x2928 <prvCopyDataToQueue+0x8e>
    2926:	50 c0       	rjmp	.+160    	; 0x29c8 <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    2928:	eb 81       	ldd	r30, Y+3	; 0x03
    292a:	fc 81       	ldd	r31, Y+4	; 0x04
    292c:	80 81       	ld	r24, Z
    292e:	91 81       	ldd	r25, Z+1	; 0x01
    2930:	eb 81       	ldd	r30, Y+3	; 0x03
    2932:	fc 81       	ldd	r31, Y+4	; 0x04
    2934:	93 83       	std	Z+3, r25	; 0x03
    2936:	82 83       	std	Z+2, r24	; 0x02
    2938:	47 c0       	rjmp	.+142    	; 0x29c8 <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    293a:	eb 81       	ldd	r30, Y+3	; 0x03
    293c:	fc 81       	ldd	r31, Y+4	; 0x04
    293e:	66 81       	ldd	r22, Z+6	; 0x06
    2940:	77 81       	ldd	r23, Z+7	; 0x07
    2942:	eb 81       	ldd	r30, Y+3	; 0x03
    2944:	fc 81       	ldd	r31, Y+4	; 0x04
    2946:	84 8d       	ldd	r24, Z+28	; 0x1c
    2948:	48 2f       	mov	r20, r24
    294a:	50 e0       	ldi	r21, 0x00	; 0
    294c:	2d 81       	ldd	r18, Y+5	; 0x05
    294e:	3e 81       	ldd	r19, Y+6	; 0x06
    2950:	cb 01       	movw	r24, r22
    2952:	b9 01       	movw	r22, r18
    2954:	0e 94 9b 32 	call	0x6536	; 0x6536 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2958:	eb 81       	ldd	r30, Y+3	; 0x03
    295a:	fc 81       	ldd	r31, Y+4	; 0x04
    295c:	26 81       	ldd	r18, Z+6	; 0x06
    295e:	37 81       	ldd	r19, Z+7	; 0x07
    2960:	eb 81       	ldd	r30, Y+3	; 0x03
    2962:	fc 81       	ldd	r31, Y+4	; 0x04
    2964:	84 8d       	ldd	r24, Z+28	; 0x1c
    2966:	88 2f       	mov	r24, r24
    2968:	90 e0       	ldi	r25, 0x00	; 0
    296a:	90 95       	com	r25
    296c:	81 95       	neg	r24
    296e:	9f 4f       	sbci	r25, 0xFF	; 255
    2970:	82 0f       	add	r24, r18
    2972:	93 1f       	adc	r25, r19
    2974:	eb 81       	ldd	r30, Y+3	; 0x03
    2976:	fc 81       	ldd	r31, Y+4	; 0x04
    2978:	97 83       	std	Z+7, r25	; 0x07
    297a:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    297c:	eb 81       	ldd	r30, Y+3	; 0x03
    297e:	fc 81       	ldd	r31, Y+4	; 0x04
    2980:	26 81       	ldd	r18, Z+6	; 0x06
    2982:	37 81       	ldd	r19, Z+7	; 0x07
    2984:	eb 81       	ldd	r30, Y+3	; 0x03
    2986:	fc 81       	ldd	r31, Y+4	; 0x04
    2988:	80 81       	ld	r24, Z
    298a:	91 81       	ldd	r25, Z+1	; 0x01
    298c:	28 17       	cp	r18, r24
    298e:	39 07       	cpc	r19, r25
    2990:	90 f4       	brcc	.+36     	; 0x29b6 <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2992:	eb 81       	ldd	r30, Y+3	; 0x03
    2994:	fc 81       	ldd	r31, Y+4	; 0x04
    2996:	24 81       	ldd	r18, Z+4	; 0x04
    2998:	35 81       	ldd	r19, Z+5	; 0x05
    299a:	eb 81       	ldd	r30, Y+3	; 0x03
    299c:	fc 81       	ldd	r31, Y+4	; 0x04
    299e:	84 8d       	ldd	r24, Z+28	; 0x1c
    29a0:	88 2f       	mov	r24, r24
    29a2:	90 e0       	ldi	r25, 0x00	; 0
    29a4:	90 95       	com	r25
    29a6:	81 95       	neg	r24
    29a8:	9f 4f       	sbci	r25, 0xFF	; 255
    29aa:	82 0f       	add	r24, r18
    29ac:	93 1f       	adc	r25, r19
    29ae:	eb 81       	ldd	r30, Y+3	; 0x03
    29b0:	fc 81       	ldd	r31, Y+4	; 0x04
    29b2:	97 83       	std	Z+7, r25	; 0x07
    29b4:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    29b6:	8f 81       	ldd	r24, Y+7	; 0x07
    29b8:	82 30       	cpi	r24, 0x02	; 2
    29ba:	31 f4       	brne	.+12     	; 0x29c8 <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    29bc:	89 81       	ldd	r24, Y+1	; 0x01
    29be:	88 23       	and	r24, r24
    29c0:	19 f0       	breq	.+6      	; 0x29c8 <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    29c2:	89 81       	ldd	r24, Y+1	; 0x01
    29c4:	81 50       	subi	r24, 0x01	; 1
    29c6:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    29c8:	89 81       	ldd	r24, Y+1	; 0x01
    29ca:	8f 5f       	subi	r24, 0xFF	; 255
    29cc:	eb 81       	ldd	r30, Y+3	; 0x03
    29ce:	fc 81       	ldd	r31, Y+4	; 0x04
    29d0:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    29d2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    29d4:	27 96       	adiw	r28, 0x07	; 7
    29d6:	0f b6       	in	r0, 0x3f	; 63
    29d8:	f8 94       	cli
    29da:	de bf       	out	0x3e, r29	; 62
    29dc:	0f be       	out	0x3f, r0	; 63
    29de:	cd bf       	out	0x3d, r28	; 61
    29e0:	cf 91       	pop	r28
    29e2:	df 91       	pop	r29
    29e4:	08 95       	ret

000029e6 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    29e6:	df 93       	push	r29
    29e8:	cf 93       	push	r28
    29ea:	00 d0       	rcall	.+0      	; 0x29ec <prvCopyDataFromQueue+0x6>
    29ec:	00 d0       	rcall	.+0      	; 0x29ee <prvCopyDataFromQueue+0x8>
    29ee:	cd b7       	in	r28, 0x3d	; 61
    29f0:	de b7       	in	r29, 0x3e	; 62
    29f2:	9a 83       	std	Y+2, r25	; 0x02
    29f4:	89 83       	std	Y+1, r24	; 0x01
    29f6:	7c 83       	std	Y+4, r23	; 0x04
    29f8:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    29fa:	e9 81       	ldd	r30, Y+1	; 0x01
    29fc:	fa 81       	ldd	r31, Y+2	; 0x02
    29fe:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a00:	88 23       	and	r24, r24
    2a02:	89 f1       	breq	.+98     	; 0x2a66 <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2a04:	e9 81       	ldd	r30, Y+1	; 0x01
    2a06:	fa 81       	ldd	r31, Y+2	; 0x02
    2a08:	26 81       	ldd	r18, Z+6	; 0x06
    2a0a:	37 81       	ldd	r19, Z+7	; 0x07
    2a0c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a0e:	fa 81       	ldd	r31, Y+2	; 0x02
    2a10:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a12:	88 2f       	mov	r24, r24
    2a14:	90 e0       	ldi	r25, 0x00	; 0
    2a16:	82 0f       	add	r24, r18
    2a18:	93 1f       	adc	r25, r19
    2a1a:	e9 81       	ldd	r30, Y+1	; 0x01
    2a1c:	fa 81       	ldd	r31, Y+2	; 0x02
    2a1e:	97 83       	std	Z+7, r25	; 0x07
    2a20:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2a22:	e9 81       	ldd	r30, Y+1	; 0x01
    2a24:	fa 81       	ldd	r31, Y+2	; 0x02
    2a26:	26 81       	ldd	r18, Z+6	; 0x06
    2a28:	37 81       	ldd	r19, Z+7	; 0x07
    2a2a:	e9 81       	ldd	r30, Y+1	; 0x01
    2a2c:	fa 81       	ldd	r31, Y+2	; 0x02
    2a2e:	84 81       	ldd	r24, Z+4	; 0x04
    2a30:	95 81       	ldd	r25, Z+5	; 0x05
    2a32:	28 17       	cp	r18, r24
    2a34:	39 07       	cpc	r19, r25
    2a36:	40 f0       	brcs	.+16     	; 0x2a48 <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2a38:	e9 81       	ldd	r30, Y+1	; 0x01
    2a3a:	fa 81       	ldd	r31, Y+2	; 0x02
    2a3c:	80 81       	ld	r24, Z
    2a3e:	91 81       	ldd	r25, Z+1	; 0x01
    2a40:	e9 81       	ldd	r30, Y+1	; 0x01
    2a42:	fa 81       	ldd	r31, Y+2	; 0x02
    2a44:	97 83       	std	Z+7, r25	; 0x07
    2a46:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2a48:	e9 81       	ldd	r30, Y+1	; 0x01
    2a4a:	fa 81       	ldd	r31, Y+2	; 0x02
    2a4c:	46 81       	ldd	r20, Z+6	; 0x06
    2a4e:	57 81       	ldd	r21, Z+7	; 0x07
    2a50:	e9 81       	ldd	r30, Y+1	; 0x01
    2a52:	fa 81       	ldd	r31, Y+2	; 0x02
    2a54:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a56:	28 2f       	mov	r18, r24
    2a58:	30 e0       	ldi	r19, 0x00	; 0
    2a5a:	8b 81       	ldd	r24, Y+3	; 0x03
    2a5c:	9c 81       	ldd	r25, Y+4	; 0x04
    2a5e:	ba 01       	movw	r22, r20
    2a60:	a9 01       	movw	r20, r18
    2a62:	0e 94 9b 32 	call	0x6536	; 0x6536 <memcpy>
    }
}
    2a66:	0f 90       	pop	r0
    2a68:	0f 90       	pop	r0
    2a6a:	0f 90       	pop	r0
    2a6c:	0f 90       	pop	r0
    2a6e:	cf 91       	pop	r28
    2a70:	df 91       	pop	r29
    2a72:	08 95       	ret

00002a74 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2a74:	df 93       	push	r29
    2a76:	cf 93       	push	r28
    2a78:	00 d0       	rcall	.+0      	; 0x2a7a <prvUnlockQueue+0x6>
    2a7a:	00 d0       	rcall	.+0      	; 0x2a7c <prvUnlockQueue+0x8>
    2a7c:	cd b7       	in	r28, 0x3d	; 61
    2a7e:	de b7       	in	r29, 0x3e	; 62
    2a80:	9c 83       	std	Y+4, r25	; 0x04
    2a82:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    2a84:	0f b6       	in	r0, 0x3f	; 63
    2a86:	f8 94       	cli
    2a88:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    2a8a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a8c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a8e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2a90:	8a 83       	std	Y+2, r24	; 0x02
    2a92:	11 c0       	rjmp	.+34     	; 0x2ab6 <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2a94:	eb 81       	ldd	r30, Y+3	; 0x03
    2a96:	fc 81       	ldd	r31, Y+4	; 0x04
    2a98:	81 89       	ldd	r24, Z+17	; 0x11
    2a9a:	88 23       	and	r24, r24
    2a9c:	79 f0       	breq	.+30     	; 0x2abc <prvUnlockQueue+0x48>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2a9e:	8b 81       	ldd	r24, Y+3	; 0x03
    2aa0:	9c 81       	ldd	r25, Y+4	; 0x04
    2aa2:	41 96       	adiw	r24, 0x11	; 17
    2aa4:	0e 94 0a 20 	call	0x4014	; 0x4014 <xTaskRemoveFromEventList>
    2aa8:	88 23       	and	r24, r24
    2aaa:	11 f0       	breq	.+4      	; 0x2ab0 <prvUnlockQueue+0x3c>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    2aac:	0e 94 fa 22 	call	0x45f4	; 0x45f4 <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    2ab0:	8a 81       	ldd	r24, Y+2	; 0x02
    2ab2:	81 50       	subi	r24, 0x01	; 1
    2ab4:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    2ab6:	8a 81       	ldd	r24, Y+2	; 0x02
    2ab8:	18 16       	cp	r1, r24
    2aba:	64 f3       	brlt	.-40     	; 0x2a94 <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    2abc:	eb 81       	ldd	r30, Y+3	; 0x03
    2abe:	fc 81       	ldd	r31, Y+4	; 0x04
    2ac0:	8f ef       	ldi	r24, 0xFF	; 255
    2ac2:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    2ac4:	0f 90       	pop	r0
    2ac6:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    2ac8:	0f b6       	in	r0, 0x3f	; 63
    2aca:	f8 94       	cli
    2acc:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    2ace:	eb 81       	ldd	r30, Y+3	; 0x03
    2ad0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ad2:	85 8d       	ldd	r24, Z+29	; 0x1d
    2ad4:	89 83       	std	Y+1, r24	; 0x01
    2ad6:	11 c0       	rjmp	.+34     	; 0x2afa <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2ad8:	eb 81       	ldd	r30, Y+3	; 0x03
    2ada:	fc 81       	ldd	r31, Y+4	; 0x04
    2adc:	80 85       	ldd	r24, Z+8	; 0x08
    2ade:	88 23       	and	r24, r24
    2ae0:	79 f0       	breq	.+30     	; 0x2b00 <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2ae2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ae6:	08 96       	adiw	r24, 0x08	; 8
    2ae8:	0e 94 0a 20 	call	0x4014	; 0x4014 <xTaskRemoveFromEventList>
    2aec:	88 23       	and	r24, r24
    2aee:	11 f0       	breq	.+4      	; 0x2af4 <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    2af0:	0e 94 fa 22 	call	0x45f4	; 0x45f4 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    2af4:	89 81       	ldd	r24, Y+1	; 0x01
    2af6:	81 50       	subi	r24, 0x01	; 1
    2af8:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    2afa:	89 81       	ldd	r24, Y+1	; 0x01
    2afc:	18 16       	cp	r1, r24
    2afe:	64 f3       	brlt	.-40     	; 0x2ad8 <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    2b00:	eb 81       	ldd	r30, Y+3	; 0x03
    2b02:	fc 81       	ldd	r31, Y+4	; 0x04
    2b04:	8f ef       	ldi	r24, 0xFF	; 255
    2b06:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    2b08:	0f 90       	pop	r0
    2b0a:	0f be       	out	0x3f, r0	; 63
}
    2b0c:	0f 90       	pop	r0
    2b0e:	0f 90       	pop	r0
    2b10:	0f 90       	pop	r0
    2b12:	0f 90       	pop	r0
    2b14:	cf 91       	pop	r28
    2b16:	df 91       	pop	r29
    2b18:	08 95       	ret

00002b1a <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    2b1a:	df 93       	push	r29
    2b1c:	cf 93       	push	r28
    2b1e:	00 d0       	rcall	.+0      	; 0x2b20 <prvIsQueueEmpty+0x6>
    2b20:	0f 92       	push	r0
    2b22:	cd b7       	in	r28, 0x3d	; 61
    2b24:	de b7       	in	r29, 0x3e	; 62
    2b26:	9b 83       	std	Y+3, r25	; 0x03
    2b28:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2b2a:	0f b6       	in	r0, 0x3f	; 63
    2b2c:	f8 94       	cli
    2b2e:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2b30:	ea 81       	ldd	r30, Y+2	; 0x02
    2b32:	fb 81       	ldd	r31, Y+3	; 0x03
    2b34:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b36:	88 23       	and	r24, r24
    2b38:	19 f4       	brne	.+6      	; 0x2b40 <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    2b3a:	81 e0       	ldi	r24, 0x01	; 1
    2b3c:	89 83       	std	Y+1, r24	; 0x01
    2b3e:	01 c0       	rjmp	.+2      	; 0x2b42 <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    2b40:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    2b42:	0f 90       	pop	r0
    2b44:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    2b46:	89 81       	ldd	r24, Y+1	; 0x01
}
    2b48:	0f 90       	pop	r0
    2b4a:	0f 90       	pop	r0
    2b4c:	0f 90       	pop	r0
    2b4e:	cf 91       	pop	r28
    2b50:	df 91       	pop	r29
    2b52:	08 95       	ret

00002b54 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2b54:	df 93       	push	r29
    2b56:	cf 93       	push	r28
    2b58:	00 d0       	rcall	.+0      	; 0x2b5a <xQueueIsQueueEmptyFromISR+0x6>
    2b5a:	00 d0       	rcall	.+0      	; 0x2b5c <xQueueIsQueueEmptyFromISR+0x8>
    2b5c:	0f 92       	push	r0
    2b5e:	cd b7       	in	r28, 0x3d	; 61
    2b60:	de b7       	in	r29, 0x3e	; 62
    2b62:	9d 83       	std	Y+5, r25	; 0x05
    2b64:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    2b66:	8c 81       	ldd	r24, Y+4	; 0x04
    2b68:	9d 81       	ldd	r25, Y+5	; 0x05
    2b6a:	9a 83       	std	Y+2, r25	; 0x02
    2b6c:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2b6e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b70:	fa 81       	ldd	r31, Y+2	; 0x02
    2b72:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b74:	88 23       	and	r24, r24
    2b76:	19 f4       	brne	.+6      	; 0x2b7e <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    2b78:	81 e0       	ldi	r24, 0x01	; 1
    2b7a:	8b 83       	std	Y+3, r24	; 0x03
    2b7c:	01 c0       	rjmp	.+2      	; 0x2b80 <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    2b7e:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    2b80:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2b82:	0f 90       	pop	r0
    2b84:	0f 90       	pop	r0
    2b86:	0f 90       	pop	r0
    2b88:	0f 90       	pop	r0
    2b8a:	0f 90       	pop	r0
    2b8c:	cf 91       	pop	r28
    2b8e:	df 91       	pop	r29
    2b90:	08 95       	ret

00002b92 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    2b92:	df 93       	push	r29
    2b94:	cf 93       	push	r28
    2b96:	00 d0       	rcall	.+0      	; 0x2b98 <prvIsQueueFull+0x6>
    2b98:	0f 92       	push	r0
    2b9a:	cd b7       	in	r28, 0x3d	; 61
    2b9c:	de b7       	in	r29, 0x3e	; 62
    2b9e:	9b 83       	std	Y+3, r25	; 0x03
    2ba0:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2ba2:	0f b6       	in	r0, 0x3f	; 63
    2ba4:	f8 94       	cli
    2ba6:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2ba8:	ea 81       	ldd	r30, Y+2	; 0x02
    2baa:	fb 81       	ldd	r31, Y+3	; 0x03
    2bac:	92 8d       	ldd	r25, Z+26	; 0x1a
    2bae:	ea 81       	ldd	r30, Y+2	; 0x02
    2bb0:	fb 81       	ldd	r31, Y+3	; 0x03
    2bb2:	83 8d       	ldd	r24, Z+27	; 0x1b
    2bb4:	98 17       	cp	r25, r24
    2bb6:	19 f4       	brne	.+6      	; 0x2bbe <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    2bb8:	81 e0       	ldi	r24, 0x01	; 1
    2bba:	89 83       	std	Y+1, r24	; 0x01
    2bbc:	01 c0       	rjmp	.+2      	; 0x2bc0 <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    2bbe:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    2bc0:	0f 90       	pop	r0
    2bc2:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    2bc4:	89 81       	ldd	r24, Y+1	; 0x01
}
    2bc6:	0f 90       	pop	r0
    2bc8:	0f 90       	pop	r0
    2bca:	0f 90       	pop	r0
    2bcc:	cf 91       	pop	r28
    2bce:	df 91       	pop	r29
    2bd0:	08 95       	ret

00002bd2 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2bd2:	df 93       	push	r29
    2bd4:	cf 93       	push	r28
    2bd6:	00 d0       	rcall	.+0      	; 0x2bd8 <xQueueIsQueueFullFromISR+0x6>
    2bd8:	00 d0       	rcall	.+0      	; 0x2bda <xQueueIsQueueFullFromISR+0x8>
    2bda:	0f 92       	push	r0
    2bdc:	cd b7       	in	r28, 0x3d	; 61
    2bde:	de b7       	in	r29, 0x3e	; 62
    2be0:	9d 83       	std	Y+5, r25	; 0x05
    2be2:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    2be4:	8c 81       	ldd	r24, Y+4	; 0x04
    2be6:	9d 81       	ldd	r25, Y+5	; 0x05
    2be8:	9a 83       	std	Y+2, r25	; 0x02
    2bea:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2bec:	e9 81       	ldd	r30, Y+1	; 0x01
    2bee:	fa 81       	ldd	r31, Y+2	; 0x02
    2bf0:	92 8d       	ldd	r25, Z+26	; 0x1a
    2bf2:	e9 81       	ldd	r30, Y+1	; 0x01
    2bf4:	fa 81       	ldd	r31, Y+2	; 0x02
    2bf6:	83 8d       	ldd	r24, Z+27	; 0x1b
    2bf8:	98 17       	cp	r25, r24
    2bfa:	19 f4       	brne	.+6      	; 0x2c02 <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    2bfc:	81 e0       	ldi	r24, 0x01	; 1
    2bfe:	8b 83       	std	Y+3, r24	; 0x03
    2c00:	01 c0       	rjmp	.+2      	; 0x2c04 <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    2c02:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    2c04:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2c06:	0f 90       	pop	r0
    2c08:	0f 90       	pop	r0
    2c0a:	0f 90       	pop	r0
    2c0c:	0f 90       	pop	r0
    2c0e:	0f 90       	pop	r0
    2c10:	cf 91       	pop	r28
    2c12:	df 91       	pop	r29
    2c14:	08 95       	ret

00002c16 <xQueueCRSend>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSend( QueueHandle_t xQueue,
                             const void * pvItemToQueue,
                             TickType_t xTicksToWait )
    {
    2c16:	df 93       	push	r29
    2c18:	cf 93       	push	r28
    2c1a:	cd b7       	in	r28, 0x3d	; 61
    2c1c:	de b7       	in	r29, 0x3e	; 62
    2c1e:	2a 97       	sbiw	r28, 0x0a	; 10
    2c20:	0f b6       	in	r0, 0x3f	; 63
    2c22:	f8 94       	cli
    2c24:	de bf       	out	0x3e, r29	; 62
    2c26:	0f be       	out	0x3f, r0	; 63
    2c28:	cd bf       	out	0x3d, r28	; 61
    2c2a:	9d 83       	std	Y+5, r25	; 0x05
    2c2c:	8c 83       	std	Y+4, r24	; 0x04
    2c2e:	7f 83       	std	Y+7, r23	; 0x07
    2c30:	6e 83       	std	Y+6, r22	; 0x06
    2c32:	59 87       	std	Y+9, r21	; 0x09
    2c34:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    2c36:	8c 81       	ldd	r24, Y+4	; 0x04
    2c38:	9d 81       	ldd	r25, Y+5	; 0x05
    2c3a:	9a 83       	std	Y+2, r25	; 0x02
    2c3c:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    2c3e:	f8 94       	cli
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2c40:	89 81       	ldd	r24, Y+1	; 0x01
    2c42:	9a 81       	ldd	r25, Y+2	; 0x02
    2c44:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <prvIsQueueFull>
    2c48:	88 23       	and	r24, r24
    2c4a:	a9 f0       	breq	.+42     	; 0x2c76 <xQueueCRSend+0x60>
            {
                /* The queue is full - do we want to block or just leave without
                 * posting? */
                if( xTicksToWait > ( TickType_t ) 0 )
    2c4c:	88 85       	ldd	r24, Y+8	; 0x08
    2c4e:	99 85       	ldd	r25, Y+9	; 0x09
    2c50:	00 97       	sbiw	r24, 0x00	; 0
    2c52:	71 f0       	breq	.+28     	; 0x2c70 <xQueueCRSend+0x5a>
                {
                    /* As this is called from a coroutine we cannot block directly, but
                     * return indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    2c54:	89 81       	ldd	r24, Y+1	; 0x01
    2c56:	9a 81       	ldd	r25, Y+2	; 0x02
    2c58:	9c 01       	movw	r18, r24
    2c5a:	28 5f       	subi	r18, 0xF8	; 248
    2c5c:	3f 4f       	sbci	r19, 0xFF	; 255
    2c5e:	88 85       	ldd	r24, Y+8	; 0x08
    2c60:	99 85       	ldd	r25, Y+9	; 0x09
    2c62:	b9 01       	movw	r22, r18
    2c64:	0e 94 d7 07 	call	0xfae	; 0xfae <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    2c68:	78 94       	sei
                    return errQUEUE_BLOCKED;
    2c6a:	8c ef       	ldi	r24, 0xFC	; 252
    2c6c:	8a 87       	std	Y+10, r24	; 0x0a
    2c6e:	2a c0       	rjmp	.+84     	; 0x2cc4 <xQueueCRSend+0xae>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    2c70:	78 94       	sei
                    return errQUEUE_FULL;
    2c72:	1a 86       	std	Y+10, r1	; 0x0a
    2c74:	27 c0       	rjmp	.+78     	; 0x2cc4 <xQueueCRSend+0xae>
                }
            }
        }
        portENABLE_INTERRUPTS();
    2c76:	78 94       	sei

        portDISABLE_INTERRUPTS();
    2c78:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2c7a:	e9 81       	ldd	r30, Y+1	; 0x01
    2c7c:	fa 81       	ldd	r31, Y+2	; 0x02
    2c7e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2c80:	e9 81       	ldd	r30, Y+1	; 0x01
    2c82:	fa 81       	ldd	r31, Y+2	; 0x02
    2c84:	83 8d       	ldd	r24, Z+27	; 0x1b
    2c86:	98 17       	cp	r25, r24
    2c88:	c8 f4       	brcc	.+50     	; 0x2cbc <xQueueCRSend+0xa6>
            {
                /* There is room in the queue, copy the data into the queue. */
                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    2c8a:	89 81       	ldd	r24, Y+1	; 0x01
    2c8c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c8e:	2e 81       	ldd	r18, Y+6	; 0x06
    2c90:	3f 81       	ldd	r19, Y+7	; 0x07
    2c92:	b9 01       	movw	r22, r18
    2c94:	40 e0       	ldi	r20, 0x00	; 0
    2c96:	0e 94 4d 14 	call	0x289a	; 0x289a <prvCopyDataToQueue>
                xReturn = pdPASS;
    2c9a:	81 e0       	ldi	r24, 0x01	; 1
    2c9c:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for data to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2c9e:	e9 81       	ldd	r30, Y+1	; 0x01
    2ca0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ca2:	81 89       	ldd	r24, Z+17	; 0x11
    2ca4:	88 23       	and	r24, r24
    2ca6:	59 f0       	breq	.+22     	; 0x2cbe <xQueueCRSend+0xa8>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2ca8:	89 81       	ldd	r24, Y+1	; 0x01
    2caa:	9a 81       	ldd	r25, Y+2	; 0x02
    2cac:	41 96       	adiw	r24, 0x11	; 17
    2cae:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <xCoRoutineRemoveFromEventList>
    2cb2:	88 23       	and	r24, r24
    2cb4:	21 f0       	breq	.+8      	; 0x2cbe <xQueueCRSend+0xa8>
                    {
                        /* The co-routine waiting has a higher priority so record
                         * that a yield might be appropriate. */
                        xReturn = errQUEUE_YIELD;
    2cb6:	8b ef       	ldi	r24, 0xFB	; 251
    2cb8:	8b 83       	std	Y+3, r24	; 0x03
    2cba:	01 c0       	rjmp	.+2      	; 0x2cbe <xQueueCRSend+0xa8>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = errQUEUE_FULL;
    2cbc:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    2cbe:	78 94       	sei

        return xReturn;
    2cc0:	8b 81       	ldd	r24, Y+3	; 0x03
    2cc2:	8a 87       	std	Y+10, r24	; 0x0a
    2cc4:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    2cc6:	2a 96       	adiw	r28, 0x0a	; 10
    2cc8:	0f b6       	in	r0, 0x3f	; 63
    2cca:	f8 94       	cli
    2ccc:	de bf       	out	0x3e, r29	; 62
    2cce:	0f be       	out	0x3f, r0	; 63
    2cd0:	cd bf       	out	0x3d, r28	; 61
    2cd2:	cf 91       	pop	r28
    2cd4:	df 91       	pop	r29
    2cd6:	08 95       	ret

00002cd8 <xQueueCRReceive>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
                                void * pvBuffer,
                                TickType_t xTicksToWait )
    {
    2cd8:	df 93       	push	r29
    2cda:	cf 93       	push	r28
    2cdc:	cd b7       	in	r28, 0x3d	; 61
    2cde:	de b7       	in	r29, 0x3e	; 62
    2ce0:	2a 97       	sbiw	r28, 0x0a	; 10
    2ce2:	0f b6       	in	r0, 0x3f	; 63
    2ce4:	f8 94       	cli
    2ce6:	de bf       	out	0x3e, r29	; 62
    2ce8:	0f be       	out	0x3f, r0	; 63
    2cea:	cd bf       	out	0x3d, r28	; 61
    2cec:	9d 83       	std	Y+5, r25	; 0x05
    2cee:	8c 83       	std	Y+4, r24	; 0x04
    2cf0:	7f 83       	std	Y+7, r23	; 0x07
    2cf2:	6e 83       	std	Y+6, r22	; 0x06
    2cf4:	59 87       	std	Y+9, r21	; 0x09
    2cf6:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    2cf8:	8c 81       	ldd	r24, Y+4	; 0x04
    2cfa:	9d 81       	ldd	r25, Y+5	; 0x05
    2cfc:	9a 83       	std	Y+2, r25	; 0x02
    2cfe:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already empty we may have to block.  A critical section
         * is required to prevent an interrupt adding something to the queue
         * between the check to see if the queue is empty and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    2d00:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2d02:	e9 81       	ldd	r30, Y+1	; 0x01
    2d04:	fa 81       	ldd	r31, Y+2	; 0x02
    2d06:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d08:	88 23       	and	r24, r24
    2d0a:	a9 f4       	brne	.+42     	; 0x2d36 <xQueueCRReceive+0x5e>
            {
                /* There are no messages in the queue, do we want to block or just
                 * leave with nothing? */
                if( xTicksToWait > ( TickType_t ) 0 )
    2d0c:	88 85       	ldd	r24, Y+8	; 0x08
    2d0e:	99 85       	ldd	r25, Y+9	; 0x09
    2d10:	00 97       	sbiw	r24, 0x00	; 0
    2d12:	71 f0       	breq	.+28     	; 0x2d30 <xQueueCRReceive+0x58>
                {
                    /* As this is a co-routine we cannot block directly, but return
                     * indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    2d14:	89 81       	ldd	r24, Y+1	; 0x01
    2d16:	9a 81       	ldd	r25, Y+2	; 0x02
    2d18:	9c 01       	movw	r18, r24
    2d1a:	2f 5e       	subi	r18, 0xEF	; 239
    2d1c:	3f 4f       	sbci	r19, 0xFF	; 255
    2d1e:	88 85       	ldd	r24, Y+8	; 0x08
    2d20:	99 85       	ldd	r25, Y+9	; 0x09
    2d22:	b9 01       	movw	r22, r18
    2d24:	0e 94 d7 07 	call	0xfae	; 0xfae <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    2d28:	78 94       	sei
                    return errQUEUE_BLOCKED;
    2d2a:	8c ef       	ldi	r24, 0xFC	; 252
    2d2c:	8a 87       	std	Y+10, r24	; 0x0a
    2d2e:	58 c0       	rjmp	.+176    	; 0x2de0 <xQueueCRReceive+0x108>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    2d30:	78 94       	sei
                    return errQUEUE_FULL;
    2d32:	1a 86       	std	Y+10, r1	; 0x0a
    2d34:	55 c0       	rjmp	.+170    	; 0x2de0 <xQueueCRReceive+0x108>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portENABLE_INTERRUPTS();
    2d36:	78 94       	sei

        portDISABLE_INTERRUPTS();
    2d38:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2d3a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d3c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d3e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d40:	88 23       	and	r24, r24
    2d42:	09 f4       	brne	.+2      	; 0x2d46 <xQueueCRReceive+0x6e>
    2d44:	49 c0       	rjmp	.+146    	; 0x2dd8 <xQueueCRReceive+0x100>
            {
                /* Data is available from the queue. */
                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    2d46:	e9 81       	ldd	r30, Y+1	; 0x01
    2d48:	fa 81       	ldd	r31, Y+2	; 0x02
    2d4a:	26 81       	ldd	r18, Z+6	; 0x06
    2d4c:	37 81       	ldd	r19, Z+7	; 0x07
    2d4e:	e9 81       	ldd	r30, Y+1	; 0x01
    2d50:	fa 81       	ldd	r31, Y+2	; 0x02
    2d52:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d54:	88 2f       	mov	r24, r24
    2d56:	90 e0       	ldi	r25, 0x00	; 0
    2d58:	82 0f       	add	r24, r18
    2d5a:	93 1f       	adc	r25, r19
    2d5c:	e9 81       	ldd	r30, Y+1	; 0x01
    2d5e:	fa 81       	ldd	r31, Y+2	; 0x02
    2d60:	97 83       	std	Z+7, r25	; 0x07
    2d62:	86 83       	std	Z+6, r24	; 0x06

                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    2d64:	e9 81       	ldd	r30, Y+1	; 0x01
    2d66:	fa 81       	ldd	r31, Y+2	; 0x02
    2d68:	26 81       	ldd	r18, Z+6	; 0x06
    2d6a:	37 81       	ldd	r19, Z+7	; 0x07
    2d6c:	e9 81       	ldd	r30, Y+1	; 0x01
    2d6e:	fa 81       	ldd	r31, Y+2	; 0x02
    2d70:	84 81       	ldd	r24, Z+4	; 0x04
    2d72:	95 81       	ldd	r25, Z+5	; 0x05
    2d74:	28 17       	cp	r18, r24
    2d76:	39 07       	cpc	r19, r25
    2d78:	40 f0       	brcs	.+16     	; 0x2d8a <xQueueCRReceive+0xb2>
                {
                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2d7a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d7c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d7e:	80 81       	ld	r24, Z
    2d80:	91 81       	ldd	r25, Z+1	; 0x01
    2d82:	e9 81       	ldd	r30, Y+1	; 0x01
    2d84:	fa 81       	ldd	r31, Y+2	; 0x02
    2d86:	97 83       	std	Z+7, r25	; 0x07
    2d88:	86 83       	std	Z+6, r24	; 0x06
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --( pxQueue->uxMessagesWaiting );
    2d8a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d8c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d8e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d90:	81 50       	subi	r24, 0x01	; 1
    2d92:	e9 81       	ldd	r30, Y+1	; 0x01
    2d94:	fa 81       	ldd	r31, Y+2	; 0x02
    2d96:	82 8f       	std	Z+26, r24	; 0x1a
                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2d98:	e9 81       	ldd	r30, Y+1	; 0x01
    2d9a:	fa 81       	ldd	r31, Y+2	; 0x02
    2d9c:	46 81       	ldd	r20, Z+6	; 0x06
    2d9e:	57 81       	ldd	r21, Z+7	; 0x07
    2da0:	e9 81       	ldd	r30, Y+1	; 0x01
    2da2:	fa 81       	ldd	r31, Y+2	; 0x02
    2da4:	84 8d       	ldd	r24, Z+28	; 0x1c
    2da6:	28 2f       	mov	r18, r24
    2da8:	30 e0       	ldi	r19, 0x00	; 0
    2daa:	8e 81       	ldd	r24, Y+6	; 0x06
    2dac:	9f 81       	ldd	r25, Y+7	; 0x07
    2dae:	ba 01       	movw	r22, r20
    2db0:	a9 01       	movw	r20, r18
    2db2:	0e 94 9b 32 	call	0x6536	; 0x6536 <memcpy>

                xReturn = pdPASS;
    2db6:	81 e0       	ldi	r24, 0x01	; 1
    2db8:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for space to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2dba:	e9 81       	ldd	r30, Y+1	; 0x01
    2dbc:	fa 81       	ldd	r31, Y+2	; 0x02
    2dbe:	80 85       	ldd	r24, Z+8	; 0x08
    2dc0:	88 23       	and	r24, r24
    2dc2:	59 f0       	breq	.+22     	; 0x2dda <xQueueCRReceive+0x102>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2dc4:	89 81       	ldd	r24, Y+1	; 0x01
    2dc6:	9a 81       	ldd	r25, Y+2	; 0x02
    2dc8:	08 96       	adiw	r24, 0x08	; 8
    2dca:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <xCoRoutineRemoveFromEventList>
    2dce:	88 23       	and	r24, r24
    2dd0:	21 f0       	breq	.+8      	; 0x2dda <xQueueCRReceive+0x102>
                    {
                        xReturn = errQUEUE_YIELD;
    2dd2:	8b ef       	ldi	r24, 0xFB	; 251
    2dd4:	8b 83       	std	Y+3, r24	; 0x03
    2dd6:	01 c0       	rjmp	.+2      	; 0x2dda <xQueueCRReceive+0x102>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = pdFAIL;
    2dd8:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    2dda:	78 94       	sei

        return xReturn;
    2ddc:	8b 81       	ldd	r24, Y+3	; 0x03
    2dde:	8a 87       	std	Y+10, r24	; 0x0a
    2de0:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    2de2:	2a 96       	adiw	r28, 0x0a	; 10
    2de4:	0f b6       	in	r0, 0x3f	; 63
    2de6:	f8 94       	cli
    2de8:	de bf       	out	0x3e, r29	; 62
    2dea:	0f be       	out	0x3f, r0	; 63
    2dec:	cd bf       	out	0x3d, r28	; 61
    2dee:	cf 91       	pop	r28
    2df0:	df 91       	pop	r29
    2df2:	08 95       	ret

00002df4 <xQueueCRSendFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
                                    const void * pvItemToQueue,
                                    BaseType_t xCoRoutinePreviouslyWoken )
    {
    2df4:	df 93       	push	r29
    2df6:	cf 93       	push	r28
    2df8:	cd b7       	in	r28, 0x3d	; 61
    2dfa:	de b7       	in	r29, 0x3e	; 62
    2dfc:	28 97       	sbiw	r28, 0x08	; 8
    2dfe:	0f b6       	in	r0, 0x3f	; 63
    2e00:	f8 94       	cli
    2e02:	de bf       	out	0x3e, r29	; 62
    2e04:	0f be       	out	0x3f, r0	; 63
    2e06:	cd bf       	out	0x3d, r28	; 61
    2e08:	9c 83       	std	Y+4, r25	; 0x04
    2e0a:	8b 83       	std	Y+3, r24	; 0x03
    2e0c:	7e 83       	std	Y+6, r23	; 0x06
    2e0e:	6d 83       	std	Y+5, r22	; 0x05
    2e10:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    2e12:	8b 81       	ldd	r24, Y+3	; 0x03
    2e14:	9c 81       	ldd	r25, Y+4	; 0x04
    2e16:	9a 83       	std	Y+2, r25	; 0x02
    2e18:	89 83       	std	Y+1, r24	; 0x01

        /* Cannot block within an ISR so if there is no space on the queue then
         * exit without doing anything. */
        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2e1a:	e9 81       	ldd	r30, Y+1	; 0x01
    2e1c:	fa 81       	ldd	r31, Y+2	; 0x02
    2e1e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2e20:	e9 81       	ldd	r30, Y+1	; 0x01
    2e22:	fa 81       	ldd	r31, Y+2	; 0x02
    2e24:	83 8d       	ldd	r24, Z+27	; 0x1b
    2e26:	98 17       	cp	r25, r24
    2e28:	d0 f4       	brcc	.+52     	; 0x2e5e <xQueueCRSendFromISR+0x6a>
        {
            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    2e2a:	89 81       	ldd	r24, Y+1	; 0x01
    2e2c:	9a 81       	ldd	r25, Y+2	; 0x02
    2e2e:	2d 81       	ldd	r18, Y+5	; 0x05
    2e30:	3e 81       	ldd	r19, Y+6	; 0x06
    2e32:	b9 01       	movw	r22, r18
    2e34:	40 e0       	ldi	r20, 0x00	; 0
    2e36:	0e 94 4d 14 	call	0x289a	; 0x289a <prvCopyDataToQueue>

            /* We only want to wake one co-routine per ISR, so check that a
             * co-routine has not already been woken. */
            if( xCoRoutinePreviouslyWoken == pdFALSE )
    2e3a:	8f 81       	ldd	r24, Y+7	; 0x07
    2e3c:	88 23       	and	r24, r24
    2e3e:	79 f4       	brne	.+30     	; 0x2e5e <xQueueCRSendFromISR+0x6a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2e40:	e9 81       	ldd	r30, Y+1	; 0x01
    2e42:	fa 81       	ldd	r31, Y+2	; 0x02
    2e44:	81 89       	ldd	r24, Z+17	; 0x11
    2e46:	88 23       	and	r24, r24
    2e48:	51 f0       	breq	.+20     	; 0x2e5e <xQueueCRSendFromISR+0x6a>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2e4a:	89 81       	ldd	r24, Y+1	; 0x01
    2e4c:	9a 81       	ldd	r25, Y+2	; 0x02
    2e4e:	41 96       	adiw	r24, 0x11	; 17
    2e50:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <xCoRoutineRemoveFromEventList>
    2e54:	88 23       	and	r24, r24
    2e56:	19 f0       	breq	.+6      	; 0x2e5e <xQueueCRSendFromISR+0x6a>
                    {
                        return pdTRUE;
    2e58:	81 e0       	ldi	r24, 0x01	; 1
    2e5a:	88 87       	std	Y+8, r24	; 0x08
    2e5c:	02 c0       	rjmp	.+4      	; 0x2e62 <xQueueCRSendFromISR+0x6e>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xCoRoutinePreviouslyWoken;
    2e5e:	8f 81       	ldd	r24, Y+7	; 0x07
    2e60:	88 87       	std	Y+8, r24	; 0x08
    2e62:	88 85       	ldd	r24, Y+8	; 0x08
    }
    2e64:	28 96       	adiw	r28, 0x08	; 8
    2e66:	0f b6       	in	r0, 0x3f	; 63
    2e68:	f8 94       	cli
    2e6a:	de bf       	out	0x3e, r29	; 62
    2e6c:	0f be       	out	0x3f, r0	; 63
    2e6e:	cd bf       	out	0x3d, r28	; 61
    2e70:	cf 91       	pop	r28
    2e72:	df 91       	pop	r29
    2e74:	08 95       	ret

00002e76 <xQueueCRReceiveFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
                                       void * pvBuffer,
                                       BaseType_t * pxCoRoutineWoken )
    {
    2e76:	df 93       	push	r29
    2e78:	cf 93       	push	r28
    2e7a:	cd b7       	in	r28, 0x3d	; 61
    2e7c:	de b7       	in	r29, 0x3e	; 62
    2e7e:	29 97       	sbiw	r28, 0x09	; 9
    2e80:	0f b6       	in	r0, 0x3f	; 63
    2e82:	f8 94       	cli
    2e84:	de bf       	out	0x3e, r29	; 62
    2e86:	0f be       	out	0x3f, r0	; 63
    2e88:	cd bf       	out	0x3d, r28	; 61
    2e8a:	9d 83       	std	Y+5, r25	; 0x05
    2e8c:	8c 83       	std	Y+4, r24	; 0x04
    2e8e:	7f 83       	std	Y+7, r23	; 0x07
    2e90:	6e 83       	std	Y+6, r22	; 0x06
    2e92:	59 87       	std	Y+9, r21	; 0x09
    2e94:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    2e96:	8c 81       	ldd	r24, Y+4	; 0x04
    2e98:	9d 81       	ldd	r25, Y+5	; 0x05
    2e9a:	9a 83       	std	Y+2, r25	; 0x02
    2e9c:	89 83       	std	Y+1, r24	; 0x01

        /* We cannot block from an ISR, so check there is data available. If
         * not then just leave without doing anything. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2e9e:	e9 81       	ldd	r30, Y+1	; 0x01
    2ea0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ea2:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ea4:	88 23       	and	r24, r24
    2ea6:	09 f4       	brne	.+2      	; 0x2eaa <xQueueCRReceiveFromISR+0x34>
    2ea8:	50 c0       	rjmp	.+160    	; 0x2f4a <xQueueCRReceiveFromISR+0xd4>
        {
            /* Copy the data from the queue. */
            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    2eaa:	e9 81       	ldd	r30, Y+1	; 0x01
    2eac:	fa 81       	ldd	r31, Y+2	; 0x02
    2eae:	26 81       	ldd	r18, Z+6	; 0x06
    2eb0:	37 81       	ldd	r19, Z+7	; 0x07
    2eb2:	e9 81       	ldd	r30, Y+1	; 0x01
    2eb4:	fa 81       	ldd	r31, Y+2	; 0x02
    2eb6:	84 8d       	ldd	r24, Z+28	; 0x1c
    2eb8:	88 2f       	mov	r24, r24
    2eba:	90 e0       	ldi	r25, 0x00	; 0
    2ebc:	82 0f       	add	r24, r18
    2ebe:	93 1f       	adc	r25, r19
    2ec0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ec2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ec4:	97 83       	std	Z+7, r25	; 0x07
    2ec6:	86 83       	std	Z+6, r24	; 0x06

            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    2ec8:	e9 81       	ldd	r30, Y+1	; 0x01
    2eca:	fa 81       	ldd	r31, Y+2	; 0x02
    2ecc:	26 81       	ldd	r18, Z+6	; 0x06
    2ece:	37 81       	ldd	r19, Z+7	; 0x07
    2ed0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ed2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ed4:	84 81       	ldd	r24, Z+4	; 0x04
    2ed6:	95 81       	ldd	r25, Z+5	; 0x05
    2ed8:	28 17       	cp	r18, r24
    2eda:	39 07       	cpc	r19, r25
    2edc:	40 f0       	brcs	.+16     	; 0x2eee <xQueueCRReceiveFromISR+0x78>
            {
                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2ede:	e9 81       	ldd	r30, Y+1	; 0x01
    2ee0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ee2:	80 81       	ld	r24, Z
    2ee4:	91 81       	ldd	r25, Z+1	; 0x01
    2ee6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ee8:	fa 81       	ldd	r31, Y+2	; 0x02
    2eea:	97 83       	std	Z+7, r25	; 0x07
    2eec:	86 83       	std	Z+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            --( pxQueue->uxMessagesWaiting );
    2eee:	e9 81       	ldd	r30, Y+1	; 0x01
    2ef0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ef2:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ef4:	81 50       	subi	r24, 0x01	; 1
    2ef6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ef8:	fa 81       	ldd	r31, Y+2	; 0x02
    2efa:	82 8f       	std	Z+26, r24	; 0x1a
            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2efc:	e9 81       	ldd	r30, Y+1	; 0x01
    2efe:	fa 81       	ldd	r31, Y+2	; 0x02
    2f00:	46 81       	ldd	r20, Z+6	; 0x06
    2f02:	57 81       	ldd	r21, Z+7	; 0x07
    2f04:	e9 81       	ldd	r30, Y+1	; 0x01
    2f06:	fa 81       	ldd	r31, Y+2	; 0x02
    2f08:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f0a:	28 2f       	mov	r18, r24
    2f0c:	30 e0       	ldi	r19, 0x00	; 0
    2f0e:	8e 81       	ldd	r24, Y+6	; 0x06
    2f10:	9f 81       	ldd	r25, Y+7	; 0x07
    2f12:	ba 01       	movw	r22, r20
    2f14:	a9 01       	movw	r20, r18
    2f16:	0e 94 9b 32 	call	0x6536	; 0x6536 <memcpy>

            if( ( *pxCoRoutineWoken ) == pdFALSE )
    2f1a:	e8 85       	ldd	r30, Y+8	; 0x08
    2f1c:	f9 85       	ldd	r31, Y+9	; 0x09
    2f1e:	80 81       	ld	r24, Z
    2f20:	88 23       	and	r24, r24
    2f22:	81 f4       	brne	.+32     	; 0x2f44 <xQueueCRReceiveFromISR+0xce>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2f24:	e9 81       	ldd	r30, Y+1	; 0x01
    2f26:	fa 81       	ldd	r31, Y+2	; 0x02
    2f28:	80 85       	ldd	r24, Z+8	; 0x08
    2f2a:	88 23       	and	r24, r24
    2f2c:	59 f0       	breq	.+22     	; 0x2f44 <xQueueCRReceiveFromISR+0xce>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2f2e:	89 81       	ldd	r24, Y+1	; 0x01
    2f30:	9a 81       	ldd	r25, Y+2	; 0x02
    2f32:	08 96       	adiw	r24, 0x08	; 8
    2f34:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <xCoRoutineRemoveFromEventList>
    2f38:	88 23       	and	r24, r24
    2f3a:	21 f0       	breq	.+8      	; 0x2f44 <xQueueCRReceiveFromISR+0xce>
                    {
                        *pxCoRoutineWoken = pdTRUE;
    2f3c:	e8 85       	ldd	r30, Y+8	; 0x08
    2f3e:	f9 85       	ldd	r31, Y+9	; 0x09
    2f40:	81 e0       	ldi	r24, 0x01	; 1
    2f42:	80 83       	st	Z, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
    2f44:	81 e0       	ldi	r24, 0x01	; 1
    2f46:	8b 83       	std	Y+3, r24	; 0x03
    2f48:	01 c0       	rjmp	.+2      	; 0x2f4c <xQueueCRReceiveFromISR+0xd6>
        }
        else
        {
            xReturn = pdFAIL;
    2f4a:	1b 82       	std	Y+3, r1	; 0x03
        }

        return xReturn;
    2f4c:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    2f4e:	29 96       	adiw	r28, 0x09	; 9
    2f50:	0f b6       	in	r0, 0x3f	; 63
    2f52:	f8 94       	cli
    2f54:	de bf       	out	0x3e, r29	; 62
    2f56:	0f be       	out	0x3f, r0	; 63
    2f58:	cd bf       	out	0x3d, r28	; 61
    2f5a:	cf 91       	pop	r28
    2f5c:	df 91       	pop	r29
    2f5e:	08 95       	ret

00002f60 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
    2f60:	df 93       	push	r29
    2f62:	cf 93       	push	r28
    2f64:	cd b7       	in	r28, 0x3d	; 61
    2f66:	de b7       	in	r29, 0x3e	; 62
    2f68:	27 97       	sbiw	r28, 0x07	; 7
    2f6a:	0f b6       	in	r0, 0x3f	; 63
    2f6c:	f8 94       	cli
    2f6e:	de bf       	out	0x3e, r29	; 62
    2f70:	0f be       	out	0x3f, r0	; 63
    2f72:	cd bf       	out	0x3d, r28	; 61
    2f74:	9c 83       	std	Y+4, r25	; 0x04
    2f76:	8b 83       	std	Y+3, r24	; 0x03
    2f78:	7e 83       	std	Y+6, r23	; 0x06
    2f7a:	6d 83       	std	Y+5, r22	; 0x05
    2f7c:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    2f7e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f80:	9c 81       	ldd	r25, Y+4	; 0x04
    2f82:	9a 83       	std	Y+2, r25	; 0x02
    2f84:	89 83       	std	Y+1, r24	; 0x01
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    2f86:	0f b6       	in	r0, 0x3f	; 63
    2f88:	f8 94       	cli
    2f8a:	0f 92       	push	r0
    2f8c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f8e:	fa 81       	ldd	r31, Y+2	; 0x02
    2f90:	85 8d       	ldd	r24, Z+29	; 0x1d
    2f92:	8f 3f       	cpi	r24, 0xFF	; 255
    2f94:	19 f4       	brne	.+6      	; 0x2f9c <vQueueWaitForMessageRestricted+0x3c>
    2f96:	e9 81       	ldd	r30, Y+1	; 0x01
    2f98:	fa 81       	ldd	r31, Y+2	; 0x02
    2f9a:	15 8e       	std	Z+29, r1	; 0x1d
    2f9c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f9e:	fa 81       	ldd	r31, Y+2	; 0x02
    2fa0:	86 8d       	ldd	r24, Z+30	; 0x1e
    2fa2:	8f 3f       	cpi	r24, 0xFF	; 255
    2fa4:	19 f4       	brne	.+6      	; 0x2fac <vQueueWaitForMessageRestricted+0x4c>
    2fa6:	e9 81       	ldd	r30, Y+1	; 0x01
    2fa8:	fa 81       	ldd	r31, Y+2	; 0x02
    2faa:	16 8e       	std	Z+30, r1	; 0x1e
    2fac:	0f 90       	pop	r0
    2fae:	0f be       	out	0x3f, r0	; 63

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    2fb0:	e9 81       	ldd	r30, Y+1	; 0x01
    2fb2:	fa 81       	ldd	r31, Y+2	; 0x02
    2fb4:	82 8d       	ldd	r24, Z+26	; 0x1a
    2fb6:	88 23       	and	r24, r24
    2fb8:	49 f4       	brne	.+18     	; 0x2fcc <vQueueWaitForMessageRestricted+0x6c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    2fba:	89 81       	ldd	r24, Y+1	; 0x01
    2fbc:	9a 81       	ldd	r25, Y+2	; 0x02
    2fbe:	41 96       	adiw	r24, 0x11	; 17
    2fc0:	2d 81       	ldd	r18, Y+5	; 0x05
    2fc2:	3e 81       	ldd	r19, Y+6	; 0x06
    2fc4:	b9 01       	movw	r22, r18
    2fc6:	4f 81       	ldd	r20, Y+7	; 0x07
    2fc8:	0e 94 a8 1f 	call	0x3f50	; 0x3f50 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
    2fcc:	89 81       	ldd	r24, Y+1	; 0x01
    2fce:	9a 81       	ldd	r25, Y+2	; 0x02
    2fd0:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <prvUnlockQueue>
    }
    2fd4:	27 96       	adiw	r28, 0x07	; 7
    2fd6:	0f b6       	in	r0, 0x3f	; 63
    2fd8:	f8 94       	cli
    2fda:	de bf       	out	0x3e, r29	; 62
    2fdc:	0f be       	out	0x3f, r0	; 63
    2fde:	cd bf       	out	0x3d, r28	; 61
    2fe0:	cf 91       	pop	r28
    2fe2:	df 91       	pop	r29
    2fe4:	08 95       	ret

00002fe6 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    2fe6:	8f 92       	push	r8
    2fe8:	9f 92       	push	r9
    2fea:	af 92       	push	r10
    2fec:	bf 92       	push	r11
    2fee:	cf 92       	push	r12
    2ff0:	df 92       	push	r13
    2ff2:	ef 92       	push	r14
    2ff4:	ff 92       	push	r15
    2ff6:	0f 93       	push	r16
    2ff8:	1f 93       	push	r17
    2ffa:	df 93       	push	r29
    2ffc:	cf 93       	push	r28
    2ffe:	cd b7       	in	r28, 0x3d	; 61
    3000:	de b7       	in	r29, 0x3e	; 62
    3002:	60 97       	sbiw	r28, 0x10	; 16
    3004:	0f b6       	in	r0, 0x3f	; 63
    3006:	f8 94       	cli
    3008:	de bf       	out	0x3e, r29	; 62
    300a:	0f be       	out	0x3f, r0	; 63
    300c:	cd bf       	out	0x3d, r28	; 61
    300e:	9f 83       	std	Y+7, r25	; 0x07
    3010:	8e 83       	std	Y+6, r24	; 0x06
    3012:	79 87       	std	Y+9, r23	; 0x09
    3014:	68 87       	std	Y+8, r22	; 0x08
    3016:	5b 87       	std	Y+11, r21	; 0x0b
    3018:	4a 87       	std	Y+10, r20	; 0x0a
    301a:	3d 87       	std	Y+13, r19	; 0x0d
    301c:	2c 87       	std	Y+12, r18	; 0x0c
    301e:	0e 87       	std	Y+14, r16	; 0x0e
    3020:	f8 8a       	std	Y+16, r15	; 0x10
    3022:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3024:	8a 85       	ldd	r24, Y+10	; 0x0a
    3026:	9b 85       	ldd	r25, Y+11	; 0x0b
    3028:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    302c:	9a 83       	std	Y+2, r25	; 0x02
    302e:	89 83       	std	Y+1, r24	; 0x01

                if( pxStack != NULL )
    3030:	89 81       	ldd	r24, Y+1	; 0x01
    3032:	9a 81       	ldd	r25, Y+2	; 0x02
    3034:	00 97       	sbiw	r24, 0x00	; 0
    3036:	b1 f0       	breq	.+44     	; 0x3064 <xTaskCreate+0x7e>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    3038:	86 e2       	ldi	r24, 0x26	; 38
    303a:	90 e0       	ldi	r25, 0x00	; 0
    303c:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    3040:	9d 83       	std	Y+5, r25	; 0x05
    3042:	8c 83       	std	Y+4, r24	; 0x04

                    if( pxNewTCB != NULL )
    3044:	8c 81       	ldd	r24, Y+4	; 0x04
    3046:	9d 81       	ldd	r25, Y+5	; 0x05
    3048:	00 97       	sbiw	r24, 0x00	; 0
    304a:	39 f0       	breq	.+14     	; 0x305a <xTaskCreate+0x74>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    304c:	ec 81       	ldd	r30, Y+4	; 0x04
    304e:	fd 81       	ldd	r31, Y+5	; 0x05
    3050:	89 81       	ldd	r24, Y+1	; 0x01
    3052:	9a 81       	ldd	r25, Y+2	; 0x02
    3054:	90 8f       	std	Z+24, r25	; 0x18
    3056:	87 8b       	std	Z+23, r24	; 0x17
    3058:	07 c0       	rjmp	.+14     	; 0x3068 <xTaskCreate+0x82>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFreeStack( pxStack );
    305a:	89 81       	ldd	r24, Y+1	; 0x01
    305c:	9a 81       	ldd	r25, Y+2	; 0x02
    305e:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
    3062:	02 c0       	rjmp	.+4      	; 0x3068 <xTaskCreate+0x82>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
    3064:	1d 82       	std	Y+5, r1	; 0x05
    3066:	1c 82       	std	Y+4, r1	; 0x04
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    3068:	8c 81       	ldd	r24, Y+4	; 0x04
    306a:	9d 81       	ldd	r25, Y+5	; 0x05
    306c:	00 97       	sbiw	r24, 0x00	; 0
    306e:	e9 f0       	breq	.+58     	; 0x30aa <xTaskCreate+0xc4>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    3070:	8a 85       	ldd	r24, Y+10	; 0x0a
    3072:	9b 85       	ldd	r25, Y+11	; 0x0b
    3074:	9c 01       	movw	r18, r24
    3076:	40 e0       	ldi	r20, 0x00	; 0
    3078:	50 e0       	ldi	r21, 0x00	; 0
    307a:	8e 81       	ldd	r24, Y+6	; 0x06
    307c:	9f 81       	ldd	r25, Y+7	; 0x07
    307e:	68 85       	ldd	r22, Y+8	; 0x08
    3080:	79 85       	ldd	r23, Y+9	; 0x09
    3082:	ec 85       	ldd	r30, Y+12	; 0x0c
    3084:	fd 85       	ldd	r31, Y+13	; 0x0d
    3086:	af 85       	ldd	r26, Y+15	; 0x0f
    3088:	b8 89       	ldd	r27, Y+16	; 0x10
    308a:	ac 80       	ldd	r10, Y+4	; 0x04
    308c:	bd 80       	ldd	r11, Y+5	; 0x05
    308e:	8f 01       	movw	r16, r30
    3090:	ee 84       	ldd	r14, Y+14	; 0x0e
    3092:	6d 01       	movw	r12, r26
    3094:	88 24       	eor	r8, r8
    3096:	99 24       	eor	r9, r9
    3098:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    309c:	8c 81       	ldd	r24, Y+4	; 0x04
    309e:	9d 81       	ldd	r25, Y+5	; 0x05
    30a0:	0e 94 30 19 	call	0x3260	; 0x3260 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    30a4:	81 e0       	ldi	r24, 0x01	; 1
    30a6:	8b 83       	std	Y+3, r24	; 0x03
    30a8:	02 c0       	rjmp	.+4      	; 0x30ae <xTaskCreate+0xc8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    30aa:	8f ef       	ldi	r24, 0xFF	; 255
    30ac:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    30ae:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    30b0:	60 96       	adiw	r28, 0x10	; 16
    30b2:	0f b6       	in	r0, 0x3f	; 63
    30b4:	f8 94       	cli
    30b6:	de bf       	out	0x3e, r29	; 62
    30b8:	0f be       	out	0x3f, r0	; 63
    30ba:	cd bf       	out	0x3d, r28	; 61
    30bc:	cf 91       	pop	r28
    30be:	df 91       	pop	r29
    30c0:	1f 91       	pop	r17
    30c2:	0f 91       	pop	r16
    30c4:	ff 90       	pop	r15
    30c6:	ef 90       	pop	r14
    30c8:	df 90       	pop	r13
    30ca:	cf 90       	pop	r12
    30cc:	bf 90       	pop	r11
    30ce:	af 90       	pop	r10
    30d0:	9f 90       	pop	r9
    30d2:	8f 90       	pop	r8
    30d4:	08 95       	ret

000030d6 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    30d6:	8f 92       	push	r8
    30d8:	9f 92       	push	r9
    30da:	af 92       	push	r10
    30dc:	bf 92       	push	r11
    30de:	cf 92       	push	r12
    30e0:	df 92       	push	r13
    30e2:	ef 92       	push	r14
    30e4:	0f 93       	push	r16
    30e6:	1f 93       	push	r17
    30e8:	df 93       	push	r29
    30ea:	cf 93       	push	r28
    30ec:	cd b7       	in	r28, 0x3d	; 61
    30ee:	de b7       	in	r29, 0x3e	; 62
    30f0:	64 97       	sbiw	r28, 0x14	; 20
    30f2:	0f b6       	in	r0, 0x3f	; 63
    30f4:	f8 94       	cli
    30f6:	de bf       	out	0x3e, r29	; 62
    30f8:	0f be       	out	0x3f, r0	; 63
    30fa:	cd bf       	out	0x3d, r28	; 61
    30fc:	9d 83       	std	Y+5, r25	; 0x05
    30fe:	8c 83       	std	Y+4, r24	; 0x04
    3100:	7f 83       	std	Y+7, r23	; 0x07
    3102:	6e 83       	std	Y+6, r22	; 0x06
    3104:	28 87       	std	Y+8, r18	; 0x08
    3106:	39 87       	std	Y+9, r19	; 0x09
    3108:	4a 87       	std	Y+10, r20	; 0x0a
    310a:	5b 87       	std	Y+11, r21	; 0x0b
    310c:	1d 87       	std	Y+13, r17	; 0x0d
    310e:	0c 87       	std	Y+12, r16	; 0x0c
    3110:	ee 86       	std	Y+14, r14	; 0x0e
    3112:	d8 8a       	std	Y+16, r13	; 0x10
    3114:	cf 86       	std	Y+15, r12	; 0x0f
    3116:	ba 8a       	std	Y+18, r11	; 0x12
    3118:	a9 8a       	std	Y+17, r10	; 0x11
    311a:	9c 8a       	std	Y+20, r9	; 0x14
    311c:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    311e:	e9 89       	ldd	r30, Y+17	; 0x11
    3120:	fa 89       	ldd	r31, Y+18	; 0x12
    3122:	27 89       	ldd	r18, Z+23	; 0x17
    3124:	30 8d       	ldd	r19, Z+24	; 0x18
    3126:	88 85       	ldd	r24, Y+8	; 0x08
    3128:	99 85       	ldd	r25, Y+9	; 0x09
    312a:	01 97       	sbiw	r24, 0x01	; 1
    312c:	82 0f       	add	r24, r18
    312e:	93 1f       	adc	r25, r19
    3130:	9b 83       	std	Y+3, r25	; 0x03
    3132:	8a 83       	std	Y+2, r24	; 0x02
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    3134:	8e 81       	ldd	r24, Y+6	; 0x06
    3136:	9f 81       	ldd	r25, Y+7	; 0x07
    3138:	00 97       	sbiw	r24, 0x00	; 0
    313a:	51 f1       	breq	.+84     	; 0x3190 <prvInitialiseNewTask+0xba>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    313c:	19 82       	std	Y+1, r1	; 0x01
    313e:	21 c0       	rjmp	.+66     	; 0x3182 <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3140:	89 81       	ldd	r24, Y+1	; 0x01
    3142:	48 2f       	mov	r20, r24
    3144:	50 e0       	ldi	r21, 0x00	; 0
    3146:	89 81       	ldd	r24, Y+1	; 0x01
    3148:	28 2f       	mov	r18, r24
    314a:	30 e0       	ldi	r19, 0x00	; 0
    314c:	8e 81       	ldd	r24, Y+6	; 0x06
    314e:	9f 81       	ldd	r25, Y+7	; 0x07
    3150:	fc 01       	movw	r30, r24
    3152:	e2 0f       	add	r30, r18
    3154:	f3 1f       	adc	r31, r19
    3156:	20 81       	ld	r18, Z
    3158:	89 89       	ldd	r24, Y+17	; 0x11
    315a:	9a 89       	ldd	r25, Y+18	; 0x12
    315c:	84 0f       	add	r24, r20
    315e:	95 1f       	adc	r25, r21
    3160:	fc 01       	movw	r30, r24
    3162:	79 96       	adiw	r30, 0x19	; 25
    3164:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    3166:	89 81       	ldd	r24, Y+1	; 0x01
    3168:	28 2f       	mov	r18, r24
    316a:	30 e0       	ldi	r19, 0x00	; 0
    316c:	8e 81       	ldd	r24, Y+6	; 0x06
    316e:	9f 81       	ldd	r25, Y+7	; 0x07
    3170:	fc 01       	movw	r30, r24
    3172:	e2 0f       	add	r30, r18
    3174:	f3 1f       	adc	r31, r19
    3176:	80 81       	ld	r24, Z
    3178:	88 23       	and	r24, r24
    317a:	31 f0       	breq	.+12     	; 0x3188 <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    317c:	89 81       	ldd	r24, Y+1	; 0x01
    317e:	8f 5f       	subi	r24, 0xFF	; 255
    3180:	89 83       	std	Y+1, r24	; 0x01
    3182:	89 81       	ldd	r24, Y+1	; 0x01
    3184:	88 30       	cpi	r24, 0x08	; 8
    3186:	e0 f2       	brcs	.-72     	; 0x3140 <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3188:	e9 89       	ldd	r30, Y+17	; 0x11
    318a:	fa 89       	ldd	r31, Y+18	; 0x12
    318c:	10 a2       	std	Z+32, r1	; 0x20
    318e:	03 c0       	rjmp	.+6      	; 0x3196 <prvInitialiseNewTask+0xc0>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    3190:	e9 89       	ldd	r30, Y+17	; 0x11
    3192:	fa 89       	ldd	r31, Y+18	; 0x12
    3194:	11 8e       	std	Z+25, r1	; 0x19
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3196:	8e 85       	ldd	r24, Y+14	; 0x0e
    3198:	84 30       	cpi	r24, 0x04	; 4
    319a:	10 f0       	brcs	.+4      	; 0x31a0 <prvInitialiseNewTask+0xca>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    319c:	83 e0       	ldi	r24, 0x03	; 3
    319e:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    31a0:	e9 89       	ldd	r30, Y+17	; 0x11
    31a2:	fa 89       	ldd	r31, Y+18	; 0x12
    31a4:	8e 85       	ldd	r24, Y+14	; 0x0e
    31a6:	86 8b       	std	Z+22, r24	; 0x16
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    31a8:	89 89       	ldd	r24, Y+17	; 0x11
    31aa:	9a 89       	ldd	r25, Y+18	; 0x12
    31ac:	02 96       	adiw	r24, 0x02	; 2
    31ae:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    31b2:	89 89       	ldd	r24, Y+17	; 0x11
    31b4:	9a 89       	ldd	r25, Y+18	; 0x12
    31b6:	0c 96       	adiw	r24, 0x0c	; 12
    31b8:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    31bc:	e9 89       	ldd	r30, Y+17	; 0x11
    31be:	fa 89       	ldd	r31, Y+18	; 0x12
    31c0:	89 89       	ldd	r24, Y+17	; 0x11
    31c2:	9a 89       	ldd	r25, Y+18	; 0x12
    31c4:	91 87       	std	Z+9, r25	; 0x09
    31c6:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    31c8:	8e 85       	ldd	r24, Y+14	; 0x0e
    31ca:	28 2f       	mov	r18, r24
    31cc:	30 e0       	ldi	r19, 0x00	; 0
    31ce:	84 e0       	ldi	r24, 0x04	; 4
    31d0:	90 e0       	ldi	r25, 0x00	; 0
    31d2:	82 1b       	sub	r24, r18
    31d4:	93 0b       	sbc	r25, r19
    31d6:	e9 89       	ldd	r30, Y+17	; 0x11
    31d8:	fa 89       	ldd	r31, Y+18	; 0x12
    31da:	95 87       	std	Z+13, r25	; 0x0d
    31dc:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    31de:	e9 89       	ldd	r30, Y+17	; 0x11
    31e0:	fa 89       	ldd	r31, Y+18	; 0x12
    31e2:	89 89       	ldd	r24, Y+17	; 0x11
    31e4:	9a 89       	ldd	r25, Y+18	; 0x12
    31e6:	93 8b       	std	Z+19, r25	; 0x13
    31e8:	82 8b       	std	Z+18, r24	; 0x12
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    31ea:	89 89       	ldd	r24, Y+17	; 0x11
    31ec:	9a 89       	ldd	r25, Y+18	; 0x12
    31ee:	81 96       	adiw	r24, 0x21	; 33
    31f0:	60 e0       	ldi	r22, 0x00	; 0
    31f2:	70 e0       	ldi	r23, 0x00	; 0
    31f4:	44 e0       	ldi	r20, 0x04	; 4
    31f6:	50 e0       	ldi	r21, 0x00	; 0
    31f8:	0e 94 a4 32 	call	0x6548	; 0x6548 <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    31fc:	89 89       	ldd	r24, Y+17	; 0x11
    31fe:	9a 89       	ldd	r25, Y+18	; 0x12
    3200:	85 96       	adiw	r24, 0x25	; 37
    3202:	60 e0       	ldi	r22, 0x00	; 0
    3204:	70 e0       	ldi	r23, 0x00	; 0
    3206:	41 e0       	ldi	r20, 0x01	; 1
    3208:	50 e0       	ldi	r21, 0x00	; 0
    320a:	0e 94 a4 32 	call	0x6548	; 0x6548 <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    320e:	8a 81       	ldd	r24, Y+2	; 0x02
    3210:	9b 81       	ldd	r25, Y+3	; 0x03
    3212:	2c 81       	ldd	r18, Y+4	; 0x04
    3214:	3d 81       	ldd	r19, Y+5	; 0x05
    3216:	4c 85       	ldd	r20, Y+12	; 0x0c
    3218:	5d 85       	ldd	r21, Y+13	; 0x0d
    321a:	b9 01       	movw	r22, r18
    321c:	0e 94 c9 00 	call	0x192	; 0x192 <pxPortInitialiseStack>
    3220:	e9 89       	ldd	r30, Y+17	; 0x11
    3222:	fa 89       	ldd	r31, Y+18	; 0x12
    3224:	91 83       	std	Z+1, r25	; 0x01
    3226:	80 83       	st	Z, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    3228:	8f 85       	ldd	r24, Y+15	; 0x0f
    322a:	98 89       	ldd	r25, Y+16	; 0x10
    322c:	00 97       	sbiw	r24, 0x00	; 0
    322e:	31 f0       	breq	.+12     	; 0x323c <prvInitialiseNewTask+0x166>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3230:	ef 85       	ldd	r30, Y+15	; 0x0f
    3232:	f8 89       	ldd	r31, Y+16	; 0x10
    3234:	89 89       	ldd	r24, Y+17	; 0x11
    3236:	9a 89       	ldd	r25, Y+18	; 0x12
    3238:	91 83       	std	Z+1, r25	; 0x01
    323a:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    323c:	64 96       	adiw	r28, 0x14	; 20
    323e:	0f b6       	in	r0, 0x3f	; 63
    3240:	f8 94       	cli
    3242:	de bf       	out	0x3e, r29	; 62
    3244:	0f be       	out	0x3f, r0	; 63
    3246:	cd bf       	out	0x3d, r28	; 61
    3248:	cf 91       	pop	r28
    324a:	df 91       	pop	r29
    324c:	1f 91       	pop	r17
    324e:	0f 91       	pop	r16
    3250:	ef 90       	pop	r14
    3252:	df 90       	pop	r13
    3254:	cf 90       	pop	r12
    3256:	bf 90       	pop	r11
    3258:	af 90       	pop	r10
    325a:	9f 90       	pop	r9
    325c:	8f 90       	pop	r8
    325e:	08 95       	ret

00003260 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    3260:	df 93       	push	r29
    3262:	cf 93       	push	r28
    3264:	00 d0       	rcall	.+0      	; 0x3266 <prvAddNewTaskToReadyList+0x6>
    3266:	00 d0       	rcall	.+0      	; 0x3268 <prvAddNewTaskToReadyList+0x8>
    3268:	cd b7       	in	r28, 0x3d	; 61
    326a:	de b7       	in	r29, 0x3e	; 62
    326c:	9c 83       	std	Y+4, r25	; 0x04
    326e:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    3270:	0f b6       	in	r0, 0x3f	; 63
    3272:	f8 94       	cli
    3274:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    3276:	80 91 a9 06 	lds	r24, 0x06A9
    327a:	8f 5f       	subi	r24, 0xFF	; 255
    327c:	80 93 a9 06 	sts	0x06A9, r24

        if( pxCurrentTCB == NULL )
    3280:	80 91 a6 06 	lds	r24, 0x06A6
    3284:	90 91 a7 06 	lds	r25, 0x06A7
    3288:	00 97       	sbiw	r24, 0x00	; 0
    328a:	69 f4       	brne	.+26     	; 0x32a6 <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    328c:	8b 81       	ldd	r24, Y+3	; 0x03
    328e:	9c 81       	ldd	r25, Y+4	; 0x04
    3290:	90 93 a7 06 	sts	0x06A7, r25
    3294:	80 93 a6 06 	sts	0x06A6, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3298:	80 91 a9 06 	lds	r24, 0x06A9
    329c:	81 30       	cpi	r24, 0x01	; 1
    329e:	b9 f4       	brne	.+46     	; 0x32ce <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    32a0:	0e 94 14 23 	call	0x4628	; 0x4628 <prvInitialiseTaskLists>
    32a4:	14 c0       	rjmp	.+40     	; 0x32ce <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    32a6:	80 91 ad 06 	lds	r24, 0x06AD
    32aa:	88 23       	and	r24, r24
    32ac:	81 f4       	brne	.+32     	; 0x32ce <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    32ae:	e0 91 a6 06 	lds	r30, 0x06A6
    32b2:	f0 91 a7 06 	lds	r31, 0x06A7
    32b6:	96 89       	ldd	r25, Z+22	; 0x16
    32b8:	eb 81       	ldd	r30, Y+3	; 0x03
    32ba:	fc 81       	ldd	r31, Y+4	; 0x04
    32bc:	86 89       	ldd	r24, Z+22	; 0x16
    32be:	89 17       	cp	r24, r25
    32c0:	30 f0       	brcs	.+12     	; 0x32ce <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    32c2:	8b 81       	ldd	r24, Y+3	; 0x03
    32c4:	9c 81       	ldd	r25, Y+4	; 0x04
    32c6:	90 93 a7 06 	sts	0x06A7, r25
    32ca:	80 93 a6 06 	sts	0x06A6, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    32ce:	80 91 b2 06 	lds	r24, 0x06B2
    32d2:	8f 5f       	subi	r24, 0xFF	; 255
    32d4:	80 93 b2 06 	sts	0x06B2, r24
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    32d8:	eb 81       	ldd	r30, Y+3	; 0x03
    32da:	fc 81       	ldd	r31, Y+4	; 0x04
    32dc:	96 89       	ldd	r25, Z+22	; 0x16
    32de:	80 91 ac 06 	lds	r24, 0x06AC
    32e2:	89 17       	cp	r24, r25
    32e4:	28 f4       	brcc	.+10     	; 0x32f0 <prvAddNewTaskToReadyList+0x90>
    32e6:	eb 81       	ldd	r30, Y+3	; 0x03
    32e8:	fc 81       	ldd	r31, Y+4	; 0x04
    32ea:	86 89       	ldd	r24, Z+22	; 0x16
    32ec:	80 93 ac 06 	sts	0x06AC, r24
    32f0:	eb 81       	ldd	r30, Y+3	; 0x03
    32f2:	fc 81       	ldd	r31, Y+4	; 0x04
    32f4:	86 89       	ldd	r24, Z+22	; 0x16
    32f6:	28 2f       	mov	r18, r24
    32f8:	30 e0       	ldi	r19, 0x00	; 0
    32fa:	c9 01       	movw	r24, r18
    32fc:	88 0f       	add	r24, r24
    32fe:	99 1f       	adc	r25, r25
    3300:	88 0f       	add	r24, r24
    3302:	99 1f       	adc	r25, r25
    3304:	88 0f       	add	r24, r24
    3306:	99 1f       	adc	r25, r25
    3308:	82 0f       	add	r24, r18
    330a:	93 1f       	adc	r25, r19
    330c:	fc 01       	movw	r30, r24
    330e:	e8 54       	subi	r30, 0x48	; 72
    3310:	f9 4f       	sbci	r31, 0xF9	; 249
    3312:	81 81       	ldd	r24, Z+1	; 0x01
    3314:	92 81       	ldd	r25, Z+2	; 0x02
    3316:	9a 83       	std	Y+2, r25	; 0x02
    3318:	89 83       	std	Y+1, r24	; 0x01
    331a:	eb 81       	ldd	r30, Y+3	; 0x03
    331c:	fc 81       	ldd	r31, Y+4	; 0x04
    331e:	89 81       	ldd	r24, Y+1	; 0x01
    3320:	9a 81       	ldd	r25, Y+2	; 0x02
    3322:	95 83       	std	Z+5, r25	; 0x05
    3324:	84 83       	std	Z+4, r24	; 0x04
    3326:	e9 81       	ldd	r30, Y+1	; 0x01
    3328:	fa 81       	ldd	r31, Y+2	; 0x02
    332a:	84 81       	ldd	r24, Z+4	; 0x04
    332c:	95 81       	ldd	r25, Z+5	; 0x05
    332e:	eb 81       	ldd	r30, Y+3	; 0x03
    3330:	fc 81       	ldd	r31, Y+4	; 0x04
    3332:	97 83       	std	Z+7, r25	; 0x07
    3334:	86 83       	std	Z+6, r24	; 0x06
    3336:	e9 81       	ldd	r30, Y+1	; 0x01
    3338:	fa 81       	ldd	r31, Y+2	; 0x02
    333a:	04 80       	ldd	r0, Z+4	; 0x04
    333c:	f5 81       	ldd	r31, Z+5	; 0x05
    333e:	e0 2d       	mov	r30, r0
    3340:	8b 81       	ldd	r24, Y+3	; 0x03
    3342:	9c 81       	ldd	r25, Y+4	; 0x04
    3344:	02 96       	adiw	r24, 0x02	; 2
    3346:	93 83       	std	Z+3, r25	; 0x03
    3348:	82 83       	std	Z+2, r24	; 0x02
    334a:	8b 81       	ldd	r24, Y+3	; 0x03
    334c:	9c 81       	ldd	r25, Y+4	; 0x04
    334e:	02 96       	adiw	r24, 0x02	; 2
    3350:	e9 81       	ldd	r30, Y+1	; 0x01
    3352:	fa 81       	ldd	r31, Y+2	; 0x02
    3354:	95 83       	std	Z+5, r25	; 0x05
    3356:	84 83       	std	Z+4, r24	; 0x04
    3358:	eb 81       	ldd	r30, Y+3	; 0x03
    335a:	fc 81       	ldd	r31, Y+4	; 0x04
    335c:	86 89       	ldd	r24, Z+22	; 0x16
    335e:	28 2f       	mov	r18, r24
    3360:	30 e0       	ldi	r19, 0x00	; 0
    3362:	c9 01       	movw	r24, r18
    3364:	88 0f       	add	r24, r24
    3366:	99 1f       	adc	r25, r25
    3368:	88 0f       	add	r24, r24
    336a:	99 1f       	adc	r25, r25
    336c:	88 0f       	add	r24, r24
    336e:	99 1f       	adc	r25, r25
    3370:	82 0f       	add	r24, r18
    3372:	93 1f       	adc	r25, r19
    3374:	88 54       	subi	r24, 0x48	; 72
    3376:	99 4f       	sbci	r25, 0xF9	; 249
    3378:	eb 81       	ldd	r30, Y+3	; 0x03
    337a:	fc 81       	ldd	r31, Y+4	; 0x04
    337c:	93 87       	std	Z+11, r25	; 0x0b
    337e:	82 87       	std	Z+10, r24	; 0x0a
    3380:	eb 81       	ldd	r30, Y+3	; 0x03
    3382:	fc 81       	ldd	r31, Y+4	; 0x04
    3384:	86 89       	ldd	r24, Z+22	; 0x16
    3386:	28 2f       	mov	r18, r24
    3388:	30 e0       	ldi	r19, 0x00	; 0
    338a:	c9 01       	movw	r24, r18
    338c:	88 0f       	add	r24, r24
    338e:	99 1f       	adc	r25, r25
    3390:	88 0f       	add	r24, r24
    3392:	99 1f       	adc	r25, r25
    3394:	88 0f       	add	r24, r24
    3396:	99 1f       	adc	r25, r25
    3398:	82 0f       	add	r24, r18
    339a:	93 1f       	adc	r25, r19
    339c:	fc 01       	movw	r30, r24
    339e:	e8 54       	subi	r30, 0x48	; 72
    33a0:	f9 4f       	sbci	r31, 0xF9	; 249
    33a2:	80 81       	ld	r24, Z
    33a4:	8f 5f       	subi	r24, 0xFF	; 255
    33a6:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    33a8:	0f 90       	pop	r0
    33aa:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    33ac:	80 91 ad 06 	lds	r24, 0x06AD
    33b0:	88 23       	and	r24, r24
    33b2:	61 f0       	breq	.+24     	; 0x33cc <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    33b4:	e0 91 a6 06 	lds	r30, 0x06A6
    33b8:	f0 91 a7 06 	lds	r31, 0x06A7
    33bc:	96 89       	ldd	r25, Z+22	; 0x16
    33be:	eb 81       	ldd	r30, Y+3	; 0x03
    33c0:	fc 81       	ldd	r31, Y+4	; 0x04
    33c2:	86 89       	ldd	r24, Z+22	; 0x16
    33c4:	98 17       	cp	r25, r24
    33c6:	10 f4       	brcc	.+4      	; 0x33cc <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    33c8:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    33cc:	0f 90       	pop	r0
    33ce:	0f 90       	pop	r0
    33d0:	0f 90       	pop	r0
    33d2:	0f 90       	pop	r0
    33d4:	cf 91       	pop	r28
    33d6:	df 91       	pop	r29
    33d8:	08 95       	ret

000033da <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    33da:	df 93       	push	r29
    33dc:	cf 93       	push	r28
    33de:	00 d0       	rcall	.+0      	; 0x33e0 <vTaskDelete+0x6>
    33e0:	00 d0       	rcall	.+0      	; 0x33e2 <vTaskDelete+0x8>
    33e2:	00 d0       	rcall	.+0      	; 0x33e4 <vTaskDelete+0xa>
    33e4:	cd b7       	in	r28, 0x3d	; 61
    33e6:	de b7       	in	r29, 0x3e	; 62
    33e8:	9c 83       	std	Y+4, r25	; 0x04
    33ea:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    33ec:	0f b6       	in	r0, 0x3f	; 63
    33ee:	f8 94       	cli
    33f0:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    33f2:	8b 81       	ldd	r24, Y+3	; 0x03
    33f4:	9c 81       	ldd	r25, Y+4	; 0x04
    33f6:	00 97       	sbiw	r24, 0x00	; 0
    33f8:	39 f4       	brne	.+14     	; 0x3408 <vTaskDelete+0x2e>
    33fa:	80 91 a6 06 	lds	r24, 0x06A6
    33fe:	90 91 a7 06 	lds	r25, 0x06A7
    3402:	9e 83       	std	Y+6, r25	; 0x06
    3404:	8d 83       	std	Y+5, r24	; 0x05
    3406:	04 c0       	rjmp	.+8      	; 0x3410 <vTaskDelete+0x36>
    3408:	8b 81       	ldd	r24, Y+3	; 0x03
    340a:	9c 81       	ldd	r25, Y+4	; 0x04
    340c:	9e 83       	std	Y+6, r25	; 0x06
    340e:	8d 83       	std	Y+5, r24	; 0x05
    3410:	8d 81       	ldd	r24, Y+5	; 0x05
    3412:	9e 81       	ldd	r25, Y+6	; 0x06
    3414:	9a 83       	std	Y+2, r25	; 0x02
    3416:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3418:	89 81       	ldd	r24, Y+1	; 0x01
    341a:	9a 81       	ldd	r25, Y+2	; 0x02
    341c:	02 96       	adiw	r24, 0x02	; 2
    341e:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3422:	e9 81       	ldd	r30, Y+1	; 0x01
    3424:	fa 81       	ldd	r31, Y+2	; 0x02
    3426:	84 89       	ldd	r24, Z+20	; 0x14
    3428:	95 89       	ldd	r25, Z+21	; 0x15
    342a:	00 97       	sbiw	r24, 0x00	; 0
    342c:	29 f0       	breq	.+10     	; 0x3438 <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    342e:	89 81       	ldd	r24, Y+1	; 0x01
    3430:	9a 81       	ldd	r25, Y+2	; 0x02
    3432:	0c 96       	adiw	r24, 0x0c	; 12
    3434:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    3438:	80 91 b2 06 	lds	r24, 0x06B2
    343c:	8f 5f       	subi	r24, 0xFF	; 255
    343e:	80 93 b2 06 	sts	0x06B2, r24

            if( pxTCB == pxCurrentTCB )
    3442:	20 91 a6 06 	lds	r18, 0x06A6
    3446:	30 91 a7 06 	lds	r19, 0x06A7
    344a:	89 81       	ldd	r24, Y+1	; 0x01
    344c:	9a 81       	ldd	r25, Y+2	; 0x02
    344e:	82 17       	cp	r24, r18
    3450:	93 07       	cpc	r25, r19
    3452:	81 f4       	brne	.+32     	; 0x3474 <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    3454:	89 81       	ldd	r24, Y+1	; 0x01
    3456:	9a 81       	ldd	r25, Y+2	; 0x02
    3458:	9c 01       	movw	r18, r24
    345a:	2e 5f       	subi	r18, 0xFE	; 254
    345c:	3f 4f       	sbci	r19, 0xFF	; 255
    345e:	8b ef       	ldi	r24, 0xFB	; 251
    3460:	96 e0       	ldi	r25, 0x06	; 6
    3462:	b9 01       	movw	r22, r18
    3464:	0e 94 a1 0d 	call	0x1b42	; 0x1b42 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    3468:	80 91 a8 06 	lds	r24, 0x06A8
    346c:	8f 5f       	subi	r24, 0xFF	; 255
    346e:	80 93 a8 06 	sts	0x06A8, r24
    3472:	07 c0       	rjmp	.+14     	; 0x3482 <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    3474:	80 91 a9 06 	lds	r24, 0x06A9
    3478:	81 50       	subi	r24, 0x01	; 1
    347a:	80 93 a9 06 	sts	0x06A9, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    347e:	0e 94 96 23 	call	0x472c	; 0x472c <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    3482:	0f 90       	pop	r0
    3484:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    3486:	20 91 a6 06 	lds	r18, 0x06A6
    348a:	30 91 a7 06 	lds	r19, 0x06A7
    348e:	89 81       	ldd	r24, Y+1	; 0x01
    3490:	9a 81       	ldd	r25, Y+2	; 0x02
    3492:	82 17       	cp	r24, r18
    3494:	93 07       	cpc	r25, r19
    3496:	21 f0       	breq	.+8      	; 0x34a0 <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    3498:	89 81       	ldd	r24, Y+1	; 0x01
    349a:	9a 81       	ldd	r25, Y+2	; 0x02
    349c:	0e 94 80 23 	call	0x4700	; 0x4700 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    34a0:	80 91 ad 06 	lds	r24, 0x06AD
    34a4:	88 23       	and	r24, r24
    34a6:	59 f0       	breq	.+22     	; 0x34be <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    34a8:	20 91 a6 06 	lds	r18, 0x06A6
    34ac:	30 91 a7 06 	lds	r19, 0x06A7
    34b0:	89 81       	ldd	r24, Y+1	; 0x01
    34b2:	9a 81       	ldd	r25, Y+2	; 0x02
    34b4:	82 17       	cp	r24, r18
    34b6:	93 07       	cpc	r25, r19
    34b8:	11 f4       	brne	.+4      	; 0x34be <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    34ba:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    34be:	26 96       	adiw	r28, 0x06	; 6
    34c0:	0f b6       	in	r0, 0x3f	; 63
    34c2:	f8 94       	cli
    34c4:	de bf       	out	0x3e, r29	; 62
    34c6:	0f be       	out	0x3f, r0	; 63
    34c8:	cd bf       	out	0x3d, r28	; 61
    34ca:	cf 91       	pop	r28
    34cc:	df 91       	pop	r29
    34ce:	08 95       	ret

000034d0 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    34d0:	df 93       	push	r29
    34d2:	cf 93       	push	r28
    34d4:	cd b7       	in	r28, 0x3d	; 61
    34d6:	de b7       	in	r29, 0x3e	; 62
    34d8:	2a 97       	sbiw	r28, 0x0a	; 10
    34da:	0f b6       	in	r0, 0x3f	; 63
    34dc:	f8 94       	cli
    34de:	de bf       	out	0x3e, r29	; 62
    34e0:	0f be       	out	0x3f, r0	; 63
    34e2:	cd bf       	out	0x3d, r28	; 61
    34e4:	98 87       	std	Y+8, r25	; 0x08
    34e6:	8f 83       	std	Y+7, r24	; 0x07
    34e8:	7a 87       	std	Y+10, r23	; 0x0a
    34ea:	69 87       	std	Y+9, r22	; 0x09
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    34ec:	1b 82       	std	Y+3, r1	; 0x03

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    34ee:	0e 94 44 1b 	call	0x3688	; 0x3688 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    34f2:	80 91 aa 06 	lds	r24, 0x06AA
    34f6:	90 91 ab 06 	lds	r25, 0x06AB
    34fa:	9a 83       	std	Y+2, r25	; 0x02
    34fc:	89 83       	std	Y+1, r24	; 0x01

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    34fe:	ef 81       	ldd	r30, Y+7	; 0x07
    3500:	f8 85       	ldd	r31, Y+8	; 0x08
    3502:	20 81       	ld	r18, Z
    3504:	31 81       	ldd	r19, Z+1	; 0x01
    3506:	89 85       	ldd	r24, Y+9	; 0x09
    3508:	9a 85       	ldd	r25, Y+10	; 0x0a
    350a:	82 0f       	add	r24, r18
    350c:	93 1f       	adc	r25, r19
    350e:	9e 83       	std	Y+6, r25	; 0x06
    3510:	8d 83       	std	Y+5, r24	; 0x05

            if( xConstTickCount < *pxPreviousWakeTime )
    3512:	ef 81       	ldd	r30, Y+7	; 0x07
    3514:	f8 85       	ldd	r31, Y+8	; 0x08
    3516:	20 81       	ld	r18, Z
    3518:	31 81       	ldd	r19, Z+1	; 0x01
    351a:	89 81       	ldd	r24, Y+1	; 0x01
    351c:	9a 81       	ldd	r25, Y+2	; 0x02
    351e:	82 17       	cp	r24, r18
    3520:	93 07       	cpc	r25, r19
    3522:	98 f4       	brcc	.+38     	; 0x354a <xTaskDelayUntil+0x7a>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    3524:	ef 81       	ldd	r30, Y+7	; 0x07
    3526:	f8 85       	ldd	r31, Y+8	; 0x08
    3528:	20 81       	ld	r18, Z
    352a:	31 81       	ldd	r19, Z+1	; 0x01
    352c:	8d 81       	ldd	r24, Y+5	; 0x05
    352e:	9e 81       	ldd	r25, Y+6	; 0x06
    3530:	82 17       	cp	r24, r18
    3532:	93 07       	cpc	r25, r19
    3534:	e0 f4       	brcc	.+56     	; 0x356e <xTaskDelayUntil+0x9e>
    3536:	2d 81       	ldd	r18, Y+5	; 0x05
    3538:	3e 81       	ldd	r19, Y+6	; 0x06
    353a:	89 81       	ldd	r24, Y+1	; 0x01
    353c:	9a 81       	ldd	r25, Y+2	; 0x02
    353e:	82 17       	cp	r24, r18
    3540:	93 07       	cpc	r25, r19
    3542:	a8 f4       	brcc	.+42     	; 0x356e <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    3544:	81 e0       	ldi	r24, 0x01	; 1
    3546:	8b 83       	std	Y+3, r24	; 0x03
    3548:	12 c0       	rjmp	.+36     	; 0x356e <xTaskDelayUntil+0x9e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    354a:	ef 81       	ldd	r30, Y+7	; 0x07
    354c:	f8 85       	ldd	r31, Y+8	; 0x08
    354e:	20 81       	ld	r18, Z
    3550:	31 81       	ldd	r19, Z+1	; 0x01
    3552:	8d 81       	ldd	r24, Y+5	; 0x05
    3554:	9e 81       	ldd	r25, Y+6	; 0x06
    3556:	82 17       	cp	r24, r18
    3558:	93 07       	cpc	r25, r19
    355a:	38 f0       	brcs	.+14     	; 0x356a <xTaskDelayUntil+0x9a>
    355c:	2d 81       	ldd	r18, Y+5	; 0x05
    355e:	3e 81       	ldd	r19, Y+6	; 0x06
    3560:	89 81       	ldd	r24, Y+1	; 0x01
    3562:	9a 81       	ldd	r25, Y+2	; 0x02
    3564:	82 17       	cp	r24, r18
    3566:	93 07       	cpc	r25, r19
    3568:	10 f4       	brcc	.+4      	; 0x356e <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    356a:	81 e0       	ldi	r24, 0x01	; 1
    356c:	8b 83       	std	Y+3, r24	; 0x03
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    356e:	ef 81       	ldd	r30, Y+7	; 0x07
    3570:	f8 85       	ldd	r31, Y+8	; 0x08
    3572:	8d 81       	ldd	r24, Y+5	; 0x05
    3574:	9e 81       	ldd	r25, Y+6	; 0x06
    3576:	91 83       	std	Z+1, r25	; 0x01
    3578:	80 83       	st	Z, r24

            if( xShouldDelay != pdFALSE )
    357a:	8b 81       	ldd	r24, Y+3	; 0x03
    357c:	88 23       	and	r24, r24
    357e:	49 f0       	breq	.+18     	; 0x3592 <xTaskDelayUntil+0xc2>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    3580:	8d 81       	ldd	r24, Y+5	; 0x05
    3582:	9e 81       	ldd	r25, Y+6	; 0x06
    3584:	29 81       	ldd	r18, Y+1	; 0x01
    3586:	3a 81       	ldd	r19, Y+2	; 0x02
    3588:	82 1b       	sub	r24, r18
    358a:	93 0b       	sbc	r25, r19
    358c:	60 e0       	ldi	r22, 0x00	; 0
    358e:	0e 94 7d 2b 	call	0x56fa	; 0x56fa <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    3592:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>
    3596:	8c 83       	std	Y+4, r24	; 0x04

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3598:	8c 81       	ldd	r24, Y+4	; 0x04
    359a:	88 23       	and	r24, r24
    359c:	11 f4       	brne	.+4      	; 0x35a2 <xTaskDelayUntil+0xd2>
        {
            portYIELD_WITHIN_API();
    359e:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    35a2:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    35a4:	2a 96       	adiw	r28, 0x0a	; 10
    35a6:	0f b6       	in	r0, 0x3f	; 63
    35a8:	f8 94       	cli
    35aa:	de bf       	out	0x3e, r29	; 62
    35ac:	0f be       	out	0x3f, r0	; 63
    35ae:	cd bf       	out	0x3d, r28	; 61
    35b0:	cf 91       	pop	r28
    35b2:	df 91       	pop	r29
    35b4:	08 95       	ret

000035b6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    35b6:	df 93       	push	r29
    35b8:	cf 93       	push	r28
    35ba:	00 d0       	rcall	.+0      	; 0x35bc <vTaskDelay+0x6>
    35bc:	0f 92       	push	r0
    35be:	cd b7       	in	r28, 0x3d	; 61
    35c0:	de b7       	in	r29, 0x3e	; 62
    35c2:	9b 83       	std	Y+3, r25	; 0x03
    35c4:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    35c6:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    35c8:	8a 81       	ldd	r24, Y+2	; 0x02
    35ca:	9b 81       	ldd	r25, Y+3	; 0x03
    35cc:	00 97       	sbiw	r24, 0x00	; 0
    35ce:	51 f0       	breq	.+20     	; 0x35e4 <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    35d0:	0e 94 44 1b 	call	0x3688	; 0x3688 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    35d4:	8a 81       	ldd	r24, Y+2	; 0x02
    35d6:	9b 81       	ldd	r25, Y+3	; 0x03
    35d8:	60 e0       	ldi	r22, 0x00	; 0
    35da:	0e 94 7d 2b 	call	0x56fa	; 0x56fa <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    35de:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>
    35e2:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    35e4:	89 81       	ldd	r24, Y+1	; 0x01
    35e6:	88 23       	and	r24, r24
    35e8:	11 f4       	brne	.+4      	; 0x35ee <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    35ea:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    35ee:	0f 90       	pop	r0
    35f0:	0f 90       	pop	r0
    35f2:	0f 90       	pop	r0
    35f4:	cf 91       	pop	r28
    35f6:	df 91       	pop	r29
    35f8:	08 95       	ret

000035fa <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    35fa:	ef 92       	push	r14
    35fc:	ff 92       	push	r15
    35fe:	0f 93       	push	r16
    3600:	df 93       	push	r29
    3602:	cf 93       	push	r28
    3604:	00 d0       	rcall	.+0      	; 0x3606 <vTaskStartScheduler+0xc>
    3606:	cd b7       	in	r28, 0x3d	; 61
    3608:	de b7       	in	r29, 0x3e	; 62
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    360a:	84 e0       	ldi	r24, 0x04	; 4
    360c:	93 e2       	ldi	r25, 0x23	; 35
    360e:	20 e6       	ldi	r18, 0x60	; 96
    3610:	30 e0       	ldi	r19, 0x00	; 0
    3612:	e5 eb       	ldi	r30, 0xB5	; 181
    3614:	f6 e0       	ldi	r31, 0x06	; 6
    3616:	b9 01       	movw	r22, r18
    3618:	45 e5       	ldi	r20, 0x55	; 85
    361a:	50 e0       	ldi	r21, 0x00	; 0
    361c:	20 e0       	ldi	r18, 0x00	; 0
    361e:	30 e0       	ldi	r19, 0x00	; 0
    3620:	00 e0       	ldi	r16, 0x00	; 0
    3622:	7f 01       	movw	r14, r30
    3624:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <xTaskCreate>
    3628:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
        {
            if( xReturn == pdPASS )
    362a:	89 81       	ldd	r24, Y+1	; 0x01
    362c:	81 30       	cpi	r24, 0x01	; 1
    362e:	19 f4       	brne	.+6      	; 0x3636 <vTaskStartScheduler+0x3c>
            {
                xReturn = xTimerCreateTimerTask();
    3630:	0e 94 e3 2b 	call	0x57c6	; 0x57c6 <xTimerCreateTimerTask>
    3634:	89 83       	std	Y+1, r24	; 0x01
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    3636:	89 81       	ldd	r24, Y+1	; 0x01
    3638:	81 30       	cpi	r24, 0x01	; 1
    363a:	81 f4       	brne	.+32     	; 0x365c <vTaskStartScheduler+0x62>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    363c:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    363e:	8f ef       	ldi	r24, 0xFF	; 255
    3640:	9f ef       	ldi	r25, 0xFF	; 255
    3642:	90 93 b4 06 	sts	0x06B4, r25
    3646:	80 93 b3 06 	sts	0x06B3, r24
        xSchedulerRunning = pdTRUE;
    364a:	81 e0       	ldi	r24, 0x01	; 1
    364c:	80 93 ad 06 	sts	0x06AD, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    3650:	10 92 ab 06 	sts	0x06AB, r1
    3654:	10 92 aa 06 	sts	0x06AA, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    3658:	0e 94 4c 02 	call	0x498	; 0x498 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    365c:	80 91 8a 00 	lds	r24, 0x008A
}
    3660:	0f 90       	pop	r0
    3662:	0f 90       	pop	r0
    3664:	cf 91       	pop	r28
    3666:	df 91       	pop	r29
    3668:	0f 91       	pop	r16
    366a:	ff 90       	pop	r15
    366c:	ef 90       	pop	r14
    366e:	08 95       	ret

00003670 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3670:	df 93       	push	r29
    3672:	cf 93       	push	r28
    3674:	cd b7       	in	r28, 0x3d	; 61
    3676:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    3678:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    367a:	10 92 ad 06 	sts	0x06AD, r1
    vPortEndScheduler();
    367e:	0e 94 81 02 	call	0x502	; 0x502 <vPortEndScheduler>
}
    3682:	cf 91       	pop	r28
    3684:	df 91       	pop	r29
    3686:	08 95       	ret

00003688 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3688:	df 93       	push	r29
    368a:	cf 93       	push	r28
    368c:	cd b7       	in	r28, 0x3d	; 61
    368e:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    3690:	80 91 b7 06 	lds	r24, 0x06B7
    3694:	8f 5f       	subi	r24, 0xFF	; 255
    3696:	80 93 b7 06 	sts	0x06B7, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    369a:	cf 91       	pop	r28
    369c:	df 91       	pop	r29
    369e:	08 95       	ret

000036a0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    36a0:	df 93       	push	r29
    36a2:	cf 93       	push	r28
    36a4:	cd b7       	in	r28, 0x3d	; 61
    36a6:	de b7       	in	r29, 0x3e	; 62
    36a8:	2b 97       	sbiw	r28, 0x0b	; 11
    36aa:	0f b6       	in	r0, 0x3f	; 63
    36ac:	f8 94       	cli
    36ae:	de bf       	out	0x3e, r29	; 62
    36b0:	0f be       	out	0x3f, r0	; 63
    36b2:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    36b4:	1b 86       	std	Y+11, r1	; 0x0b
    36b6:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    36b8:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    36ba:	0f b6       	in	r0, 0x3f	; 63
    36bc:	f8 94       	cli
    36be:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    36c0:	80 91 b7 06 	lds	r24, 0x06B7
    36c4:	81 50       	subi	r24, 0x01	; 1
    36c6:	80 93 b7 06 	sts	0x06B7, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    36ca:	80 91 b7 06 	lds	r24, 0x06B7
    36ce:	88 23       	and	r24, r24
    36d0:	09 f0       	breq	.+2      	; 0x36d4 <xTaskResumeAll+0x34>
    36d2:	2a c1       	rjmp	.+596    	; 0x3928 <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    36d4:	80 91 a9 06 	lds	r24, 0x06A9
    36d8:	88 23       	and	r24, r24
    36da:	09 f4       	brne	.+2      	; 0x36de <xTaskResumeAll+0x3e>
    36dc:	25 c1       	rjmp	.+586    	; 0x3928 <xTaskResumeAll+0x288>
    36de:	f3 c0       	rjmp	.+486    	; 0x38c6 <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    36e0:	e0 91 f7 06 	lds	r30, 0x06F7
    36e4:	f0 91 f8 06 	lds	r31, 0x06F8
    36e8:	86 81       	ldd	r24, Z+6	; 0x06
    36ea:	97 81       	ldd	r25, Z+7	; 0x07
    36ec:	9b 87       	std	Y+11, r25	; 0x0b
    36ee:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    36f0:	ea 85       	ldd	r30, Y+10	; 0x0a
    36f2:	fb 85       	ldd	r31, Y+11	; 0x0b
    36f4:	84 89       	ldd	r24, Z+20	; 0x14
    36f6:	95 89       	ldd	r25, Z+21	; 0x15
    36f8:	98 87       	std	Y+8, r25	; 0x08
    36fa:	8f 83       	std	Y+7, r24	; 0x07
    36fc:	ea 85       	ldd	r30, Y+10	; 0x0a
    36fe:	fb 85       	ldd	r31, Y+11	; 0x0b
    3700:	a6 85       	ldd	r26, Z+14	; 0x0e
    3702:	b7 85       	ldd	r27, Z+15	; 0x0f
    3704:	ea 85       	ldd	r30, Y+10	; 0x0a
    3706:	fb 85       	ldd	r31, Y+11	; 0x0b
    3708:	80 89       	ldd	r24, Z+16	; 0x10
    370a:	91 89       	ldd	r25, Z+17	; 0x11
    370c:	15 96       	adiw	r26, 0x05	; 5
    370e:	9c 93       	st	X, r25
    3710:	8e 93       	st	-X, r24
    3712:	14 97       	sbiw	r26, 0x04	; 4
    3714:	ea 85       	ldd	r30, Y+10	; 0x0a
    3716:	fb 85       	ldd	r31, Y+11	; 0x0b
    3718:	a0 89       	ldd	r26, Z+16	; 0x10
    371a:	b1 89       	ldd	r27, Z+17	; 0x11
    371c:	ea 85       	ldd	r30, Y+10	; 0x0a
    371e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3720:	86 85       	ldd	r24, Z+14	; 0x0e
    3722:	97 85       	ldd	r25, Z+15	; 0x0f
    3724:	13 96       	adiw	r26, 0x03	; 3
    3726:	9c 93       	st	X, r25
    3728:	8e 93       	st	-X, r24
    372a:	12 97       	sbiw	r26, 0x02	; 2
    372c:	ef 81       	ldd	r30, Y+7	; 0x07
    372e:	f8 85       	ldd	r31, Y+8	; 0x08
    3730:	21 81       	ldd	r18, Z+1	; 0x01
    3732:	32 81       	ldd	r19, Z+2	; 0x02
    3734:	8a 85       	ldd	r24, Y+10	; 0x0a
    3736:	9b 85       	ldd	r25, Y+11	; 0x0b
    3738:	0c 96       	adiw	r24, 0x0c	; 12
    373a:	28 17       	cp	r18, r24
    373c:	39 07       	cpc	r19, r25
    373e:	41 f4       	brne	.+16     	; 0x3750 <xTaskResumeAll+0xb0>
    3740:	ea 85       	ldd	r30, Y+10	; 0x0a
    3742:	fb 85       	ldd	r31, Y+11	; 0x0b
    3744:	80 89       	ldd	r24, Z+16	; 0x10
    3746:	91 89       	ldd	r25, Z+17	; 0x11
    3748:	ef 81       	ldd	r30, Y+7	; 0x07
    374a:	f8 85       	ldd	r31, Y+8	; 0x08
    374c:	92 83       	std	Z+2, r25	; 0x02
    374e:	81 83       	std	Z+1, r24	; 0x01
    3750:	ea 85       	ldd	r30, Y+10	; 0x0a
    3752:	fb 85       	ldd	r31, Y+11	; 0x0b
    3754:	15 8a       	std	Z+21, r1	; 0x15
    3756:	14 8a       	std	Z+20, r1	; 0x14
    3758:	ef 81       	ldd	r30, Y+7	; 0x07
    375a:	f8 85       	ldd	r31, Y+8	; 0x08
    375c:	80 81       	ld	r24, Z
    375e:	81 50       	subi	r24, 0x01	; 1
    3760:	ef 81       	ldd	r30, Y+7	; 0x07
    3762:	f8 85       	ldd	r31, Y+8	; 0x08
    3764:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3766:	ea 85       	ldd	r30, Y+10	; 0x0a
    3768:	fb 85       	ldd	r31, Y+11	; 0x0b
    376a:	82 85       	ldd	r24, Z+10	; 0x0a
    376c:	93 85       	ldd	r25, Z+11	; 0x0b
    376e:	9e 83       	std	Y+6, r25	; 0x06
    3770:	8d 83       	std	Y+5, r24	; 0x05
    3772:	ea 85       	ldd	r30, Y+10	; 0x0a
    3774:	fb 85       	ldd	r31, Y+11	; 0x0b
    3776:	a4 81       	ldd	r26, Z+4	; 0x04
    3778:	b5 81       	ldd	r27, Z+5	; 0x05
    377a:	ea 85       	ldd	r30, Y+10	; 0x0a
    377c:	fb 85       	ldd	r31, Y+11	; 0x0b
    377e:	86 81       	ldd	r24, Z+6	; 0x06
    3780:	97 81       	ldd	r25, Z+7	; 0x07
    3782:	15 96       	adiw	r26, 0x05	; 5
    3784:	9c 93       	st	X, r25
    3786:	8e 93       	st	-X, r24
    3788:	14 97       	sbiw	r26, 0x04	; 4
    378a:	ea 85       	ldd	r30, Y+10	; 0x0a
    378c:	fb 85       	ldd	r31, Y+11	; 0x0b
    378e:	a6 81       	ldd	r26, Z+6	; 0x06
    3790:	b7 81       	ldd	r27, Z+7	; 0x07
    3792:	ea 85       	ldd	r30, Y+10	; 0x0a
    3794:	fb 85       	ldd	r31, Y+11	; 0x0b
    3796:	84 81       	ldd	r24, Z+4	; 0x04
    3798:	95 81       	ldd	r25, Z+5	; 0x05
    379a:	13 96       	adiw	r26, 0x03	; 3
    379c:	9c 93       	st	X, r25
    379e:	8e 93       	st	-X, r24
    37a0:	12 97       	sbiw	r26, 0x02	; 2
    37a2:	ed 81       	ldd	r30, Y+5	; 0x05
    37a4:	fe 81       	ldd	r31, Y+6	; 0x06
    37a6:	21 81       	ldd	r18, Z+1	; 0x01
    37a8:	32 81       	ldd	r19, Z+2	; 0x02
    37aa:	8a 85       	ldd	r24, Y+10	; 0x0a
    37ac:	9b 85       	ldd	r25, Y+11	; 0x0b
    37ae:	02 96       	adiw	r24, 0x02	; 2
    37b0:	28 17       	cp	r18, r24
    37b2:	39 07       	cpc	r19, r25
    37b4:	41 f4       	brne	.+16     	; 0x37c6 <xTaskResumeAll+0x126>
    37b6:	ea 85       	ldd	r30, Y+10	; 0x0a
    37b8:	fb 85       	ldd	r31, Y+11	; 0x0b
    37ba:	86 81       	ldd	r24, Z+6	; 0x06
    37bc:	97 81       	ldd	r25, Z+7	; 0x07
    37be:	ed 81       	ldd	r30, Y+5	; 0x05
    37c0:	fe 81       	ldd	r31, Y+6	; 0x06
    37c2:	92 83       	std	Z+2, r25	; 0x02
    37c4:	81 83       	std	Z+1, r24	; 0x01
    37c6:	ea 85       	ldd	r30, Y+10	; 0x0a
    37c8:	fb 85       	ldd	r31, Y+11	; 0x0b
    37ca:	13 86       	std	Z+11, r1	; 0x0b
    37cc:	12 86       	std	Z+10, r1	; 0x0a
    37ce:	ed 81       	ldd	r30, Y+5	; 0x05
    37d0:	fe 81       	ldd	r31, Y+6	; 0x06
    37d2:	80 81       	ld	r24, Z
    37d4:	81 50       	subi	r24, 0x01	; 1
    37d6:	ed 81       	ldd	r30, Y+5	; 0x05
    37d8:	fe 81       	ldd	r31, Y+6	; 0x06
    37da:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    37dc:	ea 85       	ldd	r30, Y+10	; 0x0a
    37de:	fb 85       	ldd	r31, Y+11	; 0x0b
    37e0:	96 89       	ldd	r25, Z+22	; 0x16
    37e2:	80 91 ac 06 	lds	r24, 0x06AC
    37e6:	89 17       	cp	r24, r25
    37e8:	28 f4       	brcc	.+10     	; 0x37f4 <xTaskResumeAll+0x154>
    37ea:	ea 85       	ldd	r30, Y+10	; 0x0a
    37ec:	fb 85       	ldd	r31, Y+11	; 0x0b
    37ee:	86 89       	ldd	r24, Z+22	; 0x16
    37f0:	80 93 ac 06 	sts	0x06AC, r24
    37f4:	ea 85       	ldd	r30, Y+10	; 0x0a
    37f6:	fb 85       	ldd	r31, Y+11	; 0x0b
    37f8:	86 89       	ldd	r24, Z+22	; 0x16
    37fa:	28 2f       	mov	r18, r24
    37fc:	30 e0       	ldi	r19, 0x00	; 0
    37fe:	c9 01       	movw	r24, r18
    3800:	88 0f       	add	r24, r24
    3802:	99 1f       	adc	r25, r25
    3804:	88 0f       	add	r24, r24
    3806:	99 1f       	adc	r25, r25
    3808:	88 0f       	add	r24, r24
    380a:	99 1f       	adc	r25, r25
    380c:	82 0f       	add	r24, r18
    380e:	93 1f       	adc	r25, r19
    3810:	fc 01       	movw	r30, r24
    3812:	e8 54       	subi	r30, 0x48	; 72
    3814:	f9 4f       	sbci	r31, 0xF9	; 249
    3816:	81 81       	ldd	r24, Z+1	; 0x01
    3818:	92 81       	ldd	r25, Z+2	; 0x02
    381a:	9c 83       	std	Y+4, r25	; 0x04
    381c:	8b 83       	std	Y+3, r24	; 0x03
    381e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3820:	fb 85       	ldd	r31, Y+11	; 0x0b
    3822:	8b 81       	ldd	r24, Y+3	; 0x03
    3824:	9c 81       	ldd	r25, Y+4	; 0x04
    3826:	95 83       	std	Z+5, r25	; 0x05
    3828:	84 83       	std	Z+4, r24	; 0x04
    382a:	eb 81       	ldd	r30, Y+3	; 0x03
    382c:	fc 81       	ldd	r31, Y+4	; 0x04
    382e:	84 81       	ldd	r24, Z+4	; 0x04
    3830:	95 81       	ldd	r25, Z+5	; 0x05
    3832:	ea 85       	ldd	r30, Y+10	; 0x0a
    3834:	fb 85       	ldd	r31, Y+11	; 0x0b
    3836:	97 83       	std	Z+7, r25	; 0x07
    3838:	86 83       	std	Z+6, r24	; 0x06
    383a:	eb 81       	ldd	r30, Y+3	; 0x03
    383c:	fc 81       	ldd	r31, Y+4	; 0x04
    383e:	04 80       	ldd	r0, Z+4	; 0x04
    3840:	f5 81       	ldd	r31, Z+5	; 0x05
    3842:	e0 2d       	mov	r30, r0
    3844:	8a 85       	ldd	r24, Y+10	; 0x0a
    3846:	9b 85       	ldd	r25, Y+11	; 0x0b
    3848:	02 96       	adiw	r24, 0x02	; 2
    384a:	93 83       	std	Z+3, r25	; 0x03
    384c:	82 83       	std	Z+2, r24	; 0x02
    384e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3850:	9b 85       	ldd	r25, Y+11	; 0x0b
    3852:	02 96       	adiw	r24, 0x02	; 2
    3854:	eb 81       	ldd	r30, Y+3	; 0x03
    3856:	fc 81       	ldd	r31, Y+4	; 0x04
    3858:	95 83       	std	Z+5, r25	; 0x05
    385a:	84 83       	std	Z+4, r24	; 0x04
    385c:	ea 85       	ldd	r30, Y+10	; 0x0a
    385e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3860:	86 89       	ldd	r24, Z+22	; 0x16
    3862:	28 2f       	mov	r18, r24
    3864:	30 e0       	ldi	r19, 0x00	; 0
    3866:	c9 01       	movw	r24, r18
    3868:	88 0f       	add	r24, r24
    386a:	99 1f       	adc	r25, r25
    386c:	88 0f       	add	r24, r24
    386e:	99 1f       	adc	r25, r25
    3870:	88 0f       	add	r24, r24
    3872:	99 1f       	adc	r25, r25
    3874:	82 0f       	add	r24, r18
    3876:	93 1f       	adc	r25, r19
    3878:	88 54       	subi	r24, 0x48	; 72
    387a:	99 4f       	sbci	r25, 0xF9	; 249
    387c:	ea 85       	ldd	r30, Y+10	; 0x0a
    387e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3880:	93 87       	std	Z+11, r25	; 0x0b
    3882:	82 87       	std	Z+10, r24	; 0x0a
    3884:	ea 85       	ldd	r30, Y+10	; 0x0a
    3886:	fb 85       	ldd	r31, Y+11	; 0x0b
    3888:	86 89       	ldd	r24, Z+22	; 0x16
    388a:	28 2f       	mov	r18, r24
    388c:	30 e0       	ldi	r19, 0x00	; 0
    388e:	c9 01       	movw	r24, r18
    3890:	88 0f       	add	r24, r24
    3892:	99 1f       	adc	r25, r25
    3894:	88 0f       	add	r24, r24
    3896:	99 1f       	adc	r25, r25
    3898:	88 0f       	add	r24, r24
    389a:	99 1f       	adc	r25, r25
    389c:	82 0f       	add	r24, r18
    389e:	93 1f       	adc	r25, r19
    38a0:	fc 01       	movw	r30, r24
    38a2:	e8 54       	subi	r30, 0x48	; 72
    38a4:	f9 4f       	sbci	r31, 0xF9	; 249
    38a6:	80 81       	ld	r24, Z
    38a8:	8f 5f       	subi	r24, 0xFF	; 255
    38aa:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    38ac:	ea 85       	ldd	r30, Y+10	; 0x0a
    38ae:	fb 85       	ldd	r31, Y+11	; 0x0b
    38b0:	96 89       	ldd	r25, Z+22	; 0x16
    38b2:	e0 91 a6 06 	lds	r30, 0x06A6
    38b6:	f0 91 a7 06 	lds	r31, 0x06A7
    38ba:	86 89       	ldd	r24, Z+22	; 0x16
    38bc:	98 17       	cp	r25, r24
    38be:	18 f0       	brcs	.+6      	; 0x38c6 <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    38c0:	81 e0       	ldi	r24, 0x01	; 1
    38c2:	80 93 b0 06 	sts	0x06B0, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    38c6:	80 91 f2 06 	lds	r24, 0x06F2
    38ca:	88 23       	and	r24, r24
    38cc:	09 f0       	breq	.+2      	; 0x38d0 <xTaskResumeAll+0x230>
    38ce:	08 cf       	rjmp	.-496    	; 0x36e0 <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    38d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    38d2:	9b 85       	ldd	r25, Y+11	; 0x0b
    38d4:	00 97       	sbiw	r24, 0x00	; 0
    38d6:	11 f0       	breq	.+4      	; 0x38dc <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    38d8:	0e 94 96 23 	call	0x472c	; 0x472c <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    38dc:	80 91 ae 06 	lds	r24, 0x06AE
    38e0:	90 91 af 06 	lds	r25, 0x06AF
    38e4:	9a 83       	std	Y+2, r25	; 0x02
    38e6:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    38e8:	89 81       	ldd	r24, Y+1	; 0x01
    38ea:	9a 81       	ldd	r25, Y+2	; 0x02
    38ec:	00 97       	sbiw	r24, 0x00	; 0
    38ee:	a1 f0       	breq	.+40     	; 0x3918 <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    38f0:	0e 94 1d 1d 	call	0x3a3a	; 0x3a3a <xTaskIncrementTick>
    38f4:	88 23       	and	r24, r24
    38f6:	19 f0       	breq	.+6      	; 0x38fe <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    38f8:	81 e0       	ldi	r24, 0x01	; 1
    38fa:	80 93 b0 06 	sts	0x06B0, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    38fe:	89 81       	ldd	r24, Y+1	; 0x01
    3900:	9a 81       	ldd	r25, Y+2	; 0x02
    3902:	01 97       	sbiw	r24, 0x01	; 1
    3904:	9a 83       	std	Y+2, r25	; 0x02
    3906:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    3908:	89 81       	ldd	r24, Y+1	; 0x01
    390a:	9a 81       	ldd	r25, Y+2	; 0x02
    390c:	00 97       	sbiw	r24, 0x00	; 0
    390e:	81 f7       	brne	.-32     	; 0x38f0 <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    3910:	10 92 af 06 	sts	0x06AF, r1
    3914:	10 92 ae 06 	sts	0x06AE, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    3918:	80 91 b0 06 	lds	r24, 0x06B0
    391c:	88 23       	and	r24, r24
    391e:	21 f0       	breq	.+8      	; 0x3928 <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    3920:	81 e0       	ldi	r24, 0x01	; 1
    3922:	89 87       	std	Y+9, r24	; 0x09
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    3924:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    3928:	0f 90       	pop	r0
    392a:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    392c:	89 85       	ldd	r24, Y+9	; 0x09
}
    392e:	2b 96       	adiw	r28, 0x0b	; 11
    3930:	0f b6       	in	r0, 0x3f	; 63
    3932:	f8 94       	cli
    3934:	de bf       	out	0x3e, r29	; 62
    3936:	0f be       	out	0x3f, r0	; 63
    3938:	cd bf       	out	0x3d, r28	; 61
    393a:	cf 91       	pop	r28
    393c:	df 91       	pop	r29
    393e:	08 95       	ret

00003940 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3940:	df 93       	push	r29
    3942:	cf 93       	push	r28
    3944:	00 d0       	rcall	.+0      	; 0x3946 <xTaskGetTickCount+0x6>
    3946:	cd b7       	in	r28, 0x3d	; 61
    3948:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    394a:	0f b6       	in	r0, 0x3f	; 63
    394c:	f8 94       	cli
    394e:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    3950:	80 91 aa 06 	lds	r24, 0x06AA
    3954:	90 91 ab 06 	lds	r25, 0x06AB
    3958:	9a 83       	std	Y+2, r25	; 0x02
    395a:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    395c:	0f 90       	pop	r0
    395e:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    3960:	89 81       	ldd	r24, Y+1	; 0x01
    3962:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3964:	0f 90       	pop	r0
    3966:	0f 90       	pop	r0
    3968:	cf 91       	pop	r28
    396a:	df 91       	pop	r29
    396c:	08 95       	ret

0000396e <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    396e:	df 93       	push	r29
    3970:	cf 93       	push	r28
    3972:	00 d0       	rcall	.+0      	; 0x3974 <xTaskGetTickCountFromISR+0x6>
    3974:	0f 92       	push	r0
    3976:	cd b7       	in	r28, 0x3d	; 61
    3978:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    397a:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    397c:	80 91 aa 06 	lds	r24, 0x06AA
    3980:	90 91 ab 06 	lds	r25, 0x06AB
    3984:	9b 83       	std	Y+3, r25	; 0x03
    3986:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3988:	8a 81       	ldd	r24, Y+2	; 0x02
    398a:	9b 81       	ldd	r25, Y+3	; 0x03
}
    398c:	0f 90       	pop	r0
    398e:	0f 90       	pop	r0
    3990:	0f 90       	pop	r0
    3992:	cf 91       	pop	r28
    3994:	df 91       	pop	r29
    3996:	08 95       	ret

00003998 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3998:	df 93       	push	r29
    399a:	cf 93       	push	r28
    399c:	cd b7       	in	r28, 0x3d	; 61
    399e:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    39a0:	80 91 a9 06 	lds	r24, 0x06A9
}
    39a4:	cf 91       	pop	r28
    39a6:	df 91       	pop	r29
    39a8:	08 95       	ret

000039aa <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    39aa:	df 93       	push	r29
    39ac:	cf 93       	push	r28
    39ae:	00 d0       	rcall	.+0      	; 0x39b0 <pcTaskGetName+0x6>
    39b0:	00 d0       	rcall	.+0      	; 0x39b2 <pcTaskGetName+0x8>
    39b2:	00 d0       	rcall	.+0      	; 0x39b4 <pcTaskGetName+0xa>
    39b4:	cd b7       	in	r28, 0x3d	; 61
    39b6:	de b7       	in	r29, 0x3e	; 62
    39b8:	9c 83       	std	Y+4, r25	; 0x04
    39ba:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    39bc:	8b 81       	ldd	r24, Y+3	; 0x03
    39be:	9c 81       	ldd	r25, Y+4	; 0x04
    39c0:	00 97       	sbiw	r24, 0x00	; 0
    39c2:	39 f4       	brne	.+14     	; 0x39d2 <pcTaskGetName+0x28>
    39c4:	80 91 a6 06 	lds	r24, 0x06A6
    39c8:	90 91 a7 06 	lds	r25, 0x06A7
    39cc:	9e 83       	std	Y+6, r25	; 0x06
    39ce:	8d 83       	std	Y+5, r24	; 0x05
    39d0:	04 c0       	rjmp	.+8      	; 0x39da <pcTaskGetName+0x30>
    39d2:	8b 81       	ldd	r24, Y+3	; 0x03
    39d4:	9c 81       	ldd	r25, Y+4	; 0x04
    39d6:	9e 83       	std	Y+6, r25	; 0x06
    39d8:	8d 83       	std	Y+5, r24	; 0x05
    39da:	8d 81       	ldd	r24, Y+5	; 0x05
    39dc:	9e 81       	ldd	r25, Y+6	; 0x06
    39de:	9a 83       	std	Y+2, r25	; 0x02
    39e0:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    39e2:	89 81       	ldd	r24, Y+1	; 0x01
    39e4:	9a 81       	ldd	r25, Y+2	; 0x02
    39e6:	49 96       	adiw	r24, 0x19	; 25
}
    39e8:	26 96       	adiw	r28, 0x06	; 6
    39ea:	0f b6       	in	r0, 0x3f	; 63
    39ec:	f8 94       	cli
    39ee:	de bf       	out	0x3e, r29	; 62
    39f0:	0f be       	out	0x3f, r0	; 63
    39f2:	cd bf       	out	0x3d, r28	; 61
    39f4:	cf 91       	pop	r28
    39f6:	df 91       	pop	r29
    39f8:	08 95       	ret

000039fa <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    39fa:	df 93       	push	r29
    39fc:	cf 93       	push	r28
    39fe:	00 d0       	rcall	.+0      	; 0x3a00 <xTaskCatchUpTicks+0x6>
    3a00:	0f 92       	push	r0
    3a02:	cd b7       	in	r28, 0x3d	; 61
    3a04:	de b7       	in	r29, 0x3e	; 62
    3a06:	9b 83       	std	Y+3, r25	; 0x03
    3a08:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    3a0a:	0e 94 44 1b 	call	0x3688	; 0x3688 <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
    3a0e:	20 91 ae 06 	lds	r18, 0x06AE
    3a12:	30 91 af 06 	lds	r19, 0x06AF
    3a16:	8a 81       	ldd	r24, Y+2	; 0x02
    3a18:	9b 81       	ldd	r25, Y+3	; 0x03
    3a1a:	82 0f       	add	r24, r18
    3a1c:	93 1f       	adc	r25, r19
    3a1e:	90 93 af 06 	sts	0x06AF, r25
    3a22:	80 93 ae 06 	sts	0x06AE, r24
    xYieldOccurred = xTaskResumeAll();
    3a26:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>
    3a2a:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    3a2c:	89 81       	ldd	r24, Y+1	; 0x01
}
    3a2e:	0f 90       	pop	r0
    3a30:	0f 90       	pop	r0
    3a32:	0f 90       	pop	r0
    3a34:	cf 91       	pop	r28
    3a36:	df 91       	pop	r29
    3a38:	08 95       	ret

00003a3a <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3a3a:	df 93       	push	r29
    3a3c:	cf 93       	push	r28
    3a3e:	cd b7       	in	r28, 0x3d	; 61
    3a40:	de b7       	in	r29, 0x3e	; 62
    3a42:	2f 97       	sbiw	r28, 0x0f	; 15
    3a44:	0f b6       	in	r0, 0x3f	; 63
    3a46:	f8 94       	cli
    3a48:	de bf       	out	0x3e, r29	; 62
    3a4a:	0f be       	out	0x3f, r0	; 63
    3a4c:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    3a4e:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3a50:	80 91 b7 06 	lds	r24, 0x06B7
    3a54:	88 23       	and	r24, r24
    3a56:	09 f0       	breq	.+2      	; 0x3a5a <xTaskIncrementTick+0x20>
    3a58:	74 c1       	rjmp	.+744    	; 0x3d42 <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    3a5a:	80 91 aa 06 	lds	r24, 0x06AA
    3a5e:	90 91 ab 06 	lds	r25, 0x06AB
    3a62:	01 96       	adiw	r24, 0x01	; 1
    3a64:	9a 87       	std	Y+10, r25	; 0x0a
    3a66:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    3a68:	89 85       	ldd	r24, Y+9	; 0x09
    3a6a:	9a 85       	ldd	r25, Y+10	; 0x0a
    3a6c:	90 93 ab 06 	sts	0x06AB, r25
    3a70:	80 93 aa 06 	sts	0x06AA, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    3a74:	89 85       	ldd	r24, Y+9	; 0x09
    3a76:	9a 85       	ldd	r25, Y+10	; 0x0a
    3a78:	00 97       	sbiw	r24, 0x00	; 0
    3a7a:	d9 f4       	brne	.+54     	; 0x3ab2 <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    3a7c:	80 91 ee 06 	lds	r24, 0x06EE
    3a80:	90 91 ef 06 	lds	r25, 0x06EF
    3a84:	98 87       	std	Y+8, r25	; 0x08
    3a86:	8f 83       	std	Y+7, r24	; 0x07
    3a88:	80 91 f0 06 	lds	r24, 0x06F0
    3a8c:	90 91 f1 06 	lds	r25, 0x06F1
    3a90:	90 93 ef 06 	sts	0x06EF, r25
    3a94:	80 93 ee 06 	sts	0x06EE, r24
    3a98:	8f 81       	ldd	r24, Y+7	; 0x07
    3a9a:	98 85       	ldd	r25, Y+8	; 0x08
    3a9c:	90 93 f1 06 	sts	0x06F1, r25
    3aa0:	80 93 f0 06 	sts	0x06F0, r24
    3aa4:	80 91 b1 06 	lds	r24, 0x06B1
    3aa8:	8f 5f       	subi	r24, 0xFF	; 255
    3aaa:	80 93 b1 06 	sts	0x06B1, r24
    3aae:	0e 94 96 23 	call	0x472c	; 0x472c <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    3ab2:	20 91 b3 06 	lds	r18, 0x06B3
    3ab6:	30 91 b4 06 	lds	r19, 0x06B4
    3aba:	89 85       	ldd	r24, Y+9	; 0x09
    3abc:	9a 85       	ldd	r25, Y+10	; 0x0a
    3abe:	82 17       	cp	r24, r18
    3ac0:	93 07       	cpc	r25, r19
    3ac2:	08 f4       	brcc	.+2      	; 0x3ac6 <xTaskIncrementTick+0x8c>
    3ac4:	1f c1       	rjmp	.+574    	; 0x3d04 <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3ac6:	e0 91 ee 06 	lds	r30, 0x06EE
    3aca:	f0 91 ef 06 	lds	r31, 0x06EF
    3ace:	80 81       	ld	r24, Z
    3ad0:	88 23       	and	r24, r24
    3ad2:	39 f4       	brne	.+14     	; 0x3ae2 <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3ad4:	8f ef       	ldi	r24, 0xFF	; 255
    3ad6:	9f ef       	ldi	r25, 0xFF	; 255
    3ad8:	90 93 b4 06 	sts	0x06B4, r25
    3adc:	80 93 b3 06 	sts	0x06B3, r24
    3ae0:	11 c1       	rjmp	.+546    	; 0x3d04 <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3ae2:	e0 91 ee 06 	lds	r30, 0x06EE
    3ae6:	f0 91 ef 06 	lds	r31, 0x06EF
    3aea:	05 80       	ldd	r0, Z+5	; 0x05
    3aec:	f6 81       	ldd	r31, Z+6	; 0x06
    3aee:	e0 2d       	mov	r30, r0
    3af0:	86 81       	ldd	r24, Z+6	; 0x06
    3af2:	97 81       	ldd	r25, Z+7	; 0x07
    3af4:	9f 87       	std	Y+15, r25	; 0x0f
    3af6:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    3af8:	ee 85       	ldd	r30, Y+14	; 0x0e
    3afa:	ff 85       	ldd	r31, Y+15	; 0x0f
    3afc:	82 81       	ldd	r24, Z+2	; 0x02
    3afe:	93 81       	ldd	r25, Z+3	; 0x03
    3b00:	9d 87       	std	Y+13, r25	; 0x0d
    3b02:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    3b04:	29 85       	ldd	r18, Y+9	; 0x09
    3b06:	3a 85       	ldd	r19, Y+10	; 0x0a
    3b08:	8c 85       	ldd	r24, Y+12	; 0x0c
    3b0a:	9d 85       	ldd	r25, Y+13	; 0x0d
    3b0c:	28 17       	cp	r18, r24
    3b0e:	39 07       	cpc	r19, r25
    3b10:	38 f4       	brcc	.+14     	; 0x3b20 <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    3b12:	8c 85       	ldd	r24, Y+12	; 0x0c
    3b14:	9d 85       	ldd	r25, Y+13	; 0x0d
    3b16:	90 93 b4 06 	sts	0x06B4, r25
    3b1a:	80 93 b3 06 	sts	0x06B3, r24
    3b1e:	f2 c0       	rjmp	.+484    	; 0x3d04 <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3b20:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b22:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b24:	82 85       	ldd	r24, Z+10	; 0x0a
    3b26:	93 85       	ldd	r25, Z+11	; 0x0b
    3b28:	9e 83       	std	Y+6, r25	; 0x06
    3b2a:	8d 83       	std	Y+5, r24	; 0x05
    3b2c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b2e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b30:	a4 81       	ldd	r26, Z+4	; 0x04
    3b32:	b5 81       	ldd	r27, Z+5	; 0x05
    3b34:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b36:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b38:	86 81       	ldd	r24, Z+6	; 0x06
    3b3a:	97 81       	ldd	r25, Z+7	; 0x07
    3b3c:	15 96       	adiw	r26, 0x05	; 5
    3b3e:	9c 93       	st	X, r25
    3b40:	8e 93       	st	-X, r24
    3b42:	14 97       	sbiw	r26, 0x04	; 4
    3b44:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b46:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b48:	a6 81       	ldd	r26, Z+6	; 0x06
    3b4a:	b7 81       	ldd	r27, Z+7	; 0x07
    3b4c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b4e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b50:	84 81       	ldd	r24, Z+4	; 0x04
    3b52:	95 81       	ldd	r25, Z+5	; 0x05
    3b54:	13 96       	adiw	r26, 0x03	; 3
    3b56:	9c 93       	st	X, r25
    3b58:	8e 93       	st	-X, r24
    3b5a:	12 97       	sbiw	r26, 0x02	; 2
    3b5c:	ed 81       	ldd	r30, Y+5	; 0x05
    3b5e:	fe 81       	ldd	r31, Y+6	; 0x06
    3b60:	21 81       	ldd	r18, Z+1	; 0x01
    3b62:	32 81       	ldd	r19, Z+2	; 0x02
    3b64:	8e 85       	ldd	r24, Y+14	; 0x0e
    3b66:	9f 85       	ldd	r25, Y+15	; 0x0f
    3b68:	02 96       	adiw	r24, 0x02	; 2
    3b6a:	28 17       	cp	r18, r24
    3b6c:	39 07       	cpc	r19, r25
    3b6e:	41 f4       	brne	.+16     	; 0x3b80 <xTaskIncrementTick+0x146>
    3b70:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b72:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b74:	86 81       	ldd	r24, Z+6	; 0x06
    3b76:	97 81       	ldd	r25, Z+7	; 0x07
    3b78:	ed 81       	ldd	r30, Y+5	; 0x05
    3b7a:	fe 81       	ldd	r31, Y+6	; 0x06
    3b7c:	92 83       	std	Z+2, r25	; 0x02
    3b7e:	81 83       	std	Z+1, r24	; 0x01
    3b80:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b82:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b84:	13 86       	std	Z+11, r1	; 0x0b
    3b86:	12 86       	std	Z+10, r1	; 0x0a
    3b88:	ed 81       	ldd	r30, Y+5	; 0x05
    3b8a:	fe 81       	ldd	r31, Y+6	; 0x06
    3b8c:	80 81       	ld	r24, Z
    3b8e:	81 50       	subi	r24, 0x01	; 1
    3b90:	ed 81       	ldd	r30, Y+5	; 0x05
    3b92:	fe 81       	ldd	r31, Y+6	; 0x06
    3b94:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3b96:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b98:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b9a:	84 89       	ldd	r24, Z+20	; 0x14
    3b9c:	95 89       	ldd	r25, Z+21	; 0x15
    3b9e:	00 97       	sbiw	r24, 0x00	; 0
    3ba0:	d9 f1       	breq	.+118    	; 0x3c18 <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3ba2:	ee 85       	ldd	r30, Y+14	; 0x0e
    3ba4:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ba6:	84 89       	ldd	r24, Z+20	; 0x14
    3ba8:	95 89       	ldd	r25, Z+21	; 0x15
    3baa:	9c 83       	std	Y+4, r25	; 0x04
    3bac:	8b 83       	std	Y+3, r24	; 0x03
    3bae:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bb0:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bb2:	a6 85       	ldd	r26, Z+14	; 0x0e
    3bb4:	b7 85       	ldd	r27, Z+15	; 0x0f
    3bb6:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bb8:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bba:	80 89       	ldd	r24, Z+16	; 0x10
    3bbc:	91 89       	ldd	r25, Z+17	; 0x11
    3bbe:	15 96       	adiw	r26, 0x05	; 5
    3bc0:	9c 93       	st	X, r25
    3bc2:	8e 93       	st	-X, r24
    3bc4:	14 97       	sbiw	r26, 0x04	; 4
    3bc6:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bc8:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bca:	a0 89       	ldd	r26, Z+16	; 0x10
    3bcc:	b1 89       	ldd	r27, Z+17	; 0x11
    3bce:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bd0:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bd2:	86 85       	ldd	r24, Z+14	; 0x0e
    3bd4:	97 85       	ldd	r25, Z+15	; 0x0f
    3bd6:	13 96       	adiw	r26, 0x03	; 3
    3bd8:	9c 93       	st	X, r25
    3bda:	8e 93       	st	-X, r24
    3bdc:	12 97       	sbiw	r26, 0x02	; 2
    3bde:	eb 81       	ldd	r30, Y+3	; 0x03
    3be0:	fc 81       	ldd	r31, Y+4	; 0x04
    3be2:	21 81       	ldd	r18, Z+1	; 0x01
    3be4:	32 81       	ldd	r19, Z+2	; 0x02
    3be6:	8e 85       	ldd	r24, Y+14	; 0x0e
    3be8:	9f 85       	ldd	r25, Y+15	; 0x0f
    3bea:	0c 96       	adiw	r24, 0x0c	; 12
    3bec:	28 17       	cp	r18, r24
    3bee:	39 07       	cpc	r19, r25
    3bf0:	41 f4       	brne	.+16     	; 0x3c02 <xTaskIncrementTick+0x1c8>
    3bf2:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bf4:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bf6:	80 89       	ldd	r24, Z+16	; 0x10
    3bf8:	91 89       	ldd	r25, Z+17	; 0x11
    3bfa:	eb 81       	ldd	r30, Y+3	; 0x03
    3bfc:	fc 81       	ldd	r31, Y+4	; 0x04
    3bfe:	92 83       	std	Z+2, r25	; 0x02
    3c00:	81 83       	std	Z+1, r24	; 0x01
    3c02:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c04:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c06:	15 8a       	std	Z+21, r1	; 0x15
    3c08:	14 8a       	std	Z+20, r1	; 0x14
    3c0a:	eb 81       	ldd	r30, Y+3	; 0x03
    3c0c:	fc 81       	ldd	r31, Y+4	; 0x04
    3c0e:	80 81       	ld	r24, Z
    3c10:	81 50       	subi	r24, 0x01	; 1
    3c12:	eb 81       	ldd	r30, Y+3	; 0x03
    3c14:	fc 81       	ldd	r31, Y+4	; 0x04
    3c16:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    3c18:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c1a:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c1c:	96 89       	ldd	r25, Z+22	; 0x16
    3c1e:	80 91 ac 06 	lds	r24, 0x06AC
    3c22:	89 17       	cp	r24, r25
    3c24:	28 f4       	brcc	.+10     	; 0x3c30 <xTaskIncrementTick+0x1f6>
    3c26:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c28:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c2a:	86 89       	ldd	r24, Z+22	; 0x16
    3c2c:	80 93 ac 06 	sts	0x06AC, r24
    3c30:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c32:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c34:	86 89       	ldd	r24, Z+22	; 0x16
    3c36:	28 2f       	mov	r18, r24
    3c38:	30 e0       	ldi	r19, 0x00	; 0
    3c3a:	c9 01       	movw	r24, r18
    3c3c:	88 0f       	add	r24, r24
    3c3e:	99 1f       	adc	r25, r25
    3c40:	88 0f       	add	r24, r24
    3c42:	99 1f       	adc	r25, r25
    3c44:	88 0f       	add	r24, r24
    3c46:	99 1f       	adc	r25, r25
    3c48:	82 0f       	add	r24, r18
    3c4a:	93 1f       	adc	r25, r19
    3c4c:	fc 01       	movw	r30, r24
    3c4e:	e8 54       	subi	r30, 0x48	; 72
    3c50:	f9 4f       	sbci	r31, 0xF9	; 249
    3c52:	81 81       	ldd	r24, Z+1	; 0x01
    3c54:	92 81       	ldd	r25, Z+2	; 0x02
    3c56:	9a 83       	std	Y+2, r25	; 0x02
    3c58:	89 83       	std	Y+1, r24	; 0x01
    3c5a:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c5c:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c5e:	89 81       	ldd	r24, Y+1	; 0x01
    3c60:	9a 81       	ldd	r25, Y+2	; 0x02
    3c62:	95 83       	std	Z+5, r25	; 0x05
    3c64:	84 83       	std	Z+4, r24	; 0x04
    3c66:	e9 81       	ldd	r30, Y+1	; 0x01
    3c68:	fa 81       	ldd	r31, Y+2	; 0x02
    3c6a:	84 81       	ldd	r24, Z+4	; 0x04
    3c6c:	95 81       	ldd	r25, Z+5	; 0x05
    3c6e:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c70:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c72:	97 83       	std	Z+7, r25	; 0x07
    3c74:	86 83       	std	Z+6, r24	; 0x06
    3c76:	e9 81       	ldd	r30, Y+1	; 0x01
    3c78:	fa 81       	ldd	r31, Y+2	; 0x02
    3c7a:	04 80       	ldd	r0, Z+4	; 0x04
    3c7c:	f5 81       	ldd	r31, Z+5	; 0x05
    3c7e:	e0 2d       	mov	r30, r0
    3c80:	8e 85       	ldd	r24, Y+14	; 0x0e
    3c82:	9f 85       	ldd	r25, Y+15	; 0x0f
    3c84:	02 96       	adiw	r24, 0x02	; 2
    3c86:	93 83       	std	Z+3, r25	; 0x03
    3c88:	82 83       	std	Z+2, r24	; 0x02
    3c8a:	8e 85       	ldd	r24, Y+14	; 0x0e
    3c8c:	9f 85       	ldd	r25, Y+15	; 0x0f
    3c8e:	02 96       	adiw	r24, 0x02	; 2
    3c90:	e9 81       	ldd	r30, Y+1	; 0x01
    3c92:	fa 81       	ldd	r31, Y+2	; 0x02
    3c94:	95 83       	std	Z+5, r25	; 0x05
    3c96:	84 83       	std	Z+4, r24	; 0x04
    3c98:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c9a:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c9c:	86 89       	ldd	r24, Z+22	; 0x16
    3c9e:	28 2f       	mov	r18, r24
    3ca0:	30 e0       	ldi	r19, 0x00	; 0
    3ca2:	c9 01       	movw	r24, r18
    3ca4:	88 0f       	add	r24, r24
    3ca6:	99 1f       	adc	r25, r25
    3ca8:	88 0f       	add	r24, r24
    3caa:	99 1f       	adc	r25, r25
    3cac:	88 0f       	add	r24, r24
    3cae:	99 1f       	adc	r25, r25
    3cb0:	82 0f       	add	r24, r18
    3cb2:	93 1f       	adc	r25, r19
    3cb4:	88 54       	subi	r24, 0x48	; 72
    3cb6:	99 4f       	sbci	r25, 0xF9	; 249
    3cb8:	ee 85       	ldd	r30, Y+14	; 0x0e
    3cba:	ff 85       	ldd	r31, Y+15	; 0x0f
    3cbc:	93 87       	std	Z+11, r25	; 0x0b
    3cbe:	82 87       	std	Z+10, r24	; 0x0a
    3cc0:	ee 85       	ldd	r30, Y+14	; 0x0e
    3cc2:	ff 85       	ldd	r31, Y+15	; 0x0f
    3cc4:	86 89       	ldd	r24, Z+22	; 0x16
    3cc6:	28 2f       	mov	r18, r24
    3cc8:	30 e0       	ldi	r19, 0x00	; 0
    3cca:	c9 01       	movw	r24, r18
    3ccc:	88 0f       	add	r24, r24
    3cce:	99 1f       	adc	r25, r25
    3cd0:	88 0f       	add	r24, r24
    3cd2:	99 1f       	adc	r25, r25
    3cd4:	88 0f       	add	r24, r24
    3cd6:	99 1f       	adc	r25, r25
    3cd8:	82 0f       	add	r24, r18
    3cda:	93 1f       	adc	r25, r19
    3cdc:	fc 01       	movw	r30, r24
    3cde:	e8 54       	subi	r30, 0x48	; 72
    3ce0:	f9 4f       	sbci	r31, 0xF9	; 249
    3ce2:	80 81       	ld	r24, Z
    3ce4:	8f 5f       	subi	r24, 0xFF	; 255
    3ce6:	80 83       	st	Z, r24
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3ce8:	ee 85       	ldd	r30, Y+14	; 0x0e
    3cea:	ff 85       	ldd	r31, Y+15	; 0x0f
    3cec:	96 89       	ldd	r25, Z+22	; 0x16
    3cee:	e0 91 a6 06 	lds	r30, 0x06A6
    3cf2:	f0 91 a7 06 	lds	r31, 0x06A7
    3cf6:	86 89       	ldd	r24, Z+22	; 0x16
    3cf8:	98 17       	cp	r25, r24
    3cfa:	08 f4       	brcc	.+2      	; 0x3cfe <xTaskIncrementTick+0x2c4>
    3cfc:	e4 ce       	rjmp	.-568    	; 0x3ac6 <xTaskIncrementTick+0x8c>
                            {
                                xSwitchRequired = pdTRUE;
    3cfe:	81 e0       	ldi	r24, 0x01	; 1
    3d00:	8b 87       	std	Y+11, r24	; 0x0b
    3d02:	e1 ce       	rjmp	.-574    	; 0x3ac6 <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3d04:	e0 91 a6 06 	lds	r30, 0x06A6
    3d08:	f0 91 a7 06 	lds	r31, 0x06A7
    3d0c:	86 89       	ldd	r24, Z+22	; 0x16
    3d0e:	28 2f       	mov	r18, r24
    3d10:	30 e0       	ldi	r19, 0x00	; 0
    3d12:	c9 01       	movw	r24, r18
    3d14:	88 0f       	add	r24, r24
    3d16:	99 1f       	adc	r25, r25
    3d18:	88 0f       	add	r24, r24
    3d1a:	99 1f       	adc	r25, r25
    3d1c:	88 0f       	add	r24, r24
    3d1e:	99 1f       	adc	r25, r25
    3d20:	82 0f       	add	r24, r18
    3d22:	93 1f       	adc	r25, r19
    3d24:	fc 01       	movw	r30, r24
    3d26:	e8 54       	subi	r30, 0x48	; 72
    3d28:	f9 4f       	sbci	r31, 0xF9	; 249
    3d2a:	80 81       	ld	r24, Z
    3d2c:	82 30       	cpi	r24, 0x02	; 2
    3d2e:	10 f0       	brcs	.+4      	; 0x3d34 <xTaskIncrementTick+0x2fa>
                {
                    xSwitchRequired = pdTRUE;
    3d30:	81 e0       	ldi	r24, 0x01	; 1
    3d32:	8b 87       	std	Y+11, r24	; 0x0b
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    3d34:	80 91 b0 06 	lds	r24, 0x06B0
    3d38:	88 23       	and	r24, r24
    3d3a:	61 f0       	breq	.+24     	; 0x3d54 <xTaskIncrementTick+0x31a>
                {
                    xSwitchRequired = pdTRUE;
    3d3c:	81 e0       	ldi	r24, 0x01	; 1
    3d3e:	8b 87       	std	Y+11, r24	; 0x0b
    3d40:	09 c0       	rjmp	.+18     	; 0x3d54 <xTaskIncrementTick+0x31a>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    3d42:	80 91 ae 06 	lds	r24, 0x06AE
    3d46:	90 91 af 06 	lds	r25, 0x06AF
    3d4a:	01 96       	adiw	r24, 0x01	; 1
    3d4c:	90 93 af 06 	sts	0x06AF, r25
    3d50:	80 93 ae 06 	sts	0x06AE, r24
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
    3d54:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    3d56:	2f 96       	adiw	r28, 0x0f	; 15
    3d58:	0f b6       	in	r0, 0x3f	; 63
    3d5a:	f8 94       	cli
    3d5c:	de bf       	out	0x3e, r29	; 62
    3d5e:	0f be       	out	0x3f, r0	; 63
    3d60:	cd bf       	out	0x3d, r28	; 61
    3d62:	cf 91       	pop	r28
    3d64:	df 91       	pop	r29
    3d66:	08 95       	ret

00003d68 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3d68:	df 93       	push	r29
    3d6a:	cf 93       	push	r28
    3d6c:	00 d0       	rcall	.+0      	; 0x3d6e <vTaskSwitchContext+0x6>
    3d6e:	0f 92       	push	r0
    3d70:	cd b7       	in	r28, 0x3d	; 61
    3d72:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3d74:	80 91 b7 06 	lds	r24, 0x06B7
    3d78:	88 23       	and	r24, r24
    3d7a:	21 f0       	breq	.+8      	; 0x3d84 <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    3d7c:	81 e0       	ldi	r24, 0x01	; 1
    3d7e:	80 93 b0 06 	sts	0x06B0, r24
    3d82:	59 c0       	rjmp	.+178    	; 0x3e36 <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    3d84:	10 92 b0 06 	sts	0x06B0, r1
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3d88:	80 91 ac 06 	lds	r24, 0x06AC
    3d8c:	8b 83       	std	Y+3, r24	; 0x03
    3d8e:	03 c0       	rjmp	.+6      	; 0x3d96 <vTaskSwitchContext+0x2e>
    3d90:	8b 81       	ldd	r24, Y+3	; 0x03
    3d92:	81 50       	subi	r24, 0x01	; 1
    3d94:	8b 83       	std	Y+3, r24	; 0x03
    3d96:	8b 81       	ldd	r24, Y+3	; 0x03
    3d98:	28 2f       	mov	r18, r24
    3d9a:	30 e0       	ldi	r19, 0x00	; 0
    3d9c:	c9 01       	movw	r24, r18
    3d9e:	88 0f       	add	r24, r24
    3da0:	99 1f       	adc	r25, r25
    3da2:	88 0f       	add	r24, r24
    3da4:	99 1f       	adc	r25, r25
    3da6:	88 0f       	add	r24, r24
    3da8:	99 1f       	adc	r25, r25
    3daa:	82 0f       	add	r24, r18
    3dac:	93 1f       	adc	r25, r19
    3dae:	fc 01       	movw	r30, r24
    3db0:	e8 54       	subi	r30, 0x48	; 72
    3db2:	f9 4f       	sbci	r31, 0xF9	; 249
    3db4:	80 81       	ld	r24, Z
    3db6:	88 23       	and	r24, r24
    3db8:	59 f3       	breq	.-42     	; 0x3d90 <vTaskSwitchContext+0x28>
    3dba:	8b 81       	ldd	r24, Y+3	; 0x03
    3dbc:	28 2f       	mov	r18, r24
    3dbe:	30 e0       	ldi	r19, 0x00	; 0
    3dc0:	c9 01       	movw	r24, r18
    3dc2:	88 0f       	add	r24, r24
    3dc4:	99 1f       	adc	r25, r25
    3dc6:	88 0f       	add	r24, r24
    3dc8:	99 1f       	adc	r25, r25
    3dca:	88 0f       	add	r24, r24
    3dcc:	99 1f       	adc	r25, r25
    3dce:	82 0f       	add	r24, r18
    3dd0:	93 1f       	adc	r25, r19
    3dd2:	88 54       	subi	r24, 0x48	; 72
    3dd4:	99 4f       	sbci	r25, 0xF9	; 249
    3dd6:	9a 83       	std	Y+2, r25	; 0x02
    3dd8:	89 83       	std	Y+1, r24	; 0x01
    3dda:	e9 81       	ldd	r30, Y+1	; 0x01
    3ddc:	fa 81       	ldd	r31, Y+2	; 0x02
    3dde:	01 80       	ldd	r0, Z+1	; 0x01
    3de0:	f2 81       	ldd	r31, Z+2	; 0x02
    3de2:	e0 2d       	mov	r30, r0
    3de4:	82 81       	ldd	r24, Z+2	; 0x02
    3de6:	93 81       	ldd	r25, Z+3	; 0x03
    3de8:	e9 81       	ldd	r30, Y+1	; 0x01
    3dea:	fa 81       	ldd	r31, Y+2	; 0x02
    3dec:	92 83       	std	Z+2, r25	; 0x02
    3dee:	81 83       	std	Z+1, r24	; 0x01
    3df0:	e9 81       	ldd	r30, Y+1	; 0x01
    3df2:	fa 81       	ldd	r31, Y+2	; 0x02
    3df4:	21 81       	ldd	r18, Z+1	; 0x01
    3df6:	32 81       	ldd	r19, Z+2	; 0x02
    3df8:	89 81       	ldd	r24, Y+1	; 0x01
    3dfa:	9a 81       	ldd	r25, Y+2	; 0x02
    3dfc:	03 96       	adiw	r24, 0x03	; 3
    3dfe:	28 17       	cp	r18, r24
    3e00:	39 07       	cpc	r19, r25
    3e02:	59 f4       	brne	.+22     	; 0x3e1a <vTaskSwitchContext+0xb2>
    3e04:	e9 81       	ldd	r30, Y+1	; 0x01
    3e06:	fa 81       	ldd	r31, Y+2	; 0x02
    3e08:	01 80       	ldd	r0, Z+1	; 0x01
    3e0a:	f2 81       	ldd	r31, Z+2	; 0x02
    3e0c:	e0 2d       	mov	r30, r0
    3e0e:	82 81       	ldd	r24, Z+2	; 0x02
    3e10:	93 81       	ldd	r25, Z+3	; 0x03
    3e12:	e9 81       	ldd	r30, Y+1	; 0x01
    3e14:	fa 81       	ldd	r31, Y+2	; 0x02
    3e16:	92 83       	std	Z+2, r25	; 0x02
    3e18:	81 83       	std	Z+1, r24	; 0x01
    3e1a:	e9 81       	ldd	r30, Y+1	; 0x01
    3e1c:	fa 81       	ldd	r31, Y+2	; 0x02
    3e1e:	01 80       	ldd	r0, Z+1	; 0x01
    3e20:	f2 81       	ldd	r31, Z+2	; 0x02
    3e22:	e0 2d       	mov	r30, r0
    3e24:	86 81       	ldd	r24, Z+6	; 0x06
    3e26:	97 81       	ldd	r25, Z+7	; 0x07
    3e28:	90 93 a7 06 	sts	0x06A7, r25
    3e2c:	80 93 a6 06 	sts	0x06A6, r24
    3e30:	8b 81       	ldd	r24, Y+3	; 0x03
    3e32:	80 93 ac 06 	sts	0x06AC, r24
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    3e36:	0f 90       	pop	r0
    3e38:	0f 90       	pop	r0
    3e3a:	0f 90       	pop	r0
    3e3c:	cf 91       	pop	r28
    3e3e:	df 91       	pop	r29
    3e40:	08 95       	ret

00003e42 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    3e42:	df 93       	push	r29
    3e44:	cf 93       	push	r28
    3e46:	00 d0       	rcall	.+0      	; 0x3e48 <vTaskPlaceOnEventList+0x6>
    3e48:	00 d0       	rcall	.+0      	; 0x3e4a <vTaskPlaceOnEventList+0x8>
    3e4a:	cd b7       	in	r28, 0x3d	; 61
    3e4c:	de b7       	in	r29, 0x3e	; 62
    3e4e:	9a 83       	std	Y+2, r25	; 0x02
    3e50:	89 83       	std	Y+1, r24	; 0x01
    3e52:	7c 83       	std	Y+4, r23	; 0x04
    3e54:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3e56:	80 91 a6 06 	lds	r24, 0x06A6
    3e5a:	90 91 a7 06 	lds	r25, 0x06A7
    3e5e:	9c 01       	movw	r18, r24
    3e60:	24 5f       	subi	r18, 0xF4	; 244
    3e62:	3f 4f       	sbci	r19, 0xFF	; 255
    3e64:	89 81       	ldd	r24, Y+1	; 0x01
    3e66:	9a 81       	ldd	r25, Y+2	; 0x02
    3e68:	b9 01       	movw	r22, r18
    3e6a:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3e6e:	8b 81       	ldd	r24, Y+3	; 0x03
    3e70:	9c 81       	ldd	r25, Y+4	; 0x04
    3e72:	61 e0       	ldi	r22, 0x01	; 1
    3e74:	0e 94 7d 2b 	call	0x56fa	; 0x56fa <prvAddCurrentTaskToDelayedList>
}
    3e78:	0f 90       	pop	r0
    3e7a:	0f 90       	pop	r0
    3e7c:	0f 90       	pop	r0
    3e7e:	0f 90       	pop	r0
    3e80:	cf 91       	pop	r28
    3e82:	df 91       	pop	r29
    3e84:	08 95       	ret

00003e86 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    3e86:	df 93       	push	r29
    3e88:	cf 93       	push	r28
    3e8a:	cd b7       	in	r28, 0x3d	; 61
    3e8c:	de b7       	in	r29, 0x3e	; 62
    3e8e:	28 97       	sbiw	r28, 0x08	; 8
    3e90:	0f b6       	in	r0, 0x3f	; 63
    3e92:	f8 94       	cli
    3e94:	de bf       	out	0x3e, r29	; 62
    3e96:	0f be       	out	0x3f, r0	; 63
    3e98:	cd bf       	out	0x3d, r28	; 61
    3e9a:	9c 83       	std	Y+4, r25	; 0x04
    3e9c:	8b 83       	std	Y+3, r24	; 0x03
    3e9e:	7e 83       	std	Y+6, r23	; 0x06
    3ea0:	6d 83       	std	Y+5, r22	; 0x05
    3ea2:	58 87       	std	Y+8, r21	; 0x08
    3ea4:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3ea6:	e0 91 a6 06 	lds	r30, 0x06A6
    3eaa:	f0 91 a7 06 	lds	r31, 0x06A7
    3eae:	8d 81       	ldd	r24, Y+5	; 0x05
    3eb0:	9e 81       	ldd	r25, Y+6	; 0x06
    3eb2:	90 68       	ori	r25, 0x80	; 128
    3eb4:	95 87       	std	Z+13, r25	; 0x0d
    3eb6:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3eb8:	eb 81       	ldd	r30, Y+3	; 0x03
    3eba:	fc 81       	ldd	r31, Y+4	; 0x04
    3ebc:	81 81       	ldd	r24, Z+1	; 0x01
    3ebe:	92 81       	ldd	r25, Z+2	; 0x02
    3ec0:	9a 83       	std	Y+2, r25	; 0x02
    3ec2:	89 83       	std	Y+1, r24	; 0x01
    3ec4:	e0 91 a6 06 	lds	r30, 0x06A6
    3ec8:	f0 91 a7 06 	lds	r31, 0x06A7
    3ecc:	89 81       	ldd	r24, Y+1	; 0x01
    3ece:	9a 81       	ldd	r25, Y+2	; 0x02
    3ed0:	97 87       	std	Z+15, r25	; 0x0f
    3ed2:	86 87       	std	Z+14, r24	; 0x0e
    3ed4:	a0 91 a6 06 	lds	r26, 0x06A6
    3ed8:	b0 91 a7 06 	lds	r27, 0x06A7
    3edc:	e9 81       	ldd	r30, Y+1	; 0x01
    3ede:	fa 81       	ldd	r31, Y+2	; 0x02
    3ee0:	84 81       	ldd	r24, Z+4	; 0x04
    3ee2:	95 81       	ldd	r25, Z+5	; 0x05
    3ee4:	51 96       	adiw	r26, 0x11	; 17
    3ee6:	9c 93       	st	X, r25
    3ee8:	8e 93       	st	-X, r24
    3eea:	50 97       	sbiw	r26, 0x10	; 16
    3eec:	e9 81       	ldd	r30, Y+1	; 0x01
    3eee:	fa 81       	ldd	r31, Y+2	; 0x02
    3ef0:	04 80       	ldd	r0, Z+4	; 0x04
    3ef2:	f5 81       	ldd	r31, Z+5	; 0x05
    3ef4:	e0 2d       	mov	r30, r0
    3ef6:	80 91 a6 06 	lds	r24, 0x06A6
    3efa:	90 91 a7 06 	lds	r25, 0x06A7
    3efe:	0c 96       	adiw	r24, 0x0c	; 12
    3f00:	93 83       	std	Z+3, r25	; 0x03
    3f02:	82 83       	std	Z+2, r24	; 0x02
    3f04:	80 91 a6 06 	lds	r24, 0x06A6
    3f08:	90 91 a7 06 	lds	r25, 0x06A7
    3f0c:	0c 96       	adiw	r24, 0x0c	; 12
    3f0e:	e9 81       	ldd	r30, Y+1	; 0x01
    3f10:	fa 81       	ldd	r31, Y+2	; 0x02
    3f12:	95 83       	std	Z+5, r25	; 0x05
    3f14:	84 83       	std	Z+4, r24	; 0x04
    3f16:	e0 91 a6 06 	lds	r30, 0x06A6
    3f1a:	f0 91 a7 06 	lds	r31, 0x06A7
    3f1e:	8b 81       	ldd	r24, Y+3	; 0x03
    3f20:	9c 81       	ldd	r25, Y+4	; 0x04
    3f22:	95 8b       	std	Z+21, r25	; 0x15
    3f24:	84 8b       	std	Z+20, r24	; 0x14
    3f26:	eb 81       	ldd	r30, Y+3	; 0x03
    3f28:	fc 81       	ldd	r31, Y+4	; 0x04
    3f2a:	80 81       	ld	r24, Z
    3f2c:	8f 5f       	subi	r24, 0xFF	; 255
    3f2e:	eb 81       	ldd	r30, Y+3	; 0x03
    3f30:	fc 81       	ldd	r31, Y+4	; 0x04
    3f32:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3f34:	8f 81       	ldd	r24, Y+7	; 0x07
    3f36:	98 85       	ldd	r25, Y+8	; 0x08
    3f38:	61 e0       	ldi	r22, 0x01	; 1
    3f3a:	0e 94 7d 2b 	call	0x56fa	; 0x56fa <prvAddCurrentTaskToDelayedList>
}
    3f3e:	28 96       	adiw	r28, 0x08	; 8
    3f40:	0f b6       	in	r0, 0x3f	; 63
    3f42:	f8 94       	cli
    3f44:	de bf       	out	0x3e, r29	; 62
    3f46:	0f be       	out	0x3f, r0	; 63
    3f48:	cd bf       	out	0x3d, r28	; 61
    3f4a:	cf 91       	pop	r28
    3f4c:	df 91       	pop	r29
    3f4e:	08 95       	ret

00003f50 <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
    3f50:	df 93       	push	r29
    3f52:	cf 93       	push	r28
    3f54:	cd b7       	in	r28, 0x3d	; 61
    3f56:	de b7       	in	r29, 0x3e	; 62
    3f58:	27 97       	sbiw	r28, 0x07	; 7
    3f5a:	0f b6       	in	r0, 0x3f	; 63
    3f5c:	f8 94       	cli
    3f5e:	de bf       	out	0x3e, r29	; 62
    3f60:	0f be       	out	0x3f, r0	; 63
    3f62:	cd bf       	out	0x3d, r28	; 61
    3f64:	9c 83       	std	Y+4, r25	; 0x04
    3f66:	8b 83       	std	Y+3, r24	; 0x03
    3f68:	7e 83       	std	Y+6, r23	; 0x06
    3f6a:	6d 83       	std	Y+5, r22	; 0x05
    3f6c:	4f 83       	std	Y+7, r20	; 0x07

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3f6e:	eb 81       	ldd	r30, Y+3	; 0x03
    3f70:	fc 81       	ldd	r31, Y+4	; 0x04
    3f72:	81 81       	ldd	r24, Z+1	; 0x01
    3f74:	92 81       	ldd	r25, Z+2	; 0x02
    3f76:	9a 83       	std	Y+2, r25	; 0x02
    3f78:	89 83       	std	Y+1, r24	; 0x01
    3f7a:	e0 91 a6 06 	lds	r30, 0x06A6
    3f7e:	f0 91 a7 06 	lds	r31, 0x06A7
    3f82:	89 81       	ldd	r24, Y+1	; 0x01
    3f84:	9a 81       	ldd	r25, Y+2	; 0x02
    3f86:	97 87       	std	Z+15, r25	; 0x0f
    3f88:	86 87       	std	Z+14, r24	; 0x0e
    3f8a:	a0 91 a6 06 	lds	r26, 0x06A6
    3f8e:	b0 91 a7 06 	lds	r27, 0x06A7
    3f92:	e9 81       	ldd	r30, Y+1	; 0x01
    3f94:	fa 81       	ldd	r31, Y+2	; 0x02
    3f96:	84 81       	ldd	r24, Z+4	; 0x04
    3f98:	95 81       	ldd	r25, Z+5	; 0x05
    3f9a:	51 96       	adiw	r26, 0x11	; 17
    3f9c:	9c 93       	st	X, r25
    3f9e:	8e 93       	st	-X, r24
    3fa0:	50 97       	sbiw	r26, 0x10	; 16
    3fa2:	e9 81       	ldd	r30, Y+1	; 0x01
    3fa4:	fa 81       	ldd	r31, Y+2	; 0x02
    3fa6:	04 80       	ldd	r0, Z+4	; 0x04
    3fa8:	f5 81       	ldd	r31, Z+5	; 0x05
    3faa:	e0 2d       	mov	r30, r0
    3fac:	80 91 a6 06 	lds	r24, 0x06A6
    3fb0:	90 91 a7 06 	lds	r25, 0x06A7
    3fb4:	0c 96       	adiw	r24, 0x0c	; 12
    3fb6:	93 83       	std	Z+3, r25	; 0x03
    3fb8:	82 83       	std	Z+2, r24	; 0x02
    3fba:	80 91 a6 06 	lds	r24, 0x06A6
    3fbe:	90 91 a7 06 	lds	r25, 0x06A7
    3fc2:	0c 96       	adiw	r24, 0x0c	; 12
    3fc4:	e9 81       	ldd	r30, Y+1	; 0x01
    3fc6:	fa 81       	ldd	r31, Y+2	; 0x02
    3fc8:	95 83       	std	Z+5, r25	; 0x05
    3fca:	84 83       	std	Z+4, r24	; 0x04
    3fcc:	e0 91 a6 06 	lds	r30, 0x06A6
    3fd0:	f0 91 a7 06 	lds	r31, 0x06A7
    3fd4:	8b 81       	ldd	r24, Y+3	; 0x03
    3fd6:	9c 81       	ldd	r25, Y+4	; 0x04
    3fd8:	95 8b       	std	Z+21, r25	; 0x15
    3fda:	84 8b       	std	Z+20, r24	; 0x14
    3fdc:	eb 81       	ldd	r30, Y+3	; 0x03
    3fde:	fc 81       	ldd	r31, Y+4	; 0x04
    3fe0:	80 81       	ld	r24, Z
    3fe2:	8f 5f       	subi	r24, 0xFF	; 255
    3fe4:	eb 81       	ldd	r30, Y+3	; 0x03
    3fe6:	fc 81       	ldd	r31, Y+4	; 0x04
    3fe8:	80 83       	st	Z, r24

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
    3fea:	8f 81       	ldd	r24, Y+7	; 0x07
    3fec:	88 23       	and	r24, r24
    3fee:	21 f0       	breq	.+8      	; 0x3ff8 <vTaskPlaceOnEventListRestricted+0xa8>
        {
            xTicksToWait = portMAX_DELAY;
    3ff0:	8f ef       	ldi	r24, 0xFF	; 255
    3ff2:	9f ef       	ldi	r25, 0xFF	; 255
    3ff4:	9e 83       	std	Y+6, r25	; 0x06
    3ff6:	8d 83       	std	Y+5, r24	; 0x05
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    3ff8:	8d 81       	ldd	r24, Y+5	; 0x05
    3ffa:	9e 81       	ldd	r25, Y+6	; 0x06
    3ffc:	6f 81       	ldd	r22, Y+7	; 0x07
    3ffe:	0e 94 7d 2b 	call	0x56fa	; 0x56fa <prvAddCurrentTaskToDelayedList>
    }
    4002:	27 96       	adiw	r28, 0x07	; 7
    4004:	0f b6       	in	r0, 0x3f	; 63
    4006:	f8 94       	cli
    4008:	de bf       	out	0x3e, r29	; 62
    400a:	0f be       	out	0x3f, r0	; 63
    400c:	cd bf       	out	0x3d, r28	; 61
    400e:	cf 91       	pop	r28
    4010:	df 91       	pop	r29
    4012:	08 95       	ret

00004014 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4014:	df 93       	push	r29
    4016:	cf 93       	push	r28
    4018:	cd b7       	in	r28, 0x3d	; 61
    401a:	de b7       	in	r29, 0x3e	; 62
    401c:	2d 97       	sbiw	r28, 0x0d	; 13
    401e:	0f b6       	in	r0, 0x3f	; 63
    4020:	f8 94       	cli
    4022:	de bf       	out	0x3e, r29	; 62
    4024:	0f be       	out	0x3f, r0	; 63
    4026:	cd bf       	out	0x3d, r28	; 61
    4028:	9d 87       	std	Y+13, r25	; 0x0d
    402a:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    402c:	ec 85       	ldd	r30, Y+12	; 0x0c
    402e:	fd 85       	ldd	r31, Y+13	; 0x0d
    4030:	05 80       	ldd	r0, Z+5	; 0x05
    4032:	f6 81       	ldd	r31, Z+6	; 0x06
    4034:	e0 2d       	mov	r30, r0
    4036:	86 81       	ldd	r24, Z+6	; 0x06
    4038:	97 81       	ldd	r25, Z+7	; 0x07
    403a:	9b 87       	std	Y+11, r25	; 0x0b
    403c:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    403e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4040:	fb 85       	ldd	r31, Y+11	; 0x0b
    4042:	84 89       	ldd	r24, Z+20	; 0x14
    4044:	95 89       	ldd	r25, Z+21	; 0x15
    4046:	98 87       	std	Y+8, r25	; 0x08
    4048:	8f 83       	std	Y+7, r24	; 0x07
    404a:	ea 85       	ldd	r30, Y+10	; 0x0a
    404c:	fb 85       	ldd	r31, Y+11	; 0x0b
    404e:	a6 85       	ldd	r26, Z+14	; 0x0e
    4050:	b7 85       	ldd	r27, Z+15	; 0x0f
    4052:	ea 85       	ldd	r30, Y+10	; 0x0a
    4054:	fb 85       	ldd	r31, Y+11	; 0x0b
    4056:	80 89       	ldd	r24, Z+16	; 0x10
    4058:	91 89       	ldd	r25, Z+17	; 0x11
    405a:	15 96       	adiw	r26, 0x05	; 5
    405c:	9c 93       	st	X, r25
    405e:	8e 93       	st	-X, r24
    4060:	14 97       	sbiw	r26, 0x04	; 4
    4062:	ea 85       	ldd	r30, Y+10	; 0x0a
    4064:	fb 85       	ldd	r31, Y+11	; 0x0b
    4066:	a0 89       	ldd	r26, Z+16	; 0x10
    4068:	b1 89       	ldd	r27, Z+17	; 0x11
    406a:	ea 85       	ldd	r30, Y+10	; 0x0a
    406c:	fb 85       	ldd	r31, Y+11	; 0x0b
    406e:	86 85       	ldd	r24, Z+14	; 0x0e
    4070:	97 85       	ldd	r25, Z+15	; 0x0f
    4072:	13 96       	adiw	r26, 0x03	; 3
    4074:	9c 93       	st	X, r25
    4076:	8e 93       	st	-X, r24
    4078:	12 97       	sbiw	r26, 0x02	; 2
    407a:	ef 81       	ldd	r30, Y+7	; 0x07
    407c:	f8 85       	ldd	r31, Y+8	; 0x08
    407e:	21 81       	ldd	r18, Z+1	; 0x01
    4080:	32 81       	ldd	r19, Z+2	; 0x02
    4082:	8a 85       	ldd	r24, Y+10	; 0x0a
    4084:	9b 85       	ldd	r25, Y+11	; 0x0b
    4086:	0c 96       	adiw	r24, 0x0c	; 12
    4088:	28 17       	cp	r18, r24
    408a:	39 07       	cpc	r19, r25
    408c:	41 f4       	brne	.+16     	; 0x409e <xTaskRemoveFromEventList+0x8a>
    408e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4090:	fb 85       	ldd	r31, Y+11	; 0x0b
    4092:	80 89       	ldd	r24, Z+16	; 0x10
    4094:	91 89       	ldd	r25, Z+17	; 0x11
    4096:	ef 81       	ldd	r30, Y+7	; 0x07
    4098:	f8 85       	ldd	r31, Y+8	; 0x08
    409a:	92 83       	std	Z+2, r25	; 0x02
    409c:	81 83       	std	Z+1, r24	; 0x01
    409e:	ea 85       	ldd	r30, Y+10	; 0x0a
    40a0:	fb 85       	ldd	r31, Y+11	; 0x0b
    40a2:	15 8a       	std	Z+21, r1	; 0x15
    40a4:	14 8a       	std	Z+20, r1	; 0x14
    40a6:	ef 81       	ldd	r30, Y+7	; 0x07
    40a8:	f8 85       	ldd	r31, Y+8	; 0x08
    40aa:	80 81       	ld	r24, Z
    40ac:	81 50       	subi	r24, 0x01	; 1
    40ae:	ef 81       	ldd	r30, Y+7	; 0x07
    40b0:	f8 85       	ldd	r31, Y+8	; 0x08
    40b2:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    40b4:	80 91 b7 06 	lds	r24, 0x06B7
    40b8:	88 23       	and	r24, r24
    40ba:	09 f0       	breq	.+2      	; 0x40be <xTaskRemoveFromEventList+0xaa>
    40bc:	a4 c0       	rjmp	.+328    	; 0x4206 <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    40be:	ea 85       	ldd	r30, Y+10	; 0x0a
    40c0:	fb 85       	ldd	r31, Y+11	; 0x0b
    40c2:	82 85       	ldd	r24, Z+10	; 0x0a
    40c4:	93 85       	ldd	r25, Z+11	; 0x0b
    40c6:	9e 83       	std	Y+6, r25	; 0x06
    40c8:	8d 83       	std	Y+5, r24	; 0x05
    40ca:	ea 85       	ldd	r30, Y+10	; 0x0a
    40cc:	fb 85       	ldd	r31, Y+11	; 0x0b
    40ce:	a4 81       	ldd	r26, Z+4	; 0x04
    40d0:	b5 81       	ldd	r27, Z+5	; 0x05
    40d2:	ea 85       	ldd	r30, Y+10	; 0x0a
    40d4:	fb 85       	ldd	r31, Y+11	; 0x0b
    40d6:	86 81       	ldd	r24, Z+6	; 0x06
    40d8:	97 81       	ldd	r25, Z+7	; 0x07
    40da:	15 96       	adiw	r26, 0x05	; 5
    40dc:	9c 93       	st	X, r25
    40de:	8e 93       	st	-X, r24
    40e0:	14 97       	sbiw	r26, 0x04	; 4
    40e2:	ea 85       	ldd	r30, Y+10	; 0x0a
    40e4:	fb 85       	ldd	r31, Y+11	; 0x0b
    40e6:	a6 81       	ldd	r26, Z+6	; 0x06
    40e8:	b7 81       	ldd	r27, Z+7	; 0x07
    40ea:	ea 85       	ldd	r30, Y+10	; 0x0a
    40ec:	fb 85       	ldd	r31, Y+11	; 0x0b
    40ee:	84 81       	ldd	r24, Z+4	; 0x04
    40f0:	95 81       	ldd	r25, Z+5	; 0x05
    40f2:	13 96       	adiw	r26, 0x03	; 3
    40f4:	9c 93       	st	X, r25
    40f6:	8e 93       	st	-X, r24
    40f8:	12 97       	sbiw	r26, 0x02	; 2
    40fa:	ed 81       	ldd	r30, Y+5	; 0x05
    40fc:	fe 81       	ldd	r31, Y+6	; 0x06
    40fe:	21 81       	ldd	r18, Z+1	; 0x01
    4100:	32 81       	ldd	r19, Z+2	; 0x02
    4102:	8a 85       	ldd	r24, Y+10	; 0x0a
    4104:	9b 85       	ldd	r25, Y+11	; 0x0b
    4106:	02 96       	adiw	r24, 0x02	; 2
    4108:	28 17       	cp	r18, r24
    410a:	39 07       	cpc	r19, r25
    410c:	41 f4       	brne	.+16     	; 0x411e <xTaskRemoveFromEventList+0x10a>
    410e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4110:	fb 85       	ldd	r31, Y+11	; 0x0b
    4112:	86 81       	ldd	r24, Z+6	; 0x06
    4114:	97 81       	ldd	r25, Z+7	; 0x07
    4116:	ed 81       	ldd	r30, Y+5	; 0x05
    4118:	fe 81       	ldd	r31, Y+6	; 0x06
    411a:	92 83       	std	Z+2, r25	; 0x02
    411c:	81 83       	std	Z+1, r24	; 0x01
    411e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4120:	fb 85       	ldd	r31, Y+11	; 0x0b
    4122:	13 86       	std	Z+11, r1	; 0x0b
    4124:	12 86       	std	Z+10, r1	; 0x0a
    4126:	ed 81       	ldd	r30, Y+5	; 0x05
    4128:	fe 81       	ldd	r31, Y+6	; 0x06
    412a:	80 81       	ld	r24, Z
    412c:	81 50       	subi	r24, 0x01	; 1
    412e:	ed 81       	ldd	r30, Y+5	; 0x05
    4130:	fe 81       	ldd	r31, Y+6	; 0x06
    4132:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    4134:	ea 85       	ldd	r30, Y+10	; 0x0a
    4136:	fb 85       	ldd	r31, Y+11	; 0x0b
    4138:	96 89       	ldd	r25, Z+22	; 0x16
    413a:	80 91 ac 06 	lds	r24, 0x06AC
    413e:	89 17       	cp	r24, r25
    4140:	28 f4       	brcc	.+10     	; 0x414c <xTaskRemoveFromEventList+0x138>
    4142:	ea 85       	ldd	r30, Y+10	; 0x0a
    4144:	fb 85       	ldd	r31, Y+11	; 0x0b
    4146:	86 89       	ldd	r24, Z+22	; 0x16
    4148:	80 93 ac 06 	sts	0x06AC, r24
    414c:	ea 85       	ldd	r30, Y+10	; 0x0a
    414e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4150:	86 89       	ldd	r24, Z+22	; 0x16
    4152:	28 2f       	mov	r18, r24
    4154:	30 e0       	ldi	r19, 0x00	; 0
    4156:	c9 01       	movw	r24, r18
    4158:	88 0f       	add	r24, r24
    415a:	99 1f       	adc	r25, r25
    415c:	88 0f       	add	r24, r24
    415e:	99 1f       	adc	r25, r25
    4160:	88 0f       	add	r24, r24
    4162:	99 1f       	adc	r25, r25
    4164:	82 0f       	add	r24, r18
    4166:	93 1f       	adc	r25, r19
    4168:	fc 01       	movw	r30, r24
    416a:	e8 54       	subi	r30, 0x48	; 72
    416c:	f9 4f       	sbci	r31, 0xF9	; 249
    416e:	81 81       	ldd	r24, Z+1	; 0x01
    4170:	92 81       	ldd	r25, Z+2	; 0x02
    4172:	9c 83       	std	Y+4, r25	; 0x04
    4174:	8b 83       	std	Y+3, r24	; 0x03
    4176:	ea 85       	ldd	r30, Y+10	; 0x0a
    4178:	fb 85       	ldd	r31, Y+11	; 0x0b
    417a:	8b 81       	ldd	r24, Y+3	; 0x03
    417c:	9c 81       	ldd	r25, Y+4	; 0x04
    417e:	95 83       	std	Z+5, r25	; 0x05
    4180:	84 83       	std	Z+4, r24	; 0x04
    4182:	eb 81       	ldd	r30, Y+3	; 0x03
    4184:	fc 81       	ldd	r31, Y+4	; 0x04
    4186:	84 81       	ldd	r24, Z+4	; 0x04
    4188:	95 81       	ldd	r25, Z+5	; 0x05
    418a:	ea 85       	ldd	r30, Y+10	; 0x0a
    418c:	fb 85       	ldd	r31, Y+11	; 0x0b
    418e:	97 83       	std	Z+7, r25	; 0x07
    4190:	86 83       	std	Z+6, r24	; 0x06
    4192:	eb 81       	ldd	r30, Y+3	; 0x03
    4194:	fc 81       	ldd	r31, Y+4	; 0x04
    4196:	04 80       	ldd	r0, Z+4	; 0x04
    4198:	f5 81       	ldd	r31, Z+5	; 0x05
    419a:	e0 2d       	mov	r30, r0
    419c:	8a 85       	ldd	r24, Y+10	; 0x0a
    419e:	9b 85       	ldd	r25, Y+11	; 0x0b
    41a0:	02 96       	adiw	r24, 0x02	; 2
    41a2:	93 83       	std	Z+3, r25	; 0x03
    41a4:	82 83       	std	Z+2, r24	; 0x02
    41a6:	8a 85       	ldd	r24, Y+10	; 0x0a
    41a8:	9b 85       	ldd	r25, Y+11	; 0x0b
    41aa:	02 96       	adiw	r24, 0x02	; 2
    41ac:	eb 81       	ldd	r30, Y+3	; 0x03
    41ae:	fc 81       	ldd	r31, Y+4	; 0x04
    41b0:	95 83       	std	Z+5, r25	; 0x05
    41b2:	84 83       	std	Z+4, r24	; 0x04
    41b4:	ea 85       	ldd	r30, Y+10	; 0x0a
    41b6:	fb 85       	ldd	r31, Y+11	; 0x0b
    41b8:	86 89       	ldd	r24, Z+22	; 0x16
    41ba:	28 2f       	mov	r18, r24
    41bc:	30 e0       	ldi	r19, 0x00	; 0
    41be:	c9 01       	movw	r24, r18
    41c0:	88 0f       	add	r24, r24
    41c2:	99 1f       	adc	r25, r25
    41c4:	88 0f       	add	r24, r24
    41c6:	99 1f       	adc	r25, r25
    41c8:	88 0f       	add	r24, r24
    41ca:	99 1f       	adc	r25, r25
    41cc:	82 0f       	add	r24, r18
    41ce:	93 1f       	adc	r25, r19
    41d0:	88 54       	subi	r24, 0x48	; 72
    41d2:	99 4f       	sbci	r25, 0xF9	; 249
    41d4:	ea 85       	ldd	r30, Y+10	; 0x0a
    41d6:	fb 85       	ldd	r31, Y+11	; 0x0b
    41d8:	93 87       	std	Z+11, r25	; 0x0b
    41da:	82 87       	std	Z+10, r24	; 0x0a
    41dc:	ea 85       	ldd	r30, Y+10	; 0x0a
    41de:	fb 85       	ldd	r31, Y+11	; 0x0b
    41e0:	86 89       	ldd	r24, Z+22	; 0x16
    41e2:	28 2f       	mov	r18, r24
    41e4:	30 e0       	ldi	r19, 0x00	; 0
    41e6:	c9 01       	movw	r24, r18
    41e8:	88 0f       	add	r24, r24
    41ea:	99 1f       	adc	r25, r25
    41ec:	88 0f       	add	r24, r24
    41ee:	99 1f       	adc	r25, r25
    41f0:	88 0f       	add	r24, r24
    41f2:	99 1f       	adc	r25, r25
    41f4:	82 0f       	add	r24, r18
    41f6:	93 1f       	adc	r25, r19
    41f8:	fc 01       	movw	r30, r24
    41fa:	e8 54       	subi	r30, 0x48	; 72
    41fc:	f9 4f       	sbci	r31, 0xF9	; 249
    41fe:	80 81       	ld	r24, Z
    4200:	8f 5f       	subi	r24, 0xFF	; 255
    4202:	80 83       	st	Z, r24
    4204:	30 c0       	rjmp	.+96     	; 0x4266 <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4206:	80 91 f3 06 	lds	r24, 0x06F3
    420a:	90 91 f4 06 	lds	r25, 0x06F4
    420e:	9a 83       	std	Y+2, r25	; 0x02
    4210:	89 83       	std	Y+1, r24	; 0x01
    4212:	ea 85       	ldd	r30, Y+10	; 0x0a
    4214:	fb 85       	ldd	r31, Y+11	; 0x0b
    4216:	89 81       	ldd	r24, Y+1	; 0x01
    4218:	9a 81       	ldd	r25, Y+2	; 0x02
    421a:	97 87       	std	Z+15, r25	; 0x0f
    421c:	86 87       	std	Z+14, r24	; 0x0e
    421e:	e9 81       	ldd	r30, Y+1	; 0x01
    4220:	fa 81       	ldd	r31, Y+2	; 0x02
    4222:	84 81       	ldd	r24, Z+4	; 0x04
    4224:	95 81       	ldd	r25, Z+5	; 0x05
    4226:	ea 85       	ldd	r30, Y+10	; 0x0a
    4228:	fb 85       	ldd	r31, Y+11	; 0x0b
    422a:	91 8b       	std	Z+17, r25	; 0x11
    422c:	80 8b       	std	Z+16, r24	; 0x10
    422e:	e9 81       	ldd	r30, Y+1	; 0x01
    4230:	fa 81       	ldd	r31, Y+2	; 0x02
    4232:	04 80       	ldd	r0, Z+4	; 0x04
    4234:	f5 81       	ldd	r31, Z+5	; 0x05
    4236:	e0 2d       	mov	r30, r0
    4238:	8a 85       	ldd	r24, Y+10	; 0x0a
    423a:	9b 85       	ldd	r25, Y+11	; 0x0b
    423c:	0c 96       	adiw	r24, 0x0c	; 12
    423e:	93 83       	std	Z+3, r25	; 0x03
    4240:	82 83       	std	Z+2, r24	; 0x02
    4242:	8a 85       	ldd	r24, Y+10	; 0x0a
    4244:	9b 85       	ldd	r25, Y+11	; 0x0b
    4246:	0c 96       	adiw	r24, 0x0c	; 12
    4248:	e9 81       	ldd	r30, Y+1	; 0x01
    424a:	fa 81       	ldd	r31, Y+2	; 0x02
    424c:	95 83       	std	Z+5, r25	; 0x05
    424e:	84 83       	std	Z+4, r24	; 0x04
    4250:	ea 85       	ldd	r30, Y+10	; 0x0a
    4252:	fb 85       	ldd	r31, Y+11	; 0x0b
    4254:	82 ef       	ldi	r24, 0xF2	; 242
    4256:	96 e0       	ldi	r25, 0x06	; 6
    4258:	95 8b       	std	Z+21, r25	; 0x15
    425a:	84 8b       	std	Z+20, r24	; 0x14
    425c:	80 91 f2 06 	lds	r24, 0x06F2
    4260:	8f 5f       	subi	r24, 0xFF	; 255
    4262:	80 93 f2 06 	sts	0x06F2, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4266:	ea 85       	ldd	r30, Y+10	; 0x0a
    4268:	fb 85       	ldd	r31, Y+11	; 0x0b
    426a:	96 89       	ldd	r25, Z+22	; 0x16
    426c:	e0 91 a6 06 	lds	r30, 0x06A6
    4270:	f0 91 a7 06 	lds	r31, 0x06A7
    4274:	86 89       	ldd	r24, Z+22	; 0x16
    4276:	89 17       	cp	r24, r25
    4278:	30 f4       	brcc	.+12     	; 0x4286 <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    427a:	81 e0       	ldi	r24, 0x01	; 1
    427c:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    427e:	81 e0       	ldi	r24, 0x01	; 1
    4280:	80 93 b0 06 	sts	0x06B0, r24
    4284:	01 c0       	rjmp	.+2      	; 0x4288 <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    4286:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    4288:	89 85       	ldd	r24, Y+9	; 0x09
}
    428a:	2d 96       	adiw	r28, 0x0d	; 13
    428c:	0f b6       	in	r0, 0x3f	; 63
    428e:	f8 94       	cli
    4290:	de bf       	out	0x3e, r29	; 62
    4292:	0f be       	out	0x3f, r0	; 63
    4294:	cd bf       	out	0x3d, r28	; 61
    4296:	cf 91       	pop	r28
    4298:	df 91       	pop	r29
    429a:	08 95       	ret

0000429c <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    429c:	df 93       	push	r29
    429e:	cf 93       	push	r28
    42a0:	cd b7       	in	r28, 0x3d	; 61
    42a2:	de b7       	in	r29, 0x3e	; 62
    42a4:	2c 97       	sbiw	r28, 0x0c	; 12
    42a6:	0f b6       	in	r0, 0x3f	; 63
    42a8:	f8 94       	cli
    42aa:	de bf       	out	0x3e, r29	; 62
    42ac:	0f be       	out	0x3f, r0	; 63
    42ae:	cd bf       	out	0x3d, r28	; 61
    42b0:	9a 87       	std	Y+10, r25	; 0x0a
    42b2:	89 87       	std	Y+9, r24	; 0x09
    42b4:	7c 87       	std	Y+12, r23	; 0x0c
    42b6:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    42b8:	8b 85       	ldd	r24, Y+11	; 0x0b
    42ba:	9c 85       	ldd	r25, Y+12	; 0x0c
    42bc:	90 68       	ori	r25, 0x80	; 128
    42be:	e9 85       	ldd	r30, Y+9	; 0x09
    42c0:	fa 85       	ldd	r31, Y+10	; 0x0a
    42c2:	91 83       	std	Z+1, r25	; 0x01
    42c4:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    42c6:	e9 85       	ldd	r30, Y+9	; 0x09
    42c8:	fa 85       	ldd	r31, Y+10	; 0x0a
    42ca:	86 81       	ldd	r24, Z+6	; 0x06
    42cc:	97 81       	ldd	r25, Z+7	; 0x07
    42ce:	98 87       	std	Y+8, r25	; 0x08
    42d0:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    42d2:	e9 85       	ldd	r30, Y+9	; 0x09
    42d4:	fa 85       	ldd	r31, Y+10	; 0x0a
    42d6:	80 85       	ldd	r24, Z+8	; 0x08
    42d8:	91 85       	ldd	r25, Z+9	; 0x09
    42da:	9e 83       	std	Y+6, r25	; 0x06
    42dc:	8d 83       	std	Y+5, r24	; 0x05
    42de:	e9 85       	ldd	r30, Y+9	; 0x09
    42e0:	fa 85       	ldd	r31, Y+10	; 0x0a
    42e2:	a2 81       	ldd	r26, Z+2	; 0x02
    42e4:	b3 81       	ldd	r27, Z+3	; 0x03
    42e6:	e9 85       	ldd	r30, Y+9	; 0x09
    42e8:	fa 85       	ldd	r31, Y+10	; 0x0a
    42ea:	84 81       	ldd	r24, Z+4	; 0x04
    42ec:	95 81       	ldd	r25, Z+5	; 0x05
    42ee:	15 96       	adiw	r26, 0x05	; 5
    42f0:	9c 93       	st	X, r25
    42f2:	8e 93       	st	-X, r24
    42f4:	14 97       	sbiw	r26, 0x04	; 4
    42f6:	e9 85       	ldd	r30, Y+9	; 0x09
    42f8:	fa 85       	ldd	r31, Y+10	; 0x0a
    42fa:	a4 81       	ldd	r26, Z+4	; 0x04
    42fc:	b5 81       	ldd	r27, Z+5	; 0x05
    42fe:	e9 85       	ldd	r30, Y+9	; 0x09
    4300:	fa 85       	ldd	r31, Y+10	; 0x0a
    4302:	82 81       	ldd	r24, Z+2	; 0x02
    4304:	93 81       	ldd	r25, Z+3	; 0x03
    4306:	13 96       	adiw	r26, 0x03	; 3
    4308:	9c 93       	st	X, r25
    430a:	8e 93       	st	-X, r24
    430c:	12 97       	sbiw	r26, 0x02	; 2
    430e:	ed 81       	ldd	r30, Y+5	; 0x05
    4310:	fe 81       	ldd	r31, Y+6	; 0x06
    4312:	21 81       	ldd	r18, Z+1	; 0x01
    4314:	32 81       	ldd	r19, Z+2	; 0x02
    4316:	89 85       	ldd	r24, Y+9	; 0x09
    4318:	9a 85       	ldd	r25, Y+10	; 0x0a
    431a:	28 17       	cp	r18, r24
    431c:	39 07       	cpc	r19, r25
    431e:	41 f4       	brne	.+16     	; 0x4330 <vTaskRemoveFromUnorderedEventList+0x94>
    4320:	e9 85       	ldd	r30, Y+9	; 0x09
    4322:	fa 85       	ldd	r31, Y+10	; 0x0a
    4324:	84 81       	ldd	r24, Z+4	; 0x04
    4326:	95 81       	ldd	r25, Z+5	; 0x05
    4328:	ed 81       	ldd	r30, Y+5	; 0x05
    432a:	fe 81       	ldd	r31, Y+6	; 0x06
    432c:	92 83       	std	Z+2, r25	; 0x02
    432e:	81 83       	std	Z+1, r24	; 0x01
    4330:	e9 85       	ldd	r30, Y+9	; 0x09
    4332:	fa 85       	ldd	r31, Y+10	; 0x0a
    4334:	11 86       	std	Z+9, r1	; 0x09
    4336:	10 86       	std	Z+8, r1	; 0x08
    4338:	ed 81       	ldd	r30, Y+5	; 0x05
    433a:	fe 81       	ldd	r31, Y+6	; 0x06
    433c:	80 81       	ld	r24, Z
    433e:	81 50       	subi	r24, 0x01	; 1
    4340:	ed 81       	ldd	r30, Y+5	; 0x05
    4342:	fe 81       	ldd	r31, Y+6	; 0x06
    4344:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    4346:	ef 81       	ldd	r30, Y+7	; 0x07
    4348:	f8 85       	ldd	r31, Y+8	; 0x08
    434a:	82 85       	ldd	r24, Z+10	; 0x0a
    434c:	93 85       	ldd	r25, Z+11	; 0x0b
    434e:	9c 83       	std	Y+4, r25	; 0x04
    4350:	8b 83       	std	Y+3, r24	; 0x03
    4352:	ef 81       	ldd	r30, Y+7	; 0x07
    4354:	f8 85       	ldd	r31, Y+8	; 0x08
    4356:	a4 81       	ldd	r26, Z+4	; 0x04
    4358:	b5 81       	ldd	r27, Z+5	; 0x05
    435a:	ef 81       	ldd	r30, Y+7	; 0x07
    435c:	f8 85       	ldd	r31, Y+8	; 0x08
    435e:	86 81       	ldd	r24, Z+6	; 0x06
    4360:	97 81       	ldd	r25, Z+7	; 0x07
    4362:	15 96       	adiw	r26, 0x05	; 5
    4364:	9c 93       	st	X, r25
    4366:	8e 93       	st	-X, r24
    4368:	14 97       	sbiw	r26, 0x04	; 4
    436a:	ef 81       	ldd	r30, Y+7	; 0x07
    436c:	f8 85       	ldd	r31, Y+8	; 0x08
    436e:	a6 81       	ldd	r26, Z+6	; 0x06
    4370:	b7 81       	ldd	r27, Z+7	; 0x07
    4372:	ef 81       	ldd	r30, Y+7	; 0x07
    4374:	f8 85       	ldd	r31, Y+8	; 0x08
    4376:	84 81       	ldd	r24, Z+4	; 0x04
    4378:	95 81       	ldd	r25, Z+5	; 0x05
    437a:	13 96       	adiw	r26, 0x03	; 3
    437c:	9c 93       	st	X, r25
    437e:	8e 93       	st	-X, r24
    4380:	12 97       	sbiw	r26, 0x02	; 2
    4382:	eb 81       	ldd	r30, Y+3	; 0x03
    4384:	fc 81       	ldd	r31, Y+4	; 0x04
    4386:	21 81       	ldd	r18, Z+1	; 0x01
    4388:	32 81       	ldd	r19, Z+2	; 0x02
    438a:	8f 81       	ldd	r24, Y+7	; 0x07
    438c:	98 85       	ldd	r25, Y+8	; 0x08
    438e:	02 96       	adiw	r24, 0x02	; 2
    4390:	28 17       	cp	r18, r24
    4392:	39 07       	cpc	r19, r25
    4394:	41 f4       	brne	.+16     	; 0x43a6 <vTaskRemoveFromUnorderedEventList+0x10a>
    4396:	ef 81       	ldd	r30, Y+7	; 0x07
    4398:	f8 85       	ldd	r31, Y+8	; 0x08
    439a:	86 81       	ldd	r24, Z+6	; 0x06
    439c:	97 81       	ldd	r25, Z+7	; 0x07
    439e:	eb 81       	ldd	r30, Y+3	; 0x03
    43a0:	fc 81       	ldd	r31, Y+4	; 0x04
    43a2:	92 83       	std	Z+2, r25	; 0x02
    43a4:	81 83       	std	Z+1, r24	; 0x01
    43a6:	ef 81       	ldd	r30, Y+7	; 0x07
    43a8:	f8 85       	ldd	r31, Y+8	; 0x08
    43aa:	13 86       	std	Z+11, r1	; 0x0b
    43ac:	12 86       	std	Z+10, r1	; 0x0a
    43ae:	eb 81       	ldd	r30, Y+3	; 0x03
    43b0:	fc 81       	ldd	r31, Y+4	; 0x04
    43b2:	80 81       	ld	r24, Z
    43b4:	81 50       	subi	r24, 0x01	; 1
    43b6:	eb 81       	ldd	r30, Y+3	; 0x03
    43b8:	fc 81       	ldd	r31, Y+4	; 0x04
    43ba:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    43bc:	ef 81       	ldd	r30, Y+7	; 0x07
    43be:	f8 85       	ldd	r31, Y+8	; 0x08
    43c0:	96 89       	ldd	r25, Z+22	; 0x16
    43c2:	80 91 ac 06 	lds	r24, 0x06AC
    43c6:	89 17       	cp	r24, r25
    43c8:	28 f4       	brcc	.+10     	; 0x43d4 <vTaskRemoveFromUnorderedEventList+0x138>
    43ca:	ef 81       	ldd	r30, Y+7	; 0x07
    43cc:	f8 85       	ldd	r31, Y+8	; 0x08
    43ce:	86 89       	ldd	r24, Z+22	; 0x16
    43d0:	80 93 ac 06 	sts	0x06AC, r24
    43d4:	ef 81       	ldd	r30, Y+7	; 0x07
    43d6:	f8 85       	ldd	r31, Y+8	; 0x08
    43d8:	86 89       	ldd	r24, Z+22	; 0x16
    43da:	28 2f       	mov	r18, r24
    43dc:	30 e0       	ldi	r19, 0x00	; 0
    43de:	c9 01       	movw	r24, r18
    43e0:	88 0f       	add	r24, r24
    43e2:	99 1f       	adc	r25, r25
    43e4:	88 0f       	add	r24, r24
    43e6:	99 1f       	adc	r25, r25
    43e8:	88 0f       	add	r24, r24
    43ea:	99 1f       	adc	r25, r25
    43ec:	82 0f       	add	r24, r18
    43ee:	93 1f       	adc	r25, r19
    43f0:	fc 01       	movw	r30, r24
    43f2:	e8 54       	subi	r30, 0x48	; 72
    43f4:	f9 4f       	sbci	r31, 0xF9	; 249
    43f6:	81 81       	ldd	r24, Z+1	; 0x01
    43f8:	92 81       	ldd	r25, Z+2	; 0x02
    43fa:	9a 83       	std	Y+2, r25	; 0x02
    43fc:	89 83       	std	Y+1, r24	; 0x01
    43fe:	ef 81       	ldd	r30, Y+7	; 0x07
    4400:	f8 85       	ldd	r31, Y+8	; 0x08
    4402:	89 81       	ldd	r24, Y+1	; 0x01
    4404:	9a 81       	ldd	r25, Y+2	; 0x02
    4406:	95 83       	std	Z+5, r25	; 0x05
    4408:	84 83       	std	Z+4, r24	; 0x04
    440a:	e9 81       	ldd	r30, Y+1	; 0x01
    440c:	fa 81       	ldd	r31, Y+2	; 0x02
    440e:	84 81       	ldd	r24, Z+4	; 0x04
    4410:	95 81       	ldd	r25, Z+5	; 0x05
    4412:	ef 81       	ldd	r30, Y+7	; 0x07
    4414:	f8 85       	ldd	r31, Y+8	; 0x08
    4416:	97 83       	std	Z+7, r25	; 0x07
    4418:	86 83       	std	Z+6, r24	; 0x06
    441a:	e9 81       	ldd	r30, Y+1	; 0x01
    441c:	fa 81       	ldd	r31, Y+2	; 0x02
    441e:	04 80       	ldd	r0, Z+4	; 0x04
    4420:	f5 81       	ldd	r31, Z+5	; 0x05
    4422:	e0 2d       	mov	r30, r0
    4424:	8f 81       	ldd	r24, Y+7	; 0x07
    4426:	98 85       	ldd	r25, Y+8	; 0x08
    4428:	02 96       	adiw	r24, 0x02	; 2
    442a:	93 83       	std	Z+3, r25	; 0x03
    442c:	82 83       	std	Z+2, r24	; 0x02
    442e:	8f 81       	ldd	r24, Y+7	; 0x07
    4430:	98 85       	ldd	r25, Y+8	; 0x08
    4432:	02 96       	adiw	r24, 0x02	; 2
    4434:	e9 81       	ldd	r30, Y+1	; 0x01
    4436:	fa 81       	ldd	r31, Y+2	; 0x02
    4438:	95 83       	std	Z+5, r25	; 0x05
    443a:	84 83       	std	Z+4, r24	; 0x04
    443c:	ef 81       	ldd	r30, Y+7	; 0x07
    443e:	f8 85       	ldd	r31, Y+8	; 0x08
    4440:	86 89       	ldd	r24, Z+22	; 0x16
    4442:	28 2f       	mov	r18, r24
    4444:	30 e0       	ldi	r19, 0x00	; 0
    4446:	c9 01       	movw	r24, r18
    4448:	88 0f       	add	r24, r24
    444a:	99 1f       	adc	r25, r25
    444c:	88 0f       	add	r24, r24
    444e:	99 1f       	adc	r25, r25
    4450:	88 0f       	add	r24, r24
    4452:	99 1f       	adc	r25, r25
    4454:	82 0f       	add	r24, r18
    4456:	93 1f       	adc	r25, r19
    4458:	88 54       	subi	r24, 0x48	; 72
    445a:	99 4f       	sbci	r25, 0xF9	; 249
    445c:	ef 81       	ldd	r30, Y+7	; 0x07
    445e:	f8 85       	ldd	r31, Y+8	; 0x08
    4460:	93 87       	std	Z+11, r25	; 0x0b
    4462:	82 87       	std	Z+10, r24	; 0x0a
    4464:	ef 81       	ldd	r30, Y+7	; 0x07
    4466:	f8 85       	ldd	r31, Y+8	; 0x08
    4468:	86 89       	ldd	r24, Z+22	; 0x16
    446a:	28 2f       	mov	r18, r24
    446c:	30 e0       	ldi	r19, 0x00	; 0
    446e:	c9 01       	movw	r24, r18
    4470:	88 0f       	add	r24, r24
    4472:	99 1f       	adc	r25, r25
    4474:	88 0f       	add	r24, r24
    4476:	99 1f       	adc	r25, r25
    4478:	88 0f       	add	r24, r24
    447a:	99 1f       	adc	r25, r25
    447c:	82 0f       	add	r24, r18
    447e:	93 1f       	adc	r25, r19
    4480:	fc 01       	movw	r30, r24
    4482:	e8 54       	subi	r30, 0x48	; 72
    4484:	f9 4f       	sbci	r31, 0xF9	; 249
    4486:	80 81       	ld	r24, Z
    4488:	8f 5f       	subi	r24, 0xFF	; 255
    448a:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    448c:	ef 81       	ldd	r30, Y+7	; 0x07
    448e:	f8 85       	ldd	r31, Y+8	; 0x08
    4490:	96 89       	ldd	r25, Z+22	; 0x16
    4492:	e0 91 a6 06 	lds	r30, 0x06A6
    4496:	f0 91 a7 06 	lds	r31, 0x06A7
    449a:	86 89       	ldd	r24, Z+22	; 0x16
    449c:	89 17       	cp	r24, r25
    449e:	18 f4       	brcc	.+6      	; 0x44a6 <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    44a0:	81 e0       	ldi	r24, 0x01	; 1
    44a2:	80 93 b0 06 	sts	0x06B0, r24
    }
}
    44a6:	2c 96       	adiw	r28, 0x0c	; 12
    44a8:	0f b6       	in	r0, 0x3f	; 63
    44aa:	f8 94       	cli
    44ac:	de bf       	out	0x3e, r29	; 62
    44ae:	0f be       	out	0x3f, r0	; 63
    44b0:	cd bf       	out	0x3d, r28	; 61
    44b2:	cf 91       	pop	r28
    44b4:	df 91       	pop	r29
    44b6:	08 95       	ret

000044b8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    44b8:	df 93       	push	r29
    44ba:	cf 93       	push	r28
    44bc:	00 d0       	rcall	.+0      	; 0x44be <vTaskSetTimeOutState+0x6>
    44be:	cd b7       	in	r28, 0x3d	; 61
    44c0:	de b7       	in	r29, 0x3e	; 62
    44c2:	9a 83       	std	Y+2, r25	; 0x02
    44c4:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    44c6:	0f b6       	in	r0, 0x3f	; 63
    44c8:	f8 94       	cli
    44ca:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    44cc:	80 91 b1 06 	lds	r24, 0x06B1
    44d0:	e9 81       	ldd	r30, Y+1	; 0x01
    44d2:	fa 81       	ldd	r31, Y+2	; 0x02
    44d4:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    44d6:	80 91 aa 06 	lds	r24, 0x06AA
    44da:	90 91 ab 06 	lds	r25, 0x06AB
    44de:	e9 81       	ldd	r30, Y+1	; 0x01
    44e0:	fa 81       	ldd	r31, Y+2	; 0x02
    44e2:	92 83       	std	Z+2, r25	; 0x02
    44e4:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    44e6:	0f 90       	pop	r0
    44e8:	0f be       	out	0x3f, r0	; 63
}
    44ea:	0f 90       	pop	r0
    44ec:	0f 90       	pop	r0
    44ee:	cf 91       	pop	r28
    44f0:	df 91       	pop	r29
    44f2:	08 95       	ret

000044f4 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    44f4:	df 93       	push	r29
    44f6:	cf 93       	push	r28
    44f8:	00 d0       	rcall	.+0      	; 0x44fa <vTaskInternalSetTimeOutState+0x6>
    44fa:	cd b7       	in	r28, 0x3d	; 61
    44fc:	de b7       	in	r29, 0x3e	; 62
    44fe:	9a 83       	std	Y+2, r25	; 0x02
    4500:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    4502:	80 91 b1 06 	lds	r24, 0x06B1
    4506:	e9 81       	ldd	r30, Y+1	; 0x01
    4508:	fa 81       	ldd	r31, Y+2	; 0x02
    450a:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    450c:	80 91 aa 06 	lds	r24, 0x06AA
    4510:	90 91 ab 06 	lds	r25, 0x06AB
    4514:	e9 81       	ldd	r30, Y+1	; 0x01
    4516:	fa 81       	ldd	r31, Y+2	; 0x02
    4518:	92 83       	std	Z+2, r25	; 0x02
    451a:	81 83       	std	Z+1, r24	; 0x01
}
    451c:	0f 90       	pop	r0
    451e:	0f 90       	pop	r0
    4520:	cf 91       	pop	r28
    4522:	df 91       	pop	r29
    4524:	08 95       	ret

00004526 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    4526:	df 93       	push	r29
    4528:	cf 93       	push	r28
    452a:	cd b7       	in	r28, 0x3d	; 61
    452c:	de b7       	in	r29, 0x3e	; 62
    452e:	29 97       	sbiw	r28, 0x09	; 9
    4530:	0f b6       	in	r0, 0x3f	; 63
    4532:	f8 94       	cli
    4534:	de bf       	out	0x3e, r29	; 62
    4536:	0f be       	out	0x3f, r0	; 63
    4538:	cd bf       	out	0x3d, r28	; 61
    453a:	9f 83       	std	Y+7, r25	; 0x07
    453c:	8e 83       	std	Y+6, r24	; 0x06
    453e:	79 87       	std	Y+9, r23	; 0x09
    4540:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    4542:	0f b6       	in	r0, 0x3f	; 63
    4544:	f8 94       	cli
    4546:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    4548:	80 91 aa 06 	lds	r24, 0x06AA
    454c:	90 91 ab 06 	lds	r25, 0x06AB
    4550:	9c 83       	std	Y+4, r25	; 0x04
    4552:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4554:	ee 81       	ldd	r30, Y+6	; 0x06
    4556:	ff 81       	ldd	r31, Y+7	; 0x07
    4558:	21 81       	ldd	r18, Z+1	; 0x01
    455a:	32 81       	ldd	r19, Z+2	; 0x02
    455c:	8b 81       	ldd	r24, Y+3	; 0x03
    455e:	9c 81       	ldd	r25, Y+4	; 0x04
    4560:	82 1b       	sub	r24, r18
    4562:	93 0b       	sbc	r25, r19
    4564:	9a 83       	std	Y+2, r25	; 0x02
    4566:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4568:	ee 81       	ldd	r30, Y+6	; 0x06
    456a:	ff 81       	ldd	r31, Y+7	; 0x07
    456c:	90 81       	ld	r25, Z
    456e:	80 91 b1 06 	lds	r24, 0x06B1
    4572:	98 17       	cp	r25, r24
    4574:	81 f0       	breq	.+32     	; 0x4596 <xTaskCheckForTimeOut+0x70>
    4576:	ee 81       	ldd	r30, Y+6	; 0x06
    4578:	ff 81       	ldd	r31, Y+7	; 0x07
    457a:	21 81       	ldd	r18, Z+1	; 0x01
    457c:	32 81       	ldd	r19, Z+2	; 0x02
    457e:	8b 81       	ldd	r24, Y+3	; 0x03
    4580:	9c 81       	ldd	r25, Y+4	; 0x04
    4582:	82 17       	cp	r24, r18
    4584:	93 07       	cpc	r25, r19
    4586:	38 f0       	brcs	.+14     	; 0x4596 <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    4588:	81 e0       	ldi	r24, 0x01	; 1
    458a:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    458c:	e8 85       	ldd	r30, Y+8	; 0x08
    458e:	f9 85       	ldd	r31, Y+9	; 0x09
    4590:	11 82       	std	Z+1, r1	; 0x01
    4592:	10 82       	st	Z, r1
    4594:	23 c0       	rjmp	.+70     	; 0x45dc <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4596:	e8 85       	ldd	r30, Y+8	; 0x08
    4598:	f9 85       	ldd	r31, Y+9	; 0x09
    459a:	20 81       	ld	r18, Z
    459c:	31 81       	ldd	r19, Z+1	; 0x01
    459e:	89 81       	ldd	r24, Y+1	; 0x01
    45a0:	9a 81       	ldd	r25, Y+2	; 0x02
    45a2:	82 17       	cp	r24, r18
    45a4:	93 07       	cpc	r25, r19
    45a6:	a0 f4       	brcc	.+40     	; 0x45d0 <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    45a8:	e8 85       	ldd	r30, Y+8	; 0x08
    45aa:	f9 85       	ldd	r31, Y+9	; 0x09
    45ac:	20 81       	ld	r18, Z
    45ae:	31 81       	ldd	r19, Z+1	; 0x01
    45b0:	89 81       	ldd	r24, Y+1	; 0x01
    45b2:	9a 81       	ldd	r25, Y+2	; 0x02
    45b4:	a9 01       	movw	r20, r18
    45b6:	48 1b       	sub	r20, r24
    45b8:	59 0b       	sbc	r21, r25
    45ba:	ca 01       	movw	r24, r20
    45bc:	e8 85       	ldd	r30, Y+8	; 0x08
    45be:	f9 85       	ldd	r31, Y+9	; 0x09
    45c0:	91 83       	std	Z+1, r25	; 0x01
    45c2:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    45c4:	8e 81       	ldd	r24, Y+6	; 0x06
    45c6:	9f 81       	ldd	r25, Y+7	; 0x07
    45c8:	0e 94 7a 22 	call	0x44f4	; 0x44f4 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    45cc:	1d 82       	std	Y+5, r1	; 0x05
    45ce:	06 c0       	rjmp	.+12     	; 0x45dc <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    45d0:	e8 85       	ldd	r30, Y+8	; 0x08
    45d2:	f9 85       	ldd	r31, Y+9	; 0x09
    45d4:	11 82       	std	Z+1, r1	; 0x01
    45d6:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    45d8:	81 e0       	ldi	r24, 0x01	; 1
    45da:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    45dc:	0f 90       	pop	r0
    45de:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    45e0:	8d 81       	ldd	r24, Y+5	; 0x05
}
    45e2:	29 96       	adiw	r28, 0x09	; 9
    45e4:	0f b6       	in	r0, 0x3f	; 63
    45e6:	f8 94       	cli
    45e8:	de bf       	out	0x3e, r29	; 62
    45ea:	0f be       	out	0x3f, r0	; 63
    45ec:	cd bf       	out	0x3d, r28	; 61
    45ee:	cf 91       	pop	r28
    45f0:	df 91       	pop	r29
    45f2:	08 95       	ret

000045f4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    45f4:	df 93       	push	r29
    45f6:	cf 93       	push	r28
    45f8:	cd b7       	in	r28, 0x3d	; 61
    45fa:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    45fc:	81 e0       	ldi	r24, 0x01	; 1
    45fe:	80 93 b0 06 	sts	0x06B0, r24
}
    4602:	cf 91       	pop	r28
    4604:	df 91       	pop	r29
    4606:	08 95       	ret

00004608 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4608:	df 93       	push	r29
    460a:	cf 93       	push	r28
    460c:	00 d0       	rcall	.+0      	; 0x460e <prvIdleTask+0x6>
    460e:	cd b7       	in	r28, 0x3d	; 61
    4610:	de b7       	in	r29, 0x3e	; 62
    4612:	9a 83       	std	Y+2, r25	; 0x02
    4614:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    4616:	0e 94 51 23 	call	0x46a2	; 0x46a2 <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    461a:	80 91 b8 06 	lds	r24, 0x06B8
    461e:	82 30       	cpi	r24, 0x02	; 2
    4620:	d0 f3       	brcs	.-12     	; 0x4616 <prvIdleTask+0xe>
                {
                    taskYIELD();
    4622:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    4626:	f7 cf       	rjmp	.-18     	; 0x4616 <prvIdleTask+0xe>

00004628 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4628:	df 93       	push	r29
    462a:	cf 93       	push	r28
    462c:	0f 92       	push	r0
    462e:	cd b7       	in	r28, 0x3d	; 61
    4630:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4632:	19 82       	std	Y+1, r1	; 0x01
    4634:	13 c0       	rjmp	.+38     	; 0x465c <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4636:	89 81       	ldd	r24, Y+1	; 0x01
    4638:	28 2f       	mov	r18, r24
    463a:	30 e0       	ldi	r19, 0x00	; 0
    463c:	c9 01       	movw	r24, r18
    463e:	88 0f       	add	r24, r24
    4640:	99 1f       	adc	r25, r25
    4642:	88 0f       	add	r24, r24
    4644:	99 1f       	adc	r25, r25
    4646:	88 0f       	add	r24, r24
    4648:	99 1f       	adc	r25, r25
    464a:	82 0f       	add	r24, r18
    464c:	93 1f       	adc	r25, r19
    464e:	88 54       	subi	r24, 0x48	; 72
    4650:	99 4f       	sbci	r25, 0xF9	; 249
    4652:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4656:	89 81       	ldd	r24, Y+1	; 0x01
    4658:	8f 5f       	subi	r24, 0xFF	; 255
    465a:	89 83       	std	Y+1, r24	; 0x01
    465c:	89 81       	ldd	r24, Y+1	; 0x01
    465e:	84 30       	cpi	r24, 0x04	; 4
    4660:	50 f3       	brcs	.-44     	; 0x4636 <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    4662:	8c ed       	ldi	r24, 0xDC	; 220
    4664:	96 e0       	ldi	r25, 0x06	; 6
    4666:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    466a:	85 ee       	ldi	r24, 0xE5	; 229
    466c:	96 e0       	ldi	r25, 0x06	; 6
    466e:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInitialise>
    vListInitialise( &xPendingReadyList );
    4672:	82 ef       	ldi	r24, 0xF2	; 242
    4674:	96 e0       	ldi	r25, 0x06	; 6
    4676:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    467a:	8b ef       	ldi	r24, 0xFB	; 251
    467c:	96 e0       	ldi	r25, 0x06	; 6
    467e:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    4682:	8c ed       	ldi	r24, 0xDC	; 220
    4684:	96 e0       	ldi	r25, 0x06	; 6
    4686:	90 93 ef 06 	sts	0x06EF, r25
    468a:	80 93 ee 06 	sts	0x06EE, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    468e:	85 ee       	ldi	r24, 0xE5	; 229
    4690:	96 e0       	ldi	r25, 0x06	; 6
    4692:	90 93 f1 06 	sts	0x06F1, r25
    4696:	80 93 f0 06 	sts	0x06F0, r24
}
    469a:	0f 90       	pop	r0
    469c:	cf 91       	pop	r28
    469e:	df 91       	pop	r29
    46a0:	08 95       	ret

000046a2 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    46a2:	df 93       	push	r29
    46a4:	cf 93       	push	r28
    46a6:	00 d0       	rcall	.+0      	; 0x46a8 <prvCheckTasksWaitingTermination+0x6>
    46a8:	cd b7       	in	r28, 0x3d	; 61
    46aa:	de b7       	in	r29, 0x3e	; 62
    46ac:	20 c0       	rjmp	.+64     	; 0x46ee <prvCheckTasksWaitingTermination+0x4c>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    46ae:	0f b6       	in	r0, 0x3f	; 63
    46b0:	f8 94       	cli
    46b2:	0f 92       	push	r0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    46b4:	e0 91 00 07 	lds	r30, 0x0700
    46b8:	f0 91 01 07 	lds	r31, 0x0701
    46bc:	86 81       	ldd	r24, Z+6	; 0x06
    46be:	97 81       	ldd	r25, Z+7	; 0x07
    46c0:	9a 83       	std	Y+2, r25	; 0x02
    46c2:	89 83       	std	Y+1, r24	; 0x01
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    46c4:	89 81       	ldd	r24, Y+1	; 0x01
    46c6:	9a 81       	ldd	r25, Y+2	; 0x02
    46c8:	02 96       	adiw	r24, 0x02	; 2
    46ca:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <uxListRemove>
                    --uxCurrentNumberOfTasks;
    46ce:	80 91 a9 06 	lds	r24, 0x06A9
    46d2:	81 50       	subi	r24, 0x01	; 1
    46d4:	80 93 a9 06 	sts	0x06A9, r24
                    --uxDeletedTasksWaitingCleanUp;
    46d8:	80 91 a8 06 	lds	r24, 0x06A8
    46dc:	81 50       	subi	r24, 0x01	; 1
    46de:	80 93 a8 06 	sts	0x06A8, r24
                }
                taskEXIT_CRITICAL();
    46e2:	0f 90       	pop	r0
    46e4:	0f be       	out	0x3f, r0	; 63

                prvDeleteTCB( pxTCB );
    46e6:	89 81       	ldd	r24, Y+1	; 0x01
    46e8:	9a 81       	ldd	r25, Y+2	; 0x02
    46ea:	0e 94 80 23 	call	0x4700	; 0x4700 <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    46ee:	80 91 a8 06 	lds	r24, 0x06A8
    46f2:	88 23       	and	r24, r24
    46f4:	e1 f6       	brne	.-72     	; 0x46ae <prvCheckTasksWaitingTermination+0xc>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    46f6:	0f 90       	pop	r0
    46f8:	0f 90       	pop	r0
    46fa:	cf 91       	pop	r28
    46fc:	df 91       	pop	r29
    46fe:	08 95       	ret

00004700 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    4700:	df 93       	push	r29
    4702:	cf 93       	push	r28
    4704:	00 d0       	rcall	.+0      	; 0x4706 <prvDeleteTCB+0x6>
    4706:	cd b7       	in	r28, 0x3d	; 61
    4708:	de b7       	in	r29, 0x3e	; 62
    470a:	9a 83       	std	Y+2, r25	; 0x02
    470c:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    470e:	e9 81       	ldd	r30, Y+1	; 0x01
    4710:	fa 81       	ldd	r31, Y+2	; 0x02
    4712:	87 89       	ldd	r24, Z+23	; 0x17
    4714:	90 8d       	ldd	r25, Z+24	; 0x18
    4716:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                vPortFree( pxTCB );
    471a:	89 81       	ldd	r24, Y+1	; 0x01
    471c:	9a 81       	ldd	r25, Y+2	; 0x02
    471e:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    4722:	0f 90       	pop	r0
    4724:	0f 90       	pop	r0
    4726:	cf 91       	pop	r28
    4728:	df 91       	pop	r29
    472a:	08 95       	ret

0000472c <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    472c:	df 93       	push	r29
    472e:	cf 93       	push	r28
    4730:	cd b7       	in	r28, 0x3d	; 61
    4732:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4734:	e0 91 ee 06 	lds	r30, 0x06EE
    4738:	f0 91 ef 06 	lds	r31, 0x06EF
    473c:	80 81       	ld	r24, Z
    473e:	88 23       	and	r24, r24
    4740:	39 f4       	brne	.+14     	; 0x4750 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    4742:	8f ef       	ldi	r24, 0xFF	; 255
    4744:	9f ef       	ldi	r25, 0xFF	; 255
    4746:	90 93 b4 06 	sts	0x06B4, r25
    474a:	80 93 b3 06 	sts	0x06B3, r24
    474e:	0d c0       	rjmp	.+26     	; 0x476a <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    4750:	e0 91 ee 06 	lds	r30, 0x06EE
    4754:	f0 91 ef 06 	lds	r31, 0x06EF
    4758:	05 80       	ldd	r0, Z+5	; 0x05
    475a:	f6 81       	ldd	r31, Z+6	; 0x06
    475c:	e0 2d       	mov	r30, r0
    475e:	80 81       	ld	r24, Z
    4760:	91 81       	ldd	r25, Z+1	; 0x01
    4762:	90 93 b4 06 	sts	0x06B4, r25
    4766:	80 93 b3 06 	sts	0x06B3, r24
    }
}
    476a:	cf 91       	pop	r28
    476c:	df 91       	pop	r29
    476e:	08 95       	ret

00004770 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
    4770:	df 93       	push	r29
    4772:	cf 93       	push	r28
    4774:	0f 92       	push	r0
    4776:	cd b7       	in	r28, 0x3d	; 61
    4778:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
    477a:	80 91 ad 06 	lds	r24, 0x06AD
    477e:	88 23       	and	r24, r24
    4780:	19 f4       	brne	.+6      	; 0x4788 <xTaskGetSchedulerState+0x18>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
    4782:	81 e0       	ldi	r24, 0x01	; 1
    4784:	89 83       	std	Y+1, r24	; 0x01
    4786:	08 c0       	rjmp	.+16     	; 0x4798 <xTaskGetSchedulerState+0x28>
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4788:	80 91 b7 06 	lds	r24, 0x06B7
    478c:	88 23       	and	r24, r24
    478e:	19 f4       	brne	.+6      	; 0x4796 <xTaskGetSchedulerState+0x26>
            {
                xReturn = taskSCHEDULER_RUNNING;
    4790:	82 e0       	ldi	r24, 0x02	; 2
    4792:	89 83       	std	Y+1, r24	; 0x01
    4794:	01 c0       	rjmp	.+2      	; 0x4798 <xTaskGetSchedulerState+0x28>
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
    4796:	19 82       	std	Y+1, r1	; 0x01
            }
        }

        return xReturn;
    4798:	89 81       	ldd	r24, Y+1	; 0x01
    }
    479a:	0f 90       	pop	r0
    479c:	cf 91       	pop	r28
    479e:	df 91       	pop	r29
    47a0:	08 95       	ret

000047a2 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    47a2:	df 93       	push	r29
    47a4:	cf 93       	push	r28
    47a6:	00 d0       	rcall	.+0      	; 0x47a8 <uxTaskResetEventItemValue+0x6>
    47a8:	cd b7       	in	r28, 0x3d	; 61
    47aa:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    47ac:	e0 91 a6 06 	lds	r30, 0x06A6
    47b0:	f0 91 a7 06 	lds	r31, 0x06A7
    47b4:	84 85       	ldd	r24, Z+12	; 0x0c
    47b6:	95 85       	ldd	r25, Z+13	; 0x0d
    47b8:	9a 83       	std	Y+2, r25	; 0x02
    47ba:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    47bc:	a0 91 a6 06 	lds	r26, 0x06A6
    47c0:	b0 91 a7 06 	lds	r27, 0x06A7
    47c4:	e0 91 a6 06 	lds	r30, 0x06A6
    47c8:	f0 91 a7 06 	lds	r31, 0x06A7
    47cc:	86 89       	ldd	r24, Z+22	; 0x16
    47ce:	28 2f       	mov	r18, r24
    47d0:	30 e0       	ldi	r19, 0x00	; 0
    47d2:	84 e0       	ldi	r24, 0x04	; 4
    47d4:	90 e0       	ldi	r25, 0x00	; 0
    47d6:	82 1b       	sub	r24, r18
    47d8:	93 0b       	sbc	r25, r19
    47da:	1d 96       	adiw	r26, 0x0d	; 13
    47dc:	9c 93       	st	X, r25
    47de:	8e 93       	st	-X, r24
    47e0:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    47e2:	89 81       	ldd	r24, Y+1	; 0x01
    47e4:	9a 81       	ldd	r25, Y+2	; 0x02
}
    47e6:	0f 90       	pop	r0
    47e8:	0f 90       	pop	r0
    47ea:	cf 91       	pop	r28
    47ec:	df 91       	pop	r29
    47ee:	08 95       	ret

000047f0 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    47f0:	df 93       	push	r29
    47f2:	cf 93       	push	r28
    47f4:	cd b7       	in	r28, 0x3d	; 61
    47f6:	de b7       	in	r29, 0x3e	; 62
    47f8:	28 97       	sbiw	r28, 0x08	; 8
    47fa:	0f b6       	in	r0, 0x3f	; 63
    47fc:	f8 94       	cli
    47fe:	de bf       	out	0x3e, r29	; 62
    4800:	0f be       	out	0x3f, r0	; 63
    4802:	cd bf       	out	0x3d, r28	; 61
    4804:	8d 83       	std	Y+5, r24	; 0x05
    4806:	6e 83       	std	Y+6, r22	; 0x06
    4808:	58 87       	std	Y+8, r21	; 0x08
    480a:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    480c:	0f b6       	in	r0, 0x3f	; 63
    480e:	f8 94       	cli
    4810:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    4812:	20 91 a6 06 	lds	r18, 0x06A6
    4816:	30 91 a7 06 	lds	r19, 0x06A7
    481a:	8d 81       	ldd	r24, Y+5	; 0x05
    481c:	88 2f       	mov	r24, r24
    481e:	90 e0       	ldi	r25, 0x00	; 0
    4820:	88 0f       	add	r24, r24
    4822:	99 1f       	adc	r25, r25
    4824:	88 0f       	add	r24, r24
    4826:	99 1f       	adc	r25, r25
    4828:	82 0f       	add	r24, r18
    482a:	93 1f       	adc	r25, r19
    482c:	fc 01       	movw	r30, r24
    482e:	b1 96       	adiw	r30, 0x21	; 33
    4830:	80 81       	ld	r24, Z
    4832:	91 81       	ldd	r25, Z+1	; 0x01
    4834:	a2 81       	ldd	r26, Z+2	; 0x02
    4836:	b3 81       	ldd	r27, Z+3	; 0x03
    4838:	00 97       	sbiw	r24, 0x00	; 0
    483a:	a1 05       	cpc	r26, r1
    483c:	b1 05       	cpc	r27, r1
    483e:	c1 f4       	brne	.+48     	; 0x4870 <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4840:	20 91 a6 06 	lds	r18, 0x06A6
    4844:	30 91 a7 06 	lds	r19, 0x06A7
    4848:	8d 81       	ldd	r24, Y+5	; 0x05
    484a:	88 2f       	mov	r24, r24
    484c:	90 e0       	ldi	r25, 0x00	; 0
    484e:	82 0f       	add	r24, r18
    4850:	93 1f       	adc	r25, r19
    4852:	fc 01       	movw	r30, r24
    4854:	b5 96       	adiw	r30, 0x25	; 37
    4856:	81 e0       	ldi	r24, 0x01	; 1
    4858:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    485a:	8f 81       	ldd	r24, Y+7	; 0x07
    485c:	98 85       	ldd	r25, Y+8	; 0x08
    485e:	00 97       	sbiw	r24, 0x00	; 0
    4860:	39 f0       	breq	.+14     	; 0x4870 <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4862:	8f 81       	ldd	r24, Y+7	; 0x07
    4864:	98 85       	ldd	r25, Y+8	; 0x08
    4866:	61 e0       	ldi	r22, 0x01	; 1
    4868:	0e 94 7d 2b 	call	0x56fa	; 0x56fa <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    486c:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4870:	0f 90       	pop	r0
    4872:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4874:	0f b6       	in	r0, 0x3f	; 63
    4876:	f8 94       	cli
    4878:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    487a:	20 91 a6 06 	lds	r18, 0x06A6
    487e:	30 91 a7 06 	lds	r19, 0x06A7
    4882:	8d 81       	ldd	r24, Y+5	; 0x05
    4884:	88 2f       	mov	r24, r24
    4886:	90 e0       	ldi	r25, 0x00	; 0
    4888:	88 0f       	add	r24, r24
    488a:	99 1f       	adc	r25, r25
    488c:	88 0f       	add	r24, r24
    488e:	99 1f       	adc	r25, r25
    4890:	82 0f       	add	r24, r18
    4892:	93 1f       	adc	r25, r19
    4894:	fc 01       	movw	r30, r24
    4896:	b1 96       	adiw	r30, 0x21	; 33
    4898:	80 81       	ld	r24, Z
    489a:	91 81       	ldd	r25, Z+1	; 0x01
    489c:	a2 81       	ldd	r26, Z+2	; 0x02
    489e:	b3 81       	ldd	r27, Z+3	; 0x03
    48a0:	89 83       	std	Y+1, r24	; 0x01
    48a2:	9a 83       	std	Y+2, r25	; 0x02
    48a4:	ab 83       	std	Y+3, r26	; 0x03
    48a6:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    48a8:	89 81       	ldd	r24, Y+1	; 0x01
    48aa:	9a 81       	ldd	r25, Y+2	; 0x02
    48ac:	ab 81       	ldd	r26, Y+3	; 0x03
    48ae:	bc 81       	ldd	r27, Y+4	; 0x04
    48b0:	00 97       	sbiw	r24, 0x00	; 0
    48b2:	a1 05       	cpc	r26, r1
    48b4:	b1 05       	cpc	r27, r1
    48b6:	a9 f1       	breq	.+106    	; 0x4922 <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    48b8:	8e 81       	ldd	r24, Y+6	; 0x06
    48ba:	88 23       	and	r24, r24
    48bc:	a1 f0       	breq	.+40     	; 0x48e6 <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    48be:	20 91 a6 06 	lds	r18, 0x06A6
    48c2:	30 91 a7 06 	lds	r19, 0x06A7
    48c6:	8d 81       	ldd	r24, Y+5	; 0x05
    48c8:	88 2f       	mov	r24, r24
    48ca:	90 e0       	ldi	r25, 0x00	; 0
    48cc:	88 0f       	add	r24, r24
    48ce:	99 1f       	adc	r25, r25
    48d0:	88 0f       	add	r24, r24
    48d2:	99 1f       	adc	r25, r25
    48d4:	82 0f       	add	r24, r18
    48d6:	93 1f       	adc	r25, r19
    48d8:	fc 01       	movw	r30, r24
    48da:	b1 96       	adiw	r30, 0x21	; 33
    48dc:	10 82       	st	Z, r1
    48de:	11 82       	std	Z+1, r1	; 0x01
    48e0:	12 82       	std	Z+2, r1	; 0x02
    48e2:	13 82       	std	Z+3, r1	; 0x03
    48e4:	1e c0       	rjmp	.+60     	; 0x4922 <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    48e6:	e0 91 a6 06 	lds	r30, 0x06A6
    48ea:	f0 91 a7 06 	lds	r31, 0x06A7
    48ee:	8d 81       	ldd	r24, Y+5	; 0x05
    48f0:	68 2f       	mov	r22, r24
    48f2:	70 e0       	ldi	r23, 0x00	; 0
    48f4:	89 81       	ldd	r24, Y+1	; 0x01
    48f6:	9a 81       	ldd	r25, Y+2	; 0x02
    48f8:	ab 81       	ldd	r26, Y+3	; 0x03
    48fa:	bc 81       	ldd	r27, Y+4	; 0x04
    48fc:	9c 01       	movw	r18, r24
    48fe:	ad 01       	movw	r20, r26
    4900:	21 50       	subi	r18, 0x01	; 1
    4902:	30 40       	sbci	r19, 0x00	; 0
    4904:	40 40       	sbci	r20, 0x00	; 0
    4906:	50 40       	sbci	r21, 0x00	; 0
    4908:	cb 01       	movw	r24, r22
    490a:	88 0f       	add	r24, r24
    490c:	99 1f       	adc	r25, r25
    490e:	88 0f       	add	r24, r24
    4910:	99 1f       	adc	r25, r25
    4912:	8e 0f       	add	r24, r30
    4914:	9f 1f       	adc	r25, r31
    4916:	fc 01       	movw	r30, r24
    4918:	b1 96       	adiw	r30, 0x21	; 33
    491a:	20 83       	st	Z, r18
    491c:	31 83       	std	Z+1, r19	; 0x01
    491e:	42 83       	std	Z+2, r20	; 0x02
    4920:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    4922:	20 91 a6 06 	lds	r18, 0x06A6
    4926:	30 91 a7 06 	lds	r19, 0x06A7
    492a:	8d 81       	ldd	r24, Y+5	; 0x05
    492c:	88 2f       	mov	r24, r24
    492e:	90 e0       	ldi	r25, 0x00	; 0
    4930:	82 0f       	add	r24, r18
    4932:	93 1f       	adc	r25, r19
    4934:	fc 01       	movw	r30, r24
    4936:	b5 96       	adiw	r30, 0x25	; 37
    4938:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    493a:	0f 90       	pop	r0
    493c:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    493e:	89 81       	ldd	r24, Y+1	; 0x01
    4940:	9a 81       	ldd	r25, Y+2	; 0x02
    4942:	ab 81       	ldd	r26, Y+3	; 0x03
    4944:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    4946:	bc 01       	movw	r22, r24
    4948:	cd 01       	movw	r24, r26
    494a:	28 96       	adiw	r28, 0x08	; 8
    494c:	0f b6       	in	r0, 0x3f	; 63
    494e:	f8 94       	cli
    4950:	de bf       	out	0x3e, r29	; 62
    4952:	0f be       	out	0x3f, r0	; 63
    4954:	cd bf       	out	0x3d, r28	; 61
    4956:	cf 91       	pop	r28
    4958:	df 91       	pop	r29
    495a:	08 95       	ret

0000495c <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    495c:	cf 92       	push	r12
    495e:	df 92       	push	r13
    4960:	ef 92       	push	r14
    4962:	ff 92       	push	r15
    4964:	0f 93       	push	r16
    4966:	1f 93       	push	r17
    4968:	df 93       	push	r29
    496a:	cf 93       	push	r28
    496c:	cd b7       	in	r28, 0x3d	; 61
    496e:	de b7       	in	r29, 0x3e	; 62
    4970:	2e 97       	sbiw	r28, 0x0e	; 14
    4972:	0f b6       	in	r0, 0x3f	; 63
    4974:	f8 94       	cli
    4976:	de bf       	out	0x3e, r29	; 62
    4978:	0f be       	out	0x3f, r0	; 63
    497a:	cd bf       	out	0x3d, r28	; 61
    497c:	8a 83       	std	Y+2, r24	; 0x02
    497e:	4b 83       	std	Y+3, r20	; 0x03
    4980:	5c 83       	std	Y+4, r21	; 0x04
    4982:	6d 83       	std	Y+5, r22	; 0x05
    4984:	7e 83       	std	Y+6, r23	; 0x06
    4986:	0f 83       	std	Y+7, r16	; 0x07
    4988:	18 87       	std	Y+8, r17	; 0x08
    498a:	29 87       	std	Y+9, r18	; 0x09
    498c:	3a 87       	std	Y+10, r19	; 0x0a
    498e:	fc 86       	std	Y+12, r15	; 0x0c
    4990:	eb 86       	std	Y+11, r14	; 0x0b
    4992:	de 86       	std	Y+14, r13	; 0x0e
    4994:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    4996:	0f b6       	in	r0, 0x3f	; 63
    4998:	f8 94       	cli
    499a:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    499c:	20 91 a6 06 	lds	r18, 0x06A6
    49a0:	30 91 a7 06 	lds	r19, 0x06A7
    49a4:	8a 81       	ldd	r24, Y+2	; 0x02
    49a6:	88 2f       	mov	r24, r24
    49a8:	90 e0       	ldi	r25, 0x00	; 0
    49aa:	82 0f       	add	r24, r18
    49ac:	93 1f       	adc	r25, r19
    49ae:	fc 01       	movw	r30, r24
    49b0:	b5 96       	adiw	r30, 0x25	; 37
    49b2:	80 81       	ld	r24, Z
    49b4:	82 30       	cpi	r24, 0x02	; 2
    49b6:	09 f4       	brne	.+2      	; 0x49ba <xTaskGenericNotifyWait+0x5e>
    49b8:	47 c0       	rjmp	.+142    	; 0x4a48 <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    49ba:	60 91 a6 06 	lds	r22, 0x06A6
    49be:	70 91 a7 06 	lds	r23, 0x06A7
    49c2:	8a 81       	ldd	r24, Y+2	; 0x02
    49c4:	08 2f       	mov	r16, r24
    49c6:	10 e0       	ldi	r17, 0x00	; 0
    49c8:	8a 81       	ldd	r24, Y+2	; 0x02
    49ca:	88 2f       	mov	r24, r24
    49cc:	90 e0       	ldi	r25, 0x00	; 0
    49ce:	88 0f       	add	r24, r24
    49d0:	99 1f       	adc	r25, r25
    49d2:	88 0f       	add	r24, r24
    49d4:	99 1f       	adc	r25, r25
    49d6:	86 0f       	add	r24, r22
    49d8:	97 1f       	adc	r25, r23
    49da:	fc 01       	movw	r30, r24
    49dc:	b1 96       	adiw	r30, 0x21	; 33
    49de:	20 81       	ld	r18, Z
    49e0:	31 81       	ldd	r19, Z+1	; 0x01
    49e2:	42 81       	ldd	r20, Z+2	; 0x02
    49e4:	53 81       	ldd	r21, Z+3	; 0x03
    49e6:	8b 81       	ldd	r24, Y+3	; 0x03
    49e8:	9c 81       	ldd	r25, Y+4	; 0x04
    49ea:	ad 81       	ldd	r26, Y+5	; 0x05
    49ec:	be 81       	ldd	r27, Y+6	; 0x06
    49ee:	80 95       	com	r24
    49f0:	90 95       	com	r25
    49f2:	a0 95       	com	r26
    49f4:	b0 95       	com	r27
    49f6:	28 23       	and	r18, r24
    49f8:	39 23       	and	r19, r25
    49fa:	4a 23       	and	r20, r26
    49fc:	5b 23       	and	r21, r27
    49fe:	c8 01       	movw	r24, r16
    4a00:	88 0f       	add	r24, r24
    4a02:	99 1f       	adc	r25, r25
    4a04:	88 0f       	add	r24, r24
    4a06:	99 1f       	adc	r25, r25
    4a08:	86 0f       	add	r24, r22
    4a0a:	97 1f       	adc	r25, r23
    4a0c:	fc 01       	movw	r30, r24
    4a0e:	b1 96       	adiw	r30, 0x21	; 33
    4a10:	20 83       	st	Z, r18
    4a12:	31 83       	std	Z+1, r19	; 0x01
    4a14:	42 83       	std	Z+2, r20	; 0x02
    4a16:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4a18:	20 91 a6 06 	lds	r18, 0x06A6
    4a1c:	30 91 a7 06 	lds	r19, 0x06A7
    4a20:	8a 81       	ldd	r24, Y+2	; 0x02
    4a22:	88 2f       	mov	r24, r24
    4a24:	90 e0       	ldi	r25, 0x00	; 0
    4a26:	82 0f       	add	r24, r18
    4a28:	93 1f       	adc	r25, r19
    4a2a:	fc 01       	movw	r30, r24
    4a2c:	b5 96       	adiw	r30, 0x25	; 37
    4a2e:	81 e0       	ldi	r24, 0x01	; 1
    4a30:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    4a32:	8d 85       	ldd	r24, Y+13	; 0x0d
    4a34:	9e 85       	ldd	r25, Y+14	; 0x0e
    4a36:	00 97       	sbiw	r24, 0x00	; 0
    4a38:	39 f0       	breq	.+14     	; 0x4a48 <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4a3a:	8d 85       	ldd	r24, Y+13	; 0x0d
    4a3c:	9e 85       	ldd	r25, Y+14	; 0x0e
    4a3e:	61 e0       	ldi	r22, 0x01	; 1
    4a40:	0e 94 7d 2b 	call	0x56fa	; 0x56fa <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    4a44:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4a48:	0f 90       	pop	r0
    4a4a:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4a4c:	0f b6       	in	r0, 0x3f	; 63
    4a4e:	f8 94       	cli
    4a50:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    4a52:	8b 85       	ldd	r24, Y+11	; 0x0b
    4a54:	9c 85       	ldd	r25, Y+12	; 0x0c
    4a56:	00 97       	sbiw	r24, 0x00	; 0
    4a58:	c9 f0       	breq	.+50     	; 0x4a8c <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    4a5a:	20 91 a6 06 	lds	r18, 0x06A6
    4a5e:	30 91 a7 06 	lds	r19, 0x06A7
    4a62:	8a 81       	ldd	r24, Y+2	; 0x02
    4a64:	88 2f       	mov	r24, r24
    4a66:	90 e0       	ldi	r25, 0x00	; 0
    4a68:	88 0f       	add	r24, r24
    4a6a:	99 1f       	adc	r25, r25
    4a6c:	88 0f       	add	r24, r24
    4a6e:	99 1f       	adc	r25, r25
    4a70:	82 0f       	add	r24, r18
    4a72:	93 1f       	adc	r25, r19
    4a74:	fc 01       	movw	r30, r24
    4a76:	b1 96       	adiw	r30, 0x21	; 33
    4a78:	80 81       	ld	r24, Z
    4a7a:	91 81       	ldd	r25, Z+1	; 0x01
    4a7c:	a2 81       	ldd	r26, Z+2	; 0x02
    4a7e:	b3 81       	ldd	r27, Z+3	; 0x03
    4a80:	eb 85       	ldd	r30, Y+11	; 0x0b
    4a82:	fc 85       	ldd	r31, Y+12	; 0x0c
    4a84:	80 83       	st	Z, r24
    4a86:	91 83       	std	Z+1, r25	; 0x01
    4a88:	a2 83       	std	Z+2, r26	; 0x02
    4a8a:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    4a8c:	20 91 a6 06 	lds	r18, 0x06A6
    4a90:	30 91 a7 06 	lds	r19, 0x06A7
    4a94:	8a 81       	ldd	r24, Y+2	; 0x02
    4a96:	88 2f       	mov	r24, r24
    4a98:	90 e0       	ldi	r25, 0x00	; 0
    4a9a:	82 0f       	add	r24, r18
    4a9c:	93 1f       	adc	r25, r19
    4a9e:	fc 01       	movw	r30, r24
    4aa0:	b5 96       	adiw	r30, 0x25	; 37
    4aa2:	80 81       	ld	r24, Z
    4aa4:	82 30       	cpi	r24, 0x02	; 2
    4aa6:	11 f0       	breq	.+4      	; 0x4aac <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    4aa8:	19 82       	std	Y+1, r1	; 0x01
    4aaa:	31 c0       	rjmp	.+98     	; 0x4b0e <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    4aac:	60 91 a6 06 	lds	r22, 0x06A6
    4ab0:	70 91 a7 06 	lds	r23, 0x06A7
    4ab4:	8a 81       	ldd	r24, Y+2	; 0x02
    4ab6:	08 2f       	mov	r16, r24
    4ab8:	10 e0       	ldi	r17, 0x00	; 0
    4aba:	8a 81       	ldd	r24, Y+2	; 0x02
    4abc:	88 2f       	mov	r24, r24
    4abe:	90 e0       	ldi	r25, 0x00	; 0
    4ac0:	88 0f       	add	r24, r24
    4ac2:	99 1f       	adc	r25, r25
    4ac4:	88 0f       	add	r24, r24
    4ac6:	99 1f       	adc	r25, r25
    4ac8:	86 0f       	add	r24, r22
    4aca:	97 1f       	adc	r25, r23
    4acc:	fc 01       	movw	r30, r24
    4ace:	b1 96       	adiw	r30, 0x21	; 33
    4ad0:	20 81       	ld	r18, Z
    4ad2:	31 81       	ldd	r19, Z+1	; 0x01
    4ad4:	42 81       	ldd	r20, Z+2	; 0x02
    4ad6:	53 81       	ldd	r21, Z+3	; 0x03
    4ad8:	8f 81       	ldd	r24, Y+7	; 0x07
    4ada:	98 85       	ldd	r25, Y+8	; 0x08
    4adc:	a9 85       	ldd	r26, Y+9	; 0x09
    4ade:	ba 85       	ldd	r27, Y+10	; 0x0a
    4ae0:	80 95       	com	r24
    4ae2:	90 95       	com	r25
    4ae4:	a0 95       	com	r26
    4ae6:	b0 95       	com	r27
    4ae8:	28 23       	and	r18, r24
    4aea:	39 23       	and	r19, r25
    4aec:	4a 23       	and	r20, r26
    4aee:	5b 23       	and	r21, r27
    4af0:	c8 01       	movw	r24, r16
    4af2:	88 0f       	add	r24, r24
    4af4:	99 1f       	adc	r25, r25
    4af6:	88 0f       	add	r24, r24
    4af8:	99 1f       	adc	r25, r25
    4afa:	86 0f       	add	r24, r22
    4afc:	97 1f       	adc	r25, r23
    4afe:	fc 01       	movw	r30, r24
    4b00:	b1 96       	adiw	r30, 0x21	; 33
    4b02:	20 83       	st	Z, r18
    4b04:	31 83       	std	Z+1, r19	; 0x01
    4b06:	42 83       	std	Z+2, r20	; 0x02
    4b08:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    4b0a:	81 e0       	ldi	r24, 0x01	; 1
    4b0c:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    4b0e:	20 91 a6 06 	lds	r18, 0x06A6
    4b12:	30 91 a7 06 	lds	r19, 0x06A7
    4b16:	8a 81       	ldd	r24, Y+2	; 0x02
    4b18:	88 2f       	mov	r24, r24
    4b1a:	90 e0       	ldi	r25, 0x00	; 0
    4b1c:	82 0f       	add	r24, r18
    4b1e:	93 1f       	adc	r25, r19
    4b20:	fc 01       	movw	r30, r24
    4b22:	b5 96       	adiw	r30, 0x25	; 37
    4b24:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    4b26:	0f 90       	pop	r0
    4b28:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    4b2a:	89 81       	ldd	r24, Y+1	; 0x01
    }
    4b2c:	2e 96       	adiw	r28, 0x0e	; 14
    4b2e:	0f b6       	in	r0, 0x3f	; 63
    4b30:	f8 94       	cli
    4b32:	de bf       	out	0x3e, r29	; 62
    4b34:	0f be       	out	0x3f, r0	; 63
    4b36:	cd bf       	out	0x3d, r28	; 61
    4b38:	cf 91       	pop	r28
    4b3a:	df 91       	pop	r29
    4b3c:	1f 91       	pop	r17
    4b3e:	0f 91       	pop	r16
    4b40:	ff 90       	pop	r15
    4b42:	ef 90       	pop	r14
    4b44:	df 90       	pop	r13
    4b46:	cf 90       	pop	r12
    4b48:	08 95       	ret

00004b4a <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    4b4a:	ef 92       	push	r14
    4b4c:	ff 92       	push	r15
    4b4e:	0f 93       	push	r16
    4b50:	1f 93       	push	r17
    4b52:	df 93       	push	r29
    4b54:	cf 93       	push	r28
    4b56:	cd b7       	in	r28, 0x3d	; 61
    4b58:	de b7       	in	r29, 0x3e	; 62
    4b5a:	64 97       	sbiw	r28, 0x14	; 20
    4b5c:	0f b6       	in	r0, 0x3f	; 63
    4b5e:	f8 94       	cli
    4b60:	de bf       	out	0x3e, r29	; 62
    4b62:	0f be       	out	0x3f, r0	; 63
    4b64:	cd bf       	out	0x3d, r28	; 61
    4b66:	9a 87       	std	Y+10, r25	; 0x0a
    4b68:	89 87       	std	Y+9, r24	; 0x09
    4b6a:	6b 87       	std	Y+11, r22	; 0x0b
    4b6c:	2c 87       	std	Y+12, r18	; 0x0c
    4b6e:	3d 87       	std	Y+13, r19	; 0x0d
    4b70:	4e 87       	std	Y+14, r20	; 0x0e
    4b72:	5f 87       	std	Y+15, r21	; 0x0f
    4b74:	08 8b       	std	Y+16, r16	; 0x10
    4b76:	fa 8a       	std	Y+18, r15	; 0x12
    4b78:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    4b7a:	81 e0       	ldi	r24, 0x01	; 1
    4b7c:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    4b7e:	89 85       	ldd	r24, Y+9	; 0x09
    4b80:	9a 85       	ldd	r25, Y+10	; 0x0a
    4b82:	98 87       	std	Y+8, r25	; 0x08
    4b84:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    4b86:	0f b6       	in	r0, 0x3f	; 63
    4b88:	f8 94       	cli
    4b8a:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    4b8c:	89 89       	ldd	r24, Y+17	; 0x11
    4b8e:	9a 89       	ldd	r25, Y+18	; 0x12
    4b90:	00 97       	sbiw	r24, 0x00	; 0
    4b92:	b9 f0       	breq	.+46     	; 0x4bc2 <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    4b94:	8b 85       	ldd	r24, Y+11	; 0x0b
    4b96:	88 2f       	mov	r24, r24
    4b98:	90 e0       	ldi	r25, 0x00	; 0
    4b9a:	2f 81       	ldd	r18, Y+7	; 0x07
    4b9c:	38 85       	ldd	r19, Y+8	; 0x08
    4b9e:	88 0f       	add	r24, r24
    4ba0:	99 1f       	adc	r25, r25
    4ba2:	88 0f       	add	r24, r24
    4ba4:	99 1f       	adc	r25, r25
    4ba6:	82 0f       	add	r24, r18
    4ba8:	93 1f       	adc	r25, r19
    4baa:	fc 01       	movw	r30, r24
    4bac:	b1 96       	adiw	r30, 0x21	; 33
    4bae:	80 81       	ld	r24, Z
    4bb0:	91 81       	ldd	r25, Z+1	; 0x01
    4bb2:	a2 81       	ldd	r26, Z+2	; 0x02
    4bb4:	b3 81       	ldd	r27, Z+3	; 0x03
    4bb6:	e9 89       	ldd	r30, Y+17	; 0x11
    4bb8:	fa 89       	ldd	r31, Y+18	; 0x12
    4bba:	80 83       	st	Z, r24
    4bbc:	91 83       	std	Z+1, r25	; 0x01
    4bbe:	a2 83       	std	Z+2, r26	; 0x02
    4bc0:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4bc2:	8b 85       	ldd	r24, Y+11	; 0x0b
    4bc4:	28 2f       	mov	r18, r24
    4bc6:	30 e0       	ldi	r19, 0x00	; 0
    4bc8:	8f 81       	ldd	r24, Y+7	; 0x07
    4bca:	98 85       	ldd	r25, Y+8	; 0x08
    4bcc:	82 0f       	add	r24, r18
    4bce:	93 1f       	adc	r25, r19
    4bd0:	fc 01       	movw	r30, r24
    4bd2:	b5 96       	adiw	r30, 0x25	; 37
    4bd4:	80 81       	ld	r24, Z
    4bd6:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    4bd8:	8b 85       	ldd	r24, Y+11	; 0x0b
    4bda:	28 2f       	mov	r18, r24
    4bdc:	30 e0       	ldi	r19, 0x00	; 0
    4bde:	8f 81       	ldd	r24, Y+7	; 0x07
    4be0:	98 85       	ldd	r25, Y+8	; 0x08
    4be2:	82 0f       	add	r24, r18
    4be4:	93 1f       	adc	r25, r19
    4be6:	fc 01       	movw	r30, r24
    4be8:	b5 96       	adiw	r30, 0x25	; 37
    4bea:	82 e0       	ldi	r24, 0x02	; 2
    4bec:	80 83       	st	Z, r24

            switch( eAction )
    4bee:	88 89       	ldd	r24, Y+16	; 0x10
    4bf0:	28 2f       	mov	r18, r24
    4bf2:	30 e0       	ldi	r19, 0x00	; 0
    4bf4:	3c 8b       	std	Y+20, r19	; 0x14
    4bf6:	2b 8b       	std	Y+19, r18	; 0x13
    4bf8:	8b 89       	ldd	r24, Y+19	; 0x13
    4bfa:	9c 89       	ldd	r25, Y+20	; 0x14
    4bfc:	82 30       	cpi	r24, 0x02	; 2
    4bfe:	91 05       	cpc	r25, r1
    4c00:	09 f4       	brne	.+2      	; 0x4c04 <xTaskGenericNotify+0xba>
    4c02:	46 c0       	rjmp	.+140    	; 0x4c90 <xTaskGenericNotify+0x146>
    4c04:	2b 89       	ldd	r18, Y+19	; 0x13
    4c06:	3c 89       	ldd	r19, Y+20	; 0x14
    4c08:	23 30       	cpi	r18, 0x03	; 3
    4c0a:	31 05       	cpc	r19, r1
    4c0c:	34 f4       	brge	.+12     	; 0x4c1a <xTaskGenericNotify+0xd0>
    4c0e:	8b 89       	ldd	r24, Y+19	; 0x13
    4c10:	9c 89       	ldd	r25, Y+20	; 0x14
    4c12:	81 30       	cpi	r24, 0x01	; 1
    4c14:	91 05       	cpc	r25, r1
    4c16:	71 f0       	breq	.+28     	; 0x4c34 <xTaskGenericNotify+0xea>
    4c18:	93 c0       	rjmp	.+294    	; 0x4d40 <xTaskGenericNotify+0x1f6>
    4c1a:	2b 89       	ldd	r18, Y+19	; 0x13
    4c1c:	3c 89       	ldd	r19, Y+20	; 0x14
    4c1e:	23 30       	cpi	r18, 0x03	; 3
    4c20:	31 05       	cpc	r19, r1
    4c22:	09 f4       	brne	.+2      	; 0x4c26 <xTaskGenericNotify+0xdc>
    4c24:	5d c0       	rjmp	.+186    	; 0x4ce0 <xTaskGenericNotify+0x196>
    4c26:	8b 89       	ldd	r24, Y+19	; 0x13
    4c28:	9c 89       	ldd	r25, Y+20	; 0x14
    4c2a:	84 30       	cpi	r24, 0x04	; 4
    4c2c:	91 05       	cpc	r25, r1
    4c2e:	09 f4       	brne	.+2      	; 0x4c32 <xTaskGenericNotify+0xe8>
    4c30:	6d c0       	rjmp	.+218    	; 0x4d0c <xTaskGenericNotify+0x1c2>
    4c32:	86 c0       	rjmp	.+268    	; 0x4d40 <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    4c34:	8b 85       	ldd	r24, Y+11	; 0x0b
    4c36:	08 2f       	mov	r16, r24
    4c38:	10 e0       	ldi	r17, 0x00	; 0
    4c3a:	8b 85       	ldd	r24, Y+11	; 0x0b
    4c3c:	88 2f       	mov	r24, r24
    4c3e:	90 e0       	ldi	r25, 0x00	; 0
    4c40:	2f 81       	ldd	r18, Y+7	; 0x07
    4c42:	38 85       	ldd	r19, Y+8	; 0x08
    4c44:	88 0f       	add	r24, r24
    4c46:	99 1f       	adc	r25, r25
    4c48:	88 0f       	add	r24, r24
    4c4a:	99 1f       	adc	r25, r25
    4c4c:	82 0f       	add	r24, r18
    4c4e:	93 1f       	adc	r25, r19
    4c50:	fc 01       	movw	r30, r24
    4c52:	b1 96       	adiw	r30, 0x21	; 33
    4c54:	20 81       	ld	r18, Z
    4c56:	31 81       	ldd	r19, Z+1	; 0x01
    4c58:	42 81       	ldd	r20, Z+2	; 0x02
    4c5a:	53 81       	ldd	r21, Z+3	; 0x03
    4c5c:	8c 85       	ldd	r24, Y+12	; 0x0c
    4c5e:	9d 85       	ldd	r25, Y+13	; 0x0d
    4c60:	ae 85       	ldd	r26, Y+14	; 0x0e
    4c62:	bf 85       	ldd	r27, Y+15	; 0x0f
    4c64:	ba 01       	movw	r22, r20
    4c66:	a9 01       	movw	r20, r18
    4c68:	48 2b       	or	r20, r24
    4c6a:	59 2b       	or	r21, r25
    4c6c:	6a 2b       	or	r22, r26
    4c6e:	7b 2b       	or	r23, r27
    4c70:	2f 81       	ldd	r18, Y+7	; 0x07
    4c72:	38 85       	ldd	r19, Y+8	; 0x08
    4c74:	c8 01       	movw	r24, r16
    4c76:	88 0f       	add	r24, r24
    4c78:	99 1f       	adc	r25, r25
    4c7a:	88 0f       	add	r24, r24
    4c7c:	99 1f       	adc	r25, r25
    4c7e:	82 0f       	add	r24, r18
    4c80:	93 1f       	adc	r25, r19
    4c82:	fc 01       	movw	r30, r24
    4c84:	b1 96       	adiw	r30, 0x21	; 33
    4c86:	40 83       	st	Z, r20
    4c88:	51 83       	std	Z+1, r21	; 0x01
    4c8a:	62 83       	std	Z+2, r22	; 0x02
    4c8c:	73 83       	std	Z+3, r23	; 0x03
    4c8e:	58 c0       	rjmp	.+176    	; 0x4d40 <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    4c90:	8b 85       	ldd	r24, Y+11	; 0x0b
    4c92:	08 2f       	mov	r16, r24
    4c94:	10 e0       	ldi	r17, 0x00	; 0
    4c96:	2f 81       	ldd	r18, Y+7	; 0x07
    4c98:	38 85       	ldd	r19, Y+8	; 0x08
    4c9a:	c8 01       	movw	r24, r16
    4c9c:	88 0f       	add	r24, r24
    4c9e:	99 1f       	adc	r25, r25
    4ca0:	88 0f       	add	r24, r24
    4ca2:	99 1f       	adc	r25, r25
    4ca4:	82 0f       	add	r24, r18
    4ca6:	93 1f       	adc	r25, r19
    4ca8:	fc 01       	movw	r30, r24
    4caa:	b1 96       	adiw	r30, 0x21	; 33
    4cac:	80 81       	ld	r24, Z
    4cae:	91 81       	ldd	r25, Z+1	; 0x01
    4cb0:	a2 81       	ldd	r26, Z+2	; 0x02
    4cb2:	b3 81       	ldd	r27, Z+3	; 0x03
    4cb4:	ac 01       	movw	r20, r24
    4cb6:	bd 01       	movw	r22, r26
    4cb8:	4f 5f       	subi	r20, 0xFF	; 255
    4cba:	5f 4f       	sbci	r21, 0xFF	; 255
    4cbc:	6f 4f       	sbci	r22, 0xFF	; 255
    4cbe:	7f 4f       	sbci	r23, 0xFF	; 255
    4cc0:	2f 81       	ldd	r18, Y+7	; 0x07
    4cc2:	38 85       	ldd	r19, Y+8	; 0x08
    4cc4:	c8 01       	movw	r24, r16
    4cc6:	88 0f       	add	r24, r24
    4cc8:	99 1f       	adc	r25, r25
    4cca:	88 0f       	add	r24, r24
    4ccc:	99 1f       	adc	r25, r25
    4cce:	82 0f       	add	r24, r18
    4cd0:	93 1f       	adc	r25, r19
    4cd2:	fc 01       	movw	r30, r24
    4cd4:	b1 96       	adiw	r30, 0x21	; 33
    4cd6:	40 83       	st	Z, r20
    4cd8:	51 83       	std	Z+1, r21	; 0x01
    4cda:	62 83       	std	Z+2, r22	; 0x02
    4cdc:	73 83       	std	Z+3, r23	; 0x03
    4cde:	30 c0       	rjmp	.+96     	; 0x4d40 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4ce0:	8b 85       	ldd	r24, Y+11	; 0x0b
    4ce2:	88 2f       	mov	r24, r24
    4ce4:	90 e0       	ldi	r25, 0x00	; 0
    4ce6:	2f 81       	ldd	r18, Y+7	; 0x07
    4ce8:	38 85       	ldd	r19, Y+8	; 0x08
    4cea:	88 0f       	add	r24, r24
    4cec:	99 1f       	adc	r25, r25
    4cee:	88 0f       	add	r24, r24
    4cf0:	99 1f       	adc	r25, r25
    4cf2:	82 0f       	add	r24, r18
    4cf4:	93 1f       	adc	r25, r19
    4cf6:	fc 01       	movw	r30, r24
    4cf8:	b1 96       	adiw	r30, 0x21	; 33
    4cfa:	8c 85       	ldd	r24, Y+12	; 0x0c
    4cfc:	9d 85       	ldd	r25, Y+13	; 0x0d
    4cfe:	ae 85       	ldd	r26, Y+14	; 0x0e
    4d00:	bf 85       	ldd	r27, Y+15	; 0x0f
    4d02:	80 83       	st	Z, r24
    4d04:	91 83       	std	Z+1, r25	; 0x01
    4d06:	a2 83       	std	Z+2, r26	; 0x02
    4d08:	b3 83       	std	Z+3, r27	; 0x03
    4d0a:	1a c0       	rjmp	.+52     	; 0x4d40 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4d0c:	8d 81       	ldd	r24, Y+5	; 0x05
    4d0e:	82 30       	cpi	r24, 0x02	; 2
    4d10:	b1 f0       	breq	.+44     	; 0x4d3e <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4d12:	8b 85       	ldd	r24, Y+11	; 0x0b
    4d14:	88 2f       	mov	r24, r24
    4d16:	90 e0       	ldi	r25, 0x00	; 0
    4d18:	2f 81       	ldd	r18, Y+7	; 0x07
    4d1a:	38 85       	ldd	r19, Y+8	; 0x08
    4d1c:	88 0f       	add	r24, r24
    4d1e:	99 1f       	adc	r25, r25
    4d20:	88 0f       	add	r24, r24
    4d22:	99 1f       	adc	r25, r25
    4d24:	82 0f       	add	r24, r18
    4d26:	93 1f       	adc	r25, r19
    4d28:	fc 01       	movw	r30, r24
    4d2a:	b1 96       	adiw	r30, 0x21	; 33
    4d2c:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d2e:	9d 85       	ldd	r25, Y+13	; 0x0d
    4d30:	ae 85       	ldd	r26, Y+14	; 0x0e
    4d32:	bf 85       	ldd	r27, Y+15	; 0x0f
    4d34:	80 83       	st	Z, r24
    4d36:	91 83       	std	Z+1, r25	; 0x01
    4d38:	a2 83       	std	Z+2, r26	; 0x02
    4d3a:	b3 83       	std	Z+3, r27	; 0x03
    4d3c:	01 c0       	rjmp	.+2      	; 0x4d40 <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    4d3e:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4d40:	8d 81       	ldd	r24, Y+5	; 0x05
    4d42:	81 30       	cpi	r24, 0x01	; 1
    4d44:	09 f0       	breq	.+2      	; 0x4d48 <xTaskGenericNotify+0x1fe>
    4d46:	af c0       	rjmp	.+350    	; 0x4ea6 <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    4d48:	ef 81       	ldd	r30, Y+7	; 0x07
    4d4a:	f8 85       	ldd	r31, Y+8	; 0x08
    4d4c:	82 85       	ldd	r24, Z+10	; 0x0a
    4d4e:	93 85       	ldd	r25, Z+11	; 0x0b
    4d50:	9c 83       	std	Y+4, r25	; 0x04
    4d52:	8b 83       	std	Y+3, r24	; 0x03
    4d54:	ef 81       	ldd	r30, Y+7	; 0x07
    4d56:	f8 85       	ldd	r31, Y+8	; 0x08
    4d58:	a4 81       	ldd	r26, Z+4	; 0x04
    4d5a:	b5 81       	ldd	r27, Z+5	; 0x05
    4d5c:	ef 81       	ldd	r30, Y+7	; 0x07
    4d5e:	f8 85       	ldd	r31, Y+8	; 0x08
    4d60:	86 81       	ldd	r24, Z+6	; 0x06
    4d62:	97 81       	ldd	r25, Z+7	; 0x07
    4d64:	15 96       	adiw	r26, 0x05	; 5
    4d66:	9c 93       	st	X, r25
    4d68:	8e 93       	st	-X, r24
    4d6a:	14 97       	sbiw	r26, 0x04	; 4
    4d6c:	ef 81       	ldd	r30, Y+7	; 0x07
    4d6e:	f8 85       	ldd	r31, Y+8	; 0x08
    4d70:	a6 81       	ldd	r26, Z+6	; 0x06
    4d72:	b7 81       	ldd	r27, Z+7	; 0x07
    4d74:	ef 81       	ldd	r30, Y+7	; 0x07
    4d76:	f8 85       	ldd	r31, Y+8	; 0x08
    4d78:	84 81       	ldd	r24, Z+4	; 0x04
    4d7a:	95 81       	ldd	r25, Z+5	; 0x05
    4d7c:	13 96       	adiw	r26, 0x03	; 3
    4d7e:	9c 93       	st	X, r25
    4d80:	8e 93       	st	-X, r24
    4d82:	12 97       	sbiw	r26, 0x02	; 2
    4d84:	eb 81       	ldd	r30, Y+3	; 0x03
    4d86:	fc 81       	ldd	r31, Y+4	; 0x04
    4d88:	21 81       	ldd	r18, Z+1	; 0x01
    4d8a:	32 81       	ldd	r19, Z+2	; 0x02
    4d8c:	8f 81       	ldd	r24, Y+7	; 0x07
    4d8e:	98 85       	ldd	r25, Y+8	; 0x08
    4d90:	02 96       	adiw	r24, 0x02	; 2
    4d92:	28 17       	cp	r18, r24
    4d94:	39 07       	cpc	r19, r25
    4d96:	41 f4       	brne	.+16     	; 0x4da8 <xTaskGenericNotify+0x25e>
    4d98:	ef 81       	ldd	r30, Y+7	; 0x07
    4d9a:	f8 85       	ldd	r31, Y+8	; 0x08
    4d9c:	86 81       	ldd	r24, Z+6	; 0x06
    4d9e:	97 81       	ldd	r25, Z+7	; 0x07
    4da0:	eb 81       	ldd	r30, Y+3	; 0x03
    4da2:	fc 81       	ldd	r31, Y+4	; 0x04
    4da4:	92 83       	std	Z+2, r25	; 0x02
    4da6:	81 83       	std	Z+1, r24	; 0x01
    4da8:	ef 81       	ldd	r30, Y+7	; 0x07
    4daa:	f8 85       	ldd	r31, Y+8	; 0x08
    4dac:	13 86       	std	Z+11, r1	; 0x0b
    4dae:	12 86       	std	Z+10, r1	; 0x0a
    4db0:	eb 81       	ldd	r30, Y+3	; 0x03
    4db2:	fc 81       	ldd	r31, Y+4	; 0x04
    4db4:	80 81       	ld	r24, Z
    4db6:	81 50       	subi	r24, 0x01	; 1
    4db8:	eb 81       	ldd	r30, Y+3	; 0x03
    4dba:	fc 81       	ldd	r31, Y+4	; 0x04
    4dbc:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    4dbe:	ef 81       	ldd	r30, Y+7	; 0x07
    4dc0:	f8 85       	ldd	r31, Y+8	; 0x08
    4dc2:	96 89       	ldd	r25, Z+22	; 0x16
    4dc4:	80 91 ac 06 	lds	r24, 0x06AC
    4dc8:	89 17       	cp	r24, r25
    4dca:	28 f4       	brcc	.+10     	; 0x4dd6 <xTaskGenericNotify+0x28c>
    4dcc:	ef 81       	ldd	r30, Y+7	; 0x07
    4dce:	f8 85       	ldd	r31, Y+8	; 0x08
    4dd0:	86 89       	ldd	r24, Z+22	; 0x16
    4dd2:	80 93 ac 06 	sts	0x06AC, r24
    4dd6:	ef 81       	ldd	r30, Y+7	; 0x07
    4dd8:	f8 85       	ldd	r31, Y+8	; 0x08
    4dda:	86 89       	ldd	r24, Z+22	; 0x16
    4ddc:	28 2f       	mov	r18, r24
    4dde:	30 e0       	ldi	r19, 0x00	; 0
    4de0:	c9 01       	movw	r24, r18
    4de2:	88 0f       	add	r24, r24
    4de4:	99 1f       	adc	r25, r25
    4de6:	88 0f       	add	r24, r24
    4de8:	99 1f       	adc	r25, r25
    4dea:	88 0f       	add	r24, r24
    4dec:	99 1f       	adc	r25, r25
    4dee:	82 0f       	add	r24, r18
    4df0:	93 1f       	adc	r25, r19
    4df2:	fc 01       	movw	r30, r24
    4df4:	e8 54       	subi	r30, 0x48	; 72
    4df6:	f9 4f       	sbci	r31, 0xF9	; 249
    4df8:	81 81       	ldd	r24, Z+1	; 0x01
    4dfa:	92 81       	ldd	r25, Z+2	; 0x02
    4dfc:	9a 83       	std	Y+2, r25	; 0x02
    4dfe:	89 83       	std	Y+1, r24	; 0x01
    4e00:	ef 81       	ldd	r30, Y+7	; 0x07
    4e02:	f8 85       	ldd	r31, Y+8	; 0x08
    4e04:	89 81       	ldd	r24, Y+1	; 0x01
    4e06:	9a 81       	ldd	r25, Y+2	; 0x02
    4e08:	95 83       	std	Z+5, r25	; 0x05
    4e0a:	84 83       	std	Z+4, r24	; 0x04
    4e0c:	e9 81       	ldd	r30, Y+1	; 0x01
    4e0e:	fa 81       	ldd	r31, Y+2	; 0x02
    4e10:	84 81       	ldd	r24, Z+4	; 0x04
    4e12:	95 81       	ldd	r25, Z+5	; 0x05
    4e14:	ef 81       	ldd	r30, Y+7	; 0x07
    4e16:	f8 85       	ldd	r31, Y+8	; 0x08
    4e18:	97 83       	std	Z+7, r25	; 0x07
    4e1a:	86 83       	std	Z+6, r24	; 0x06
    4e1c:	e9 81       	ldd	r30, Y+1	; 0x01
    4e1e:	fa 81       	ldd	r31, Y+2	; 0x02
    4e20:	04 80       	ldd	r0, Z+4	; 0x04
    4e22:	f5 81       	ldd	r31, Z+5	; 0x05
    4e24:	e0 2d       	mov	r30, r0
    4e26:	8f 81       	ldd	r24, Y+7	; 0x07
    4e28:	98 85       	ldd	r25, Y+8	; 0x08
    4e2a:	02 96       	adiw	r24, 0x02	; 2
    4e2c:	93 83       	std	Z+3, r25	; 0x03
    4e2e:	82 83       	std	Z+2, r24	; 0x02
    4e30:	8f 81       	ldd	r24, Y+7	; 0x07
    4e32:	98 85       	ldd	r25, Y+8	; 0x08
    4e34:	02 96       	adiw	r24, 0x02	; 2
    4e36:	e9 81       	ldd	r30, Y+1	; 0x01
    4e38:	fa 81       	ldd	r31, Y+2	; 0x02
    4e3a:	95 83       	std	Z+5, r25	; 0x05
    4e3c:	84 83       	std	Z+4, r24	; 0x04
    4e3e:	ef 81       	ldd	r30, Y+7	; 0x07
    4e40:	f8 85       	ldd	r31, Y+8	; 0x08
    4e42:	86 89       	ldd	r24, Z+22	; 0x16
    4e44:	28 2f       	mov	r18, r24
    4e46:	30 e0       	ldi	r19, 0x00	; 0
    4e48:	c9 01       	movw	r24, r18
    4e4a:	88 0f       	add	r24, r24
    4e4c:	99 1f       	adc	r25, r25
    4e4e:	88 0f       	add	r24, r24
    4e50:	99 1f       	adc	r25, r25
    4e52:	88 0f       	add	r24, r24
    4e54:	99 1f       	adc	r25, r25
    4e56:	82 0f       	add	r24, r18
    4e58:	93 1f       	adc	r25, r19
    4e5a:	88 54       	subi	r24, 0x48	; 72
    4e5c:	99 4f       	sbci	r25, 0xF9	; 249
    4e5e:	ef 81       	ldd	r30, Y+7	; 0x07
    4e60:	f8 85       	ldd	r31, Y+8	; 0x08
    4e62:	93 87       	std	Z+11, r25	; 0x0b
    4e64:	82 87       	std	Z+10, r24	; 0x0a
    4e66:	ef 81       	ldd	r30, Y+7	; 0x07
    4e68:	f8 85       	ldd	r31, Y+8	; 0x08
    4e6a:	86 89       	ldd	r24, Z+22	; 0x16
    4e6c:	28 2f       	mov	r18, r24
    4e6e:	30 e0       	ldi	r19, 0x00	; 0
    4e70:	c9 01       	movw	r24, r18
    4e72:	88 0f       	add	r24, r24
    4e74:	99 1f       	adc	r25, r25
    4e76:	88 0f       	add	r24, r24
    4e78:	99 1f       	adc	r25, r25
    4e7a:	88 0f       	add	r24, r24
    4e7c:	99 1f       	adc	r25, r25
    4e7e:	82 0f       	add	r24, r18
    4e80:	93 1f       	adc	r25, r19
    4e82:	fc 01       	movw	r30, r24
    4e84:	e8 54       	subi	r30, 0x48	; 72
    4e86:	f9 4f       	sbci	r31, 0xF9	; 249
    4e88:	80 81       	ld	r24, Z
    4e8a:	8f 5f       	subi	r24, 0xFF	; 255
    4e8c:	80 83       	st	Z, r24
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4e8e:	ef 81       	ldd	r30, Y+7	; 0x07
    4e90:	f8 85       	ldd	r31, Y+8	; 0x08
    4e92:	96 89       	ldd	r25, Z+22	; 0x16
    4e94:	e0 91 a6 06 	lds	r30, 0x06A6
    4e98:	f0 91 a7 06 	lds	r31, 0x06A7
    4e9c:	86 89       	ldd	r24, Z+22	; 0x16
    4e9e:	89 17       	cp	r24, r25
    4ea0:	10 f4       	brcc	.+4      	; 0x4ea6 <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    4ea2:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4ea6:	0f 90       	pop	r0
    4ea8:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    4eaa:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    4eac:	64 96       	adiw	r28, 0x14	; 20
    4eae:	0f b6       	in	r0, 0x3f	; 63
    4eb0:	f8 94       	cli
    4eb2:	de bf       	out	0x3e, r29	; 62
    4eb4:	0f be       	out	0x3f, r0	; 63
    4eb6:	cd bf       	out	0x3d, r28	; 61
    4eb8:	cf 91       	pop	r28
    4eba:	df 91       	pop	r29
    4ebc:	1f 91       	pop	r17
    4ebe:	0f 91       	pop	r16
    4ec0:	ff 90       	pop	r15
    4ec2:	ef 90       	pop	r14
    4ec4:	08 95       	ret

00004ec6 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    4ec6:	cf 92       	push	r12
    4ec8:	df 92       	push	r13
    4eca:	ef 92       	push	r14
    4ecc:	ff 92       	push	r15
    4ece:	0f 93       	push	r16
    4ed0:	1f 93       	push	r17
    4ed2:	df 93       	push	r29
    4ed4:	cf 93       	push	r28
    4ed6:	cd b7       	in	r28, 0x3d	; 61
    4ed8:	de b7       	in	r29, 0x3e	; 62
    4eda:	69 97       	sbiw	r28, 0x19	; 25
    4edc:	0f b6       	in	r0, 0x3f	; 63
    4ede:	f8 94       	cli
    4ee0:	de bf       	out	0x3e, r29	; 62
    4ee2:	0f be       	out	0x3f, r0	; 63
    4ee4:	cd bf       	out	0x3d, r28	; 61
    4ee6:	9d 87       	std	Y+13, r25	; 0x0d
    4ee8:	8c 87       	std	Y+12, r24	; 0x0c
    4eea:	6e 87       	std	Y+14, r22	; 0x0e
    4eec:	2f 87       	std	Y+15, r18	; 0x0f
    4eee:	38 8b       	std	Y+16, r19	; 0x10
    4ef0:	49 8b       	std	Y+17, r20	; 0x11
    4ef2:	5a 8b       	std	Y+18, r21	; 0x12
    4ef4:	0b 8b       	std	Y+19, r16	; 0x13
    4ef6:	fd 8a       	std	Y+21, r15	; 0x15
    4ef8:	ec 8a       	std	Y+20, r14	; 0x14
    4efa:	df 8a       	std	Y+23, r13	; 0x17
    4efc:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    4efe:	81 e0       	ldi	r24, 0x01	; 1
    4f00:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    4f02:	8c 85       	ldd	r24, Y+12	; 0x0c
    4f04:	9d 85       	ldd	r25, Y+13	; 0x0d
    4f06:	9b 87       	std	Y+11, r25	; 0x0b
    4f08:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4f0a:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    4f0c:	8c 89       	ldd	r24, Y+20	; 0x14
    4f0e:	9d 89       	ldd	r25, Y+21	; 0x15
    4f10:	00 97       	sbiw	r24, 0x00	; 0
    4f12:	b9 f0       	breq	.+46     	; 0x4f42 <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    4f14:	8e 85       	ldd	r24, Y+14	; 0x0e
    4f16:	88 2f       	mov	r24, r24
    4f18:	90 e0       	ldi	r25, 0x00	; 0
    4f1a:	2a 85       	ldd	r18, Y+10	; 0x0a
    4f1c:	3b 85       	ldd	r19, Y+11	; 0x0b
    4f1e:	88 0f       	add	r24, r24
    4f20:	99 1f       	adc	r25, r25
    4f22:	88 0f       	add	r24, r24
    4f24:	99 1f       	adc	r25, r25
    4f26:	82 0f       	add	r24, r18
    4f28:	93 1f       	adc	r25, r19
    4f2a:	fc 01       	movw	r30, r24
    4f2c:	b1 96       	adiw	r30, 0x21	; 33
    4f2e:	80 81       	ld	r24, Z
    4f30:	91 81       	ldd	r25, Z+1	; 0x01
    4f32:	a2 81       	ldd	r26, Z+2	; 0x02
    4f34:	b3 81       	ldd	r27, Z+3	; 0x03
    4f36:	ec 89       	ldd	r30, Y+20	; 0x14
    4f38:	fd 89       	ldd	r31, Y+21	; 0x15
    4f3a:	80 83       	st	Z, r24
    4f3c:	91 83       	std	Z+1, r25	; 0x01
    4f3e:	a2 83       	std	Z+2, r26	; 0x02
    4f40:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4f42:	8e 85       	ldd	r24, Y+14	; 0x0e
    4f44:	28 2f       	mov	r18, r24
    4f46:	30 e0       	ldi	r19, 0x00	; 0
    4f48:	8a 85       	ldd	r24, Y+10	; 0x0a
    4f4a:	9b 85       	ldd	r25, Y+11	; 0x0b
    4f4c:	82 0f       	add	r24, r18
    4f4e:	93 1f       	adc	r25, r19
    4f50:	fc 01       	movw	r30, r24
    4f52:	b5 96       	adiw	r30, 0x25	; 37
    4f54:	80 81       	ld	r24, Z
    4f56:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    4f58:	8e 85       	ldd	r24, Y+14	; 0x0e
    4f5a:	28 2f       	mov	r18, r24
    4f5c:	30 e0       	ldi	r19, 0x00	; 0
    4f5e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4f60:	9b 85       	ldd	r25, Y+11	; 0x0b
    4f62:	82 0f       	add	r24, r18
    4f64:	93 1f       	adc	r25, r19
    4f66:	fc 01       	movw	r30, r24
    4f68:	b5 96       	adiw	r30, 0x25	; 37
    4f6a:	82 e0       	ldi	r24, 0x02	; 2
    4f6c:	80 83       	st	Z, r24

            switch( eAction )
    4f6e:	8b 89       	ldd	r24, Y+19	; 0x13
    4f70:	28 2f       	mov	r18, r24
    4f72:	30 e0       	ldi	r19, 0x00	; 0
    4f74:	39 8f       	std	Y+25, r19	; 0x19
    4f76:	28 8f       	std	Y+24, r18	; 0x18
    4f78:	88 8d       	ldd	r24, Y+24	; 0x18
    4f7a:	99 8d       	ldd	r25, Y+25	; 0x19
    4f7c:	82 30       	cpi	r24, 0x02	; 2
    4f7e:	91 05       	cpc	r25, r1
    4f80:	09 f4       	brne	.+2      	; 0x4f84 <xTaskGenericNotifyFromISR+0xbe>
    4f82:	46 c0       	rjmp	.+140    	; 0x5010 <xTaskGenericNotifyFromISR+0x14a>
    4f84:	28 8d       	ldd	r18, Y+24	; 0x18
    4f86:	39 8d       	ldd	r19, Y+25	; 0x19
    4f88:	23 30       	cpi	r18, 0x03	; 3
    4f8a:	31 05       	cpc	r19, r1
    4f8c:	34 f4       	brge	.+12     	; 0x4f9a <xTaskGenericNotifyFromISR+0xd4>
    4f8e:	88 8d       	ldd	r24, Y+24	; 0x18
    4f90:	99 8d       	ldd	r25, Y+25	; 0x19
    4f92:	81 30       	cpi	r24, 0x01	; 1
    4f94:	91 05       	cpc	r25, r1
    4f96:	71 f0       	breq	.+28     	; 0x4fb4 <xTaskGenericNotifyFromISR+0xee>
    4f98:	93 c0       	rjmp	.+294    	; 0x50c0 <xTaskGenericNotifyFromISR+0x1fa>
    4f9a:	28 8d       	ldd	r18, Y+24	; 0x18
    4f9c:	39 8d       	ldd	r19, Y+25	; 0x19
    4f9e:	23 30       	cpi	r18, 0x03	; 3
    4fa0:	31 05       	cpc	r19, r1
    4fa2:	09 f4       	brne	.+2      	; 0x4fa6 <xTaskGenericNotifyFromISR+0xe0>
    4fa4:	5d c0       	rjmp	.+186    	; 0x5060 <xTaskGenericNotifyFromISR+0x19a>
    4fa6:	88 8d       	ldd	r24, Y+24	; 0x18
    4fa8:	99 8d       	ldd	r25, Y+25	; 0x19
    4faa:	84 30       	cpi	r24, 0x04	; 4
    4fac:	91 05       	cpc	r25, r1
    4fae:	09 f4       	brne	.+2      	; 0x4fb2 <xTaskGenericNotifyFromISR+0xec>
    4fb0:	6d c0       	rjmp	.+218    	; 0x508c <xTaskGenericNotifyFromISR+0x1c6>
    4fb2:	86 c0       	rjmp	.+268    	; 0x50c0 <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    4fb4:	8e 85       	ldd	r24, Y+14	; 0x0e
    4fb6:	08 2f       	mov	r16, r24
    4fb8:	10 e0       	ldi	r17, 0x00	; 0
    4fba:	8e 85       	ldd	r24, Y+14	; 0x0e
    4fbc:	88 2f       	mov	r24, r24
    4fbe:	90 e0       	ldi	r25, 0x00	; 0
    4fc0:	2a 85       	ldd	r18, Y+10	; 0x0a
    4fc2:	3b 85       	ldd	r19, Y+11	; 0x0b
    4fc4:	88 0f       	add	r24, r24
    4fc6:	99 1f       	adc	r25, r25
    4fc8:	88 0f       	add	r24, r24
    4fca:	99 1f       	adc	r25, r25
    4fcc:	82 0f       	add	r24, r18
    4fce:	93 1f       	adc	r25, r19
    4fd0:	fc 01       	movw	r30, r24
    4fd2:	b1 96       	adiw	r30, 0x21	; 33
    4fd4:	20 81       	ld	r18, Z
    4fd6:	31 81       	ldd	r19, Z+1	; 0x01
    4fd8:	42 81       	ldd	r20, Z+2	; 0x02
    4fda:	53 81       	ldd	r21, Z+3	; 0x03
    4fdc:	8f 85       	ldd	r24, Y+15	; 0x0f
    4fde:	98 89       	ldd	r25, Y+16	; 0x10
    4fe0:	a9 89       	ldd	r26, Y+17	; 0x11
    4fe2:	ba 89       	ldd	r27, Y+18	; 0x12
    4fe4:	ba 01       	movw	r22, r20
    4fe6:	a9 01       	movw	r20, r18
    4fe8:	48 2b       	or	r20, r24
    4fea:	59 2b       	or	r21, r25
    4fec:	6a 2b       	or	r22, r26
    4fee:	7b 2b       	or	r23, r27
    4ff0:	2a 85       	ldd	r18, Y+10	; 0x0a
    4ff2:	3b 85       	ldd	r19, Y+11	; 0x0b
    4ff4:	c8 01       	movw	r24, r16
    4ff6:	88 0f       	add	r24, r24
    4ff8:	99 1f       	adc	r25, r25
    4ffa:	88 0f       	add	r24, r24
    4ffc:	99 1f       	adc	r25, r25
    4ffe:	82 0f       	add	r24, r18
    5000:	93 1f       	adc	r25, r19
    5002:	fc 01       	movw	r30, r24
    5004:	b1 96       	adiw	r30, 0x21	; 33
    5006:	40 83       	st	Z, r20
    5008:	51 83       	std	Z+1, r21	; 0x01
    500a:	62 83       	std	Z+2, r22	; 0x02
    500c:	73 83       	std	Z+3, r23	; 0x03
    500e:	58 c0       	rjmp	.+176    	; 0x50c0 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    5010:	8e 85       	ldd	r24, Y+14	; 0x0e
    5012:	08 2f       	mov	r16, r24
    5014:	10 e0       	ldi	r17, 0x00	; 0
    5016:	2a 85       	ldd	r18, Y+10	; 0x0a
    5018:	3b 85       	ldd	r19, Y+11	; 0x0b
    501a:	c8 01       	movw	r24, r16
    501c:	88 0f       	add	r24, r24
    501e:	99 1f       	adc	r25, r25
    5020:	88 0f       	add	r24, r24
    5022:	99 1f       	adc	r25, r25
    5024:	82 0f       	add	r24, r18
    5026:	93 1f       	adc	r25, r19
    5028:	fc 01       	movw	r30, r24
    502a:	b1 96       	adiw	r30, 0x21	; 33
    502c:	80 81       	ld	r24, Z
    502e:	91 81       	ldd	r25, Z+1	; 0x01
    5030:	a2 81       	ldd	r26, Z+2	; 0x02
    5032:	b3 81       	ldd	r27, Z+3	; 0x03
    5034:	ac 01       	movw	r20, r24
    5036:	bd 01       	movw	r22, r26
    5038:	4f 5f       	subi	r20, 0xFF	; 255
    503a:	5f 4f       	sbci	r21, 0xFF	; 255
    503c:	6f 4f       	sbci	r22, 0xFF	; 255
    503e:	7f 4f       	sbci	r23, 0xFF	; 255
    5040:	2a 85       	ldd	r18, Y+10	; 0x0a
    5042:	3b 85       	ldd	r19, Y+11	; 0x0b
    5044:	c8 01       	movw	r24, r16
    5046:	88 0f       	add	r24, r24
    5048:	99 1f       	adc	r25, r25
    504a:	88 0f       	add	r24, r24
    504c:	99 1f       	adc	r25, r25
    504e:	82 0f       	add	r24, r18
    5050:	93 1f       	adc	r25, r19
    5052:	fc 01       	movw	r30, r24
    5054:	b1 96       	adiw	r30, 0x21	; 33
    5056:	40 83       	st	Z, r20
    5058:	51 83       	std	Z+1, r21	; 0x01
    505a:	62 83       	std	Z+2, r22	; 0x02
    505c:	73 83       	std	Z+3, r23	; 0x03
    505e:	30 c0       	rjmp	.+96     	; 0x50c0 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5060:	8e 85       	ldd	r24, Y+14	; 0x0e
    5062:	88 2f       	mov	r24, r24
    5064:	90 e0       	ldi	r25, 0x00	; 0
    5066:	2a 85       	ldd	r18, Y+10	; 0x0a
    5068:	3b 85       	ldd	r19, Y+11	; 0x0b
    506a:	88 0f       	add	r24, r24
    506c:	99 1f       	adc	r25, r25
    506e:	88 0f       	add	r24, r24
    5070:	99 1f       	adc	r25, r25
    5072:	82 0f       	add	r24, r18
    5074:	93 1f       	adc	r25, r19
    5076:	fc 01       	movw	r30, r24
    5078:	b1 96       	adiw	r30, 0x21	; 33
    507a:	8f 85       	ldd	r24, Y+15	; 0x0f
    507c:	98 89       	ldd	r25, Y+16	; 0x10
    507e:	a9 89       	ldd	r26, Y+17	; 0x11
    5080:	ba 89       	ldd	r27, Y+18	; 0x12
    5082:	80 83       	st	Z, r24
    5084:	91 83       	std	Z+1, r25	; 0x01
    5086:	a2 83       	std	Z+2, r26	; 0x02
    5088:	b3 83       	std	Z+3, r27	; 0x03
    508a:	1a c0       	rjmp	.+52     	; 0x50c0 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    508c:	89 85       	ldd	r24, Y+9	; 0x09
    508e:	82 30       	cpi	r24, 0x02	; 2
    5090:	b1 f0       	breq	.+44     	; 0x50be <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5092:	8e 85       	ldd	r24, Y+14	; 0x0e
    5094:	88 2f       	mov	r24, r24
    5096:	90 e0       	ldi	r25, 0x00	; 0
    5098:	2a 85       	ldd	r18, Y+10	; 0x0a
    509a:	3b 85       	ldd	r19, Y+11	; 0x0b
    509c:	88 0f       	add	r24, r24
    509e:	99 1f       	adc	r25, r25
    50a0:	88 0f       	add	r24, r24
    50a2:	99 1f       	adc	r25, r25
    50a4:	82 0f       	add	r24, r18
    50a6:	93 1f       	adc	r25, r19
    50a8:	fc 01       	movw	r30, r24
    50aa:	b1 96       	adiw	r30, 0x21	; 33
    50ac:	8f 85       	ldd	r24, Y+15	; 0x0f
    50ae:	98 89       	ldd	r25, Y+16	; 0x10
    50b0:	a9 89       	ldd	r26, Y+17	; 0x11
    50b2:	ba 89       	ldd	r27, Y+18	; 0x12
    50b4:	80 83       	st	Z, r24
    50b6:	91 83       	std	Z+1, r25	; 0x01
    50b8:	a2 83       	std	Z+2, r26	; 0x02
    50ba:	b3 83       	std	Z+3, r27	; 0x03
    50bc:	01 c0       	rjmp	.+2      	; 0x50c0 <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    50be:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    50c0:	89 85       	ldd	r24, Y+9	; 0x09
    50c2:	81 30       	cpi	r24, 0x01	; 1
    50c4:	09 f0       	breq	.+2      	; 0x50c8 <xTaskGenericNotifyFromISR+0x202>
    50c6:	ee c0       	rjmp	.+476    	; 0x52a4 <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    50c8:	80 91 b7 06 	lds	r24, 0x06B7
    50cc:	88 23       	and	r24, r24
    50ce:	09 f0       	breq	.+2      	; 0x50d2 <xTaskGenericNotifyFromISR+0x20c>
    50d0:	a4 c0       	rjmp	.+328    	; 0x521a <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    50d2:	ea 85       	ldd	r30, Y+10	; 0x0a
    50d4:	fb 85       	ldd	r31, Y+11	; 0x0b
    50d6:	82 85       	ldd	r24, Z+10	; 0x0a
    50d8:	93 85       	ldd	r25, Z+11	; 0x0b
    50da:	9e 83       	std	Y+6, r25	; 0x06
    50dc:	8d 83       	std	Y+5, r24	; 0x05
    50de:	ea 85       	ldd	r30, Y+10	; 0x0a
    50e0:	fb 85       	ldd	r31, Y+11	; 0x0b
    50e2:	a4 81       	ldd	r26, Z+4	; 0x04
    50e4:	b5 81       	ldd	r27, Z+5	; 0x05
    50e6:	ea 85       	ldd	r30, Y+10	; 0x0a
    50e8:	fb 85       	ldd	r31, Y+11	; 0x0b
    50ea:	86 81       	ldd	r24, Z+6	; 0x06
    50ec:	97 81       	ldd	r25, Z+7	; 0x07
    50ee:	15 96       	adiw	r26, 0x05	; 5
    50f0:	9c 93       	st	X, r25
    50f2:	8e 93       	st	-X, r24
    50f4:	14 97       	sbiw	r26, 0x04	; 4
    50f6:	ea 85       	ldd	r30, Y+10	; 0x0a
    50f8:	fb 85       	ldd	r31, Y+11	; 0x0b
    50fa:	a6 81       	ldd	r26, Z+6	; 0x06
    50fc:	b7 81       	ldd	r27, Z+7	; 0x07
    50fe:	ea 85       	ldd	r30, Y+10	; 0x0a
    5100:	fb 85       	ldd	r31, Y+11	; 0x0b
    5102:	84 81       	ldd	r24, Z+4	; 0x04
    5104:	95 81       	ldd	r25, Z+5	; 0x05
    5106:	13 96       	adiw	r26, 0x03	; 3
    5108:	9c 93       	st	X, r25
    510a:	8e 93       	st	-X, r24
    510c:	12 97       	sbiw	r26, 0x02	; 2
    510e:	ed 81       	ldd	r30, Y+5	; 0x05
    5110:	fe 81       	ldd	r31, Y+6	; 0x06
    5112:	21 81       	ldd	r18, Z+1	; 0x01
    5114:	32 81       	ldd	r19, Z+2	; 0x02
    5116:	8a 85       	ldd	r24, Y+10	; 0x0a
    5118:	9b 85       	ldd	r25, Y+11	; 0x0b
    511a:	02 96       	adiw	r24, 0x02	; 2
    511c:	28 17       	cp	r18, r24
    511e:	39 07       	cpc	r19, r25
    5120:	41 f4       	brne	.+16     	; 0x5132 <xTaskGenericNotifyFromISR+0x26c>
    5122:	ea 85       	ldd	r30, Y+10	; 0x0a
    5124:	fb 85       	ldd	r31, Y+11	; 0x0b
    5126:	86 81       	ldd	r24, Z+6	; 0x06
    5128:	97 81       	ldd	r25, Z+7	; 0x07
    512a:	ed 81       	ldd	r30, Y+5	; 0x05
    512c:	fe 81       	ldd	r31, Y+6	; 0x06
    512e:	92 83       	std	Z+2, r25	; 0x02
    5130:	81 83       	std	Z+1, r24	; 0x01
    5132:	ea 85       	ldd	r30, Y+10	; 0x0a
    5134:	fb 85       	ldd	r31, Y+11	; 0x0b
    5136:	13 86       	std	Z+11, r1	; 0x0b
    5138:	12 86       	std	Z+10, r1	; 0x0a
    513a:	ed 81       	ldd	r30, Y+5	; 0x05
    513c:	fe 81       	ldd	r31, Y+6	; 0x06
    513e:	80 81       	ld	r24, Z
    5140:	81 50       	subi	r24, 0x01	; 1
    5142:	ed 81       	ldd	r30, Y+5	; 0x05
    5144:	fe 81       	ldd	r31, Y+6	; 0x06
    5146:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5148:	ea 85       	ldd	r30, Y+10	; 0x0a
    514a:	fb 85       	ldd	r31, Y+11	; 0x0b
    514c:	96 89       	ldd	r25, Z+22	; 0x16
    514e:	80 91 ac 06 	lds	r24, 0x06AC
    5152:	89 17       	cp	r24, r25
    5154:	28 f4       	brcc	.+10     	; 0x5160 <xTaskGenericNotifyFromISR+0x29a>
    5156:	ea 85       	ldd	r30, Y+10	; 0x0a
    5158:	fb 85       	ldd	r31, Y+11	; 0x0b
    515a:	86 89       	ldd	r24, Z+22	; 0x16
    515c:	80 93 ac 06 	sts	0x06AC, r24
    5160:	ea 85       	ldd	r30, Y+10	; 0x0a
    5162:	fb 85       	ldd	r31, Y+11	; 0x0b
    5164:	86 89       	ldd	r24, Z+22	; 0x16
    5166:	28 2f       	mov	r18, r24
    5168:	30 e0       	ldi	r19, 0x00	; 0
    516a:	c9 01       	movw	r24, r18
    516c:	88 0f       	add	r24, r24
    516e:	99 1f       	adc	r25, r25
    5170:	88 0f       	add	r24, r24
    5172:	99 1f       	adc	r25, r25
    5174:	88 0f       	add	r24, r24
    5176:	99 1f       	adc	r25, r25
    5178:	82 0f       	add	r24, r18
    517a:	93 1f       	adc	r25, r19
    517c:	fc 01       	movw	r30, r24
    517e:	e8 54       	subi	r30, 0x48	; 72
    5180:	f9 4f       	sbci	r31, 0xF9	; 249
    5182:	81 81       	ldd	r24, Z+1	; 0x01
    5184:	92 81       	ldd	r25, Z+2	; 0x02
    5186:	9c 83       	std	Y+4, r25	; 0x04
    5188:	8b 83       	std	Y+3, r24	; 0x03
    518a:	ea 85       	ldd	r30, Y+10	; 0x0a
    518c:	fb 85       	ldd	r31, Y+11	; 0x0b
    518e:	8b 81       	ldd	r24, Y+3	; 0x03
    5190:	9c 81       	ldd	r25, Y+4	; 0x04
    5192:	95 83       	std	Z+5, r25	; 0x05
    5194:	84 83       	std	Z+4, r24	; 0x04
    5196:	eb 81       	ldd	r30, Y+3	; 0x03
    5198:	fc 81       	ldd	r31, Y+4	; 0x04
    519a:	84 81       	ldd	r24, Z+4	; 0x04
    519c:	95 81       	ldd	r25, Z+5	; 0x05
    519e:	ea 85       	ldd	r30, Y+10	; 0x0a
    51a0:	fb 85       	ldd	r31, Y+11	; 0x0b
    51a2:	97 83       	std	Z+7, r25	; 0x07
    51a4:	86 83       	std	Z+6, r24	; 0x06
    51a6:	eb 81       	ldd	r30, Y+3	; 0x03
    51a8:	fc 81       	ldd	r31, Y+4	; 0x04
    51aa:	04 80       	ldd	r0, Z+4	; 0x04
    51ac:	f5 81       	ldd	r31, Z+5	; 0x05
    51ae:	e0 2d       	mov	r30, r0
    51b0:	8a 85       	ldd	r24, Y+10	; 0x0a
    51b2:	9b 85       	ldd	r25, Y+11	; 0x0b
    51b4:	02 96       	adiw	r24, 0x02	; 2
    51b6:	93 83       	std	Z+3, r25	; 0x03
    51b8:	82 83       	std	Z+2, r24	; 0x02
    51ba:	8a 85       	ldd	r24, Y+10	; 0x0a
    51bc:	9b 85       	ldd	r25, Y+11	; 0x0b
    51be:	02 96       	adiw	r24, 0x02	; 2
    51c0:	eb 81       	ldd	r30, Y+3	; 0x03
    51c2:	fc 81       	ldd	r31, Y+4	; 0x04
    51c4:	95 83       	std	Z+5, r25	; 0x05
    51c6:	84 83       	std	Z+4, r24	; 0x04
    51c8:	ea 85       	ldd	r30, Y+10	; 0x0a
    51ca:	fb 85       	ldd	r31, Y+11	; 0x0b
    51cc:	86 89       	ldd	r24, Z+22	; 0x16
    51ce:	28 2f       	mov	r18, r24
    51d0:	30 e0       	ldi	r19, 0x00	; 0
    51d2:	c9 01       	movw	r24, r18
    51d4:	88 0f       	add	r24, r24
    51d6:	99 1f       	adc	r25, r25
    51d8:	88 0f       	add	r24, r24
    51da:	99 1f       	adc	r25, r25
    51dc:	88 0f       	add	r24, r24
    51de:	99 1f       	adc	r25, r25
    51e0:	82 0f       	add	r24, r18
    51e2:	93 1f       	adc	r25, r19
    51e4:	88 54       	subi	r24, 0x48	; 72
    51e6:	99 4f       	sbci	r25, 0xF9	; 249
    51e8:	ea 85       	ldd	r30, Y+10	; 0x0a
    51ea:	fb 85       	ldd	r31, Y+11	; 0x0b
    51ec:	93 87       	std	Z+11, r25	; 0x0b
    51ee:	82 87       	std	Z+10, r24	; 0x0a
    51f0:	ea 85       	ldd	r30, Y+10	; 0x0a
    51f2:	fb 85       	ldd	r31, Y+11	; 0x0b
    51f4:	86 89       	ldd	r24, Z+22	; 0x16
    51f6:	28 2f       	mov	r18, r24
    51f8:	30 e0       	ldi	r19, 0x00	; 0
    51fa:	c9 01       	movw	r24, r18
    51fc:	88 0f       	add	r24, r24
    51fe:	99 1f       	adc	r25, r25
    5200:	88 0f       	add	r24, r24
    5202:	99 1f       	adc	r25, r25
    5204:	88 0f       	add	r24, r24
    5206:	99 1f       	adc	r25, r25
    5208:	82 0f       	add	r24, r18
    520a:	93 1f       	adc	r25, r19
    520c:	fc 01       	movw	r30, r24
    520e:	e8 54       	subi	r30, 0x48	; 72
    5210:	f9 4f       	sbci	r31, 0xF9	; 249
    5212:	80 81       	ld	r24, Z
    5214:	8f 5f       	subi	r24, 0xFF	; 255
    5216:	80 83       	st	Z, r24
    5218:	30 c0       	rjmp	.+96     	; 0x527a <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    521a:	80 91 f3 06 	lds	r24, 0x06F3
    521e:	90 91 f4 06 	lds	r25, 0x06F4
    5222:	9a 83       	std	Y+2, r25	; 0x02
    5224:	89 83       	std	Y+1, r24	; 0x01
    5226:	ea 85       	ldd	r30, Y+10	; 0x0a
    5228:	fb 85       	ldd	r31, Y+11	; 0x0b
    522a:	89 81       	ldd	r24, Y+1	; 0x01
    522c:	9a 81       	ldd	r25, Y+2	; 0x02
    522e:	97 87       	std	Z+15, r25	; 0x0f
    5230:	86 87       	std	Z+14, r24	; 0x0e
    5232:	e9 81       	ldd	r30, Y+1	; 0x01
    5234:	fa 81       	ldd	r31, Y+2	; 0x02
    5236:	84 81       	ldd	r24, Z+4	; 0x04
    5238:	95 81       	ldd	r25, Z+5	; 0x05
    523a:	ea 85       	ldd	r30, Y+10	; 0x0a
    523c:	fb 85       	ldd	r31, Y+11	; 0x0b
    523e:	91 8b       	std	Z+17, r25	; 0x11
    5240:	80 8b       	std	Z+16, r24	; 0x10
    5242:	e9 81       	ldd	r30, Y+1	; 0x01
    5244:	fa 81       	ldd	r31, Y+2	; 0x02
    5246:	04 80       	ldd	r0, Z+4	; 0x04
    5248:	f5 81       	ldd	r31, Z+5	; 0x05
    524a:	e0 2d       	mov	r30, r0
    524c:	8a 85       	ldd	r24, Y+10	; 0x0a
    524e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5250:	0c 96       	adiw	r24, 0x0c	; 12
    5252:	93 83       	std	Z+3, r25	; 0x03
    5254:	82 83       	std	Z+2, r24	; 0x02
    5256:	8a 85       	ldd	r24, Y+10	; 0x0a
    5258:	9b 85       	ldd	r25, Y+11	; 0x0b
    525a:	0c 96       	adiw	r24, 0x0c	; 12
    525c:	e9 81       	ldd	r30, Y+1	; 0x01
    525e:	fa 81       	ldd	r31, Y+2	; 0x02
    5260:	95 83       	std	Z+5, r25	; 0x05
    5262:	84 83       	std	Z+4, r24	; 0x04
    5264:	ea 85       	ldd	r30, Y+10	; 0x0a
    5266:	fb 85       	ldd	r31, Y+11	; 0x0b
    5268:	82 ef       	ldi	r24, 0xF2	; 242
    526a:	96 e0       	ldi	r25, 0x06	; 6
    526c:	95 8b       	std	Z+21, r25	; 0x15
    526e:	84 8b       	std	Z+20, r24	; 0x14
    5270:	80 91 f2 06 	lds	r24, 0x06F2
    5274:	8f 5f       	subi	r24, 0xFF	; 255
    5276:	80 93 f2 06 	sts	0x06F2, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    527a:	ea 85       	ldd	r30, Y+10	; 0x0a
    527c:	fb 85       	ldd	r31, Y+11	; 0x0b
    527e:	96 89       	ldd	r25, Z+22	; 0x16
    5280:	e0 91 a6 06 	lds	r30, 0x06A6
    5284:	f0 91 a7 06 	lds	r31, 0x06A7
    5288:	86 89       	ldd	r24, Z+22	; 0x16
    528a:	89 17       	cp	r24, r25
    528c:	58 f4       	brcc	.+22     	; 0x52a4 <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    528e:	8e 89       	ldd	r24, Y+22	; 0x16
    5290:	9f 89       	ldd	r25, Y+23	; 0x17
    5292:	00 97       	sbiw	r24, 0x00	; 0
    5294:	21 f0       	breq	.+8      	; 0x529e <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5296:	ee 89       	ldd	r30, Y+22	; 0x16
    5298:	ff 89       	ldd	r31, Y+23	; 0x17
    529a:	81 e0       	ldi	r24, 0x01	; 1
    529c:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    529e:	81 e0       	ldi	r24, 0x01	; 1
    52a0:	80 93 b0 06 	sts	0x06B0, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    52a4:	88 85       	ldd	r24, Y+8	; 0x08
    }
    52a6:	69 96       	adiw	r28, 0x19	; 25
    52a8:	0f b6       	in	r0, 0x3f	; 63
    52aa:	f8 94       	cli
    52ac:	de bf       	out	0x3e, r29	; 62
    52ae:	0f be       	out	0x3f, r0	; 63
    52b0:	cd bf       	out	0x3d, r28	; 61
    52b2:	cf 91       	pop	r28
    52b4:	df 91       	pop	r29
    52b6:	1f 91       	pop	r17
    52b8:	0f 91       	pop	r16
    52ba:	ff 90       	pop	r15
    52bc:	ef 90       	pop	r14
    52be:	df 90       	pop	r13
    52c0:	cf 90       	pop	r12
    52c2:	08 95       	ret

000052c4 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    52c4:	0f 93       	push	r16
    52c6:	1f 93       	push	r17
    52c8:	df 93       	push	r29
    52ca:	cf 93       	push	r28
    52cc:	cd b7       	in	r28, 0x3d	; 61
    52ce:	de b7       	in	r29, 0x3e	; 62
    52d0:	2f 97       	sbiw	r28, 0x0f	; 15
    52d2:	0f b6       	in	r0, 0x3f	; 63
    52d4:	f8 94       	cli
    52d6:	de bf       	out	0x3e, r29	; 62
    52d8:	0f be       	out	0x3f, r0	; 63
    52da:	cd bf       	out	0x3d, r28	; 61
    52dc:	9c 87       	std	Y+12, r25	; 0x0c
    52de:	8b 87       	std	Y+11, r24	; 0x0b
    52e0:	6d 87       	std	Y+13, r22	; 0x0d
    52e2:	5f 87       	std	Y+15, r21	; 0x0f
    52e4:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    52e6:	8b 85       	ldd	r24, Y+11	; 0x0b
    52e8:	9c 85       	ldd	r25, Y+12	; 0x0c
    52ea:	9a 87       	std	Y+10, r25	; 0x0a
    52ec:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    52ee:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    52f0:	8d 85       	ldd	r24, Y+13	; 0x0d
    52f2:	28 2f       	mov	r18, r24
    52f4:	30 e0       	ldi	r19, 0x00	; 0
    52f6:	89 85       	ldd	r24, Y+9	; 0x09
    52f8:	9a 85       	ldd	r25, Y+10	; 0x0a
    52fa:	82 0f       	add	r24, r18
    52fc:	93 1f       	adc	r25, r19
    52fe:	fc 01       	movw	r30, r24
    5300:	b5 96       	adiw	r30, 0x25	; 37
    5302:	80 81       	ld	r24, Z
    5304:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    5306:	8d 85       	ldd	r24, Y+13	; 0x0d
    5308:	28 2f       	mov	r18, r24
    530a:	30 e0       	ldi	r19, 0x00	; 0
    530c:	89 85       	ldd	r24, Y+9	; 0x09
    530e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5310:	82 0f       	add	r24, r18
    5312:	93 1f       	adc	r25, r19
    5314:	fc 01       	movw	r30, r24
    5316:	b5 96       	adiw	r30, 0x25	; 37
    5318:	82 e0       	ldi	r24, 0x02	; 2
    531a:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    531c:	8d 85       	ldd	r24, Y+13	; 0x0d
    531e:	08 2f       	mov	r16, r24
    5320:	10 e0       	ldi	r17, 0x00	; 0
    5322:	29 85       	ldd	r18, Y+9	; 0x09
    5324:	3a 85       	ldd	r19, Y+10	; 0x0a
    5326:	c8 01       	movw	r24, r16
    5328:	88 0f       	add	r24, r24
    532a:	99 1f       	adc	r25, r25
    532c:	88 0f       	add	r24, r24
    532e:	99 1f       	adc	r25, r25
    5330:	82 0f       	add	r24, r18
    5332:	93 1f       	adc	r25, r19
    5334:	fc 01       	movw	r30, r24
    5336:	b1 96       	adiw	r30, 0x21	; 33
    5338:	80 81       	ld	r24, Z
    533a:	91 81       	ldd	r25, Z+1	; 0x01
    533c:	a2 81       	ldd	r26, Z+2	; 0x02
    533e:	b3 81       	ldd	r27, Z+3	; 0x03
    5340:	ac 01       	movw	r20, r24
    5342:	bd 01       	movw	r22, r26
    5344:	4f 5f       	subi	r20, 0xFF	; 255
    5346:	5f 4f       	sbci	r21, 0xFF	; 255
    5348:	6f 4f       	sbci	r22, 0xFF	; 255
    534a:	7f 4f       	sbci	r23, 0xFF	; 255
    534c:	29 85       	ldd	r18, Y+9	; 0x09
    534e:	3a 85       	ldd	r19, Y+10	; 0x0a
    5350:	c8 01       	movw	r24, r16
    5352:	88 0f       	add	r24, r24
    5354:	99 1f       	adc	r25, r25
    5356:	88 0f       	add	r24, r24
    5358:	99 1f       	adc	r25, r25
    535a:	82 0f       	add	r24, r18
    535c:	93 1f       	adc	r25, r19
    535e:	fc 01       	movw	r30, r24
    5360:	b1 96       	adiw	r30, 0x21	; 33
    5362:	40 83       	st	Z, r20
    5364:	51 83       	std	Z+1, r21	; 0x01
    5366:	62 83       	std	Z+2, r22	; 0x02
    5368:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    536a:	88 85       	ldd	r24, Y+8	; 0x08
    536c:	81 30       	cpi	r24, 0x01	; 1
    536e:	09 f0       	breq	.+2      	; 0x5372 <vTaskGenericNotifyGiveFromISR+0xae>
    5370:	ee c0       	rjmp	.+476    	; 0x554e <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5372:	80 91 b7 06 	lds	r24, 0x06B7
    5376:	88 23       	and	r24, r24
    5378:	09 f0       	breq	.+2      	; 0x537c <vTaskGenericNotifyGiveFromISR+0xb8>
    537a:	a4 c0       	rjmp	.+328    	; 0x54c4 <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    537c:	e9 85       	ldd	r30, Y+9	; 0x09
    537e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5380:	82 85       	ldd	r24, Z+10	; 0x0a
    5382:	93 85       	ldd	r25, Z+11	; 0x0b
    5384:	9e 83       	std	Y+6, r25	; 0x06
    5386:	8d 83       	std	Y+5, r24	; 0x05
    5388:	e9 85       	ldd	r30, Y+9	; 0x09
    538a:	fa 85       	ldd	r31, Y+10	; 0x0a
    538c:	a4 81       	ldd	r26, Z+4	; 0x04
    538e:	b5 81       	ldd	r27, Z+5	; 0x05
    5390:	e9 85       	ldd	r30, Y+9	; 0x09
    5392:	fa 85       	ldd	r31, Y+10	; 0x0a
    5394:	86 81       	ldd	r24, Z+6	; 0x06
    5396:	97 81       	ldd	r25, Z+7	; 0x07
    5398:	15 96       	adiw	r26, 0x05	; 5
    539a:	9c 93       	st	X, r25
    539c:	8e 93       	st	-X, r24
    539e:	14 97       	sbiw	r26, 0x04	; 4
    53a0:	e9 85       	ldd	r30, Y+9	; 0x09
    53a2:	fa 85       	ldd	r31, Y+10	; 0x0a
    53a4:	a6 81       	ldd	r26, Z+6	; 0x06
    53a6:	b7 81       	ldd	r27, Z+7	; 0x07
    53a8:	e9 85       	ldd	r30, Y+9	; 0x09
    53aa:	fa 85       	ldd	r31, Y+10	; 0x0a
    53ac:	84 81       	ldd	r24, Z+4	; 0x04
    53ae:	95 81       	ldd	r25, Z+5	; 0x05
    53b0:	13 96       	adiw	r26, 0x03	; 3
    53b2:	9c 93       	st	X, r25
    53b4:	8e 93       	st	-X, r24
    53b6:	12 97       	sbiw	r26, 0x02	; 2
    53b8:	ed 81       	ldd	r30, Y+5	; 0x05
    53ba:	fe 81       	ldd	r31, Y+6	; 0x06
    53bc:	21 81       	ldd	r18, Z+1	; 0x01
    53be:	32 81       	ldd	r19, Z+2	; 0x02
    53c0:	89 85       	ldd	r24, Y+9	; 0x09
    53c2:	9a 85       	ldd	r25, Y+10	; 0x0a
    53c4:	02 96       	adiw	r24, 0x02	; 2
    53c6:	28 17       	cp	r18, r24
    53c8:	39 07       	cpc	r19, r25
    53ca:	41 f4       	brne	.+16     	; 0x53dc <vTaskGenericNotifyGiveFromISR+0x118>
    53cc:	e9 85       	ldd	r30, Y+9	; 0x09
    53ce:	fa 85       	ldd	r31, Y+10	; 0x0a
    53d0:	86 81       	ldd	r24, Z+6	; 0x06
    53d2:	97 81       	ldd	r25, Z+7	; 0x07
    53d4:	ed 81       	ldd	r30, Y+5	; 0x05
    53d6:	fe 81       	ldd	r31, Y+6	; 0x06
    53d8:	92 83       	std	Z+2, r25	; 0x02
    53da:	81 83       	std	Z+1, r24	; 0x01
    53dc:	e9 85       	ldd	r30, Y+9	; 0x09
    53de:	fa 85       	ldd	r31, Y+10	; 0x0a
    53e0:	13 86       	std	Z+11, r1	; 0x0b
    53e2:	12 86       	std	Z+10, r1	; 0x0a
    53e4:	ed 81       	ldd	r30, Y+5	; 0x05
    53e6:	fe 81       	ldd	r31, Y+6	; 0x06
    53e8:	80 81       	ld	r24, Z
    53ea:	81 50       	subi	r24, 0x01	; 1
    53ec:	ed 81       	ldd	r30, Y+5	; 0x05
    53ee:	fe 81       	ldd	r31, Y+6	; 0x06
    53f0:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    53f2:	e9 85       	ldd	r30, Y+9	; 0x09
    53f4:	fa 85       	ldd	r31, Y+10	; 0x0a
    53f6:	96 89       	ldd	r25, Z+22	; 0x16
    53f8:	80 91 ac 06 	lds	r24, 0x06AC
    53fc:	89 17       	cp	r24, r25
    53fe:	28 f4       	brcc	.+10     	; 0x540a <vTaskGenericNotifyGiveFromISR+0x146>
    5400:	e9 85       	ldd	r30, Y+9	; 0x09
    5402:	fa 85       	ldd	r31, Y+10	; 0x0a
    5404:	86 89       	ldd	r24, Z+22	; 0x16
    5406:	80 93 ac 06 	sts	0x06AC, r24
    540a:	e9 85       	ldd	r30, Y+9	; 0x09
    540c:	fa 85       	ldd	r31, Y+10	; 0x0a
    540e:	86 89       	ldd	r24, Z+22	; 0x16
    5410:	28 2f       	mov	r18, r24
    5412:	30 e0       	ldi	r19, 0x00	; 0
    5414:	c9 01       	movw	r24, r18
    5416:	88 0f       	add	r24, r24
    5418:	99 1f       	adc	r25, r25
    541a:	88 0f       	add	r24, r24
    541c:	99 1f       	adc	r25, r25
    541e:	88 0f       	add	r24, r24
    5420:	99 1f       	adc	r25, r25
    5422:	82 0f       	add	r24, r18
    5424:	93 1f       	adc	r25, r19
    5426:	fc 01       	movw	r30, r24
    5428:	e8 54       	subi	r30, 0x48	; 72
    542a:	f9 4f       	sbci	r31, 0xF9	; 249
    542c:	81 81       	ldd	r24, Z+1	; 0x01
    542e:	92 81       	ldd	r25, Z+2	; 0x02
    5430:	9c 83       	std	Y+4, r25	; 0x04
    5432:	8b 83       	std	Y+3, r24	; 0x03
    5434:	e9 85       	ldd	r30, Y+9	; 0x09
    5436:	fa 85       	ldd	r31, Y+10	; 0x0a
    5438:	8b 81       	ldd	r24, Y+3	; 0x03
    543a:	9c 81       	ldd	r25, Y+4	; 0x04
    543c:	95 83       	std	Z+5, r25	; 0x05
    543e:	84 83       	std	Z+4, r24	; 0x04
    5440:	eb 81       	ldd	r30, Y+3	; 0x03
    5442:	fc 81       	ldd	r31, Y+4	; 0x04
    5444:	84 81       	ldd	r24, Z+4	; 0x04
    5446:	95 81       	ldd	r25, Z+5	; 0x05
    5448:	e9 85       	ldd	r30, Y+9	; 0x09
    544a:	fa 85       	ldd	r31, Y+10	; 0x0a
    544c:	97 83       	std	Z+7, r25	; 0x07
    544e:	86 83       	std	Z+6, r24	; 0x06
    5450:	eb 81       	ldd	r30, Y+3	; 0x03
    5452:	fc 81       	ldd	r31, Y+4	; 0x04
    5454:	04 80       	ldd	r0, Z+4	; 0x04
    5456:	f5 81       	ldd	r31, Z+5	; 0x05
    5458:	e0 2d       	mov	r30, r0
    545a:	89 85       	ldd	r24, Y+9	; 0x09
    545c:	9a 85       	ldd	r25, Y+10	; 0x0a
    545e:	02 96       	adiw	r24, 0x02	; 2
    5460:	93 83       	std	Z+3, r25	; 0x03
    5462:	82 83       	std	Z+2, r24	; 0x02
    5464:	89 85       	ldd	r24, Y+9	; 0x09
    5466:	9a 85       	ldd	r25, Y+10	; 0x0a
    5468:	02 96       	adiw	r24, 0x02	; 2
    546a:	eb 81       	ldd	r30, Y+3	; 0x03
    546c:	fc 81       	ldd	r31, Y+4	; 0x04
    546e:	95 83       	std	Z+5, r25	; 0x05
    5470:	84 83       	std	Z+4, r24	; 0x04
    5472:	e9 85       	ldd	r30, Y+9	; 0x09
    5474:	fa 85       	ldd	r31, Y+10	; 0x0a
    5476:	86 89       	ldd	r24, Z+22	; 0x16
    5478:	28 2f       	mov	r18, r24
    547a:	30 e0       	ldi	r19, 0x00	; 0
    547c:	c9 01       	movw	r24, r18
    547e:	88 0f       	add	r24, r24
    5480:	99 1f       	adc	r25, r25
    5482:	88 0f       	add	r24, r24
    5484:	99 1f       	adc	r25, r25
    5486:	88 0f       	add	r24, r24
    5488:	99 1f       	adc	r25, r25
    548a:	82 0f       	add	r24, r18
    548c:	93 1f       	adc	r25, r19
    548e:	88 54       	subi	r24, 0x48	; 72
    5490:	99 4f       	sbci	r25, 0xF9	; 249
    5492:	e9 85       	ldd	r30, Y+9	; 0x09
    5494:	fa 85       	ldd	r31, Y+10	; 0x0a
    5496:	93 87       	std	Z+11, r25	; 0x0b
    5498:	82 87       	std	Z+10, r24	; 0x0a
    549a:	e9 85       	ldd	r30, Y+9	; 0x09
    549c:	fa 85       	ldd	r31, Y+10	; 0x0a
    549e:	86 89       	ldd	r24, Z+22	; 0x16
    54a0:	28 2f       	mov	r18, r24
    54a2:	30 e0       	ldi	r19, 0x00	; 0
    54a4:	c9 01       	movw	r24, r18
    54a6:	88 0f       	add	r24, r24
    54a8:	99 1f       	adc	r25, r25
    54aa:	88 0f       	add	r24, r24
    54ac:	99 1f       	adc	r25, r25
    54ae:	88 0f       	add	r24, r24
    54b0:	99 1f       	adc	r25, r25
    54b2:	82 0f       	add	r24, r18
    54b4:	93 1f       	adc	r25, r19
    54b6:	fc 01       	movw	r30, r24
    54b8:	e8 54       	subi	r30, 0x48	; 72
    54ba:	f9 4f       	sbci	r31, 0xF9	; 249
    54bc:	80 81       	ld	r24, Z
    54be:	8f 5f       	subi	r24, 0xFF	; 255
    54c0:	80 83       	st	Z, r24
    54c2:	30 c0       	rjmp	.+96     	; 0x5524 <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    54c4:	80 91 f3 06 	lds	r24, 0x06F3
    54c8:	90 91 f4 06 	lds	r25, 0x06F4
    54cc:	9a 83       	std	Y+2, r25	; 0x02
    54ce:	89 83       	std	Y+1, r24	; 0x01
    54d0:	e9 85       	ldd	r30, Y+9	; 0x09
    54d2:	fa 85       	ldd	r31, Y+10	; 0x0a
    54d4:	89 81       	ldd	r24, Y+1	; 0x01
    54d6:	9a 81       	ldd	r25, Y+2	; 0x02
    54d8:	97 87       	std	Z+15, r25	; 0x0f
    54da:	86 87       	std	Z+14, r24	; 0x0e
    54dc:	e9 81       	ldd	r30, Y+1	; 0x01
    54de:	fa 81       	ldd	r31, Y+2	; 0x02
    54e0:	84 81       	ldd	r24, Z+4	; 0x04
    54e2:	95 81       	ldd	r25, Z+5	; 0x05
    54e4:	e9 85       	ldd	r30, Y+9	; 0x09
    54e6:	fa 85       	ldd	r31, Y+10	; 0x0a
    54e8:	91 8b       	std	Z+17, r25	; 0x11
    54ea:	80 8b       	std	Z+16, r24	; 0x10
    54ec:	e9 81       	ldd	r30, Y+1	; 0x01
    54ee:	fa 81       	ldd	r31, Y+2	; 0x02
    54f0:	04 80       	ldd	r0, Z+4	; 0x04
    54f2:	f5 81       	ldd	r31, Z+5	; 0x05
    54f4:	e0 2d       	mov	r30, r0
    54f6:	89 85       	ldd	r24, Y+9	; 0x09
    54f8:	9a 85       	ldd	r25, Y+10	; 0x0a
    54fa:	0c 96       	adiw	r24, 0x0c	; 12
    54fc:	93 83       	std	Z+3, r25	; 0x03
    54fe:	82 83       	std	Z+2, r24	; 0x02
    5500:	89 85       	ldd	r24, Y+9	; 0x09
    5502:	9a 85       	ldd	r25, Y+10	; 0x0a
    5504:	0c 96       	adiw	r24, 0x0c	; 12
    5506:	e9 81       	ldd	r30, Y+1	; 0x01
    5508:	fa 81       	ldd	r31, Y+2	; 0x02
    550a:	95 83       	std	Z+5, r25	; 0x05
    550c:	84 83       	std	Z+4, r24	; 0x04
    550e:	e9 85       	ldd	r30, Y+9	; 0x09
    5510:	fa 85       	ldd	r31, Y+10	; 0x0a
    5512:	82 ef       	ldi	r24, 0xF2	; 242
    5514:	96 e0       	ldi	r25, 0x06	; 6
    5516:	95 8b       	std	Z+21, r25	; 0x15
    5518:	84 8b       	std	Z+20, r24	; 0x14
    551a:	80 91 f2 06 	lds	r24, 0x06F2
    551e:	8f 5f       	subi	r24, 0xFF	; 255
    5520:	80 93 f2 06 	sts	0x06F2, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5524:	e9 85       	ldd	r30, Y+9	; 0x09
    5526:	fa 85       	ldd	r31, Y+10	; 0x0a
    5528:	96 89       	ldd	r25, Z+22	; 0x16
    552a:	e0 91 a6 06 	lds	r30, 0x06A6
    552e:	f0 91 a7 06 	lds	r31, 0x06A7
    5532:	86 89       	ldd	r24, Z+22	; 0x16
    5534:	89 17       	cp	r24, r25
    5536:	58 f4       	brcc	.+22     	; 0x554e <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    5538:	8e 85       	ldd	r24, Y+14	; 0x0e
    553a:	9f 85       	ldd	r25, Y+15	; 0x0f
    553c:	00 97       	sbiw	r24, 0x00	; 0
    553e:	21 f0       	breq	.+8      	; 0x5548 <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5540:	ee 85       	ldd	r30, Y+14	; 0x0e
    5542:	ff 85       	ldd	r31, Y+15	; 0x0f
    5544:	81 e0       	ldi	r24, 0x01	; 1
    5546:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5548:	81 e0       	ldi	r24, 0x01	; 1
    554a:	80 93 b0 06 	sts	0x06B0, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    554e:	2f 96       	adiw	r28, 0x0f	; 15
    5550:	0f b6       	in	r0, 0x3f	; 63
    5552:	f8 94       	cli
    5554:	de bf       	out	0x3e, r29	; 62
    5556:	0f be       	out	0x3f, r0	; 63
    5558:	cd bf       	out	0x3d, r28	; 61
    555a:	cf 91       	pop	r28
    555c:	df 91       	pop	r29
    555e:	1f 91       	pop	r17
    5560:	0f 91       	pop	r16
    5562:	08 95       	ret

00005564 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    5564:	df 93       	push	r29
    5566:	cf 93       	push	r28
    5568:	cd b7       	in	r28, 0x3d	; 61
    556a:	de b7       	in	r29, 0x3e	; 62
    556c:	28 97       	sbiw	r28, 0x08	; 8
    556e:	0f b6       	in	r0, 0x3f	; 63
    5570:	f8 94       	cli
    5572:	de bf       	out	0x3e, r29	; 62
    5574:	0f be       	out	0x3f, r0	; 63
    5576:	cd bf       	out	0x3d, r28	; 61
    5578:	9d 83       	std	Y+5, r25	; 0x05
    557a:	8c 83       	std	Y+4, r24	; 0x04
    557c:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    557e:	8c 81       	ldd	r24, Y+4	; 0x04
    5580:	9d 81       	ldd	r25, Y+5	; 0x05
    5582:	00 97       	sbiw	r24, 0x00	; 0
    5584:	39 f4       	brne	.+14     	; 0x5594 <xTaskGenericNotifyStateClear+0x30>
    5586:	80 91 a6 06 	lds	r24, 0x06A6
    558a:	90 91 a7 06 	lds	r25, 0x06A7
    558e:	98 87       	std	Y+8, r25	; 0x08
    5590:	8f 83       	std	Y+7, r24	; 0x07
    5592:	04 c0       	rjmp	.+8      	; 0x559c <xTaskGenericNotifyStateClear+0x38>
    5594:	8c 81       	ldd	r24, Y+4	; 0x04
    5596:	9d 81       	ldd	r25, Y+5	; 0x05
    5598:	98 87       	std	Y+8, r25	; 0x08
    559a:	8f 83       	std	Y+7, r24	; 0x07
    559c:	8f 81       	ldd	r24, Y+7	; 0x07
    559e:	98 85       	ldd	r25, Y+8	; 0x08
    55a0:	9b 83       	std	Y+3, r25	; 0x03
    55a2:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    55a4:	0f b6       	in	r0, 0x3f	; 63
    55a6:	f8 94       	cli
    55a8:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    55aa:	8e 81       	ldd	r24, Y+6	; 0x06
    55ac:	28 2f       	mov	r18, r24
    55ae:	30 e0       	ldi	r19, 0x00	; 0
    55b0:	8a 81       	ldd	r24, Y+2	; 0x02
    55b2:	9b 81       	ldd	r25, Y+3	; 0x03
    55b4:	82 0f       	add	r24, r18
    55b6:	93 1f       	adc	r25, r19
    55b8:	fc 01       	movw	r30, r24
    55ba:	b5 96       	adiw	r30, 0x25	; 37
    55bc:	80 81       	ld	r24, Z
    55be:	82 30       	cpi	r24, 0x02	; 2
    55c0:	69 f4       	brne	.+26     	; 0x55dc <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    55c2:	8e 81       	ldd	r24, Y+6	; 0x06
    55c4:	28 2f       	mov	r18, r24
    55c6:	30 e0       	ldi	r19, 0x00	; 0
    55c8:	8a 81       	ldd	r24, Y+2	; 0x02
    55ca:	9b 81       	ldd	r25, Y+3	; 0x03
    55cc:	82 0f       	add	r24, r18
    55ce:	93 1f       	adc	r25, r19
    55d0:	fc 01       	movw	r30, r24
    55d2:	b5 96       	adiw	r30, 0x25	; 37
    55d4:	10 82       	st	Z, r1
                xReturn = pdPASS;
    55d6:	81 e0       	ldi	r24, 0x01	; 1
    55d8:	89 83       	std	Y+1, r24	; 0x01
    55da:	01 c0       	rjmp	.+2      	; 0x55de <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    55dc:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    55de:	0f 90       	pop	r0
    55e0:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    55e2:	89 81       	ldd	r24, Y+1	; 0x01
    }
    55e4:	28 96       	adiw	r28, 0x08	; 8
    55e6:	0f b6       	in	r0, 0x3f	; 63
    55e8:	f8 94       	cli
    55ea:	de bf       	out	0x3e, r29	; 62
    55ec:	0f be       	out	0x3f, r0	; 63
    55ee:	cd bf       	out	0x3d, r28	; 61
    55f0:	cf 91       	pop	r28
    55f2:	df 91       	pop	r29
    55f4:	08 95       	ret

000055f6 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    55f6:	0f 93       	push	r16
    55f8:	1f 93       	push	r17
    55fa:	df 93       	push	r29
    55fc:	cf 93       	push	r28
    55fe:	cd b7       	in	r28, 0x3d	; 61
    5600:	de b7       	in	r29, 0x3e	; 62
    5602:	2f 97       	sbiw	r28, 0x0f	; 15
    5604:	0f b6       	in	r0, 0x3f	; 63
    5606:	f8 94       	cli
    5608:	de bf       	out	0x3e, r29	; 62
    560a:	0f be       	out	0x3f, r0	; 63
    560c:	cd bf       	out	0x3d, r28	; 61
    560e:	98 87       	std	Y+8, r25	; 0x08
    5610:	8f 83       	std	Y+7, r24	; 0x07
    5612:	69 87       	std	Y+9, r22	; 0x09
    5614:	2a 87       	std	Y+10, r18	; 0x0a
    5616:	3b 87       	std	Y+11, r19	; 0x0b
    5618:	4c 87       	std	Y+12, r20	; 0x0c
    561a:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    561c:	8f 81       	ldd	r24, Y+7	; 0x07
    561e:	98 85       	ldd	r25, Y+8	; 0x08
    5620:	00 97       	sbiw	r24, 0x00	; 0
    5622:	39 f4       	brne	.+14     	; 0x5632 <ulTaskGenericNotifyValueClear+0x3c>
    5624:	80 91 a6 06 	lds	r24, 0x06A6
    5628:	90 91 a7 06 	lds	r25, 0x06A7
    562c:	9f 87       	std	Y+15, r25	; 0x0f
    562e:	8e 87       	std	Y+14, r24	; 0x0e
    5630:	04 c0       	rjmp	.+8      	; 0x563a <ulTaskGenericNotifyValueClear+0x44>
    5632:	8f 81       	ldd	r24, Y+7	; 0x07
    5634:	98 85       	ldd	r25, Y+8	; 0x08
    5636:	9f 87       	std	Y+15, r25	; 0x0f
    5638:	8e 87       	std	Y+14, r24	; 0x0e
    563a:	8e 85       	ldd	r24, Y+14	; 0x0e
    563c:	9f 85       	ldd	r25, Y+15	; 0x0f
    563e:	9e 83       	std	Y+6, r25	; 0x06
    5640:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    5642:	0f b6       	in	r0, 0x3f	; 63
    5644:	f8 94       	cli
    5646:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    5648:	89 85       	ldd	r24, Y+9	; 0x09
    564a:	88 2f       	mov	r24, r24
    564c:	90 e0       	ldi	r25, 0x00	; 0
    564e:	2d 81       	ldd	r18, Y+5	; 0x05
    5650:	3e 81       	ldd	r19, Y+6	; 0x06
    5652:	88 0f       	add	r24, r24
    5654:	99 1f       	adc	r25, r25
    5656:	88 0f       	add	r24, r24
    5658:	99 1f       	adc	r25, r25
    565a:	82 0f       	add	r24, r18
    565c:	93 1f       	adc	r25, r19
    565e:	fc 01       	movw	r30, r24
    5660:	b1 96       	adiw	r30, 0x21	; 33
    5662:	80 81       	ld	r24, Z
    5664:	91 81       	ldd	r25, Z+1	; 0x01
    5666:	a2 81       	ldd	r26, Z+2	; 0x02
    5668:	b3 81       	ldd	r27, Z+3	; 0x03
    566a:	89 83       	std	Y+1, r24	; 0x01
    566c:	9a 83       	std	Y+2, r25	; 0x02
    566e:	ab 83       	std	Y+3, r26	; 0x03
    5670:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    5672:	89 85       	ldd	r24, Y+9	; 0x09
    5674:	08 2f       	mov	r16, r24
    5676:	10 e0       	ldi	r17, 0x00	; 0
    5678:	89 85       	ldd	r24, Y+9	; 0x09
    567a:	88 2f       	mov	r24, r24
    567c:	90 e0       	ldi	r25, 0x00	; 0
    567e:	2d 81       	ldd	r18, Y+5	; 0x05
    5680:	3e 81       	ldd	r19, Y+6	; 0x06
    5682:	88 0f       	add	r24, r24
    5684:	99 1f       	adc	r25, r25
    5686:	88 0f       	add	r24, r24
    5688:	99 1f       	adc	r25, r25
    568a:	82 0f       	add	r24, r18
    568c:	93 1f       	adc	r25, r19
    568e:	fc 01       	movw	r30, r24
    5690:	b1 96       	adiw	r30, 0x21	; 33
    5692:	20 81       	ld	r18, Z
    5694:	31 81       	ldd	r19, Z+1	; 0x01
    5696:	42 81       	ldd	r20, Z+2	; 0x02
    5698:	53 81       	ldd	r21, Z+3	; 0x03
    569a:	8a 85       	ldd	r24, Y+10	; 0x0a
    569c:	9b 85       	ldd	r25, Y+11	; 0x0b
    569e:	ac 85       	ldd	r26, Y+12	; 0x0c
    56a0:	bd 85       	ldd	r27, Y+13	; 0x0d
    56a2:	80 95       	com	r24
    56a4:	90 95       	com	r25
    56a6:	a0 95       	com	r26
    56a8:	b0 95       	com	r27
    56aa:	ba 01       	movw	r22, r20
    56ac:	a9 01       	movw	r20, r18
    56ae:	48 23       	and	r20, r24
    56b0:	59 23       	and	r21, r25
    56b2:	6a 23       	and	r22, r26
    56b4:	7b 23       	and	r23, r27
    56b6:	2d 81       	ldd	r18, Y+5	; 0x05
    56b8:	3e 81       	ldd	r19, Y+6	; 0x06
    56ba:	c8 01       	movw	r24, r16
    56bc:	88 0f       	add	r24, r24
    56be:	99 1f       	adc	r25, r25
    56c0:	88 0f       	add	r24, r24
    56c2:	99 1f       	adc	r25, r25
    56c4:	82 0f       	add	r24, r18
    56c6:	93 1f       	adc	r25, r19
    56c8:	fc 01       	movw	r30, r24
    56ca:	b1 96       	adiw	r30, 0x21	; 33
    56cc:	40 83       	st	Z, r20
    56ce:	51 83       	std	Z+1, r21	; 0x01
    56d0:	62 83       	std	Z+2, r22	; 0x02
    56d2:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    56d4:	0f 90       	pop	r0
    56d6:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    56d8:	89 81       	ldd	r24, Y+1	; 0x01
    56da:	9a 81       	ldd	r25, Y+2	; 0x02
    56dc:	ab 81       	ldd	r26, Y+3	; 0x03
    56de:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    56e0:	bc 01       	movw	r22, r24
    56e2:	cd 01       	movw	r24, r26
    56e4:	2f 96       	adiw	r28, 0x0f	; 15
    56e6:	0f b6       	in	r0, 0x3f	; 63
    56e8:	f8 94       	cli
    56ea:	de bf       	out	0x3e, r29	; 62
    56ec:	0f be       	out	0x3f, r0	; 63
    56ee:	cd bf       	out	0x3d, r28	; 61
    56f0:	cf 91       	pop	r28
    56f2:	df 91       	pop	r29
    56f4:	1f 91       	pop	r17
    56f6:	0f 91       	pop	r16
    56f8:	08 95       	ret

000056fa <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    56fa:	df 93       	push	r29
    56fc:	cf 93       	push	r28
    56fe:	cd b7       	in	r28, 0x3d	; 61
    5700:	de b7       	in	r29, 0x3e	; 62
    5702:	27 97       	sbiw	r28, 0x07	; 7
    5704:	0f b6       	in	r0, 0x3f	; 63
    5706:	f8 94       	cli
    5708:	de bf       	out	0x3e, r29	; 62
    570a:	0f be       	out	0x3f, r0	; 63
    570c:	cd bf       	out	0x3d, r28	; 61
    570e:	9e 83       	std	Y+6, r25	; 0x06
    5710:	8d 83       	std	Y+5, r24	; 0x05
    5712:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    5714:	80 91 aa 06 	lds	r24, 0x06AA
    5718:	90 91 ab 06 	lds	r25, 0x06AB
    571c:	9a 83       	std	Y+2, r25	; 0x02
    571e:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5720:	80 91 a6 06 	lds	r24, 0x06A6
    5724:	90 91 a7 06 	lds	r25, 0x06A7
    5728:	02 96       	adiw	r24, 0x02	; 2
    572a:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the kernel
             * will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    572e:	29 81       	ldd	r18, Y+1	; 0x01
    5730:	3a 81       	ldd	r19, Y+2	; 0x02
    5732:	8d 81       	ldd	r24, Y+5	; 0x05
    5734:	9e 81       	ldd	r25, Y+6	; 0x06
    5736:	82 0f       	add	r24, r18
    5738:	93 1f       	adc	r25, r19
    573a:	9c 83       	std	Y+4, r25	; 0x04
    573c:	8b 83       	std	Y+3, r24	; 0x03

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    573e:	e0 91 a6 06 	lds	r30, 0x06A6
    5742:	f0 91 a7 06 	lds	r31, 0x06A7
    5746:	8b 81       	ldd	r24, Y+3	; 0x03
    5748:	9c 81       	ldd	r25, Y+4	; 0x04
    574a:	93 83       	std	Z+3, r25	; 0x03
    574c:	82 83       	std	Z+2, r24	; 0x02

            if( xTimeToWake < xConstTickCount )
    574e:	2b 81       	ldd	r18, Y+3	; 0x03
    5750:	3c 81       	ldd	r19, Y+4	; 0x04
    5752:	89 81       	ldd	r24, Y+1	; 0x01
    5754:	9a 81       	ldd	r25, Y+2	; 0x02
    5756:	28 17       	cp	r18, r24
    5758:	39 07       	cpc	r19, r25
    575a:	70 f4       	brcc	.+28     	; 0x5778 <prvAddCurrentTaskToDelayedList+0x7e>
            {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    575c:	80 91 f0 06 	lds	r24, 0x06F0
    5760:	90 91 f1 06 	lds	r25, 0x06F1
    5764:	20 91 a6 06 	lds	r18, 0x06A6
    5768:	30 91 a7 06 	lds	r19, 0x06A7
    576c:	2e 5f       	subi	r18, 0xFE	; 254
    576e:	3f 4f       	sbci	r19, 0xFF	; 255
    5770:	b9 01       	movw	r22, r18
    5772:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <vListInsert>
    5776:	1e c0       	rjmp	.+60     	; 0x57b4 <prvAddCurrentTaskToDelayedList+0xba>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5778:	40 91 ee 06 	lds	r20, 0x06EE
    577c:	50 91 ef 06 	lds	r21, 0x06EF
    5780:	80 91 a6 06 	lds	r24, 0x06A6
    5784:	90 91 a7 06 	lds	r25, 0x06A7
    5788:	9c 01       	movw	r18, r24
    578a:	2e 5f       	subi	r18, 0xFE	; 254
    578c:	3f 4f       	sbci	r19, 0xFF	; 255
    578e:	ca 01       	movw	r24, r20
    5790:	b9 01       	movw	r22, r18
    5792:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <vListInsert>

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    5796:	20 91 b3 06 	lds	r18, 0x06B3
    579a:	30 91 b4 06 	lds	r19, 0x06B4
    579e:	8b 81       	ldd	r24, Y+3	; 0x03
    57a0:	9c 81       	ldd	r25, Y+4	; 0x04
    57a2:	82 17       	cp	r24, r18
    57a4:	93 07       	cpc	r25, r19
    57a6:	30 f4       	brcc	.+12     	; 0x57b4 <prvAddCurrentTaskToDelayedList+0xba>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    57a8:	8b 81       	ldd	r24, Y+3	; 0x03
    57aa:	9c 81       	ldd	r25, Y+4	; 0x04
    57ac:	90 93 b4 06 	sts	0x06B4, r25
    57b0:	80 93 b3 06 	sts	0x06B3, r24

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    57b4:	27 96       	adiw	r28, 0x07	; 7
    57b6:	0f b6       	in	r0, 0x3f	; 63
    57b8:	f8 94       	cli
    57ba:	de bf       	out	0x3e, r29	; 62
    57bc:	0f be       	out	0x3f, r0	; 63
    57be:	cd bf       	out	0x3d, r28	; 61
    57c0:	cf 91       	pop	r28
    57c2:	df 91       	pop	r29
    57c4:	08 95       	ret

000057c6 <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
    57c6:	ef 92       	push	r14
    57c8:	ff 92       	push	r15
    57ca:	0f 93       	push	r16
    57cc:	df 93       	push	r29
    57ce:	cf 93       	push	r28
    57d0:	0f 92       	push	r0
    57d2:	cd b7       	in	r28, 0x3d	; 61
    57d4:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn = pdFAIL;
    57d6:	19 82       	std	Y+1, r1	; 0x01

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
    57d8:	0e 94 a2 30 	call	0x6144	; 0x6144 <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
    57dc:	80 91 04 07 	lds	r24, 0x0704
    57e0:	90 91 05 07 	lds	r25, 0x0705
    57e4:	00 97       	sbiw	r24, 0x00	; 0
    57e6:	81 f0       	breq	.+32     	; 0x5808 <xTimerCreateTimerTask+0x42>
                        xReturn = pdPASS;
                    }
                }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
    57e8:	84 e3       	ldi	r24, 0x34	; 52
    57ea:	9e e2       	ldi	r25, 0x2E	; 46
    57ec:	25 e6       	ldi	r18, 0x65	; 101
    57ee:	30 e0       	ldi	r19, 0x00	; 0
    57f0:	e6 e0       	ldi	r30, 0x06	; 6
    57f2:	f7 e0       	ldi	r31, 0x07	; 7
    57f4:	b9 01       	movw	r22, r18
    57f6:	45 e5       	ldi	r20, 0x55	; 85
    57f8:	50 e0       	ldi	r21, 0x00	; 0
    57fa:	20 e0       	ldi	r18, 0x00	; 0
    57fc:	30 e0       	ldi	r19, 0x00	; 0
    57fe:	03 e0       	ldi	r16, 0x03	; 3
    5800:	7f 01       	movw	r14, r30
    5802:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <xTaskCreate>
    5806:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
        return xReturn;
    5808:	89 81       	ldd	r24, Y+1	; 0x01
    }
    580a:	0f 90       	pop	r0
    580c:	cf 91       	pop	r28
    580e:	df 91       	pop	r29
    5810:	0f 91       	pop	r16
    5812:	ff 90       	pop	r15
    5814:	ef 90       	pop	r14
    5816:	08 95       	ret

00005818 <xTimerCreate>:
        TimerHandle_t xTimerCreate( const char * const pcTimerName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                    const TickType_t xTimerPeriodInTicks,
                                    const UBaseType_t uxAutoReload,
                                    void * const pvTimerID,
                                    TimerCallbackFunction_t pxCallbackFunction )
        {
    5818:	ef 92       	push	r14
    581a:	ff 92       	push	r15
    581c:	0f 93       	push	r16
    581e:	1f 93       	push	r17
    5820:	df 93       	push	r29
    5822:	cf 93       	push	r28
    5824:	cd b7       	in	r28, 0x3d	; 61
    5826:	de b7       	in	r29, 0x3e	; 62
    5828:	2b 97       	sbiw	r28, 0x0b	; 11
    582a:	0f b6       	in	r0, 0x3f	; 63
    582c:	f8 94       	cli
    582e:	de bf       	out	0x3e, r29	; 62
    5830:	0f be       	out	0x3f, r0	; 63
    5832:	cd bf       	out	0x3d, r28	; 61
    5834:	9c 83       	std	Y+4, r25	; 0x04
    5836:	8b 83       	std	Y+3, r24	; 0x03
    5838:	7e 83       	std	Y+6, r23	; 0x06
    583a:	6d 83       	std	Y+5, r22	; 0x05
    583c:	4f 83       	std	Y+7, r20	; 0x07
    583e:	39 87       	std	Y+9, r19	; 0x09
    5840:	28 87       	std	Y+8, r18	; 0x08
    5842:	1b 87       	std	Y+11, r17	; 0x0b
    5844:	0a 87       	std	Y+10, r16	; 0x0a
            Timer_t * pxNewTimer;

            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
    5846:	83 e1       	ldi	r24, 0x13	; 19
    5848:	90 e0       	ldi	r25, 0x00	; 0
    584a:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    584e:	9a 83       	std	Y+2, r25	; 0x02
    5850:	89 83       	std	Y+1, r24	; 0x01

            if( pxNewTimer != NULL )
    5852:	89 81       	ldd	r24, Y+1	; 0x01
    5854:	9a 81       	ldd	r25, Y+2	; 0x02
    5856:	00 97       	sbiw	r24, 0x00	; 0
    5858:	99 f0       	breq	.+38     	; 0x5880 <xTimerCreate+0x68>
            {
                /* Status is thus far zero as the timer is not created statically
                 * and has not been started.  The auto-reload bit may get set in
                 * prvInitialiseNewTimer. */
                pxNewTimer->ucStatus = 0x00;
    585a:	e9 81       	ldd	r30, Y+1	; 0x01
    585c:	fa 81       	ldd	r31, Y+2	; 0x02
    585e:	12 8a       	std	Z+18, r1	; 0x12
                prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
    5860:	8b 81       	ldd	r24, Y+3	; 0x03
    5862:	9c 81       	ldd	r25, Y+4	; 0x04
    5864:	2d 81       	ldd	r18, Y+5	; 0x05
    5866:	3e 81       	ldd	r19, Y+6	; 0x06
    5868:	e8 85       	ldd	r30, Y+8	; 0x08
    586a:	f9 85       	ldd	r31, Y+9	; 0x09
    586c:	aa 85       	ldd	r26, Y+10	; 0x0a
    586e:	bb 85       	ldd	r27, Y+11	; 0x0b
    5870:	e9 80       	ldd	r14, Y+1	; 0x01
    5872:	fa 80       	ldd	r15, Y+2	; 0x02
    5874:	b9 01       	movw	r22, r18
    5876:	4f 81       	ldd	r20, Y+7	; 0x07
    5878:	9f 01       	movw	r18, r30
    587a:	8d 01       	movw	r16, r26
    587c:	0e 94 4f 2c 	call	0x589e	; 0x589e <prvInitialiseNewTimer>
            }

            return pxNewTimer;
    5880:	89 81       	ldd	r24, Y+1	; 0x01
    5882:	9a 81       	ldd	r25, Y+2	; 0x02
        }
    5884:	2b 96       	adiw	r28, 0x0b	; 11
    5886:	0f b6       	in	r0, 0x3f	; 63
    5888:	f8 94       	cli
    588a:	de bf       	out	0x3e, r29	; 62
    588c:	0f be       	out	0x3f, r0	; 63
    588e:	cd bf       	out	0x3d, r28	; 61
    5890:	cf 91       	pop	r28
    5892:	df 91       	pop	r29
    5894:	1f 91       	pop	r17
    5896:	0f 91       	pop	r16
    5898:	ff 90       	pop	r15
    589a:	ef 90       	pop	r14
    589c:	08 95       	ret

0000589e <prvInitialiseNewTimer>:
                                       const TickType_t xTimerPeriodInTicks,
                                       const UBaseType_t uxAutoReload,
                                       void * const pvTimerID,
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer )
    {
    589e:	ef 92       	push	r14
    58a0:	ff 92       	push	r15
    58a2:	0f 93       	push	r16
    58a4:	1f 93       	push	r17
    58a6:	df 93       	push	r29
    58a8:	cf 93       	push	r28
    58aa:	cd b7       	in	r28, 0x3d	; 61
    58ac:	de b7       	in	r29, 0x3e	; 62
    58ae:	2b 97       	sbiw	r28, 0x0b	; 11
    58b0:	0f b6       	in	r0, 0x3f	; 63
    58b2:	f8 94       	cli
    58b4:	de bf       	out	0x3e, r29	; 62
    58b6:	0f be       	out	0x3f, r0	; 63
    58b8:	cd bf       	out	0x3d, r28	; 61
    58ba:	9a 83       	std	Y+2, r25	; 0x02
    58bc:	89 83       	std	Y+1, r24	; 0x01
    58be:	7c 83       	std	Y+4, r23	; 0x04
    58c0:	6b 83       	std	Y+3, r22	; 0x03
    58c2:	4d 83       	std	Y+5, r20	; 0x05
    58c4:	3f 83       	std	Y+7, r19	; 0x07
    58c6:	2e 83       	std	Y+6, r18	; 0x06
    58c8:	19 87       	std	Y+9, r17	; 0x09
    58ca:	08 87       	std	Y+8, r16	; 0x08
    58cc:	fb 86       	std	Y+11, r15	; 0x0b
    58ce:	ea 86       	std	Y+10, r14	; 0x0a
        /* 0 is not a valid value for xTimerPeriodInTicks. */
        configASSERT( ( xTimerPeriodInTicks > 0 ) );

        /* Ensure the infrastructure used by the timer service task has been
         * created/initialised. */
        prvCheckForValidListAndQueue();
    58d0:	0e 94 a2 30 	call	0x6144	; 0x6144 <prvCheckForValidListAndQueue>

        /* Initialise the timer structure members using the function
         * parameters. */
        pxNewTimer->pcTimerName = pcTimerName;
    58d4:	ea 85       	ldd	r30, Y+10	; 0x0a
    58d6:	fb 85       	ldd	r31, Y+11	; 0x0b
    58d8:	89 81       	ldd	r24, Y+1	; 0x01
    58da:	9a 81       	ldd	r25, Y+2	; 0x02
    58dc:	91 83       	std	Z+1, r25	; 0x01
    58de:	80 83       	st	Z, r24
        pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    58e0:	ea 85       	ldd	r30, Y+10	; 0x0a
    58e2:	fb 85       	ldd	r31, Y+11	; 0x0b
    58e4:	8b 81       	ldd	r24, Y+3	; 0x03
    58e6:	9c 81       	ldd	r25, Y+4	; 0x04
    58e8:	95 87       	std	Z+13, r25	; 0x0d
    58ea:	84 87       	std	Z+12, r24	; 0x0c
        pxNewTimer->pvTimerID = pvTimerID;
    58ec:	ea 85       	ldd	r30, Y+10	; 0x0a
    58ee:	fb 85       	ldd	r31, Y+11	; 0x0b
    58f0:	8e 81       	ldd	r24, Y+6	; 0x06
    58f2:	9f 81       	ldd	r25, Y+7	; 0x07
    58f4:	97 87       	std	Z+15, r25	; 0x0f
    58f6:	86 87       	std	Z+14, r24	; 0x0e
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    58f8:	ea 85       	ldd	r30, Y+10	; 0x0a
    58fa:	fb 85       	ldd	r31, Y+11	; 0x0b
    58fc:	88 85       	ldd	r24, Y+8	; 0x08
    58fe:	99 85       	ldd	r25, Y+9	; 0x09
    5900:	91 8b       	std	Z+17, r25	; 0x11
    5902:	80 8b       	std	Z+16, r24	; 0x10
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    5904:	8a 85       	ldd	r24, Y+10	; 0x0a
    5906:	9b 85       	ldd	r25, Y+11	; 0x0b
    5908:	02 96       	adiw	r24, 0x02	; 2
    590a:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <vListInitialiseItem>

        if( uxAutoReload != pdFALSE )
    590e:	8d 81       	ldd	r24, Y+5	; 0x05
    5910:	88 23       	and	r24, r24
    5912:	39 f0       	breq	.+14     	; 0x5922 <prvInitialiseNewTimer+0x84>
        {
            pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    5914:	ea 85       	ldd	r30, Y+10	; 0x0a
    5916:	fb 85       	ldd	r31, Y+11	; 0x0b
    5918:	82 89       	ldd	r24, Z+18	; 0x12
    591a:	84 60       	ori	r24, 0x04	; 4
    591c:	ea 85       	ldd	r30, Y+10	; 0x0a
    591e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5920:	82 8b       	std	Z+18, r24	; 0x12
        }

        traceTIMER_CREATE( pxNewTimer );
    }
    5922:	2b 96       	adiw	r28, 0x0b	; 11
    5924:	0f b6       	in	r0, 0x3f	; 63
    5926:	f8 94       	cli
    5928:	de bf       	out	0x3e, r29	; 62
    592a:	0f be       	out	0x3f, r0	; 63
    592c:	cd bf       	out	0x3d, r28	; 61
    592e:	cf 91       	pop	r28
    5930:	df 91       	pop	r29
    5932:	1f 91       	pop	r17
    5934:	0f 91       	pop	r16
    5936:	ff 90       	pop	r15
    5938:	ef 90       	pop	r14
    593a:	08 95       	ret

0000593c <xTimerGenericCommand>:
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
    593c:	0f 93       	push	r16
    593e:	1f 93       	push	r17
    5940:	df 93       	push	r29
    5942:	cf 93       	push	r28
    5944:	cd b7       	in	r28, 0x3d	; 61
    5946:	de b7       	in	r29, 0x3e	; 62
    5948:	2f 97       	sbiw	r28, 0x0f	; 15
    594a:	0f b6       	in	r0, 0x3f	; 63
    594c:	f8 94       	cli
    594e:	de bf       	out	0x3e, r29	; 62
    5950:	0f be       	out	0x3f, r0	; 63
    5952:	cd bf       	out	0x3d, r28	; 61
    5954:	98 87       	std	Y+8, r25	; 0x08
    5956:	8f 83       	std	Y+7, r24	; 0x07
    5958:	69 87       	std	Y+9, r22	; 0x09
    595a:	5b 87       	std	Y+11, r21	; 0x0b
    595c:	4a 87       	std	Y+10, r20	; 0x0a
    595e:	3d 87       	std	Y+13, r19	; 0x0d
    5960:	2c 87       	std	Y+12, r18	; 0x0c
    5962:	1f 87       	std	Y+15, r17	; 0x0f
    5964:	0e 87       	std	Y+14, r16	; 0x0e
        BaseType_t xReturn = pdFAIL;
    5966:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTimer );

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
    5968:	80 91 04 07 	lds	r24, 0x0704
    596c:	90 91 05 07 	lds	r25, 0x0705
    5970:	00 97       	sbiw	r24, 0x00	; 0
    5972:	e9 f1       	breq	.+122    	; 0x59ee <xTimerGenericCommand+0xb2>
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
    5974:	89 85       	ldd	r24, Y+9	; 0x09
    5976:	8a 83       	std	Y+2, r24	; 0x02
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    5978:	8a 85       	ldd	r24, Y+10	; 0x0a
    597a:	9b 85       	ldd	r25, Y+11	; 0x0b
    597c:	9c 83       	std	Y+4, r25	; 0x04
    597e:	8b 83       	std	Y+3, r24	; 0x03
            xMessage.u.xTimerParameters.pxTimer = xTimer;
    5980:	8f 81       	ldd	r24, Y+7	; 0x07
    5982:	98 85       	ldd	r25, Y+8	; 0x08
    5984:	9e 83       	std	Y+6, r25	; 0x06
    5986:	8d 83       	std	Y+5, r24	; 0x05

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    5988:	89 85       	ldd	r24, Y+9	; 0x09
    598a:	86 30       	cpi	r24, 0x06	; 6
    598c:	14 f5       	brge	.+68     	; 0x59d2 <xTimerGenericCommand+0x96>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    598e:	0e 94 b8 23 	call	0x4770	; 0x4770 <xTaskGetSchedulerState>
    5992:	82 30       	cpi	r24, 0x02	; 2
    5994:	79 f4       	brne	.+30     	; 0x59b4 <xTimerGenericCommand+0x78>
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    5996:	80 91 04 07 	lds	r24, 0x0704
    599a:	90 91 05 07 	lds	r25, 0x0705
    599e:	9e 01       	movw	r18, r28
    59a0:	2e 5f       	subi	r18, 0xFE	; 254
    59a2:	3f 4f       	sbci	r19, 0xFF	; 255
    59a4:	4e 85       	ldd	r20, Y+14	; 0x0e
    59a6:	5f 85       	ldd	r21, Y+15	; 0x0f
    59a8:	b9 01       	movw	r22, r18
    59aa:	20 e0       	ldi	r18, 0x00	; 0
    59ac:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <xQueueGenericSend>
    59b0:	89 83       	std	Y+1, r24	; 0x01
    59b2:	1d c0       	rjmp	.+58     	; 0x59ee <xTimerGenericCommand+0xb2>
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    59b4:	80 91 04 07 	lds	r24, 0x0704
    59b8:	90 91 05 07 	lds	r25, 0x0705
    59bc:	9e 01       	movw	r18, r28
    59be:	2e 5f       	subi	r18, 0xFE	; 254
    59c0:	3f 4f       	sbci	r19, 0xFF	; 255
    59c2:	b9 01       	movw	r22, r18
    59c4:	40 e0       	ldi	r20, 0x00	; 0
    59c6:	50 e0       	ldi	r21, 0x00	; 0
    59c8:	20 e0       	ldi	r18, 0x00	; 0
    59ca:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <xQueueGenericSend>
    59ce:	89 83       	std	Y+1, r24	; 0x01
    59d0:	0e c0       	rjmp	.+28     	; 0x59ee <xTimerGenericCommand+0xb2>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    59d2:	80 91 04 07 	lds	r24, 0x0704
    59d6:	90 91 05 07 	lds	r25, 0x0705
    59da:	9e 01       	movw	r18, r28
    59dc:	2e 5f       	subi	r18, 0xFE	; 254
    59de:	3f 4f       	sbci	r19, 0xFF	; 255
    59e0:	4c 85       	ldd	r20, Y+12	; 0x0c
    59e2:	5d 85       	ldd	r21, Y+13	; 0x0d
    59e4:	b9 01       	movw	r22, r18
    59e6:	20 e0       	ldi	r18, 0x00	; 0
    59e8:	0e 94 a3 10 	call	0x2146	; 0x2146 <xQueueGenericSendFromISR>
    59ec:	89 83       	std	Y+1, r24	; 0x01
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    59ee:	89 81       	ldd	r24, Y+1	; 0x01
    }
    59f0:	2f 96       	adiw	r28, 0x0f	; 15
    59f2:	0f b6       	in	r0, 0x3f	; 63
    59f4:	f8 94       	cli
    59f6:	de bf       	out	0x3e, r29	; 62
    59f8:	0f be       	out	0x3f, r0	; 63
    59fa:	cd bf       	out	0x3d, r28	; 61
    59fc:	cf 91       	pop	r28
    59fe:	df 91       	pop	r29
    5a00:	1f 91       	pop	r17
    5a02:	0f 91       	pop	r16
    5a04:	08 95       	ret

00005a06 <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
    {
    5a06:	df 93       	push	r29
    5a08:	cf 93       	push	r28
    5a0a:	cd b7       	in	r28, 0x3d	; 61
    5a0c:	de b7       	in	r29, 0x3e	; 62
        /* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
         * started, then xTimerTaskHandle will be NULL. */
        configASSERT( ( xTimerTaskHandle != NULL ) );
        return xTimerTaskHandle;
    5a0e:	80 91 06 07 	lds	r24, 0x0706
    5a12:	90 91 07 07 	lds	r25, 0x0707
    }
    5a16:	cf 91       	pop	r28
    5a18:	df 91       	pop	r29
    5a1a:	08 95       	ret

00005a1c <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
    {
    5a1c:	df 93       	push	r29
    5a1e:	cf 93       	push	r28
    5a20:	00 d0       	rcall	.+0      	; 0x5a22 <xTimerGetPeriod+0x6>
    5a22:	00 d0       	rcall	.+0      	; 0x5a24 <xTimerGetPeriod+0x8>
    5a24:	cd b7       	in	r28, 0x3d	; 61
    5a26:	de b7       	in	r29, 0x3e	; 62
    5a28:	9c 83       	std	Y+4, r25	; 0x04
    5a2a:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    5a2c:	8b 81       	ldd	r24, Y+3	; 0x03
    5a2e:	9c 81       	ldd	r25, Y+4	; 0x04
    5a30:	9a 83       	std	Y+2, r25	; 0x02
    5a32:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->xTimerPeriodInTicks;
    5a34:	e9 81       	ldd	r30, Y+1	; 0x01
    5a36:	fa 81       	ldd	r31, Y+2	; 0x02
    5a38:	84 85       	ldd	r24, Z+12	; 0x0c
    5a3a:	95 85       	ldd	r25, Z+13	; 0x0d
    }
    5a3c:	0f 90       	pop	r0
    5a3e:	0f 90       	pop	r0
    5a40:	0f 90       	pop	r0
    5a42:	0f 90       	pop	r0
    5a44:	cf 91       	pop	r28
    5a46:	df 91       	pop	r29
    5a48:	08 95       	ret

00005a4a <vTimerSetReloadMode>:
/*-----------------------------------------------------------*/

    void vTimerSetReloadMode( TimerHandle_t xTimer,
                              const UBaseType_t uxAutoReload )
    {
    5a4a:	df 93       	push	r29
    5a4c:	cf 93       	push	r28
    5a4e:	00 d0       	rcall	.+0      	; 0x5a50 <vTimerSetReloadMode+0x6>
    5a50:	00 d0       	rcall	.+0      	; 0x5a52 <vTimerSetReloadMode+0x8>
    5a52:	0f 92       	push	r0
    5a54:	cd b7       	in	r28, 0x3d	; 61
    5a56:	de b7       	in	r29, 0x3e	; 62
    5a58:	9c 83       	std	Y+4, r25	; 0x04
    5a5a:	8b 83       	std	Y+3, r24	; 0x03
    5a5c:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * pxTimer = xTimer;
    5a5e:	8b 81       	ldd	r24, Y+3	; 0x03
    5a60:	9c 81       	ldd	r25, Y+4	; 0x04
    5a62:	9a 83       	std	Y+2, r25	; 0x02
    5a64:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    5a66:	0f b6       	in	r0, 0x3f	; 63
    5a68:	f8 94       	cli
    5a6a:	0f 92       	push	r0
        {
            if( uxAutoReload != pdFALSE )
    5a6c:	8d 81       	ldd	r24, Y+5	; 0x05
    5a6e:	88 23       	and	r24, r24
    5a70:	41 f0       	breq	.+16     	; 0x5a82 <vTimerSetReloadMode+0x38>
            {
                pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    5a72:	e9 81       	ldd	r30, Y+1	; 0x01
    5a74:	fa 81       	ldd	r31, Y+2	; 0x02
    5a76:	82 89       	ldd	r24, Z+18	; 0x12
    5a78:	84 60       	ori	r24, 0x04	; 4
    5a7a:	e9 81       	ldd	r30, Y+1	; 0x01
    5a7c:	fa 81       	ldd	r31, Y+2	; 0x02
    5a7e:	82 8b       	std	Z+18, r24	; 0x12
    5a80:	07 c0       	rjmp	.+14     	; 0x5a90 <vTimerSetReloadMode+0x46>
            }
            else
            {
                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_AUTORELOAD );
    5a82:	e9 81       	ldd	r30, Y+1	; 0x01
    5a84:	fa 81       	ldd	r31, Y+2	; 0x02
    5a86:	82 89       	ldd	r24, Z+18	; 0x12
    5a88:	8b 7f       	andi	r24, 0xFB	; 251
    5a8a:	e9 81       	ldd	r30, Y+1	; 0x01
    5a8c:	fa 81       	ldd	r31, Y+2	; 0x02
    5a8e:	82 8b       	std	Z+18, r24	; 0x12
            }
        }
        taskEXIT_CRITICAL();
    5a90:	0f 90       	pop	r0
    5a92:	0f be       	out	0x3f, r0	; 63
    }
    5a94:	0f 90       	pop	r0
    5a96:	0f 90       	pop	r0
    5a98:	0f 90       	pop	r0
    5a9a:	0f 90       	pop	r0
    5a9c:	0f 90       	pop	r0
    5a9e:	cf 91       	pop	r28
    5aa0:	df 91       	pop	r29
    5aa2:	08 95       	ret

00005aa4 <uxTimerGetReloadMode>:
/*-----------------------------------------------------------*/

    UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
    {
    5aa4:	df 93       	push	r29
    5aa6:	cf 93       	push	r28
    5aa8:	00 d0       	rcall	.+0      	; 0x5aaa <uxTimerGetReloadMode+0x6>
    5aaa:	00 d0       	rcall	.+0      	; 0x5aac <uxTimerGetReloadMode+0x8>
    5aac:	0f 92       	push	r0
    5aae:	cd b7       	in	r28, 0x3d	; 61
    5ab0:	de b7       	in	r29, 0x3e	; 62
    5ab2:	9d 83       	std	Y+5, r25	; 0x05
    5ab4:	8c 83       	std	Y+4, r24	; 0x04
        Timer_t * pxTimer = xTimer;
    5ab6:	8c 81       	ldd	r24, Y+4	; 0x04
    5ab8:	9d 81       	ldd	r25, Y+5	; 0x05
    5aba:	9b 83       	std	Y+3, r25	; 0x03
    5abc:	8a 83       	std	Y+2, r24	; 0x02
        UBaseType_t uxReturn;

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    5abe:	0f b6       	in	r0, 0x3f	; 63
    5ac0:	f8 94       	cli
    5ac2:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
    5ac4:	ea 81       	ldd	r30, Y+2	; 0x02
    5ac6:	fb 81       	ldd	r31, Y+3	; 0x03
    5ac8:	82 89       	ldd	r24, Z+18	; 0x12
    5aca:	88 2f       	mov	r24, r24
    5acc:	90 e0       	ldi	r25, 0x00	; 0
    5ace:	84 70       	andi	r24, 0x04	; 4
    5ad0:	90 70       	andi	r25, 0x00	; 0
    5ad2:	00 97       	sbiw	r24, 0x00	; 0
    5ad4:	11 f4       	brne	.+4      	; 0x5ada <uxTimerGetReloadMode+0x36>
            {
                /* Not an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdFALSE;
    5ad6:	19 82       	std	Y+1, r1	; 0x01
    5ad8:	02 c0       	rjmp	.+4      	; 0x5ade <uxTimerGetReloadMode+0x3a>
            }
            else
            {
                /* Is an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdTRUE;
    5ada:	81 e0       	ldi	r24, 0x01	; 1
    5adc:	89 83       	std	Y+1, r24	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    5ade:	0f 90       	pop	r0
    5ae0:	0f be       	out	0x3f, r0	; 63

        return uxReturn;
    5ae2:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5ae4:	0f 90       	pop	r0
    5ae6:	0f 90       	pop	r0
    5ae8:	0f 90       	pop	r0
    5aea:	0f 90       	pop	r0
    5aec:	0f 90       	pop	r0
    5aee:	cf 91       	pop	r28
    5af0:	df 91       	pop	r29
    5af2:	08 95       	ret

00005af4 <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
    {
    5af4:	df 93       	push	r29
    5af6:	cf 93       	push	r28
    5af8:	00 d0       	rcall	.+0      	; 0x5afa <xTimerGetExpiryTime+0x6>
    5afa:	00 d0       	rcall	.+0      	; 0x5afc <xTimerGetExpiryTime+0x8>
    5afc:	00 d0       	rcall	.+0      	; 0x5afe <xTimerGetExpiryTime+0xa>
    5afe:	cd b7       	in	r28, 0x3d	; 61
    5b00:	de b7       	in	r29, 0x3e	; 62
    5b02:	9e 83       	std	Y+6, r25	; 0x06
    5b04:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * pxTimer = xTimer;
    5b06:	8d 81       	ldd	r24, Y+5	; 0x05
    5b08:	9e 81       	ldd	r25, Y+6	; 0x06
    5b0a:	9c 83       	std	Y+4, r25	; 0x04
    5b0c:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xReturn;

        configASSERT( xTimer );
        xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
    5b0e:	eb 81       	ldd	r30, Y+3	; 0x03
    5b10:	fc 81       	ldd	r31, Y+4	; 0x04
    5b12:	82 81       	ldd	r24, Z+2	; 0x02
    5b14:	93 81       	ldd	r25, Z+3	; 0x03
    5b16:	9a 83       	std	Y+2, r25	; 0x02
    5b18:	89 83       	std	Y+1, r24	; 0x01
        return xReturn;
    5b1a:	89 81       	ldd	r24, Y+1	; 0x01
    5b1c:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    5b1e:	26 96       	adiw	r28, 0x06	; 6
    5b20:	0f b6       	in	r0, 0x3f	; 63
    5b22:	f8 94       	cli
    5b24:	de bf       	out	0x3e, r29	; 62
    5b26:	0f be       	out	0x3f, r0	; 63
    5b28:	cd bf       	out	0x3d, r28	; 61
    5b2a:	cf 91       	pop	r28
    5b2c:	df 91       	pop	r29
    5b2e:	08 95       	ret

00005b30 <pcTimerGetName>:
/*-----------------------------------------------------------*/

    const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
    5b30:	df 93       	push	r29
    5b32:	cf 93       	push	r28
    5b34:	00 d0       	rcall	.+0      	; 0x5b36 <pcTimerGetName+0x6>
    5b36:	00 d0       	rcall	.+0      	; 0x5b38 <pcTimerGetName+0x8>
    5b38:	cd b7       	in	r28, 0x3d	; 61
    5b3a:	de b7       	in	r29, 0x3e	; 62
    5b3c:	9c 83       	std	Y+4, r25	; 0x04
    5b3e:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    5b40:	8b 81       	ldd	r24, Y+3	; 0x03
    5b42:	9c 81       	ldd	r25, Y+4	; 0x04
    5b44:	9a 83       	std	Y+2, r25	; 0x02
    5b46:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->pcTimerName;
    5b48:	e9 81       	ldd	r30, Y+1	; 0x01
    5b4a:	fa 81       	ldd	r31, Y+2	; 0x02
    5b4c:	80 81       	ld	r24, Z
    5b4e:	91 81       	ldd	r25, Z+1	; 0x01
    }
    5b50:	0f 90       	pop	r0
    5b52:	0f 90       	pop	r0
    5b54:	0f 90       	pop	r0
    5b56:	0f 90       	pop	r0
    5b58:	cf 91       	pop	r28
    5b5a:	df 91       	pop	r29
    5b5c:	08 95       	ret

00005b5e <prvReloadTimer>:
/*-----------------------------------------------------------*/

    static void prvReloadTimer( Timer_t * const pxTimer,
                                TickType_t xExpiredTime,
                                const TickType_t xTimeNow )
    {
    5b5e:	df 93       	push	r29
    5b60:	cf 93       	push	r28
    5b62:	00 d0       	rcall	.+0      	; 0x5b64 <prvReloadTimer+0x6>
    5b64:	00 d0       	rcall	.+0      	; 0x5b66 <prvReloadTimer+0x8>
    5b66:	00 d0       	rcall	.+0      	; 0x5b68 <prvReloadTimer+0xa>
    5b68:	cd b7       	in	r28, 0x3d	; 61
    5b6a:	de b7       	in	r29, 0x3e	; 62
    5b6c:	9a 83       	std	Y+2, r25	; 0x02
    5b6e:	89 83       	std	Y+1, r24	; 0x01
    5b70:	7c 83       	std	Y+4, r23	; 0x04
    5b72:	6b 83       	std	Y+3, r22	; 0x03
    5b74:	5e 83       	std	Y+6, r21	; 0x06
    5b76:	4d 83       	std	Y+5, r20	; 0x05
    5b78:	12 c0       	rjmp	.+36     	; 0x5b9e <prvReloadTimer+0x40>
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
        {
            /* Advance the expiry time. */
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
    5b7a:	e9 81       	ldd	r30, Y+1	; 0x01
    5b7c:	fa 81       	ldd	r31, Y+2	; 0x02
    5b7e:	24 85       	ldd	r18, Z+12	; 0x0c
    5b80:	35 85       	ldd	r19, Z+13	; 0x0d
    5b82:	8b 81       	ldd	r24, Y+3	; 0x03
    5b84:	9c 81       	ldd	r25, Y+4	; 0x04
    5b86:	82 0f       	add	r24, r18
    5b88:	93 1f       	adc	r25, r19
    5b8a:	9c 83       	std	Y+4, r25	; 0x04
    5b8c:	8b 83       	std	Y+3, r24	; 0x03

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    5b8e:	e9 81       	ldd	r30, Y+1	; 0x01
    5b90:	fa 81       	ldd	r31, Y+2	; 0x02
    5b92:	00 88       	ldd	r0, Z+16	; 0x10
    5b94:	f1 89       	ldd	r31, Z+17	; 0x11
    5b96:	e0 2d       	mov	r30, r0
    5b98:	89 81       	ldd	r24, Y+1	; 0x01
    5b9a:	9a 81       	ldd	r25, Y+2	; 0x02
    5b9c:	09 95       	icall
                                const TickType_t xTimeNow )
    {
        /* Insert the timer into the appropriate list for the next expiry time.
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
    5b9e:	e9 81       	ldd	r30, Y+1	; 0x01
    5ba0:	fa 81       	ldd	r31, Y+2	; 0x02
    5ba2:	24 85       	ldd	r18, Z+12	; 0x0c
    5ba4:	35 85       	ldd	r19, Z+13	; 0x0d
    5ba6:	8b 81       	ldd	r24, Y+3	; 0x03
    5ba8:	9c 81       	ldd	r25, Y+4	; 0x04
    5baa:	a9 01       	movw	r20, r18
    5bac:	48 0f       	add	r20, r24
    5bae:	59 1f       	adc	r21, r25
    5bb0:	89 81       	ldd	r24, Y+1	; 0x01
    5bb2:	9a 81       	ldd	r25, Y+2	; 0x02
    5bb4:	2d 81       	ldd	r18, Y+5	; 0x05
    5bb6:	3e 81       	ldd	r19, Y+6	; 0x06
    5bb8:	eb 81       	ldd	r30, Y+3	; 0x03
    5bba:	fc 81       	ldd	r31, Y+4	; 0x04
    5bbc:	ba 01       	movw	r22, r20
    5bbe:	a9 01       	movw	r20, r18
    5bc0:	9f 01       	movw	r18, r30
    5bc2:	0e 94 05 2f 	call	0x5e0a	; 0x5e0a <prvInsertTimerInActiveList>
    5bc6:	88 23       	and	r24, r24
    5bc8:	c1 f6       	brne	.-80     	; 0x5b7a <prvReloadTimer+0x1c>

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
        }
    }
    5bca:	26 96       	adiw	r28, 0x06	; 6
    5bcc:	0f b6       	in	r0, 0x3f	; 63
    5bce:	f8 94       	cli
    5bd0:	de bf       	out	0x3e, r29	; 62
    5bd2:	0f be       	out	0x3f, r0	; 63
    5bd4:	cd bf       	out	0x3d, r28	; 61
    5bd6:	cf 91       	pop	r28
    5bd8:	df 91       	pop	r29
    5bda:	08 95       	ret

00005bdc <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
    5bdc:	df 93       	push	r29
    5bde:	cf 93       	push	r28
    5be0:	00 d0       	rcall	.+0      	; 0x5be2 <prvProcessExpiredTimer+0x6>
    5be2:	00 d0       	rcall	.+0      	; 0x5be4 <prvProcessExpiredTimer+0x8>
    5be4:	00 d0       	rcall	.+0      	; 0x5be6 <prvProcessExpiredTimer+0xa>
    5be6:	cd b7       	in	r28, 0x3d	; 61
    5be8:	de b7       	in	r29, 0x3e	; 62
    5bea:	9c 83       	std	Y+4, r25	; 0x04
    5bec:	8b 83       	std	Y+3, r24	; 0x03
    5bee:	7e 83       	std	Y+6, r23	; 0x06
    5bf0:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5bf2:	e0 91 1c 07 	lds	r30, 0x071C
    5bf6:	f0 91 1d 07 	lds	r31, 0x071D
    5bfa:	05 80       	ldd	r0, Z+5	; 0x05
    5bfc:	f6 81       	ldd	r31, Z+6	; 0x06
    5bfe:	e0 2d       	mov	r30, r0
    5c00:	86 81       	ldd	r24, Z+6	; 0x06
    5c02:	97 81       	ldd	r25, Z+7	; 0x07
    5c04:	9a 83       	std	Y+2, r25	; 0x02
    5c06:	89 83       	std	Y+1, r24	; 0x01

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    5c08:	89 81       	ldd	r24, Y+1	; 0x01
    5c0a:	9a 81       	ldd	r25, Y+2	; 0x02
    5c0c:	02 96       	adiw	r24, 0x02	; 2
    5c0e:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <uxListRemove>

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    5c12:	e9 81       	ldd	r30, Y+1	; 0x01
    5c14:	fa 81       	ldd	r31, Y+2	; 0x02
    5c16:	82 89       	ldd	r24, Z+18	; 0x12
    5c18:	88 2f       	mov	r24, r24
    5c1a:	90 e0       	ldi	r25, 0x00	; 0
    5c1c:	84 70       	andi	r24, 0x04	; 4
    5c1e:	90 70       	andi	r25, 0x00	; 0
    5c20:	00 97       	sbiw	r24, 0x00	; 0
    5c22:	51 f0       	breq	.+20     	; 0x5c38 <prvProcessExpiredTimer+0x5c>
        {
            prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
    5c24:	89 81       	ldd	r24, Y+1	; 0x01
    5c26:	9a 81       	ldd	r25, Y+2	; 0x02
    5c28:	2b 81       	ldd	r18, Y+3	; 0x03
    5c2a:	3c 81       	ldd	r19, Y+4	; 0x04
    5c2c:	4d 81       	ldd	r20, Y+5	; 0x05
    5c2e:	5e 81       	ldd	r21, Y+6	; 0x06
    5c30:	b9 01       	movw	r22, r18
    5c32:	0e 94 af 2d 	call	0x5b5e	; 0x5b5e <prvReloadTimer>
    5c36:	07 c0       	rjmp	.+14     	; 0x5c46 <prvProcessExpiredTimer+0x6a>
        }
        else
        {
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    5c38:	e9 81       	ldd	r30, Y+1	; 0x01
    5c3a:	fa 81       	ldd	r31, Y+2	; 0x02
    5c3c:	82 89       	ldd	r24, Z+18	; 0x12
    5c3e:	8e 7f       	andi	r24, 0xFE	; 254
    5c40:	e9 81       	ldd	r30, Y+1	; 0x01
    5c42:	fa 81       	ldd	r31, Y+2	; 0x02
    5c44:	82 8b       	std	Z+18, r24	; 0x12
        }

        /* Call the timer callback. */
        traceTIMER_EXPIRED( pxTimer );
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    5c46:	e9 81       	ldd	r30, Y+1	; 0x01
    5c48:	fa 81       	ldd	r31, Y+2	; 0x02
    5c4a:	00 88       	ldd	r0, Z+16	; 0x10
    5c4c:	f1 89       	ldd	r31, Z+17	; 0x11
    5c4e:	e0 2d       	mov	r30, r0
    5c50:	89 81       	ldd	r24, Y+1	; 0x01
    5c52:	9a 81       	ldd	r25, Y+2	; 0x02
    5c54:	09 95       	icall
    }
    5c56:	26 96       	adiw	r28, 0x06	; 6
    5c58:	0f b6       	in	r0, 0x3f	; 63
    5c5a:	f8 94       	cli
    5c5c:	de bf       	out	0x3e, r29	; 62
    5c5e:	0f be       	out	0x3f, r0	; 63
    5c60:	cd bf       	out	0x3d, r28	; 61
    5c62:	cf 91       	pop	r28
    5c64:	df 91       	pop	r29
    5c66:	08 95       	ret

00005c68 <prvTimerTask>:
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
    5c68:	df 93       	push	r29
    5c6a:	cf 93       	push	r28
    5c6c:	00 d0       	rcall	.+0      	; 0x5c6e <prvTimerTask+0x6>
    5c6e:	00 d0       	rcall	.+0      	; 0x5c70 <prvTimerTask+0x8>
    5c70:	0f 92       	push	r0
    5c72:	cd b7       	in	r28, 0x3d	; 61
    5c74:	de b7       	in	r29, 0x3e	; 62
    5c76:	9d 83       	std	Y+5, r25	; 0x05
    5c78:	8c 83       	std	Y+4, r24	; 0x04

        for( ; ; )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    5c7a:	ce 01       	movw	r24, r28
    5c7c:	03 96       	adiw	r24, 0x03	; 3
    5c7e:	0e 94 a3 2e 	call	0x5d46	; 0x5d46 <prvGetNextExpireTime>
    5c82:	9a 83       	std	Y+2, r25	; 0x02
    5c84:	89 83       	std	Y+1, r24	; 0x01

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    5c86:	2b 81       	ldd	r18, Y+3	; 0x03
    5c88:	89 81       	ldd	r24, Y+1	; 0x01
    5c8a:	9a 81       	ldd	r25, Y+2	; 0x02
    5c8c:	62 2f       	mov	r22, r18
    5c8e:	0e 94 4c 2e 	call	0x5c98	; 0x5c98 <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
    5c92:	0e 94 6d 2f 	call	0x5eda	; 0x5eda <prvProcessReceivedCommands>
    5c96:	f1 cf       	rjmp	.-30     	; 0x5c7a <prvTimerTask+0x12>

00005c98 <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
    5c98:	df 93       	push	r29
    5c9a:	cf 93       	push	r28
    5c9c:	00 d0       	rcall	.+0      	; 0x5c9e <prvProcessTimerOrBlockTask+0x6>
    5c9e:	00 d0       	rcall	.+0      	; 0x5ca0 <prvProcessTimerOrBlockTask+0x8>
    5ca0:	00 d0       	rcall	.+0      	; 0x5ca2 <prvProcessTimerOrBlockTask+0xa>
    5ca2:	cd b7       	in	r28, 0x3d	; 61
    5ca4:	de b7       	in	r29, 0x3e	; 62
    5ca6:	9d 83       	std	Y+5, r25	; 0x05
    5ca8:	8c 83       	std	Y+4, r24	; 0x04
    5caa:	6e 83       	std	Y+6, r22	; 0x06
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
    5cac:	0e 94 44 1b 	call	0x3688	; 0x3688 <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    5cb0:	ce 01       	movw	r24, r28
    5cb2:	03 96       	adiw	r24, 0x03	; 3
    5cb4:	0e 94 d7 2e 	call	0x5dae	; 0x5dae <prvSampleTimeNow>
    5cb8:	9a 83       	std	Y+2, r25	; 0x02
    5cba:	89 83       	std	Y+1, r24	; 0x01

            if( xTimerListsWereSwitched == pdFALSE )
    5cbc:	8b 81       	ldd	r24, Y+3	; 0x03
    5cbe:	88 23       	and	r24, r24
    5cc0:	b9 f5       	brne	.+110    	; 0x5d30 <prvProcessTimerOrBlockTask+0x98>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    5cc2:	8e 81       	ldd	r24, Y+6	; 0x06
    5cc4:	88 23       	and	r24, r24
    5cc6:	89 f4       	brne	.+34     	; 0x5cea <prvProcessTimerOrBlockTask+0x52>
    5cc8:	2c 81       	ldd	r18, Y+4	; 0x04
    5cca:	3d 81       	ldd	r19, Y+5	; 0x05
    5ccc:	89 81       	ldd	r24, Y+1	; 0x01
    5cce:	9a 81       	ldd	r25, Y+2	; 0x02
    5cd0:	82 17       	cp	r24, r18
    5cd2:	93 07       	cpc	r25, r19
    5cd4:	50 f0       	brcs	.+20     	; 0x5cea <prvProcessTimerOrBlockTask+0x52>
                {
                    ( void ) xTaskResumeAll();
    5cd6:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    5cda:	8c 81       	ldd	r24, Y+4	; 0x04
    5cdc:	9d 81       	ldd	r25, Y+5	; 0x05
    5cde:	29 81       	ldd	r18, Y+1	; 0x01
    5ce0:	3a 81       	ldd	r19, Y+2	; 0x02
    5ce2:	b9 01       	movw	r22, r18
    5ce4:	0e 94 ee 2d 	call	0x5bdc	; 0x5bdc <prvProcessExpiredTimer>
    5ce8:	25 c0       	rjmp	.+74     	; 0x5d34 <prvProcessTimerOrBlockTask+0x9c>
                     * time has not been reached yet.  This task should therefore
                     * block to wait for the next expire time or a command to be
                     * received - whichever comes first.  The following line cannot
                     * be reached unless xNextExpireTime > xTimeNow, except in the
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
    5cea:	8e 81       	ldd	r24, Y+6	; 0x06
    5cec:	88 23       	and	r24, r24
    5cee:	51 f0       	breq	.+20     	; 0x5d04 <prvProcessTimerOrBlockTask+0x6c>
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    5cf0:	e0 91 1e 07 	lds	r30, 0x071E
    5cf4:	f0 91 1f 07 	lds	r31, 0x071F
    5cf8:	80 81       	ld	r24, Z
    5cfa:	1e 82       	std	Y+6, r1	; 0x06
    5cfc:	88 23       	and	r24, r24
    5cfe:	11 f4       	brne	.+4      	; 0x5d04 <prvProcessTimerOrBlockTask+0x6c>
    5d00:	81 e0       	ldi	r24, 0x01	; 1
    5d02:	8e 83       	std	Y+6, r24	; 0x06
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    5d04:	40 91 04 07 	lds	r20, 0x0704
    5d08:	50 91 05 07 	lds	r21, 0x0705
    5d0c:	2c 81       	ldd	r18, Y+4	; 0x04
    5d0e:	3d 81       	ldd	r19, Y+5	; 0x05
    5d10:	89 81       	ldd	r24, Y+1	; 0x01
    5d12:	9a 81       	ldd	r25, Y+2	; 0x02
    5d14:	28 1b       	sub	r18, r24
    5d16:	39 0b       	sbc	r19, r25
    5d18:	ca 01       	movw	r24, r20
    5d1a:	b9 01       	movw	r22, r18
    5d1c:	4e 81       	ldd	r20, Y+6	; 0x06
    5d1e:	0e 94 b0 17 	call	0x2f60	; 0x2f60 <vQueueWaitForMessageRestricted>

                    if( xTaskResumeAll() == pdFALSE )
    5d22:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>
    5d26:	88 23       	and	r24, r24
    5d28:	29 f4       	brne	.+10     	; 0x5d34 <prvProcessTimerOrBlockTask+0x9c>
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
    5d2a:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    5d2e:	02 c0       	rjmp	.+4      	; 0x5d34 <prvProcessTimerOrBlockTask+0x9c>
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
    5d30:	0e 94 50 1b 	call	0x36a0	; 0x36a0 <xTaskResumeAll>
            }
        }
    }
    5d34:	26 96       	adiw	r28, 0x06	; 6
    5d36:	0f b6       	in	r0, 0x3f	; 63
    5d38:	f8 94       	cli
    5d3a:	de bf       	out	0x3e, r29	; 62
    5d3c:	0f be       	out	0x3f, r0	; 63
    5d3e:	cd bf       	out	0x3d, r28	; 61
    5d40:	cf 91       	pop	r28
    5d42:	df 91       	pop	r29
    5d44:	08 95       	ret

00005d46 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
    5d46:	df 93       	push	r29
    5d48:	cf 93       	push	r28
    5d4a:	00 d0       	rcall	.+0      	; 0x5d4c <prvGetNextExpireTime+0x6>
    5d4c:	00 d0       	rcall	.+0      	; 0x5d4e <prvGetNextExpireTime+0x8>
    5d4e:	0f 92       	push	r0
    5d50:	cd b7       	in	r28, 0x3d	; 61
    5d52:	de b7       	in	r29, 0x3e	; 62
    5d54:	9c 83       	std	Y+4, r25	; 0x04
    5d56:	8b 83       	std	Y+3, r24	; 0x03
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    5d58:	e0 91 1c 07 	lds	r30, 0x071C
    5d5c:	f0 91 1d 07 	lds	r31, 0x071D
    5d60:	80 81       	ld	r24, Z
    5d62:	1d 82       	std	Y+5, r1	; 0x05
    5d64:	88 23       	and	r24, r24
    5d66:	11 f4       	brne	.+4      	; 0x5d6c <prvGetNextExpireTime+0x26>
    5d68:	81 e0       	ldi	r24, 0x01	; 1
    5d6a:	8d 83       	std	Y+5, r24	; 0x05
    5d6c:	eb 81       	ldd	r30, Y+3	; 0x03
    5d6e:	fc 81       	ldd	r31, Y+4	; 0x04
    5d70:	8d 81       	ldd	r24, Y+5	; 0x05
    5d72:	80 83       	st	Z, r24

        if( *pxListWasEmpty == pdFALSE )
    5d74:	eb 81       	ldd	r30, Y+3	; 0x03
    5d76:	fc 81       	ldd	r31, Y+4	; 0x04
    5d78:	80 81       	ld	r24, Z
    5d7a:	88 23       	and	r24, r24
    5d7c:	61 f4       	brne	.+24     	; 0x5d96 <prvGetNextExpireTime+0x50>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    5d7e:	e0 91 1c 07 	lds	r30, 0x071C
    5d82:	f0 91 1d 07 	lds	r31, 0x071D
    5d86:	05 80       	ldd	r0, Z+5	; 0x05
    5d88:	f6 81       	ldd	r31, Z+6	; 0x06
    5d8a:	e0 2d       	mov	r30, r0
    5d8c:	80 81       	ld	r24, Z
    5d8e:	91 81       	ldd	r25, Z+1	; 0x01
    5d90:	9a 83       	std	Y+2, r25	; 0x02
    5d92:	89 83       	std	Y+1, r24	; 0x01
    5d94:	02 c0       	rjmp	.+4      	; 0x5d9a <prvGetNextExpireTime+0x54>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
    5d96:	1a 82       	std	Y+2, r1	; 0x02
    5d98:	19 82       	std	Y+1, r1	; 0x01
        }

        return xNextExpireTime;
    5d9a:	89 81       	ldd	r24, Y+1	; 0x01
    5d9c:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    5d9e:	0f 90       	pop	r0
    5da0:	0f 90       	pop	r0
    5da2:	0f 90       	pop	r0
    5da4:	0f 90       	pop	r0
    5da6:	0f 90       	pop	r0
    5da8:	cf 91       	pop	r28
    5daa:	df 91       	pop	r29
    5dac:	08 95       	ret

00005dae <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
    5dae:	df 93       	push	r29
    5db0:	cf 93       	push	r28
    5db2:	00 d0       	rcall	.+0      	; 0x5db4 <prvSampleTimeNow+0x6>
    5db4:	00 d0       	rcall	.+0      	; 0x5db6 <prvSampleTimeNow+0x8>
    5db6:	cd b7       	in	r28, 0x3d	; 61
    5db8:	de b7       	in	r29, 0x3e	; 62
    5dba:	9c 83       	std	Y+4, r25	; 0x04
    5dbc:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
    5dbe:	0e 94 a0 1c 	call	0x3940	; 0x3940 <xTaskGetTickCount>
    5dc2:	9a 83       	std	Y+2, r25	; 0x02
    5dc4:	89 83       	std	Y+1, r24	; 0x01

        if( xTimeNow < xLastTime )
    5dc6:	20 91 08 07 	lds	r18, 0x0708
    5dca:	30 91 09 07 	lds	r19, 0x0709
    5dce:	89 81       	ldd	r24, Y+1	; 0x01
    5dd0:	9a 81       	ldd	r25, Y+2	; 0x02
    5dd2:	82 17       	cp	r24, r18
    5dd4:	93 07       	cpc	r25, r19
    5dd6:	38 f4       	brcc	.+14     	; 0x5de6 <prvSampleTimeNow+0x38>
        {
            prvSwitchTimerLists();
    5dd8:	0e 94 68 30 	call	0x60d0	; 0x60d0 <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
    5ddc:	eb 81       	ldd	r30, Y+3	; 0x03
    5dde:	fc 81       	ldd	r31, Y+4	; 0x04
    5de0:	81 e0       	ldi	r24, 0x01	; 1
    5de2:	80 83       	st	Z, r24
    5de4:	03 c0       	rjmp	.+6      	; 0x5dec <prvSampleTimeNow+0x3e>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
    5de6:	eb 81       	ldd	r30, Y+3	; 0x03
    5de8:	fc 81       	ldd	r31, Y+4	; 0x04
    5dea:	10 82       	st	Z, r1
        }

        xLastTime = xTimeNow;
    5dec:	89 81       	ldd	r24, Y+1	; 0x01
    5dee:	9a 81       	ldd	r25, Y+2	; 0x02
    5df0:	90 93 09 07 	sts	0x0709, r25
    5df4:	80 93 08 07 	sts	0x0708, r24

        return xTimeNow;
    5df8:	89 81       	ldd	r24, Y+1	; 0x01
    5dfa:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    5dfc:	0f 90       	pop	r0
    5dfe:	0f 90       	pop	r0
    5e00:	0f 90       	pop	r0
    5e02:	0f 90       	pop	r0
    5e04:	cf 91       	pop	r28
    5e06:	df 91       	pop	r29
    5e08:	08 95       	ret

00005e0a <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
    5e0a:	df 93       	push	r29
    5e0c:	cf 93       	push	r28
    5e0e:	cd b7       	in	r28, 0x3d	; 61
    5e10:	de b7       	in	r29, 0x3e	; 62
    5e12:	29 97       	sbiw	r28, 0x09	; 9
    5e14:	0f b6       	in	r0, 0x3f	; 63
    5e16:	f8 94       	cli
    5e18:	de bf       	out	0x3e, r29	; 62
    5e1a:	0f be       	out	0x3f, r0	; 63
    5e1c:	cd bf       	out	0x3d, r28	; 61
    5e1e:	9b 83       	std	Y+3, r25	; 0x03
    5e20:	8a 83       	std	Y+2, r24	; 0x02
    5e22:	7d 83       	std	Y+5, r23	; 0x05
    5e24:	6c 83       	std	Y+4, r22	; 0x04
    5e26:	5f 83       	std	Y+7, r21	; 0x07
    5e28:	4e 83       	std	Y+6, r20	; 0x06
    5e2a:	39 87       	std	Y+9, r19	; 0x09
    5e2c:	28 87       	std	Y+8, r18	; 0x08
        BaseType_t xProcessTimerNow = pdFALSE;
    5e2e:	19 82       	std	Y+1, r1	; 0x01

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    5e30:	ea 81       	ldd	r30, Y+2	; 0x02
    5e32:	fb 81       	ldd	r31, Y+3	; 0x03
    5e34:	8c 81       	ldd	r24, Y+4	; 0x04
    5e36:	9d 81       	ldd	r25, Y+5	; 0x05
    5e38:	93 83       	std	Z+3, r25	; 0x03
    5e3a:	82 83       	std	Z+2, r24	; 0x02
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    5e3c:	ea 81       	ldd	r30, Y+2	; 0x02
    5e3e:	fb 81       	ldd	r31, Y+3	; 0x03
    5e40:	8a 81       	ldd	r24, Y+2	; 0x02
    5e42:	9b 81       	ldd	r25, Y+3	; 0x03
    5e44:	91 87       	std	Z+9, r25	; 0x09
    5e46:	80 87       	std	Z+8, r24	; 0x08

        if( xNextExpiryTime <= xTimeNow )
    5e48:	2c 81       	ldd	r18, Y+4	; 0x04
    5e4a:	3d 81       	ldd	r19, Y+5	; 0x05
    5e4c:	8e 81       	ldd	r24, Y+6	; 0x06
    5e4e:	9f 81       	ldd	r25, Y+7	; 0x07
    5e50:	82 17       	cp	r24, r18
    5e52:	93 07       	cpc	r25, r19
    5e54:	e0 f0       	brcs	.+56     	; 0x5e8e <prvInsertTimerInActiveList+0x84>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5e56:	2e 81       	ldd	r18, Y+6	; 0x06
    5e58:	3f 81       	ldd	r19, Y+7	; 0x07
    5e5a:	88 85       	ldd	r24, Y+8	; 0x08
    5e5c:	99 85       	ldd	r25, Y+9	; 0x09
    5e5e:	28 1b       	sub	r18, r24
    5e60:	39 0b       	sbc	r19, r25
    5e62:	ea 81       	ldd	r30, Y+2	; 0x02
    5e64:	fb 81       	ldd	r31, Y+3	; 0x03
    5e66:	84 85       	ldd	r24, Z+12	; 0x0c
    5e68:	95 85       	ldd	r25, Z+13	; 0x0d
    5e6a:	28 17       	cp	r18, r24
    5e6c:	39 07       	cpc	r19, r25
    5e6e:	18 f0       	brcs	.+6      	; 0x5e76 <prvInsertTimerInActiveList+0x6c>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
    5e70:	81 e0       	ldi	r24, 0x01	; 1
    5e72:	89 83       	std	Y+1, r24	; 0x01
    5e74:	28 c0       	rjmp	.+80     	; 0x5ec6 <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    5e76:	80 91 1e 07 	lds	r24, 0x071E
    5e7a:	90 91 1f 07 	lds	r25, 0x071F
    5e7e:	2a 81       	ldd	r18, Y+2	; 0x02
    5e80:	3b 81       	ldd	r19, Y+3	; 0x03
    5e82:	2e 5f       	subi	r18, 0xFE	; 254
    5e84:	3f 4f       	sbci	r19, 0xFF	; 255
    5e86:	b9 01       	movw	r22, r18
    5e88:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <vListInsert>
    5e8c:	1c c0       	rjmp	.+56     	; 0x5ec6 <prvInsertTimerInActiveList+0xbc>
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    5e8e:	2e 81       	ldd	r18, Y+6	; 0x06
    5e90:	3f 81       	ldd	r19, Y+7	; 0x07
    5e92:	88 85       	ldd	r24, Y+8	; 0x08
    5e94:	99 85       	ldd	r25, Y+9	; 0x09
    5e96:	28 17       	cp	r18, r24
    5e98:	39 07       	cpc	r19, r25
    5e9a:	50 f4       	brcc	.+20     	; 0x5eb0 <prvInsertTimerInActiveList+0xa6>
    5e9c:	2c 81       	ldd	r18, Y+4	; 0x04
    5e9e:	3d 81       	ldd	r19, Y+5	; 0x05
    5ea0:	88 85       	ldd	r24, Y+8	; 0x08
    5ea2:	99 85       	ldd	r25, Y+9	; 0x09
    5ea4:	28 17       	cp	r18, r24
    5ea6:	39 07       	cpc	r19, r25
    5ea8:	18 f0       	brcs	.+6      	; 0x5eb0 <prvInsertTimerInActiveList+0xa6>
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
    5eaa:	81 e0       	ldi	r24, 0x01	; 1
    5eac:	89 83       	std	Y+1, r24	; 0x01
    5eae:	0b c0       	rjmp	.+22     	; 0x5ec6 <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    5eb0:	80 91 1c 07 	lds	r24, 0x071C
    5eb4:	90 91 1d 07 	lds	r25, 0x071D
    5eb8:	2a 81       	ldd	r18, Y+2	; 0x02
    5eba:	3b 81       	ldd	r19, Y+3	; 0x03
    5ebc:	2e 5f       	subi	r18, 0xFE	; 254
    5ebe:	3f 4f       	sbci	r19, 0xFF	; 255
    5ec0:	b9 01       	movw	r22, r18
    5ec2:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <vListInsert>
            }
        }

        return xProcessTimerNow;
    5ec6:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5ec8:	29 96       	adiw	r28, 0x09	; 9
    5eca:	0f b6       	in	r0, 0x3f	; 63
    5ecc:	f8 94       	cli
    5ece:	de bf       	out	0x3e, r29	; 62
    5ed0:	0f be       	out	0x3f, r0	; 63
    5ed2:	cd bf       	out	0x3d, r28	; 61
    5ed4:	cf 91       	pop	r28
    5ed6:	df 91       	pop	r29
    5ed8:	08 95       	ret

00005eda <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
    5eda:	df 93       	push	r29
    5edc:	cf 93       	push	r28
    5ede:	cd b7       	in	r28, 0x3d	; 61
    5ee0:	de b7       	in	r29, 0x3e	; 62
    5ee2:	2c 97       	sbiw	r28, 0x0c	; 12
    5ee4:	0f b6       	in	r0, 0x3f	; 63
    5ee6:	f8 94       	cli
    5ee8:	de bf       	out	0x3e, r29	; 62
    5eea:	0f be       	out	0x3f, r0	; 63
    5eec:	cd bf       	out	0x3d, r28	; 61
    5eee:	d8 c0       	rjmp	.+432    	; 0x60a0 <prvProcessReceivedCommands+0x1c6>
                }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    5ef0:	8d 81       	ldd	r24, Y+5	; 0x05
    5ef2:	88 23       	and	r24, r24
    5ef4:	0c f4       	brge	.+2      	; 0x5ef8 <prvProcessReceivedCommands+0x1e>
    5ef6:	d4 c0       	rjmp	.+424    	; 0x60a0 <prvProcessReceivedCommands+0x1c6>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
    5ef8:	88 85       	ldd	r24, Y+8	; 0x08
    5efa:	99 85       	ldd	r25, Y+9	; 0x09
    5efc:	9c 83       	std	Y+4, r25	; 0x04
    5efe:	8b 83       	std	Y+3, r24	; 0x03

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    5f00:	eb 81       	ldd	r30, Y+3	; 0x03
    5f02:	fc 81       	ldd	r31, Y+4	; 0x04
    5f04:	82 85       	ldd	r24, Z+10	; 0x0a
    5f06:	93 85       	ldd	r25, Z+11	; 0x0b
    5f08:	00 97       	sbiw	r24, 0x00	; 0
    5f0a:	29 f0       	breq	.+10     	; 0x5f16 <prvProcessReceivedCommands+0x3c>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    5f0c:	8b 81       	ldd	r24, Y+3	; 0x03
    5f0e:	9c 81       	ldd	r25, Y+4	; 0x04
    5f10:	02 96       	adiw	r24, 0x02	; 2
    5f12:	0e 94 51 0e 	call	0x1ca2	; 0x1ca2 <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    5f16:	ce 01       	movw	r24, r28
    5f18:	0a 96       	adiw	r24, 0x0a	; 10
    5f1a:	0e 94 d7 2e 	call	0x5dae	; 0x5dae <prvSampleTimeNow>
    5f1e:	9a 83       	std	Y+2, r25	; 0x02
    5f20:	89 83       	std	Y+1, r24	; 0x01

                switch( xMessage.xMessageID )
    5f22:	8d 81       	ldd	r24, Y+5	; 0x05
    5f24:	28 2f       	mov	r18, r24
    5f26:	33 27       	eor	r19, r19
    5f28:	27 fd       	sbrc	r18, 7
    5f2a:	30 95       	com	r19
    5f2c:	3c 87       	std	Y+12, r19	; 0x0c
    5f2e:	2b 87       	std	Y+11, r18	; 0x0b
    5f30:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f32:	9c 85       	ldd	r25, Y+12	; 0x0c
    5f34:	85 30       	cpi	r24, 0x05	; 5
    5f36:	91 05       	cpc	r25, r1
    5f38:	09 f4       	brne	.+2      	; 0x5f3c <prvProcessReceivedCommands+0x62>
    5f3a:	9d c0       	rjmp	.+314    	; 0x6076 <prvProcessReceivedCommands+0x19c>
    5f3c:	2b 85       	ldd	r18, Y+11	; 0x0b
    5f3e:	3c 85       	ldd	r19, Y+12	; 0x0c
    5f40:	26 30       	cpi	r18, 0x06	; 6
    5f42:	31 05       	cpc	r19, r1
    5f44:	9c f4       	brge	.+38     	; 0x5f6c <prvProcessReceivedCommands+0x92>
    5f46:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f48:	9c 85       	ldd	r25, Y+12	; 0x0c
    5f4a:	83 30       	cpi	r24, 0x03	; 3
    5f4c:	91 05       	cpc	r25, r1
    5f4e:	09 f4       	brne	.+2      	; 0x5f52 <prvProcessReceivedCommands+0x78>
    5f50:	68 c0       	rjmp	.+208    	; 0x6022 <prvProcessReceivedCommands+0x148>
    5f52:	2b 85       	ldd	r18, Y+11	; 0x0b
    5f54:	3c 85       	ldd	r19, Y+12	; 0x0c
    5f56:	24 30       	cpi	r18, 0x04	; 4
    5f58:	31 05       	cpc	r19, r1
    5f5a:	0c f0       	brlt	.+2      	; 0x5f5e <prvProcessReceivedCommands+0x84>
    5f5c:	6a c0       	rjmp	.+212    	; 0x6032 <prvProcessReceivedCommands+0x158>
    5f5e:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f60:	9c 85       	ldd	r25, Y+12	; 0x0c
    5f62:	81 30       	cpi	r24, 0x01	; 1
    5f64:	91 05       	cpc	r25, r1
    5f66:	0c f4       	brge	.+2      	; 0x5f6a <prvProcessReceivedCommands+0x90>
    5f68:	9b c0       	rjmp	.+310    	; 0x60a0 <prvProcessReceivedCommands+0x1c6>
    5f6a:	12 c0       	rjmp	.+36     	; 0x5f90 <prvProcessReceivedCommands+0xb6>
    5f6c:	2b 85       	ldd	r18, Y+11	; 0x0b
    5f6e:	3c 85       	ldd	r19, Y+12	; 0x0c
    5f70:	28 30       	cpi	r18, 0x08	; 8
    5f72:	31 05       	cpc	r19, r1
    5f74:	09 f4       	brne	.+2      	; 0x5f78 <prvProcessReceivedCommands+0x9e>
    5f76:	55 c0       	rjmp	.+170    	; 0x6022 <prvProcessReceivedCommands+0x148>
    5f78:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f7a:	9c 85       	ldd	r25, Y+12	; 0x0c
    5f7c:	88 30       	cpi	r24, 0x08	; 8
    5f7e:	91 05       	cpc	r25, r1
    5f80:	3c f0       	brlt	.+14     	; 0x5f90 <prvProcessReceivedCommands+0xb6>
    5f82:	2b 85       	ldd	r18, Y+11	; 0x0b
    5f84:	3c 85       	ldd	r19, Y+12	; 0x0c
    5f86:	29 30       	cpi	r18, 0x09	; 9
    5f88:	31 05       	cpc	r19, r1
    5f8a:	09 f4       	brne	.+2      	; 0x5f8e <prvProcessReceivedCommands+0xb4>
    5f8c:	52 c0       	rjmp	.+164    	; 0x6032 <prvProcessReceivedCommands+0x158>
    5f8e:	88 c0       	rjmp	.+272    	; 0x60a0 <prvProcessReceivedCommands+0x1c6>
                    case tmrCOMMAND_START:
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    5f90:	eb 81       	ldd	r30, Y+3	; 0x03
    5f92:	fc 81       	ldd	r31, Y+4	; 0x04
    5f94:	82 89       	ldd	r24, Z+18	; 0x12
    5f96:	81 60       	ori	r24, 0x01	; 1
    5f98:	eb 81       	ldd	r30, Y+3	; 0x03
    5f9a:	fc 81       	ldd	r31, Y+4	; 0x04
    5f9c:	82 8b       	std	Z+18, r24	; 0x12

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    5f9e:	2e 81       	ldd	r18, Y+6	; 0x06
    5fa0:	3f 81       	ldd	r19, Y+7	; 0x07
    5fa2:	eb 81       	ldd	r30, Y+3	; 0x03
    5fa4:	fc 81       	ldd	r31, Y+4	; 0x04
    5fa6:	84 85       	ldd	r24, Z+12	; 0x0c
    5fa8:	95 85       	ldd	r25, Z+13	; 0x0d
    5faa:	a9 01       	movw	r20, r18
    5fac:	48 0f       	add	r20, r24
    5fae:	59 1f       	adc	r21, r25
    5fb0:	ee 81       	ldd	r30, Y+6	; 0x06
    5fb2:	ff 81       	ldd	r31, Y+7	; 0x07
    5fb4:	8b 81       	ldd	r24, Y+3	; 0x03
    5fb6:	9c 81       	ldd	r25, Y+4	; 0x04
    5fb8:	29 81       	ldd	r18, Y+1	; 0x01
    5fba:	3a 81       	ldd	r19, Y+2	; 0x02
    5fbc:	ba 01       	movw	r22, r20
    5fbe:	a9 01       	movw	r20, r18
    5fc0:	9f 01       	movw	r18, r30
    5fc2:	0e 94 05 2f 	call	0x5e0a	; 0x5e0a <prvInsertTimerInActiveList>
    5fc6:	88 23       	and	r24, r24
    5fc8:	09 f4       	brne	.+2      	; 0x5fcc <prvProcessReceivedCommands+0xf2>
    5fca:	6a c0       	rjmp	.+212    	; 0x60a0 <prvProcessReceivedCommands+0x1c6>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    5fcc:	eb 81       	ldd	r30, Y+3	; 0x03
    5fce:	fc 81       	ldd	r31, Y+4	; 0x04
    5fd0:	82 89       	ldd	r24, Z+18	; 0x12
    5fd2:	88 2f       	mov	r24, r24
    5fd4:	90 e0       	ldi	r25, 0x00	; 0
    5fd6:	84 70       	andi	r24, 0x04	; 4
    5fd8:	90 70       	andi	r25, 0x00	; 0
    5fda:	00 97       	sbiw	r24, 0x00	; 0
    5fdc:	91 f0       	breq	.+36     	; 0x6002 <prvProcessReceivedCommands+0x128>
                            {
                                prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow );
    5fde:	2e 81       	ldd	r18, Y+6	; 0x06
    5fe0:	3f 81       	ldd	r19, Y+7	; 0x07
    5fe2:	eb 81       	ldd	r30, Y+3	; 0x03
    5fe4:	fc 81       	ldd	r31, Y+4	; 0x04
    5fe6:	84 85       	ldd	r24, Z+12	; 0x0c
    5fe8:	95 85       	ldd	r25, Z+13	; 0x0d
    5fea:	a9 01       	movw	r20, r18
    5fec:	48 0f       	add	r20, r24
    5fee:	59 1f       	adc	r21, r25
    5ff0:	8b 81       	ldd	r24, Y+3	; 0x03
    5ff2:	9c 81       	ldd	r25, Y+4	; 0x04
    5ff4:	29 81       	ldd	r18, Y+1	; 0x01
    5ff6:	3a 81       	ldd	r19, Y+2	; 0x02
    5ff8:	ba 01       	movw	r22, r20
    5ffa:	a9 01       	movw	r20, r18
    5ffc:	0e 94 af 2d 	call	0x5b5e	; 0x5b5e <prvReloadTimer>
    6000:	07 c0       	rjmp	.+14     	; 0x6010 <prvProcessReceivedCommands+0x136>
                            }
                            else
                            {
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    6002:	eb 81       	ldd	r30, Y+3	; 0x03
    6004:	fc 81       	ldd	r31, Y+4	; 0x04
    6006:	82 89       	ldd	r24, Z+18	; 0x12
    6008:	8e 7f       	andi	r24, 0xFE	; 254
    600a:	eb 81       	ldd	r30, Y+3	; 0x03
    600c:	fc 81       	ldd	r31, Y+4	; 0x04
    600e:	82 8b       	std	Z+18, r24	; 0x12
                            }

                            /* Call the timer callback. */
                            traceTIMER_EXPIRED( pxTimer );
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    6010:	eb 81       	ldd	r30, Y+3	; 0x03
    6012:	fc 81       	ldd	r31, Y+4	; 0x04
    6014:	00 88       	ldd	r0, Z+16	; 0x10
    6016:	f1 89       	ldd	r31, Z+17	; 0x11
    6018:	e0 2d       	mov	r30, r0
    601a:	8b 81       	ldd	r24, Y+3	; 0x03
    601c:	9c 81       	ldd	r25, Y+4	; 0x04
    601e:	09 95       	icall
    6020:	3f c0       	rjmp	.+126    	; 0x60a0 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    6022:	eb 81       	ldd	r30, Y+3	; 0x03
    6024:	fc 81       	ldd	r31, Y+4	; 0x04
    6026:	82 89       	ldd	r24, Z+18	; 0x12
    6028:	8e 7f       	andi	r24, 0xFE	; 254
    602a:	eb 81       	ldd	r30, Y+3	; 0x03
    602c:	fc 81       	ldd	r31, Y+4	; 0x04
    602e:	82 8b       	std	Z+18, r24	; 0x12
    6030:	37 c0       	rjmp	.+110    	; 0x60a0 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    6032:	eb 81       	ldd	r30, Y+3	; 0x03
    6034:	fc 81       	ldd	r31, Y+4	; 0x04
    6036:	82 89       	ldd	r24, Z+18	; 0x12
    6038:	81 60       	ori	r24, 0x01	; 1
    603a:	eb 81       	ldd	r30, Y+3	; 0x03
    603c:	fc 81       	ldd	r31, Y+4	; 0x04
    603e:	82 8b       	std	Z+18, r24	; 0x12
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    6040:	8e 81       	ldd	r24, Y+6	; 0x06
    6042:	9f 81       	ldd	r25, Y+7	; 0x07
    6044:	eb 81       	ldd	r30, Y+3	; 0x03
    6046:	fc 81       	ldd	r31, Y+4	; 0x04
    6048:	95 87       	std	Z+13, r25	; 0x0d
    604a:	84 87       	std	Z+12, r24	; 0x0c
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    604c:	eb 81       	ldd	r30, Y+3	; 0x03
    604e:	fc 81       	ldd	r31, Y+4	; 0x04
    6050:	24 85       	ldd	r18, Z+12	; 0x0c
    6052:	35 85       	ldd	r19, Z+13	; 0x0d
    6054:	89 81       	ldd	r24, Y+1	; 0x01
    6056:	9a 81       	ldd	r25, Y+2	; 0x02
    6058:	a9 01       	movw	r20, r18
    605a:	48 0f       	add	r20, r24
    605c:	59 1f       	adc	r21, r25
    605e:	8b 81       	ldd	r24, Y+3	; 0x03
    6060:	9c 81       	ldd	r25, Y+4	; 0x04
    6062:	29 81       	ldd	r18, Y+1	; 0x01
    6064:	3a 81       	ldd	r19, Y+2	; 0x02
    6066:	e9 81       	ldd	r30, Y+1	; 0x01
    6068:	fa 81       	ldd	r31, Y+2	; 0x02
    606a:	ba 01       	movw	r22, r20
    606c:	a9 01       	movw	r20, r18
    606e:	9f 01       	movw	r18, r30
    6070:	0e 94 05 2f 	call	0x5e0a	; 0x5e0a <prvInsertTimerInActiveList>
    6074:	15 c0       	rjmp	.+42     	; 0x60a0 <prvProcessReceivedCommands+0x1c6>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                            {
                                /* The timer has already been removed from the active list,
                                 * just free up the memory if the memory was dynamically
                                 * allocated. */
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    6076:	eb 81       	ldd	r30, Y+3	; 0x03
    6078:	fc 81       	ldd	r31, Y+4	; 0x04
    607a:	82 89       	ldd	r24, Z+18	; 0x12
    607c:	88 2f       	mov	r24, r24
    607e:	90 e0       	ldi	r25, 0x00	; 0
    6080:	82 70       	andi	r24, 0x02	; 2
    6082:	90 70       	andi	r25, 0x00	; 0
    6084:	00 97       	sbiw	r24, 0x00	; 0
    6086:	29 f4       	brne	.+10     	; 0x6092 <prvProcessReceivedCommands+0x1b8>
                                {
                                    vPortFree( pxTimer );
    6088:	8b 81       	ldd	r24, Y+3	; 0x03
    608a:	9c 81       	ldd	r25, Y+4	; 0x04
    608c:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
    6090:	07 c0       	rjmp	.+14     	; 0x60a0 <prvProcessReceivedCommands+0x1c6>
                                }
                                else
                                {
                                    pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    6092:	eb 81       	ldd	r30, Y+3	; 0x03
    6094:	fc 81       	ldd	r31, Y+4	; 0x04
    6096:	82 89       	ldd	r24, Z+18	; 0x12
    6098:	8e 7f       	andi	r24, 0xFE	; 254
    609a:	eb 81       	ldd	r30, Y+3	; 0x03
    609c:	fc 81       	ldd	r31, Y+4	; 0x04
    609e:	82 8b       	std	Z+18, r24	; 0x12
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    60a0:	80 91 04 07 	lds	r24, 0x0704
    60a4:	90 91 05 07 	lds	r25, 0x0705
    60a8:	9e 01       	movw	r18, r28
    60aa:	2b 5f       	subi	r18, 0xFB	; 251
    60ac:	3f 4f       	sbci	r19, 0xFF	; 255
    60ae:	b9 01       	movw	r22, r18
    60b0:	40 e0       	ldi	r20, 0x00	; 0
    60b2:	50 e0       	ldi	r21, 0x00	; 0
    60b4:	0e 94 50 11 	call	0x22a0	; 0x22a0 <xQueueReceive>
    60b8:	88 23       	and	r24, r24
    60ba:	09 f0       	breq	.+2      	; 0x60be <prvProcessReceivedCommands+0x1e4>
    60bc:	19 cf       	rjmp	.-462    	; 0x5ef0 <prvProcessReceivedCommands+0x16>
                        /* Don't expect to get here. */
                        break;
                }
            }
        }
    }
    60be:	2c 96       	adiw	r28, 0x0c	; 12
    60c0:	0f b6       	in	r0, 0x3f	; 63
    60c2:	f8 94       	cli
    60c4:	de bf       	out	0x3e, r29	; 62
    60c6:	0f be       	out	0x3f, r0	; 63
    60c8:	cd bf       	out	0x3d, r28	; 61
    60ca:	cf 91       	pop	r28
    60cc:	df 91       	pop	r29
    60ce:	08 95       	ret

000060d0 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
    60d0:	df 93       	push	r29
    60d2:	cf 93       	push	r28
    60d4:	00 d0       	rcall	.+0      	; 0x60d6 <prvSwitchTimerLists+0x6>
    60d6:	00 d0       	rcall	.+0      	; 0x60d8 <prvSwitchTimerLists+0x8>
    60d8:	cd b7       	in	r28, 0x3d	; 61
    60da:	de b7       	in	r29, 0x3e	; 62
    60dc:	11 c0       	rjmp	.+34     	; 0x6100 <prvSwitchTimerLists+0x30>
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    60de:	e0 91 1c 07 	lds	r30, 0x071C
    60e2:	f0 91 1d 07 	lds	r31, 0x071D
    60e6:	05 80       	ldd	r0, Z+5	; 0x05
    60e8:	f6 81       	ldd	r31, Z+6	; 0x06
    60ea:	e0 2d       	mov	r30, r0
    60ec:	80 81       	ld	r24, Z
    60ee:	91 81       	ldd	r25, Z+1	; 0x01
    60f0:	9c 83       	std	Y+4, r25	; 0x04
    60f2:	8b 83       	std	Y+3, r24	; 0x03

            /* Process the expired timer.  For auto-reload timers, be careful to
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
    60f4:	8b 81       	ldd	r24, Y+3	; 0x03
    60f6:	9c 81       	ldd	r25, Y+4	; 0x04
    60f8:	6f ef       	ldi	r22, 0xFF	; 255
    60fa:	7f ef       	ldi	r23, 0xFF	; 255
    60fc:	0e 94 ee 2d 	call	0x5bdc	; 0x5bdc <prvProcessExpiredTimer>

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    6100:	e0 91 1c 07 	lds	r30, 0x071C
    6104:	f0 91 1d 07 	lds	r31, 0x071D
    6108:	80 81       	ld	r24, Z
    610a:	88 23       	and	r24, r24
    610c:	41 f7       	brne	.-48     	; 0x60de <prvSwitchTimerLists+0xe>
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
        }

        pxTemp = pxCurrentTimerList;
    610e:	80 91 1c 07 	lds	r24, 0x071C
    6112:	90 91 1d 07 	lds	r25, 0x071D
    6116:	9a 83       	std	Y+2, r25	; 0x02
    6118:	89 83       	std	Y+1, r24	; 0x01
        pxCurrentTimerList = pxOverflowTimerList;
    611a:	80 91 1e 07 	lds	r24, 0x071E
    611e:	90 91 1f 07 	lds	r25, 0x071F
    6122:	90 93 1d 07 	sts	0x071D, r25
    6126:	80 93 1c 07 	sts	0x071C, r24
        pxOverflowTimerList = pxTemp;
    612a:	89 81       	ldd	r24, Y+1	; 0x01
    612c:	9a 81       	ldd	r25, Y+2	; 0x02
    612e:	90 93 1f 07 	sts	0x071F, r25
    6132:	80 93 1e 07 	sts	0x071E, r24
    }
    6136:	0f 90       	pop	r0
    6138:	0f 90       	pop	r0
    613a:	0f 90       	pop	r0
    613c:	0f 90       	pop	r0
    613e:	cf 91       	pop	r28
    6140:	df 91       	pop	r29
    6142:	08 95       	ret

00006144 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
    6144:	df 93       	push	r29
    6146:	cf 93       	push	r28
    6148:	cd b7       	in	r28, 0x3d	; 61
    614a:	de b7       	in	r29, 0x3e	; 62
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
    614c:	0f b6       	in	r0, 0x3f	; 63
    614e:	f8 94       	cli
    6150:	0f 92       	push	r0
        {
            if( xTimerQueue == NULL )
    6152:	80 91 04 07 	lds	r24, 0x0704
    6156:	90 91 05 07 	lds	r25, 0x0705
    615a:	00 97       	sbiw	r24, 0x00	; 0
    615c:	e9 f4       	brne	.+58     	; 0x6198 <prvCheckForValidListAndQueue+0x54>
            {
                vListInitialise( &xActiveTimerList1 );
    615e:	8a e0       	ldi	r24, 0x0A	; 10
    6160:	97 e0       	ldi	r25, 0x07	; 7
    6162:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
    6166:	83 e1       	ldi	r24, 0x13	; 19
    6168:	97 e0       	ldi	r25, 0x07	; 7
    616a:	0e 94 67 0d 	call	0x1ace	; 0x1ace <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
    616e:	8a e0       	ldi	r24, 0x0A	; 10
    6170:	97 e0       	ldi	r25, 0x07	; 7
    6172:	90 93 1d 07 	sts	0x071D, r25
    6176:	80 93 1c 07 	sts	0x071C, r24
                pxOverflowTimerList = &xActiveTimerList2;
    617a:	83 e1       	ldi	r24, 0x13	; 19
    617c:	97 e0       	ldi	r25, 0x07	; 7
    617e:	90 93 1f 07 	sts	0x071F, r25
    6182:	80 93 1e 07 	sts	0x071E, r24

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    6186:	8a e0       	ldi	r24, 0x0A	; 10
    6188:	65 e0       	ldi	r22, 0x05	; 5
    618a:	40 e0       	ldi	r20, 0x00	; 0
    618c:	0e 94 48 0f 	call	0x1e90	; 0x1e90 <xQueueGenericCreate>
    6190:	90 93 05 07 	sts	0x0705, r25
    6194:	80 93 04 07 	sts	0x0704, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    6198:	0f 90       	pop	r0
    619a:	0f be       	out	0x3f, r0	; 63
    }
    619c:	cf 91       	pop	r28
    619e:	df 91       	pop	r29
    61a0:	08 95       	ret

000061a2 <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
    {
    61a2:	df 93       	push	r29
    61a4:	cf 93       	push	r28
    61a6:	00 d0       	rcall	.+0      	; 0x61a8 <xTimerIsTimerActive+0x6>
    61a8:	00 d0       	rcall	.+0      	; 0x61aa <xTimerIsTimerActive+0x8>
    61aa:	0f 92       	push	r0
    61ac:	cd b7       	in	r28, 0x3d	; 61
    61ae:	de b7       	in	r29, 0x3e	; 62
    61b0:	9d 83       	std	Y+5, r25	; 0x05
    61b2:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;
        Timer_t * pxTimer = xTimer;
    61b4:	8c 81       	ldd	r24, Y+4	; 0x04
    61b6:	9d 81       	ldd	r25, Y+5	; 0x05
    61b8:	9a 83       	std	Y+2, r25	; 0x02
    61ba:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        /* Is the timer in the list of active timers? */
        taskENTER_CRITICAL();
    61bc:	0f b6       	in	r0, 0x3f	; 63
    61be:	f8 94       	cli
    61c0:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
    61c2:	e9 81       	ldd	r30, Y+1	; 0x01
    61c4:	fa 81       	ldd	r31, Y+2	; 0x02
    61c6:	82 89       	ldd	r24, Z+18	; 0x12
    61c8:	88 2f       	mov	r24, r24
    61ca:	90 e0       	ldi	r25, 0x00	; 0
    61cc:	81 70       	andi	r24, 0x01	; 1
    61ce:	90 70       	andi	r25, 0x00	; 0
    61d0:	00 97       	sbiw	r24, 0x00	; 0
    61d2:	11 f4       	brne	.+4      	; 0x61d8 <xTimerIsTimerActive+0x36>
            {
                xReturn = pdFALSE;
    61d4:	1b 82       	std	Y+3, r1	; 0x03
    61d6:	02 c0       	rjmp	.+4      	; 0x61dc <xTimerIsTimerActive+0x3a>
            }
            else
            {
                xReturn = pdTRUE;
    61d8:	81 e0       	ldi	r24, 0x01	; 1
    61da:	8b 83       	std	Y+3, r24	; 0x03
            }
        }
        taskEXIT_CRITICAL();
    61dc:	0f 90       	pop	r0
    61de:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    61e0:	8b 81       	ldd	r24, Y+3	; 0x03
    } /*lint !e818 Can't be pointer to const due to the typedef. */
    61e2:	0f 90       	pop	r0
    61e4:	0f 90       	pop	r0
    61e6:	0f 90       	pop	r0
    61e8:	0f 90       	pop	r0
    61ea:	0f 90       	pop	r0
    61ec:	cf 91       	pop	r28
    61ee:	df 91       	pop	r29
    61f0:	08 95       	ret

000061f2 <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

    void * pvTimerGetTimerID( const TimerHandle_t xTimer )
    {
    61f2:	df 93       	push	r29
    61f4:	cf 93       	push	r28
    61f6:	00 d0       	rcall	.+0      	; 0x61f8 <pvTimerGetTimerID+0x6>
    61f8:	00 d0       	rcall	.+0      	; 0x61fa <pvTimerGetTimerID+0x8>
    61fa:	00 d0       	rcall	.+0      	; 0x61fc <pvTimerGetTimerID+0xa>
    61fc:	cd b7       	in	r28, 0x3d	; 61
    61fe:	de b7       	in	r29, 0x3e	; 62
    6200:	9e 83       	std	Y+6, r25	; 0x06
    6202:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * const pxTimer = xTimer;
    6204:	8d 81       	ldd	r24, Y+5	; 0x05
    6206:	9e 81       	ldd	r25, Y+6	; 0x06
    6208:	9c 83       	std	Y+4, r25	; 0x04
    620a:	8b 83       	std	Y+3, r24	; 0x03
        void * pvReturn;

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    620c:	0f b6       	in	r0, 0x3f	; 63
    620e:	f8 94       	cli
    6210:	0f 92       	push	r0
        {
            pvReturn = pxTimer->pvTimerID;
    6212:	eb 81       	ldd	r30, Y+3	; 0x03
    6214:	fc 81       	ldd	r31, Y+4	; 0x04
    6216:	86 85       	ldd	r24, Z+14	; 0x0e
    6218:	97 85       	ldd	r25, Z+15	; 0x0f
    621a:	9a 83       	std	Y+2, r25	; 0x02
    621c:	89 83       	std	Y+1, r24	; 0x01
        }
        taskEXIT_CRITICAL();
    621e:	0f 90       	pop	r0
    6220:	0f be       	out	0x3f, r0	; 63

        return pvReturn;
    6222:	89 81       	ldd	r24, Y+1	; 0x01
    6224:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    6226:	26 96       	adiw	r28, 0x06	; 6
    6228:	0f b6       	in	r0, 0x3f	; 63
    622a:	f8 94       	cli
    622c:	de bf       	out	0x3e, r29	; 62
    622e:	0f be       	out	0x3f, r0	; 63
    6230:	cd bf       	out	0x3d, r28	; 61
    6232:	cf 91       	pop	r28
    6234:	df 91       	pop	r29
    6236:	08 95       	ret

00006238 <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

    void vTimerSetTimerID( TimerHandle_t xTimer,
                           void * pvNewID )
    {
    6238:	df 93       	push	r29
    623a:	cf 93       	push	r28
    623c:	00 d0       	rcall	.+0      	; 0x623e <vTimerSetTimerID+0x6>
    623e:	00 d0       	rcall	.+0      	; 0x6240 <vTimerSetTimerID+0x8>
    6240:	00 d0       	rcall	.+0      	; 0x6242 <vTimerSetTimerID+0xa>
    6242:	cd b7       	in	r28, 0x3d	; 61
    6244:	de b7       	in	r29, 0x3e	; 62
    6246:	9c 83       	std	Y+4, r25	; 0x04
    6248:	8b 83       	std	Y+3, r24	; 0x03
    624a:	7e 83       	std	Y+6, r23	; 0x06
    624c:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = xTimer;
    624e:	8b 81       	ldd	r24, Y+3	; 0x03
    6250:	9c 81       	ldd	r25, Y+4	; 0x04
    6252:	9a 83       	std	Y+2, r25	; 0x02
    6254:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    6256:	0f b6       	in	r0, 0x3f	; 63
    6258:	f8 94       	cli
    625a:	0f 92       	push	r0
        {
            pxTimer->pvTimerID = pvNewID;
    625c:	e9 81       	ldd	r30, Y+1	; 0x01
    625e:	fa 81       	ldd	r31, Y+2	; 0x02
    6260:	8d 81       	ldd	r24, Y+5	; 0x05
    6262:	9e 81       	ldd	r25, Y+6	; 0x06
    6264:	97 87       	std	Z+15, r25	; 0x0f
    6266:	86 87       	std	Z+14, r24	; 0x0e
        }
        taskEXIT_CRITICAL();
    6268:	0f 90       	pop	r0
    626a:	0f be       	out	0x3f, r0	; 63
    }
    626c:	26 96       	adiw	r28, 0x06	; 6
    626e:	0f b6       	in	r0, 0x3f	; 63
    6270:	f8 94       	cli
    6272:	de bf       	out	0x3e, r29	; 62
    6274:	0f be       	out	0x3f, r0	; 63
    6276:	cd bf       	out	0x3d, r28	; 61
    6278:	cf 91       	pop	r28
    627a:	df 91       	pop	r29
    627c:	08 95       	ret

0000627e <main>:
void toggle_led_mode(void);

TaskHandle_t task2ptr;

int main(void)
{
    627e:	ef 92       	push	r14
    6280:	ff 92       	push	r15
    6282:	0f 93       	push	r16
    6284:	1f 93       	push	r17
    6286:	df 93       	push	r29
    6288:	cf 93       	push	r28
    628a:	cd b7       	in	r28, 0x3d	; 61
    628c:	de b7       	in	r29, 0x3e	; 62


	PWM_INIT();
    628e:	0e 94 76 06 	call	0xcec	; 0xcec <PWM_INIT>



	xButtonTimer = xTimerCreate
    6292:	ee ea       	ldi	r30, 0xAE	; 174
    6294:	f1 e3       	ldi	r31, 0x31	; 49
    6296:	8d e6       	ldi	r24, 0x6D	; 109
    6298:	90 e0       	ldi	r25, 0x00	; 0
    629a:	65 e0       	ldi	r22, 0x05	; 5
    629c:	70 e0       	ldi	r23, 0x00	; 0
    629e:	41 e0       	ldi	r20, 0x01	; 1
    62a0:	20 e0       	ldi	r18, 0x00	; 0
    62a2:	30 e0       	ldi	r19, 0x00	; 0
    62a4:	8f 01       	movw	r16, r30
    62a6:	0e 94 0c 2c 	call	0x5818	; 0x5818 <xTimerCreate>
    62aa:	90 93 21 07 	sts	0x0721, r25
    62ae:	80 93 20 07 	sts	0x0720, r24
	                     ( void * ) 0,
	                     /* Each timer calls the same callback when
	                     it expires. */
						 get_readings
	                   );
	xLedBlinkingTimer = xTimerCreate
    62b2:	eb e9       	ldi	r30, 0x9B	; 155
    62b4:	f1 e3       	ldi	r31, 0x31	; 49
    62b6:	8a e7       	ldi	r24, 0x7A	; 122
    62b8:	90 e0       	ldi	r25, 0x00	; 0
    62ba:	64 ef       	ldi	r22, 0xF4	; 244
    62bc:	71 e0       	ldi	r23, 0x01	; 1
    62be:	41 e0       	ldi	r20, 0x01	; 1
    62c0:	20 e0       	ldi	r18, 0x00	; 0
    62c2:	30 e0       	ldi	r19, 0x00	; 0
    62c4:	8f 01       	movw	r16, r30
    62c6:	0e 94 0c 2c 	call	0x5818	; 0x5818 <xTimerCreate>
    62ca:	90 93 23 07 	sts	0x0723, r25
    62ce:	80 93 22 07 	sts	0x0722, r24
		                     ( void * ) 0,
		                     /* Each timer calls the same callback when
		                     it expires. */
							 toggle_led_mode
		                   );
	xTaskCreate(vState_machine,"first",configMINIMAL_STACK_SIZE,NULL,1,&task1ptr);
    62d2:	85 e4       	ldi	r24, 0x45	; 69
    62d4:	92 e3       	ldi	r25, 0x32	; 50
    62d6:	24 e8       	ldi	r18, 0x84	; 132
    62d8:	30 e0       	ldi	r19, 0x00	; 0
    62da:	ec e2       	ldi	r30, 0x2C	; 44
    62dc:	f7 e0       	ldi	r31, 0x07	; 7
    62de:	b9 01       	movw	r22, r18
    62e0:	45 e5       	ldi	r20, 0x55	; 85
    62e2:	50 e0       	ldi	r21, 0x00	; 0
    62e4:	20 e0       	ldi	r18, 0x00	; 0
    62e6:	30 e0       	ldi	r19, 0x00	; 0
    62e8:	01 e0       	ldi	r16, 0x01	; 1
    62ea:	7f 01       	movw	r14, r30
    62ec:	0e 94 f3 17 	call	0x2fe6	; 0x2fe6 <xTaskCreate>
	xTimerStart(xButtonTimer, 10 );
    62f0:	00 91 20 07 	lds	r16, 0x0720
    62f4:	10 91 21 07 	lds	r17, 0x0721
    62f8:	0e 94 a0 1c 	call	0x3940	; 0x3940 <xTaskGetTickCount>
    62fc:	9c 01       	movw	r18, r24
    62fe:	c8 01       	movw	r24, r16
    6300:	61 e0       	ldi	r22, 0x01	; 1
    6302:	a9 01       	movw	r20, r18
    6304:	20 e0       	ldi	r18, 0x00	; 0
    6306:	30 e0       	ldi	r19, 0x00	; 0
    6308:	0a e0       	ldi	r16, 0x0A	; 10
    630a:	10 e0       	ldi	r17, 0x00	; 0
    630c:	0e 94 9e 2c 	call	0x593c	; 0x593c <xTimerGenericCommand>
	xTimerStart(xLedBlinkingTimer, 10 );
    6310:	00 91 22 07 	lds	r16, 0x0722
    6314:	10 91 23 07 	lds	r17, 0x0723
    6318:	0e 94 a0 1c 	call	0x3940	; 0x3940 <xTaskGetTickCount>
    631c:	9c 01       	movw	r18, r24
    631e:	c8 01       	movw	r24, r16
    6320:	61 e0       	ldi	r22, 0x01	; 1
    6322:	a9 01       	movw	r20, r18
    6324:	20 e0       	ldi	r18, 0x00	; 0
    6326:	30 e0       	ldi	r19, 0x00	; 0
    6328:	0a e0       	ldi	r16, 0x0A	; 10
    632a:	10 e0       	ldi	r17, 0x00	; 0
    632c:	0e 94 9e 2c 	call	0x593c	; 0x593c <xTimerGenericCommand>
	vTaskStartScheduler();
    6330:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <vTaskStartScheduler>
    6334:	ff cf       	rjmp	.-2      	; 0x6334 <main+0xb6>

00006336 <toggle_led_mode>:


	}
}

void toggle_led_mode(void){
    6336:	df 93       	push	r29
    6338:	cf 93       	push	r28
    633a:	0f 92       	push	r0
    633c:	cd b7       	in	r28, 0x3d	; 61
    633e:	de b7       	in	r29, 0x3e	; 62
		led_mode = !led_mode;
    6340:	80 91 24 07 	lds	r24, 0x0724
    6344:	19 82       	std	Y+1, r1	; 0x01
    6346:	88 23       	and	r24, r24
    6348:	11 f4       	brne	.+4      	; 0x634e <toggle_led_mode+0x18>
    634a:	81 e0       	ldi	r24, 0x01	; 1
    634c:	89 83       	std	Y+1, r24	; 0x01
    634e:	89 81       	ldd	r24, Y+1	; 0x01
    6350:	80 93 24 07 	sts	0x0724, r24
}
    6354:	0f 90       	pop	r0
    6356:	cf 91       	pop	r28
    6358:	df 91       	pop	r29
    635a:	08 95       	ret

0000635c <get_readings>:
void get_readings(void)
{
    635c:	df 93       	push	r29
    635e:	cf 93       	push	r28
    6360:	00 d0       	rcall	.+0      	; 0x6362 <get_readings+0x6>
    6362:	0f 92       	push	r0
    6364:	cd b7       	in	r28, 0x3d	; 61
    6366:	de b7       	in	r29, 0x3e	; 62

		ignition_button = READ_IGNITON();
    6368:	0e 94 cf 06 	call	0xd9e	; 0xd9e <READ_IGNITON>
    636c:	80 93 27 07 	sts	0x0727, r24

		if(!ignition_button){
    6370:	80 91 27 07 	lds	r24, 0x0727
    6374:	88 23       	and	r24, r24
    6376:	09 f0       	breq	.+2      	; 0x637a <get_readings+0x1e>
    6378:	7e c0       	rjmp	.+252    	; 0x6476 <get_readings+0x11a>
			uint8_t hazard_data = READ_HAZARD_Button();
    637a:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <READ_HAZARD_Button>
    637e:	8b 83       	std	Y+3, r24	; 0x03
			uint8_t right_data = READ_RIGHT_Button();
    6380:	0e 94 f7 06 	call	0xdee	; 0xdee <READ_RIGHT_Button>
    6384:	8a 83       	std	Y+2, r24	; 0x02
			uint8_t left_data = READ_LEFT_Button();
    6386:	0e 94 0b 07 	call	0xe16	; 0xe16 <READ_LEFT_Button>
    638a:	89 83       	std	Y+1, r24	; 0x01
			if(hazard_data){
    638c:	8b 81       	ldd	r24, Y+3	; 0x03
    638e:	88 23       	and	r24, r24
    6390:	41 f0       	breq	.+16     	; 0x63a2 <get_readings+0x46>
					Hazzred_button = 1;
    6392:	81 e0       	ldi	r24, 0x01	; 1
    6394:	80 93 2e 07 	sts	0x072E, r24
					L_button = 0;
    6398:	10 92 2b 07 	sts	0x072B, r1
					R_button = 0;
    639c:	10 92 28 07 	sts	0x0728, r1
    63a0:	6e c0       	rjmp	.+220    	; 0x647e <get_readings+0x122>
			}
			else if(right_data){
    63a2:	8a 81       	ldd	r24, Y+2	; 0x02
    63a4:	88 23       	and	r24, r24
    63a6:	39 f1       	breq	.+78     	; 0x63f6 <get_readings+0x9a>
				right_button_pressed_counter++;
    63a8:	80 91 31 07 	lds	r24, 0x0731
    63ac:	90 91 32 07 	lds	r25, 0x0732
    63b0:	01 96       	adiw	r24, 0x01	; 1
    63b2:	90 93 32 07 	sts	0x0732, r25
    63b6:	80 93 31 07 	sts	0x0731, r24
				hazzred_button_pressed_counter=0;
    63ba:	10 92 26 07 	sts	0x0726, r1
    63be:	10 92 25 07 	sts	0x0725, r1
				left_button_pressed_counter=0;
    63c2:	10 92 30 07 	sts	0x0730, r1
    63c6:	10 92 2f 07 	sts	0x072F, r1
				if(!(right_button_pressed_counter%10)){
    63ca:	80 91 31 07 	lds	r24, 0x0731
    63ce:	90 91 32 07 	lds	r25, 0x0732
    63d2:	2a e0       	ldi	r18, 0x0A	; 10
    63d4:	30 e0       	ldi	r19, 0x00	; 0
    63d6:	b9 01       	movw	r22, r18
    63d8:	0e 94 88 32 	call	0x6510	; 0x6510 <__divmodhi4>
    63dc:	00 97       	sbiw	r24, 0x00	; 0
    63de:	09 f0       	breq	.+2      	; 0x63e2 <get_readings+0x86>
    63e0:	4e c0       	rjmp	.+156    	; 0x647e <get_readings+0x122>
					R_button = 1;
    63e2:	81 e0       	ldi	r24, 0x01	; 1
    63e4:	80 93 28 07 	sts	0x0728, r24
					Hazzred_button = 0;
    63e8:	10 92 2e 07 	sts	0x072E, r1
					L_button = 0;
    63ec:	10 92 2b 07 	sts	0x072B, r1
					Stop_PWM2();
    63f0:	0e 94 ba 06 	call	0xd74	; 0xd74 <Stop_PWM2>
    63f4:	44 c0       	rjmp	.+136    	; 0x647e <get_readings+0x122>
				}
			}
			else if(left_data){
    63f6:	89 81       	ldd	r24, Y+1	; 0x01
    63f8:	88 23       	and	r24, r24
    63fa:	31 f1       	breq	.+76     	; 0x6448 <get_readings+0xec>
				left_button_pressed_counter++;
    63fc:	80 91 2f 07 	lds	r24, 0x072F
    6400:	90 91 30 07 	lds	r25, 0x0730
    6404:	01 96       	adiw	r24, 0x01	; 1
    6406:	90 93 30 07 	sts	0x0730, r25
    640a:	80 93 2f 07 	sts	0x072F, r24
				hazzred_button_pressed_counter=0;
    640e:	10 92 26 07 	sts	0x0726, r1
    6412:	10 92 25 07 	sts	0x0725, r1
				right_button_pressed_counter=0;
    6416:	10 92 32 07 	sts	0x0732, r1
    641a:	10 92 31 07 	sts	0x0731, r1
				if(!(left_button_pressed_counter%10)){
    641e:	80 91 2f 07 	lds	r24, 0x072F
    6422:	90 91 30 07 	lds	r25, 0x0730
    6426:	2a e0       	ldi	r18, 0x0A	; 10
    6428:	30 e0       	ldi	r19, 0x00	; 0
    642a:	b9 01       	movw	r22, r18
    642c:	0e 94 88 32 	call	0x6510	; 0x6510 <__divmodhi4>
    6430:	00 97       	sbiw	r24, 0x00	; 0
    6432:	29 f5       	brne	.+74     	; 0x647e <get_readings+0x122>
					L_button = 1;
    6434:	81 e0       	ldi	r24, 0x01	; 1
    6436:	80 93 2b 07 	sts	0x072B, r24
					R_button = 0;
    643a:	10 92 28 07 	sts	0x0728, r1
					Hazzred_button = 0;
    643e:	10 92 2e 07 	sts	0x072E, r1
					Stop_PWM1();
    6442:	0e 94 a5 06 	call	0xd4a	; 0xd4a <Stop_PWM1>
    6446:	1b c0       	rjmp	.+54     	; 0x647e <get_readings+0x122>
				}
			}
			else{
				/*neutral state*/
				Stop_PWM1();
    6448:	0e 94 a5 06 	call	0xd4a	; 0xd4a <Stop_PWM1>
				Stop_PWM2();
    644c:	0e 94 ba 06 	call	0xd74	; 0xd74 <Stop_PWM2>
				hazzred_button_pressed_counter=0;
    6450:	10 92 26 07 	sts	0x0726, r1
    6454:	10 92 25 07 	sts	0x0725, r1
				right_button_pressed_counter=0;
    6458:	10 92 32 07 	sts	0x0732, r1
    645c:	10 92 31 07 	sts	0x0731, r1
				left_button_pressed_counter=0;
    6460:	10 92 30 07 	sts	0x0730, r1
    6464:	10 92 2f 07 	sts	0x072F, r1
				L_button = 0;
    6468:	10 92 2b 07 	sts	0x072B, r1
				R_button = 0;
    646c:	10 92 28 07 	sts	0x0728, r1
				Hazzred_button = 0;
    6470:	10 92 2e 07 	sts	0x072E, r1
    6474:	04 c0       	rjmp	.+8      	; 0x647e <get_readings+0x122>

			}
		}else{
			Stop_PWM1();
    6476:	0e 94 a5 06 	call	0xd4a	; 0xd4a <Stop_PWM1>
			Stop_PWM2();
    647a:	0e 94 ba 06 	call	0xd74	; 0xd74 <Stop_PWM2>
		}

}
    647e:	0f 90       	pop	r0
    6480:	0f 90       	pop	r0
    6482:	0f 90       	pop	r0
    6484:	cf 91       	pop	r28
    6486:	df 91       	pop	r29
    6488:	08 95       	ret

0000648a <vState_machine>:


void vState_machine(void)
{
    648a:	df 93       	push	r29
    648c:	cf 93       	push	r28
    648e:	cd b7       	in	r28, 0x3d	; 61
    6490:	de b7       	in	r29, 0x3e	; 62
	while(1)
	{

		if(!ignition_button){
    6492:	80 91 27 07 	lds	r24, 0x0727
    6496:	88 23       	and	r24, r24
    6498:	e1 f7       	brne	.-8      	; 0x6492 <vState_machine+0x8>


			if(Hazzred_button){
    649a:	80 91 2e 07 	lds	r24, 0x072E
    649e:	88 23       	and	r24, r24
    64a0:	69 f0       	breq	.+26     	; 0x64bc <vState_machine+0x32>

				vBlink_Right(led_mode);
    64a2:	80 91 24 07 	lds	r24, 0x0724
    64a6:	88 2f       	mov	r24, r24
    64a8:	90 e0       	ldi	r25, 0x00	; 0
    64aa:	0e 94 1f 07 	call	0xe3e	; 0xe3e <vBlink_Right>
				Blink_LEFT(led_mode);
    64ae:	80 91 24 07 	lds	r24, 0x0724
    64b2:	88 2f       	mov	r24, r24
    64b4:	90 e0       	ldi	r25, 0x00	; 0
    64b6:	0e 94 31 07 	call	0xe62	; 0xe62 <Blink_LEFT>
    64ba:	eb cf       	rjmp	.-42     	; 0x6492 <vState_machine+0x8>
			}
			else if(R_button ){
    64bc:	80 91 28 07 	lds	r24, 0x0728
    64c0:	88 23       	and	r24, r24
    64c2:	39 f0       	breq	.+14     	; 0x64d2 <vState_machine+0x48>
				vBlink_Right(led_mode);
    64c4:	80 91 24 07 	lds	r24, 0x0724
    64c8:	88 2f       	mov	r24, r24
    64ca:	90 e0       	ldi	r25, 0x00	; 0
    64cc:	0e 94 1f 07 	call	0xe3e	; 0xe3e <vBlink_Right>
    64d0:	e0 cf       	rjmp	.-64     	; 0x6492 <vState_machine+0x8>
			}
			else if(L_button ){
    64d2:	80 91 2b 07 	lds	r24, 0x072B
    64d6:	88 23       	and	r24, r24
    64d8:	e1 f2       	breq	.-72     	; 0x6492 <vState_machine+0x8>

				Blink_LEFT(led_mode);
    64da:	80 91 24 07 	lds	r24, 0x0724
    64de:	88 2f       	mov	r24, r24
    64e0:	90 e0       	ldi	r25, 0x00	; 0
    64e2:	0e 94 31 07 	call	0xe62	; 0xe62 <Blink_LEFT>
    64e6:	d5 cf       	rjmp	.-86     	; 0x6492 <vState_machine+0x8>

000064e8 <__udivmodhi4>:
    64e8:	aa 1b       	sub	r26, r26
    64ea:	bb 1b       	sub	r27, r27
    64ec:	51 e1       	ldi	r21, 0x11	; 17
    64ee:	07 c0       	rjmp	.+14     	; 0x64fe <__udivmodhi4_ep>

000064f0 <__udivmodhi4_loop>:
    64f0:	aa 1f       	adc	r26, r26
    64f2:	bb 1f       	adc	r27, r27
    64f4:	a6 17       	cp	r26, r22
    64f6:	b7 07       	cpc	r27, r23
    64f8:	10 f0       	brcs	.+4      	; 0x64fe <__udivmodhi4_ep>
    64fa:	a6 1b       	sub	r26, r22
    64fc:	b7 0b       	sbc	r27, r23

000064fe <__udivmodhi4_ep>:
    64fe:	88 1f       	adc	r24, r24
    6500:	99 1f       	adc	r25, r25
    6502:	5a 95       	dec	r21
    6504:	a9 f7       	brne	.-22     	; 0x64f0 <__udivmodhi4_loop>
    6506:	80 95       	com	r24
    6508:	90 95       	com	r25
    650a:	bc 01       	movw	r22, r24
    650c:	cd 01       	movw	r24, r26
    650e:	08 95       	ret

00006510 <__divmodhi4>:
    6510:	97 fb       	bst	r25, 7
    6512:	09 2e       	mov	r0, r25
    6514:	07 26       	eor	r0, r23
    6516:	0a d0       	rcall	.+20     	; 0x652c <__divmodhi4_neg1>
    6518:	77 fd       	sbrc	r23, 7
    651a:	04 d0       	rcall	.+8      	; 0x6524 <__divmodhi4_neg2>
    651c:	e5 df       	rcall	.-54     	; 0x64e8 <__udivmodhi4>
    651e:	06 d0       	rcall	.+12     	; 0x652c <__divmodhi4_neg1>
    6520:	00 20       	and	r0, r0
    6522:	1a f4       	brpl	.+6      	; 0x652a <__divmodhi4_exit>

00006524 <__divmodhi4_neg2>:
    6524:	70 95       	com	r23
    6526:	61 95       	neg	r22
    6528:	7f 4f       	sbci	r23, 0xFF	; 255

0000652a <__divmodhi4_exit>:
    652a:	08 95       	ret

0000652c <__divmodhi4_neg1>:
    652c:	f6 f7       	brtc	.-4      	; 0x652a <__divmodhi4_exit>
    652e:	90 95       	com	r25
    6530:	81 95       	neg	r24
    6532:	9f 4f       	sbci	r25, 0xFF	; 255
    6534:	08 95       	ret

00006536 <memcpy>:
    6536:	fb 01       	movw	r30, r22
    6538:	dc 01       	movw	r26, r24
    653a:	02 c0       	rjmp	.+4      	; 0x6540 <memcpy+0xa>
    653c:	01 90       	ld	r0, Z+
    653e:	0d 92       	st	X+, r0
    6540:	41 50       	subi	r20, 0x01	; 1
    6542:	50 40       	sbci	r21, 0x00	; 0
    6544:	d8 f7       	brcc	.-10     	; 0x653c <memcpy+0x6>
    6546:	08 95       	ret

00006548 <memset>:
    6548:	dc 01       	movw	r26, r24
    654a:	01 c0       	rjmp	.+2      	; 0x654e <memset+0x6>
    654c:	6d 93       	st	X+, r22
    654e:	41 50       	subi	r20, 0x01	; 1
    6550:	50 40       	sbci	r21, 0x00	; 0
    6552:	e0 f7       	brcc	.-8      	; 0x654c <memset+0x4>
    6554:	08 95       	ret

00006556 <_exit>:
    6556:	f8 94       	cli

00006558 <__stop_program>:
    6558:	ff cf       	rjmp	.-2      	; 0x6558 <__stop_program>
