
RTOS_2023.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000066ba  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000002c  00800060  000066ba  0000674e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000006a7  0080008c  0080008c  0000677a  2**0
                  ALLOC
  3 .stab         00009750  00000000  00000000  0000677c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00005a74  00000000  00000000  0000fecc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 9a 03 	jmp	0x734	; 0x734 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea eb       	ldi	r30, 0xBA	; 186
      68:	f6 e6       	ldi	r31, 0x66	; 102
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 38       	cpi	r26, 0x8C	; 140
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	ac e8       	ldi	r26, 0x8C	; 140
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 33       	cpi	r26, 0x33	; 51
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 86 31 	call	0x630c	; 0x630c <main>
      8a:	0c 94 5b 33 	jmp	0x66b6	; 0x66b6 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <pvPortMalloc+0x6>
      98:	00 d0       	rcall	.+0      	; 0x9a <pvPortMalloc+0x8>
      9a:	cd b7       	in	r28, 0x3d	; 61
      9c:	de b7       	in	r29, 0x3e	; 62
      9e:	9c 83       	std	Y+4, r25	; 0x04
      a0:	8b 83       	std	Y+3, r24	; 0x03
    void * pvReturn = NULL;
      a2:	1a 82       	std	Y+2, r1	; 0x02
      a4:	19 82       	std	Y+1, r1	; 0x01
                }
            }
        }
    #endif

    vTaskSuspendAll();
      a6:	0e 94 8b 1b 	call	0x3716	; 0x3716 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
      aa:	80 91 8e 00 	lds	r24, 0x008E
      ae:	90 91 8f 00 	lds	r25, 0x008F
      b2:	00 97       	sbiw	r24, 0x00	; 0
      b4:	31 f4       	brne	.+12     	; 0xc2 <pvPortMalloc+0x30>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
      b6:	80 e9       	ldi	r24, 0x90	; 144
      b8:	90 e0       	ldi	r25, 0x00	; 0
      ba:	90 93 8f 00 	sts	0x008F, r25
      be:	80 93 8e 00 	sts	0x008E, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
      c2:	8b 81       	ldd	r24, Y+3	; 0x03
      c4:	9c 81       	ldd	r25, Y+4	; 0x04
      c6:	00 97       	sbiw	r24, 0x00	; 0
      c8:	99 f1       	breq	.+102    	; 0x130 <pvPortMalloc+0x9e>
      ca:	80 91 8c 00 	lds	r24, 0x008C
      ce:	90 91 8d 00 	lds	r25, 0x008D
      d2:	2b 81       	ldd	r18, Y+3	; 0x03
      d4:	3c 81       	ldd	r19, Y+4	; 0x04
      d6:	82 0f       	add	r24, r18
      d8:	93 1f       	adc	r25, r19
      da:	25 e0       	ldi	r18, 0x05	; 5
      dc:	8b 3d       	cpi	r24, 0xDB	; 219
      de:	92 07       	cpc	r25, r18
      e0:	38 f5       	brcc	.+78     	; 0x130 <pvPortMalloc+0x9e>
      e2:	20 91 8c 00 	lds	r18, 0x008C
      e6:	30 91 8d 00 	lds	r19, 0x008D
      ea:	8b 81       	ldd	r24, Y+3	; 0x03
      ec:	9c 81       	ldd	r25, Y+4	; 0x04
      ee:	28 0f       	add	r18, r24
      f0:	39 1f       	adc	r19, r25
      f2:	80 91 8c 00 	lds	r24, 0x008C
      f6:	90 91 8d 00 	lds	r25, 0x008D
      fa:	82 17       	cp	r24, r18
      fc:	93 07       	cpc	r25, r19
      fe:	c0 f4       	brcc	.+48     	; 0x130 <pvPortMalloc+0x9e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
     100:	20 91 8e 00 	lds	r18, 0x008E
     104:	30 91 8f 00 	lds	r19, 0x008F
     108:	80 91 8c 00 	lds	r24, 0x008C
     10c:	90 91 8d 00 	lds	r25, 0x008D
     110:	82 0f       	add	r24, r18
     112:	93 1f       	adc	r25, r19
     114:	9a 83       	std	Y+2, r25	; 0x02
     116:	89 83       	std	Y+1, r24	; 0x01
            xNextFreeByte += xWantedSize;
     118:	20 91 8c 00 	lds	r18, 0x008C
     11c:	30 91 8d 00 	lds	r19, 0x008D
     120:	8b 81       	ldd	r24, Y+3	; 0x03
     122:	9c 81       	ldd	r25, Y+4	; 0x04
     124:	82 0f       	add	r24, r18
     126:	93 1f       	adc	r25, r19
     128:	90 93 8d 00 	sts	0x008D, r25
     12c:	80 93 8c 00 	sts	0x008C, r24
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
     130:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
     134:	89 81       	ldd	r24, Y+1	; 0x01
     136:	9a 81       	ldd	r25, Y+2	; 0x02
}
     138:	0f 90       	pop	r0
     13a:	0f 90       	pop	r0
     13c:	0f 90       	pop	r0
     13e:	0f 90       	pop	r0
     140:	cf 91       	pop	r28
     142:	df 91       	pop	r29
     144:	08 95       	ret

00000146 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
     146:	df 93       	push	r29
     148:	cf 93       	push	r28
     14a:	00 d0       	rcall	.+0      	; 0x14c <vPortFree+0x6>
     14c:	cd b7       	in	r28, 0x3d	; 61
     14e:	de b7       	in	r29, 0x3e	; 62
     150:	9a 83       	std	Y+2, r25	; 0x02
     152:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
     154:	0f 90       	pop	r0
     156:	0f 90       	pop	r0
     158:	cf 91       	pop	r28
     15a:	df 91       	pop	r29
     15c:	08 95       	ret

0000015e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     15e:	df 93       	push	r29
     160:	cf 93       	push	r28
     162:	cd b7       	in	r28, 0x3d	; 61
     164:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
     166:	10 92 8d 00 	sts	0x008D, r1
     16a:	10 92 8c 00 	sts	0x008C, r1
}
     16e:	cf 91       	pop	r28
     170:	df 91       	pop	r29
     172:	08 95       	ret

00000174 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     174:	df 93       	push	r29
     176:	cf 93       	push	r28
     178:	cd b7       	in	r28, 0x3d	; 61
     17a:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     17c:	20 91 8c 00 	lds	r18, 0x008C
     180:	30 91 8d 00 	lds	r19, 0x008D
     184:	8b ed       	ldi	r24, 0xDB	; 219
     186:	95 e0       	ldi	r25, 0x05	; 5
     188:	82 1b       	sub	r24, r18
     18a:	93 0b       	sbc	r25, r19
}
     18c:	cf 91       	pop	r28
     18e:	df 91       	pop	r29
     190:	08 95       	ret

00000192 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     192:	df 93       	push	r29
     194:	cf 93       	push	r28
     196:	cd b7       	in	r28, 0x3d	; 61
     198:	de b7       	in	r29, 0x3e	; 62
     19a:	28 97       	sbiw	r28, 0x08	; 8
     19c:	0f b6       	in	r0, 0x3f	; 63
     19e:	f8 94       	cli
     1a0:	de bf       	out	0x3e, r29	; 62
     1a2:	0f be       	out	0x3f, r0	; 63
     1a4:	cd bf       	out	0x3d, r28	; 61
     1a6:	9c 83       	std	Y+4, r25	; 0x04
     1a8:	8b 83       	std	Y+3, r24	; 0x03
     1aa:	7e 83       	std	Y+6, r23	; 0x06
     1ac:	6d 83       	std	Y+5, r22	; 0x05
     1ae:	58 87       	std	Y+8, r21	; 0x08
     1b0:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     1b2:	eb 81       	ldd	r30, Y+3	; 0x03
     1b4:	fc 81       	ldd	r31, Y+4	; 0x04
     1b6:	81 e1       	ldi	r24, 0x11	; 17
     1b8:	80 83       	st	Z, r24
	pxTopOfStack--;
     1ba:	8b 81       	ldd	r24, Y+3	; 0x03
     1bc:	9c 81       	ldd	r25, Y+4	; 0x04
     1be:	01 97       	sbiw	r24, 0x01	; 1
     1c0:	9c 83       	std	Y+4, r25	; 0x04
     1c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     1c4:	eb 81       	ldd	r30, Y+3	; 0x03
     1c6:	fc 81       	ldd	r31, Y+4	; 0x04
     1c8:	82 e2       	ldi	r24, 0x22	; 34
     1ca:	80 83       	st	Z, r24
	pxTopOfStack--;
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	01 97       	sbiw	r24, 0x01	; 1
     1d2:	9c 83       	std	Y+4, r25	; 0x04
     1d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     1d6:	eb 81       	ldd	r30, Y+3	; 0x03
     1d8:	fc 81       	ldd	r31, Y+4	; 0x04
     1da:	83 e3       	ldi	r24, 0x33	; 51
     1dc:	80 83       	st	Z, r24
	pxTopOfStack--;
     1de:	8b 81       	ldd	r24, Y+3	; 0x03
     1e0:	9c 81       	ldd	r25, Y+4	; 0x04
     1e2:	01 97       	sbiw	r24, 0x01	; 1
     1e4:	9c 83       	std	Y+4, r25	; 0x04
     1e6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     1e8:	8d 81       	ldd	r24, Y+5	; 0x05
     1ea:	9e 81       	ldd	r25, Y+6	; 0x06
     1ec:	9a 83       	std	Y+2, r25	; 0x02
     1ee:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     1f0:	89 81       	ldd	r24, Y+1	; 0x01
     1f2:	eb 81       	ldd	r30, Y+3	; 0x03
     1f4:	fc 81       	ldd	r31, Y+4	; 0x04
     1f6:	80 83       	st	Z, r24
	pxTopOfStack--;
     1f8:	8b 81       	ldd	r24, Y+3	; 0x03
     1fa:	9c 81       	ldd	r25, Y+4	; 0x04
     1fc:	01 97       	sbiw	r24, 0x01	; 1
     1fe:	9c 83       	std	Y+4, r25	; 0x04
     200:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     202:	89 81       	ldd	r24, Y+1	; 0x01
     204:	9a 81       	ldd	r25, Y+2	; 0x02
     206:	89 2f       	mov	r24, r25
     208:	99 27       	eor	r25, r25
     20a:	9a 83       	std	Y+2, r25	; 0x02
     20c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     20e:	89 81       	ldd	r24, Y+1	; 0x01
     210:	eb 81       	ldd	r30, Y+3	; 0x03
     212:	fc 81       	ldd	r31, Y+4	; 0x04
     214:	80 83       	st	Z, r24
	pxTopOfStack--;
     216:	8b 81       	ldd	r24, Y+3	; 0x03
     218:	9c 81       	ldd	r25, Y+4	; 0x04
     21a:	01 97       	sbiw	r24, 0x01	; 1
     21c:	9c 83       	std	Y+4, r25	; 0x04
     21e:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     220:	eb 81       	ldd	r30, Y+3	; 0x03
     222:	fc 81       	ldd	r31, Y+4	; 0x04
     224:	10 82       	st	Z, r1
	pxTopOfStack--;
     226:	8b 81       	ldd	r24, Y+3	; 0x03
     228:	9c 81       	ldd	r25, Y+4	; 0x04
     22a:	01 97       	sbiw	r24, 0x01	; 1
     22c:	9c 83       	std	Y+4, r25	; 0x04
     22e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     230:	eb 81       	ldd	r30, Y+3	; 0x03
     232:	fc 81       	ldd	r31, Y+4	; 0x04
     234:	80 e8       	ldi	r24, 0x80	; 128
     236:	80 83       	st	Z, r24
	pxTopOfStack--;
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	01 97       	sbiw	r24, 0x01	; 1
     23e:	9c 83       	std	Y+4, r25	; 0x04
     240:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     242:	eb 81       	ldd	r30, Y+3	; 0x03
     244:	fc 81       	ldd	r31, Y+4	; 0x04
     246:	10 82       	st	Z, r1
	pxTopOfStack--;
     248:	8b 81       	ldd	r24, Y+3	; 0x03
     24a:	9c 81       	ldd	r25, Y+4	; 0x04
     24c:	01 97       	sbiw	r24, 0x01	; 1
     24e:	9c 83       	std	Y+4, r25	; 0x04
     250:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     252:	eb 81       	ldd	r30, Y+3	; 0x03
     254:	fc 81       	ldd	r31, Y+4	; 0x04
     256:	82 e0       	ldi	r24, 0x02	; 2
     258:	80 83       	st	Z, r24
	pxTopOfStack--;
     25a:	8b 81       	ldd	r24, Y+3	; 0x03
     25c:	9c 81       	ldd	r25, Y+4	; 0x04
     25e:	01 97       	sbiw	r24, 0x01	; 1
     260:	9c 83       	std	Y+4, r25	; 0x04
     262:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     264:	eb 81       	ldd	r30, Y+3	; 0x03
     266:	fc 81       	ldd	r31, Y+4	; 0x04
     268:	83 e0       	ldi	r24, 0x03	; 3
     26a:	80 83       	st	Z, r24
	pxTopOfStack--;
     26c:	8b 81       	ldd	r24, Y+3	; 0x03
     26e:	9c 81       	ldd	r25, Y+4	; 0x04
     270:	01 97       	sbiw	r24, 0x01	; 1
     272:	9c 83       	std	Y+4, r25	; 0x04
     274:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     276:	eb 81       	ldd	r30, Y+3	; 0x03
     278:	fc 81       	ldd	r31, Y+4	; 0x04
     27a:	84 e0       	ldi	r24, 0x04	; 4
     27c:	80 83       	st	Z, r24
	pxTopOfStack--;
     27e:	8b 81       	ldd	r24, Y+3	; 0x03
     280:	9c 81       	ldd	r25, Y+4	; 0x04
     282:	01 97       	sbiw	r24, 0x01	; 1
     284:	9c 83       	std	Y+4, r25	; 0x04
     286:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     288:	eb 81       	ldd	r30, Y+3	; 0x03
     28a:	fc 81       	ldd	r31, Y+4	; 0x04
     28c:	85 e0       	ldi	r24, 0x05	; 5
     28e:	80 83       	st	Z, r24
	pxTopOfStack--;
     290:	8b 81       	ldd	r24, Y+3	; 0x03
     292:	9c 81       	ldd	r25, Y+4	; 0x04
     294:	01 97       	sbiw	r24, 0x01	; 1
     296:	9c 83       	std	Y+4, r25	; 0x04
     298:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     29a:	eb 81       	ldd	r30, Y+3	; 0x03
     29c:	fc 81       	ldd	r31, Y+4	; 0x04
     29e:	86 e0       	ldi	r24, 0x06	; 6
     2a0:	80 83       	st	Z, r24
	pxTopOfStack--;
     2a2:	8b 81       	ldd	r24, Y+3	; 0x03
     2a4:	9c 81       	ldd	r25, Y+4	; 0x04
     2a6:	01 97       	sbiw	r24, 0x01	; 1
     2a8:	9c 83       	std	Y+4, r25	; 0x04
     2aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     2ac:	eb 81       	ldd	r30, Y+3	; 0x03
     2ae:	fc 81       	ldd	r31, Y+4	; 0x04
     2b0:	87 e0       	ldi	r24, 0x07	; 7
     2b2:	80 83       	st	Z, r24
	pxTopOfStack--;
     2b4:	8b 81       	ldd	r24, Y+3	; 0x03
     2b6:	9c 81       	ldd	r25, Y+4	; 0x04
     2b8:	01 97       	sbiw	r24, 0x01	; 1
     2ba:	9c 83       	std	Y+4, r25	; 0x04
     2bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     2be:	eb 81       	ldd	r30, Y+3	; 0x03
     2c0:	fc 81       	ldd	r31, Y+4	; 0x04
     2c2:	88 e0       	ldi	r24, 0x08	; 8
     2c4:	80 83       	st	Z, r24
	pxTopOfStack--;
     2c6:	8b 81       	ldd	r24, Y+3	; 0x03
     2c8:	9c 81       	ldd	r25, Y+4	; 0x04
     2ca:	01 97       	sbiw	r24, 0x01	; 1
     2cc:	9c 83       	std	Y+4, r25	; 0x04
     2ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     2d0:	eb 81       	ldd	r30, Y+3	; 0x03
     2d2:	fc 81       	ldd	r31, Y+4	; 0x04
     2d4:	89 e0       	ldi	r24, 0x09	; 9
     2d6:	80 83       	st	Z, r24
	pxTopOfStack--;
     2d8:	8b 81       	ldd	r24, Y+3	; 0x03
     2da:	9c 81       	ldd	r25, Y+4	; 0x04
     2dc:	01 97       	sbiw	r24, 0x01	; 1
     2de:	9c 83       	std	Y+4, r25	; 0x04
     2e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     2e2:	eb 81       	ldd	r30, Y+3	; 0x03
     2e4:	fc 81       	ldd	r31, Y+4	; 0x04
     2e6:	80 e1       	ldi	r24, 0x10	; 16
     2e8:	80 83       	st	Z, r24
	pxTopOfStack--;
     2ea:	8b 81       	ldd	r24, Y+3	; 0x03
     2ec:	9c 81       	ldd	r25, Y+4	; 0x04
     2ee:	01 97       	sbiw	r24, 0x01	; 1
     2f0:	9c 83       	std	Y+4, r25	; 0x04
     2f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     2f4:	eb 81       	ldd	r30, Y+3	; 0x03
     2f6:	fc 81       	ldd	r31, Y+4	; 0x04
     2f8:	81 e1       	ldi	r24, 0x11	; 17
     2fa:	80 83       	st	Z, r24
	pxTopOfStack--;
     2fc:	8b 81       	ldd	r24, Y+3	; 0x03
     2fe:	9c 81       	ldd	r25, Y+4	; 0x04
     300:	01 97       	sbiw	r24, 0x01	; 1
     302:	9c 83       	std	Y+4, r25	; 0x04
     304:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     306:	eb 81       	ldd	r30, Y+3	; 0x03
     308:	fc 81       	ldd	r31, Y+4	; 0x04
     30a:	82 e1       	ldi	r24, 0x12	; 18
     30c:	80 83       	st	Z, r24
	pxTopOfStack--;
     30e:	8b 81       	ldd	r24, Y+3	; 0x03
     310:	9c 81       	ldd	r25, Y+4	; 0x04
     312:	01 97       	sbiw	r24, 0x01	; 1
     314:	9c 83       	std	Y+4, r25	; 0x04
     316:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     318:	eb 81       	ldd	r30, Y+3	; 0x03
     31a:	fc 81       	ldd	r31, Y+4	; 0x04
     31c:	83 e1       	ldi	r24, 0x13	; 19
     31e:	80 83       	st	Z, r24
	pxTopOfStack--;
     320:	8b 81       	ldd	r24, Y+3	; 0x03
     322:	9c 81       	ldd	r25, Y+4	; 0x04
     324:	01 97       	sbiw	r24, 0x01	; 1
     326:	9c 83       	std	Y+4, r25	; 0x04
     328:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     32a:	eb 81       	ldd	r30, Y+3	; 0x03
     32c:	fc 81       	ldd	r31, Y+4	; 0x04
     32e:	84 e1       	ldi	r24, 0x14	; 20
     330:	80 83       	st	Z, r24
	pxTopOfStack--;
     332:	8b 81       	ldd	r24, Y+3	; 0x03
     334:	9c 81       	ldd	r25, Y+4	; 0x04
     336:	01 97       	sbiw	r24, 0x01	; 1
     338:	9c 83       	std	Y+4, r25	; 0x04
     33a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     33c:	eb 81       	ldd	r30, Y+3	; 0x03
     33e:	fc 81       	ldd	r31, Y+4	; 0x04
     340:	85 e1       	ldi	r24, 0x15	; 21
     342:	80 83       	st	Z, r24
	pxTopOfStack--;
     344:	8b 81       	ldd	r24, Y+3	; 0x03
     346:	9c 81       	ldd	r25, Y+4	; 0x04
     348:	01 97       	sbiw	r24, 0x01	; 1
     34a:	9c 83       	std	Y+4, r25	; 0x04
     34c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     34e:	eb 81       	ldd	r30, Y+3	; 0x03
     350:	fc 81       	ldd	r31, Y+4	; 0x04
     352:	86 e1       	ldi	r24, 0x16	; 22
     354:	80 83       	st	Z, r24
	pxTopOfStack--;
     356:	8b 81       	ldd	r24, Y+3	; 0x03
     358:	9c 81       	ldd	r25, Y+4	; 0x04
     35a:	01 97       	sbiw	r24, 0x01	; 1
     35c:	9c 83       	std	Y+4, r25	; 0x04
     35e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     360:	eb 81       	ldd	r30, Y+3	; 0x03
     362:	fc 81       	ldd	r31, Y+4	; 0x04
     364:	87 e1       	ldi	r24, 0x17	; 23
     366:	80 83       	st	Z, r24
	pxTopOfStack--;
     368:	8b 81       	ldd	r24, Y+3	; 0x03
     36a:	9c 81       	ldd	r25, Y+4	; 0x04
     36c:	01 97       	sbiw	r24, 0x01	; 1
     36e:	9c 83       	std	Y+4, r25	; 0x04
     370:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     372:	eb 81       	ldd	r30, Y+3	; 0x03
     374:	fc 81       	ldd	r31, Y+4	; 0x04
     376:	88 e1       	ldi	r24, 0x18	; 24
     378:	80 83       	st	Z, r24
	pxTopOfStack--;
     37a:	8b 81       	ldd	r24, Y+3	; 0x03
     37c:	9c 81       	ldd	r25, Y+4	; 0x04
     37e:	01 97       	sbiw	r24, 0x01	; 1
     380:	9c 83       	std	Y+4, r25	; 0x04
     382:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     384:	eb 81       	ldd	r30, Y+3	; 0x03
     386:	fc 81       	ldd	r31, Y+4	; 0x04
     388:	89 e1       	ldi	r24, 0x19	; 25
     38a:	80 83       	st	Z, r24
	pxTopOfStack--;
     38c:	8b 81       	ldd	r24, Y+3	; 0x03
     38e:	9c 81       	ldd	r25, Y+4	; 0x04
     390:	01 97       	sbiw	r24, 0x01	; 1
     392:	9c 83       	std	Y+4, r25	; 0x04
     394:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     396:	eb 81       	ldd	r30, Y+3	; 0x03
     398:	fc 81       	ldd	r31, Y+4	; 0x04
     39a:	80 e2       	ldi	r24, 0x20	; 32
     39c:	80 83       	st	Z, r24
	pxTopOfStack--;
     39e:	8b 81       	ldd	r24, Y+3	; 0x03
     3a0:	9c 81       	ldd	r25, Y+4	; 0x04
     3a2:	01 97       	sbiw	r24, 0x01	; 1
     3a4:	9c 83       	std	Y+4, r25	; 0x04
     3a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     3a8:	eb 81       	ldd	r30, Y+3	; 0x03
     3aa:	fc 81       	ldd	r31, Y+4	; 0x04
     3ac:	81 e2       	ldi	r24, 0x21	; 33
     3ae:	80 83       	st	Z, r24
	pxTopOfStack--;
     3b0:	8b 81       	ldd	r24, Y+3	; 0x03
     3b2:	9c 81       	ldd	r25, Y+4	; 0x04
     3b4:	01 97       	sbiw	r24, 0x01	; 1
     3b6:	9c 83       	std	Y+4, r25	; 0x04
     3b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     3ba:	eb 81       	ldd	r30, Y+3	; 0x03
     3bc:	fc 81       	ldd	r31, Y+4	; 0x04
     3be:	82 e2       	ldi	r24, 0x22	; 34
     3c0:	80 83       	st	Z, r24
	pxTopOfStack--;
     3c2:	8b 81       	ldd	r24, Y+3	; 0x03
     3c4:	9c 81       	ldd	r25, Y+4	; 0x04
     3c6:	01 97       	sbiw	r24, 0x01	; 1
     3c8:	9c 83       	std	Y+4, r25	; 0x04
     3ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     3cc:	eb 81       	ldd	r30, Y+3	; 0x03
     3ce:	fc 81       	ldd	r31, Y+4	; 0x04
     3d0:	83 e2       	ldi	r24, 0x23	; 35
     3d2:	80 83       	st	Z, r24
	pxTopOfStack--;
     3d4:	8b 81       	ldd	r24, Y+3	; 0x03
     3d6:	9c 81       	ldd	r25, Y+4	; 0x04
     3d8:	01 97       	sbiw	r24, 0x01	; 1
     3da:	9c 83       	std	Y+4, r25	; 0x04
     3dc:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     3de:	8f 81       	ldd	r24, Y+7	; 0x07
     3e0:	98 85       	ldd	r25, Y+8	; 0x08
     3e2:	9a 83       	std	Y+2, r25	; 0x02
     3e4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     3e6:	89 81       	ldd	r24, Y+1	; 0x01
     3e8:	eb 81       	ldd	r30, Y+3	; 0x03
     3ea:	fc 81       	ldd	r31, Y+4	; 0x04
     3ec:	80 83       	st	Z, r24
	pxTopOfStack--;
     3ee:	8b 81       	ldd	r24, Y+3	; 0x03
     3f0:	9c 81       	ldd	r25, Y+4	; 0x04
     3f2:	01 97       	sbiw	r24, 0x01	; 1
     3f4:	9c 83       	std	Y+4, r25	; 0x04
     3f6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     3f8:	89 81       	ldd	r24, Y+1	; 0x01
     3fa:	9a 81       	ldd	r25, Y+2	; 0x02
     3fc:	89 2f       	mov	r24, r25
     3fe:	99 27       	eor	r25, r25
     400:	9a 83       	std	Y+2, r25	; 0x02
     402:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     404:	89 81       	ldd	r24, Y+1	; 0x01
     406:	eb 81       	ldd	r30, Y+3	; 0x03
     408:	fc 81       	ldd	r31, Y+4	; 0x04
     40a:	80 83       	st	Z, r24
	pxTopOfStack--;
     40c:	8b 81       	ldd	r24, Y+3	; 0x03
     40e:	9c 81       	ldd	r25, Y+4	; 0x04
     410:	01 97       	sbiw	r24, 0x01	; 1
     412:	9c 83       	std	Y+4, r25	; 0x04
     414:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     416:	eb 81       	ldd	r30, Y+3	; 0x03
     418:	fc 81       	ldd	r31, Y+4	; 0x04
     41a:	86 e2       	ldi	r24, 0x26	; 38
     41c:	80 83       	st	Z, r24
	pxTopOfStack--;
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	9c 81       	ldd	r25, Y+4	; 0x04
     422:	01 97       	sbiw	r24, 0x01	; 1
     424:	9c 83       	std	Y+4, r25	; 0x04
     426:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     428:	eb 81       	ldd	r30, Y+3	; 0x03
     42a:	fc 81       	ldd	r31, Y+4	; 0x04
     42c:	87 e2       	ldi	r24, 0x27	; 39
     42e:	80 83       	st	Z, r24
	pxTopOfStack--;
     430:	8b 81       	ldd	r24, Y+3	; 0x03
     432:	9c 81       	ldd	r25, Y+4	; 0x04
     434:	01 97       	sbiw	r24, 0x01	; 1
     436:	9c 83       	std	Y+4, r25	; 0x04
     438:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     43a:	eb 81       	ldd	r30, Y+3	; 0x03
     43c:	fc 81       	ldd	r31, Y+4	; 0x04
     43e:	88 e2       	ldi	r24, 0x28	; 40
     440:	80 83       	st	Z, r24
	pxTopOfStack--;
     442:	8b 81       	ldd	r24, Y+3	; 0x03
     444:	9c 81       	ldd	r25, Y+4	; 0x04
     446:	01 97       	sbiw	r24, 0x01	; 1
     448:	9c 83       	std	Y+4, r25	; 0x04
     44a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     44c:	eb 81       	ldd	r30, Y+3	; 0x03
     44e:	fc 81       	ldd	r31, Y+4	; 0x04
     450:	89 e2       	ldi	r24, 0x29	; 41
     452:	80 83       	st	Z, r24
	pxTopOfStack--;
     454:	8b 81       	ldd	r24, Y+3	; 0x03
     456:	9c 81       	ldd	r25, Y+4	; 0x04
     458:	01 97       	sbiw	r24, 0x01	; 1
     45a:	9c 83       	std	Y+4, r25	; 0x04
     45c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     45e:	eb 81       	ldd	r30, Y+3	; 0x03
     460:	fc 81       	ldd	r31, Y+4	; 0x04
     462:	80 e3       	ldi	r24, 0x30	; 48
     464:	80 83       	st	Z, r24
	pxTopOfStack--;
     466:	8b 81       	ldd	r24, Y+3	; 0x03
     468:	9c 81       	ldd	r25, Y+4	; 0x04
     46a:	01 97       	sbiw	r24, 0x01	; 1
     46c:	9c 83       	std	Y+4, r25	; 0x04
     46e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     470:	eb 81       	ldd	r30, Y+3	; 0x03
     472:	fc 81       	ldd	r31, Y+4	; 0x04
     474:	81 e3       	ldi	r24, 0x31	; 49
     476:	80 83       	st	Z, r24
	pxTopOfStack--;
     478:	8b 81       	ldd	r24, Y+3	; 0x03
     47a:	9c 81       	ldd	r25, Y+4	; 0x04
     47c:	01 97       	sbiw	r24, 0x01	; 1
     47e:	9c 83       	std	Y+4, r25	; 0x04
     480:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     482:	8b 81       	ldd	r24, Y+3	; 0x03
     484:	9c 81       	ldd	r25, Y+4	; 0x04
}
     486:	28 96       	adiw	r28, 0x08	; 8
     488:	0f b6       	in	r0, 0x3f	; 63
     48a:	f8 94       	cli
     48c:	de bf       	out	0x3e, r29	; 62
     48e:	0f be       	out	0x3f, r0	; 63
     490:	cd bf       	out	0x3d, r28	; 61
     492:	cf 91       	pop	r28
     494:	df 91       	pop	r29
     496:	08 95       	ret

00000498 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     498:	df 93       	push	r29
     49a:	cf 93       	push	r28
     49c:	cd b7       	in	r28, 0x3d	; 61
     49e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     4a0:	0e 94 3e 03 	call	0x67c	; 0x67c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     4a4:	a0 91 a6 06 	lds	r26, 0x06A6
     4a8:	b0 91 a7 06 	lds	r27, 0x06A7
     4ac:	cd 91       	ld	r28, X+
     4ae:	cd bf       	out	0x3d, r28	; 61
     4b0:	dd 91       	ld	r29, X+
     4b2:	de bf       	out	0x3e, r29	; 62
     4b4:	ff 91       	pop	r31
     4b6:	ef 91       	pop	r30
     4b8:	df 91       	pop	r29
     4ba:	cf 91       	pop	r28
     4bc:	bf 91       	pop	r27
     4be:	af 91       	pop	r26
     4c0:	9f 91       	pop	r25
     4c2:	8f 91       	pop	r24
     4c4:	7f 91       	pop	r23
     4c6:	6f 91       	pop	r22
     4c8:	5f 91       	pop	r21
     4ca:	4f 91       	pop	r20
     4cc:	3f 91       	pop	r19
     4ce:	2f 91       	pop	r18
     4d0:	1f 91       	pop	r17
     4d2:	0f 91       	pop	r16
     4d4:	ff 90       	pop	r15
     4d6:	ef 90       	pop	r14
     4d8:	df 90       	pop	r13
     4da:	cf 90       	pop	r12
     4dc:	bf 90       	pop	r11
     4de:	af 90       	pop	r10
     4e0:	9f 90       	pop	r9
     4e2:	8f 90       	pop	r8
     4e4:	7f 90       	pop	r7
     4e6:	6f 90       	pop	r6
     4e8:	5f 90       	pop	r5
     4ea:	4f 90       	pop	r4
     4ec:	3f 90       	pop	r3
     4ee:	2f 90       	pop	r2
     4f0:	1f 90       	pop	r1
     4f2:	0f 90       	pop	r0
     4f4:	0f be       	out	0x3f, r0	; 63
     4f6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     4f8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     4fa:	81 e0       	ldi	r24, 0x01	; 1
}
     4fc:	cf 91       	pop	r28
     4fe:	df 91       	pop	r29
     500:	08 95       	ret

00000502 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     502:	df 93       	push	r29
     504:	cf 93       	push	r28
     506:	cd b7       	in	r28, 0x3d	; 61
     508:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     50a:	cf 91       	pop	r28
     50c:	df 91       	pop	r29
     50e:	08 95       	ret

00000510 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     510:	0f 92       	push	r0
     512:	0f b6       	in	r0, 0x3f	; 63
     514:	f8 94       	cli
     516:	0f 92       	push	r0
     518:	1f 92       	push	r1
     51a:	11 24       	eor	r1, r1
     51c:	2f 92       	push	r2
     51e:	3f 92       	push	r3
     520:	4f 92       	push	r4
     522:	5f 92       	push	r5
     524:	6f 92       	push	r6
     526:	7f 92       	push	r7
     528:	8f 92       	push	r8
     52a:	9f 92       	push	r9
     52c:	af 92       	push	r10
     52e:	bf 92       	push	r11
     530:	cf 92       	push	r12
     532:	df 92       	push	r13
     534:	ef 92       	push	r14
     536:	ff 92       	push	r15
     538:	0f 93       	push	r16
     53a:	1f 93       	push	r17
     53c:	2f 93       	push	r18
     53e:	3f 93       	push	r19
     540:	4f 93       	push	r20
     542:	5f 93       	push	r21
     544:	6f 93       	push	r22
     546:	7f 93       	push	r23
     548:	8f 93       	push	r24
     54a:	9f 93       	push	r25
     54c:	af 93       	push	r26
     54e:	bf 93       	push	r27
     550:	cf 93       	push	r28
     552:	df 93       	push	r29
     554:	ef 93       	push	r30
     556:	ff 93       	push	r31
     558:	a0 91 a6 06 	lds	r26, 0x06A6
     55c:	b0 91 a7 06 	lds	r27, 0x06A7
     560:	0d b6       	in	r0, 0x3d	; 61
     562:	0d 92       	st	X+, r0
     564:	0e b6       	in	r0, 0x3e	; 62
     566:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     568:	0e 94 fb 1e 	call	0x3df6	; 0x3df6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     56c:	a0 91 a6 06 	lds	r26, 0x06A6
     570:	b0 91 a7 06 	lds	r27, 0x06A7
     574:	cd 91       	ld	r28, X+
     576:	cd bf       	out	0x3d, r28	; 61
     578:	dd 91       	ld	r29, X+
     57a:	de bf       	out	0x3e, r29	; 62
     57c:	ff 91       	pop	r31
     57e:	ef 91       	pop	r30
     580:	df 91       	pop	r29
     582:	cf 91       	pop	r28
     584:	bf 91       	pop	r27
     586:	af 91       	pop	r26
     588:	9f 91       	pop	r25
     58a:	8f 91       	pop	r24
     58c:	7f 91       	pop	r23
     58e:	6f 91       	pop	r22
     590:	5f 91       	pop	r21
     592:	4f 91       	pop	r20
     594:	3f 91       	pop	r19
     596:	2f 91       	pop	r18
     598:	1f 91       	pop	r17
     59a:	0f 91       	pop	r16
     59c:	ff 90       	pop	r15
     59e:	ef 90       	pop	r14
     5a0:	df 90       	pop	r13
     5a2:	cf 90       	pop	r12
     5a4:	bf 90       	pop	r11
     5a6:	af 90       	pop	r10
     5a8:	9f 90       	pop	r9
     5aa:	8f 90       	pop	r8
     5ac:	7f 90       	pop	r7
     5ae:	6f 90       	pop	r6
     5b0:	5f 90       	pop	r5
     5b2:	4f 90       	pop	r4
     5b4:	3f 90       	pop	r3
     5b6:	2f 90       	pop	r2
     5b8:	1f 90       	pop	r1
     5ba:	0f 90       	pop	r0
     5bc:	0f be       	out	0x3f, r0	; 63
     5be:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5c0:	08 95       	ret

000005c2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     5c2:	0f 92       	push	r0
     5c4:	0f b6       	in	r0, 0x3f	; 63
     5c6:	f8 94       	cli
     5c8:	0f 92       	push	r0
     5ca:	1f 92       	push	r1
     5cc:	11 24       	eor	r1, r1
     5ce:	2f 92       	push	r2
     5d0:	3f 92       	push	r3
     5d2:	4f 92       	push	r4
     5d4:	5f 92       	push	r5
     5d6:	6f 92       	push	r6
     5d8:	7f 92       	push	r7
     5da:	8f 92       	push	r8
     5dc:	9f 92       	push	r9
     5de:	af 92       	push	r10
     5e0:	bf 92       	push	r11
     5e2:	cf 92       	push	r12
     5e4:	df 92       	push	r13
     5e6:	ef 92       	push	r14
     5e8:	ff 92       	push	r15
     5ea:	0f 93       	push	r16
     5ec:	1f 93       	push	r17
     5ee:	2f 93       	push	r18
     5f0:	3f 93       	push	r19
     5f2:	4f 93       	push	r20
     5f4:	5f 93       	push	r21
     5f6:	6f 93       	push	r22
     5f8:	7f 93       	push	r23
     5fa:	8f 93       	push	r24
     5fc:	9f 93       	push	r25
     5fe:	af 93       	push	r26
     600:	bf 93       	push	r27
     602:	cf 93       	push	r28
     604:	df 93       	push	r29
     606:	ef 93       	push	r30
     608:	ff 93       	push	r31
     60a:	a0 91 a6 06 	lds	r26, 0x06A6
     60e:	b0 91 a7 06 	lds	r27, 0x06A7
     612:	0d b6       	in	r0, 0x3d	; 61
     614:	0d 92       	st	X+, r0
     616:	0e b6       	in	r0, 0x3e	; 62
     618:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     61a:	0e 94 64 1d 	call	0x3ac8	; 0x3ac8 <xTaskIncrementTick>
     61e:	88 23       	and	r24, r24
     620:	11 f0       	breq	.+4      	; 0x626 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     622:	0e 94 fb 1e 	call	0x3df6	; 0x3df6 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     626:	a0 91 a6 06 	lds	r26, 0x06A6
     62a:	b0 91 a7 06 	lds	r27, 0x06A7
     62e:	cd 91       	ld	r28, X+
     630:	cd bf       	out	0x3d, r28	; 61
     632:	dd 91       	ld	r29, X+
     634:	de bf       	out	0x3e, r29	; 62
     636:	ff 91       	pop	r31
     638:	ef 91       	pop	r30
     63a:	df 91       	pop	r29
     63c:	cf 91       	pop	r28
     63e:	bf 91       	pop	r27
     640:	af 91       	pop	r26
     642:	9f 91       	pop	r25
     644:	8f 91       	pop	r24
     646:	7f 91       	pop	r23
     648:	6f 91       	pop	r22
     64a:	5f 91       	pop	r21
     64c:	4f 91       	pop	r20
     64e:	3f 91       	pop	r19
     650:	2f 91       	pop	r18
     652:	1f 91       	pop	r17
     654:	0f 91       	pop	r16
     656:	ff 90       	pop	r15
     658:	ef 90       	pop	r14
     65a:	df 90       	pop	r13
     65c:	cf 90       	pop	r12
     65e:	bf 90       	pop	r11
     660:	af 90       	pop	r10
     662:	9f 90       	pop	r9
     664:	8f 90       	pop	r8
     666:	7f 90       	pop	r7
     668:	6f 90       	pop	r6
     66a:	5f 90       	pop	r5
     66c:	4f 90       	pop	r4
     66e:	3f 90       	pop	r3
     670:	2f 90       	pop	r2
     672:	1f 90       	pop	r1
     674:	0f 90       	pop	r0
     676:	0f be       	out	0x3f, r0	; 63
     678:	0f 90       	pop	r0

	asm volatile ( "ret" );
     67a:	08 95       	ret

0000067c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     67c:	df 93       	push	r29
     67e:	cf 93       	push	r28
     680:	00 d0       	rcall	.+0      	; 0x682 <prvSetupTimerInterrupt+0x6>
     682:	00 d0       	rcall	.+0      	; 0x684 <prvSetupTimerInterrupt+0x8>
     684:	00 d0       	rcall	.+0      	; 0x686 <prvSetupTimerInterrupt+0xa>
     686:	cd b7       	in	r28, 0x3d	; 61
     688:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     68a:	80 e4       	ldi	r24, 0x40	; 64
     68c:	9f e1       	ldi	r25, 0x1F	; 31
     68e:	a0 e0       	ldi	r26, 0x00	; 0
     690:	b0 e0       	ldi	r27, 0x00	; 0
     692:	8b 83       	std	Y+3, r24	; 0x03
     694:	9c 83       	std	Y+4, r25	; 0x04
     696:	ad 83       	std	Y+5, r26	; 0x05
     698:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     69a:	8b 81       	ldd	r24, Y+3	; 0x03
     69c:	9c 81       	ldd	r25, Y+4	; 0x04
     69e:	ad 81       	ldd	r26, Y+5	; 0x05
     6a0:	be 81       	ldd	r27, Y+6	; 0x06
     6a2:	68 94       	set
     6a4:	15 f8       	bld	r1, 5
     6a6:	b6 95       	lsr	r27
     6a8:	a7 95       	ror	r26
     6aa:	97 95       	ror	r25
     6ac:	87 95       	ror	r24
     6ae:	16 94       	lsr	r1
     6b0:	d1 f7       	brne	.-12     	; 0x6a6 <prvSetupTimerInterrupt+0x2a>
     6b2:	8b 83       	std	Y+3, r24	; 0x03
     6b4:	9c 83       	std	Y+4, r25	; 0x04
     6b6:	ad 83       	std	Y+5, r26	; 0x05
     6b8:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     6ba:	8b 81       	ldd	r24, Y+3	; 0x03
     6bc:	9c 81       	ldd	r25, Y+4	; 0x04
     6be:	ad 81       	ldd	r26, Y+5	; 0x05
     6c0:	be 81       	ldd	r27, Y+6	; 0x06
     6c2:	01 97       	sbiw	r24, 0x01	; 1
     6c4:	a1 09       	sbc	r26, r1
     6c6:	b1 09       	sbc	r27, r1
     6c8:	8b 83       	std	Y+3, r24	; 0x03
     6ca:	9c 83       	std	Y+4, r25	; 0x04
     6cc:	ad 83       	std	Y+5, r26	; 0x05
     6ce:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     6d0:	8b 81       	ldd	r24, Y+3	; 0x03
     6d2:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     6d4:	8b 81       	ldd	r24, Y+3	; 0x03
     6d6:	9c 81       	ldd	r25, Y+4	; 0x04
     6d8:	ad 81       	ldd	r26, Y+5	; 0x05
     6da:	be 81       	ldd	r27, Y+6	; 0x06
     6dc:	89 2f       	mov	r24, r25
     6de:	9a 2f       	mov	r25, r26
     6e0:	ab 2f       	mov	r26, r27
     6e2:	bb 27       	eor	r27, r27
     6e4:	8b 83       	std	Y+3, r24	; 0x03
     6e6:	9c 83       	std	Y+4, r25	; 0x04
     6e8:	ad 83       	std	Y+5, r26	; 0x05
     6ea:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     6ec:	8b 81       	ldd	r24, Y+3	; 0x03
     6ee:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     6f0:	eb e4       	ldi	r30, 0x4B	; 75
     6f2:	f0 e0       	ldi	r31, 0x00	; 0
     6f4:	8a 81       	ldd	r24, Y+2	; 0x02
     6f6:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     6f8:	ea e4       	ldi	r30, 0x4A	; 74
     6fa:	f0 e0       	ldi	r31, 0x00	; 0
     6fc:	89 81       	ldd	r24, Y+1	; 0x01
     6fe:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     700:	8b e0       	ldi	r24, 0x0B	; 11
     702:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     704:	ee e4       	ldi	r30, 0x4E	; 78
     706:	f0 e0       	ldi	r31, 0x00	; 0
     708:	89 81       	ldd	r24, Y+1	; 0x01
     70a:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     70c:	e9 e5       	ldi	r30, 0x59	; 89
     70e:	f0 e0       	ldi	r31, 0x00	; 0
     710:	80 81       	ld	r24, Z
     712:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     714:	89 81       	ldd	r24, Y+1	; 0x01
     716:	80 61       	ori	r24, 0x10	; 16
     718:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
     71a:	e9 e5       	ldi	r30, 0x59	; 89
     71c:	f0 e0       	ldi	r31, 0x00	; 0
     71e:	89 81       	ldd	r24, Y+1	; 0x01
     720:	80 83       	st	Z, r24
}
     722:	26 96       	adiw	r28, 0x06	; 6
     724:	0f b6       	in	r0, 0x3f	; 63
     726:	f8 94       	cli
     728:	de bf       	out	0x3e, r29	; 62
     72a:	0f be       	out	0x3f, r0	; 63
     72c:	cd bf       	out	0x3d, r28	; 61
     72e:	cf 91       	pop	r28
     730:	df 91       	pop	r29
     732:	08 95       	ret

00000734 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     734:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vPortYieldFromTick>
		asm volatile ( "reti" );
     738:	18 95       	reti

0000073a <DIO_SetPinDir>:


#include "DIO.h"

void DIO_SetPinDir(uint8_t port ,uint8_t pin, uint8_t dir)
{
     73a:	df 93       	push	r29
     73c:	cf 93       	push	r28
     73e:	cd b7       	in	r28, 0x3d	; 61
     740:	de b7       	in	r29, 0x3e	; 62
     742:	2d 97       	sbiw	r28, 0x0d	; 13
     744:	0f b6       	in	r0, 0x3f	; 63
     746:	f8 94       	cli
     748:	de bf       	out	0x3e, r29	; 62
     74a:	0f be       	out	0x3f, r0	; 63
     74c:	cd bf       	out	0x3d, r28	; 61
     74e:	89 83       	std	Y+1, r24	; 0x01
     750:	6a 83       	std	Y+2, r22	; 0x02
     752:	4b 83       	std	Y+3, r20	; 0x03
	switch (port)
     754:	89 81       	ldd	r24, Y+1	; 0x01
     756:	28 2f       	mov	r18, r24
     758:	30 e0       	ldi	r19, 0x00	; 0
     75a:	3d 87       	std	Y+13, r19	; 0x0d
     75c:	2c 87       	std	Y+12, r18	; 0x0c
     75e:	8c 85       	ldd	r24, Y+12	; 0x0c
     760:	9d 85       	ldd	r25, Y+13	; 0x0d
     762:	81 30       	cpi	r24, 0x01	; 1
     764:	91 05       	cpc	r25, r1
     766:	09 f4       	brne	.+2      	; 0x76a <DIO_SetPinDir+0x30>
     768:	44 c0       	rjmp	.+136    	; 0x7f2 <DIO_SetPinDir+0xb8>
     76a:	2c 85       	ldd	r18, Y+12	; 0x0c
     76c:	3d 85       	ldd	r19, Y+13	; 0x0d
     76e:	22 30       	cpi	r18, 0x02	; 2
     770:	31 05       	cpc	r19, r1
     772:	2c f4       	brge	.+10     	; 0x77e <DIO_SetPinDir+0x44>
     774:	8c 85       	ldd	r24, Y+12	; 0x0c
     776:	9d 85       	ldd	r25, Y+13	; 0x0d
     778:	00 97       	sbiw	r24, 0x00	; 0
     77a:	71 f0       	breq	.+28     	; 0x798 <DIO_SetPinDir+0x5e>
     77c:	c2 c0       	rjmp	.+388    	; 0x902 <__stack+0xa3>
     77e:	2c 85       	ldd	r18, Y+12	; 0x0c
     780:	3d 85       	ldd	r19, Y+13	; 0x0d
     782:	22 30       	cpi	r18, 0x02	; 2
     784:	31 05       	cpc	r19, r1
     786:	09 f4       	brne	.+2      	; 0x78a <DIO_SetPinDir+0x50>
     788:	62 c0       	rjmp	.+196    	; 0x84e <DIO_SetPinDir+0x114>
     78a:	8c 85       	ldd	r24, Y+12	; 0x0c
     78c:	9d 85       	ldd	r25, Y+13	; 0x0d
     78e:	83 30       	cpi	r24, 0x03	; 3
     790:	91 05       	cpc	r25, r1
     792:	09 f4       	brne	.+2      	; 0x796 <DIO_SetPinDir+0x5c>
     794:	89 c0       	rjmp	.+274    	; 0x8a8 <__stack+0x49>
     796:	b5 c0       	rjmp	.+362    	; 0x902 <__stack+0xa3>
	{
		case DIO_PORTA:
		(dir == OUTPUT)? (SET_BIT(DDRA,pin)):(CLR_BIT(DDRA,pin));
     798:	8b 81       	ldd	r24, Y+3	; 0x03
     79a:	83 30       	cpi	r24, 0x03	; 3
     79c:	a9 f4       	brne	.+42     	; 0x7c8 <DIO_SetPinDir+0x8e>
     79e:	aa e3       	ldi	r26, 0x3A	; 58
     7a0:	b0 e0       	ldi	r27, 0x00	; 0
     7a2:	ea e3       	ldi	r30, 0x3A	; 58
     7a4:	f0 e0       	ldi	r31, 0x00	; 0
     7a6:	80 81       	ld	r24, Z
     7a8:	48 2f       	mov	r20, r24
     7aa:	8a 81       	ldd	r24, Y+2	; 0x02
     7ac:	28 2f       	mov	r18, r24
     7ae:	30 e0       	ldi	r19, 0x00	; 0
     7b0:	81 e0       	ldi	r24, 0x01	; 1
     7b2:	90 e0       	ldi	r25, 0x00	; 0
     7b4:	02 2e       	mov	r0, r18
     7b6:	02 c0       	rjmp	.+4      	; 0x7bc <DIO_SetPinDir+0x82>
     7b8:	88 0f       	add	r24, r24
     7ba:	99 1f       	adc	r25, r25
     7bc:	0a 94       	dec	r0
     7be:	e2 f7       	brpl	.-8      	; 0x7b8 <DIO_SetPinDir+0x7e>
     7c0:	84 2b       	or	r24, r20
     7c2:	8c 93       	st	X, r24
     7c4:	9c 91       	ld	r25, X
     7c6:	9d c0       	rjmp	.+314    	; 0x902 <__stack+0xa3>
     7c8:	aa e3       	ldi	r26, 0x3A	; 58
     7ca:	b0 e0       	ldi	r27, 0x00	; 0
     7cc:	ea e3       	ldi	r30, 0x3A	; 58
     7ce:	f0 e0       	ldi	r31, 0x00	; 0
     7d0:	80 81       	ld	r24, Z
     7d2:	48 2f       	mov	r20, r24
     7d4:	8a 81       	ldd	r24, Y+2	; 0x02
     7d6:	28 2f       	mov	r18, r24
     7d8:	30 e0       	ldi	r19, 0x00	; 0
     7da:	81 e0       	ldi	r24, 0x01	; 1
     7dc:	90 e0       	ldi	r25, 0x00	; 0
     7de:	02 c0       	rjmp	.+4      	; 0x7e4 <DIO_SetPinDir+0xaa>
     7e0:	88 0f       	add	r24, r24
     7e2:	99 1f       	adc	r25, r25
     7e4:	2a 95       	dec	r18
     7e6:	e2 f7       	brpl	.-8      	; 0x7e0 <DIO_SetPinDir+0xa6>
     7e8:	80 95       	com	r24
     7ea:	84 23       	and	r24, r20
     7ec:	8c 93       	st	X, r24
     7ee:	2c 91       	ld	r18, X
     7f0:	88 c0       	rjmp	.+272    	; 0x902 <__stack+0xa3>
		break;

		case DIO_PORTB:
		(dir == OUTPUT)? (SET_BIT(DDRB,pin)):(CLR_BIT(DDRB,pin));
     7f2:	8b 81       	ldd	r24, Y+3	; 0x03
     7f4:	83 30       	cpi	r24, 0x03	; 3
     7f6:	a9 f4       	brne	.+42     	; 0x822 <DIO_SetPinDir+0xe8>
     7f8:	a7 e3       	ldi	r26, 0x37	; 55
     7fa:	b0 e0       	ldi	r27, 0x00	; 0
     7fc:	e7 e3       	ldi	r30, 0x37	; 55
     7fe:	f0 e0       	ldi	r31, 0x00	; 0
     800:	80 81       	ld	r24, Z
     802:	48 2f       	mov	r20, r24
     804:	8a 81       	ldd	r24, Y+2	; 0x02
     806:	28 2f       	mov	r18, r24
     808:	30 e0       	ldi	r19, 0x00	; 0
     80a:	81 e0       	ldi	r24, 0x01	; 1
     80c:	90 e0       	ldi	r25, 0x00	; 0
     80e:	02 2e       	mov	r0, r18
     810:	02 c0       	rjmp	.+4      	; 0x816 <DIO_SetPinDir+0xdc>
     812:	88 0f       	add	r24, r24
     814:	99 1f       	adc	r25, r25
     816:	0a 94       	dec	r0
     818:	e2 f7       	brpl	.-8      	; 0x812 <DIO_SetPinDir+0xd8>
     81a:	84 2b       	or	r24, r20
     81c:	8c 93       	st	X, r24
     81e:	3c 91       	ld	r19, X
     820:	70 c0       	rjmp	.+224    	; 0x902 <__stack+0xa3>
     822:	a7 e3       	ldi	r26, 0x37	; 55
     824:	b0 e0       	ldi	r27, 0x00	; 0
     826:	e7 e3       	ldi	r30, 0x37	; 55
     828:	f0 e0       	ldi	r31, 0x00	; 0
     82a:	80 81       	ld	r24, Z
     82c:	48 2f       	mov	r20, r24
     82e:	8a 81       	ldd	r24, Y+2	; 0x02
     830:	28 2f       	mov	r18, r24
     832:	30 e0       	ldi	r19, 0x00	; 0
     834:	81 e0       	ldi	r24, 0x01	; 1
     836:	90 e0       	ldi	r25, 0x00	; 0
     838:	02 2e       	mov	r0, r18
     83a:	02 c0       	rjmp	.+4      	; 0x840 <DIO_SetPinDir+0x106>
     83c:	88 0f       	add	r24, r24
     83e:	99 1f       	adc	r25, r25
     840:	0a 94       	dec	r0
     842:	e2 f7       	brpl	.-8      	; 0x83c <DIO_SetPinDir+0x102>
     844:	80 95       	com	r24
     846:	84 23       	and	r24, r20
     848:	8c 93       	st	X, r24
     84a:	8c 91       	ld	r24, X
     84c:	5a c0       	rjmp	.+180    	; 0x902 <__stack+0xa3>
		break;

		case DIO_PORTC:
		(dir == OUTPUT)? (SET_BIT(DDRC,pin)):(CLR_BIT(DDRC,pin));
     84e:	8b 81       	ldd	r24, Y+3	; 0x03
     850:	83 30       	cpi	r24, 0x03	; 3
     852:	a9 f4       	brne	.+42     	; 0x87e <__stack+0x1f>
     854:	a4 e3       	ldi	r26, 0x34	; 52
     856:	b0 e0       	ldi	r27, 0x00	; 0
     858:	e4 e3       	ldi	r30, 0x34	; 52
     85a:	f0 e0       	ldi	r31, 0x00	; 0
     85c:	80 81       	ld	r24, Z
     85e:	48 2f       	mov	r20, r24
     860:	8a 81       	ldd	r24, Y+2	; 0x02
     862:	28 2f       	mov	r18, r24
     864:	30 e0       	ldi	r19, 0x00	; 0
     866:	81 e0       	ldi	r24, 0x01	; 1
     868:	90 e0       	ldi	r25, 0x00	; 0
     86a:	02 2e       	mov	r0, r18
     86c:	02 c0       	rjmp	.+4      	; 0x872 <__stack+0x13>
     86e:	88 0f       	add	r24, r24
     870:	99 1f       	adc	r25, r25
     872:	0a 94       	dec	r0
     874:	e2 f7       	brpl	.-8      	; 0x86e <__stack+0xf>
     876:	84 2b       	or	r24, r20
     878:	8c 93       	st	X, r24
     87a:	9c 91       	ld	r25, X
     87c:	42 c0       	rjmp	.+132    	; 0x902 <__stack+0xa3>
     87e:	a4 e3       	ldi	r26, 0x34	; 52
     880:	b0 e0       	ldi	r27, 0x00	; 0
     882:	e4 e3       	ldi	r30, 0x34	; 52
     884:	f0 e0       	ldi	r31, 0x00	; 0
     886:	80 81       	ld	r24, Z
     888:	48 2f       	mov	r20, r24
     88a:	8a 81       	ldd	r24, Y+2	; 0x02
     88c:	28 2f       	mov	r18, r24
     88e:	30 e0       	ldi	r19, 0x00	; 0
     890:	81 e0       	ldi	r24, 0x01	; 1
     892:	90 e0       	ldi	r25, 0x00	; 0
     894:	02 c0       	rjmp	.+4      	; 0x89a <__stack+0x3b>
     896:	88 0f       	add	r24, r24
     898:	99 1f       	adc	r25, r25
     89a:	2a 95       	dec	r18
     89c:	e2 f7       	brpl	.-8      	; 0x896 <__stack+0x37>
     89e:	80 95       	com	r24
     8a0:	84 23       	and	r24, r20
     8a2:	8c 93       	st	X, r24
     8a4:	2c 91       	ld	r18, X
     8a6:	2d c0       	rjmp	.+90     	; 0x902 <__stack+0xa3>
		break;

		case DIO_PORTD:
		(dir == OUTPUT)? (SET_BIT(DDRD,pin)):(CLR_BIT(DDRD,pin));
     8a8:	8b 81       	ldd	r24, Y+3	; 0x03
     8aa:	83 30       	cpi	r24, 0x03	; 3
     8ac:	a9 f4       	brne	.+42     	; 0x8d8 <__stack+0x79>
     8ae:	a1 e3       	ldi	r26, 0x31	; 49
     8b0:	b0 e0       	ldi	r27, 0x00	; 0
     8b2:	e1 e3       	ldi	r30, 0x31	; 49
     8b4:	f0 e0       	ldi	r31, 0x00	; 0
     8b6:	80 81       	ld	r24, Z
     8b8:	48 2f       	mov	r20, r24
     8ba:	8a 81       	ldd	r24, Y+2	; 0x02
     8bc:	28 2f       	mov	r18, r24
     8be:	30 e0       	ldi	r19, 0x00	; 0
     8c0:	81 e0       	ldi	r24, 0x01	; 1
     8c2:	90 e0       	ldi	r25, 0x00	; 0
     8c4:	02 2e       	mov	r0, r18
     8c6:	02 c0       	rjmp	.+4      	; 0x8cc <__stack+0x6d>
     8c8:	88 0f       	add	r24, r24
     8ca:	99 1f       	adc	r25, r25
     8cc:	0a 94       	dec	r0
     8ce:	e2 f7       	brpl	.-8      	; 0x8c8 <__stack+0x69>
     8d0:	84 2b       	or	r24, r20
     8d2:	8c 93       	st	X, r24
     8d4:	3c 91       	ld	r19, X
     8d6:	15 c0       	rjmp	.+42     	; 0x902 <__stack+0xa3>
     8d8:	a1 e3       	ldi	r26, 0x31	; 49
     8da:	b0 e0       	ldi	r27, 0x00	; 0
     8dc:	e1 e3       	ldi	r30, 0x31	; 49
     8de:	f0 e0       	ldi	r31, 0x00	; 0
     8e0:	80 81       	ld	r24, Z
     8e2:	48 2f       	mov	r20, r24
     8e4:	8a 81       	ldd	r24, Y+2	; 0x02
     8e6:	28 2f       	mov	r18, r24
     8e8:	30 e0       	ldi	r19, 0x00	; 0
     8ea:	81 e0       	ldi	r24, 0x01	; 1
     8ec:	90 e0       	ldi	r25, 0x00	; 0
     8ee:	02 2e       	mov	r0, r18
     8f0:	02 c0       	rjmp	.+4      	; 0x8f6 <__stack+0x97>
     8f2:	88 0f       	add	r24, r24
     8f4:	99 1f       	adc	r25, r25
     8f6:	0a 94       	dec	r0
     8f8:	e2 f7       	brpl	.-8      	; 0x8f2 <__stack+0x93>
     8fa:	80 95       	com	r24
     8fc:	84 23       	and	r24, r20
     8fe:	8c 93       	st	X, r24
     900:	8c 91       	ld	r24, X
		break;
	}
}
     902:	2d 96       	adiw	r28, 0x0d	; 13
     904:	0f b6       	in	r0, 0x3f	; 63
     906:	f8 94       	cli
     908:	de bf       	out	0x3e, r29	; 62
     90a:	0f be       	out	0x3f, r0	; 63
     90c:	cd bf       	out	0x3d, r28	; 61
     90e:	cf 91       	pop	r28
     910:	df 91       	pop	r29
     912:	08 95       	ret

00000914 <DIO_SetPinVal>:


void DIO_SetPinVal(uint8_t port ,uint8_t pin , uint8_t val)
{
     914:	df 93       	push	r29
     916:	cf 93       	push	r28
     918:	cd b7       	in	r28, 0x3d	; 61
     91a:	de b7       	in	r29, 0x3e	; 62
     91c:	2d 97       	sbiw	r28, 0x0d	; 13
     91e:	0f b6       	in	r0, 0x3f	; 63
     920:	f8 94       	cli
     922:	de bf       	out	0x3e, r29	; 62
     924:	0f be       	out	0x3f, r0	; 63
     926:	cd bf       	out	0x3d, r28	; 61
     928:	89 83       	std	Y+1, r24	; 0x01
     92a:	6a 83       	std	Y+2, r22	; 0x02
     92c:	4b 83       	std	Y+3, r20	; 0x03
	switch (port)
     92e:	89 81       	ldd	r24, Y+1	; 0x01
     930:	28 2f       	mov	r18, r24
     932:	30 e0       	ldi	r19, 0x00	; 0
     934:	3d 87       	std	Y+13, r19	; 0x0d
     936:	2c 87       	std	Y+12, r18	; 0x0c
     938:	8c 85       	ldd	r24, Y+12	; 0x0c
     93a:	9d 85       	ldd	r25, Y+13	; 0x0d
     93c:	81 30       	cpi	r24, 0x01	; 1
     93e:	91 05       	cpc	r25, r1
     940:	09 f4       	brne	.+2      	; 0x944 <DIO_SetPinVal+0x30>
     942:	44 c0       	rjmp	.+136    	; 0x9cc <DIO_SetPinVal+0xb8>
     944:	2c 85       	ldd	r18, Y+12	; 0x0c
     946:	3d 85       	ldd	r19, Y+13	; 0x0d
     948:	22 30       	cpi	r18, 0x02	; 2
     94a:	31 05       	cpc	r19, r1
     94c:	2c f4       	brge	.+10     	; 0x958 <DIO_SetPinVal+0x44>
     94e:	8c 85       	ldd	r24, Y+12	; 0x0c
     950:	9d 85       	ldd	r25, Y+13	; 0x0d
     952:	00 97       	sbiw	r24, 0x00	; 0
     954:	71 f0       	breq	.+28     	; 0x972 <DIO_SetPinVal+0x5e>
     956:	c2 c0       	rjmp	.+388    	; 0xadc <DIO_SetPinVal+0x1c8>
     958:	2c 85       	ldd	r18, Y+12	; 0x0c
     95a:	3d 85       	ldd	r19, Y+13	; 0x0d
     95c:	22 30       	cpi	r18, 0x02	; 2
     95e:	31 05       	cpc	r19, r1
     960:	09 f4       	brne	.+2      	; 0x964 <DIO_SetPinVal+0x50>
     962:	62 c0       	rjmp	.+196    	; 0xa28 <DIO_SetPinVal+0x114>
     964:	8c 85       	ldd	r24, Y+12	; 0x0c
     966:	9d 85       	ldd	r25, Y+13	; 0x0d
     968:	83 30       	cpi	r24, 0x03	; 3
     96a:	91 05       	cpc	r25, r1
     96c:	09 f4       	brne	.+2      	; 0x970 <DIO_SetPinVal+0x5c>
     96e:	89 c0       	rjmp	.+274    	; 0xa82 <DIO_SetPinVal+0x16e>
     970:	b5 c0       	rjmp	.+362    	; 0xadc <DIO_SetPinVal+0x1c8>
	{
		case DIO_PORTA:
		(val == HIGH)? (SET_BIT(PORTA,pin)):(CLR_BIT(PORTA,pin));
     972:	8b 81       	ldd	r24, Y+3	; 0x03
     974:	81 30       	cpi	r24, 0x01	; 1
     976:	a9 f4       	brne	.+42     	; 0x9a2 <DIO_SetPinVal+0x8e>
     978:	ab e3       	ldi	r26, 0x3B	; 59
     97a:	b0 e0       	ldi	r27, 0x00	; 0
     97c:	eb e3       	ldi	r30, 0x3B	; 59
     97e:	f0 e0       	ldi	r31, 0x00	; 0
     980:	80 81       	ld	r24, Z
     982:	48 2f       	mov	r20, r24
     984:	8a 81       	ldd	r24, Y+2	; 0x02
     986:	28 2f       	mov	r18, r24
     988:	30 e0       	ldi	r19, 0x00	; 0
     98a:	81 e0       	ldi	r24, 0x01	; 1
     98c:	90 e0       	ldi	r25, 0x00	; 0
     98e:	02 2e       	mov	r0, r18
     990:	02 c0       	rjmp	.+4      	; 0x996 <DIO_SetPinVal+0x82>
     992:	88 0f       	add	r24, r24
     994:	99 1f       	adc	r25, r25
     996:	0a 94       	dec	r0
     998:	e2 f7       	brpl	.-8      	; 0x992 <DIO_SetPinVal+0x7e>
     99a:	84 2b       	or	r24, r20
     99c:	8c 93       	st	X, r24
     99e:	9c 91       	ld	r25, X
     9a0:	9d c0       	rjmp	.+314    	; 0xadc <DIO_SetPinVal+0x1c8>
     9a2:	ab e3       	ldi	r26, 0x3B	; 59
     9a4:	b0 e0       	ldi	r27, 0x00	; 0
     9a6:	eb e3       	ldi	r30, 0x3B	; 59
     9a8:	f0 e0       	ldi	r31, 0x00	; 0
     9aa:	80 81       	ld	r24, Z
     9ac:	48 2f       	mov	r20, r24
     9ae:	8a 81       	ldd	r24, Y+2	; 0x02
     9b0:	28 2f       	mov	r18, r24
     9b2:	30 e0       	ldi	r19, 0x00	; 0
     9b4:	81 e0       	ldi	r24, 0x01	; 1
     9b6:	90 e0       	ldi	r25, 0x00	; 0
     9b8:	02 c0       	rjmp	.+4      	; 0x9be <DIO_SetPinVal+0xaa>
     9ba:	88 0f       	add	r24, r24
     9bc:	99 1f       	adc	r25, r25
     9be:	2a 95       	dec	r18
     9c0:	e2 f7       	brpl	.-8      	; 0x9ba <DIO_SetPinVal+0xa6>
     9c2:	80 95       	com	r24
     9c4:	84 23       	and	r24, r20
     9c6:	8c 93       	st	X, r24
     9c8:	2c 91       	ld	r18, X
     9ca:	88 c0       	rjmp	.+272    	; 0xadc <DIO_SetPinVal+0x1c8>
		break;

		case DIO_PORTB:
		(val == HIGH)? (SET_BIT(PORTB,pin)):(CLR_BIT(PORTB,pin));
     9cc:	8b 81       	ldd	r24, Y+3	; 0x03
     9ce:	81 30       	cpi	r24, 0x01	; 1
     9d0:	a9 f4       	brne	.+42     	; 0x9fc <DIO_SetPinVal+0xe8>
     9d2:	a8 e3       	ldi	r26, 0x38	; 56
     9d4:	b0 e0       	ldi	r27, 0x00	; 0
     9d6:	e8 e3       	ldi	r30, 0x38	; 56
     9d8:	f0 e0       	ldi	r31, 0x00	; 0
     9da:	80 81       	ld	r24, Z
     9dc:	48 2f       	mov	r20, r24
     9de:	8a 81       	ldd	r24, Y+2	; 0x02
     9e0:	28 2f       	mov	r18, r24
     9e2:	30 e0       	ldi	r19, 0x00	; 0
     9e4:	81 e0       	ldi	r24, 0x01	; 1
     9e6:	90 e0       	ldi	r25, 0x00	; 0
     9e8:	02 2e       	mov	r0, r18
     9ea:	02 c0       	rjmp	.+4      	; 0x9f0 <DIO_SetPinVal+0xdc>
     9ec:	88 0f       	add	r24, r24
     9ee:	99 1f       	adc	r25, r25
     9f0:	0a 94       	dec	r0
     9f2:	e2 f7       	brpl	.-8      	; 0x9ec <DIO_SetPinVal+0xd8>
     9f4:	84 2b       	or	r24, r20
     9f6:	8c 93       	st	X, r24
     9f8:	3c 91       	ld	r19, X
     9fa:	70 c0       	rjmp	.+224    	; 0xadc <DIO_SetPinVal+0x1c8>
     9fc:	a8 e3       	ldi	r26, 0x38	; 56
     9fe:	b0 e0       	ldi	r27, 0x00	; 0
     a00:	e8 e3       	ldi	r30, 0x38	; 56
     a02:	f0 e0       	ldi	r31, 0x00	; 0
     a04:	80 81       	ld	r24, Z
     a06:	48 2f       	mov	r20, r24
     a08:	8a 81       	ldd	r24, Y+2	; 0x02
     a0a:	28 2f       	mov	r18, r24
     a0c:	30 e0       	ldi	r19, 0x00	; 0
     a0e:	81 e0       	ldi	r24, 0x01	; 1
     a10:	90 e0       	ldi	r25, 0x00	; 0
     a12:	02 2e       	mov	r0, r18
     a14:	02 c0       	rjmp	.+4      	; 0xa1a <DIO_SetPinVal+0x106>
     a16:	88 0f       	add	r24, r24
     a18:	99 1f       	adc	r25, r25
     a1a:	0a 94       	dec	r0
     a1c:	e2 f7       	brpl	.-8      	; 0xa16 <DIO_SetPinVal+0x102>
     a1e:	80 95       	com	r24
     a20:	84 23       	and	r24, r20
     a22:	8c 93       	st	X, r24
     a24:	8c 91       	ld	r24, X
     a26:	5a c0       	rjmp	.+180    	; 0xadc <DIO_SetPinVal+0x1c8>
		break;

		case DIO_PORTC:
		(val == HIGH)? (SET_BIT(PORTC,pin)):(CLR_BIT(PORTC,pin));
     a28:	8b 81       	ldd	r24, Y+3	; 0x03
     a2a:	81 30       	cpi	r24, 0x01	; 1
     a2c:	a9 f4       	brne	.+42     	; 0xa58 <DIO_SetPinVal+0x144>
     a2e:	a5 e3       	ldi	r26, 0x35	; 53
     a30:	b0 e0       	ldi	r27, 0x00	; 0
     a32:	e5 e3       	ldi	r30, 0x35	; 53
     a34:	f0 e0       	ldi	r31, 0x00	; 0
     a36:	80 81       	ld	r24, Z
     a38:	48 2f       	mov	r20, r24
     a3a:	8a 81       	ldd	r24, Y+2	; 0x02
     a3c:	28 2f       	mov	r18, r24
     a3e:	30 e0       	ldi	r19, 0x00	; 0
     a40:	81 e0       	ldi	r24, 0x01	; 1
     a42:	90 e0       	ldi	r25, 0x00	; 0
     a44:	02 2e       	mov	r0, r18
     a46:	02 c0       	rjmp	.+4      	; 0xa4c <DIO_SetPinVal+0x138>
     a48:	88 0f       	add	r24, r24
     a4a:	99 1f       	adc	r25, r25
     a4c:	0a 94       	dec	r0
     a4e:	e2 f7       	brpl	.-8      	; 0xa48 <DIO_SetPinVal+0x134>
     a50:	84 2b       	or	r24, r20
     a52:	8c 93       	st	X, r24
     a54:	9c 91       	ld	r25, X
     a56:	42 c0       	rjmp	.+132    	; 0xadc <DIO_SetPinVal+0x1c8>
     a58:	a5 e3       	ldi	r26, 0x35	; 53
     a5a:	b0 e0       	ldi	r27, 0x00	; 0
     a5c:	e5 e3       	ldi	r30, 0x35	; 53
     a5e:	f0 e0       	ldi	r31, 0x00	; 0
     a60:	80 81       	ld	r24, Z
     a62:	48 2f       	mov	r20, r24
     a64:	8a 81       	ldd	r24, Y+2	; 0x02
     a66:	28 2f       	mov	r18, r24
     a68:	30 e0       	ldi	r19, 0x00	; 0
     a6a:	81 e0       	ldi	r24, 0x01	; 1
     a6c:	90 e0       	ldi	r25, 0x00	; 0
     a6e:	02 c0       	rjmp	.+4      	; 0xa74 <DIO_SetPinVal+0x160>
     a70:	88 0f       	add	r24, r24
     a72:	99 1f       	adc	r25, r25
     a74:	2a 95       	dec	r18
     a76:	e2 f7       	brpl	.-8      	; 0xa70 <DIO_SetPinVal+0x15c>
     a78:	80 95       	com	r24
     a7a:	84 23       	and	r24, r20
     a7c:	8c 93       	st	X, r24
     a7e:	2c 91       	ld	r18, X
     a80:	2d c0       	rjmp	.+90     	; 0xadc <DIO_SetPinVal+0x1c8>
		break;

		case DIO_PORTD:
		(val == HIGH)? (SET_BIT(PORTD,pin)):(CLR_BIT(PORTD,pin));
     a82:	8b 81       	ldd	r24, Y+3	; 0x03
     a84:	81 30       	cpi	r24, 0x01	; 1
     a86:	a9 f4       	brne	.+42     	; 0xab2 <DIO_SetPinVal+0x19e>
     a88:	a2 e3       	ldi	r26, 0x32	; 50
     a8a:	b0 e0       	ldi	r27, 0x00	; 0
     a8c:	e2 e3       	ldi	r30, 0x32	; 50
     a8e:	f0 e0       	ldi	r31, 0x00	; 0
     a90:	80 81       	ld	r24, Z
     a92:	48 2f       	mov	r20, r24
     a94:	8a 81       	ldd	r24, Y+2	; 0x02
     a96:	28 2f       	mov	r18, r24
     a98:	30 e0       	ldi	r19, 0x00	; 0
     a9a:	81 e0       	ldi	r24, 0x01	; 1
     a9c:	90 e0       	ldi	r25, 0x00	; 0
     a9e:	02 2e       	mov	r0, r18
     aa0:	02 c0       	rjmp	.+4      	; 0xaa6 <DIO_SetPinVal+0x192>
     aa2:	88 0f       	add	r24, r24
     aa4:	99 1f       	adc	r25, r25
     aa6:	0a 94       	dec	r0
     aa8:	e2 f7       	brpl	.-8      	; 0xaa2 <DIO_SetPinVal+0x18e>
     aaa:	84 2b       	or	r24, r20
     aac:	8c 93       	st	X, r24
     aae:	3c 91       	ld	r19, X
     ab0:	15 c0       	rjmp	.+42     	; 0xadc <DIO_SetPinVal+0x1c8>
     ab2:	a2 e3       	ldi	r26, 0x32	; 50
     ab4:	b0 e0       	ldi	r27, 0x00	; 0
     ab6:	e2 e3       	ldi	r30, 0x32	; 50
     ab8:	f0 e0       	ldi	r31, 0x00	; 0
     aba:	80 81       	ld	r24, Z
     abc:	48 2f       	mov	r20, r24
     abe:	8a 81       	ldd	r24, Y+2	; 0x02
     ac0:	28 2f       	mov	r18, r24
     ac2:	30 e0       	ldi	r19, 0x00	; 0
     ac4:	81 e0       	ldi	r24, 0x01	; 1
     ac6:	90 e0       	ldi	r25, 0x00	; 0
     ac8:	02 2e       	mov	r0, r18
     aca:	02 c0       	rjmp	.+4      	; 0xad0 <DIO_SetPinVal+0x1bc>
     acc:	88 0f       	add	r24, r24
     ace:	99 1f       	adc	r25, r25
     ad0:	0a 94       	dec	r0
     ad2:	e2 f7       	brpl	.-8      	; 0xacc <DIO_SetPinVal+0x1b8>
     ad4:	80 95       	com	r24
     ad6:	84 23       	and	r24, r20
     ad8:	8c 93       	st	X, r24
     ada:	8c 91       	ld	r24, X
		break;
	}
}
     adc:	2d 96       	adiw	r28, 0x0d	; 13
     ade:	0f b6       	in	r0, 0x3f	; 63
     ae0:	f8 94       	cli
     ae2:	de bf       	out	0x3e, r29	; 62
     ae4:	0f be       	out	0x3f, r0	; 63
     ae6:	cd bf       	out	0x3d, r28	; 61
     ae8:	cf 91       	pop	r28
     aea:	df 91       	pop	r29
     aec:	08 95       	ret

00000aee <DIO_GetPinVal>:


uint8_t  DIO_GetPinVal(uint8_t port ,uint8_t pin)
{
     aee:	df 93       	push	r29
     af0:	cf 93       	push	r28
     af2:	00 d0       	rcall	.+0      	; 0xaf4 <DIO_GetPinVal+0x6>
     af4:	00 d0       	rcall	.+0      	; 0xaf6 <DIO_GetPinVal+0x8>
     af6:	00 d0       	rcall	.+0      	; 0xaf8 <DIO_GetPinVal+0xa>
     af8:	cd b7       	in	r28, 0x3d	; 61
     afa:	de b7       	in	r29, 0x3e	; 62
     afc:	89 83       	std	Y+1, r24	; 0x01
     afe:	6a 83       	std	Y+2, r22	; 0x02
	switch(port)
     b00:	89 81       	ldd	r24, Y+1	; 0x01
     b02:	28 2f       	mov	r18, r24
     b04:	30 e0       	ldi	r19, 0x00	; 0
     b06:	3d 83       	std	Y+5, r19	; 0x05
     b08:	2c 83       	std	Y+4, r18	; 0x04
     b0a:	4c 81       	ldd	r20, Y+4	; 0x04
     b0c:	5d 81       	ldd	r21, Y+5	; 0x05
     b0e:	41 30       	cpi	r20, 0x01	; 1
     b10:	51 05       	cpc	r21, r1
     b12:	49 f1       	breq	.+82     	; 0xb66 <DIO_GetPinVal+0x78>
     b14:	8c 81       	ldd	r24, Y+4	; 0x04
     b16:	9d 81       	ldd	r25, Y+5	; 0x05
     b18:	82 30       	cpi	r24, 0x02	; 2
     b1a:	91 05       	cpc	r25, r1
     b1c:	34 f4       	brge	.+12     	; 0xb2a <DIO_GetPinVal+0x3c>
     b1e:	2c 81       	ldd	r18, Y+4	; 0x04
     b20:	3d 81       	ldd	r19, Y+5	; 0x05
     b22:	21 15       	cp	r18, r1
     b24:	31 05       	cpc	r19, r1
     b26:	61 f0       	breq	.+24     	; 0xb40 <DIO_GetPinVal+0x52>
     b28:	57 c0       	rjmp	.+174    	; 0xbd8 <DIO_GetPinVal+0xea>
     b2a:	4c 81       	ldd	r20, Y+4	; 0x04
     b2c:	5d 81       	ldd	r21, Y+5	; 0x05
     b2e:	42 30       	cpi	r20, 0x02	; 2
     b30:	51 05       	cpc	r21, r1
     b32:	61 f1       	breq	.+88     	; 0xb8c <DIO_GetPinVal+0x9e>
     b34:	8c 81       	ldd	r24, Y+4	; 0x04
     b36:	9d 81       	ldd	r25, Y+5	; 0x05
     b38:	83 30       	cpi	r24, 0x03	; 3
     b3a:	91 05       	cpc	r25, r1
     b3c:	d1 f1       	breq	.+116    	; 0xbb2 <DIO_GetPinVal+0xc4>
     b3e:	4c c0       	rjmp	.+152    	; 0xbd8 <DIO_GetPinVal+0xea>
	{
		case  DIO_PORTA :
			return GET_BIT(PINA,pin);
     b40:	e9 e3       	ldi	r30, 0x39	; 57
     b42:	f0 e0       	ldi	r31, 0x00	; 0
     b44:	80 81       	ld	r24, Z
     b46:	28 2f       	mov	r18, r24
     b48:	30 e0       	ldi	r19, 0x00	; 0
     b4a:	8a 81       	ldd	r24, Y+2	; 0x02
     b4c:	88 2f       	mov	r24, r24
     b4e:	90 e0       	ldi	r25, 0x00	; 0
     b50:	a9 01       	movw	r20, r18
     b52:	02 c0       	rjmp	.+4      	; 0xb58 <DIO_GetPinVal+0x6a>
     b54:	55 95       	asr	r21
     b56:	47 95       	ror	r20
     b58:	8a 95       	dec	r24
     b5a:	e2 f7       	brpl	.-8      	; 0xb54 <DIO_GetPinVal+0x66>
     b5c:	ca 01       	movw	r24, r20
     b5e:	58 2f       	mov	r21, r24
     b60:	51 70       	andi	r21, 0x01	; 1
     b62:	5b 83       	std	Y+3, r21	; 0x03
     b64:	3a c0       	rjmp	.+116    	; 0xbda <DIO_GetPinVal+0xec>
			break;
		case  DIO_PORTB :
			return GET_BIT(PINB,pin);
     b66:	e6 e3       	ldi	r30, 0x36	; 54
     b68:	f0 e0       	ldi	r31, 0x00	; 0
     b6a:	80 81       	ld	r24, Z
     b6c:	28 2f       	mov	r18, r24
     b6e:	30 e0       	ldi	r19, 0x00	; 0
     b70:	8a 81       	ldd	r24, Y+2	; 0x02
     b72:	88 2f       	mov	r24, r24
     b74:	90 e0       	ldi	r25, 0x00	; 0
     b76:	a9 01       	movw	r20, r18
     b78:	02 c0       	rjmp	.+4      	; 0xb7e <DIO_GetPinVal+0x90>
     b7a:	55 95       	asr	r21
     b7c:	47 95       	ror	r20
     b7e:	8a 95       	dec	r24
     b80:	e2 f7       	brpl	.-8      	; 0xb7a <DIO_GetPinVal+0x8c>
     b82:	ca 01       	movw	r24, r20
     b84:	58 2f       	mov	r21, r24
     b86:	51 70       	andi	r21, 0x01	; 1
     b88:	5b 83       	std	Y+3, r21	; 0x03
     b8a:	27 c0       	rjmp	.+78     	; 0xbda <DIO_GetPinVal+0xec>
			break;
		case  DIO_PORTC :
			return GET_BIT(PINC,pin);
     b8c:	e3 e3       	ldi	r30, 0x33	; 51
     b8e:	f0 e0       	ldi	r31, 0x00	; 0
     b90:	80 81       	ld	r24, Z
     b92:	28 2f       	mov	r18, r24
     b94:	30 e0       	ldi	r19, 0x00	; 0
     b96:	8a 81       	ldd	r24, Y+2	; 0x02
     b98:	88 2f       	mov	r24, r24
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	a9 01       	movw	r20, r18
     b9e:	02 c0       	rjmp	.+4      	; 0xba4 <DIO_GetPinVal+0xb6>
     ba0:	55 95       	asr	r21
     ba2:	47 95       	ror	r20
     ba4:	8a 95       	dec	r24
     ba6:	e2 f7       	brpl	.-8      	; 0xba0 <DIO_GetPinVal+0xb2>
     ba8:	ca 01       	movw	r24, r20
     baa:	58 2f       	mov	r21, r24
     bac:	51 70       	andi	r21, 0x01	; 1
     bae:	5b 83       	std	Y+3, r21	; 0x03
     bb0:	14 c0       	rjmp	.+40     	; 0xbda <DIO_GetPinVal+0xec>
			break;
		case  DIO_PORTD :
			return GET_BIT(PIND,pin);
     bb2:	e0 e3       	ldi	r30, 0x30	; 48
     bb4:	f0 e0       	ldi	r31, 0x00	; 0
     bb6:	80 81       	ld	r24, Z
     bb8:	28 2f       	mov	r18, r24
     bba:	30 e0       	ldi	r19, 0x00	; 0
     bbc:	8a 81       	ldd	r24, Y+2	; 0x02
     bbe:	88 2f       	mov	r24, r24
     bc0:	90 e0       	ldi	r25, 0x00	; 0
     bc2:	a9 01       	movw	r20, r18
     bc4:	02 c0       	rjmp	.+4      	; 0xbca <DIO_GetPinVal+0xdc>
     bc6:	55 95       	asr	r21
     bc8:	47 95       	ror	r20
     bca:	8a 95       	dec	r24
     bcc:	e2 f7       	brpl	.-8      	; 0xbc6 <DIO_GetPinVal+0xd8>
     bce:	ca 01       	movw	r24, r20
     bd0:	58 2f       	mov	r21, r24
     bd2:	51 70       	andi	r21, 0x01	; 1
     bd4:	5b 83       	std	Y+3, r21	; 0x03
     bd6:	01 c0       	rjmp	.+2      	; 0xbda <DIO_GetPinVal+0xec>
     bd8:	02 c0       	rjmp	.+4      	; 0xbde <DIO_GetPinVal+0xf0>
			break;
	}
}
     bda:	8b 81       	ldd	r24, Y+3	; 0x03
     bdc:	8e 83       	std	Y+6, r24	; 0x06
     bde:	8e 81       	ldd	r24, Y+6	; 0x06
     be0:	26 96       	adiw	r28, 0x06	; 6
     be2:	0f b6       	in	r0, 0x3f	; 63
     be4:	f8 94       	cli
     be6:	de bf       	out	0x3e, r29	; 62
     be8:	0f be       	out	0x3f, r0	; 63
     bea:	cd bf       	out	0x3d, r28	; 61
     bec:	cf 91       	pop	r28
     bee:	df 91       	pop	r29
     bf0:	08 95       	ret

00000bf2 <DIO_TogPinVal>:


void  DIO_TogPinVal(uint8_t port ,uint8_t pin)
{
     bf2:	df 93       	push	r29
     bf4:	cf 93       	push	r28
     bf6:	00 d0       	rcall	.+0      	; 0xbf8 <DIO_TogPinVal+0x6>
     bf8:	00 d0       	rcall	.+0      	; 0xbfa <DIO_TogPinVal+0x8>
     bfa:	cd b7       	in	r28, 0x3d	; 61
     bfc:	de b7       	in	r29, 0x3e	; 62
     bfe:	89 83       	std	Y+1, r24	; 0x01
     c00:	6a 83       	std	Y+2, r22	; 0x02
	switch(port)
     c02:	89 81       	ldd	r24, Y+1	; 0x01
     c04:	28 2f       	mov	r18, r24
     c06:	30 e0       	ldi	r19, 0x00	; 0
     c08:	3c 83       	std	Y+4, r19	; 0x04
     c0a:	2b 83       	std	Y+3, r18	; 0x03
     c0c:	8b 81       	ldd	r24, Y+3	; 0x03
     c0e:	9c 81       	ldd	r25, Y+4	; 0x04
     c10:	81 30       	cpi	r24, 0x01	; 1
     c12:	91 05       	cpc	r25, r1
     c14:	49 f1       	breq	.+82     	; 0xc68 <DIO_TogPinVal+0x76>
     c16:	2b 81       	ldd	r18, Y+3	; 0x03
     c18:	3c 81       	ldd	r19, Y+4	; 0x04
     c1a:	22 30       	cpi	r18, 0x02	; 2
     c1c:	31 05       	cpc	r19, r1
     c1e:	2c f4       	brge	.+10     	; 0xc2a <DIO_TogPinVal+0x38>
     c20:	8b 81       	ldd	r24, Y+3	; 0x03
     c22:	9c 81       	ldd	r25, Y+4	; 0x04
     c24:	00 97       	sbiw	r24, 0x00	; 0
     c26:	61 f0       	breq	.+24     	; 0xc40 <DIO_TogPinVal+0x4e>
     c28:	5a c0       	rjmp	.+180    	; 0xcde <DIO_TogPinVal+0xec>
     c2a:	2b 81       	ldd	r18, Y+3	; 0x03
     c2c:	3c 81       	ldd	r19, Y+4	; 0x04
     c2e:	22 30       	cpi	r18, 0x02	; 2
     c30:	31 05       	cpc	r19, r1
     c32:	71 f1       	breq	.+92     	; 0xc90 <DIO_TogPinVal+0x9e>
     c34:	8b 81       	ldd	r24, Y+3	; 0x03
     c36:	9c 81       	ldd	r25, Y+4	; 0x04
     c38:	83 30       	cpi	r24, 0x03	; 3
     c3a:	91 05       	cpc	r25, r1
     c3c:	e9 f1       	breq	.+122    	; 0xcb8 <DIO_TogPinVal+0xc6>
     c3e:	4f c0       	rjmp	.+158    	; 0xcde <DIO_TogPinVal+0xec>
	{
		case  DIO_PORTA :	TOG_BIT(PORTA,pin);
     c40:	ab e3       	ldi	r26, 0x3B	; 59
     c42:	b0 e0       	ldi	r27, 0x00	; 0
     c44:	eb e3       	ldi	r30, 0x3B	; 59
     c46:	f0 e0       	ldi	r31, 0x00	; 0
     c48:	80 81       	ld	r24, Z
     c4a:	48 2f       	mov	r20, r24
     c4c:	8a 81       	ldd	r24, Y+2	; 0x02
     c4e:	28 2f       	mov	r18, r24
     c50:	30 e0       	ldi	r19, 0x00	; 0
     c52:	81 e0       	ldi	r24, 0x01	; 1
     c54:	90 e0       	ldi	r25, 0x00	; 0
     c56:	02 2e       	mov	r0, r18
     c58:	02 c0       	rjmp	.+4      	; 0xc5e <DIO_TogPinVal+0x6c>
     c5a:	88 0f       	add	r24, r24
     c5c:	99 1f       	adc	r25, r25
     c5e:	0a 94       	dec	r0
     c60:	e2 f7       	brpl	.-8      	; 0xc5a <DIO_TogPinVal+0x68>
     c62:	84 27       	eor	r24, r20
     c64:	8c 93       	st	X, r24
     c66:	3b c0       	rjmp	.+118    	; 0xcde <DIO_TogPinVal+0xec>
		break;
		case  DIO_PORTB :   TOG_BIT(PORTB,pin);
     c68:	a8 e3       	ldi	r26, 0x38	; 56
     c6a:	b0 e0       	ldi	r27, 0x00	; 0
     c6c:	e8 e3       	ldi	r30, 0x38	; 56
     c6e:	f0 e0       	ldi	r31, 0x00	; 0
     c70:	80 81       	ld	r24, Z
     c72:	48 2f       	mov	r20, r24
     c74:	8a 81       	ldd	r24, Y+2	; 0x02
     c76:	28 2f       	mov	r18, r24
     c78:	30 e0       	ldi	r19, 0x00	; 0
     c7a:	81 e0       	ldi	r24, 0x01	; 1
     c7c:	90 e0       	ldi	r25, 0x00	; 0
     c7e:	02 2e       	mov	r0, r18
     c80:	02 c0       	rjmp	.+4      	; 0xc86 <DIO_TogPinVal+0x94>
     c82:	88 0f       	add	r24, r24
     c84:	99 1f       	adc	r25, r25
     c86:	0a 94       	dec	r0
     c88:	e2 f7       	brpl	.-8      	; 0xc82 <DIO_TogPinVal+0x90>
     c8a:	84 27       	eor	r24, r20
     c8c:	8c 93       	st	X, r24
     c8e:	27 c0       	rjmp	.+78     	; 0xcde <DIO_TogPinVal+0xec>
		break;
		case  DIO_PORTC :   TOG_BIT(PORTC,pin);
     c90:	a5 e3       	ldi	r26, 0x35	; 53
     c92:	b0 e0       	ldi	r27, 0x00	; 0
     c94:	e5 e3       	ldi	r30, 0x35	; 53
     c96:	f0 e0       	ldi	r31, 0x00	; 0
     c98:	80 81       	ld	r24, Z
     c9a:	48 2f       	mov	r20, r24
     c9c:	8a 81       	ldd	r24, Y+2	; 0x02
     c9e:	28 2f       	mov	r18, r24
     ca0:	30 e0       	ldi	r19, 0x00	; 0
     ca2:	81 e0       	ldi	r24, 0x01	; 1
     ca4:	90 e0       	ldi	r25, 0x00	; 0
     ca6:	02 2e       	mov	r0, r18
     ca8:	02 c0       	rjmp	.+4      	; 0xcae <DIO_TogPinVal+0xbc>
     caa:	88 0f       	add	r24, r24
     cac:	99 1f       	adc	r25, r25
     cae:	0a 94       	dec	r0
     cb0:	e2 f7       	brpl	.-8      	; 0xcaa <DIO_TogPinVal+0xb8>
     cb2:	84 27       	eor	r24, r20
     cb4:	8c 93       	st	X, r24
     cb6:	13 c0       	rjmp	.+38     	; 0xcde <DIO_TogPinVal+0xec>
		break;
		case  DIO_PORTD :   TOG_BIT(PORTD,pin);
     cb8:	a2 e3       	ldi	r26, 0x32	; 50
     cba:	b0 e0       	ldi	r27, 0x00	; 0
     cbc:	e2 e3       	ldi	r30, 0x32	; 50
     cbe:	f0 e0       	ldi	r31, 0x00	; 0
     cc0:	80 81       	ld	r24, Z
     cc2:	48 2f       	mov	r20, r24
     cc4:	8a 81       	ldd	r24, Y+2	; 0x02
     cc6:	28 2f       	mov	r18, r24
     cc8:	30 e0       	ldi	r19, 0x00	; 0
     cca:	81 e0       	ldi	r24, 0x01	; 1
     ccc:	90 e0       	ldi	r25, 0x00	; 0
     cce:	02 2e       	mov	r0, r18
     cd0:	02 c0       	rjmp	.+4      	; 0xcd6 <DIO_TogPinVal+0xe4>
     cd2:	88 0f       	add	r24, r24
     cd4:	99 1f       	adc	r25, r25
     cd6:	0a 94       	dec	r0
     cd8:	e2 f7       	brpl	.-8      	; 0xcd2 <DIO_TogPinVal+0xe0>
     cda:	84 27       	eor	r24, r20
     cdc:	8c 93       	st	X, r24
		break;
	}
}
     cde:	0f 90       	pop	r0
     ce0:	0f 90       	pop	r0
     ce2:	0f 90       	pop	r0
     ce4:	0f 90       	pop	r0
     ce6:	cf 91       	pop	r28
     ce8:	df 91       	pop	r29
     cea:	08 95       	ret

00000cec <GIE>:


#include "INT.h"

void GIE()
{
     cec:	df 93       	push	r29
     cee:	cf 93       	push	r28
     cf0:	cd b7       	in	r28, 0x3d	; 61
     cf2:	de b7       	in	r29, 0x3e	; 62
    SET_BIT(SREG,I_BIT);
     cf4:	af e5       	ldi	r26, 0x5F	; 95
     cf6:	b0 e0       	ldi	r27, 0x00	; 0
     cf8:	ef e5       	ldi	r30, 0x5F	; 95
     cfa:	f0 e0       	ldi	r31, 0x00	; 0
     cfc:	80 81       	ld	r24, Z
     cfe:	80 68       	ori	r24, 0x80	; 128
     d00:	8c 93       	st	X, r24
}
     d02:	cf 91       	pop	r28
     d04:	df 91       	pop	r29
     d06:	08 95       	ret

00000d08 <GID>:
void GID()
{
     d08:	df 93       	push	r29
     d0a:	cf 93       	push	r28
     d0c:	cd b7       	in	r28, 0x3d	; 61
     d0e:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG,I_BIT);
     d10:	af e5       	ldi	r26, 0x5F	; 95
     d12:	b0 e0       	ldi	r27, 0x00	; 0
     d14:	ef e5       	ldi	r30, 0x5F	; 95
     d16:	f0 e0       	ldi	r31, 0x00	; 0
     d18:	80 81       	ld	r24, Z
     d1a:	8f 77       	andi	r24, 0x7F	; 127
     d1c:	8c 93       	st	X, r24
}
     d1e:	cf 91       	pop	r28
     d20:	df 91       	pop	r29
     d22:	08 95       	ret

00000d24 <Timer0_INIT>:


#include "TIMER.h"

void Timer0_INIT()
{
     d24:	df 93       	push	r29
     d26:	cf 93       	push	r28
     d28:	cd b7       	in	r28, 0x3d	; 61
     d2a:	de b7       	in	r29, 0x3e	; 62
	GIE();
     d2c:	0e 94 76 06 	call	0xcec	; 0xcec <GIE>
	SET_BIT(TCCR0,WGM00);
	CLR_BIT(TCCR0,WGM01);
	SET_BIT(DDRB,3);//set OC0 as OUTPUT PIN

	#elif (TIMER0_MODE == CTC_MODE)
	SET_BIT(TIMSK,OCIE0);
     d30:	a9 e5       	ldi	r26, 0x59	; 89
     d32:	b0 e0       	ldi	r27, 0x00	; 0
     d34:	e9 e5       	ldi	r30, 0x59	; 89
     d36:	f0 e0       	ldi	r31, 0x00	; 0
     d38:	80 81       	ld	r24, Z
     d3a:	82 60       	ori	r24, 0x02	; 2
     d3c:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,WGM00);
     d3e:	a3 e5       	ldi	r26, 0x53	; 83
     d40:	b0 e0       	ldi	r27, 0x00	; 0
     d42:	e3 e5       	ldi	r30, 0x53	; 83
     d44:	f0 e0       	ldi	r31, 0x00	; 0
     d46:	80 81       	ld	r24, Z
     d48:	8f 7b       	andi	r24, 0xBF	; 191
     d4a:	8c 93       	st	X, r24
	SET_BIT(TCCR0,WGM01);
     d4c:	a3 e5       	ldi	r26, 0x53	; 83
     d4e:	b0 e0       	ldi	r27, 0x00	; 0
     d50:	e3 e5       	ldi	r30, 0x53	; 83
     d52:	f0 e0       	ldi	r31, 0x00	; 0
     d54:	80 81       	ld	r24, Z
     d56:	88 60       	ori	r24, 0x08	; 8
     d58:	8c 93       	st	X, r24
	SET_BIT(TCCR0,WGM00);
	SET_BIT(TCCR0,WGM01);
	SET_BIT(DDRB,3);//set OC0 as OUTPUT PIN

	#endif
}
     d5a:	cf 91       	pop	r28
     d5c:	df 91       	pop	r29
     d5e:	08 95       	ret

00000d60 <Timer0_Start>:

void Timer0_Start()
{
     d60:	df 93       	push	r29
     d62:	cf 93       	push	r28
     d64:	cd b7       	in	r28, 0x3d	; 61
     d66:	de b7       	in	r29, 0x3e	; 62
	switch(TIMER0_FREQ)
	{
		case PRE_1024:
		{
			SET_BIT(TCCR0,CS00);
     d68:	a3 e5       	ldi	r26, 0x53	; 83
     d6a:	b0 e0       	ldi	r27, 0x00	; 0
     d6c:	e3 e5       	ldi	r30, 0x53	; 83
     d6e:	f0 e0       	ldi	r31, 0x00	; 0
     d70:	80 81       	ld	r24, Z
     d72:	81 60       	ori	r24, 0x01	; 1
     d74:	8c 93       	st	X, r24
			CLR_BIT(TCCR0,CS01);
     d76:	a3 e5       	ldi	r26, 0x53	; 83
     d78:	b0 e0       	ldi	r27, 0x00	; 0
     d7a:	e3 e5       	ldi	r30, 0x53	; 83
     d7c:	f0 e0       	ldi	r31, 0x00	; 0
     d7e:	80 81       	ld	r24, Z
     d80:	8d 7f       	andi	r24, 0xFD	; 253
     d82:	8c 93       	st	X, r24
			SET_BIT(TCCR0,CS02);
     d84:	a3 e5       	ldi	r26, 0x53	; 83
     d86:	b0 e0       	ldi	r27, 0x00	; 0
     d88:	e3 e5       	ldi	r30, 0x53	; 83
     d8a:	f0 e0       	ldi	r31, 0x00	; 0
     d8c:	80 81       	ld	r24, Z
     d8e:	84 60       	ori	r24, 0x04	; 4
     d90:	8c 93       	st	X, r24
			SET_BIT(TCCR0,CS00);
			CLR_BIT(TCCR0,CS01);
			CLR_BIT(TCCR0,CS02);
		} break;
	}
}
     d92:	cf 91       	pop	r28
     d94:	df 91       	pop	r29
     d96:	08 95       	ret

00000d98 <Timer0_Stop>:

void Timer0_Stop()
{
     d98:	df 93       	push	r29
     d9a:	cf 93       	push	r28
     d9c:	cd b7       	in	r28, 0x3d	; 61
     d9e:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TCCR0,CS00);
     da0:	a3 e5       	ldi	r26, 0x53	; 83
     da2:	b0 e0       	ldi	r27, 0x00	; 0
     da4:	e3 e5       	ldi	r30, 0x53	; 83
     da6:	f0 e0       	ldi	r31, 0x00	; 0
     da8:	80 81       	ld	r24, Z
     daa:	8e 7f       	andi	r24, 0xFE	; 254
     dac:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,CS01);
     dae:	a3 e5       	ldi	r26, 0x53	; 83
     db0:	b0 e0       	ldi	r27, 0x00	; 0
     db2:	e3 e5       	ldi	r30, 0x53	; 83
     db4:	f0 e0       	ldi	r31, 0x00	; 0
     db6:	80 81       	ld	r24, Z
     db8:	8d 7f       	andi	r24, 0xFD	; 253
     dba:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,CS02);
     dbc:	a3 e5       	ldi	r26, 0x53	; 83
     dbe:	b0 e0       	ldi	r27, 0x00	; 0
     dc0:	e3 e5       	ldi	r30, 0x53	; 83
     dc2:	f0 e0       	ldi	r31, 0x00	; 0
     dc4:	80 81       	ld	r24, Z
     dc6:	8b 7f       	andi	r24, 0xFB	; 251
     dc8:	8c 93       	st	X, r24
}
     dca:	cf 91       	pop	r28
     dcc:	df 91       	pop	r29
     dce:	08 95       	ret

00000dd0 <TIMER0_PWM_Stop>:

void TIMER0_PWM_Stop(void)
{
     dd0:	df 93       	push	r29
     dd2:	cf 93       	push	r28
     dd4:	cd b7       	in	r28, 0x3d	; 61
     dd6:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TCCR0,COM00);
     dd8:	a3 e5       	ldi	r26, 0x53	; 83
     dda:	b0 e0       	ldi	r27, 0x00	; 0
     ddc:	e3 e5       	ldi	r30, 0x53	; 83
     dde:	f0 e0       	ldi	r31, 0x00	; 0
     de0:	80 81       	ld	r24, Z
     de2:	8f 7e       	andi	r24, 0xEF	; 239
     de4:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,COM01);
     de6:	a3 e5       	ldi	r26, 0x53	; 83
     de8:	b0 e0       	ldi	r27, 0x00	; 0
     dea:	e3 e5       	ldi	r30, 0x53	; 83
     dec:	f0 e0       	ldi	r31, 0x00	; 0
     dee:	80 81       	ld	r24, Z
     df0:	8f 7d       	andi	r24, 0xDF	; 223
     df2:	8c 93       	st	X, r24
}
     df4:	cf 91       	pop	r28
     df6:	df 91       	pop	r29
     df8:	08 95       	ret

00000dfa <TIMER0_PWM_Start>:

void TIMER0_PWM_Start(void)
{
     dfa:	df 93       	push	r29
     dfc:	cf 93       	push	r28
     dfe:	cd b7       	in	r28, 0x3d	; 61
     e00:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TCCR0,COM00);
     e02:	a3 e5       	ldi	r26, 0x53	; 83
     e04:	b0 e0       	ldi	r27, 0x00	; 0
     e06:	e3 e5       	ldi	r30, 0x53	; 83
     e08:	f0 e0       	ldi	r31, 0x00	; 0
     e0a:	80 81       	ld	r24, Z
     e0c:	8f 7e       	andi	r24, 0xEF	; 239
     e0e:	8c 93       	st	X, r24
	SET_BIT(TCCR0,COM01);
     e10:	a3 e5       	ldi	r26, 0x53	; 83
     e12:	b0 e0       	ldi	r27, 0x00	; 0
     e14:	e3 e5       	ldi	r30, 0x53	; 83
     e16:	f0 e0       	ldi	r31, 0x00	; 0
     e18:	80 81       	ld	r24, Z
     e1a:	80 62       	ori	r24, 0x20	; 32
     e1c:	8c 93       	st	X, r24
}
     e1e:	cf 91       	pop	r28
     e20:	df 91       	pop	r29
     e22:	08 95       	ret

00000e24 <Timer0_SET_DUTY_CYCLE>:

void Timer0_SET_DUTY_CYCLE (uint8_t percentage)
{
     e24:	df 93       	push	r29
     e26:	cf 93       	push	r28
     e28:	0f 92       	push	r0
     e2a:	cd b7       	in	r28, 0x3d	; 61
     e2c:	de b7       	in	r29, 0x3e	; 62
     e2e:	89 83       	std	Y+1, r24	; 0x01
	if (percentage <= 0)
     e30:	89 81       	ldd	r24, Y+1	; 0x01
     e32:	88 23       	and	r24, r24
     e34:	21 f4       	brne	.+8      	; 0xe3e <Timer0_SET_DUTY_CYCLE+0x1a>
	{
		OCR0 = 0;
     e36:	ec e5       	ldi	r30, 0x5C	; 92
     e38:	f0 e0       	ldi	r31, 0x00	; 0
     e3a:	10 82       	st	Z, r1
     e3c:	17 c0       	rjmp	.+46     	; 0xe6c <Timer0_SET_DUTY_CYCLE+0x48>
	}

	else if (percentage >= 100)
     e3e:	89 81       	ldd	r24, Y+1	; 0x01
     e40:	84 36       	cpi	r24, 0x64	; 100
     e42:	28 f0       	brcs	.+10     	; 0xe4e <Timer0_SET_DUTY_CYCLE+0x2a>
	{
		OCR0 = 255;
     e44:	ec e5       	ldi	r30, 0x5C	; 92
     e46:	f0 e0       	ldi	r31, 0x00	; 0
     e48:	8f ef       	ldi	r24, 0xFF	; 255
     e4a:	80 83       	st	Z, r24
     e4c:	0f c0       	rjmp	.+30     	; 0xe6c <Timer0_SET_DUTY_CYCLE+0x48>
	}

	else
	{
		OCR0 = (uint8_t) (((percentage * 256)/100)-1);
     e4e:	ec e5       	ldi	r30, 0x5C	; 92
     e50:	f0 e0       	ldi	r31, 0x00	; 0
     e52:	89 81       	ldd	r24, Y+1	; 0x01
     e54:	88 2f       	mov	r24, r24
     e56:	90 e0       	ldi	r25, 0x00	; 0
     e58:	98 2f       	mov	r25, r24
     e5a:	88 27       	eor	r24, r24
     e5c:	24 e6       	ldi	r18, 0x64	; 100
     e5e:	30 e0       	ldi	r19, 0x00	; 0
     e60:	b9 01       	movw	r22, r18
     e62:	0e 94 38 33 	call	0x6670	; 0x6670 <__divmodhi4>
     e66:	cb 01       	movw	r24, r22
     e68:	81 50       	subi	r24, 0x01	; 1
     e6a:	80 83       	st	Z, r24
	}
}
     e6c:	0f 90       	pop	r0
     e6e:	cf 91       	pop	r28
     e70:	df 91       	pop	r29
     e72:	08 95       	ret

00000e74 <READ_IGNITON>:
 *
 *  Created on: Feb 11, 2023
 *      Author: wario
 */
#include "Btn_Handler.h"
uint8_t READ_IGNITON(void){
     e74:	df 93       	push	r29
     e76:	cf 93       	push	r28
     e78:	0f 92       	push	r0
     e7a:	cd b7       	in	r28, 0x3d	; 61
     e7c:	de b7       	in	r29, 0x3e	; 62

	DIO_SetPinDir(DIO_PORTA ,Pin0, INPUT);
     e7e:	80 e0       	ldi	r24, 0x00	; 0
     e80:	60 e0       	ldi	r22, 0x00	; 0
     e82:	42 e0       	ldi	r20, 0x02	; 2
     e84:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	uint8_t IGNITION_data = DIO_GetPinVal(DIO_PORTA ,Pin0) ;
     e88:	80 e0       	ldi	r24, 0x00	; 0
     e8a:	60 e0       	ldi	r22, 0x00	; 0
     e8c:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_GetPinVal>
     e90:	89 83       	std	Y+1, r24	; 0x01
	return IGNITION_data;
     e92:	89 81       	ldd	r24, Y+1	; 0x01
}
     e94:	0f 90       	pop	r0
     e96:	cf 91       	pop	r28
     e98:	df 91       	pop	r29
     e9a:	08 95       	ret

00000e9c <READ_HAZARD_Button>:
uint8_t READ_HAZARD_Button(void){
     e9c:	df 93       	push	r29
     e9e:	cf 93       	push	r28
     ea0:	0f 92       	push	r0
     ea2:	cd b7       	in	r28, 0x3d	; 61
     ea4:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTA ,Pin1, INPUT);
     ea6:	80 e0       	ldi	r24, 0x00	; 0
     ea8:	61 e0       	ldi	r22, 0x01	; 1
     eaa:	42 e0       	ldi	r20, 0x02	; 2
     eac:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	uint8_t HAZARD_data = DIO_GetPinVal(DIO_PORTA ,Pin1) ;
     eb0:	80 e0       	ldi	r24, 0x00	; 0
     eb2:	61 e0       	ldi	r22, 0x01	; 1
     eb4:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_GetPinVal>
     eb8:	89 83       	std	Y+1, r24	; 0x01
	 return pressed ;
	 }else{
	 return unpressed;
	 }
	 */
	return HAZARD_data;
     eba:	89 81       	ldd	r24, Y+1	; 0x01
}
     ebc:	0f 90       	pop	r0
     ebe:	cf 91       	pop	r28
     ec0:	df 91       	pop	r29
     ec2:	08 95       	ret

00000ec4 <READ_RIGHT_Button>:
uint8_t READ_RIGHT_Button(void){
     ec4:	df 93       	push	r29
     ec6:	cf 93       	push	r28
     ec8:	0f 92       	push	r0
     eca:	cd b7       	in	r28, 0x3d	; 61
     ecc:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTA ,Pin2, INPUT);
     ece:	80 e0       	ldi	r24, 0x00	; 0
     ed0:	62 e0       	ldi	r22, 0x02	; 2
     ed2:	42 e0       	ldi	r20, 0x02	; 2
     ed4:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	uint8_t right_data  = DIO_GetPinVal(DIO_PORTA ,Pin2) ;
     ed8:	80 e0       	ldi	r24, 0x00	; 0
     eda:	62 e0       	ldi	r22, 0x02	; 2
     edc:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_GetPinVal>
     ee0:	89 83       	std	Y+1, r24	; 0x01
	return right_data ;
     ee2:	89 81       	ldd	r24, Y+1	; 0x01
}
     ee4:	0f 90       	pop	r0
     ee6:	cf 91       	pop	r28
     ee8:	df 91       	pop	r29
     eea:	08 95       	ret

00000eec <READ_LEFT_Button>:
uint8_t READ_LEFT_Button(void){
     eec:	df 93       	push	r29
     eee:	cf 93       	push	r28
     ef0:	0f 92       	push	r0
     ef2:	cd b7       	in	r28, 0x3d	; 61
     ef4:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTA ,Pin3, INPUT);
     ef6:	80 e0       	ldi	r24, 0x00	; 0
     ef8:	63 e0       	ldi	r22, 0x03	; 3
     efa:	42 e0       	ldi	r20, 0x02	; 2
     efc:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	uint8_t right_data  = DIO_GetPinVal(DIO_PORTA ,Pin3) ;
     f00:	80 e0       	ldi	r24, 0x00	; 0
     f02:	63 e0       	ldi	r22, 0x03	; 3
     f04:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_GetPinVal>
     f08:	89 83       	std	Y+1, r24	; 0x01
	return right_data;
     f0a:	89 81       	ldd	r24, Y+1	; 0x01

}
     f0c:	0f 90       	pop	r0
     f0e:	cf 91       	pop	r28
     f10:	df 91       	pop	r29
     f12:	08 95       	ret

00000f14 <xCoRoutineCreate>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode,
                                 UBaseType_t uxPriority,
                                 UBaseType_t uxIndex )
    {
     f14:	df 93       	push	r29
     f16:	cf 93       	push	r28
     f18:	cd b7       	in	r28, 0x3d	; 61
     f1a:	de b7       	in	r29, 0x3e	; 62
     f1c:	27 97       	sbiw	r28, 0x07	; 7
     f1e:	0f b6       	in	r0, 0x3f	; 63
     f20:	f8 94       	cli
     f22:	de bf       	out	0x3e, r29	; 62
     f24:	0f be       	out	0x3f, r0	; 63
     f26:	cd bf       	out	0x3d, r28	; 61
     f28:	9d 83       	std	Y+5, r25	; 0x05
     f2a:	8c 83       	std	Y+4, r24	; 0x04
     f2c:	6e 83       	std	Y+6, r22	; 0x06
     f2e:	4f 83       	std	Y+7, r20	; 0x07
        BaseType_t xReturn;
        CRCB_t * pxCoRoutine;

        /* Allocate the memory that will store the co-routine control block. */
        pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     f30:	8a e1       	ldi	r24, 0x1A	; 26
     f32:	90 e0       	ldi	r25, 0x00	; 0
     f34:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     f38:	9a 83       	std	Y+2, r25	; 0x02
     f3a:	89 83       	std	Y+1, r24	; 0x01

        if( pxCoRoutine )
     f3c:	89 81       	ldd	r24, Y+1	; 0x01
     f3e:	9a 81       	ldd	r25, Y+2	; 0x02
     f40:	00 97       	sbiw	r24, 0x00	; 0
     f42:	09 f4       	brne	.+2      	; 0xf46 <xCoRoutineCreate+0x32>
     f44:	6f c0       	rjmp	.+222    	; 0x1024 <xCoRoutineCreate+0x110>
        {
            /* If pxCurrentCoRoutine is NULL then this is the first co-routine to
            * be created and the co-routine data structures need initialising. */
            if( pxCurrentCoRoutine == NULL )
     f46:	80 91 70 06 	lds	r24, 0x0670
     f4a:	90 91 71 06 	lds	r25, 0x0671
     f4e:	00 97       	sbiw	r24, 0x00	; 0
     f50:	41 f4       	brne	.+16     	; 0xf62 <xCoRoutineCreate+0x4e>
            {
                pxCurrentCoRoutine = pxCoRoutine;
     f52:	89 81       	ldd	r24, Y+1	; 0x01
     f54:	9a 81       	ldd	r25, Y+2	; 0x02
     f56:	90 93 71 06 	sts	0x0671, r25
     f5a:	80 93 70 06 	sts	0x0670, r24
                prvInitialiseCoRoutineLists();
     f5e:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <prvInitialiseCoRoutineLists>
            }

            /* Check the priority is within limits. */
            if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     f62:	8e 81       	ldd	r24, Y+6	; 0x06
     f64:	82 30       	cpi	r24, 0x02	; 2
     f66:	10 f0       	brcs	.+4      	; 0xf6c <xCoRoutineCreate+0x58>
            {
                uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     f68:	81 e0       	ldi	r24, 0x01	; 1
     f6a:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Fill out the co-routine control block from the function parameters. */
            pxCoRoutine->uxState = corINITIAL_STATE;
     f6c:	e9 81       	ldd	r30, Y+1	; 0x01
     f6e:	fa 81       	ldd	r31, Y+2	; 0x02
     f70:	11 8e       	std	Z+25, r1	; 0x19
     f72:	10 8e       	std	Z+24, r1	; 0x18
            pxCoRoutine->uxPriority = uxPriority;
     f74:	e9 81       	ldd	r30, Y+1	; 0x01
     f76:	fa 81       	ldd	r31, Y+2	; 0x02
     f78:	8e 81       	ldd	r24, Y+6	; 0x06
     f7a:	86 8b       	std	Z+22, r24	; 0x16
            pxCoRoutine->uxIndex = uxIndex;
     f7c:	e9 81       	ldd	r30, Y+1	; 0x01
     f7e:	fa 81       	ldd	r31, Y+2	; 0x02
     f80:	8f 81       	ldd	r24, Y+7	; 0x07
     f82:	87 8b       	std	Z+23, r24	; 0x17
            pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     f84:	e9 81       	ldd	r30, Y+1	; 0x01
     f86:	fa 81       	ldd	r31, Y+2	; 0x02
     f88:	8c 81       	ldd	r24, Y+4	; 0x04
     f8a:	9d 81       	ldd	r25, Y+5	; 0x05
     f8c:	91 83       	std	Z+1, r25	; 0x01
     f8e:	80 83       	st	Z, r24

            /* Initialise all the other co-routine control block parameters. */
            vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     f90:	89 81       	ldd	r24, Y+1	; 0x01
     f92:	9a 81       	ldd	r25, Y+2	; 0x02
     f94:	02 96       	adiw	r24, 0x02	; 2
     f96:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <vListInitialiseItem>
            vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     f9a:	89 81       	ldd	r24, Y+1	; 0x01
     f9c:	9a 81       	ldd	r25, Y+2	; 0x02
     f9e:	0c 96       	adiw	r24, 0x0c	; 12
     fa0:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <vListInitialiseItem>

            /* Set the co-routine control block as a link back from the ListItem_t.
             * This is so we can get back to the containing CRCB from a generic item
             * in a list. */
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     fa4:	e9 81       	ldd	r30, Y+1	; 0x01
     fa6:	fa 81       	ldd	r31, Y+2	; 0x02
     fa8:	89 81       	ldd	r24, Y+1	; 0x01
     faa:	9a 81       	ldd	r25, Y+2	; 0x02
     fac:	91 87       	std	Z+9, r25	; 0x09
     fae:	80 87       	std	Z+8, r24	; 0x08
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     fb0:	e9 81       	ldd	r30, Y+1	; 0x01
     fb2:	fa 81       	ldd	r31, Y+2	; 0x02
     fb4:	89 81       	ldd	r24, Y+1	; 0x01
     fb6:	9a 81       	ldd	r25, Y+2	; 0x02
     fb8:	93 8b       	std	Z+19, r25	; 0x13
     fba:	82 8b       	std	Z+18, r24	; 0x12

            /* Event lists are always in priority order. */
            listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     fbc:	8e 81       	ldd	r24, Y+6	; 0x06
     fbe:	28 2f       	mov	r18, r24
     fc0:	30 e0       	ldi	r19, 0x00	; 0
     fc2:	82 e0       	ldi	r24, 0x02	; 2
     fc4:	90 e0       	ldi	r25, 0x00	; 0
     fc6:	82 1b       	sub	r24, r18
     fc8:	93 0b       	sbc	r25, r19
     fca:	e9 81       	ldd	r30, Y+1	; 0x01
     fcc:	fa 81       	ldd	r31, Y+2	; 0x02
     fce:	95 87       	std	Z+13, r25	; 0x0d
     fd0:	84 87       	std	Z+12, r24	; 0x0c

            /* Now the co-routine has been initialised it can be added to the ready
             * list at the correct priority. */
            prvAddCoRoutineToReadyQueue( pxCoRoutine );
     fd2:	e9 81       	ldd	r30, Y+1	; 0x01
     fd4:	fa 81       	ldd	r31, Y+2	; 0x02
     fd6:	96 89       	ldd	r25, Z+22	; 0x16
     fd8:	80 91 72 06 	lds	r24, 0x0672
     fdc:	89 17       	cp	r24, r25
     fde:	28 f4       	brcc	.+10     	; 0xfea <xCoRoutineCreate+0xd6>
     fe0:	e9 81       	ldd	r30, Y+1	; 0x01
     fe2:	fa 81       	ldd	r31, Y+2	; 0x02
     fe4:	86 89       	ldd	r24, Z+22	; 0x16
     fe6:	80 93 72 06 	sts	0x0672, r24
     fea:	e9 81       	ldd	r30, Y+1	; 0x01
     fec:	fa 81       	ldd	r31, Y+2	; 0x02
     fee:	86 89       	ldd	r24, Z+22	; 0x16
     ff0:	28 2f       	mov	r18, r24
     ff2:	30 e0       	ldi	r19, 0x00	; 0
     ff4:	c9 01       	movw	r24, r18
     ff6:	88 0f       	add	r24, r24
     ff8:	99 1f       	adc	r25, r25
     ffa:	88 0f       	add	r24, r24
     ffc:	99 1f       	adc	r25, r25
     ffe:	88 0f       	add	r24, r24
    1000:	99 1f       	adc	r25, r25
    1002:	82 0f       	add	r24, r18
    1004:	93 1f       	adc	r25, r19
    1006:	ac 01       	movw	r20, r24
    1008:	47 58       	subi	r20, 0x87	; 135
    100a:	59 4f       	sbci	r21, 0xF9	; 249
    100c:	89 81       	ldd	r24, Y+1	; 0x01
    100e:	9a 81       	ldd	r25, Y+2	; 0x02
    1010:	9c 01       	movw	r18, r24
    1012:	2e 5f       	subi	r18, 0xFE	; 254
    1014:	3f 4f       	sbci	r19, 0xFF	; 255
    1016:	ca 01       	movw	r24, r20
    1018:	b9 01       	movw	r22, r18
    101a:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <vListInsertEnd>

            xReturn = pdPASS;
    101e:	81 e0       	ldi	r24, 0x01	; 1
    1020:	8b 83       	std	Y+3, r24	; 0x03
    1022:	02 c0       	rjmp	.+4      	; 0x1028 <xCoRoutineCreate+0x114>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1024:	8f ef       	ldi	r24, 0xFF	; 255
    1026:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    1028:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    102a:	27 96       	adiw	r28, 0x07	; 7
    102c:	0f b6       	in	r0, 0x3f	; 63
    102e:	f8 94       	cli
    1030:	de bf       	out	0x3e, r29	; 62
    1032:	0f be       	out	0x3f, r0	; 63
    1034:	cd bf       	out	0x3d, r28	; 61
    1036:	cf 91       	pop	r28
    1038:	df 91       	pop	r29
    103a:	08 95       	ret

0000103c <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

    void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay,
                                     List_t * pxEventList )
    {
    103c:	df 93       	push	r29
    103e:	cf 93       	push	r28
    1040:	00 d0       	rcall	.+0      	; 0x1042 <vCoRoutineAddToDelayedList+0x6>
    1042:	00 d0       	rcall	.+0      	; 0x1044 <vCoRoutineAddToDelayedList+0x8>
    1044:	00 d0       	rcall	.+0      	; 0x1046 <vCoRoutineAddToDelayedList+0xa>
    1046:	cd b7       	in	r28, 0x3d	; 61
    1048:	de b7       	in	r29, 0x3e	; 62
    104a:	9c 83       	std	Y+4, r25	; 0x04
    104c:	8b 83       	std	Y+3, r24	; 0x03
    104e:	7e 83       	std	Y+6, r23	; 0x06
    1050:	6d 83       	std	Y+5, r22	; 0x05
        TickType_t xTimeToWake;

        /* Calculate the time to wake - this may overflow but this is
         * not a problem. */
        xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1052:	20 91 73 06 	lds	r18, 0x0673
    1056:	30 91 74 06 	lds	r19, 0x0674
    105a:	8b 81       	ldd	r24, Y+3	; 0x03
    105c:	9c 81       	ldd	r25, Y+4	; 0x04
    105e:	82 0f       	add	r24, r18
    1060:	93 1f       	adc	r25, r19
    1062:	9a 83       	std	Y+2, r25	; 0x02
    1064:	89 83       	std	Y+1, r24	; 0x01

        /* We must remove ourselves from the ready list before adding
         * ourselves to the blocked list as the same list item is used for
         * both lists. */
        ( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1066:	80 91 70 06 	lds	r24, 0x0670
    106a:	90 91 71 06 	lds	r25, 0x0671
    106e:	02 96       	adiw	r24, 0x02	; 2
    1070:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <uxListRemove>

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1074:	e0 91 70 06 	lds	r30, 0x0670
    1078:	f0 91 71 06 	lds	r31, 0x0671
    107c:	89 81       	ldd	r24, Y+1	; 0x01
    107e:	9a 81       	ldd	r25, Y+2	; 0x02
    1080:	93 83       	std	Z+3, r25	; 0x03
    1082:	82 83       	std	Z+2, r24	; 0x02

        if( xTimeToWake < xCoRoutineTickCount )
    1084:	20 91 73 06 	lds	r18, 0x0673
    1088:	30 91 74 06 	lds	r19, 0x0674
    108c:	89 81       	ldd	r24, Y+1	; 0x01
    108e:	9a 81       	ldd	r25, Y+2	; 0x02
    1090:	82 17       	cp	r24, r18
    1092:	93 07       	cpc	r25, r19
    1094:	70 f4       	brcc	.+28     	; 0x10b2 <vCoRoutineAddToDelayedList+0x76>
        {
            /* Wake time has overflowed.  Place this item in the
             * overflow list. */
            vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1096:	80 91 6e 06 	lds	r24, 0x066E
    109a:	90 91 6f 06 	lds	r25, 0x066F
    109e:	20 91 70 06 	lds	r18, 0x0670
    10a2:	30 91 71 06 	lds	r19, 0x0671
    10a6:	2e 5f       	subi	r18, 0xFE	; 254
    10a8:	3f 4f       	sbci	r19, 0xFF	; 255
    10aa:	b9 01       	movw	r22, r18
    10ac:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <vListInsert>
    10b0:	0d c0       	rjmp	.+26     	; 0x10cc <vCoRoutineAddToDelayedList+0x90>
        }
        else
        {
            /* The wake time has not overflowed, so we can use the
             * current block list. */
            vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    10b2:	80 91 6c 06 	lds	r24, 0x066C
    10b6:	90 91 6d 06 	lds	r25, 0x066D
    10ba:	20 91 70 06 	lds	r18, 0x0670
    10be:	30 91 71 06 	lds	r19, 0x0671
    10c2:	2e 5f       	subi	r18, 0xFE	; 254
    10c4:	3f 4f       	sbci	r19, 0xFF	; 255
    10c6:	b9 01       	movw	r22, r18
    10c8:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <vListInsert>
        }

        if( pxEventList )
    10cc:	8d 81       	ldd	r24, Y+5	; 0x05
    10ce:	9e 81       	ldd	r25, Y+6	; 0x06
    10d0:	00 97       	sbiw	r24, 0x00	; 0
    10d2:	61 f0       	breq	.+24     	; 0x10ec <vCoRoutineAddToDelayedList+0xb0>
        {
            /* Also add the co-routine to an event list.  If this is done then the
             * function must be called with interrupts disabled. */
            vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    10d4:	80 91 70 06 	lds	r24, 0x0670
    10d8:	90 91 71 06 	lds	r25, 0x0671
    10dc:	9c 01       	movw	r18, r24
    10de:	24 5f       	subi	r18, 0xF4	; 244
    10e0:	3f 4f       	sbci	r19, 0xFF	; 255
    10e2:	8d 81       	ldd	r24, Y+5	; 0x05
    10e4:	9e 81       	ldd	r25, Y+6	; 0x06
    10e6:	b9 01       	movw	r22, r18
    10e8:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <vListInsert>
        }
    }
    10ec:	26 96       	adiw	r28, 0x06	; 6
    10ee:	0f b6       	in	r0, 0x3f	; 63
    10f0:	f8 94       	cli
    10f2:	de bf       	out	0x3e, r29	; 62
    10f4:	0f be       	out	0x3f, r0	; 63
    10f6:	cd bf       	out	0x3d, r28	; 61
    10f8:	cf 91       	pop	r28
    10fa:	df 91       	pop	r29
    10fc:	08 95       	ret

000010fe <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

    static void prvCheckPendingReadyList( void )
    {
    10fe:	df 93       	push	r29
    1100:	cf 93       	push	r28
    1102:	00 d0       	rcall	.+0      	; 0x1104 <prvCheckPendingReadyList+0x6>
    1104:	cd b7       	in	r28, 0x3d	; 61
    1106:	de b7       	in	r29, 0x3e	; 62
    1108:	3a c0       	rjmp	.+116    	; 0x117e <prvCheckPendingReadyList+0x80>
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
        {
            CRCB_t * pxUnblockedCRCB;

            /* The pending ready list can be accessed by an ISR. */
            portDISABLE_INTERRUPTS();
    110a:	f8 94       	cli
            {
                pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyCoRoutineList ) );
    110c:	e0 91 a2 06 	lds	r30, 0x06A2
    1110:	f0 91 a3 06 	lds	r31, 0x06A3
    1114:	86 81       	ldd	r24, Z+6	; 0x06
    1116:	97 81       	ldd	r25, Z+7	; 0x07
    1118:	9a 83       	std	Y+2, r25	; 0x02
    111a:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    111c:	89 81       	ldd	r24, Y+1	; 0x01
    111e:	9a 81       	ldd	r25, Y+2	; 0x02
    1120:	0c 96       	adiw	r24, 0x0c	; 12
    1122:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <uxListRemove>
            }
            portENABLE_INTERRUPTS();
    1126:	78 94       	sei

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1128:	89 81       	ldd	r24, Y+1	; 0x01
    112a:	9a 81       	ldd	r25, Y+2	; 0x02
    112c:	02 96       	adiw	r24, 0x02	; 2
    112e:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <uxListRemove>
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1132:	e9 81       	ldd	r30, Y+1	; 0x01
    1134:	fa 81       	ldd	r31, Y+2	; 0x02
    1136:	96 89       	ldd	r25, Z+22	; 0x16
    1138:	80 91 72 06 	lds	r24, 0x0672
    113c:	89 17       	cp	r24, r25
    113e:	28 f4       	brcc	.+10     	; 0x114a <prvCheckPendingReadyList+0x4c>
    1140:	e9 81       	ldd	r30, Y+1	; 0x01
    1142:	fa 81       	ldd	r31, Y+2	; 0x02
    1144:	86 89       	ldd	r24, Z+22	; 0x16
    1146:	80 93 72 06 	sts	0x0672, r24
    114a:	e9 81       	ldd	r30, Y+1	; 0x01
    114c:	fa 81       	ldd	r31, Y+2	; 0x02
    114e:	86 89       	ldd	r24, Z+22	; 0x16
    1150:	28 2f       	mov	r18, r24
    1152:	30 e0       	ldi	r19, 0x00	; 0
    1154:	c9 01       	movw	r24, r18
    1156:	88 0f       	add	r24, r24
    1158:	99 1f       	adc	r25, r25
    115a:	88 0f       	add	r24, r24
    115c:	99 1f       	adc	r25, r25
    115e:	88 0f       	add	r24, r24
    1160:	99 1f       	adc	r25, r25
    1162:	82 0f       	add	r24, r18
    1164:	93 1f       	adc	r25, r19
    1166:	ac 01       	movw	r20, r24
    1168:	47 58       	subi	r20, 0x87	; 135
    116a:	59 4f       	sbci	r21, 0xF9	; 249
    116c:	89 81       	ldd	r24, Y+1	; 0x01
    116e:	9a 81       	ldd	r25, Y+2	; 0x02
    1170:	9c 01       	movw	r18, r24
    1172:	2e 5f       	subi	r18, 0xFE	; 254
    1174:	3f 4f       	sbci	r19, 0xFF	; 255
    1176:	ca 01       	movw	r24, r20
    1178:	b9 01       	movw	r22, r18
    117a:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <vListInsertEnd>
    static void prvCheckPendingReadyList( void )
    {
        /* Are there any co-routines waiting to get moved to the ready list?  These
         * are co-routines that have been readied by an ISR.  The ISR cannot access
         * the ready lists itself. */
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    117e:	80 91 9d 06 	lds	r24, 0x069D
    1182:	88 23       	and	r24, r24
    1184:	09 f0       	breq	.+2      	; 0x1188 <prvCheckPendingReadyList+0x8a>
    1186:	c1 cf       	rjmp	.-126    	; 0x110a <prvCheckPendingReadyList+0xc>
            portENABLE_INTERRUPTS();

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
        }
    }
    1188:	0f 90       	pop	r0
    118a:	0f 90       	pop	r0
    118c:	cf 91       	pop	r28
    118e:	df 91       	pop	r29
    1190:	08 95       	ret

00001192 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

    static void prvCheckDelayedList( void )
    {
    1192:	df 93       	push	r29
    1194:	cf 93       	push	r28
    1196:	00 d0       	rcall	.+0      	; 0x1198 <prvCheckDelayedList+0x6>
    1198:	00 d0       	rcall	.+0      	; 0x119a <prvCheckDelayedList+0x8>
    119a:	cd b7       	in	r28, 0x3d	; 61
    119c:	de b7       	in	r29, 0x3e	; 62
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    119e:	0e 94 e7 1c 	call	0x39ce	; 0x39ce <xTaskGetTickCount>
    11a2:	20 91 75 06 	lds	r18, 0x0675
    11a6:	30 91 76 06 	lds	r19, 0x0676
    11aa:	82 1b       	sub	r24, r18
    11ac:	93 0b       	sbc	r25, r19
    11ae:	90 93 78 06 	sts	0x0678, r25
    11b2:	80 93 77 06 	sts	0x0677, r24
    11b6:	85 c0       	rjmp	.+266    	; 0x12c2 <prvCheckDelayedList+0x130>

        while( xPassedTicks )
        {
            xCoRoutineTickCount++;
    11b8:	80 91 73 06 	lds	r24, 0x0673
    11bc:	90 91 74 06 	lds	r25, 0x0674
    11c0:	01 96       	adiw	r24, 0x01	; 1
    11c2:	90 93 74 06 	sts	0x0674, r25
    11c6:	80 93 73 06 	sts	0x0673, r24
            xPassedTicks--;
    11ca:	80 91 77 06 	lds	r24, 0x0677
    11ce:	90 91 78 06 	lds	r25, 0x0678
    11d2:	01 97       	sbiw	r24, 0x01	; 1
    11d4:	90 93 78 06 	sts	0x0678, r25
    11d8:	80 93 77 06 	sts	0x0677, r24

            /* If the tick count has overflowed we need to swap the ready lists. */
            if( xCoRoutineTickCount == 0 )
    11dc:	80 91 73 06 	lds	r24, 0x0673
    11e0:	90 91 74 06 	lds	r25, 0x0674
    11e4:	00 97       	sbiw	r24, 0x00	; 0
    11e6:	09 f0       	breq	.+2      	; 0x11ea <prvCheckDelayedList+0x58>
    11e8:	64 c0       	rjmp	.+200    	; 0x12b2 <prvCheckDelayedList+0x120>
            {
                List_t * pxTemp;

                /* Tick count has overflowed so we need to swap the delay lists.  If there are
                 * any items in pxDelayedCoRoutineList here then there is an error! */
                pxTemp = pxDelayedCoRoutineList;
    11ea:	80 91 6c 06 	lds	r24, 0x066C
    11ee:	90 91 6d 06 	lds	r25, 0x066D
    11f2:	9a 83       	std	Y+2, r25	; 0x02
    11f4:	89 83       	std	Y+1, r24	; 0x01
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    11f6:	80 91 6e 06 	lds	r24, 0x066E
    11fa:	90 91 6f 06 	lds	r25, 0x066F
    11fe:	90 93 6d 06 	sts	0x066D, r25
    1202:	80 93 6c 06 	sts	0x066C, r24
                pxOverflowDelayedCoRoutineList = pxTemp;
    1206:	89 81       	ldd	r24, Y+1	; 0x01
    1208:	9a 81       	ldd	r25, Y+2	; 0x02
    120a:	90 93 6f 06 	sts	0x066F, r25
    120e:	80 93 6e 06 	sts	0x066E, r24
    1212:	4f c0       	rjmp	.+158    	; 0x12b2 <prvCheckDelayedList+0x120>
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
            {
                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1214:	e0 91 6c 06 	lds	r30, 0x066C
    1218:	f0 91 6d 06 	lds	r31, 0x066D
    121c:	05 80       	ldd	r0, Z+5	; 0x05
    121e:	f6 81       	ldd	r31, Z+6	; 0x06
    1220:	e0 2d       	mov	r30, r0
    1222:	86 81       	ldd	r24, Z+6	; 0x06
    1224:	97 81       	ldd	r25, Z+7	; 0x07
    1226:	9c 83       	std	Y+4, r25	; 0x04
    1228:	8b 83       	std	Y+3, r24	; 0x03

                if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    122a:	eb 81       	ldd	r30, Y+3	; 0x03
    122c:	fc 81       	ldd	r31, Y+4	; 0x04
    122e:	22 81       	ldd	r18, Z+2	; 0x02
    1230:	33 81       	ldd	r19, Z+3	; 0x03
    1232:	80 91 73 06 	lds	r24, 0x0673
    1236:	90 91 74 06 	lds	r25, 0x0674
    123a:	82 17       	cp	r24, r18
    123c:	93 07       	cpc	r25, r19
    123e:	08 f4       	brcc	.+2      	; 0x1242 <prvCheckDelayedList+0xb0>
    1240:	40 c0       	rjmp	.+128    	; 0x12c2 <prvCheckDelayedList+0x130>
                {
                    /* Timeout not yet expired. */
                    break;
                }

                portDISABLE_INTERRUPTS();
    1242:	f8 94       	cli
                    /* The event could have occurred just before this critical
                     *  section.  If this is the case then the generic list item will
                     *  have been moved to the pending ready list and the following
                     *  line is still valid.  Also the pvContainer parameter will have
                     *  been set to NULL so the following lines are also valid. */
                    ( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    1244:	8b 81       	ldd	r24, Y+3	; 0x03
    1246:	9c 81       	ldd	r25, Y+4	; 0x04
    1248:	02 96       	adiw	r24, 0x02	; 2
    124a:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <uxListRemove>

                    /* Is the co-routine waiting on an event also? */
                    if( pxCRCB->xEventListItem.pxContainer )
    124e:	eb 81       	ldd	r30, Y+3	; 0x03
    1250:	fc 81       	ldd	r31, Y+4	; 0x04
    1252:	84 89       	ldd	r24, Z+20	; 0x14
    1254:	95 89       	ldd	r25, Z+21	; 0x15
    1256:	00 97       	sbiw	r24, 0x00	; 0
    1258:	29 f0       	breq	.+10     	; 0x1264 <prvCheckDelayedList+0xd2>
                    {
                        ( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    125a:	8b 81       	ldd	r24, Y+3	; 0x03
    125c:	9c 81       	ldd	r25, Y+4	; 0x04
    125e:	0c 96       	adiw	r24, 0x0c	; 12
    1260:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <uxListRemove>
                    }
                }
                portENABLE_INTERRUPTS();
    1264:	78 94       	sei

                prvAddCoRoutineToReadyQueue( pxCRCB );
    1266:	eb 81       	ldd	r30, Y+3	; 0x03
    1268:	fc 81       	ldd	r31, Y+4	; 0x04
    126a:	96 89       	ldd	r25, Z+22	; 0x16
    126c:	80 91 72 06 	lds	r24, 0x0672
    1270:	89 17       	cp	r24, r25
    1272:	28 f4       	brcc	.+10     	; 0x127e <prvCheckDelayedList+0xec>
    1274:	eb 81       	ldd	r30, Y+3	; 0x03
    1276:	fc 81       	ldd	r31, Y+4	; 0x04
    1278:	86 89       	ldd	r24, Z+22	; 0x16
    127a:	80 93 72 06 	sts	0x0672, r24
    127e:	eb 81       	ldd	r30, Y+3	; 0x03
    1280:	fc 81       	ldd	r31, Y+4	; 0x04
    1282:	86 89       	ldd	r24, Z+22	; 0x16
    1284:	28 2f       	mov	r18, r24
    1286:	30 e0       	ldi	r19, 0x00	; 0
    1288:	c9 01       	movw	r24, r18
    128a:	88 0f       	add	r24, r24
    128c:	99 1f       	adc	r25, r25
    128e:	88 0f       	add	r24, r24
    1290:	99 1f       	adc	r25, r25
    1292:	88 0f       	add	r24, r24
    1294:	99 1f       	adc	r25, r25
    1296:	82 0f       	add	r24, r18
    1298:	93 1f       	adc	r25, r19
    129a:	ac 01       	movw	r20, r24
    129c:	47 58       	subi	r20, 0x87	; 135
    129e:	59 4f       	sbci	r21, 0xF9	; 249
    12a0:	8b 81       	ldd	r24, Y+3	; 0x03
    12a2:	9c 81       	ldd	r25, Y+4	; 0x04
    12a4:	9c 01       	movw	r18, r24
    12a6:	2e 5f       	subi	r18, 0xFE	; 254
    12a8:	3f 4f       	sbci	r19, 0xFF	; 255
    12aa:	ca 01       	movw	r24, r20
    12ac:	b9 01       	movw	r22, r18
    12ae:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <vListInsertEnd>
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
                pxOverflowDelayedCoRoutineList = pxTemp;
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    12b2:	e0 91 6c 06 	lds	r30, 0x066C
    12b6:	f0 91 6d 06 	lds	r31, 0x066D
    12ba:	80 81       	ld	r24, Z
    12bc:	88 23       	and	r24, r24
    12be:	09 f0       	breq	.+2      	; 0x12c2 <prvCheckDelayedList+0x130>
    12c0:	a9 cf       	rjmp	.-174    	; 0x1214 <prvCheckDelayedList+0x82>
    {
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;

        while( xPassedTicks )
    12c2:	80 91 77 06 	lds	r24, 0x0677
    12c6:	90 91 78 06 	lds	r25, 0x0678
    12ca:	00 97       	sbiw	r24, 0x00	; 0
    12cc:	09 f0       	breq	.+2      	; 0x12d0 <prvCheckDelayedList+0x13e>
    12ce:	74 cf       	rjmp	.-280    	; 0x11b8 <prvCheckDelayedList+0x26>

                prvAddCoRoutineToReadyQueue( pxCRCB );
            }
        }

        xLastTickCount = xCoRoutineTickCount;
    12d0:	80 91 73 06 	lds	r24, 0x0673
    12d4:	90 91 74 06 	lds	r25, 0x0674
    12d8:	90 93 76 06 	sts	0x0676, r25
    12dc:	80 93 75 06 	sts	0x0675, r24
    }
    12e0:	0f 90       	pop	r0
    12e2:	0f 90       	pop	r0
    12e4:	0f 90       	pop	r0
    12e6:	0f 90       	pop	r0
    12e8:	cf 91       	pop	r28
    12ea:	df 91       	pop	r29
    12ec:	08 95       	ret

000012ee <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

    void vCoRoutineSchedule( void )
    {
    12ee:	df 93       	push	r29
    12f0:	cf 93       	push	r28
    12f2:	00 d0       	rcall	.+0      	; 0x12f4 <vCoRoutineSchedule+0x6>
    12f4:	cd b7       	in	r28, 0x3d	; 61
    12f6:	de b7       	in	r29, 0x3e	; 62
        /* Only run a co-routine after prvInitialiseCoRoutineLists() has been
         * called.  prvInitialiseCoRoutineLists() is called automatically when a
         * co-routine is created. */
        if( pxDelayedCoRoutineList != NULL )
    12f8:	80 91 6c 06 	lds	r24, 0x066C
    12fc:	90 91 6d 06 	lds	r25, 0x066D
    1300:	00 97       	sbiw	r24, 0x00	; 0
    1302:	09 f4       	brne	.+2      	; 0x1306 <vCoRoutineSchedule+0x18>
    1304:	70 c0       	rjmp	.+224    	; 0x13e6 <vCoRoutineSchedule+0xf8>
        {
            /* See if any co-routines readied by events need moving to the ready lists. */
            prvCheckPendingReadyList();
    1306:	0e 94 7f 08 	call	0x10fe	; 0x10fe <prvCheckPendingReadyList>

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();
    130a:	0e 94 c9 08 	call	0x1192	; 0x1192 <prvCheckDelayedList>
    130e:	0a c0       	rjmp	.+20     	; 0x1324 <vCoRoutineSchedule+0x36>

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
            {
                if( uxTopCoRoutineReadyPriority == 0 )
    1310:	80 91 72 06 	lds	r24, 0x0672
    1314:	88 23       	and	r24, r24
    1316:	09 f4       	brne	.+2      	; 0x131a <vCoRoutineSchedule+0x2c>
    1318:	66 c0       	rjmp	.+204    	; 0x13e6 <vCoRoutineSchedule+0xf8>
                {
                    /* No more co-routines to check. */
                    return;
                }

                --uxTopCoRoutineReadyPriority;
    131a:	80 91 72 06 	lds	r24, 0x0672
    131e:	81 50       	subi	r24, 0x01	; 1
    1320:	80 93 72 06 	sts	0x0672, r24

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1324:	80 91 72 06 	lds	r24, 0x0672
    1328:	28 2f       	mov	r18, r24
    132a:	30 e0       	ldi	r19, 0x00	; 0
    132c:	c9 01       	movw	r24, r18
    132e:	88 0f       	add	r24, r24
    1330:	99 1f       	adc	r25, r25
    1332:	88 0f       	add	r24, r24
    1334:	99 1f       	adc	r25, r25
    1336:	88 0f       	add	r24, r24
    1338:	99 1f       	adc	r25, r25
    133a:	82 0f       	add	r24, r18
    133c:	93 1f       	adc	r25, r19
    133e:	fc 01       	movw	r30, r24
    1340:	e7 58       	subi	r30, 0x87	; 135
    1342:	f9 4f       	sbci	r31, 0xF9	; 249
    1344:	80 81       	ld	r24, Z
    1346:	88 23       	and	r24, r24
    1348:	19 f3       	breq	.-58     	; 0x1310 <vCoRoutineSchedule+0x22>
                --uxTopCoRoutineReadyPriority;
            }

            /* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
             * of the same priority get an equal share of the processor time. */
            listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    134a:	80 91 72 06 	lds	r24, 0x0672
    134e:	28 2f       	mov	r18, r24
    1350:	30 e0       	ldi	r19, 0x00	; 0
    1352:	c9 01       	movw	r24, r18
    1354:	88 0f       	add	r24, r24
    1356:	99 1f       	adc	r25, r25
    1358:	88 0f       	add	r24, r24
    135a:	99 1f       	adc	r25, r25
    135c:	88 0f       	add	r24, r24
    135e:	99 1f       	adc	r25, r25
    1360:	82 0f       	add	r24, r18
    1362:	93 1f       	adc	r25, r19
    1364:	87 58       	subi	r24, 0x87	; 135
    1366:	99 4f       	sbci	r25, 0xF9	; 249
    1368:	9a 83       	std	Y+2, r25	; 0x02
    136a:	89 83       	std	Y+1, r24	; 0x01
    136c:	e9 81       	ldd	r30, Y+1	; 0x01
    136e:	fa 81       	ldd	r31, Y+2	; 0x02
    1370:	01 80       	ldd	r0, Z+1	; 0x01
    1372:	f2 81       	ldd	r31, Z+2	; 0x02
    1374:	e0 2d       	mov	r30, r0
    1376:	82 81       	ldd	r24, Z+2	; 0x02
    1378:	93 81       	ldd	r25, Z+3	; 0x03
    137a:	e9 81       	ldd	r30, Y+1	; 0x01
    137c:	fa 81       	ldd	r31, Y+2	; 0x02
    137e:	92 83       	std	Z+2, r25	; 0x02
    1380:	81 83       	std	Z+1, r24	; 0x01
    1382:	e9 81       	ldd	r30, Y+1	; 0x01
    1384:	fa 81       	ldd	r31, Y+2	; 0x02
    1386:	21 81       	ldd	r18, Z+1	; 0x01
    1388:	32 81       	ldd	r19, Z+2	; 0x02
    138a:	89 81       	ldd	r24, Y+1	; 0x01
    138c:	9a 81       	ldd	r25, Y+2	; 0x02
    138e:	03 96       	adiw	r24, 0x03	; 3
    1390:	28 17       	cp	r18, r24
    1392:	39 07       	cpc	r19, r25
    1394:	59 f4       	brne	.+22     	; 0x13ac <vCoRoutineSchedule+0xbe>
    1396:	e9 81       	ldd	r30, Y+1	; 0x01
    1398:	fa 81       	ldd	r31, Y+2	; 0x02
    139a:	01 80       	ldd	r0, Z+1	; 0x01
    139c:	f2 81       	ldd	r31, Z+2	; 0x02
    139e:	e0 2d       	mov	r30, r0
    13a0:	82 81       	ldd	r24, Z+2	; 0x02
    13a2:	93 81       	ldd	r25, Z+3	; 0x03
    13a4:	e9 81       	ldd	r30, Y+1	; 0x01
    13a6:	fa 81       	ldd	r31, Y+2	; 0x02
    13a8:	92 83       	std	Z+2, r25	; 0x02
    13aa:	81 83       	std	Z+1, r24	; 0x01
    13ac:	e9 81       	ldd	r30, Y+1	; 0x01
    13ae:	fa 81       	ldd	r31, Y+2	; 0x02
    13b0:	01 80       	ldd	r0, Z+1	; 0x01
    13b2:	f2 81       	ldd	r31, Z+2	; 0x02
    13b4:	e0 2d       	mov	r30, r0
    13b6:	86 81       	ldd	r24, Z+6	; 0x06
    13b8:	97 81       	ldd	r25, Z+7	; 0x07
    13ba:	90 93 71 06 	sts	0x0671, r25
    13be:	80 93 70 06 	sts	0x0670, r24

            /* Call the co-routine. */
            ( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    13c2:	e0 91 70 06 	lds	r30, 0x0670
    13c6:	f0 91 71 06 	lds	r31, 0x0671
    13ca:	40 81       	ld	r20, Z
    13cc:	51 81       	ldd	r21, Z+1	; 0x01
    13ce:	80 91 70 06 	lds	r24, 0x0670
    13d2:	90 91 71 06 	lds	r25, 0x0671
    13d6:	e0 91 70 06 	lds	r30, 0x0670
    13da:	f0 91 71 06 	lds	r31, 0x0671
    13de:	27 89       	ldd	r18, Z+23	; 0x17
    13e0:	62 2f       	mov	r22, r18
    13e2:	fa 01       	movw	r30, r20
    13e4:	09 95       	icall
        }
    }
    13e6:	0f 90       	pop	r0
    13e8:	0f 90       	pop	r0
    13ea:	cf 91       	pop	r28
    13ec:	df 91       	pop	r29
    13ee:	08 95       	ret

000013f0 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

    static void prvInitialiseCoRoutineLists( void )
    {
    13f0:	df 93       	push	r29
    13f2:	cf 93       	push	r28
    13f4:	0f 92       	push	r0
    13f6:	cd b7       	in	r28, 0x3d	; 61
    13f8:	de b7       	in	r29, 0x3e	; 62
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    13fa:	19 82       	std	Y+1, r1	; 0x01
    13fc:	13 c0       	rjmp	.+38     	; 0x1424 <prvInitialiseCoRoutineLists+0x34>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    13fe:	89 81       	ldd	r24, Y+1	; 0x01
    1400:	28 2f       	mov	r18, r24
    1402:	30 e0       	ldi	r19, 0x00	; 0
    1404:	c9 01       	movw	r24, r18
    1406:	88 0f       	add	r24, r24
    1408:	99 1f       	adc	r25, r25
    140a:	88 0f       	add	r24, r24
    140c:	99 1f       	adc	r25, r25
    140e:	88 0f       	add	r24, r24
    1410:	99 1f       	adc	r25, r25
    1412:	82 0f       	add	r24, r18
    1414:	93 1f       	adc	r25, r19
    1416:	87 58       	subi	r24, 0x87	; 135
    1418:	99 4f       	sbci	r25, 0xF9	; 249
    141a:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <vListInitialise>

    static void prvInitialiseCoRoutineLists( void )
    {
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    141e:	89 81       	ldd	r24, Y+1	; 0x01
    1420:	8f 5f       	subi	r24, 0xFF	; 255
    1422:	89 83       	std	Y+1, r24	; 0x01
    1424:	89 81       	ldd	r24, Y+1	; 0x01
    1426:	82 30       	cpi	r24, 0x02	; 2
    1428:	50 f3       	brcs	.-44     	; 0x13fe <prvInitialiseCoRoutineLists+0xe>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
        }

        vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    142a:	8b e8       	ldi	r24, 0x8B	; 139
    142c:	96 e0       	ldi	r25, 0x06	; 6
    142e:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <vListInitialise>
        vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    1432:	84 e9       	ldi	r24, 0x94	; 148
    1434:	96 e0       	ldi	r25, 0x06	; 6
    1436:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <vListInitialise>
        vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    143a:	8d e9       	ldi	r24, 0x9D	; 157
    143c:	96 e0       	ldi	r25, 0x06	; 6
    143e:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <vListInitialise>

        /* Start with pxDelayedCoRoutineList using list1 and the
         * pxOverflowDelayedCoRoutineList using list2. */
        pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1442:	8b e8       	ldi	r24, 0x8B	; 139
    1444:	96 e0       	ldi	r25, 0x06	; 6
    1446:	90 93 6d 06 	sts	0x066D, r25
    144a:	80 93 6c 06 	sts	0x066C, r24
        pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    144e:	84 e9       	ldi	r24, 0x94	; 148
    1450:	96 e0       	ldi	r25, 0x06	; 6
    1452:	90 93 6f 06 	sts	0x066F, r25
    1456:	80 93 6e 06 	sts	0x066E, r24
    }
    145a:	0f 90       	pop	r0
    145c:	cf 91       	pop	r28
    145e:	df 91       	pop	r29
    1460:	08 95       	ret

00001462 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineRemoveFromEventList( const List_t * pxEventList )
    {
    1462:	df 93       	push	r29
    1464:	cf 93       	push	r28
    1466:	00 d0       	rcall	.+0      	; 0x1468 <xCoRoutineRemoveFromEventList+0x6>
    1468:	00 d0       	rcall	.+0      	; 0x146a <xCoRoutineRemoveFromEventList+0x8>
    146a:	0f 92       	push	r0
    146c:	cd b7       	in	r28, 0x3d	; 61
    146e:	de b7       	in	r29, 0x3e	; 62
    1470:	9d 83       	std	Y+5, r25	; 0x05
    1472:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;

        /* This function is called from within an interrupt.  It can only access
         * event lists and the pending ready list.  This function assumes that a
         * check has already been made to ensure pxEventList is not empty. */
        pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1474:	ec 81       	ldd	r30, Y+4	; 0x04
    1476:	fd 81       	ldd	r31, Y+5	; 0x05
    1478:	05 80       	ldd	r0, Z+5	; 0x05
    147a:	f6 81       	ldd	r31, Z+6	; 0x06
    147c:	e0 2d       	mov	r30, r0
    147e:	86 81       	ldd	r24, Z+6	; 0x06
    1480:	97 81       	ldd	r25, Z+7	; 0x07
    1482:	9b 83       	std	Y+3, r25	; 0x03
    1484:	8a 83       	std	Y+2, r24	; 0x02
        ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1486:	8a 81       	ldd	r24, Y+2	; 0x02
    1488:	9b 81       	ldd	r25, Y+3	; 0x03
    148a:	0c 96       	adiw	r24, 0x0c	; 12
    148c:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <uxListRemove>
        vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1490:	8a 81       	ldd	r24, Y+2	; 0x02
    1492:	9b 81       	ldd	r25, Y+3	; 0x03
    1494:	9c 01       	movw	r18, r24
    1496:	24 5f       	subi	r18, 0xF4	; 244
    1498:	3f 4f       	sbci	r19, 0xFF	; 255
    149a:	8d e9       	ldi	r24, 0x9D	; 157
    149c:	96 e0       	ldi	r25, 0x06	; 6
    149e:	b9 01       	movw	r22, r18
    14a0:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <vListInsertEnd>

        if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    14a4:	ea 81       	ldd	r30, Y+2	; 0x02
    14a6:	fb 81       	ldd	r31, Y+3	; 0x03
    14a8:	96 89       	ldd	r25, Z+22	; 0x16
    14aa:	e0 91 70 06 	lds	r30, 0x0670
    14ae:	f0 91 71 06 	lds	r31, 0x0671
    14b2:	86 89       	ldd	r24, Z+22	; 0x16
    14b4:	98 17       	cp	r25, r24
    14b6:	18 f0       	brcs	.+6      	; 0x14be <xCoRoutineRemoveFromEventList+0x5c>
        {
            xReturn = pdTRUE;
    14b8:	81 e0       	ldi	r24, 0x01	; 1
    14ba:	89 83       	std	Y+1, r24	; 0x01
    14bc:	01 c0       	rjmp	.+2      	; 0x14c0 <xCoRoutineRemoveFromEventList+0x5e>
        }
        else
        {
            xReturn = pdFALSE;
    14be:	19 82       	std	Y+1, r1	; 0x01
        }

        return xReturn;
    14c0:	89 81       	ldd	r24, Y+1	; 0x01
    }
    14c2:	0f 90       	pop	r0
    14c4:	0f 90       	pop	r0
    14c6:	0f 90       	pop	r0
    14c8:	0f 90       	pop	r0
    14ca:	0f 90       	pop	r0
    14cc:	cf 91       	pop	r28
    14ce:	df 91       	pop	r29
    14d0:	08 95       	ret

000014d2 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    14d2:	df 93       	push	r29
    14d4:	cf 93       	push	r28
    14d6:	00 d0       	rcall	.+0      	; 0x14d8 <xEventGroupCreate+0x6>
    14d8:	cd b7       	in	r28, 0x3d	; 61
    14da:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    14dc:	8b e0       	ldi	r24, 0x0B	; 11
    14de:	90 e0       	ldi	r25, 0x00	; 0
    14e0:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    14e4:	9a 83       	std	Y+2, r25	; 0x02
    14e6:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
    14e8:	89 81       	ldd	r24, Y+1	; 0x01
    14ea:	9a 81       	ldd	r25, Y+2	; 0x02
    14ec:	00 97       	sbiw	r24, 0x00	; 0
    14ee:	49 f0       	breq	.+18     	; 0x1502 <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
    14f0:	e9 81       	ldd	r30, Y+1	; 0x01
    14f2:	fa 81       	ldd	r31, Y+2	; 0x02
    14f4:	11 82       	std	Z+1, r1	; 0x01
    14f6:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    14f8:	89 81       	ldd	r24, Y+1	; 0x01
    14fa:	9a 81       	ldd	r25, Y+2	; 0x02
    14fc:	02 96       	adiw	r24, 0x02	; 2
    14fe:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    1502:	89 81       	ldd	r24, Y+1	; 0x01
    1504:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    1506:	0f 90       	pop	r0
    1508:	0f 90       	pop	r0
    150a:	cf 91       	pop	r28
    150c:	df 91       	pop	r29
    150e:	08 95       	ret

00001510 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    1510:	df 93       	push	r29
    1512:	cf 93       	push	r28
    1514:	cd b7       	in	r28, 0x3d	; 61
    1516:	de b7       	in	r29, 0x3e	; 62
    1518:	60 97       	sbiw	r28, 0x10	; 16
    151a:	0f b6       	in	r0, 0x3f	; 63
    151c:	f8 94       	cli
    151e:	de bf       	out	0x3e, r29	; 62
    1520:	0f be       	out	0x3f, r0	; 63
    1522:	cd bf       	out	0x3d, r28	; 61
    1524:	9a 87       	std	Y+10, r25	; 0x0a
    1526:	89 87       	std	Y+9, r24	; 0x09
    1528:	7c 87       	std	Y+12, r23	; 0x0c
    152a:	6b 87       	std	Y+11, r22	; 0x0b
    152c:	5e 87       	std	Y+14, r21	; 0x0e
    152e:	4d 87       	std	Y+13, r20	; 0x0d
    1530:	38 8b       	std	Y+16, r19	; 0x10
    1532:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    1534:	89 85       	ldd	r24, Y+9	; 0x09
    1536:	9a 85       	ldd	r25, Y+10	; 0x0a
    1538:	9c 83       	std	Y+4, r25	; 0x04
    153a:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    153c:	19 82       	std	Y+1, r1	; 0x01
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    153e:	0e 94 8b 1b 	call	0x3716	; 0x3716 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    1542:	eb 81       	ldd	r30, Y+3	; 0x03
    1544:	fc 81       	ldd	r31, Y+4	; 0x04
    1546:	80 81       	ld	r24, Z
    1548:	91 81       	ldd	r25, Z+1	; 0x01
    154a:	98 87       	std	Y+8, r25	; 0x08
    154c:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    154e:	89 85       	ldd	r24, Y+9	; 0x09
    1550:	9a 85       	ldd	r25, Y+10	; 0x0a
    1552:	2b 85       	ldd	r18, Y+11	; 0x0b
    1554:	3c 85       	ldd	r19, Y+12	; 0x0c
    1556:	b9 01       	movw	r22, r18
    1558:	0e 94 5f 0c 	call	0x18be	; 0x18be <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    155c:	2f 81       	ldd	r18, Y+7	; 0x07
    155e:	38 85       	ldd	r19, Y+8	; 0x08
    1560:	8b 85       	ldd	r24, Y+11	; 0x0b
    1562:	9c 85       	ldd	r25, Y+12	; 0x0c
    1564:	28 2b       	or	r18, r24
    1566:	39 2b       	or	r19, r25
    1568:	8d 85       	ldd	r24, Y+13	; 0x0d
    156a:	9e 85       	ldd	r25, Y+14	; 0x0e
    156c:	28 23       	and	r18, r24
    156e:	39 23       	and	r19, r25
    1570:	8d 85       	ldd	r24, Y+13	; 0x0d
    1572:	9e 85       	ldd	r25, Y+14	; 0x0e
    1574:	28 17       	cp	r18, r24
    1576:	39 07       	cpc	r19, r25
    1578:	c9 f4       	brne	.+50     	; 0x15ac <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    157a:	2f 81       	ldd	r18, Y+7	; 0x07
    157c:	38 85       	ldd	r19, Y+8	; 0x08
    157e:	8b 85       	ldd	r24, Y+11	; 0x0b
    1580:	9c 85       	ldd	r25, Y+12	; 0x0c
    1582:	82 2b       	or	r24, r18
    1584:	93 2b       	or	r25, r19
    1586:	9e 83       	std	Y+6, r25	; 0x06
    1588:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    158a:	eb 81       	ldd	r30, Y+3	; 0x03
    158c:	fc 81       	ldd	r31, Y+4	; 0x04
    158e:	20 81       	ld	r18, Z
    1590:	31 81       	ldd	r19, Z+1	; 0x01
    1592:	8d 85       	ldd	r24, Y+13	; 0x0d
    1594:	9e 85       	ldd	r25, Y+14	; 0x0e
    1596:	80 95       	com	r24
    1598:	90 95       	com	r25
    159a:	82 23       	and	r24, r18
    159c:	93 23       	and	r25, r19
    159e:	eb 81       	ldd	r30, Y+3	; 0x03
    15a0:	fc 81       	ldd	r31, Y+4	; 0x04
    15a2:	91 83       	std	Z+1, r25	; 0x01
    15a4:	80 83       	st	Z, r24

            xTicksToWait = 0;
    15a6:	18 8a       	std	Y+16, r1	; 0x10
    15a8:	1f 86       	std	Y+15, r1	; 0x0f
    15aa:	1e c0       	rjmp	.+60     	; 0x15e8 <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    15ac:	8f 85       	ldd	r24, Y+15	; 0x0f
    15ae:	98 89       	ldd	r25, Y+16	; 0x10
    15b0:	00 97       	sbiw	r24, 0x00	; 0
    15b2:	91 f0       	breq	.+36     	; 0x15d8 <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    15b4:	8b 81       	ldd	r24, Y+3	; 0x03
    15b6:	9c 81       	ldd	r25, Y+4	; 0x04
    15b8:	bc 01       	movw	r22, r24
    15ba:	6e 5f       	subi	r22, 0xFE	; 254
    15bc:	7f 4f       	sbci	r23, 0xFF	; 255
    15be:	8d 85       	ldd	r24, Y+13	; 0x0d
    15c0:	9e 85       	ldd	r25, Y+14	; 0x0e
    15c2:	9c 01       	movw	r18, r24
    15c4:	35 60       	ori	r19, 0x05	; 5
    15c6:	4f 85       	ldd	r20, Y+15	; 0x0f
    15c8:	58 89       	ldd	r21, Y+16	; 0x10
    15ca:	cb 01       	movw	r24, r22
    15cc:	b9 01       	movw	r22, r18
    15ce:	0e 94 8a 1f 	call	0x3f14	; 0x3f14 <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    15d2:	1e 82       	std	Y+6, r1	; 0x06
    15d4:	1d 82       	std	Y+5, r1	; 0x05
    15d6:	08 c0       	rjmp	.+16     	; 0x15e8 <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    15d8:	eb 81       	ldd	r30, Y+3	; 0x03
    15da:	fc 81       	ldd	r31, Y+4	; 0x04
    15dc:	80 81       	ld	r24, Z
    15de:	91 81       	ldd	r25, Z+1	; 0x01
    15e0:	9e 83       	std	Y+6, r25	; 0x06
    15e2:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
    15e4:	81 e0       	ldi	r24, 0x01	; 1
    15e6:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    15e8:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>
    15ec:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
    15ee:	8f 85       	ldd	r24, Y+15	; 0x0f
    15f0:	98 89       	ldd	r25, Y+16	; 0x10
    15f2:	00 97       	sbiw	r24, 0x00	; 0
    15f4:	09 f4       	brne	.+2      	; 0x15f8 <xEventGroupSync+0xe8>
    15f6:	3a c0       	rjmp	.+116    	; 0x166c <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
    15f8:	8a 81       	ldd	r24, Y+2	; 0x02
    15fa:	88 23       	and	r24, r24
    15fc:	11 f4       	brne	.+4      	; 0x1602 <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
    15fe:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1602:	0e 94 18 24 	call	0x4830	; 0x4830 <uxTaskResetEventItemValue>
    1606:	9e 83       	std	Y+6, r25	; 0x06
    1608:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    160a:	8d 81       	ldd	r24, Y+5	; 0x05
    160c:	9e 81       	ldd	r25, Y+6	; 0x06
    160e:	80 70       	andi	r24, 0x00	; 0
    1610:	92 70       	andi	r25, 0x02	; 2
    1612:	00 97       	sbiw	r24, 0x00	; 0
    1614:	31 f5       	brne	.+76     	; 0x1662 <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    1616:	0f b6       	in	r0, 0x3f	; 63
    1618:	f8 94       	cli
    161a:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    161c:	eb 81       	ldd	r30, Y+3	; 0x03
    161e:	fc 81       	ldd	r31, Y+4	; 0x04
    1620:	80 81       	ld	r24, Z
    1622:	91 81       	ldd	r25, Z+1	; 0x01
    1624:	9e 83       	std	Y+6, r25	; 0x06
    1626:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1628:	2d 81       	ldd	r18, Y+5	; 0x05
    162a:	3e 81       	ldd	r19, Y+6	; 0x06
    162c:	8d 85       	ldd	r24, Y+13	; 0x0d
    162e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1630:	28 23       	and	r18, r24
    1632:	39 23       	and	r19, r25
    1634:	8d 85       	ldd	r24, Y+13	; 0x0d
    1636:	9e 85       	ldd	r25, Y+14	; 0x0e
    1638:	28 17       	cp	r18, r24
    163a:	39 07       	cpc	r19, r25
    163c:	71 f4       	brne	.+28     	; 0x165a <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    163e:	eb 81       	ldd	r30, Y+3	; 0x03
    1640:	fc 81       	ldd	r31, Y+4	; 0x04
    1642:	20 81       	ld	r18, Z
    1644:	31 81       	ldd	r19, Z+1	; 0x01
    1646:	8d 85       	ldd	r24, Y+13	; 0x0d
    1648:	9e 85       	ldd	r25, Y+14	; 0x0e
    164a:	80 95       	com	r24
    164c:	90 95       	com	r25
    164e:	82 23       	and	r24, r18
    1650:	93 23       	and	r25, r19
    1652:	eb 81       	ldd	r30, Y+3	; 0x03
    1654:	fc 81       	ldd	r31, Y+4	; 0x04
    1656:	91 83       	std	Z+1, r25	; 0x01
    1658:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    165a:	0f 90       	pop	r0
    165c:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
    165e:	81 e0       	ldi	r24, 0x01	; 1
    1660:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1662:	8d 81       	ldd	r24, Y+5	; 0x05
    1664:	9e 81       	ldd	r25, Y+6	; 0x06
    1666:	90 70       	andi	r25, 0x00	; 0
    1668:	9e 83       	std	Y+6, r25	; 0x06
    166a:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    166c:	8d 81       	ldd	r24, Y+5	; 0x05
    166e:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1670:	60 96       	adiw	r28, 0x10	; 16
    1672:	0f b6       	in	r0, 0x3f	; 63
    1674:	f8 94       	cli
    1676:	de bf       	out	0x3e, r29	; 62
    1678:	0f be       	out	0x3f, r0	; 63
    167a:	cd bf       	out	0x3d, r28	; 61
    167c:	cf 91       	pop	r28
    167e:	df 91       	pop	r29
    1680:	08 95       	ret

00001682 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    1682:	0f 93       	push	r16
    1684:	1f 93       	push	r17
    1686:	df 93       	push	r29
    1688:	cf 93       	push	r28
    168a:	cd b7       	in	r28, 0x3d	; 61
    168c:	de b7       	in	r29, 0x3e	; 62
    168e:	63 97       	sbiw	r28, 0x13	; 19
    1690:	0f b6       	in	r0, 0x3f	; 63
    1692:	f8 94       	cli
    1694:	de bf       	out	0x3e, r29	; 62
    1696:	0f be       	out	0x3f, r0	; 63
    1698:	cd bf       	out	0x3d, r28	; 61
    169a:	9d 87       	std	Y+13, r25	; 0x0d
    169c:	8c 87       	std	Y+12, r24	; 0x0c
    169e:	7f 87       	std	Y+15, r23	; 0x0f
    16a0:	6e 87       	std	Y+14, r22	; 0x0e
    16a2:	48 8b       	std	Y+16, r20	; 0x10
    16a4:	29 8b       	std	Y+17, r18	; 0x11
    16a6:	1b 8b       	std	Y+19, r17	; 0x13
    16a8:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
    16aa:	8c 85       	ldd	r24, Y+12	; 0x0c
    16ac:	9d 85       	ldd	r25, Y+13	; 0x0d
    16ae:	9b 87       	std	Y+11, r25	; 0x0b
    16b0:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
    16b2:	1f 82       	std	Y+7, r1	; 0x07
    16b4:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    16b6:	1b 82       	std	Y+3, r1	; 0x03
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    16b8:	0e 94 8b 1b 	call	0x3716	; 0x3716 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    16bc:	ea 85       	ldd	r30, Y+10	; 0x0a
    16be:	fb 85       	ldd	r31, Y+11	; 0x0b
    16c0:	80 81       	ld	r24, Z
    16c2:	91 81       	ldd	r25, Z+1	; 0x01
    16c4:	9a 83       	std	Y+2, r25	; 0x02
    16c6:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    16c8:	89 81       	ldd	r24, Y+1	; 0x01
    16ca:	9a 81       	ldd	r25, Y+2	; 0x02
    16cc:	2e 85       	ldd	r18, Y+14	; 0x0e
    16ce:	3f 85       	ldd	r19, Y+15	; 0x0f
    16d0:	b9 01       	movw	r22, r18
    16d2:	49 89       	ldd	r20, Y+17	; 0x11
    16d4:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <prvTestWaitCondition>
    16d8:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
    16da:	8d 81       	ldd	r24, Y+5	; 0x05
    16dc:	88 23       	and	r24, r24
    16de:	c1 f0       	breq	.+48     	; 0x1710 <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    16e0:	89 81       	ldd	r24, Y+1	; 0x01
    16e2:	9a 81       	ldd	r25, Y+2	; 0x02
    16e4:	99 87       	std	Y+9, r25	; 0x09
    16e6:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
    16e8:	1b 8a       	std	Y+19, r1	; 0x13
    16ea:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    16ec:	88 89       	ldd	r24, Y+16	; 0x10
    16ee:	88 23       	and	r24, r24
    16f0:	e9 f1       	breq	.+122    	; 0x176c <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    16f2:	ea 85       	ldd	r30, Y+10	; 0x0a
    16f4:	fb 85       	ldd	r31, Y+11	; 0x0b
    16f6:	20 81       	ld	r18, Z
    16f8:	31 81       	ldd	r19, Z+1	; 0x01
    16fa:	8e 85       	ldd	r24, Y+14	; 0x0e
    16fc:	9f 85       	ldd	r25, Y+15	; 0x0f
    16fe:	80 95       	com	r24
    1700:	90 95       	com	r25
    1702:	82 23       	and	r24, r18
    1704:	93 23       	and	r25, r19
    1706:	ea 85       	ldd	r30, Y+10	; 0x0a
    1708:	fb 85       	ldd	r31, Y+11	; 0x0b
    170a:	91 83       	std	Z+1, r25	; 0x01
    170c:	80 83       	st	Z, r24
    170e:	2e c0       	rjmp	.+92     	; 0x176c <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    1710:	8a 89       	ldd	r24, Y+18	; 0x12
    1712:	9b 89       	ldd	r25, Y+19	; 0x13
    1714:	00 97       	sbiw	r24, 0x00	; 0
    1716:	39 f4       	brne	.+14     	; 0x1726 <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    1718:	89 81       	ldd	r24, Y+1	; 0x01
    171a:	9a 81       	ldd	r25, Y+2	; 0x02
    171c:	99 87       	std	Y+9, r25	; 0x09
    171e:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
    1720:	81 e0       	ldi	r24, 0x01	; 1
    1722:	8b 83       	std	Y+3, r24	; 0x03
    1724:	23 c0       	rjmp	.+70     	; 0x176c <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    1726:	88 89       	ldd	r24, Y+16	; 0x10
    1728:	88 23       	and	r24, r24
    172a:	29 f0       	breq	.+10     	; 0x1736 <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    172c:	8e 81       	ldd	r24, Y+6	; 0x06
    172e:	9f 81       	ldd	r25, Y+7	; 0x07
    1730:	91 60       	ori	r25, 0x01	; 1
    1732:	9f 83       	std	Y+7, r25	; 0x07
    1734:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    1736:	89 89       	ldd	r24, Y+17	; 0x11
    1738:	88 23       	and	r24, r24
    173a:	29 f0       	breq	.+10     	; 0x1746 <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    173c:	8e 81       	ldd	r24, Y+6	; 0x06
    173e:	9f 81       	ldd	r25, Y+7	; 0x07
    1740:	94 60       	ori	r25, 0x04	; 4
    1742:	9f 83       	std	Y+7, r25	; 0x07
    1744:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    1746:	8a 85       	ldd	r24, Y+10	; 0x0a
    1748:	9b 85       	ldd	r25, Y+11	; 0x0b
    174a:	bc 01       	movw	r22, r24
    174c:	6e 5f       	subi	r22, 0xFE	; 254
    174e:	7f 4f       	sbci	r23, 0xFF	; 255
    1750:	2e 85       	ldd	r18, Y+14	; 0x0e
    1752:	3f 85       	ldd	r19, Y+15	; 0x0f
    1754:	8e 81       	ldd	r24, Y+6	; 0x06
    1756:	9f 81       	ldd	r25, Y+7	; 0x07
    1758:	28 2b       	or	r18, r24
    175a:	39 2b       	or	r19, r25
    175c:	4a 89       	ldd	r20, Y+18	; 0x12
    175e:	5b 89       	ldd	r21, Y+19	; 0x13
    1760:	cb 01       	movw	r24, r22
    1762:	b9 01       	movw	r22, r18
    1764:	0e 94 8a 1f 	call	0x3f14	; 0x3f14 <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    1768:	19 86       	std	Y+9, r1	; 0x09
    176a:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    176c:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>
    1770:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
    1772:	8a 89       	ldd	r24, Y+18	; 0x12
    1774:	9b 89       	ldd	r25, Y+19	; 0x13
    1776:	00 97       	sbiw	r24, 0x00	; 0
    1778:	09 f4       	brne	.+2      	; 0x177c <xEventGroupWaitBits+0xfa>
    177a:	3c c0       	rjmp	.+120    	; 0x17f4 <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
    177c:	8c 81       	ldd	r24, Y+4	; 0x04
    177e:	88 23       	and	r24, r24
    1780:	11 f4       	brne	.+4      	; 0x1786 <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
    1782:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1786:	0e 94 18 24 	call	0x4830	; 0x4830 <uxTaskResetEventItemValue>
    178a:	99 87       	std	Y+9, r25	; 0x09
    178c:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    178e:	88 85       	ldd	r24, Y+8	; 0x08
    1790:	99 85       	ldd	r25, Y+9	; 0x09
    1792:	80 70       	andi	r24, 0x00	; 0
    1794:	92 70       	andi	r25, 0x02	; 2
    1796:	00 97       	sbiw	r24, 0x00	; 0
    1798:	41 f5       	brne	.+80     	; 0x17ea <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
    179a:	0f b6       	in	r0, 0x3f	; 63
    179c:	f8 94       	cli
    179e:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    17a0:	ea 85       	ldd	r30, Y+10	; 0x0a
    17a2:	fb 85       	ldd	r31, Y+11	; 0x0b
    17a4:	80 81       	ld	r24, Z
    17a6:	91 81       	ldd	r25, Z+1	; 0x01
    17a8:	99 87       	std	Y+9, r25	; 0x09
    17aa:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    17ac:	88 85       	ldd	r24, Y+8	; 0x08
    17ae:	99 85       	ldd	r25, Y+9	; 0x09
    17b0:	2e 85       	ldd	r18, Y+14	; 0x0e
    17b2:	3f 85       	ldd	r19, Y+15	; 0x0f
    17b4:	b9 01       	movw	r22, r18
    17b6:	49 89       	ldd	r20, Y+17	; 0x11
    17b8:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <prvTestWaitCondition>
    17bc:	88 23       	and	r24, r24
    17be:	89 f0       	breq	.+34     	; 0x17e2 <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
    17c0:	88 89       	ldd	r24, Y+16	; 0x10
    17c2:	88 23       	and	r24, r24
    17c4:	71 f0       	breq	.+28     	; 0x17e2 <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    17c6:	ea 85       	ldd	r30, Y+10	; 0x0a
    17c8:	fb 85       	ldd	r31, Y+11	; 0x0b
    17ca:	20 81       	ld	r18, Z
    17cc:	31 81       	ldd	r19, Z+1	; 0x01
    17ce:	8e 85       	ldd	r24, Y+14	; 0x0e
    17d0:	9f 85       	ldd	r25, Y+15	; 0x0f
    17d2:	80 95       	com	r24
    17d4:	90 95       	com	r25
    17d6:	82 23       	and	r24, r18
    17d8:	93 23       	and	r25, r19
    17da:	ea 85       	ldd	r30, Y+10	; 0x0a
    17dc:	fb 85       	ldd	r31, Y+11	; 0x0b
    17de:	91 83       	std	Z+1, r25	; 0x01
    17e0:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    17e2:	81 e0       	ldi	r24, 0x01	; 1
    17e4:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    17e6:	0f 90       	pop	r0
    17e8:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    17ea:	88 85       	ldd	r24, Y+8	; 0x08
    17ec:	99 85       	ldd	r25, Y+9	; 0x09
    17ee:	90 70       	andi	r25, 0x00	; 0
    17f0:	99 87       	std	Y+9, r25	; 0x09
    17f2:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    17f4:	88 85       	ldd	r24, Y+8	; 0x08
    17f6:	99 85       	ldd	r25, Y+9	; 0x09
}
    17f8:	63 96       	adiw	r28, 0x13	; 19
    17fa:	0f b6       	in	r0, 0x3f	; 63
    17fc:	f8 94       	cli
    17fe:	de bf       	out	0x3e, r29	; 62
    1800:	0f be       	out	0x3f, r0	; 63
    1802:	cd bf       	out	0x3d, r28	; 61
    1804:	cf 91       	pop	r28
    1806:	df 91       	pop	r29
    1808:	1f 91       	pop	r17
    180a:	0f 91       	pop	r16
    180c:	08 95       	ret

0000180e <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    180e:	df 93       	push	r29
    1810:	cf 93       	push	r28
    1812:	cd b7       	in	r28, 0x3d	; 61
    1814:	de b7       	in	r29, 0x3e	; 62
    1816:	28 97       	sbiw	r28, 0x08	; 8
    1818:	0f b6       	in	r0, 0x3f	; 63
    181a:	f8 94       	cli
    181c:	de bf       	out	0x3e, r29	; 62
    181e:	0f be       	out	0x3f, r0	; 63
    1820:	cd bf       	out	0x3d, r28	; 61
    1822:	9e 83       	std	Y+6, r25	; 0x06
    1824:	8d 83       	std	Y+5, r24	; 0x05
    1826:	78 87       	std	Y+8, r23	; 0x08
    1828:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    182a:	8d 81       	ldd	r24, Y+5	; 0x05
    182c:	9e 81       	ldd	r25, Y+6	; 0x06
    182e:	9c 83       	std	Y+4, r25	; 0x04
    1830:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    1832:	0f b6       	in	r0, 0x3f	; 63
    1834:	f8 94       	cli
    1836:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    1838:	eb 81       	ldd	r30, Y+3	; 0x03
    183a:	fc 81       	ldd	r31, Y+4	; 0x04
    183c:	80 81       	ld	r24, Z
    183e:	91 81       	ldd	r25, Z+1	; 0x01
    1840:	9a 83       	std	Y+2, r25	; 0x02
    1842:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    1844:	eb 81       	ldd	r30, Y+3	; 0x03
    1846:	fc 81       	ldd	r31, Y+4	; 0x04
    1848:	20 81       	ld	r18, Z
    184a:	31 81       	ldd	r19, Z+1	; 0x01
    184c:	8f 81       	ldd	r24, Y+7	; 0x07
    184e:	98 85       	ldd	r25, Y+8	; 0x08
    1850:	80 95       	com	r24
    1852:	90 95       	com	r25
    1854:	82 23       	and	r24, r18
    1856:	93 23       	and	r25, r19
    1858:	eb 81       	ldd	r30, Y+3	; 0x03
    185a:	fc 81       	ldd	r31, Y+4	; 0x04
    185c:	91 83       	std	Z+1, r25	; 0x01
    185e:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    1860:	0f 90       	pop	r0
    1862:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    1864:	89 81       	ldd	r24, Y+1	; 0x01
    1866:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1868:	28 96       	adiw	r28, 0x08	; 8
    186a:	0f b6       	in	r0, 0x3f	; 63
    186c:	f8 94       	cli
    186e:	de bf       	out	0x3e, r29	; 62
    1870:	0f be       	out	0x3f, r0	; 63
    1872:	cd bf       	out	0x3d, r28	; 61
    1874:	cf 91       	pop	r28
    1876:	df 91       	pop	r29
    1878:	08 95       	ret

0000187a <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    187a:	df 93       	push	r29
    187c:	cf 93       	push	r28
    187e:	cd b7       	in	r28, 0x3d	; 61
    1880:	de b7       	in	r29, 0x3e	; 62
    1882:	27 97       	sbiw	r28, 0x07	; 7
    1884:	0f b6       	in	r0, 0x3f	; 63
    1886:	f8 94       	cli
    1888:	de bf       	out	0x3e, r29	; 62
    188a:	0f be       	out	0x3f, r0	; 63
    188c:	cd bf       	out	0x3d, r28	; 61
    188e:	9f 83       	std	Y+7, r25	; 0x07
    1890:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    1892:	8e 81       	ldd	r24, Y+6	; 0x06
    1894:	9f 81       	ldd	r25, Y+7	; 0x07
    1896:	9c 83       	std	Y+4, r25	; 0x04
    1898:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    189a:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    189c:	eb 81       	ldd	r30, Y+3	; 0x03
    189e:	fc 81       	ldd	r31, Y+4	; 0x04
    18a0:	80 81       	ld	r24, Z
    18a2:	91 81       	ldd	r25, Z+1	; 0x01
    18a4:	9a 83       	std	Y+2, r25	; 0x02
    18a6:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    18a8:	89 81       	ldd	r24, Y+1	; 0x01
    18aa:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    18ac:	27 96       	adiw	r28, 0x07	; 7
    18ae:	0f b6       	in	r0, 0x3f	; 63
    18b0:	f8 94       	cli
    18b2:	de bf       	out	0x3e, r29	; 62
    18b4:	0f be       	out	0x3f, r0	; 63
    18b6:	cd bf       	out	0x3d, r28	; 61
    18b8:	cf 91       	pop	r28
    18ba:	df 91       	pop	r29
    18bc:	08 95       	ret

000018be <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    18be:	df 93       	push	r29
    18c0:	cf 93       	push	r28
    18c2:	cd b7       	in	r28, 0x3d	; 61
    18c4:	de b7       	in	r29, 0x3e	; 62
    18c6:	65 97       	sbiw	r28, 0x15	; 21
    18c8:	0f b6       	in	r0, 0x3f	; 63
    18ca:	f8 94       	cli
    18cc:	de bf       	out	0x3e, r29	; 62
    18ce:	0f be       	out	0x3f, r0	; 63
    18d0:	cd bf       	out	0x3d, r28	; 61
    18d2:	9b 8b       	std	Y+19, r25	; 0x13
    18d4:	8a 8b       	std	Y+18, r24	; 0x12
    18d6:	7d 8b       	std	Y+21, r23	; 0x15
    18d8:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    18da:	19 86       	std	Y+9, r1	; 0x09
    18dc:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    18de:	8a 89       	ldd	r24, Y+18	; 0x12
    18e0:	9b 89       	ldd	r25, Y+19	; 0x13
    18e2:	9b 83       	std	Y+3, r25	; 0x03
    18e4:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    18e6:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    18e8:	8a 81       	ldd	r24, Y+2	; 0x02
    18ea:	9b 81       	ldd	r25, Y+3	; 0x03
    18ec:	02 96       	adiw	r24, 0x02	; 2
    18ee:	9b 87       	std	Y+11, r25	; 0x0b
    18f0:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    18f2:	8a 85       	ldd	r24, Y+10	; 0x0a
    18f4:	9b 85       	ldd	r25, Y+11	; 0x0b
    18f6:	03 96       	adiw	r24, 0x03	; 3
    18f8:	9d 87       	std	Y+13, r25	; 0x0d
    18fa:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    18fc:	0e 94 8b 1b 	call	0x3716	; 0x3716 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    1900:	ea 85       	ldd	r30, Y+10	; 0x0a
    1902:	fb 85       	ldd	r31, Y+11	; 0x0b
    1904:	85 81       	ldd	r24, Z+5	; 0x05
    1906:	96 81       	ldd	r25, Z+6	; 0x06
    1908:	99 8b       	std	Y+17, r25	; 0x11
    190a:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    190c:	ea 81       	ldd	r30, Y+2	; 0x02
    190e:	fb 81       	ldd	r31, Y+3	; 0x03
    1910:	20 81       	ld	r18, Z
    1912:	31 81       	ldd	r19, Z+1	; 0x01
    1914:	8c 89       	ldd	r24, Y+20	; 0x14
    1916:	9d 89       	ldd	r25, Y+21	; 0x15
    1918:	82 2b       	or	r24, r18
    191a:	93 2b       	or	r25, r19
    191c:	ea 81       	ldd	r30, Y+2	; 0x02
    191e:	fb 81       	ldd	r31, Y+3	; 0x03
    1920:	91 83       	std	Z+1, r25	; 0x01
    1922:	80 83       	st	Z, r24
    1924:	59 c0       	rjmp	.+178    	; 0x19d8 <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    1926:	e8 89       	ldd	r30, Y+16	; 0x10
    1928:	f9 89       	ldd	r31, Y+17	; 0x11
    192a:	82 81       	ldd	r24, Z+2	; 0x02
    192c:	93 81       	ldd	r25, Z+3	; 0x03
    192e:	9f 87       	std	Y+15, r25	; 0x0f
    1930:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1932:	e8 89       	ldd	r30, Y+16	; 0x10
    1934:	f9 89       	ldd	r31, Y+17	; 0x11
    1936:	80 81       	ld	r24, Z
    1938:	91 81       	ldd	r25, Z+1	; 0x01
    193a:	9f 83       	std	Y+7, r25	; 0x07
    193c:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    193e:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    1940:	8e 81       	ldd	r24, Y+6	; 0x06
    1942:	9f 81       	ldd	r25, Y+7	; 0x07
    1944:	80 70       	andi	r24, 0x00	; 0
    1946:	9d 83       	std	Y+5, r25	; 0x05
    1948:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    194a:	8e 81       	ldd	r24, Y+6	; 0x06
    194c:	9f 81       	ldd	r25, Y+7	; 0x07
    194e:	90 70       	andi	r25, 0x00	; 0
    1950:	9f 83       	std	Y+7, r25	; 0x07
    1952:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    1954:	8c 81       	ldd	r24, Y+4	; 0x04
    1956:	9d 81       	ldd	r25, Y+5	; 0x05
    1958:	80 70       	andi	r24, 0x00	; 0
    195a:	94 70       	andi	r25, 0x04	; 4
    195c:	00 97       	sbiw	r24, 0x00	; 0
    195e:	69 f4       	brne	.+26     	; 0x197a <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    1960:	ea 81       	ldd	r30, Y+2	; 0x02
    1962:	fb 81       	ldd	r31, Y+3	; 0x03
    1964:	20 81       	ld	r18, Z
    1966:	31 81       	ldd	r19, Z+1	; 0x01
    1968:	8e 81       	ldd	r24, Y+6	; 0x06
    196a:	9f 81       	ldd	r25, Y+7	; 0x07
    196c:	82 23       	and	r24, r18
    196e:	93 23       	and	r25, r19
    1970:	00 97       	sbiw	r24, 0x00	; 0
    1972:	91 f0       	breq	.+36     	; 0x1998 <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    1974:	81 e0       	ldi	r24, 0x01	; 1
    1976:	89 83       	std	Y+1, r24	; 0x01
    1978:	0f c0       	rjmp	.+30     	; 0x1998 <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    197a:	ea 81       	ldd	r30, Y+2	; 0x02
    197c:	fb 81       	ldd	r31, Y+3	; 0x03
    197e:	20 81       	ld	r18, Z
    1980:	31 81       	ldd	r19, Z+1	; 0x01
    1982:	8e 81       	ldd	r24, Y+6	; 0x06
    1984:	9f 81       	ldd	r25, Y+7	; 0x07
    1986:	28 23       	and	r18, r24
    1988:	39 23       	and	r19, r25
    198a:	8e 81       	ldd	r24, Y+6	; 0x06
    198c:	9f 81       	ldd	r25, Y+7	; 0x07
    198e:	28 17       	cp	r18, r24
    1990:	39 07       	cpc	r19, r25
    1992:	11 f4       	brne	.+4      	; 0x1998 <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    1994:	81 e0       	ldi	r24, 0x01	; 1
    1996:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    1998:	89 81       	ldd	r24, Y+1	; 0x01
    199a:	88 23       	and	r24, r24
    199c:	c9 f0       	breq	.+50     	; 0x19d0 <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    199e:	8c 81       	ldd	r24, Y+4	; 0x04
    19a0:	9d 81       	ldd	r25, Y+5	; 0x05
    19a2:	80 70       	andi	r24, 0x00	; 0
    19a4:	91 70       	andi	r25, 0x01	; 1
    19a6:	00 97       	sbiw	r24, 0x00	; 0
    19a8:	41 f0       	breq	.+16     	; 0x19ba <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    19aa:	88 85       	ldd	r24, Y+8	; 0x08
    19ac:	99 85       	ldd	r25, Y+9	; 0x09
    19ae:	2e 81       	ldd	r18, Y+6	; 0x06
    19b0:	3f 81       	ldd	r19, Y+7	; 0x07
    19b2:	82 2b       	or	r24, r18
    19b4:	93 2b       	or	r25, r19
    19b6:	99 87       	std	Y+9, r25	; 0x09
    19b8:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    19ba:	ea 81       	ldd	r30, Y+2	; 0x02
    19bc:	fb 81       	ldd	r31, Y+3	; 0x03
    19be:	80 81       	ld	r24, Z
    19c0:	91 81       	ldd	r25, Z+1	; 0x01
    19c2:	9c 01       	movw	r18, r24
    19c4:	32 60       	ori	r19, 0x02	; 2
    19c6:	88 89       	ldd	r24, Y+16	; 0x10
    19c8:	99 89       	ldd	r25, Y+17	; 0x11
    19ca:	b9 01       	movw	r22, r18
    19cc:	0e 94 95 21 	call	0x432a	; 0x432a <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    19d0:	8e 85       	ldd	r24, Y+14	; 0x0e
    19d2:	9f 85       	ldd	r25, Y+15	; 0x0f
    19d4:	99 8b       	std	Y+17, r25	; 0x11
    19d6:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    19d8:	28 89       	ldd	r18, Y+16	; 0x10
    19da:	39 89       	ldd	r19, Y+17	; 0x11
    19dc:	8c 85       	ldd	r24, Y+12	; 0x0c
    19de:	9d 85       	ldd	r25, Y+13	; 0x0d
    19e0:	28 17       	cp	r18, r24
    19e2:	39 07       	cpc	r19, r25
    19e4:	09 f0       	breq	.+2      	; 0x19e8 <xEventGroupSetBits+0x12a>
    19e6:	9f cf       	rjmp	.-194    	; 0x1926 <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    19e8:	ea 81       	ldd	r30, Y+2	; 0x02
    19ea:	fb 81       	ldd	r31, Y+3	; 0x03
    19ec:	20 81       	ld	r18, Z
    19ee:	31 81       	ldd	r19, Z+1	; 0x01
    19f0:	88 85       	ldd	r24, Y+8	; 0x08
    19f2:	99 85       	ldd	r25, Y+9	; 0x09
    19f4:	80 95       	com	r24
    19f6:	90 95       	com	r25
    19f8:	82 23       	and	r24, r18
    19fa:	93 23       	and	r25, r19
    19fc:	ea 81       	ldd	r30, Y+2	; 0x02
    19fe:	fb 81       	ldd	r31, Y+3	; 0x03
    1a00:	91 83       	std	Z+1, r25	; 0x01
    1a02:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    1a04:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    1a08:	ea 81       	ldd	r30, Y+2	; 0x02
    1a0a:	fb 81       	ldd	r31, Y+3	; 0x03
    1a0c:	80 81       	ld	r24, Z
    1a0e:	91 81       	ldd	r25, Z+1	; 0x01
}
    1a10:	65 96       	adiw	r28, 0x15	; 21
    1a12:	0f b6       	in	r0, 0x3f	; 63
    1a14:	f8 94       	cli
    1a16:	de bf       	out	0x3e, r29	; 62
    1a18:	0f be       	out	0x3f, r0	; 63
    1a1a:	cd bf       	out	0x3d, r28	; 61
    1a1c:	cf 91       	pop	r28
    1a1e:	df 91       	pop	r29
    1a20:	08 95       	ret

00001a22 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1a22:	df 93       	push	r29
    1a24:	cf 93       	push	r28
    1a26:	00 d0       	rcall	.+0      	; 0x1a28 <vEventGroupDelete+0x6>
    1a28:	00 d0       	rcall	.+0      	; 0x1a2a <vEventGroupDelete+0x8>
    1a2a:	00 d0       	rcall	.+0      	; 0x1a2c <vEventGroupDelete+0xa>
    1a2c:	cd b7       	in	r28, 0x3d	; 61
    1a2e:	de b7       	in	r29, 0x3e	; 62
    1a30:	9e 83       	std	Y+6, r25	; 0x06
    1a32:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    1a34:	8d 81       	ldd	r24, Y+5	; 0x05
    1a36:	9e 81       	ldd	r25, Y+6	; 0x06
    1a38:	9c 83       	std	Y+4, r25	; 0x04
    1a3a:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1a3c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a3e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a40:	02 96       	adiw	r24, 0x02	; 2
    1a42:	9a 83       	std	Y+2, r25	; 0x02
    1a44:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    1a46:	0e 94 8b 1b 	call	0x3716	; 0x3716 <vTaskSuspendAll>
    1a4a:	08 c0       	rjmp	.+16     	; 0x1a5c <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1a4c:	e9 81       	ldd	r30, Y+1	; 0x01
    1a4e:	fa 81       	ldd	r31, Y+2	; 0x02
    1a50:	85 81       	ldd	r24, Z+5	; 0x05
    1a52:	96 81       	ldd	r25, Z+6	; 0x06
    1a54:	60 e0       	ldi	r22, 0x00	; 0
    1a56:	72 e0       	ldi	r23, 0x02	; 2
    1a58:	0e 94 95 21 	call	0x432a	; 0x432a <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1a5c:	e9 81       	ldd	r30, Y+1	; 0x01
    1a5e:	fa 81       	ldd	r31, Y+2	; 0x02
    1a60:	80 81       	ld	r24, Z
    1a62:	88 23       	and	r24, r24
    1a64:	99 f7       	brne	.-26     	; 0x1a4c <vEventGroupDelete+0x2a>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
    1a66:	8b 81       	ldd	r24, Y+3	; 0x03
    1a68:	9c 81       	ldd	r25, Y+4	; 0x04
    1a6a:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
    1a6e:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>
}
    1a72:	26 96       	adiw	r28, 0x06	; 6
    1a74:	0f b6       	in	r0, 0x3f	; 63
    1a76:	f8 94       	cli
    1a78:	de bf       	out	0x3e, r29	; 62
    1a7a:	0f be       	out	0x3f, r0	; 63
    1a7c:	cd bf       	out	0x3d, r28	; 61
    1a7e:	cf 91       	pop	r28
    1a80:	df 91       	pop	r29
    1a82:	08 95       	ret

00001a84 <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    1a84:	df 93       	push	r29
    1a86:	cf 93       	push	r28
    1a88:	00 d0       	rcall	.+0      	; 0x1a8a <vEventGroupSetBitsCallback+0x6>
    1a8a:	00 d0       	rcall	.+0      	; 0x1a8c <vEventGroupSetBitsCallback+0x8>
    1a8c:	00 d0       	rcall	.+0      	; 0x1a8e <vEventGroupSetBitsCallback+0xa>
    1a8e:	cd b7       	in	r28, 0x3d	; 61
    1a90:	de b7       	in	r29, 0x3e	; 62
    1a92:	9a 83       	std	Y+2, r25	; 0x02
    1a94:	89 83       	std	Y+1, r24	; 0x01
    1a96:	4b 83       	std	Y+3, r20	; 0x03
    1a98:	5c 83       	std	Y+4, r21	; 0x04
    1a9a:	6d 83       	std	Y+5, r22	; 0x05
    1a9c:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1a9e:	89 81       	ldd	r24, Y+1	; 0x01
    1aa0:	9a 81       	ldd	r25, Y+2	; 0x02
    1aa2:	2b 81       	ldd	r18, Y+3	; 0x03
    1aa4:	3c 81       	ldd	r19, Y+4	; 0x04
    1aa6:	b9 01       	movw	r22, r18
    1aa8:	0e 94 5f 0c 	call	0x18be	; 0x18be <xEventGroupSetBits>
}
    1aac:	26 96       	adiw	r28, 0x06	; 6
    1aae:	0f b6       	in	r0, 0x3f	; 63
    1ab0:	f8 94       	cli
    1ab2:	de bf       	out	0x3e, r29	; 62
    1ab4:	0f be       	out	0x3f, r0	; 63
    1ab6:	cd bf       	out	0x3d, r28	; 61
    1ab8:	cf 91       	pop	r28
    1aba:	df 91       	pop	r29
    1abc:	08 95       	ret

00001abe <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    1abe:	df 93       	push	r29
    1ac0:	cf 93       	push	r28
    1ac2:	00 d0       	rcall	.+0      	; 0x1ac4 <vEventGroupClearBitsCallback+0x6>
    1ac4:	00 d0       	rcall	.+0      	; 0x1ac6 <vEventGroupClearBitsCallback+0x8>
    1ac6:	00 d0       	rcall	.+0      	; 0x1ac8 <vEventGroupClearBitsCallback+0xa>
    1ac8:	cd b7       	in	r28, 0x3d	; 61
    1aca:	de b7       	in	r29, 0x3e	; 62
    1acc:	9a 83       	std	Y+2, r25	; 0x02
    1ace:	89 83       	std	Y+1, r24	; 0x01
    1ad0:	4b 83       	std	Y+3, r20	; 0x03
    1ad2:	5c 83       	std	Y+4, r21	; 0x04
    1ad4:	6d 83       	std	Y+5, r22	; 0x05
    1ad6:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1ad8:	89 81       	ldd	r24, Y+1	; 0x01
    1ada:	9a 81       	ldd	r25, Y+2	; 0x02
    1adc:	2b 81       	ldd	r18, Y+3	; 0x03
    1ade:	3c 81       	ldd	r19, Y+4	; 0x04
    1ae0:	b9 01       	movw	r22, r18
    1ae2:	0e 94 07 0c 	call	0x180e	; 0x180e <xEventGroupClearBits>
}
    1ae6:	26 96       	adiw	r28, 0x06	; 6
    1ae8:	0f b6       	in	r0, 0x3f	; 63
    1aea:	f8 94       	cli
    1aec:	de bf       	out	0x3e, r29	; 62
    1aee:	0f be       	out	0x3f, r0	; 63
    1af0:	cd bf       	out	0x3d, r28	; 61
    1af2:	cf 91       	pop	r28
    1af4:	df 91       	pop	r29
    1af6:	08 95       	ret

00001af8 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    1af8:	df 93       	push	r29
    1afa:	cf 93       	push	r28
    1afc:	00 d0       	rcall	.+0      	; 0x1afe <prvTestWaitCondition+0x6>
    1afe:	00 d0       	rcall	.+0      	; 0x1b00 <prvTestWaitCondition+0x8>
    1b00:	00 d0       	rcall	.+0      	; 0x1b02 <prvTestWaitCondition+0xa>
    1b02:	cd b7       	in	r28, 0x3d	; 61
    1b04:	de b7       	in	r29, 0x3e	; 62
    1b06:	9b 83       	std	Y+3, r25	; 0x03
    1b08:	8a 83       	std	Y+2, r24	; 0x02
    1b0a:	7d 83       	std	Y+5, r23	; 0x05
    1b0c:	6c 83       	std	Y+4, r22	; 0x04
    1b0e:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    1b10:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    1b12:	8e 81       	ldd	r24, Y+6	; 0x06
    1b14:	88 23       	and	r24, r24
    1b16:	59 f4       	brne	.+22     	; 0x1b2e <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1b18:	8a 81       	ldd	r24, Y+2	; 0x02
    1b1a:	9b 81       	ldd	r25, Y+3	; 0x03
    1b1c:	2c 81       	ldd	r18, Y+4	; 0x04
    1b1e:	3d 81       	ldd	r19, Y+5	; 0x05
    1b20:	82 23       	and	r24, r18
    1b22:	93 23       	and	r25, r19
    1b24:	00 97       	sbiw	r24, 0x00	; 0
    1b26:	81 f0       	breq	.+32     	; 0x1b48 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    1b28:	81 e0       	ldi	r24, 0x01	; 1
    1b2a:	89 83       	std	Y+1, r24	; 0x01
    1b2c:	0d c0       	rjmp	.+26     	; 0x1b48 <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1b2e:	2a 81       	ldd	r18, Y+2	; 0x02
    1b30:	3b 81       	ldd	r19, Y+3	; 0x03
    1b32:	8c 81       	ldd	r24, Y+4	; 0x04
    1b34:	9d 81       	ldd	r25, Y+5	; 0x05
    1b36:	28 23       	and	r18, r24
    1b38:	39 23       	and	r19, r25
    1b3a:	8c 81       	ldd	r24, Y+4	; 0x04
    1b3c:	9d 81       	ldd	r25, Y+5	; 0x05
    1b3e:	28 17       	cp	r18, r24
    1b40:	39 07       	cpc	r19, r25
    1b42:	11 f4       	brne	.+4      	; 0x1b48 <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    1b44:	81 e0       	ldi	r24, 0x01	; 1
    1b46:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    1b48:	89 81       	ldd	r24, Y+1	; 0x01
}
    1b4a:	26 96       	adiw	r28, 0x06	; 6
    1b4c:	0f b6       	in	r0, 0x3f	; 63
    1b4e:	f8 94       	cli
    1b50:	de bf       	out	0x3e, r29	; 62
    1b52:	0f be       	out	0x3f, r0	; 63
    1b54:	cd bf       	out	0x3d, r28	; 61
    1b56:	cf 91       	pop	r28
    1b58:	df 91       	pop	r29
    1b5a:	08 95       	ret

00001b5c <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1b5c:	df 93       	push	r29
    1b5e:	cf 93       	push	r28
    1b60:	00 d0       	rcall	.+0      	; 0x1b62 <vListInitialise+0x6>
    1b62:	cd b7       	in	r28, 0x3d	; 61
    1b64:	de b7       	in	r29, 0x3e	; 62
    1b66:	9a 83       	std	Y+2, r25	; 0x02
    1b68:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b6a:	89 81       	ldd	r24, Y+1	; 0x01
    1b6c:	9a 81       	ldd	r25, Y+2	; 0x02
    1b6e:	03 96       	adiw	r24, 0x03	; 3
    1b70:	e9 81       	ldd	r30, Y+1	; 0x01
    1b72:	fa 81       	ldd	r31, Y+2	; 0x02
    1b74:	92 83       	std	Z+2, r25	; 0x02
    1b76:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    1b78:	e9 81       	ldd	r30, Y+1	; 0x01
    1b7a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b7c:	8f ef       	ldi	r24, 0xFF	; 255
    1b7e:	9f ef       	ldi	r25, 0xFF	; 255
    1b80:	94 83       	std	Z+4, r25	; 0x04
    1b82:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b84:	89 81       	ldd	r24, Y+1	; 0x01
    1b86:	9a 81       	ldd	r25, Y+2	; 0x02
    1b88:	03 96       	adiw	r24, 0x03	; 3
    1b8a:	e9 81       	ldd	r30, Y+1	; 0x01
    1b8c:	fa 81       	ldd	r31, Y+2	; 0x02
    1b8e:	96 83       	std	Z+6, r25	; 0x06
    1b90:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b92:	89 81       	ldd	r24, Y+1	; 0x01
    1b94:	9a 81       	ldd	r25, Y+2	; 0x02
    1b96:	03 96       	adiw	r24, 0x03	; 3
    1b98:	e9 81       	ldd	r30, Y+1	; 0x01
    1b9a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b9c:	90 87       	std	Z+8, r25	; 0x08
    1b9e:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1ba0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ba2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ba4:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1ba6:	0f 90       	pop	r0
    1ba8:	0f 90       	pop	r0
    1baa:	cf 91       	pop	r28
    1bac:	df 91       	pop	r29
    1bae:	08 95       	ret

00001bb0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1bb0:	df 93       	push	r29
    1bb2:	cf 93       	push	r28
    1bb4:	00 d0       	rcall	.+0      	; 0x1bb6 <vListInitialiseItem+0x6>
    1bb6:	cd b7       	in	r28, 0x3d	; 61
    1bb8:	de b7       	in	r29, 0x3e	; 62
    1bba:	9a 83       	std	Y+2, r25	; 0x02
    1bbc:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    1bbe:	e9 81       	ldd	r30, Y+1	; 0x01
    1bc0:	fa 81       	ldd	r31, Y+2	; 0x02
    1bc2:	11 86       	std	Z+9, r1	; 0x09
    1bc4:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1bc6:	0f 90       	pop	r0
    1bc8:	0f 90       	pop	r0
    1bca:	cf 91       	pop	r28
    1bcc:	df 91       	pop	r29
    1bce:	08 95       	ret

00001bd0 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    1bd0:	df 93       	push	r29
    1bd2:	cf 93       	push	r28
    1bd4:	00 d0       	rcall	.+0      	; 0x1bd6 <vListInsertEnd+0x6>
    1bd6:	00 d0       	rcall	.+0      	; 0x1bd8 <vListInsertEnd+0x8>
    1bd8:	00 d0       	rcall	.+0      	; 0x1bda <vListInsertEnd+0xa>
    1bda:	cd b7       	in	r28, 0x3d	; 61
    1bdc:	de b7       	in	r29, 0x3e	; 62
    1bde:	9c 83       	std	Y+4, r25	; 0x04
    1be0:	8b 83       	std	Y+3, r24	; 0x03
    1be2:	7e 83       	std	Y+6, r23	; 0x06
    1be4:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    1be6:	eb 81       	ldd	r30, Y+3	; 0x03
    1be8:	fc 81       	ldd	r31, Y+4	; 0x04
    1bea:	81 81       	ldd	r24, Z+1	; 0x01
    1bec:	92 81       	ldd	r25, Z+2	; 0x02
    1bee:	9a 83       	std	Y+2, r25	; 0x02
    1bf0:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    1bf2:	ed 81       	ldd	r30, Y+5	; 0x05
    1bf4:	fe 81       	ldd	r31, Y+6	; 0x06
    1bf6:	89 81       	ldd	r24, Y+1	; 0x01
    1bf8:	9a 81       	ldd	r25, Y+2	; 0x02
    1bfa:	93 83       	std	Z+3, r25	; 0x03
    1bfc:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1bfe:	e9 81       	ldd	r30, Y+1	; 0x01
    1c00:	fa 81       	ldd	r31, Y+2	; 0x02
    1c02:	84 81       	ldd	r24, Z+4	; 0x04
    1c04:	95 81       	ldd	r25, Z+5	; 0x05
    1c06:	ed 81       	ldd	r30, Y+5	; 0x05
    1c08:	fe 81       	ldd	r31, Y+6	; 0x06
    1c0a:	95 83       	std	Z+5, r25	; 0x05
    1c0c:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1c0e:	e9 81       	ldd	r30, Y+1	; 0x01
    1c10:	fa 81       	ldd	r31, Y+2	; 0x02
    1c12:	04 80       	ldd	r0, Z+4	; 0x04
    1c14:	f5 81       	ldd	r31, Z+5	; 0x05
    1c16:	e0 2d       	mov	r30, r0
    1c18:	8d 81       	ldd	r24, Y+5	; 0x05
    1c1a:	9e 81       	ldd	r25, Y+6	; 0x06
    1c1c:	93 83       	std	Z+3, r25	; 0x03
    1c1e:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    1c20:	e9 81       	ldd	r30, Y+1	; 0x01
    1c22:	fa 81       	ldd	r31, Y+2	; 0x02
    1c24:	8d 81       	ldd	r24, Y+5	; 0x05
    1c26:	9e 81       	ldd	r25, Y+6	; 0x06
    1c28:	95 83       	std	Z+5, r25	; 0x05
    1c2a:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    1c2c:	ed 81       	ldd	r30, Y+5	; 0x05
    1c2e:	fe 81       	ldd	r31, Y+6	; 0x06
    1c30:	8b 81       	ldd	r24, Y+3	; 0x03
    1c32:	9c 81       	ldd	r25, Y+4	; 0x04
    1c34:	91 87       	std	Z+9, r25	; 0x09
    1c36:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1c38:	eb 81       	ldd	r30, Y+3	; 0x03
    1c3a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c3c:	80 81       	ld	r24, Z
    1c3e:	8f 5f       	subi	r24, 0xFF	; 255
    1c40:	eb 81       	ldd	r30, Y+3	; 0x03
    1c42:	fc 81       	ldd	r31, Y+4	; 0x04
    1c44:	80 83       	st	Z, r24
}
    1c46:	26 96       	adiw	r28, 0x06	; 6
    1c48:	0f b6       	in	r0, 0x3f	; 63
    1c4a:	f8 94       	cli
    1c4c:	de bf       	out	0x3e, r29	; 62
    1c4e:	0f be       	out	0x3f, r0	; 63
    1c50:	cd bf       	out	0x3d, r28	; 61
    1c52:	cf 91       	pop	r28
    1c54:	df 91       	pop	r29
    1c56:	08 95       	ret

00001c58 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    1c58:	df 93       	push	r29
    1c5a:	cf 93       	push	r28
    1c5c:	cd b7       	in	r28, 0x3d	; 61
    1c5e:	de b7       	in	r29, 0x3e	; 62
    1c60:	28 97       	sbiw	r28, 0x08	; 8
    1c62:	0f b6       	in	r0, 0x3f	; 63
    1c64:	f8 94       	cli
    1c66:	de bf       	out	0x3e, r29	; 62
    1c68:	0f be       	out	0x3f, r0	; 63
    1c6a:	cd bf       	out	0x3d, r28	; 61
    1c6c:	9e 83       	std	Y+6, r25	; 0x06
    1c6e:	8d 83       	std	Y+5, r24	; 0x05
    1c70:	78 87       	std	Y+8, r23	; 0x08
    1c72:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1c74:	ef 81       	ldd	r30, Y+7	; 0x07
    1c76:	f8 85       	ldd	r31, Y+8	; 0x08
    1c78:	80 81       	ld	r24, Z
    1c7a:	91 81       	ldd	r25, Z+1	; 0x01
    1c7c:	9a 83       	std	Y+2, r25	; 0x02
    1c7e:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1c80:	89 81       	ldd	r24, Y+1	; 0x01
    1c82:	9a 81       	ldd	r25, Y+2	; 0x02
    1c84:	2f ef       	ldi	r18, 0xFF	; 255
    1c86:	8f 3f       	cpi	r24, 0xFF	; 255
    1c88:	92 07       	cpc	r25, r18
    1c8a:	39 f4       	brne	.+14     	; 0x1c9a <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1c8c:	ed 81       	ldd	r30, Y+5	; 0x05
    1c8e:	fe 81       	ldd	r31, Y+6	; 0x06
    1c90:	87 81       	ldd	r24, Z+7	; 0x07
    1c92:	90 85       	ldd	r25, Z+8	; 0x08
    1c94:	9c 83       	std	Y+4, r25	; 0x04
    1c96:	8b 83       	std	Y+3, r24	; 0x03
    1c98:	18 c0       	rjmp	.+48     	; 0x1cca <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1c9a:	8d 81       	ldd	r24, Y+5	; 0x05
    1c9c:	9e 81       	ldd	r25, Y+6	; 0x06
    1c9e:	03 96       	adiw	r24, 0x03	; 3
    1ca0:	9c 83       	std	Y+4, r25	; 0x04
    1ca2:	8b 83       	std	Y+3, r24	; 0x03
    1ca4:	06 c0       	rjmp	.+12     	; 0x1cb2 <vListInsert+0x5a>
    1ca6:	eb 81       	ldd	r30, Y+3	; 0x03
    1ca8:	fc 81       	ldd	r31, Y+4	; 0x04
    1caa:	82 81       	ldd	r24, Z+2	; 0x02
    1cac:	93 81       	ldd	r25, Z+3	; 0x03
    1cae:	9c 83       	std	Y+4, r25	; 0x04
    1cb0:	8b 83       	std	Y+3, r24	; 0x03
    1cb2:	eb 81       	ldd	r30, Y+3	; 0x03
    1cb4:	fc 81       	ldd	r31, Y+4	; 0x04
    1cb6:	02 80       	ldd	r0, Z+2	; 0x02
    1cb8:	f3 81       	ldd	r31, Z+3	; 0x03
    1cba:	e0 2d       	mov	r30, r0
    1cbc:	20 81       	ld	r18, Z
    1cbe:	31 81       	ldd	r19, Z+1	; 0x01
    1cc0:	89 81       	ldd	r24, Y+1	; 0x01
    1cc2:	9a 81       	ldd	r25, Y+2	; 0x02
    1cc4:	82 17       	cp	r24, r18
    1cc6:	93 07       	cpc	r25, r19
    1cc8:	70 f7       	brcc	.-36     	; 0x1ca6 <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1cca:	eb 81       	ldd	r30, Y+3	; 0x03
    1ccc:	fc 81       	ldd	r31, Y+4	; 0x04
    1cce:	82 81       	ldd	r24, Z+2	; 0x02
    1cd0:	93 81       	ldd	r25, Z+3	; 0x03
    1cd2:	ef 81       	ldd	r30, Y+7	; 0x07
    1cd4:	f8 85       	ldd	r31, Y+8	; 0x08
    1cd6:	93 83       	std	Z+3, r25	; 0x03
    1cd8:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1cda:	ef 81       	ldd	r30, Y+7	; 0x07
    1cdc:	f8 85       	ldd	r31, Y+8	; 0x08
    1cde:	02 80       	ldd	r0, Z+2	; 0x02
    1ce0:	f3 81       	ldd	r31, Z+3	; 0x03
    1ce2:	e0 2d       	mov	r30, r0
    1ce4:	8f 81       	ldd	r24, Y+7	; 0x07
    1ce6:	98 85       	ldd	r25, Y+8	; 0x08
    1ce8:	95 83       	std	Z+5, r25	; 0x05
    1cea:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1cec:	ef 81       	ldd	r30, Y+7	; 0x07
    1cee:	f8 85       	ldd	r31, Y+8	; 0x08
    1cf0:	8b 81       	ldd	r24, Y+3	; 0x03
    1cf2:	9c 81       	ldd	r25, Y+4	; 0x04
    1cf4:	95 83       	std	Z+5, r25	; 0x05
    1cf6:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    1cf8:	eb 81       	ldd	r30, Y+3	; 0x03
    1cfa:	fc 81       	ldd	r31, Y+4	; 0x04
    1cfc:	8f 81       	ldd	r24, Y+7	; 0x07
    1cfe:	98 85       	ldd	r25, Y+8	; 0x08
    1d00:	93 83       	std	Z+3, r25	; 0x03
    1d02:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    1d04:	ef 81       	ldd	r30, Y+7	; 0x07
    1d06:	f8 85       	ldd	r31, Y+8	; 0x08
    1d08:	8d 81       	ldd	r24, Y+5	; 0x05
    1d0a:	9e 81       	ldd	r25, Y+6	; 0x06
    1d0c:	91 87       	std	Z+9, r25	; 0x09
    1d0e:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1d10:	ed 81       	ldd	r30, Y+5	; 0x05
    1d12:	fe 81       	ldd	r31, Y+6	; 0x06
    1d14:	80 81       	ld	r24, Z
    1d16:	8f 5f       	subi	r24, 0xFF	; 255
    1d18:	ed 81       	ldd	r30, Y+5	; 0x05
    1d1a:	fe 81       	ldd	r31, Y+6	; 0x06
    1d1c:	80 83       	st	Z, r24
}
    1d1e:	28 96       	adiw	r28, 0x08	; 8
    1d20:	0f b6       	in	r0, 0x3f	; 63
    1d22:	f8 94       	cli
    1d24:	de bf       	out	0x3e, r29	; 62
    1d26:	0f be       	out	0x3f, r0	; 63
    1d28:	cd bf       	out	0x3d, r28	; 61
    1d2a:	cf 91       	pop	r28
    1d2c:	df 91       	pop	r29
    1d2e:	08 95       	ret

00001d30 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1d30:	df 93       	push	r29
    1d32:	cf 93       	push	r28
    1d34:	00 d0       	rcall	.+0      	; 0x1d36 <uxListRemove+0x6>
    1d36:	00 d0       	rcall	.+0      	; 0x1d38 <uxListRemove+0x8>
    1d38:	cd b7       	in	r28, 0x3d	; 61
    1d3a:	de b7       	in	r29, 0x3e	; 62
    1d3c:	9c 83       	std	Y+4, r25	; 0x04
    1d3e:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    1d40:	eb 81       	ldd	r30, Y+3	; 0x03
    1d42:	fc 81       	ldd	r31, Y+4	; 0x04
    1d44:	80 85       	ldd	r24, Z+8	; 0x08
    1d46:	91 85       	ldd	r25, Z+9	; 0x09
    1d48:	9a 83       	std	Y+2, r25	; 0x02
    1d4a:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1d4c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d4e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d50:	a2 81       	ldd	r26, Z+2	; 0x02
    1d52:	b3 81       	ldd	r27, Z+3	; 0x03
    1d54:	eb 81       	ldd	r30, Y+3	; 0x03
    1d56:	fc 81       	ldd	r31, Y+4	; 0x04
    1d58:	84 81       	ldd	r24, Z+4	; 0x04
    1d5a:	95 81       	ldd	r25, Z+5	; 0x05
    1d5c:	15 96       	adiw	r26, 0x05	; 5
    1d5e:	9c 93       	st	X, r25
    1d60:	8e 93       	st	-X, r24
    1d62:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1d64:	eb 81       	ldd	r30, Y+3	; 0x03
    1d66:	fc 81       	ldd	r31, Y+4	; 0x04
    1d68:	a4 81       	ldd	r26, Z+4	; 0x04
    1d6a:	b5 81       	ldd	r27, Z+5	; 0x05
    1d6c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d6e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d70:	82 81       	ldd	r24, Z+2	; 0x02
    1d72:	93 81       	ldd	r25, Z+3	; 0x03
    1d74:	13 96       	adiw	r26, 0x03	; 3
    1d76:	9c 93       	st	X, r25
    1d78:	8e 93       	st	-X, r24
    1d7a:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    1d7c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d7e:	fa 81       	ldd	r31, Y+2	; 0x02
    1d80:	21 81       	ldd	r18, Z+1	; 0x01
    1d82:	32 81       	ldd	r19, Z+2	; 0x02
    1d84:	8b 81       	ldd	r24, Y+3	; 0x03
    1d86:	9c 81       	ldd	r25, Y+4	; 0x04
    1d88:	28 17       	cp	r18, r24
    1d8a:	39 07       	cpc	r19, r25
    1d8c:	41 f4       	brne	.+16     	; 0x1d9e <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    1d8e:	eb 81       	ldd	r30, Y+3	; 0x03
    1d90:	fc 81       	ldd	r31, Y+4	; 0x04
    1d92:	84 81       	ldd	r24, Z+4	; 0x04
    1d94:	95 81       	ldd	r25, Z+5	; 0x05
    1d96:	e9 81       	ldd	r30, Y+1	; 0x01
    1d98:	fa 81       	ldd	r31, Y+2	; 0x02
    1d9a:	92 83       	std	Z+2, r25	; 0x02
    1d9c:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    1d9e:	eb 81       	ldd	r30, Y+3	; 0x03
    1da0:	fc 81       	ldd	r31, Y+4	; 0x04
    1da2:	11 86       	std	Z+9, r1	; 0x09
    1da4:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    1da6:	e9 81       	ldd	r30, Y+1	; 0x01
    1da8:	fa 81       	ldd	r31, Y+2	; 0x02
    1daa:	80 81       	ld	r24, Z
    1dac:	81 50       	subi	r24, 0x01	; 1
    1dae:	e9 81       	ldd	r30, Y+1	; 0x01
    1db0:	fa 81       	ldd	r31, Y+2	; 0x02
    1db2:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    1db4:	e9 81       	ldd	r30, Y+1	; 0x01
    1db6:	fa 81       	ldd	r31, Y+2	; 0x02
    1db8:	80 81       	ld	r24, Z
}
    1dba:	0f 90       	pop	r0
    1dbc:	0f 90       	pop	r0
    1dbe:	0f 90       	pop	r0
    1dc0:	0f 90       	pop	r0
    1dc2:	cf 91       	pop	r28
    1dc4:	df 91       	pop	r29
    1dc6:	08 95       	ret

00001dc8 <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    1dc8:	df 93       	push	r29
    1dca:	cf 93       	push	r28
    1dcc:	00 d0       	rcall	.+0      	; 0x1dce <xQueueGenericReset+0x6>
    1dce:	00 d0       	rcall	.+0      	; 0x1dd0 <xQueueGenericReset+0x8>
    1dd0:	00 d0       	rcall	.+0      	; 0x1dd2 <xQueueGenericReset+0xa>
    1dd2:	cd b7       	in	r28, 0x3d	; 61
    1dd4:	de b7       	in	r29, 0x3e	; 62
    1dd6:	9d 83       	std	Y+5, r25	; 0x05
    1dd8:	8c 83       	std	Y+4, r24	; 0x04
    1dda:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    1ddc:	81 e0       	ldi	r24, 0x01	; 1
    1dde:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    1de0:	8c 81       	ldd	r24, Y+4	; 0x04
    1de2:	9d 81       	ldd	r25, Y+5	; 0x05
    1de4:	9a 83       	std	Y+2, r25	; 0x02
    1de6:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    1de8:	89 81       	ldd	r24, Y+1	; 0x01
    1dea:	9a 81       	ldd	r25, Y+2	; 0x02
    1dec:	00 97       	sbiw	r24, 0x00	; 0
    1dee:	09 f4       	brne	.+2      	; 0x1df2 <xQueueGenericReset+0x2a>
    1df0:	8b c0       	rjmp	.+278    	; 0x1f08 <xQueueGenericReset+0x140>
    1df2:	e9 81       	ldd	r30, Y+1	; 0x01
    1df4:	fa 81       	ldd	r31, Y+2	; 0x02
    1df6:	83 8d       	ldd	r24, Z+27	; 0x1b
    1df8:	88 23       	and	r24, r24
    1dfa:	09 f4       	brne	.+2      	; 0x1dfe <xQueueGenericReset+0x36>
    1dfc:	85 c0       	rjmp	.+266    	; 0x1f08 <xQueueGenericReset+0x140>
    1dfe:	e9 81       	ldd	r30, Y+1	; 0x01
    1e00:	fa 81       	ldd	r31, Y+2	; 0x02
    1e02:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e04:	28 2f       	mov	r18, r24
    1e06:	30 e0       	ldi	r19, 0x00	; 0
    1e08:	8f ef       	ldi	r24, 0xFF	; 255
    1e0a:	9f e7       	ldi	r25, 0x7F	; 127
    1e0c:	b9 01       	movw	r22, r18
    1e0e:	0e 94 24 33 	call	0x6648	; 0x6648 <__udivmodhi4>
    1e12:	cb 01       	movw	r24, r22
    1e14:	9c 01       	movw	r18, r24
    1e16:	e9 81       	ldd	r30, Y+1	; 0x01
    1e18:	fa 81       	ldd	r31, Y+2	; 0x02
    1e1a:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e1c:	88 2f       	mov	r24, r24
    1e1e:	90 e0       	ldi	r25, 0x00	; 0
    1e20:	28 17       	cp	r18, r24
    1e22:	39 07       	cpc	r19, r25
    1e24:	08 f4       	brcc	.+2      	; 0x1e28 <xQueueGenericReset+0x60>
    1e26:	70 c0       	rjmp	.+224    	; 0x1f08 <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    1e28:	0f b6       	in	r0, 0x3f	; 63
    1e2a:	f8 94       	cli
    1e2c:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1e2e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e30:	fa 81       	ldd	r31, Y+2	; 0x02
    1e32:	40 81       	ld	r20, Z
    1e34:	51 81       	ldd	r21, Z+1	; 0x01
    1e36:	e9 81       	ldd	r30, Y+1	; 0x01
    1e38:	fa 81       	ldd	r31, Y+2	; 0x02
    1e3a:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e3c:	28 2f       	mov	r18, r24
    1e3e:	30 e0       	ldi	r19, 0x00	; 0
    1e40:	e9 81       	ldd	r30, Y+1	; 0x01
    1e42:	fa 81       	ldd	r31, Y+2	; 0x02
    1e44:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e46:	88 2f       	mov	r24, r24
    1e48:	90 e0       	ldi	r25, 0x00	; 0
    1e4a:	bc 01       	movw	r22, r24
    1e4c:	26 9f       	mul	r18, r22
    1e4e:	c0 01       	movw	r24, r0
    1e50:	27 9f       	mul	r18, r23
    1e52:	90 0d       	add	r25, r0
    1e54:	36 9f       	mul	r19, r22
    1e56:	90 0d       	add	r25, r0
    1e58:	11 24       	eor	r1, r1
    1e5a:	84 0f       	add	r24, r20
    1e5c:	95 1f       	adc	r25, r21
    1e5e:	e9 81       	ldd	r30, Y+1	; 0x01
    1e60:	fa 81       	ldd	r31, Y+2	; 0x02
    1e62:	95 83       	std	Z+5, r25	; 0x05
    1e64:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1e66:	e9 81       	ldd	r30, Y+1	; 0x01
    1e68:	fa 81       	ldd	r31, Y+2	; 0x02
    1e6a:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    1e6c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e6e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e70:	80 81       	ld	r24, Z
    1e72:	91 81       	ldd	r25, Z+1	; 0x01
    1e74:	e9 81       	ldd	r30, Y+1	; 0x01
    1e76:	fa 81       	ldd	r31, Y+2	; 0x02
    1e78:	93 83       	std	Z+3, r25	; 0x03
    1e7a:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1e7c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e7e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e80:	40 81       	ld	r20, Z
    1e82:	51 81       	ldd	r21, Z+1	; 0x01
    1e84:	e9 81       	ldd	r30, Y+1	; 0x01
    1e86:	fa 81       	ldd	r31, Y+2	; 0x02
    1e88:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e8a:	88 2f       	mov	r24, r24
    1e8c:	90 e0       	ldi	r25, 0x00	; 0
    1e8e:	9c 01       	movw	r18, r24
    1e90:	21 50       	subi	r18, 0x01	; 1
    1e92:	30 40       	sbci	r19, 0x00	; 0
    1e94:	e9 81       	ldd	r30, Y+1	; 0x01
    1e96:	fa 81       	ldd	r31, Y+2	; 0x02
    1e98:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e9a:	88 2f       	mov	r24, r24
    1e9c:	90 e0       	ldi	r25, 0x00	; 0
    1e9e:	bc 01       	movw	r22, r24
    1ea0:	26 9f       	mul	r18, r22
    1ea2:	c0 01       	movw	r24, r0
    1ea4:	27 9f       	mul	r18, r23
    1ea6:	90 0d       	add	r25, r0
    1ea8:	36 9f       	mul	r19, r22
    1eaa:	90 0d       	add	r25, r0
    1eac:	11 24       	eor	r1, r1
    1eae:	84 0f       	add	r24, r20
    1eb0:	95 1f       	adc	r25, r21
    1eb2:	e9 81       	ldd	r30, Y+1	; 0x01
    1eb4:	fa 81       	ldd	r31, Y+2	; 0x02
    1eb6:	97 83       	std	Z+7, r25	; 0x07
    1eb8:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    1eba:	e9 81       	ldd	r30, Y+1	; 0x01
    1ebc:	fa 81       	ldd	r31, Y+2	; 0x02
    1ebe:	8f ef       	ldi	r24, 0xFF	; 255
    1ec0:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    1ec2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ec4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ec6:	8f ef       	ldi	r24, 0xFF	; 255
    1ec8:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    1eca:	8e 81       	ldd	r24, Y+6	; 0x06
    1ecc:	88 23       	and	r24, r24
    1ece:	79 f4       	brne	.+30     	; 0x1eee <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ed0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ed2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ed4:	80 85       	ldd	r24, Z+8	; 0x08
    1ed6:	88 23       	and	r24, r24
    1ed8:	a1 f0       	breq	.+40     	; 0x1f02 <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1eda:	89 81       	ldd	r24, Y+1	; 0x01
    1edc:	9a 81       	ldd	r25, Y+2	; 0x02
    1ede:	08 96       	adiw	r24, 0x08	; 8
    1ee0:	0e 94 51 20 	call	0x40a2	; 0x40a2 <xTaskRemoveFromEventList>
    1ee4:	88 23       	and	r24, r24
    1ee6:	69 f0       	breq	.+26     	; 0x1f02 <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1ee8:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    1eec:	0a c0       	rjmp	.+20     	; 0x1f02 <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1eee:	89 81       	ldd	r24, Y+1	; 0x01
    1ef0:	9a 81       	ldd	r25, Y+2	; 0x02
    1ef2:	08 96       	adiw	r24, 0x08	; 8
    1ef4:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1ef8:	89 81       	ldd	r24, Y+1	; 0x01
    1efa:	9a 81       	ldd	r25, Y+2	; 0x02
    1efc:	41 96       	adiw	r24, 0x11	; 17
    1efe:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    1f02:	0f 90       	pop	r0
    1f04:	0f be       	out	0x3f, r0	; 63
    1f06:	01 c0       	rjmp	.+2      	; 0x1f0a <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    1f08:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    1f0a:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1f0c:	26 96       	adiw	r28, 0x06	; 6
    1f0e:	0f b6       	in	r0, 0x3f	; 63
    1f10:	f8 94       	cli
    1f12:	de bf       	out	0x3e, r29	; 62
    1f14:	0f be       	out	0x3f, r0	; 63
    1f16:	cd bf       	out	0x3d, r28	; 61
    1f18:	cf 91       	pop	r28
    1f1a:	df 91       	pop	r29
    1f1c:	08 95       	ret

00001f1e <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    1f1e:	0f 93       	push	r16
    1f20:	1f 93       	push	r17
    1f22:	df 93       	push	r29
    1f24:	cf 93       	push	r28
    1f26:	cd b7       	in	r28, 0x3d	; 61
    1f28:	de b7       	in	r29, 0x3e	; 62
    1f2a:	29 97       	sbiw	r28, 0x09	; 9
    1f2c:	0f b6       	in	r0, 0x3f	; 63
    1f2e:	f8 94       	cli
    1f30:	de bf       	out	0x3e, r29	; 62
    1f32:	0f be       	out	0x3f, r0	; 63
    1f34:	cd bf       	out	0x3d, r28	; 61
    1f36:	8f 83       	std	Y+7, r24	; 0x07
    1f38:	68 87       	std	Y+8, r22	; 0x08
    1f3a:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    1f3c:	1e 82       	std	Y+6, r1	; 0x06
    1f3e:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    1f40:	8f 81       	ldd	r24, Y+7	; 0x07
    1f42:	88 23       	and	r24, r24
    1f44:	09 f4       	brne	.+2      	; 0x1f48 <xQueueGenericCreate+0x2a>
    1f46:	52 c0       	rjmp	.+164    	; 0x1fec <xQueueGenericCreate+0xce>
    1f48:	8f 81       	ldd	r24, Y+7	; 0x07
    1f4a:	28 2f       	mov	r18, r24
    1f4c:	30 e0       	ldi	r19, 0x00	; 0
    1f4e:	8f ef       	ldi	r24, 0xFF	; 255
    1f50:	9f e7       	ldi	r25, 0x7F	; 127
    1f52:	b9 01       	movw	r22, r18
    1f54:	0e 94 24 33 	call	0x6648	; 0x6648 <__udivmodhi4>
    1f58:	cb 01       	movw	r24, r22
    1f5a:	9c 01       	movw	r18, r24
    1f5c:	88 85       	ldd	r24, Y+8	; 0x08
    1f5e:	88 2f       	mov	r24, r24
    1f60:	90 e0       	ldi	r25, 0x00	; 0
    1f62:	28 17       	cp	r18, r24
    1f64:	39 07       	cpc	r19, r25
    1f66:	08 f4       	brcc	.+2      	; 0x1f6a <xQueueGenericCreate+0x4c>
    1f68:	41 c0       	rjmp	.+130    	; 0x1fec <xQueueGenericCreate+0xce>
    1f6a:	8f 81       	ldd	r24, Y+7	; 0x07
    1f6c:	28 2f       	mov	r18, r24
    1f6e:	30 e0       	ldi	r19, 0x00	; 0
    1f70:	88 85       	ldd	r24, Y+8	; 0x08
    1f72:	88 2f       	mov	r24, r24
    1f74:	90 e0       	ldi	r25, 0x00	; 0
    1f76:	ac 01       	movw	r20, r24
    1f78:	24 9f       	mul	r18, r20
    1f7a:	c0 01       	movw	r24, r0
    1f7c:	25 9f       	mul	r18, r21
    1f7e:	90 0d       	add	r25, r0
    1f80:	34 9f       	mul	r19, r20
    1f82:	90 0d       	add	r25, r0
    1f84:	11 24       	eor	r1, r1
    1f86:	5f e7       	ldi	r21, 0x7F	; 127
    1f88:	81 3e       	cpi	r24, 0xE1	; 225
    1f8a:	95 07       	cpc	r25, r21
    1f8c:	78 f5       	brcc	.+94     	; 0x1fec <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1f8e:	8f 81       	ldd	r24, Y+7	; 0x07
    1f90:	28 2f       	mov	r18, r24
    1f92:	30 e0       	ldi	r19, 0x00	; 0
    1f94:	88 85       	ldd	r24, Y+8	; 0x08
    1f96:	88 2f       	mov	r24, r24
    1f98:	90 e0       	ldi	r25, 0x00	; 0
    1f9a:	ac 01       	movw	r20, r24
    1f9c:	24 9f       	mul	r18, r20
    1f9e:	c0 01       	movw	r24, r0
    1fa0:	25 9f       	mul	r18, r21
    1fa2:	90 0d       	add	r25, r0
    1fa4:	34 9f       	mul	r19, r20
    1fa6:	90 0d       	add	r25, r0
    1fa8:	11 24       	eor	r1, r1
    1faa:	9c 83       	std	Y+4, r25	; 0x04
    1fac:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1fae:	8b 81       	ldd	r24, Y+3	; 0x03
    1fb0:	9c 81       	ldd	r25, Y+4	; 0x04
    1fb2:	4f 96       	adiw	r24, 0x1f	; 31
    1fb4:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    1fb8:	9e 83       	std	Y+6, r25	; 0x06
    1fba:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    1fbc:	8d 81       	ldd	r24, Y+5	; 0x05
    1fbe:	9e 81       	ldd	r25, Y+6	; 0x06
    1fc0:	00 97       	sbiw	r24, 0x00	; 0
    1fc2:	a1 f0       	breq	.+40     	; 0x1fec <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1fc4:	8d 81       	ldd	r24, Y+5	; 0x05
    1fc6:	9e 81       	ldd	r25, Y+6	; 0x06
    1fc8:	9a 83       	std	Y+2, r25	; 0x02
    1fca:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1fcc:	89 81       	ldd	r24, Y+1	; 0x01
    1fce:	9a 81       	ldd	r25, Y+2	; 0x02
    1fd0:	4f 96       	adiw	r24, 0x1f	; 31
    1fd2:	9a 83       	std	Y+2, r25	; 0x02
    1fd4:	89 83       	std	Y+1, r24	; 0x01
                         * deleted. */
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
                    }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1fd6:	29 81       	ldd	r18, Y+1	; 0x01
    1fd8:	3a 81       	ldd	r19, Y+2	; 0x02
    1fda:	ed 81       	ldd	r30, Y+5	; 0x05
    1fdc:	fe 81       	ldd	r31, Y+6	; 0x06
    1fde:	8f 81       	ldd	r24, Y+7	; 0x07
    1fe0:	68 85       	ldd	r22, Y+8	; 0x08
    1fe2:	a9 01       	movw	r20, r18
    1fe4:	29 85       	ldd	r18, Y+9	; 0x09
    1fe6:	8f 01       	movw	r16, r30
    1fe8:	0e 94 03 10 	call	0x2006	; 0x2006 <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    1fec:	8d 81       	ldd	r24, Y+5	; 0x05
    1fee:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    1ff0:	29 96       	adiw	r28, 0x09	; 9
    1ff2:	0f b6       	in	r0, 0x3f	; 63
    1ff4:	f8 94       	cli
    1ff6:	de bf       	out	0x3e, r29	; 62
    1ff8:	0f be       	out	0x3f, r0	; 63
    1ffa:	cd bf       	out	0x3d, r28	; 61
    1ffc:	cf 91       	pop	r28
    1ffe:	df 91       	pop	r29
    2000:	1f 91       	pop	r17
    2002:	0f 91       	pop	r16
    2004:	08 95       	ret

00002006 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    2006:	0f 93       	push	r16
    2008:	1f 93       	push	r17
    200a:	df 93       	push	r29
    200c:	cf 93       	push	r28
    200e:	cd b7       	in	r28, 0x3d	; 61
    2010:	de b7       	in	r29, 0x3e	; 62
    2012:	27 97       	sbiw	r28, 0x07	; 7
    2014:	0f b6       	in	r0, 0x3f	; 63
    2016:	f8 94       	cli
    2018:	de bf       	out	0x3e, r29	; 62
    201a:	0f be       	out	0x3f, r0	; 63
    201c:	cd bf       	out	0x3d, r28	; 61
    201e:	89 83       	std	Y+1, r24	; 0x01
    2020:	6a 83       	std	Y+2, r22	; 0x02
    2022:	5c 83       	std	Y+4, r21	; 0x04
    2024:	4b 83       	std	Y+3, r20	; 0x03
    2026:	2d 83       	std	Y+5, r18	; 0x05
    2028:	1f 83       	std	Y+7, r17	; 0x07
    202a:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    202c:	8a 81       	ldd	r24, Y+2	; 0x02
    202e:	88 23       	and	r24, r24
    2030:	39 f4       	brne	.+14     	; 0x2040 <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    2032:	8e 81       	ldd	r24, Y+6	; 0x06
    2034:	9f 81       	ldd	r25, Y+7	; 0x07
    2036:	ee 81       	ldd	r30, Y+6	; 0x06
    2038:	ff 81       	ldd	r31, Y+7	; 0x07
    203a:	91 83       	std	Z+1, r25	; 0x01
    203c:	80 83       	st	Z, r24
    203e:	06 c0       	rjmp	.+12     	; 0x204c <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    2040:	8b 81       	ldd	r24, Y+3	; 0x03
    2042:	9c 81       	ldd	r25, Y+4	; 0x04
    2044:	ee 81       	ldd	r30, Y+6	; 0x06
    2046:	ff 81       	ldd	r31, Y+7	; 0x07
    2048:	91 83       	std	Z+1, r25	; 0x01
    204a:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    204c:	ee 81       	ldd	r30, Y+6	; 0x06
    204e:	ff 81       	ldd	r31, Y+7	; 0x07
    2050:	89 81       	ldd	r24, Y+1	; 0x01
    2052:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    2054:	ee 81       	ldd	r30, Y+6	; 0x06
    2056:	ff 81       	ldd	r31, Y+7	; 0x07
    2058:	8a 81       	ldd	r24, Y+2	; 0x02
    205a:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    205c:	8e 81       	ldd	r24, Y+6	; 0x06
    205e:	9f 81       	ldd	r25, Y+7	; 0x07
    2060:	61 e0       	ldi	r22, 0x01	; 1
    2062:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <xQueueGenericReset>
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    2066:	27 96       	adiw	r28, 0x07	; 7
    2068:	0f b6       	in	r0, 0x3f	; 63
    206a:	f8 94       	cli
    206c:	de bf       	out	0x3e, r29	; 62
    206e:	0f be       	out	0x3f, r0	; 63
    2070:	cd bf       	out	0x3d, r28	; 61
    2072:	cf 91       	pop	r28
    2074:	df 91       	pop	r29
    2076:	1f 91       	pop	r17
    2078:	0f 91       	pop	r16
    207a:	08 95       	ret

0000207c <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    207c:	df 93       	push	r29
    207e:	cf 93       	push	r28
    2080:	cd b7       	in	r28, 0x3d	; 61
    2082:	de b7       	in	r29, 0x3e	; 62
    2084:	2f 97       	sbiw	r28, 0x0f	; 15
    2086:	0f b6       	in	r0, 0x3f	; 63
    2088:	f8 94       	cli
    208a:	de bf       	out	0x3e, r29	; 62
    208c:	0f be       	out	0x3f, r0	; 63
    208e:	cd bf       	out	0x3d, r28	; 61
    2090:	99 87       	std	Y+9, r25	; 0x09
    2092:	88 87       	std	Y+8, r24	; 0x08
    2094:	7b 87       	std	Y+11, r23	; 0x0b
    2096:	6a 87       	std	Y+10, r22	; 0x0a
    2098:	5d 87       	std	Y+13, r21	; 0x0d
    209a:	4c 87       	std	Y+12, r20	; 0x0c
    209c:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    209e:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    20a0:	88 85       	ldd	r24, Y+8	; 0x08
    20a2:	99 85       	ldd	r25, Y+9	; 0x09
    20a4:	9a 83       	std	Y+2, r25	; 0x02
    20a6:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    20a8:	0f b6       	in	r0, 0x3f	; 63
    20aa:	f8 94       	cli
    20ac:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    20ae:	e9 81       	ldd	r30, Y+1	; 0x01
    20b0:	fa 81       	ldd	r31, Y+2	; 0x02
    20b2:	92 8d       	ldd	r25, Z+26	; 0x1a
    20b4:	e9 81       	ldd	r30, Y+1	; 0x01
    20b6:	fa 81       	ldd	r31, Y+2	; 0x02
    20b8:	83 8d       	ldd	r24, Z+27	; 0x1b
    20ba:	98 17       	cp	r25, r24
    20bc:	18 f0       	brcs	.+6      	; 0x20c4 <xQueueGenericSend+0x48>
    20be:	8e 85       	ldd	r24, Y+14	; 0x0e
    20c0:	82 30       	cpi	r24, 0x02	; 2
    20c2:	11 f5       	brne	.+68     	; 0x2108 <xQueueGenericSend+0x8c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    20c4:	89 81       	ldd	r24, Y+1	; 0x01
    20c6:	9a 81       	ldd	r25, Y+2	; 0x02
    20c8:	2a 85       	ldd	r18, Y+10	; 0x0a
    20ca:	3b 85       	ldd	r19, Y+11	; 0x0b
    20cc:	b9 01       	movw	r22, r18
    20ce:	4e 85       	ldd	r20, Y+14	; 0x0e
    20d0:	0e 94 94 14 	call	0x2928	; 0x2928 <prvCopyDataToQueue>
    20d4:	8b 83       	std	Y+3, r24	; 0x03

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20d6:	e9 81       	ldd	r30, Y+1	; 0x01
    20d8:	fa 81       	ldd	r31, Y+2	; 0x02
    20da:	81 89       	ldd	r24, Z+17	; 0x11
    20dc:	88 23       	and	r24, r24
    20de:	51 f0       	breq	.+20     	; 0x20f4 <xQueueGenericSend+0x78>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20e0:	89 81       	ldd	r24, Y+1	; 0x01
    20e2:	9a 81       	ldd	r25, Y+2	; 0x02
    20e4:	41 96       	adiw	r24, 0x11	; 17
    20e6:	0e 94 51 20 	call	0x40a2	; 0x40a2 <xTaskRemoveFromEventList>
    20ea:	88 23       	and	r24, r24
    20ec:	41 f0       	breq	.+16     	; 0x20fe <xQueueGenericSend+0x82>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    20ee:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    20f2:	05 c0       	rjmp	.+10     	; 0x20fe <xQueueGenericSend+0x82>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    20f4:	8b 81       	ldd	r24, Y+3	; 0x03
    20f6:	88 23       	and	r24, r24
    20f8:	11 f0       	breq	.+4      	; 0x20fe <xQueueGenericSend+0x82>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    20fa:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    20fe:	0f 90       	pop	r0
    2100:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2102:	81 e0       	ldi	r24, 0x01	; 1
    2104:	8f 87       	std	Y+15, r24	; 0x0f
    2106:	5c c0       	rjmp	.+184    	; 0x21c0 <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2108:	8c 85       	ldd	r24, Y+12	; 0x0c
    210a:	9d 85       	ldd	r25, Y+13	; 0x0d
    210c:	00 97       	sbiw	r24, 0x00	; 0
    210e:	21 f4       	brne	.+8      	; 0x2118 <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2110:	0f 90       	pop	r0
    2112:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    2114:	1f 86       	std	Y+15, r1	; 0x0f
    2116:	54 c0       	rjmp	.+168    	; 0x21c0 <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    2118:	8c 81       	ldd	r24, Y+4	; 0x04
    211a:	88 23       	and	r24, r24
    211c:	31 f4       	brne	.+12     	; 0x212a <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    211e:	ce 01       	movw	r24, r28
    2120:	05 96       	adiw	r24, 0x05	; 5
    2122:	0e 94 c1 22 	call	0x4582	; 0x4582 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2126:	81 e0       	ldi	r24, 0x01	; 1
    2128:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    212a:	0f 90       	pop	r0
    212c:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    212e:	0e 94 8b 1b 	call	0x3716	; 0x3716 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2132:	0f b6       	in	r0, 0x3f	; 63
    2134:	f8 94       	cli
    2136:	0f 92       	push	r0
    2138:	e9 81       	ldd	r30, Y+1	; 0x01
    213a:	fa 81       	ldd	r31, Y+2	; 0x02
    213c:	85 8d       	ldd	r24, Z+29	; 0x1d
    213e:	8f 3f       	cpi	r24, 0xFF	; 255
    2140:	19 f4       	brne	.+6      	; 0x2148 <xQueueGenericSend+0xcc>
    2142:	e9 81       	ldd	r30, Y+1	; 0x01
    2144:	fa 81       	ldd	r31, Y+2	; 0x02
    2146:	15 8e       	std	Z+29, r1	; 0x1d
    2148:	e9 81       	ldd	r30, Y+1	; 0x01
    214a:	fa 81       	ldd	r31, Y+2	; 0x02
    214c:	86 8d       	ldd	r24, Z+30	; 0x1e
    214e:	8f 3f       	cpi	r24, 0xFF	; 255
    2150:	19 f4       	brne	.+6      	; 0x2158 <xQueueGenericSend+0xdc>
    2152:	e9 81       	ldd	r30, Y+1	; 0x01
    2154:	fa 81       	ldd	r31, Y+2	; 0x02
    2156:	16 8e       	std	Z+30, r1	; 0x1e
    2158:	0f 90       	pop	r0
    215a:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    215c:	ce 01       	movw	r24, r28
    215e:	05 96       	adiw	r24, 0x05	; 5
    2160:	9e 01       	movw	r18, r28
    2162:	24 5f       	subi	r18, 0xF4	; 244
    2164:	3f 4f       	sbci	r19, 0xFF	; 255
    2166:	b9 01       	movw	r22, r18
    2168:	0e 94 da 22 	call	0x45b4	; 0x45b4 <xTaskCheckForTimeOut>
    216c:	88 23       	and	r24, r24
    216e:	09 f5       	brne	.+66     	; 0x21b2 <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2170:	89 81       	ldd	r24, Y+1	; 0x01
    2172:	9a 81       	ldd	r25, Y+2	; 0x02
    2174:	0e 94 10 16 	call	0x2c20	; 0x2c20 <prvIsQueueFull>
    2178:	88 23       	and	r24, r24
    217a:	a1 f0       	breq	.+40     	; 0x21a4 <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    217c:	89 81       	ldd	r24, Y+1	; 0x01
    217e:	9a 81       	ldd	r25, Y+2	; 0x02
    2180:	08 96       	adiw	r24, 0x08	; 8
    2182:	2c 85       	ldd	r18, Y+12	; 0x0c
    2184:	3d 85       	ldd	r19, Y+13	; 0x0d
    2186:	b9 01       	movw	r22, r18
    2188:	0e 94 68 1f 	call	0x3ed0	; 0x3ed0 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    218c:	89 81       	ldd	r24, Y+1	; 0x01
    218e:	9a 81       	ldd	r25, Y+2	; 0x02
    2190:	0e 94 81 15 	call	0x2b02	; 0x2b02 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    2194:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>
    2198:	88 23       	and	r24, r24
    219a:	09 f0       	breq	.+2      	; 0x219e <xQueueGenericSend+0x122>
    219c:	85 cf       	rjmp	.-246    	; 0x20a8 <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    219e:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    21a2:	82 cf       	rjmp	.-252    	; 0x20a8 <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    21a4:	89 81       	ldd	r24, Y+1	; 0x01
    21a6:	9a 81       	ldd	r25, Y+2	; 0x02
    21a8:	0e 94 81 15 	call	0x2b02	; 0x2b02 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    21ac:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>
    21b0:	7b cf       	rjmp	.-266    	; 0x20a8 <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    21b2:	89 81       	ldd	r24, Y+1	; 0x01
    21b4:	9a 81       	ldd	r25, Y+2	; 0x02
    21b6:	0e 94 81 15 	call	0x2b02	; 0x2b02 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    21ba:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    21be:	1f 86       	std	Y+15, r1	; 0x0f
    21c0:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    21c2:	2f 96       	adiw	r28, 0x0f	; 15
    21c4:	0f b6       	in	r0, 0x3f	; 63
    21c6:	f8 94       	cli
    21c8:	de bf       	out	0x3e, r29	; 62
    21ca:	0f be       	out	0x3f, r0	; 63
    21cc:	cd bf       	out	0x3d, r28	; 61
    21ce:	cf 91       	pop	r28
    21d0:	df 91       	pop	r29
    21d2:	08 95       	ret

000021d4 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    21d4:	df 93       	push	r29
    21d6:	cf 93       	push	r28
    21d8:	cd b7       	in	r28, 0x3d	; 61
    21da:	de b7       	in	r29, 0x3e	; 62
    21dc:	2d 97       	sbiw	r28, 0x0d	; 13
    21de:	0f b6       	in	r0, 0x3f	; 63
    21e0:	f8 94       	cli
    21e2:	de bf       	out	0x3e, r29	; 62
    21e4:	0f be       	out	0x3f, r0	; 63
    21e6:	cd bf       	out	0x3d, r28	; 61
    21e8:	98 87       	std	Y+8, r25	; 0x08
    21ea:	8f 83       	std	Y+7, r24	; 0x07
    21ec:	7a 87       	std	Y+10, r23	; 0x0a
    21ee:	69 87       	std	Y+9, r22	; 0x09
    21f0:	5c 87       	std	Y+12, r21	; 0x0c
    21f2:	4b 87       	std	Y+11, r20	; 0x0b
    21f4:	2d 87       	std	Y+13, r18	; 0x0d
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    21f6:	8f 81       	ldd	r24, Y+7	; 0x07
    21f8:	98 85       	ldd	r25, Y+8	; 0x08
    21fa:	9c 83       	std	Y+4, r25	; 0x04
    21fc:	8b 83       	std	Y+3, r24	; 0x03
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    21fe:	1d 82       	std	Y+5, r1	; 0x05
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2200:	eb 81       	ldd	r30, Y+3	; 0x03
    2202:	fc 81       	ldd	r31, Y+4	; 0x04
    2204:	92 8d       	ldd	r25, Z+26	; 0x1a
    2206:	eb 81       	ldd	r30, Y+3	; 0x03
    2208:	fc 81       	ldd	r31, Y+4	; 0x04
    220a:	83 8d       	ldd	r24, Z+27	; 0x1b
    220c:	98 17       	cp	r25, r24
    220e:	18 f0       	brcs	.+6      	; 0x2216 <xQueueGenericSendFromISR+0x42>
    2210:	8d 85       	ldd	r24, Y+13	; 0x0d
    2212:	82 30       	cpi	r24, 0x02	; 2
    2214:	81 f5       	brne	.+96     	; 0x2276 <xQueueGenericSendFromISR+0xa2>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    2216:	eb 81       	ldd	r30, Y+3	; 0x03
    2218:	fc 81       	ldd	r31, Y+4	; 0x04
    221a:	86 8d       	ldd	r24, Z+30	; 0x1e
    221c:	8a 83       	std	Y+2, r24	; 0x02
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    221e:	eb 81       	ldd	r30, Y+3	; 0x03
    2220:	fc 81       	ldd	r31, Y+4	; 0x04
    2222:	82 8d       	ldd	r24, Z+26	; 0x1a
    2224:	89 83       	std	Y+1, r24	; 0x01
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2226:	8b 81       	ldd	r24, Y+3	; 0x03
    2228:	9c 81       	ldd	r25, Y+4	; 0x04
    222a:	29 85       	ldd	r18, Y+9	; 0x09
    222c:	3a 85       	ldd	r19, Y+10	; 0x0a
    222e:	b9 01       	movw	r22, r18
    2230:	4d 85       	ldd	r20, Y+13	; 0x0d
    2232:	0e 94 94 14 	call	0x2928	; 0x2928 <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    2236:	8a 81       	ldd	r24, Y+2	; 0x02
    2238:	8f 3f       	cpi	r24, 0xFF	; 255
    223a:	a9 f4       	brne	.+42     	; 0x2266 <xQueueGenericSendFromISR+0x92>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    223c:	eb 81       	ldd	r30, Y+3	; 0x03
    223e:	fc 81       	ldd	r31, Y+4	; 0x04
    2240:	81 89       	ldd	r24, Z+17	; 0x11
    2242:	88 23       	and	r24, r24
    2244:	a9 f0       	breq	.+42     	; 0x2270 <xQueueGenericSendFromISR+0x9c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2246:	8b 81       	ldd	r24, Y+3	; 0x03
    2248:	9c 81       	ldd	r25, Y+4	; 0x04
    224a:	41 96       	adiw	r24, 0x11	; 17
    224c:	0e 94 51 20 	call	0x40a2	; 0x40a2 <xTaskRemoveFromEventList>
    2250:	88 23       	and	r24, r24
    2252:	71 f0       	breq	.+28     	; 0x2270 <xQueueGenericSendFromISR+0x9c>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    2254:	8b 85       	ldd	r24, Y+11	; 0x0b
    2256:	9c 85       	ldd	r25, Y+12	; 0x0c
    2258:	00 97       	sbiw	r24, 0x00	; 0
    225a:	51 f0       	breq	.+20     	; 0x2270 <xQueueGenericSendFromISR+0x9c>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    225c:	eb 85       	ldd	r30, Y+11	; 0x0b
    225e:	fc 85       	ldd	r31, Y+12	; 0x0c
    2260:	81 e0       	ldi	r24, 0x01	; 1
    2262:	80 83       	st	Z, r24
    2264:	05 c0       	rjmp	.+10     	; 0x2270 <xQueueGenericSendFromISR+0x9c>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2266:	8a 81       	ldd	r24, Y+2	; 0x02
    2268:	8f 5f       	subi	r24, 0xFF	; 255
    226a:	eb 81       	ldd	r30, Y+3	; 0x03
    226c:	fc 81       	ldd	r31, Y+4	; 0x04
    226e:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    2270:	81 e0       	ldi	r24, 0x01	; 1
    2272:	8e 83       	std	Y+6, r24	; 0x06
    2274:	01 c0       	rjmp	.+2      	; 0x2278 <xQueueGenericSendFromISR+0xa4>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    2276:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2278:	8e 81       	ldd	r24, Y+6	; 0x06
}
    227a:	2d 96       	adiw	r28, 0x0d	; 13
    227c:	0f b6       	in	r0, 0x3f	; 63
    227e:	f8 94       	cli
    2280:	de bf       	out	0x3e, r29	; 62
    2282:	0f be       	out	0x3f, r0	; 63
    2284:	cd bf       	out	0x3d, r28	; 61
    2286:	cf 91       	pop	r28
    2288:	df 91       	pop	r29
    228a:	08 95       	ret

0000228c <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    228c:	df 93       	push	r29
    228e:	cf 93       	push	r28
    2290:	cd b7       	in	r28, 0x3d	; 61
    2292:	de b7       	in	r29, 0x3e	; 62
    2294:	2a 97       	sbiw	r28, 0x0a	; 10
    2296:	0f b6       	in	r0, 0x3f	; 63
    2298:	f8 94       	cli
    229a:	de bf       	out	0x3e, r29	; 62
    229c:	0f be       	out	0x3f, r0	; 63
    229e:	cd bf       	out	0x3d, r28	; 61
    22a0:	98 87       	std	Y+8, r25	; 0x08
    22a2:	8f 83       	std	Y+7, r24	; 0x07
    22a4:	7a 87       	std	Y+10, r23	; 0x0a
    22a6:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    22a8:	8f 81       	ldd	r24, Y+7	; 0x07
    22aa:	98 85       	ldd	r25, Y+8	; 0x08
    22ac:	9c 83       	std	Y+4, r25	; 0x04
    22ae:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    22b0:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    22b2:	eb 81       	ldd	r30, Y+3	; 0x03
    22b4:	fc 81       	ldd	r31, Y+4	; 0x04
    22b6:	82 8d       	ldd	r24, Z+26	; 0x1a
    22b8:	8a 83       	std	Y+2, r24	; 0x02

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    22ba:	eb 81       	ldd	r30, Y+3	; 0x03
    22bc:	fc 81       	ldd	r31, Y+4	; 0x04
    22be:	93 8d       	ldd	r25, Z+27	; 0x1b
    22c0:	8a 81       	ldd	r24, Y+2	; 0x02
    22c2:	89 17       	cp	r24, r25
    22c4:	48 f5       	brcc	.+82     	; 0x2318 <xQueueGiveFromISR+0x8c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    22c6:	eb 81       	ldd	r30, Y+3	; 0x03
    22c8:	fc 81       	ldd	r31, Y+4	; 0x04
    22ca:	86 8d       	ldd	r24, Z+30	; 0x1e
    22cc:	89 83       	std	Y+1, r24	; 0x01
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    22ce:	8a 81       	ldd	r24, Y+2	; 0x02
    22d0:	8f 5f       	subi	r24, 0xFF	; 255
    22d2:	eb 81       	ldd	r30, Y+3	; 0x03
    22d4:	fc 81       	ldd	r31, Y+4	; 0x04
    22d6:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    22d8:	89 81       	ldd	r24, Y+1	; 0x01
    22da:	8f 3f       	cpi	r24, 0xFF	; 255
    22dc:	a9 f4       	brne	.+42     	; 0x2308 <xQueueGiveFromISR+0x7c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    22de:	eb 81       	ldd	r30, Y+3	; 0x03
    22e0:	fc 81       	ldd	r31, Y+4	; 0x04
    22e2:	81 89       	ldd	r24, Z+17	; 0x11
    22e4:	88 23       	and	r24, r24
    22e6:	a9 f0       	breq	.+42     	; 0x2312 <xQueueGiveFromISR+0x86>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    22e8:	8b 81       	ldd	r24, Y+3	; 0x03
    22ea:	9c 81       	ldd	r25, Y+4	; 0x04
    22ec:	41 96       	adiw	r24, 0x11	; 17
    22ee:	0e 94 51 20 	call	0x40a2	; 0x40a2 <xTaskRemoveFromEventList>
    22f2:	88 23       	and	r24, r24
    22f4:	71 f0       	breq	.+28     	; 0x2312 <xQueueGiveFromISR+0x86>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    22f6:	89 85       	ldd	r24, Y+9	; 0x09
    22f8:	9a 85       	ldd	r25, Y+10	; 0x0a
    22fa:	00 97       	sbiw	r24, 0x00	; 0
    22fc:	51 f0       	breq	.+20     	; 0x2312 <xQueueGiveFromISR+0x86>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    22fe:	e9 85       	ldd	r30, Y+9	; 0x09
    2300:	fa 85       	ldd	r31, Y+10	; 0x0a
    2302:	81 e0       	ldi	r24, 0x01	; 1
    2304:	80 83       	st	Z, r24
    2306:	05 c0       	rjmp	.+10     	; 0x2312 <xQueueGiveFromISR+0x86>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    2308:	89 81       	ldd	r24, Y+1	; 0x01
    230a:	8f 5f       	subi	r24, 0xFF	; 255
    230c:	eb 81       	ldd	r30, Y+3	; 0x03
    230e:	fc 81       	ldd	r31, Y+4	; 0x04
    2310:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    2312:	81 e0       	ldi	r24, 0x01	; 1
    2314:	8e 83       	std	Y+6, r24	; 0x06
    2316:	01 c0       	rjmp	.+2      	; 0x231a <xQueueGiveFromISR+0x8e>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    2318:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    231a:	8e 81       	ldd	r24, Y+6	; 0x06
}
    231c:	2a 96       	adiw	r28, 0x0a	; 10
    231e:	0f b6       	in	r0, 0x3f	; 63
    2320:	f8 94       	cli
    2322:	de bf       	out	0x3e, r29	; 62
    2324:	0f be       	out	0x3f, r0	; 63
    2326:	cd bf       	out	0x3d, r28	; 61
    2328:	cf 91       	pop	r28
    232a:	df 91       	pop	r29
    232c:	08 95       	ret

0000232e <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    232e:	df 93       	push	r29
    2330:	cf 93       	push	r28
    2332:	cd b7       	in	r28, 0x3d	; 61
    2334:	de b7       	in	r29, 0x3e	; 62
    2336:	2e 97       	sbiw	r28, 0x0e	; 14
    2338:	0f b6       	in	r0, 0x3f	; 63
    233a:	f8 94       	cli
    233c:	de bf       	out	0x3e, r29	; 62
    233e:	0f be       	out	0x3f, r0	; 63
    2340:	cd bf       	out	0x3d, r28	; 61
    2342:	99 87       	std	Y+9, r25	; 0x09
    2344:	88 87       	std	Y+8, r24	; 0x08
    2346:	7b 87       	std	Y+11, r23	; 0x0b
    2348:	6a 87       	std	Y+10, r22	; 0x0a
    234a:	5d 87       	std	Y+13, r21	; 0x0d
    234c:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    234e:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2350:	88 85       	ldd	r24, Y+8	; 0x08
    2352:	99 85       	ldd	r25, Y+9	; 0x09
    2354:	9b 83       	std	Y+3, r25	; 0x03
    2356:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2358:	0f b6       	in	r0, 0x3f	; 63
    235a:	f8 94       	cli
    235c:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    235e:	ea 81       	ldd	r30, Y+2	; 0x02
    2360:	fb 81       	ldd	r31, Y+3	; 0x03
    2362:	82 8d       	ldd	r24, Z+26	; 0x1a
    2364:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2366:	89 81       	ldd	r24, Y+1	; 0x01
    2368:	88 23       	and	r24, r24
    236a:	f9 f0       	breq	.+62     	; 0x23aa <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    236c:	8a 81       	ldd	r24, Y+2	; 0x02
    236e:	9b 81       	ldd	r25, Y+3	; 0x03
    2370:	2a 85       	ldd	r18, Y+10	; 0x0a
    2372:	3b 85       	ldd	r19, Y+11	; 0x0b
    2374:	b9 01       	movw	r22, r18
    2376:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    237a:	89 81       	ldd	r24, Y+1	; 0x01
    237c:	81 50       	subi	r24, 0x01	; 1
    237e:	ea 81       	ldd	r30, Y+2	; 0x02
    2380:	fb 81       	ldd	r31, Y+3	; 0x03
    2382:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2384:	ea 81       	ldd	r30, Y+2	; 0x02
    2386:	fb 81       	ldd	r31, Y+3	; 0x03
    2388:	80 85       	ldd	r24, Z+8	; 0x08
    238a:	88 23       	and	r24, r24
    238c:	49 f0       	breq	.+18     	; 0x23a0 <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    238e:	8a 81       	ldd	r24, Y+2	; 0x02
    2390:	9b 81       	ldd	r25, Y+3	; 0x03
    2392:	08 96       	adiw	r24, 0x08	; 8
    2394:	0e 94 51 20 	call	0x40a2	; 0x40a2 <xTaskRemoveFromEventList>
    2398:	88 23       	and	r24, r24
    239a:	11 f0       	breq	.+4      	; 0x23a0 <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    239c:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    23a0:	0f 90       	pop	r0
    23a2:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    23a4:	81 e0       	ldi	r24, 0x01	; 1
    23a6:	8e 87       	std	Y+14, r24	; 0x0e
    23a8:	63 c0       	rjmp	.+198    	; 0x2470 <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    23aa:	8c 85       	ldd	r24, Y+12	; 0x0c
    23ac:	9d 85       	ldd	r25, Y+13	; 0x0d
    23ae:	00 97       	sbiw	r24, 0x00	; 0
    23b0:	21 f4       	brne	.+8      	; 0x23ba <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    23b2:	0f 90       	pop	r0
    23b4:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    23b6:	1e 86       	std	Y+14, r1	; 0x0e
    23b8:	5b c0       	rjmp	.+182    	; 0x2470 <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    23ba:	8c 81       	ldd	r24, Y+4	; 0x04
    23bc:	88 23       	and	r24, r24
    23be:	31 f4       	brne	.+12     	; 0x23cc <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    23c0:	ce 01       	movw	r24, r28
    23c2:	05 96       	adiw	r24, 0x05	; 5
    23c4:	0e 94 c1 22 	call	0x4582	; 0x4582 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    23c8:	81 e0       	ldi	r24, 0x01	; 1
    23ca:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    23cc:	0f 90       	pop	r0
    23ce:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    23d0:	0e 94 8b 1b 	call	0x3716	; 0x3716 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    23d4:	0f b6       	in	r0, 0x3f	; 63
    23d6:	f8 94       	cli
    23d8:	0f 92       	push	r0
    23da:	ea 81       	ldd	r30, Y+2	; 0x02
    23dc:	fb 81       	ldd	r31, Y+3	; 0x03
    23de:	85 8d       	ldd	r24, Z+29	; 0x1d
    23e0:	8f 3f       	cpi	r24, 0xFF	; 255
    23e2:	19 f4       	brne	.+6      	; 0x23ea <xQueueReceive+0xbc>
    23e4:	ea 81       	ldd	r30, Y+2	; 0x02
    23e6:	fb 81       	ldd	r31, Y+3	; 0x03
    23e8:	15 8e       	std	Z+29, r1	; 0x1d
    23ea:	ea 81       	ldd	r30, Y+2	; 0x02
    23ec:	fb 81       	ldd	r31, Y+3	; 0x03
    23ee:	86 8d       	ldd	r24, Z+30	; 0x1e
    23f0:	8f 3f       	cpi	r24, 0xFF	; 255
    23f2:	19 f4       	brne	.+6      	; 0x23fa <xQueueReceive+0xcc>
    23f4:	ea 81       	ldd	r30, Y+2	; 0x02
    23f6:	fb 81       	ldd	r31, Y+3	; 0x03
    23f8:	16 8e       	std	Z+30, r1	; 0x1e
    23fa:	0f 90       	pop	r0
    23fc:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    23fe:	ce 01       	movw	r24, r28
    2400:	05 96       	adiw	r24, 0x05	; 5
    2402:	9e 01       	movw	r18, r28
    2404:	24 5f       	subi	r18, 0xF4	; 244
    2406:	3f 4f       	sbci	r19, 0xFF	; 255
    2408:	b9 01       	movw	r22, r18
    240a:	0e 94 da 22 	call	0x45b4	; 0x45b4 <xTaskCheckForTimeOut>
    240e:	88 23       	and	r24, r24
    2410:	09 f5       	brne	.+66     	; 0x2454 <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2412:	8a 81       	ldd	r24, Y+2	; 0x02
    2414:	9b 81       	ldd	r25, Y+3	; 0x03
    2416:	0e 94 d4 15 	call	0x2ba8	; 0x2ba8 <prvIsQueueEmpty>
    241a:	88 23       	and	r24, r24
    241c:	a1 f0       	breq	.+40     	; 0x2446 <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    241e:	8a 81       	ldd	r24, Y+2	; 0x02
    2420:	9b 81       	ldd	r25, Y+3	; 0x03
    2422:	41 96       	adiw	r24, 0x11	; 17
    2424:	2c 85       	ldd	r18, Y+12	; 0x0c
    2426:	3d 85       	ldd	r19, Y+13	; 0x0d
    2428:	b9 01       	movw	r22, r18
    242a:	0e 94 68 1f 	call	0x3ed0	; 0x3ed0 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    242e:	8a 81       	ldd	r24, Y+2	; 0x02
    2430:	9b 81       	ldd	r25, Y+3	; 0x03
    2432:	0e 94 81 15 	call	0x2b02	; 0x2b02 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2436:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>
    243a:	88 23       	and	r24, r24
    243c:	09 f0       	breq	.+2      	; 0x2440 <xQueueReceive+0x112>
    243e:	8c cf       	rjmp	.-232    	; 0x2358 <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    2440:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    2444:	89 cf       	rjmp	.-238    	; 0x2358 <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    2446:	8a 81       	ldd	r24, Y+2	; 0x02
    2448:	9b 81       	ldd	r25, Y+3	; 0x03
    244a:	0e 94 81 15 	call	0x2b02	; 0x2b02 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    244e:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>
    2452:	82 cf       	rjmp	.-252    	; 0x2358 <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    2454:	8a 81       	ldd	r24, Y+2	; 0x02
    2456:	9b 81       	ldd	r25, Y+3	; 0x03
    2458:	0e 94 81 15 	call	0x2b02	; 0x2b02 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    245c:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2460:	8a 81       	ldd	r24, Y+2	; 0x02
    2462:	9b 81       	ldd	r25, Y+3	; 0x03
    2464:	0e 94 d4 15 	call	0x2ba8	; 0x2ba8 <prvIsQueueEmpty>
    2468:	88 23       	and	r24, r24
    246a:	09 f4       	brne	.+2      	; 0x246e <xQueueReceive+0x140>
    246c:	75 cf       	rjmp	.-278    	; 0x2358 <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    246e:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2470:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    2472:	2e 96       	adiw	r28, 0x0e	; 14
    2474:	0f b6       	in	r0, 0x3f	; 63
    2476:	f8 94       	cli
    2478:	de bf       	out	0x3e, r29	; 62
    247a:	0f be       	out	0x3f, r0	; 63
    247c:	cd bf       	out	0x3d, r28	; 61
    247e:	cf 91       	pop	r28
    2480:	df 91       	pop	r29
    2482:	08 95       	ret

00002484 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    2484:	df 93       	push	r29
    2486:	cf 93       	push	r28
    2488:	cd b7       	in	r28, 0x3d	; 61
    248a:	de b7       	in	r29, 0x3e	; 62
    248c:	2c 97       	sbiw	r28, 0x0c	; 12
    248e:	0f b6       	in	r0, 0x3f	; 63
    2490:	f8 94       	cli
    2492:	de bf       	out	0x3e, r29	; 62
    2494:	0f be       	out	0x3f, r0	; 63
    2496:	cd bf       	out	0x3d, r28	; 61
    2498:	99 87       	std	Y+9, r25	; 0x09
    249a:	88 87       	std	Y+8, r24	; 0x08
    249c:	7b 87       	std	Y+11, r23	; 0x0b
    249e:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    24a0:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    24a2:	88 85       	ldd	r24, Y+8	; 0x08
    24a4:	99 85       	ldd	r25, Y+9	; 0x09
    24a6:	9b 83       	std	Y+3, r25	; 0x03
    24a8:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    24aa:	0f b6       	in	r0, 0x3f	; 63
    24ac:	f8 94       	cli
    24ae:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    24b0:	ea 81       	ldd	r30, Y+2	; 0x02
    24b2:	fb 81       	ldd	r31, Y+3	; 0x03
    24b4:	82 8d       	ldd	r24, Z+26	; 0x1a
    24b6:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    24b8:	89 81       	ldd	r24, Y+1	; 0x01
    24ba:	88 23       	and	r24, r24
    24bc:	c1 f0       	breq	.+48     	; 0x24ee <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    24be:	89 81       	ldd	r24, Y+1	; 0x01
    24c0:	81 50       	subi	r24, 0x01	; 1
    24c2:	ea 81       	ldd	r30, Y+2	; 0x02
    24c4:	fb 81       	ldd	r31, Y+3	; 0x03
    24c6:	82 8f       	std	Z+26, r24	; 0x1a
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24c8:	ea 81       	ldd	r30, Y+2	; 0x02
    24ca:	fb 81       	ldd	r31, Y+3	; 0x03
    24cc:	80 85       	ldd	r24, Z+8	; 0x08
    24ce:	88 23       	and	r24, r24
    24d0:	49 f0       	breq	.+18     	; 0x24e4 <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    24d2:	8a 81       	ldd	r24, Y+2	; 0x02
    24d4:	9b 81       	ldd	r25, Y+3	; 0x03
    24d6:	08 96       	adiw	r24, 0x08	; 8
    24d8:	0e 94 51 20 	call	0x40a2	; 0x40a2 <xTaskRemoveFromEventList>
    24dc:	88 23       	and	r24, r24
    24de:	11 f0       	breq	.+4      	; 0x24e4 <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    24e0:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    24e4:	0f 90       	pop	r0
    24e6:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    24e8:	81 e0       	ldi	r24, 0x01	; 1
    24ea:	8c 87       	std	Y+12, r24	; 0x0c
    24ec:	63 c0       	rjmp	.+198    	; 0x25b4 <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    24ee:	8a 85       	ldd	r24, Y+10	; 0x0a
    24f0:	9b 85       	ldd	r25, Y+11	; 0x0b
    24f2:	00 97       	sbiw	r24, 0x00	; 0
    24f4:	21 f4       	brne	.+8      	; 0x24fe <xQueueSemaphoreTake+0x7a>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    24f6:	0f 90       	pop	r0
    24f8:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    24fa:	1c 86       	std	Y+12, r1	; 0x0c
    24fc:	5b c0       	rjmp	.+182    	; 0x25b4 <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    24fe:	8c 81       	ldd	r24, Y+4	; 0x04
    2500:	88 23       	and	r24, r24
    2502:	31 f4       	brne	.+12     	; 0x2510 <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2504:	ce 01       	movw	r24, r28
    2506:	05 96       	adiw	r24, 0x05	; 5
    2508:	0e 94 c1 22 	call	0x4582	; 0x4582 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    250c:	81 e0       	ldi	r24, 0x01	; 1
    250e:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2510:	0f 90       	pop	r0
    2512:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2514:	0e 94 8b 1b 	call	0x3716	; 0x3716 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2518:	0f b6       	in	r0, 0x3f	; 63
    251a:	f8 94       	cli
    251c:	0f 92       	push	r0
    251e:	ea 81       	ldd	r30, Y+2	; 0x02
    2520:	fb 81       	ldd	r31, Y+3	; 0x03
    2522:	85 8d       	ldd	r24, Z+29	; 0x1d
    2524:	8f 3f       	cpi	r24, 0xFF	; 255
    2526:	19 f4       	brne	.+6      	; 0x252e <xQueueSemaphoreTake+0xaa>
    2528:	ea 81       	ldd	r30, Y+2	; 0x02
    252a:	fb 81       	ldd	r31, Y+3	; 0x03
    252c:	15 8e       	std	Z+29, r1	; 0x1d
    252e:	ea 81       	ldd	r30, Y+2	; 0x02
    2530:	fb 81       	ldd	r31, Y+3	; 0x03
    2532:	86 8d       	ldd	r24, Z+30	; 0x1e
    2534:	8f 3f       	cpi	r24, 0xFF	; 255
    2536:	19 f4       	brne	.+6      	; 0x253e <xQueueSemaphoreTake+0xba>
    2538:	ea 81       	ldd	r30, Y+2	; 0x02
    253a:	fb 81       	ldd	r31, Y+3	; 0x03
    253c:	16 8e       	std	Z+30, r1	; 0x1e
    253e:	0f 90       	pop	r0
    2540:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2542:	ce 01       	movw	r24, r28
    2544:	05 96       	adiw	r24, 0x05	; 5
    2546:	9e 01       	movw	r18, r28
    2548:	26 5f       	subi	r18, 0xF6	; 246
    254a:	3f 4f       	sbci	r19, 0xFF	; 255
    254c:	b9 01       	movw	r22, r18
    254e:	0e 94 da 22 	call	0x45b4	; 0x45b4 <xTaskCheckForTimeOut>
    2552:	88 23       	and	r24, r24
    2554:	09 f5       	brne	.+66     	; 0x2598 <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2556:	8a 81       	ldd	r24, Y+2	; 0x02
    2558:	9b 81       	ldd	r25, Y+3	; 0x03
    255a:	0e 94 d4 15 	call	0x2ba8	; 0x2ba8 <prvIsQueueEmpty>
    255e:	88 23       	and	r24, r24
    2560:	a1 f0       	breq	.+40     	; 0x258a <xQueueSemaphoreTake+0x106>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2562:	8a 81       	ldd	r24, Y+2	; 0x02
    2564:	9b 81       	ldd	r25, Y+3	; 0x03
    2566:	41 96       	adiw	r24, 0x11	; 17
    2568:	2a 85       	ldd	r18, Y+10	; 0x0a
    256a:	3b 85       	ldd	r19, Y+11	; 0x0b
    256c:	b9 01       	movw	r22, r18
    256e:	0e 94 68 1f 	call	0x3ed0	; 0x3ed0 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2572:	8a 81       	ldd	r24, Y+2	; 0x02
    2574:	9b 81       	ldd	r25, Y+3	; 0x03
    2576:	0e 94 81 15 	call	0x2b02	; 0x2b02 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    257a:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>
    257e:	88 23       	and	r24, r24
    2580:	09 f0       	breq	.+2      	; 0x2584 <xQueueSemaphoreTake+0x100>
    2582:	93 cf       	rjmp	.-218    	; 0x24aa <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    2584:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    2588:	90 cf       	rjmp	.-224    	; 0x24aa <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    258a:	8a 81       	ldd	r24, Y+2	; 0x02
    258c:	9b 81       	ldd	r25, Y+3	; 0x03
    258e:	0e 94 81 15 	call	0x2b02	; 0x2b02 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2592:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>
    2596:	89 cf       	rjmp	.-238    	; 0x24aa <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    2598:	8a 81       	ldd	r24, Y+2	; 0x02
    259a:	9b 81       	ldd	r25, Y+3	; 0x03
    259c:	0e 94 81 15 	call	0x2b02	; 0x2b02 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    25a0:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    25a4:	8a 81       	ldd	r24, Y+2	; 0x02
    25a6:	9b 81       	ldd	r25, Y+3	; 0x03
    25a8:	0e 94 d4 15 	call	0x2ba8	; 0x2ba8 <prvIsQueueEmpty>
    25ac:	88 23       	and	r24, r24
    25ae:	09 f4       	brne	.+2      	; 0x25b2 <xQueueSemaphoreTake+0x12e>
    25b0:	7c cf       	rjmp	.-264    	; 0x24aa <xQueueSemaphoreTake+0x26>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    25b2:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    25b4:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    25b6:	2c 96       	adiw	r28, 0x0c	; 12
    25b8:	0f b6       	in	r0, 0x3f	; 63
    25ba:	f8 94       	cli
    25bc:	de bf       	out	0x3e, r29	; 62
    25be:	0f be       	out	0x3f, r0	; 63
    25c0:	cd bf       	out	0x3d, r28	; 61
    25c2:	cf 91       	pop	r28
    25c4:	df 91       	pop	r29
    25c6:	08 95       	ret

000025c8 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    25c8:	df 93       	push	r29
    25ca:	cf 93       	push	r28
    25cc:	cd b7       	in	r28, 0x3d	; 61
    25ce:	de b7       	in	r29, 0x3e	; 62
    25d0:	60 97       	sbiw	r28, 0x10	; 16
    25d2:	0f b6       	in	r0, 0x3f	; 63
    25d4:	f8 94       	cli
    25d6:	de bf       	out	0x3e, r29	; 62
    25d8:	0f be       	out	0x3f, r0	; 63
    25da:	cd bf       	out	0x3d, r28	; 61
    25dc:	9b 87       	std	Y+11, r25	; 0x0b
    25de:	8a 87       	std	Y+10, r24	; 0x0a
    25e0:	7d 87       	std	Y+13, r23	; 0x0d
    25e2:	6c 87       	std	Y+12, r22	; 0x0c
    25e4:	5f 87       	std	Y+15, r21	; 0x0f
    25e6:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    25e8:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    25ea:	8a 85       	ldd	r24, Y+10	; 0x0a
    25ec:	9b 85       	ldd	r25, Y+11	; 0x0b
    25ee:	9b 83       	std	Y+3, r25	; 0x03
    25f0:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    25f2:	0f b6       	in	r0, 0x3f	; 63
    25f4:	f8 94       	cli
    25f6:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    25f8:	ea 81       	ldd	r30, Y+2	; 0x02
    25fa:	fb 81       	ldd	r31, Y+3	; 0x03
    25fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    25fe:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2600:	89 81       	ldd	r24, Y+1	; 0x01
    2602:	88 23       	and	r24, r24
    2604:	31 f1       	breq	.+76     	; 0x2652 <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2606:	ea 81       	ldd	r30, Y+2	; 0x02
    2608:	fb 81       	ldd	r31, Y+3	; 0x03
    260a:	86 81       	ldd	r24, Z+6	; 0x06
    260c:	97 81       	ldd	r25, Z+7	; 0x07
    260e:	9d 83       	std	Y+5, r25	; 0x05
    2610:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2612:	8a 81       	ldd	r24, Y+2	; 0x02
    2614:	9b 81       	ldd	r25, Y+3	; 0x03
    2616:	2c 85       	ldd	r18, Y+12	; 0x0c
    2618:	3d 85       	ldd	r19, Y+13	; 0x0d
    261a:	b9 01       	movw	r22, r18
    261c:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2620:	ea 81       	ldd	r30, Y+2	; 0x02
    2622:	fb 81       	ldd	r31, Y+3	; 0x03
    2624:	8c 81       	ldd	r24, Y+4	; 0x04
    2626:	9d 81       	ldd	r25, Y+5	; 0x05
    2628:	97 83       	std	Z+7, r25	; 0x07
    262a:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    262c:	ea 81       	ldd	r30, Y+2	; 0x02
    262e:	fb 81       	ldd	r31, Y+3	; 0x03
    2630:	81 89       	ldd	r24, Z+17	; 0x11
    2632:	88 23       	and	r24, r24
    2634:	49 f0       	breq	.+18     	; 0x2648 <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2636:	8a 81       	ldd	r24, Y+2	; 0x02
    2638:	9b 81       	ldd	r25, Y+3	; 0x03
    263a:	41 96       	adiw	r24, 0x11	; 17
    263c:	0e 94 51 20 	call	0x40a2	; 0x40a2 <xTaskRemoveFromEventList>
    2640:	88 23       	and	r24, r24
    2642:	11 f0       	breq	.+4      	; 0x2648 <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    2644:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2648:	0f 90       	pop	r0
    264a:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    264c:	81 e0       	ldi	r24, 0x01	; 1
    264e:	88 8b       	std	Y+16, r24	; 0x10
    2650:	63 c0       	rjmp	.+198    	; 0x2718 <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2652:	8e 85       	ldd	r24, Y+14	; 0x0e
    2654:	9f 85       	ldd	r25, Y+15	; 0x0f
    2656:	00 97       	sbiw	r24, 0x00	; 0
    2658:	21 f4       	brne	.+8      	; 0x2662 <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    265a:	0f 90       	pop	r0
    265c:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    265e:	18 8a       	std	Y+16, r1	; 0x10
    2660:	5b c0       	rjmp	.+182    	; 0x2718 <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    2662:	8e 81       	ldd	r24, Y+6	; 0x06
    2664:	88 23       	and	r24, r24
    2666:	31 f4       	brne	.+12     	; 0x2674 <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2668:	ce 01       	movw	r24, r28
    266a:	07 96       	adiw	r24, 0x07	; 7
    266c:	0e 94 c1 22 	call	0x4582	; 0x4582 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2670:	81 e0       	ldi	r24, 0x01	; 1
    2672:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2674:	0f 90       	pop	r0
    2676:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    2678:	0e 94 8b 1b 	call	0x3716	; 0x3716 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    267c:	0f b6       	in	r0, 0x3f	; 63
    267e:	f8 94       	cli
    2680:	0f 92       	push	r0
    2682:	ea 81       	ldd	r30, Y+2	; 0x02
    2684:	fb 81       	ldd	r31, Y+3	; 0x03
    2686:	85 8d       	ldd	r24, Z+29	; 0x1d
    2688:	8f 3f       	cpi	r24, 0xFF	; 255
    268a:	19 f4       	brne	.+6      	; 0x2692 <xQueuePeek+0xca>
    268c:	ea 81       	ldd	r30, Y+2	; 0x02
    268e:	fb 81       	ldd	r31, Y+3	; 0x03
    2690:	15 8e       	std	Z+29, r1	; 0x1d
    2692:	ea 81       	ldd	r30, Y+2	; 0x02
    2694:	fb 81       	ldd	r31, Y+3	; 0x03
    2696:	86 8d       	ldd	r24, Z+30	; 0x1e
    2698:	8f 3f       	cpi	r24, 0xFF	; 255
    269a:	19 f4       	brne	.+6      	; 0x26a2 <xQueuePeek+0xda>
    269c:	ea 81       	ldd	r30, Y+2	; 0x02
    269e:	fb 81       	ldd	r31, Y+3	; 0x03
    26a0:	16 8e       	std	Z+30, r1	; 0x1e
    26a2:	0f 90       	pop	r0
    26a4:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    26a6:	ce 01       	movw	r24, r28
    26a8:	07 96       	adiw	r24, 0x07	; 7
    26aa:	9e 01       	movw	r18, r28
    26ac:	22 5f       	subi	r18, 0xF2	; 242
    26ae:	3f 4f       	sbci	r19, 0xFF	; 255
    26b0:	b9 01       	movw	r22, r18
    26b2:	0e 94 da 22 	call	0x45b4	; 0x45b4 <xTaskCheckForTimeOut>
    26b6:	88 23       	and	r24, r24
    26b8:	09 f5       	brne	.+66     	; 0x26fc <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    26ba:	8a 81       	ldd	r24, Y+2	; 0x02
    26bc:	9b 81       	ldd	r25, Y+3	; 0x03
    26be:	0e 94 d4 15 	call	0x2ba8	; 0x2ba8 <prvIsQueueEmpty>
    26c2:	88 23       	and	r24, r24
    26c4:	a1 f0       	breq	.+40     	; 0x26ee <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    26c6:	8a 81       	ldd	r24, Y+2	; 0x02
    26c8:	9b 81       	ldd	r25, Y+3	; 0x03
    26ca:	41 96       	adiw	r24, 0x11	; 17
    26cc:	2e 85       	ldd	r18, Y+14	; 0x0e
    26ce:	3f 85       	ldd	r19, Y+15	; 0x0f
    26d0:	b9 01       	movw	r22, r18
    26d2:	0e 94 68 1f 	call	0x3ed0	; 0x3ed0 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    26d6:	8a 81       	ldd	r24, Y+2	; 0x02
    26d8:	9b 81       	ldd	r25, Y+3	; 0x03
    26da:	0e 94 81 15 	call	0x2b02	; 0x2b02 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    26de:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>
    26e2:	88 23       	and	r24, r24
    26e4:	09 f0       	breq	.+2      	; 0x26e8 <xQueuePeek+0x120>
    26e6:	85 cf       	rjmp	.-246    	; 0x25f2 <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    26e8:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    26ec:	82 cf       	rjmp	.-252    	; 0x25f2 <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    26ee:	8a 81       	ldd	r24, Y+2	; 0x02
    26f0:	9b 81       	ldd	r25, Y+3	; 0x03
    26f2:	0e 94 81 15 	call	0x2b02	; 0x2b02 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    26f6:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>
    26fa:	7b cf       	rjmp	.-266    	; 0x25f2 <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    26fc:	8a 81       	ldd	r24, Y+2	; 0x02
    26fe:	9b 81       	ldd	r25, Y+3	; 0x03
    2700:	0e 94 81 15 	call	0x2b02	; 0x2b02 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2704:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2708:	8a 81       	ldd	r24, Y+2	; 0x02
    270a:	9b 81       	ldd	r25, Y+3	; 0x03
    270c:	0e 94 d4 15 	call	0x2ba8	; 0x2ba8 <prvIsQueueEmpty>
    2710:	88 23       	and	r24, r24
    2712:	09 f4       	brne	.+2      	; 0x2716 <xQueuePeek+0x14e>
    2714:	6e cf       	rjmp	.-292    	; 0x25f2 <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2716:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2718:	88 89       	ldd	r24, Y+16	; 0x10
}
    271a:	60 96       	adiw	r28, 0x10	; 16
    271c:	0f b6       	in	r0, 0x3f	; 63
    271e:	f8 94       	cli
    2720:	de bf       	out	0x3e, r29	; 62
    2722:	0f be       	out	0x3f, r0	; 63
    2724:	cd bf       	out	0x3d, r28	; 61
    2726:	cf 91       	pop	r28
    2728:	df 91       	pop	r29
    272a:	08 95       	ret

0000272c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    272c:	df 93       	push	r29
    272e:	cf 93       	push	r28
    2730:	cd b7       	in	r28, 0x3d	; 61
    2732:	de b7       	in	r29, 0x3e	; 62
    2734:	2c 97       	sbiw	r28, 0x0c	; 12
    2736:	0f b6       	in	r0, 0x3f	; 63
    2738:	f8 94       	cli
    273a:	de bf       	out	0x3e, r29	; 62
    273c:	0f be       	out	0x3f, r0	; 63
    273e:	cd bf       	out	0x3d, r28	; 61
    2740:	98 87       	std	Y+8, r25	; 0x08
    2742:	8f 83       	std	Y+7, r24	; 0x07
    2744:	7a 87       	std	Y+10, r23	; 0x0a
    2746:	69 87       	std	Y+9, r22	; 0x09
    2748:	5c 87       	std	Y+12, r21	; 0x0c
    274a:	4b 87       	std	Y+11, r20	; 0x0b
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    274c:	8f 81       	ldd	r24, Y+7	; 0x07
    274e:	98 85       	ldd	r25, Y+8	; 0x08
    2750:	9c 83       	std	Y+4, r25	; 0x04
    2752:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2754:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2756:	eb 81       	ldd	r30, Y+3	; 0x03
    2758:	fc 81       	ldd	r31, Y+4	; 0x04
    275a:	82 8d       	ldd	r24, Z+26	; 0x1a
    275c:	8a 83       	std	Y+2, r24	; 0x02

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    275e:	8a 81       	ldd	r24, Y+2	; 0x02
    2760:	88 23       	and	r24, r24
    2762:	81 f1       	breq	.+96     	; 0x27c4 <xQueueReceiveFromISR+0x98>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    2764:	eb 81       	ldd	r30, Y+3	; 0x03
    2766:	fc 81       	ldd	r31, Y+4	; 0x04
    2768:	85 8d       	ldd	r24, Z+29	; 0x1d
    276a:	89 83       	std	Y+1, r24	; 0x01

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    276c:	8b 81       	ldd	r24, Y+3	; 0x03
    276e:	9c 81       	ldd	r25, Y+4	; 0x04
    2770:	29 85       	ldd	r18, Y+9	; 0x09
    2772:	3a 85       	ldd	r19, Y+10	; 0x0a
    2774:	b9 01       	movw	r22, r18
    2776:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    277a:	8a 81       	ldd	r24, Y+2	; 0x02
    277c:	81 50       	subi	r24, 0x01	; 1
    277e:	eb 81       	ldd	r30, Y+3	; 0x03
    2780:	fc 81       	ldd	r31, Y+4	; 0x04
    2782:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    2784:	89 81       	ldd	r24, Y+1	; 0x01
    2786:	8f 3f       	cpi	r24, 0xFF	; 255
    2788:	a9 f4       	brne	.+42     	; 0x27b4 <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    278a:	eb 81       	ldd	r30, Y+3	; 0x03
    278c:	fc 81       	ldd	r31, Y+4	; 0x04
    278e:	80 85       	ldd	r24, Z+8	; 0x08
    2790:	88 23       	and	r24, r24
    2792:	a9 f0       	breq	.+42     	; 0x27be <xQueueReceiveFromISR+0x92>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2794:	8b 81       	ldd	r24, Y+3	; 0x03
    2796:	9c 81       	ldd	r25, Y+4	; 0x04
    2798:	08 96       	adiw	r24, 0x08	; 8
    279a:	0e 94 51 20 	call	0x40a2	; 0x40a2 <xTaskRemoveFromEventList>
    279e:	88 23       	and	r24, r24
    27a0:	71 f0       	breq	.+28     	; 0x27be <xQueueReceiveFromISR+0x92>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    27a2:	8b 85       	ldd	r24, Y+11	; 0x0b
    27a4:	9c 85       	ldd	r25, Y+12	; 0x0c
    27a6:	00 97       	sbiw	r24, 0x00	; 0
    27a8:	51 f0       	breq	.+20     	; 0x27be <xQueueReceiveFromISR+0x92>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    27aa:	eb 85       	ldd	r30, Y+11	; 0x0b
    27ac:	fc 85       	ldd	r31, Y+12	; 0x0c
    27ae:	81 e0       	ldi	r24, 0x01	; 1
    27b0:	80 83       	st	Z, r24
    27b2:	05 c0       	rjmp	.+10     	; 0x27be <xQueueReceiveFromISR+0x92>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    27b4:	89 81       	ldd	r24, Y+1	; 0x01
    27b6:	8f 5f       	subi	r24, 0xFF	; 255
    27b8:	eb 81       	ldd	r30, Y+3	; 0x03
    27ba:	fc 81       	ldd	r31, Y+4	; 0x04
    27bc:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    27be:	81 e0       	ldi	r24, 0x01	; 1
    27c0:	8e 83       	std	Y+6, r24	; 0x06
    27c2:	01 c0       	rjmp	.+2      	; 0x27c6 <xQueueReceiveFromISR+0x9a>
        }
        else
        {
            xReturn = pdFAIL;
    27c4:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    27c6:	8e 81       	ldd	r24, Y+6	; 0x06
}
    27c8:	2c 96       	adiw	r28, 0x0c	; 12
    27ca:	0f b6       	in	r0, 0x3f	; 63
    27cc:	f8 94       	cli
    27ce:	de bf       	out	0x3e, r29	; 62
    27d0:	0f be       	out	0x3f, r0	; 63
    27d2:	cd bf       	out	0x3d, r28	; 61
    27d4:	cf 91       	pop	r28
    27d6:	df 91       	pop	r29
    27d8:	08 95       	ret

000027da <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    27da:	df 93       	push	r29
    27dc:	cf 93       	push	r28
    27de:	cd b7       	in	r28, 0x3d	; 61
    27e0:	de b7       	in	r29, 0x3e	; 62
    27e2:	2a 97       	sbiw	r28, 0x0a	; 10
    27e4:	0f b6       	in	r0, 0x3f	; 63
    27e6:	f8 94       	cli
    27e8:	de bf       	out	0x3e, r29	; 62
    27ea:	0f be       	out	0x3f, r0	; 63
    27ec:	cd bf       	out	0x3d, r28	; 61
    27ee:	98 87       	std	Y+8, r25	; 0x08
    27f0:	8f 83       	std	Y+7, r24	; 0x07
    27f2:	7a 87       	std	Y+10, r23	; 0x0a
    27f4:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    27f6:	8f 81       	ldd	r24, Y+7	; 0x07
    27f8:	98 85       	ldd	r25, Y+8	; 0x08
    27fa:	9a 83       	std	Y+2, r25	; 0x02
    27fc:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    27fe:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2800:	e9 81       	ldd	r30, Y+1	; 0x01
    2802:	fa 81       	ldd	r31, Y+2	; 0x02
    2804:	82 8d       	ldd	r24, Z+26	; 0x1a
    2806:	88 23       	and	r24, r24
    2808:	b1 f0       	breq	.+44     	; 0x2836 <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    280a:	e9 81       	ldd	r30, Y+1	; 0x01
    280c:	fa 81       	ldd	r31, Y+2	; 0x02
    280e:	86 81       	ldd	r24, Z+6	; 0x06
    2810:	97 81       	ldd	r25, Z+7	; 0x07
    2812:	9c 83       	std	Y+4, r25	; 0x04
    2814:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2816:	89 81       	ldd	r24, Y+1	; 0x01
    2818:	9a 81       	ldd	r25, Y+2	; 0x02
    281a:	29 85       	ldd	r18, Y+9	; 0x09
    281c:	3a 85       	ldd	r19, Y+10	; 0x0a
    281e:	b9 01       	movw	r22, r18
    2820:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2824:	e9 81       	ldd	r30, Y+1	; 0x01
    2826:	fa 81       	ldd	r31, Y+2	; 0x02
    2828:	8b 81       	ldd	r24, Y+3	; 0x03
    282a:	9c 81       	ldd	r25, Y+4	; 0x04
    282c:	97 83       	std	Z+7, r25	; 0x07
    282e:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    2830:	81 e0       	ldi	r24, 0x01	; 1
    2832:	8e 83       	std	Y+6, r24	; 0x06
    2834:	01 c0       	rjmp	.+2      	; 0x2838 <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    2836:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    2838:	8e 81       	ldd	r24, Y+6	; 0x06
}
    283a:	2a 96       	adiw	r28, 0x0a	; 10
    283c:	0f b6       	in	r0, 0x3f	; 63
    283e:	f8 94       	cli
    2840:	de bf       	out	0x3e, r29	; 62
    2842:	0f be       	out	0x3f, r0	; 63
    2844:	cd bf       	out	0x3d, r28	; 61
    2846:	cf 91       	pop	r28
    2848:	df 91       	pop	r29
    284a:	08 95       	ret

0000284c <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    284c:	df 93       	push	r29
    284e:	cf 93       	push	r28
    2850:	00 d0       	rcall	.+0      	; 0x2852 <uxQueueMessagesWaiting+0x6>
    2852:	0f 92       	push	r0
    2854:	cd b7       	in	r28, 0x3d	; 61
    2856:	de b7       	in	r29, 0x3e	; 62
    2858:	9b 83       	std	Y+3, r25	; 0x03
    285a:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    285c:	0f b6       	in	r0, 0x3f	; 63
    285e:	f8 94       	cli
    2860:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2862:	ea 81       	ldd	r30, Y+2	; 0x02
    2864:	fb 81       	ldd	r31, Y+3	; 0x03
    2866:	82 8d       	ldd	r24, Z+26	; 0x1a
    2868:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    286a:	0f 90       	pop	r0
    286c:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    286e:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2870:	0f 90       	pop	r0
    2872:	0f 90       	pop	r0
    2874:	0f 90       	pop	r0
    2876:	cf 91       	pop	r28
    2878:	df 91       	pop	r29
    287a:	08 95       	ret

0000287c <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    287c:	df 93       	push	r29
    287e:	cf 93       	push	r28
    2880:	00 d0       	rcall	.+0      	; 0x2882 <uxQueueSpacesAvailable+0x6>
    2882:	00 d0       	rcall	.+0      	; 0x2884 <uxQueueSpacesAvailable+0x8>
    2884:	0f 92       	push	r0
    2886:	cd b7       	in	r28, 0x3d	; 61
    2888:	de b7       	in	r29, 0x3e	; 62
    288a:	9d 83       	std	Y+5, r25	; 0x05
    288c:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    288e:	8c 81       	ldd	r24, Y+4	; 0x04
    2890:	9d 81       	ldd	r25, Y+5	; 0x05
    2892:	9a 83       	std	Y+2, r25	; 0x02
    2894:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    2896:	0f b6       	in	r0, 0x3f	; 63
    2898:	f8 94       	cli
    289a:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    289c:	e9 81       	ldd	r30, Y+1	; 0x01
    289e:	fa 81       	ldd	r31, Y+2	; 0x02
    28a0:	93 8d       	ldd	r25, Z+27	; 0x1b
    28a2:	e9 81       	ldd	r30, Y+1	; 0x01
    28a4:	fa 81       	ldd	r31, Y+2	; 0x02
    28a6:	82 8d       	ldd	r24, Z+26	; 0x1a
    28a8:	29 2f       	mov	r18, r25
    28aa:	28 1b       	sub	r18, r24
    28ac:	82 2f       	mov	r24, r18
    28ae:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    28b0:	0f 90       	pop	r0
    28b2:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    28b4:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    28b6:	0f 90       	pop	r0
    28b8:	0f 90       	pop	r0
    28ba:	0f 90       	pop	r0
    28bc:	0f 90       	pop	r0
    28be:	0f 90       	pop	r0
    28c0:	cf 91       	pop	r28
    28c2:	df 91       	pop	r29
    28c4:	08 95       	ret

000028c6 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    28c6:	df 93       	push	r29
    28c8:	cf 93       	push	r28
    28ca:	00 d0       	rcall	.+0      	; 0x28cc <uxQueueMessagesWaitingFromISR+0x6>
    28cc:	00 d0       	rcall	.+0      	; 0x28ce <uxQueueMessagesWaitingFromISR+0x8>
    28ce:	0f 92       	push	r0
    28d0:	cd b7       	in	r28, 0x3d	; 61
    28d2:	de b7       	in	r29, 0x3e	; 62
    28d4:	9d 83       	std	Y+5, r25	; 0x05
    28d6:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    28d8:	8c 81       	ldd	r24, Y+4	; 0x04
    28da:	9d 81       	ldd	r25, Y+5	; 0x05
    28dc:	9a 83       	std	Y+2, r25	; 0x02
    28de:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    28e0:	e9 81       	ldd	r30, Y+1	; 0x01
    28e2:	fa 81       	ldd	r31, Y+2	; 0x02
    28e4:	82 8d       	ldd	r24, Z+26	; 0x1a
    28e6:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    28e8:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    28ea:	0f 90       	pop	r0
    28ec:	0f 90       	pop	r0
    28ee:	0f 90       	pop	r0
    28f0:	0f 90       	pop	r0
    28f2:	0f 90       	pop	r0
    28f4:	cf 91       	pop	r28
    28f6:	df 91       	pop	r29
    28f8:	08 95       	ret

000028fa <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    28fa:	df 93       	push	r29
    28fc:	cf 93       	push	r28
    28fe:	00 d0       	rcall	.+0      	; 0x2900 <vQueueDelete+0x6>
    2900:	00 d0       	rcall	.+0      	; 0x2902 <vQueueDelete+0x8>
    2902:	cd b7       	in	r28, 0x3d	; 61
    2904:	de b7       	in	r29, 0x3e	; 62
    2906:	9c 83       	std	Y+4, r25	; 0x04
    2908:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    290a:	8b 81       	ldd	r24, Y+3	; 0x03
    290c:	9c 81       	ldd	r25, Y+4	; 0x04
    290e:	9a 83       	std	Y+2, r25	; 0x02
    2910:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    2912:	89 81       	ldd	r24, Y+1	; 0x01
    2914:	9a 81       	ldd	r25, Y+2	; 0x02
    2916:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    291a:	0f 90       	pop	r0
    291c:	0f 90       	pop	r0
    291e:	0f 90       	pop	r0
    2920:	0f 90       	pop	r0
    2922:	cf 91       	pop	r28
    2924:	df 91       	pop	r29
    2926:	08 95       	ret

00002928 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    2928:	df 93       	push	r29
    292a:	cf 93       	push	r28
    292c:	cd b7       	in	r28, 0x3d	; 61
    292e:	de b7       	in	r29, 0x3e	; 62
    2930:	27 97       	sbiw	r28, 0x07	; 7
    2932:	0f b6       	in	r0, 0x3f	; 63
    2934:	f8 94       	cli
    2936:	de bf       	out	0x3e, r29	; 62
    2938:	0f be       	out	0x3f, r0	; 63
    293a:	cd bf       	out	0x3d, r28	; 61
    293c:	9c 83       	std	Y+4, r25	; 0x04
    293e:	8b 83       	std	Y+3, r24	; 0x03
    2940:	7e 83       	std	Y+6, r23	; 0x06
    2942:	6d 83       	std	Y+5, r22	; 0x05
    2944:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    2946:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2948:	eb 81       	ldd	r30, Y+3	; 0x03
    294a:	fc 81       	ldd	r31, Y+4	; 0x04
    294c:	82 8d       	ldd	r24, Z+26	; 0x1a
    294e:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2950:	eb 81       	ldd	r30, Y+3	; 0x03
    2952:	fc 81       	ldd	r31, Y+4	; 0x04
    2954:	84 8d       	ldd	r24, Z+28	; 0x1c
    2956:	88 23       	and	r24, r24
    2958:	09 f4       	brne	.+2      	; 0x295c <prvCopyDataToQueue+0x34>
    295a:	7d c0       	rjmp	.+250    	; 0x2a56 <prvCopyDataToQueue+0x12e>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    295c:	8f 81       	ldd	r24, Y+7	; 0x07
    295e:	88 23       	and	r24, r24
    2960:	99 f5       	brne	.+102    	; 0x29c8 <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2962:	eb 81       	ldd	r30, Y+3	; 0x03
    2964:	fc 81       	ldd	r31, Y+4	; 0x04
    2966:	62 81       	ldd	r22, Z+2	; 0x02
    2968:	73 81       	ldd	r23, Z+3	; 0x03
    296a:	eb 81       	ldd	r30, Y+3	; 0x03
    296c:	fc 81       	ldd	r31, Y+4	; 0x04
    296e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2970:	48 2f       	mov	r20, r24
    2972:	50 e0       	ldi	r21, 0x00	; 0
    2974:	2d 81       	ldd	r18, Y+5	; 0x05
    2976:	3e 81       	ldd	r19, Y+6	; 0x06
    2978:	cb 01       	movw	r24, r22
    297a:	b9 01       	movw	r22, r18
    297c:	0e 94 4b 33 	call	0x6696	; 0x6696 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2980:	eb 81       	ldd	r30, Y+3	; 0x03
    2982:	fc 81       	ldd	r31, Y+4	; 0x04
    2984:	22 81       	ldd	r18, Z+2	; 0x02
    2986:	33 81       	ldd	r19, Z+3	; 0x03
    2988:	eb 81       	ldd	r30, Y+3	; 0x03
    298a:	fc 81       	ldd	r31, Y+4	; 0x04
    298c:	84 8d       	ldd	r24, Z+28	; 0x1c
    298e:	88 2f       	mov	r24, r24
    2990:	90 e0       	ldi	r25, 0x00	; 0
    2992:	82 0f       	add	r24, r18
    2994:	93 1f       	adc	r25, r19
    2996:	eb 81       	ldd	r30, Y+3	; 0x03
    2998:	fc 81       	ldd	r31, Y+4	; 0x04
    299a:	93 83       	std	Z+3, r25	; 0x03
    299c:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    299e:	eb 81       	ldd	r30, Y+3	; 0x03
    29a0:	fc 81       	ldd	r31, Y+4	; 0x04
    29a2:	22 81       	ldd	r18, Z+2	; 0x02
    29a4:	33 81       	ldd	r19, Z+3	; 0x03
    29a6:	eb 81       	ldd	r30, Y+3	; 0x03
    29a8:	fc 81       	ldd	r31, Y+4	; 0x04
    29aa:	84 81       	ldd	r24, Z+4	; 0x04
    29ac:	95 81       	ldd	r25, Z+5	; 0x05
    29ae:	28 17       	cp	r18, r24
    29b0:	39 07       	cpc	r19, r25
    29b2:	08 f4       	brcc	.+2      	; 0x29b6 <prvCopyDataToQueue+0x8e>
    29b4:	50 c0       	rjmp	.+160    	; 0x2a56 <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    29b6:	eb 81       	ldd	r30, Y+3	; 0x03
    29b8:	fc 81       	ldd	r31, Y+4	; 0x04
    29ba:	80 81       	ld	r24, Z
    29bc:	91 81       	ldd	r25, Z+1	; 0x01
    29be:	eb 81       	ldd	r30, Y+3	; 0x03
    29c0:	fc 81       	ldd	r31, Y+4	; 0x04
    29c2:	93 83       	std	Z+3, r25	; 0x03
    29c4:	82 83       	std	Z+2, r24	; 0x02
    29c6:	47 c0       	rjmp	.+142    	; 0x2a56 <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    29c8:	eb 81       	ldd	r30, Y+3	; 0x03
    29ca:	fc 81       	ldd	r31, Y+4	; 0x04
    29cc:	66 81       	ldd	r22, Z+6	; 0x06
    29ce:	77 81       	ldd	r23, Z+7	; 0x07
    29d0:	eb 81       	ldd	r30, Y+3	; 0x03
    29d2:	fc 81       	ldd	r31, Y+4	; 0x04
    29d4:	84 8d       	ldd	r24, Z+28	; 0x1c
    29d6:	48 2f       	mov	r20, r24
    29d8:	50 e0       	ldi	r21, 0x00	; 0
    29da:	2d 81       	ldd	r18, Y+5	; 0x05
    29dc:	3e 81       	ldd	r19, Y+6	; 0x06
    29de:	cb 01       	movw	r24, r22
    29e0:	b9 01       	movw	r22, r18
    29e2:	0e 94 4b 33 	call	0x6696	; 0x6696 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    29e6:	eb 81       	ldd	r30, Y+3	; 0x03
    29e8:	fc 81       	ldd	r31, Y+4	; 0x04
    29ea:	26 81       	ldd	r18, Z+6	; 0x06
    29ec:	37 81       	ldd	r19, Z+7	; 0x07
    29ee:	eb 81       	ldd	r30, Y+3	; 0x03
    29f0:	fc 81       	ldd	r31, Y+4	; 0x04
    29f2:	84 8d       	ldd	r24, Z+28	; 0x1c
    29f4:	88 2f       	mov	r24, r24
    29f6:	90 e0       	ldi	r25, 0x00	; 0
    29f8:	90 95       	com	r25
    29fa:	81 95       	neg	r24
    29fc:	9f 4f       	sbci	r25, 0xFF	; 255
    29fe:	82 0f       	add	r24, r18
    2a00:	93 1f       	adc	r25, r19
    2a02:	eb 81       	ldd	r30, Y+3	; 0x03
    2a04:	fc 81       	ldd	r31, Y+4	; 0x04
    2a06:	97 83       	std	Z+7, r25	; 0x07
    2a08:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2a0a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a0c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a0e:	26 81       	ldd	r18, Z+6	; 0x06
    2a10:	37 81       	ldd	r19, Z+7	; 0x07
    2a12:	eb 81       	ldd	r30, Y+3	; 0x03
    2a14:	fc 81       	ldd	r31, Y+4	; 0x04
    2a16:	80 81       	ld	r24, Z
    2a18:	91 81       	ldd	r25, Z+1	; 0x01
    2a1a:	28 17       	cp	r18, r24
    2a1c:	39 07       	cpc	r19, r25
    2a1e:	90 f4       	brcc	.+36     	; 0x2a44 <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2a20:	eb 81       	ldd	r30, Y+3	; 0x03
    2a22:	fc 81       	ldd	r31, Y+4	; 0x04
    2a24:	24 81       	ldd	r18, Z+4	; 0x04
    2a26:	35 81       	ldd	r19, Z+5	; 0x05
    2a28:	eb 81       	ldd	r30, Y+3	; 0x03
    2a2a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a2c:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a2e:	88 2f       	mov	r24, r24
    2a30:	90 e0       	ldi	r25, 0x00	; 0
    2a32:	90 95       	com	r25
    2a34:	81 95       	neg	r24
    2a36:	9f 4f       	sbci	r25, 0xFF	; 255
    2a38:	82 0f       	add	r24, r18
    2a3a:	93 1f       	adc	r25, r19
    2a3c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a3e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a40:	97 83       	std	Z+7, r25	; 0x07
    2a42:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    2a44:	8f 81       	ldd	r24, Y+7	; 0x07
    2a46:	82 30       	cpi	r24, 0x02	; 2
    2a48:	31 f4       	brne	.+12     	; 0x2a56 <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2a4a:	89 81       	ldd	r24, Y+1	; 0x01
    2a4c:	88 23       	and	r24, r24
    2a4e:	19 f0       	breq	.+6      	; 0x2a56 <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    2a50:	89 81       	ldd	r24, Y+1	; 0x01
    2a52:	81 50       	subi	r24, 0x01	; 1
    2a54:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2a56:	89 81       	ldd	r24, Y+1	; 0x01
    2a58:	8f 5f       	subi	r24, 0xFF	; 255
    2a5a:	eb 81       	ldd	r30, Y+3	; 0x03
    2a5c:	fc 81       	ldd	r31, Y+4	; 0x04
    2a5e:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    2a60:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2a62:	27 96       	adiw	r28, 0x07	; 7
    2a64:	0f b6       	in	r0, 0x3f	; 63
    2a66:	f8 94       	cli
    2a68:	de bf       	out	0x3e, r29	; 62
    2a6a:	0f be       	out	0x3f, r0	; 63
    2a6c:	cd bf       	out	0x3d, r28	; 61
    2a6e:	cf 91       	pop	r28
    2a70:	df 91       	pop	r29
    2a72:	08 95       	ret

00002a74 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    2a74:	df 93       	push	r29
    2a76:	cf 93       	push	r28
    2a78:	00 d0       	rcall	.+0      	; 0x2a7a <prvCopyDataFromQueue+0x6>
    2a7a:	00 d0       	rcall	.+0      	; 0x2a7c <prvCopyDataFromQueue+0x8>
    2a7c:	cd b7       	in	r28, 0x3d	; 61
    2a7e:	de b7       	in	r29, 0x3e	; 62
    2a80:	9a 83       	std	Y+2, r25	; 0x02
    2a82:	89 83       	std	Y+1, r24	; 0x01
    2a84:	7c 83       	std	Y+4, r23	; 0x04
    2a86:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2a88:	e9 81       	ldd	r30, Y+1	; 0x01
    2a8a:	fa 81       	ldd	r31, Y+2	; 0x02
    2a8c:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a8e:	88 23       	and	r24, r24
    2a90:	89 f1       	breq	.+98     	; 0x2af4 <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2a92:	e9 81       	ldd	r30, Y+1	; 0x01
    2a94:	fa 81       	ldd	r31, Y+2	; 0x02
    2a96:	26 81       	ldd	r18, Z+6	; 0x06
    2a98:	37 81       	ldd	r19, Z+7	; 0x07
    2a9a:	e9 81       	ldd	r30, Y+1	; 0x01
    2a9c:	fa 81       	ldd	r31, Y+2	; 0x02
    2a9e:	84 8d       	ldd	r24, Z+28	; 0x1c
    2aa0:	88 2f       	mov	r24, r24
    2aa2:	90 e0       	ldi	r25, 0x00	; 0
    2aa4:	82 0f       	add	r24, r18
    2aa6:	93 1f       	adc	r25, r19
    2aa8:	e9 81       	ldd	r30, Y+1	; 0x01
    2aaa:	fa 81       	ldd	r31, Y+2	; 0x02
    2aac:	97 83       	std	Z+7, r25	; 0x07
    2aae:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2ab0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ab2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ab4:	26 81       	ldd	r18, Z+6	; 0x06
    2ab6:	37 81       	ldd	r19, Z+7	; 0x07
    2ab8:	e9 81       	ldd	r30, Y+1	; 0x01
    2aba:	fa 81       	ldd	r31, Y+2	; 0x02
    2abc:	84 81       	ldd	r24, Z+4	; 0x04
    2abe:	95 81       	ldd	r25, Z+5	; 0x05
    2ac0:	28 17       	cp	r18, r24
    2ac2:	39 07       	cpc	r19, r25
    2ac4:	40 f0       	brcs	.+16     	; 0x2ad6 <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2ac6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ac8:	fa 81       	ldd	r31, Y+2	; 0x02
    2aca:	80 81       	ld	r24, Z
    2acc:	91 81       	ldd	r25, Z+1	; 0x01
    2ace:	e9 81       	ldd	r30, Y+1	; 0x01
    2ad0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ad2:	97 83       	std	Z+7, r25	; 0x07
    2ad4:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2ad6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ad8:	fa 81       	ldd	r31, Y+2	; 0x02
    2ada:	46 81       	ldd	r20, Z+6	; 0x06
    2adc:	57 81       	ldd	r21, Z+7	; 0x07
    2ade:	e9 81       	ldd	r30, Y+1	; 0x01
    2ae0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ae2:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ae4:	28 2f       	mov	r18, r24
    2ae6:	30 e0       	ldi	r19, 0x00	; 0
    2ae8:	8b 81       	ldd	r24, Y+3	; 0x03
    2aea:	9c 81       	ldd	r25, Y+4	; 0x04
    2aec:	ba 01       	movw	r22, r20
    2aee:	a9 01       	movw	r20, r18
    2af0:	0e 94 4b 33 	call	0x6696	; 0x6696 <memcpy>
    }
}
    2af4:	0f 90       	pop	r0
    2af6:	0f 90       	pop	r0
    2af8:	0f 90       	pop	r0
    2afa:	0f 90       	pop	r0
    2afc:	cf 91       	pop	r28
    2afe:	df 91       	pop	r29
    2b00:	08 95       	ret

00002b02 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2b02:	df 93       	push	r29
    2b04:	cf 93       	push	r28
    2b06:	00 d0       	rcall	.+0      	; 0x2b08 <prvUnlockQueue+0x6>
    2b08:	00 d0       	rcall	.+0      	; 0x2b0a <prvUnlockQueue+0x8>
    2b0a:	cd b7       	in	r28, 0x3d	; 61
    2b0c:	de b7       	in	r29, 0x3e	; 62
    2b0e:	9c 83       	std	Y+4, r25	; 0x04
    2b10:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    2b12:	0f b6       	in	r0, 0x3f	; 63
    2b14:	f8 94       	cli
    2b16:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    2b18:	eb 81       	ldd	r30, Y+3	; 0x03
    2b1a:	fc 81       	ldd	r31, Y+4	; 0x04
    2b1c:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b1e:	8a 83       	std	Y+2, r24	; 0x02
    2b20:	11 c0       	rjmp	.+34     	; 0x2b44 <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2b22:	eb 81       	ldd	r30, Y+3	; 0x03
    2b24:	fc 81       	ldd	r31, Y+4	; 0x04
    2b26:	81 89       	ldd	r24, Z+17	; 0x11
    2b28:	88 23       	and	r24, r24
    2b2a:	79 f0       	breq	.+30     	; 0x2b4a <prvUnlockQueue+0x48>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2b2c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b2e:	9c 81       	ldd	r25, Y+4	; 0x04
    2b30:	41 96       	adiw	r24, 0x11	; 17
    2b32:	0e 94 51 20 	call	0x40a2	; 0x40a2 <xTaskRemoveFromEventList>
    2b36:	88 23       	and	r24, r24
    2b38:	11 f0       	breq	.+4      	; 0x2b3e <prvUnlockQueue+0x3c>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    2b3a:	0e 94 41 23 	call	0x4682	; 0x4682 <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    2b3e:	8a 81       	ldd	r24, Y+2	; 0x02
    2b40:	81 50       	subi	r24, 0x01	; 1
    2b42:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    2b44:	8a 81       	ldd	r24, Y+2	; 0x02
    2b46:	18 16       	cp	r1, r24
    2b48:	64 f3       	brlt	.-40     	; 0x2b22 <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    2b4a:	eb 81       	ldd	r30, Y+3	; 0x03
    2b4c:	fc 81       	ldd	r31, Y+4	; 0x04
    2b4e:	8f ef       	ldi	r24, 0xFF	; 255
    2b50:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    2b52:	0f 90       	pop	r0
    2b54:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    2b56:	0f b6       	in	r0, 0x3f	; 63
    2b58:	f8 94       	cli
    2b5a:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    2b5c:	eb 81       	ldd	r30, Y+3	; 0x03
    2b5e:	fc 81       	ldd	r31, Y+4	; 0x04
    2b60:	85 8d       	ldd	r24, Z+29	; 0x1d
    2b62:	89 83       	std	Y+1, r24	; 0x01
    2b64:	11 c0       	rjmp	.+34     	; 0x2b88 <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2b66:	eb 81       	ldd	r30, Y+3	; 0x03
    2b68:	fc 81       	ldd	r31, Y+4	; 0x04
    2b6a:	80 85       	ldd	r24, Z+8	; 0x08
    2b6c:	88 23       	and	r24, r24
    2b6e:	79 f0       	breq	.+30     	; 0x2b8e <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2b70:	8b 81       	ldd	r24, Y+3	; 0x03
    2b72:	9c 81       	ldd	r25, Y+4	; 0x04
    2b74:	08 96       	adiw	r24, 0x08	; 8
    2b76:	0e 94 51 20 	call	0x40a2	; 0x40a2 <xTaskRemoveFromEventList>
    2b7a:	88 23       	and	r24, r24
    2b7c:	11 f0       	breq	.+4      	; 0x2b82 <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    2b7e:	0e 94 41 23 	call	0x4682	; 0x4682 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    2b82:	89 81       	ldd	r24, Y+1	; 0x01
    2b84:	81 50       	subi	r24, 0x01	; 1
    2b86:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    2b88:	89 81       	ldd	r24, Y+1	; 0x01
    2b8a:	18 16       	cp	r1, r24
    2b8c:	64 f3       	brlt	.-40     	; 0x2b66 <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    2b8e:	eb 81       	ldd	r30, Y+3	; 0x03
    2b90:	fc 81       	ldd	r31, Y+4	; 0x04
    2b92:	8f ef       	ldi	r24, 0xFF	; 255
    2b94:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    2b96:	0f 90       	pop	r0
    2b98:	0f be       	out	0x3f, r0	; 63
}
    2b9a:	0f 90       	pop	r0
    2b9c:	0f 90       	pop	r0
    2b9e:	0f 90       	pop	r0
    2ba0:	0f 90       	pop	r0
    2ba2:	cf 91       	pop	r28
    2ba4:	df 91       	pop	r29
    2ba6:	08 95       	ret

00002ba8 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    2ba8:	df 93       	push	r29
    2baa:	cf 93       	push	r28
    2bac:	00 d0       	rcall	.+0      	; 0x2bae <prvIsQueueEmpty+0x6>
    2bae:	0f 92       	push	r0
    2bb0:	cd b7       	in	r28, 0x3d	; 61
    2bb2:	de b7       	in	r29, 0x3e	; 62
    2bb4:	9b 83       	std	Y+3, r25	; 0x03
    2bb6:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2bb8:	0f b6       	in	r0, 0x3f	; 63
    2bba:	f8 94       	cli
    2bbc:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2bbe:	ea 81       	ldd	r30, Y+2	; 0x02
    2bc0:	fb 81       	ldd	r31, Y+3	; 0x03
    2bc2:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bc4:	88 23       	and	r24, r24
    2bc6:	19 f4       	brne	.+6      	; 0x2bce <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    2bc8:	81 e0       	ldi	r24, 0x01	; 1
    2bca:	89 83       	std	Y+1, r24	; 0x01
    2bcc:	01 c0       	rjmp	.+2      	; 0x2bd0 <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    2bce:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    2bd0:	0f 90       	pop	r0
    2bd2:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    2bd4:	89 81       	ldd	r24, Y+1	; 0x01
}
    2bd6:	0f 90       	pop	r0
    2bd8:	0f 90       	pop	r0
    2bda:	0f 90       	pop	r0
    2bdc:	cf 91       	pop	r28
    2bde:	df 91       	pop	r29
    2be0:	08 95       	ret

00002be2 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2be2:	df 93       	push	r29
    2be4:	cf 93       	push	r28
    2be6:	00 d0       	rcall	.+0      	; 0x2be8 <xQueueIsQueueEmptyFromISR+0x6>
    2be8:	00 d0       	rcall	.+0      	; 0x2bea <xQueueIsQueueEmptyFromISR+0x8>
    2bea:	0f 92       	push	r0
    2bec:	cd b7       	in	r28, 0x3d	; 61
    2bee:	de b7       	in	r29, 0x3e	; 62
    2bf0:	9d 83       	std	Y+5, r25	; 0x05
    2bf2:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    2bf4:	8c 81       	ldd	r24, Y+4	; 0x04
    2bf6:	9d 81       	ldd	r25, Y+5	; 0x05
    2bf8:	9a 83       	std	Y+2, r25	; 0x02
    2bfa:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2bfc:	e9 81       	ldd	r30, Y+1	; 0x01
    2bfe:	fa 81       	ldd	r31, Y+2	; 0x02
    2c00:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c02:	88 23       	and	r24, r24
    2c04:	19 f4       	brne	.+6      	; 0x2c0c <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    2c06:	81 e0       	ldi	r24, 0x01	; 1
    2c08:	8b 83       	std	Y+3, r24	; 0x03
    2c0a:	01 c0       	rjmp	.+2      	; 0x2c0e <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    2c0c:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    2c0e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2c10:	0f 90       	pop	r0
    2c12:	0f 90       	pop	r0
    2c14:	0f 90       	pop	r0
    2c16:	0f 90       	pop	r0
    2c18:	0f 90       	pop	r0
    2c1a:	cf 91       	pop	r28
    2c1c:	df 91       	pop	r29
    2c1e:	08 95       	ret

00002c20 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    2c20:	df 93       	push	r29
    2c22:	cf 93       	push	r28
    2c24:	00 d0       	rcall	.+0      	; 0x2c26 <prvIsQueueFull+0x6>
    2c26:	0f 92       	push	r0
    2c28:	cd b7       	in	r28, 0x3d	; 61
    2c2a:	de b7       	in	r29, 0x3e	; 62
    2c2c:	9b 83       	std	Y+3, r25	; 0x03
    2c2e:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2c30:	0f b6       	in	r0, 0x3f	; 63
    2c32:	f8 94       	cli
    2c34:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2c36:	ea 81       	ldd	r30, Y+2	; 0x02
    2c38:	fb 81       	ldd	r31, Y+3	; 0x03
    2c3a:	92 8d       	ldd	r25, Z+26	; 0x1a
    2c3c:	ea 81       	ldd	r30, Y+2	; 0x02
    2c3e:	fb 81       	ldd	r31, Y+3	; 0x03
    2c40:	83 8d       	ldd	r24, Z+27	; 0x1b
    2c42:	98 17       	cp	r25, r24
    2c44:	19 f4       	brne	.+6      	; 0x2c4c <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    2c46:	81 e0       	ldi	r24, 0x01	; 1
    2c48:	89 83       	std	Y+1, r24	; 0x01
    2c4a:	01 c0       	rjmp	.+2      	; 0x2c4e <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    2c4c:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    2c4e:	0f 90       	pop	r0
    2c50:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    2c52:	89 81       	ldd	r24, Y+1	; 0x01
}
    2c54:	0f 90       	pop	r0
    2c56:	0f 90       	pop	r0
    2c58:	0f 90       	pop	r0
    2c5a:	cf 91       	pop	r28
    2c5c:	df 91       	pop	r29
    2c5e:	08 95       	ret

00002c60 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2c60:	df 93       	push	r29
    2c62:	cf 93       	push	r28
    2c64:	00 d0       	rcall	.+0      	; 0x2c66 <xQueueIsQueueFullFromISR+0x6>
    2c66:	00 d0       	rcall	.+0      	; 0x2c68 <xQueueIsQueueFullFromISR+0x8>
    2c68:	0f 92       	push	r0
    2c6a:	cd b7       	in	r28, 0x3d	; 61
    2c6c:	de b7       	in	r29, 0x3e	; 62
    2c6e:	9d 83       	std	Y+5, r25	; 0x05
    2c70:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    2c72:	8c 81       	ldd	r24, Y+4	; 0x04
    2c74:	9d 81       	ldd	r25, Y+5	; 0x05
    2c76:	9a 83       	std	Y+2, r25	; 0x02
    2c78:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2c7a:	e9 81       	ldd	r30, Y+1	; 0x01
    2c7c:	fa 81       	ldd	r31, Y+2	; 0x02
    2c7e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2c80:	e9 81       	ldd	r30, Y+1	; 0x01
    2c82:	fa 81       	ldd	r31, Y+2	; 0x02
    2c84:	83 8d       	ldd	r24, Z+27	; 0x1b
    2c86:	98 17       	cp	r25, r24
    2c88:	19 f4       	brne	.+6      	; 0x2c90 <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    2c8a:	81 e0       	ldi	r24, 0x01	; 1
    2c8c:	8b 83       	std	Y+3, r24	; 0x03
    2c8e:	01 c0       	rjmp	.+2      	; 0x2c92 <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    2c90:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    2c92:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2c94:	0f 90       	pop	r0
    2c96:	0f 90       	pop	r0
    2c98:	0f 90       	pop	r0
    2c9a:	0f 90       	pop	r0
    2c9c:	0f 90       	pop	r0
    2c9e:	cf 91       	pop	r28
    2ca0:	df 91       	pop	r29
    2ca2:	08 95       	ret

00002ca4 <xQueueCRSend>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSend( QueueHandle_t xQueue,
                             const void * pvItemToQueue,
                             TickType_t xTicksToWait )
    {
    2ca4:	df 93       	push	r29
    2ca6:	cf 93       	push	r28
    2ca8:	cd b7       	in	r28, 0x3d	; 61
    2caa:	de b7       	in	r29, 0x3e	; 62
    2cac:	2a 97       	sbiw	r28, 0x0a	; 10
    2cae:	0f b6       	in	r0, 0x3f	; 63
    2cb0:	f8 94       	cli
    2cb2:	de bf       	out	0x3e, r29	; 62
    2cb4:	0f be       	out	0x3f, r0	; 63
    2cb6:	cd bf       	out	0x3d, r28	; 61
    2cb8:	9d 83       	std	Y+5, r25	; 0x05
    2cba:	8c 83       	std	Y+4, r24	; 0x04
    2cbc:	7f 83       	std	Y+7, r23	; 0x07
    2cbe:	6e 83       	std	Y+6, r22	; 0x06
    2cc0:	59 87       	std	Y+9, r21	; 0x09
    2cc2:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    2cc4:	8c 81       	ldd	r24, Y+4	; 0x04
    2cc6:	9d 81       	ldd	r25, Y+5	; 0x05
    2cc8:	9a 83       	std	Y+2, r25	; 0x02
    2cca:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    2ccc:	f8 94       	cli
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2cce:	89 81       	ldd	r24, Y+1	; 0x01
    2cd0:	9a 81       	ldd	r25, Y+2	; 0x02
    2cd2:	0e 94 10 16 	call	0x2c20	; 0x2c20 <prvIsQueueFull>
    2cd6:	88 23       	and	r24, r24
    2cd8:	a9 f0       	breq	.+42     	; 0x2d04 <xQueueCRSend+0x60>
            {
                /* The queue is full - do we want to block or just leave without
                 * posting? */
                if( xTicksToWait > ( TickType_t ) 0 )
    2cda:	88 85       	ldd	r24, Y+8	; 0x08
    2cdc:	99 85       	ldd	r25, Y+9	; 0x09
    2cde:	00 97       	sbiw	r24, 0x00	; 0
    2ce0:	71 f0       	breq	.+28     	; 0x2cfe <xQueueCRSend+0x5a>
                {
                    /* As this is called from a coroutine we cannot block directly, but
                     * return indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    2ce2:	89 81       	ldd	r24, Y+1	; 0x01
    2ce4:	9a 81       	ldd	r25, Y+2	; 0x02
    2ce6:	9c 01       	movw	r18, r24
    2ce8:	28 5f       	subi	r18, 0xF8	; 248
    2cea:	3f 4f       	sbci	r19, 0xFF	; 255
    2cec:	88 85       	ldd	r24, Y+8	; 0x08
    2cee:	99 85       	ldd	r25, Y+9	; 0x09
    2cf0:	b9 01       	movw	r22, r18
    2cf2:	0e 94 1e 08 	call	0x103c	; 0x103c <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    2cf6:	78 94       	sei
                    return errQUEUE_BLOCKED;
    2cf8:	8c ef       	ldi	r24, 0xFC	; 252
    2cfa:	8a 87       	std	Y+10, r24	; 0x0a
    2cfc:	2a c0       	rjmp	.+84     	; 0x2d52 <xQueueCRSend+0xae>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    2cfe:	78 94       	sei
                    return errQUEUE_FULL;
    2d00:	1a 86       	std	Y+10, r1	; 0x0a
    2d02:	27 c0       	rjmp	.+78     	; 0x2d52 <xQueueCRSend+0xae>
                }
            }
        }
        portENABLE_INTERRUPTS();
    2d04:	78 94       	sei

        portDISABLE_INTERRUPTS();
    2d06:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2d08:	e9 81       	ldd	r30, Y+1	; 0x01
    2d0a:	fa 81       	ldd	r31, Y+2	; 0x02
    2d0c:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d0e:	e9 81       	ldd	r30, Y+1	; 0x01
    2d10:	fa 81       	ldd	r31, Y+2	; 0x02
    2d12:	83 8d       	ldd	r24, Z+27	; 0x1b
    2d14:	98 17       	cp	r25, r24
    2d16:	c8 f4       	brcc	.+50     	; 0x2d4a <xQueueCRSend+0xa6>
            {
                /* There is room in the queue, copy the data into the queue. */
                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    2d18:	89 81       	ldd	r24, Y+1	; 0x01
    2d1a:	9a 81       	ldd	r25, Y+2	; 0x02
    2d1c:	2e 81       	ldd	r18, Y+6	; 0x06
    2d1e:	3f 81       	ldd	r19, Y+7	; 0x07
    2d20:	b9 01       	movw	r22, r18
    2d22:	40 e0       	ldi	r20, 0x00	; 0
    2d24:	0e 94 94 14 	call	0x2928	; 0x2928 <prvCopyDataToQueue>
                xReturn = pdPASS;
    2d28:	81 e0       	ldi	r24, 0x01	; 1
    2d2a:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for data to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2d2c:	e9 81       	ldd	r30, Y+1	; 0x01
    2d2e:	fa 81       	ldd	r31, Y+2	; 0x02
    2d30:	81 89       	ldd	r24, Z+17	; 0x11
    2d32:	88 23       	and	r24, r24
    2d34:	59 f0       	breq	.+22     	; 0x2d4c <xQueueCRSend+0xa8>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2d36:	89 81       	ldd	r24, Y+1	; 0x01
    2d38:	9a 81       	ldd	r25, Y+2	; 0x02
    2d3a:	41 96       	adiw	r24, 0x11	; 17
    2d3c:	0e 94 31 0a 	call	0x1462	; 0x1462 <xCoRoutineRemoveFromEventList>
    2d40:	88 23       	and	r24, r24
    2d42:	21 f0       	breq	.+8      	; 0x2d4c <xQueueCRSend+0xa8>
                    {
                        /* The co-routine waiting has a higher priority so record
                         * that a yield might be appropriate. */
                        xReturn = errQUEUE_YIELD;
    2d44:	8b ef       	ldi	r24, 0xFB	; 251
    2d46:	8b 83       	std	Y+3, r24	; 0x03
    2d48:	01 c0       	rjmp	.+2      	; 0x2d4c <xQueueCRSend+0xa8>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = errQUEUE_FULL;
    2d4a:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    2d4c:	78 94       	sei

        return xReturn;
    2d4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d50:	8a 87       	std	Y+10, r24	; 0x0a
    2d52:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    2d54:	2a 96       	adiw	r28, 0x0a	; 10
    2d56:	0f b6       	in	r0, 0x3f	; 63
    2d58:	f8 94       	cli
    2d5a:	de bf       	out	0x3e, r29	; 62
    2d5c:	0f be       	out	0x3f, r0	; 63
    2d5e:	cd bf       	out	0x3d, r28	; 61
    2d60:	cf 91       	pop	r28
    2d62:	df 91       	pop	r29
    2d64:	08 95       	ret

00002d66 <xQueueCRReceive>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
                                void * pvBuffer,
                                TickType_t xTicksToWait )
    {
    2d66:	df 93       	push	r29
    2d68:	cf 93       	push	r28
    2d6a:	cd b7       	in	r28, 0x3d	; 61
    2d6c:	de b7       	in	r29, 0x3e	; 62
    2d6e:	2a 97       	sbiw	r28, 0x0a	; 10
    2d70:	0f b6       	in	r0, 0x3f	; 63
    2d72:	f8 94       	cli
    2d74:	de bf       	out	0x3e, r29	; 62
    2d76:	0f be       	out	0x3f, r0	; 63
    2d78:	cd bf       	out	0x3d, r28	; 61
    2d7a:	9d 83       	std	Y+5, r25	; 0x05
    2d7c:	8c 83       	std	Y+4, r24	; 0x04
    2d7e:	7f 83       	std	Y+7, r23	; 0x07
    2d80:	6e 83       	std	Y+6, r22	; 0x06
    2d82:	59 87       	std	Y+9, r21	; 0x09
    2d84:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    2d86:	8c 81       	ldd	r24, Y+4	; 0x04
    2d88:	9d 81       	ldd	r25, Y+5	; 0x05
    2d8a:	9a 83       	std	Y+2, r25	; 0x02
    2d8c:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already empty we may have to block.  A critical section
         * is required to prevent an interrupt adding something to the queue
         * between the check to see if the queue is empty and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    2d8e:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2d90:	e9 81       	ldd	r30, Y+1	; 0x01
    2d92:	fa 81       	ldd	r31, Y+2	; 0x02
    2d94:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d96:	88 23       	and	r24, r24
    2d98:	a9 f4       	brne	.+42     	; 0x2dc4 <xQueueCRReceive+0x5e>
            {
                /* There are no messages in the queue, do we want to block or just
                 * leave with nothing? */
                if( xTicksToWait > ( TickType_t ) 0 )
    2d9a:	88 85       	ldd	r24, Y+8	; 0x08
    2d9c:	99 85       	ldd	r25, Y+9	; 0x09
    2d9e:	00 97       	sbiw	r24, 0x00	; 0
    2da0:	71 f0       	breq	.+28     	; 0x2dbe <xQueueCRReceive+0x58>
                {
                    /* As this is a co-routine we cannot block directly, but return
                     * indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    2da2:	89 81       	ldd	r24, Y+1	; 0x01
    2da4:	9a 81       	ldd	r25, Y+2	; 0x02
    2da6:	9c 01       	movw	r18, r24
    2da8:	2f 5e       	subi	r18, 0xEF	; 239
    2daa:	3f 4f       	sbci	r19, 0xFF	; 255
    2dac:	88 85       	ldd	r24, Y+8	; 0x08
    2dae:	99 85       	ldd	r25, Y+9	; 0x09
    2db0:	b9 01       	movw	r22, r18
    2db2:	0e 94 1e 08 	call	0x103c	; 0x103c <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    2db6:	78 94       	sei
                    return errQUEUE_BLOCKED;
    2db8:	8c ef       	ldi	r24, 0xFC	; 252
    2dba:	8a 87       	std	Y+10, r24	; 0x0a
    2dbc:	58 c0       	rjmp	.+176    	; 0x2e6e <xQueueCRReceive+0x108>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    2dbe:	78 94       	sei
                    return errQUEUE_FULL;
    2dc0:	1a 86       	std	Y+10, r1	; 0x0a
    2dc2:	55 c0       	rjmp	.+170    	; 0x2e6e <xQueueCRReceive+0x108>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portENABLE_INTERRUPTS();
    2dc4:	78 94       	sei

        portDISABLE_INTERRUPTS();
    2dc6:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2dc8:	e9 81       	ldd	r30, Y+1	; 0x01
    2dca:	fa 81       	ldd	r31, Y+2	; 0x02
    2dcc:	82 8d       	ldd	r24, Z+26	; 0x1a
    2dce:	88 23       	and	r24, r24
    2dd0:	09 f4       	brne	.+2      	; 0x2dd4 <xQueueCRReceive+0x6e>
    2dd2:	49 c0       	rjmp	.+146    	; 0x2e66 <xQueueCRReceive+0x100>
            {
                /* Data is available from the queue. */
                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    2dd4:	e9 81       	ldd	r30, Y+1	; 0x01
    2dd6:	fa 81       	ldd	r31, Y+2	; 0x02
    2dd8:	26 81       	ldd	r18, Z+6	; 0x06
    2dda:	37 81       	ldd	r19, Z+7	; 0x07
    2ddc:	e9 81       	ldd	r30, Y+1	; 0x01
    2dde:	fa 81       	ldd	r31, Y+2	; 0x02
    2de0:	84 8d       	ldd	r24, Z+28	; 0x1c
    2de2:	88 2f       	mov	r24, r24
    2de4:	90 e0       	ldi	r25, 0x00	; 0
    2de6:	82 0f       	add	r24, r18
    2de8:	93 1f       	adc	r25, r19
    2dea:	e9 81       	ldd	r30, Y+1	; 0x01
    2dec:	fa 81       	ldd	r31, Y+2	; 0x02
    2dee:	97 83       	std	Z+7, r25	; 0x07
    2df0:	86 83       	std	Z+6, r24	; 0x06

                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    2df2:	e9 81       	ldd	r30, Y+1	; 0x01
    2df4:	fa 81       	ldd	r31, Y+2	; 0x02
    2df6:	26 81       	ldd	r18, Z+6	; 0x06
    2df8:	37 81       	ldd	r19, Z+7	; 0x07
    2dfa:	e9 81       	ldd	r30, Y+1	; 0x01
    2dfc:	fa 81       	ldd	r31, Y+2	; 0x02
    2dfe:	84 81       	ldd	r24, Z+4	; 0x04
    2e00:	95 81       	ldd	r25, Z+5	; 0x05
    2e02:	28 17       	cp	r18, r24
    2e04:	39 07       	cpc	r19, r25
    2e06:	40 f0       	brcs	.+16     	; 0x2e18 <xQueueCRReceive+0xb2>
                {
                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2e08:	e9 81       	ldd	r30, Y+1	; 0x01
    2e0a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e0c:	80 81       	ld	r24, Z
    2e0e:	91 81       	ldd	r25, Z+1	; 0x01
    2e10:	e9 81       	ldd	r30, Y+1	; 0x01
    2e12:	fa 81       	ldd	r31, Y+2	; 0x02
    2e14:	97 83       	std	Z+7, r25	; 0x07
    2e16:	86 83       	std	Z+6, r24	; 0x06
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --( pxQueue->uxMessagesWaiting );
    2e18:	e9 81       	ldd	r30, Y+1	; 0x01
    2e1a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e1c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e1e:	81 50       	subi	r24, 0x01	; 1
    2e20:	e9 81       	ldd	r30, Y+1	; 0x01
    2e22:	fa 81       	ldd	r31, Y+2	; 0x02
    2e24:	82 8f       	std	Z+26, r24	; 0x1a
                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2e26:	e9 81       	ldd	r30, Y+1	; 0x01
    2e28:	fa 81       	ldd	r31, Y+2	; 0x02
    2e2a:	46 81       	ldd	r20, Z+6	; 0x06
    2e2c:	57 81       	ldd	r21, Z+7	; 0x07
    2e2e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e30:	fa 81       	ldd	r31, Y+2	; 0x02
    2e32:	84 8d       	ldd	r24, Z+28	; 0x1c
    2e34:	28 2f       	mov	r18, r24
    2e36:	30 e0       	ldi	r19, 0x00	; 0
    2e38:	8e 81       	ldd	r24, Y+6	; 0x06
    2e3a:	9f 81       	ldd	r25, Y+7	; 0x07
    2e3c:	ba 01       	movw	r22, r20
    2e3e:	a9 01       	movw	r20, r18
    2e40:	0e 94 4b 33 	call	0x6696	; 0x6696 <memcpy>

                xReturn = pdPASS;
    2e44:	81 e0       	ldi	r24, 0x01	; 1
    2e46:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for space to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2e48:	e9 81       	ldd	r30, Y+1	; 0x01
    2e4a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e4c:	80 85       	ldd	r24, Z+8	; 0x08
    2e4e:	88 23       	and	r24, r24
    2e50:	59 f0       	breq	.+22     	; 0x2e68 <xQueueCRReceive+0x102>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2e52:	89 81       	ldd	r24, Y+1	; 0x01
    2e54:	9a 81       	ldd	r25, Y+2	; 0x02
    2e56:	08 96       	adiw	r24, 0x08	; 8
    2e58:	0e 94 31 0a 	call	0x1462	; 0x1462 <xCoRoutineRemoveFromEventList>
    2e5c:	88 23       	and	r24, r24
    2e5e:	21 f0       	breq	.+8      	; 0x2e68 <xQueueCRReceive+0x102>
                    {
                        xReturn = errQUEUE_YIELD;
    2e60:	8b ef       	ldi	r24, 0xFB	; 251
    2e62:	8b 83       	std	Y+3, r24	; 0x03
    2e64:	01 c0       	rjmp	.+2      	; 0x2e68 <xQueueCRReceive+0x102>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = pdFAIL;
    2e66:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    2e68:	78 94       	sei

        return xReturn;
    2e6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e6c:	8a 87       	std	Y+10, r24	; 0x0a
    2e6e:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    2e70:	2a 96       	adiw	r28, 0x0a	; 10
    2e72:	0f b6       	in	r0, 0x3f	; 63
    2e74:	f8 94       	cli
    2e76:	de bf       	out	0x3e, r29	; 62
    2e78:	0f be       	out	0x3f, r0	; 63
    2e7a:	cd bf       	out	0x3d, r28	; 61
    2e7c:	cf 91       	pop	r28
    2e7e:	df 91       	pop	r29
    2e80:	08 95       	ret

00002e82 <xQueueCRSendFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
                                    const void * pvItemToQueue,
                                    BaseType_t xCoRoutinePreviouslyWoken )
    {
    2e82:	df 93       	push	r29
    2e84:	cf 93       	push	r28
    2e86:	cd b7       	in	r28, 0x3d	; 61
    2e88:	de b7       	in	r29, 0x3e	; 62
    2e8a:	28 97       	sbiw	r28, 0x08	; 8
    2e8c:	0f b6       	in	r0, 0x3f	; 63
    2e8e:	f8 94       	cli
    2e90:	de bf       	out	0x3e, r29	; 62
    2e92:	0f be       	out	0x3f, r0	; 63
    2e94:	cd bf       	out	0x3d, r28	; 61
    2e96:	9c 83       	std	Y+4, r25	; 0x04
    2e98:	8b 83       	std	Y+3, r24	; 0x03
    2e9a:	7e 83       	std	Y+6, r23	; 0x06
    2e9c:	6d 83       	std	Y+5, r22	; 0x05
    2e9e:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    2ea0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ea2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ea4:	9a 83       	std	Y+2, r25	; 0x02
    2ea6:	89 83       	std	Y+1, r24	; 0x01

        /* Cannot block within an ISR so if there is no space on the queue then
         * exit without doing anything. */
        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2ea8:	e9 81       	ldd	r30, Y+1	; 0x01
    2eaa:	fa 81       	ldd	r31, Y+2	; 0x02
    2eac:	92 8d       	ldd	r25, Z+26	; 0x1a
    2eae:	e9 81       	ldd	r30, Y+1	; 0x01
    2eb0:	fa 81       	ldd	r31, Y+2	; 0x02
    2eb2:	83 8d       	ldd	r24, Z+27	; 0x1b
    2eb4:	98 17       	cp	r25, r24
    2eb6:	d0 f4       	brcc	.+52     	; 0x2eec <xQueueCRSendFromISR+0x6a>
        {
            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    2eb8:	89 81       	ldd	r24, Y+1	; 0x01
    2eba:	9a 81       	ldd	r25, Y+2	; 0x02
    2ebc:	2d 81       	ldd	r18, Y+5	; 0x05
    2ebe:	3e 81       	ldd	r19, Y+6	; 0x06
    2ec0:	b9 01       	movw	r22, r18
    2ec2:	40 e0       	ldi	r20, 0x00	; 0
    2ec4:	0e 94 94 14 	call	0x2928	; 0x2928 <prvCopyDataToQueue>

            /* We only want to wake one co-routine per ISR, so check that a
             * co-routine has not already been woken. */
            if( xCoRoutinePreviouslyWoken == pdFALSE )
    2ec8:	8f 81       	ldd	r24, Y+7	; 0x07
    2eca:	88 23       	and	r24, r24
    2ecc:	79 f4       	brne	.+30     	; 0x2eec <xQueueCRSendFromISR+0x6a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2ece:	e9 81       	ldd	r30, Y+1	; 0x01
    2ed0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ed2:	81 89       	ldd	r24, Z+17	; 0x11
    2ed4:	88 23       	and	r24, r24
    2ed6:	51 f0       	breq	.+20     	; 0x2eec <xQueueCRSendFromISR+0x6a>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2ed8:	89 81       	ldd	r24, Y+1	; 0x01
    2eda:	9a 81       	ldd	r25, Y+2	; 0x02
    2edc:	41 96       	adiw	r24, 0x11	; 17
    2ede:	0e 94 31 0a 	call	0x1462	; 0x1462 <xCoRoutineRemoveFromEventList>
    2ee2:	88 23       	and	r24, r24
    2ee4:	19 f0       	breq	.+6      	; 0x2eec <xQueueCRSendFromISR+0x6a>
                    {
                        return pdTRUE;
    2ee6:	81 e0       	ldi	r24, 0x01	; 1
    2ee8:	88 87       	std	Y+8, r24	; 0x08
    2eea:	02 c0       	rjmp	.+4      	; 0x2ef0 <xQueueCRSendFromISR+0x6e>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xCoRoutinePreviouslyWoken;
    2eec:	8f 81       	ldd	r24, Y+7	; 0x07
    2eee:	88 87       	std	Y+8, r24	; 0x08
    2ef0:	88 85       	ldd	r24, Y+8	; 0x08
    }
    2ef2:	28 96       	adiw	r28, 0x08	; 8
    2ef4:	0f b6       	in	r0, 0x3f	; 63
    2ef6:	f8 94       	cli
    2ef8:	de bf       	out	0x3e, r29	; 62
    2efa:	0f be       	out	0x3f, r0	; 63
    2efc:	cd bf       	out	0x3d, r28	; 61
    2efe:	cf 91       	pop	r28
    2f00:	df 91       	pop	r29
    2f02:	08 95       	ret

00002f04 <xQueueCRReceiveFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
                                       void * pvBuffer,
                                       BaseType_t * pxCoRoutineWoken )
    {
    2f04:	df 93       	push	r29
    2f06:	cf 93       	push	r28
    2f08:	cd b7       	in	r28, 0x3d	; 61
    2f0a:	de b7       	in	r29, 0x3e	; 62
    2f0c:	29 97       	sbiw	r28, 0x09	; 9
    2f0e:	0f b6       	in	r0, 0x3f	; 63
    2f10:	f8 94       	cli
    2f12:	de bf       	out	0x3e, r29	; 62
    2f14:	0f be       	out	0x3f, r0	; 63
    2f16:	cd bf       	out	0x3d, r28	; 61
    2f18:	9d 83       	std	Y+5, r25	; 0x05
    2f1a:	8c 83       	std	Y+4, r24	; 0x04
    2f1c:	7f 83       	std	Y+7, r23	; 0x07
    2f1e:	6e 83       	std	Y+6, r22	; 0x06
    2f20:	59 87       	std	Y+9, r21	; 0x09
    2f22:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    2f24:	8c 81       	ldd	r24, Y+4	; 0x04
    2f26:	9d 81       	ldd	r25, Y+5	; 0x05
    2f28:	9a 83       	std	Y+2, r25	; 0x02
    2f2a:	89 83       	std	Y+1, r24	; 0x01

        /* We cannot block from an ISR, so check there is data available. If
         * not then just leave without doing anything. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2f2c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f2e:	fa 81       	ldd	r31, Y+2	; 0x02
    2f30:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f32:	88 23       	and	r24, r24
    2f34:	09 f4       	brne	.+2      	; 0x2f38 <xQueueCRReceiveFromISR+0x34>
    2f36:	50 c0       	rjmp	.+160    	; 0x2fd8 <xQueueCRReceiveFromISR+0xd4>
        {
            /* Copy the data from the queue. */
            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    2f38:	e9 81       	ldd	r30, Y+1	; 0x01
    2f3a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f3c:	26 81       	ldd	r18, Z+6	; 0x06
    2f3e:	37 81       	ldd	r19, Z+7	; 0x07
    2f40:	e9 81       	ldd	r30, Y+1	; 0x01
    2f42:	fa 81       	ldd	r31, Y+2	; 0x02
    2f44:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f46:	88 2f       	mov	r24, r24
    2f48:	90 e0       	ldi	r25, 0x00	; 0
    2f4a:	82 0f       	add	r24, r18
    2f4c:	93 1f       	adc	r25, r19
    2f4e:	e9 81       	ldd	r30, Y+1	; 0x01
    2f50:	fa 81       	ldd	r31, Y+2	; 0x02
    2f52:	97 83       	std	Z+7, r25	; 0x07
    2f54:	86 83       	std	Z+6, r24	; 0x06

            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    2f56:	e9 81       	ldd	r30, Y+1	; 0x01
    2f58:	fa 81       	ldd	r31, Y+2	; 0x02
    2f5a:	26 81       	ldd	r18, Z+6	; 0x06
    2f5c:	37 81       	ldd	r19, Z+7	; 0x07
    2f5e:	e9 81       	ldd	r30, Y+1	; 0x01
    2f60:	fa 81       	ldd	r31, Y+2	; 0x02
    2f62:	84 81       	ldd	r24, Z+4	; 0x04
    2f64:	95 81       	ldd	r25, Z+5	; 0x05
    2f66:	28 17       	cp	r18, r24
    2f68:	39 07       	cpc	r19, r25
    2f6a:	40 f0       	brcs	.+16     	; 0x2f7c <xQueueCRReceiveFromISR+0x78>
            {
                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2f6c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f6e:	fa 81       	ldd	r31, Y+2	; 0x02
    2f70:	80 81       	ld	r24, Z
    2f72:	91 81       	ldd	r25, Z+1	; 0x01
    2f74:	e9 81       	ldd	r30, Y+1	; 0x01
    2f76:	fa 81       	ldd	r31, Y+2	; 0x02
    2f78:	97 83       	std	Z+7, r25	; 0x07
    2f7a:	86 83       	std	Z+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            --( pxQueue->uxMessagesWaiting );
    2f7c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f7e:	fa 81       	ldd	r31, Y+2	; 0x02
    2f80:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f82:	81 50       	subi	r24, 0x01	; 1
    2f84:	e9 81       	ldd	r30, Y+1	; 0x01
    2f86:	fa 81       	ldd	r31, Y+2	; 0x02
    2f88:	82 8f       	std	Z+26, r24	; 0x1a
            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2f8a:	e9 81       	ldd	r30, Y+1	; 0x01
    2f8c:	fa 81       	ldd	r31, Y+2	; 0x02
    2f8e:	46 81       	ldd	r20, Z+6	; 0x06
    2f90:	57 81       	ldd	r21, Z+7	; 0x07
    2f92:	e9 81       	ldd	r30, Y+1	; 0x01
    2f94:	fa 81       	ldd	r31, Y+2	; 0x02
    2f96:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f98:	28 2f       	mov	r18, r24
    2f9a:	30 e0       	ldi	r19, 0x00	; 0
    2f9c:	8e 81       	ldd	r24, Y+6	; 0x06
    2f9e:	9f 81       	ldd	r25, Y+7	; 0x07
    2fa0:	ba 01       	movw	r22, r20
    2fa2:	a9 01       	movw	r20, r18
    2fa4:	0e 94 4b 33 	call	0x6696	; 0x6696 <memcpy>

            if( ( *pxCoRoutineWoken ) == pdFALSE )
    2fa8:	e8 85       	ldd	r30, Y+8	; 0x08
    2faa:	f9 85       	ldd	r31, Y+9	; 0x09
    2fac:	80 81       	ld	r24, Z
    2fae:	88 23       	and	r24, r24
    2fb0:	81 f4       	brne	.+32     	; 0x2fd2 <xQueueCRReceiveFromISR+0xce>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2fb2:	e9 81       	ldd	r30, Y+1	; 0x01
    2fb4:	fa 81       	ldd	r31, Y+2	; 0x02
    2fb6:	80 85       	ldd	r24, Z+8	; 0x08
    2fb8:	88 23       	and	r24, r24
    2fba:	59 f0       	breq	.+22     	; 0x2fd2 <xQueueCRReceiveFromISR+0xce>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2fbc:	89 81       	ldd	r24, Y+1	; 0x01
    2fbe:	9a 81       	ldd	r25, Y+2	; 0x02
    2fc0:	08 96       	adiw	r24, 0x08	; 8
    2fc2:	0e 94 31 0a 	call	0x1462	; 0x1462 <xCoRoutineRemoveFromEventList>
    2fc6:	88 23       	and	r24, r24
    2fc8:	21 f0       	breq	.+8      	; 0x2fd2 <xQueueCRReceiveFromISR+0xce>
                    {
                        *pxCoRoutineWoken = pdTRUE;
    2fca:	e8 85       	ldd	r30, Y+8	; 0x08
    2fcc:	f9 85       	ldd	r31, Y+9	; 0x09
    2fce:	81 e0       	ldi	r24, 0x01	; 1
    2fd0:	80 83       	st	Z, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
    2fd2:	81 e0       	ldi	r24, 0x01	; 1
    2fd4:	8b 83       	std	Y+3, r24	; 0x03
    2fd6:	01 c0       	rjmp	.+2      	; 0x2fda <xQueueCRReceiveFromISR+0xd6>
        }
        else
        {
            xReturn = pdFAIL;
    2fd8:	1b 82       	std	Y+3, r1	; 0x03
        }

        return xReturn;
    2fda:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    2fdc:	29 96       	adiw	r28, 0x09	; 9
    2fde:	0f b6       	in	r0, 0x3f	; 63
    2fe0:	f8 94       	cli
    2fe2:	de bf       	out	0x3e, r29	; 62
    2fe4:	0f be       	out	0x3f, r0	; 63
    2fe6:	cd bf       	out	0x3d, r28	; 61
    2fe8:	cf 91       	pop	r28
    2fea:	df 91       	pop	r29
    2fec:	08 95       	ret

00002fee <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
    2fee:	df 93       	push	r29
    2ff0:	cf 93       	push	r28
    2ff2:	cd b7       	in	r28, 0x3d	; 61
    2ff4:	de b7       	in	r29, 0x3e	; 62
    2ff6:	27 97       	sbiw	r28, 0x07	; 7
    2ff8:	0f b6       	in	r0, 0x3f	; 63
    2ffa:	f8 94       	cli
    2ffc:	de bf       	out	0x3e, r29	; 62
    2ffe:	0f be       	out	0x3f, r0	; 63
    3000:	cd bf       	out	0x3d, r28	; 61
    3002:	9c 83       	std	Y+4, r25	; 0x04
    3004:	8b 83       	std	Y+3, r24	; 0x03
    3006:	7e 83       	std	Y+6, r23	; 0x06
    3008:	6d 83       	std	Y+5, r22	; 0x05
    300a:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    300c:	8b 81       	ldd	r24, Y+3	; 0x03
    300e:	9c 81       	ldd	r25, Y+4	; 0x04
    3010:	9a 83       	std	Y+2, r25	; 0x02
    3012:	89 83       	std	Y+1, r24	; 0x01
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    3014:	0f b6       	in	r0, 0x3f	; 63
    3016:	f8 94       	cli
    3018:	0f 92       	push	r0
    301a:	e9 81       	ldd	r30, Y+1	; 0x01
    301c:	fa 81       	ldd	r31, Y+2	; 0x02
    301e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3020:	8f 3f       	cpi	r24, 0xFF	; 255
    3022:	19 f4       	brne	.+6      	; 0x302a <vQueueWaitForMessageRestricted+0x3c>
    3024:	e9 81       	ldd	r30, Y+1	; 0x01
    3026:	fa 81       	ldd	r31, Y+2	; 0x02
    3028:	15 8e       	std	Z+29, r1	; 0x1d
    302a:	e9 81       	ldd	r30, Y+1	; 0x01
    302c:	fa 81       	ldd	r31, Y+2	; 0x02
    302e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3030:	8f 3f       	cpi	r24, 0xFF	; 255
    3032:	19 f4       	brne	.+6      	; 0x303a <vQueueWaitForMessageRestricted+0x4c>
    3034:	e9 81       	ldd	r30, Y+1	; 0x01
    3036:	fa 81       	ldd	r31, Y+2	; 0x02
    3038:	16 8e       	std	Z+30, r1	; 0x1e
    303a:	0f 90       	pop	r0
    303c:	0f be       	out	0x3f, r0	; 63

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    303e:	e9 81       	ldd	r30, Y+1	; 0x01
    3040:	fa 81       	ldd	r31, Y+2	; 0x02
    3042:	82 8d       	ldd	r24, Z+26	; 0x1a
    3044:	88 23       	and	r24, r24
    3046:	49 f4       	brne	.+18     	; 0x305a <vQueueWaitForMessageRestricted+0x6c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    3048:	89 81       	ldd	r24, Y+1	; 0x01
    304a:	9a 81       	ldd	r25, Y+2	; 0x02
    304c:	41 96       	adiw	r24, 0x11	; 17
    304e:	2d 81       	ldd	r18, Y+5	; 0x05
    3050:	3e 81       	ldd	r19, Y+6	; 0x06
    3052:	b9 01       	movw	r22, r18
    3054:	4f 81       	ldd	r20, Y+7	; 0x07
    3056:	0e 94 ef 1f 	call	0x3fde	; 0x3fde <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
    305a:	89 81       	ldd	r24, Y+1	; 0x01
    305c:	9a 81       	ldd	r25, Y+2	; 0x02
    305e:	0e 94 81 15 	call	0x2b02	; 0x2b02 <prvUnlockQueue>
    }
    3062:	27 96       	adiw	r28, 0x07	; 7
    3064:	0f b6       	in	r0, 0x3f	; 63
    3066:	f8 94       	cli
    3068:	de bf       	out	0x3e, r29	; 62
    306a:	0f be       	out	0x3f, r0	; 63
    306c:	cd bf       	out	0x3d, r28	; 61
    306e:	cf 91       	pop	r28
    3070:	df 91       	pop	r29
    3072:	08 95       	ret

00003074 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    3074:	8f 92       	push	r8
    3076:	9f 92       	push	r9
    3078:	af 92       	push	r10
    307a:	bf 92       	push	r11
    307c:	cf 92       	push	r12
    307e:	df 92       	push	r13
    3080:	ef 92       	push	r14
    3082:	ff 92       	push	r15
    3084:	0f 93       	push	r16
    3086:	1f 93       	push	r17
    3088:	df 93       	push	r29
    308a:	cf 93       	push	r28
    308c:	cd b7       	in	r28, 0x3d	; 61
    308e:	de b7       	in	r29, 0x3e	; 62
    3090:	60 97       	sbiw	r28, 0x10	; 16
    3092:	0f b6       	in	r0, 0x3f	; 63
    3094:	f8 94       	cli
    3096:	de bf       	out	0x3e, r29	; 62
    3098:	0f be       	out	0x3f, r0	; 63
    309a:	cd bf       	out	0x3d, r28	; 61
    309c:	9f 83       	std	Y+7, r25	; 0x07
    309e:	8e 83       	std	Y+6, r24	; 0x06
    30a0:	79 87       	std	Y+9, r23	; 0x09
    30a2:	68 87       	std	Y+8, r22	; 0x08
    30a4:	5b 87       	std	Y+11, r21	; 0x0b
    30a6:	4a 87       	std	Y+10, r20	; 0x0a
    30a8:	3d 87       	std	Y+13, r19	; 0x0d
    30aa:	2c 87       	std	Y+12, r18	; 0x0c
    30ac:	0e 87       	std	Y+14, r16	; 0x0e
    30ae:	f8 8a       	std	Y+16, r15	; 0x10
    30b0:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    30b2:	8a 85       	ldd	r24, Y+10	; 0x0a
    30b4:	9b 85       	ldd	r25, Y+11	; 0x0b
    30b6:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    30ba:	9a 83       	std	Y+2, r25	; 0x02
    30bc:	89 83       	std	Y+1, r24	; 0x01

                if( pxStack != NULL )
    30be:	89 81       	ldd	r24, Y+1	; 0x01
    30c0:	9a 81       	ldd	r25, Y+2	; 0x02
    30c2:	00 97       	sbiw	r24, 0x00	; 0
    30c4:	b1 f0       	breq	.+44     	; 0x30f2 <xTaskCreate+0x7e>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    30c6:	86 e2       	ldi	r24, 0x26	; 38
    30c8:	90 e0       	ldi	r25, 0x00	; 0
    30ca:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    30ce:	9d 83       	std	Y+5, r25	; 0x05
    30d0:	8c 83       	std	Y+4, r24	; 0x04

                    if( pxNewTCB != NULL )
    30d2:	8c 81       	ldd	r24, Y+4	; 0x04
    30d4:	9d 81       	ldd	r25, Y+5	; 0x05
    30d6:	00 97       	sbiw	r24, 0x00	; 0
    30d8:	39 f0       	breq	.+14     	; 0x30e8 <xTaskCreate+0x74>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    30da:	ec 81       	ldd	r30, Y+4	; 0x04
    30dc:	fd 81       	ldd	r31, Y+5	; 0x05
    30de:	89 81       	ldd	r24, Y+1	; 0x01
    30e0:	9a 81       	ldd	r25, Y+2	; 0x02
    30e2:	90 8f       	std	Z+24, r25	; 0x18
    30e4:	87 8b       	std	Z+23, r24	; 0x17
    30e6:	07 c0       	rjmp	.+14     	; 0x30f6 <xTaskCreate+0x82>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFreeStack( pxStack );
    30e8:	89 81       	ldd	r24, Y+1	; 0x01
    30ea:	9a 81       	ldd	r25, Y+2	; 0x02
    30ec:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
    30f0:	02 c0       	rjmp	.+4      	; 0x30f6 <xTaskCreate+0x82>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
    30f2:	1d 82       	std	Y+5, r1	; 0x05
    30f4:	1c 82       	std	Y+4, r1	; 0x04
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    30f6:	8c 81       	ldd	r24, Y+4	; 0x04
    30f8:	9d 81       	ldd	r25, Y+5	; 0x05
    30fa:	00 97       	sbiw	r24, 0x00	; 0
    30fc:	e9 f0       	breq	.+58     	; 0x3138 <xTaskCreate+0xc4>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    30fe:	8a 85       	ldd	r24, Y+10	; 0x0a
    3100:	9b 85       	ldd	r25, Y+11	; 0x0b
    3102:	9c 01       	movw	r18, r24
    3104:	40 e0       	ldi	r20, 0x00	; 0
    3106:	50 e0       	ldi	r21, 0x00	; 0
    3108:	8e 81       	ldd	r24, Y+6	; 0x06
    310a:	9f 81       	ldd	r25, Y+7	; 0x07
    310c:	68 85       	ldd	r22, Y+8	; 0x08
    310e:	79 85       	ldd	r23, Y+9	; 0x09
    3110:	ec 85       	ldd	r30, Y+12	; 0x0c
    3112:	fd 85       	ldd	r31, Y+13	; 0x0d
    3114:	af 85       	ldd	r26, Y+15	; 0x0f
    3116:	b8 89       	ldd	r27, Y+16	; 0x10
    3118:	ac 80       	ldd	r10, Y+4	; 0x04
    311a:	bd 80       	ldd	r11, Y+5	; 0x05
    311c:	8f 01       	movw	r16, r30
    311e:	ee 84       	ldd	r14, Y+14	; 0x0e
    3120:	6d 01       	movw	r12, r26
    3122:	88 24       	eor	r8, r8
    3124:	99 24       	eor	r9, r9
    3126:	0e 94 b2 18 	call	0x3164	; 0x3164 <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    312a:	8c 81       	ldd	r24, Y+4	; 0x04
    312c:	9d 81       	ldd	r25, Y+5	; 0x05
    312e:	0e 94 77 19 	call	0x32ee	; 0x32ee <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    3132:	81 e0       	ldi	r24, 0x01	; 1
    3134:	8b 83       	std	Y+3, r24	; 0x03
    3136:	02 c0       	rjmp	.+4      	; 0x313c <xTaskCreate+0xc8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    3138:	8f ef       	ldi	r24, 0xFF	; 255
    313a:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    313c:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    313e:	60 96       	adiw	r28, 0x10	; 16
    3140:	0f b6       	in	r0, 0x3f	; 63
    3142:	f8 94       	cli
    3144:	de bf       	out	0x3e, r29	; 62
    3146:	0f be       	out	0x3f, r0	; 63
    3148:	cd bf       	out	0x3d, r28	; 61
    314a:	cf 91       	pop	r28
    314c:	df 91       	pop	r29
    314e:	1f 91       	pop	r17
    3150:	0f 91       	pop	r16
    3152:	ff 90       	pop	r15
    3154:	ef 90       	pop	r14
    3156:	df 90       	pop	r13
    3158:	cf 90       	pop	r12
    315a:	bf 90       	pop	r11
    315c:	af 90       	pop	r10
    315e:	9f 90       	pop	r9
    3160:	8f 90       	pop	r8
    3162:	08 95       	ret

00003164 <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    3164:	8f 92       	push	r8
    3166:	9f 92       	push	r9
    3168:	af 92       	push	r10
    316a:	bf 92       	push	r11
    316c:	cf 92       	push	r12
    316e:	df 92       	push	r13
    3170:	ef 92       	push	r14
    3172:	0f 93       	push	r16
    3174:	1f 93       	push	r17
    3176:	df 93       	push	r29
    3178:	cf 93       	push	r28
    317a:	cd b7       	in	r28, 0x3d	; 61
    317c:	de b7       	in	r29, 0x3e	; 62
    317e:	64 97       	sbiw	r28, 0x14	; 20
    3180:	0f b6       	in	r0, 0x3f	; 63
    3182:	f8 94       	cli
    3184:	de bf       	out	0x3e, r29	; 62
    3186:	0f be       	out	0x3f, r0	; 63
    3188:	cd bf       	out	0x3d, r28	; 61
    318a:	9d 83       	std	Y+5, r25	; 0x05
    318c:	8c 83       	std	Y+4, r24	; 0x04
    318e:	7f 83       	std	Y+7, r23	; 0x07
    3190:	6e 83       	std	Y+6, r22	; 0x06
    3192:	28 87       	std	Y+8, r18	; 0x08
    3194:	39 87       	std	Y+9, r19	; 0x09
    3196:	4a 87       	std	Y+10, r20	; 0x0a
    3198:	5b 87       	std	Y+11, r21	; 0x0b
    319a:	1d 87       	std	Y+13, r17	; 0x0d
    319c:	0c 87       	std	Y+12, r16	; 0x0c
    319e:	ee 86       	std	Y+14, r14	; 0x0e
    31a0:	d8 8a       	std	Y+16, r13	; 0x10
    31a2:	cf 86       	std	Y+15, r12	; 0x0f
    31a4:	ba 8a       	std	Y+18, r11	; 0x12
    31a6:	a9 8a       	std	Y+17, r10	; 0x11
    31a8:	9c 8a       	std	Y+20, r9	; 0x14
    31aa:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    31ac:	e9 89       	ldd	r30, Y+17	; 0x11
    31ae:	fa 89       	ldd	r31, Y+18	; 0x12
    31b0:	27 89       	ldd	r18, Z+23	; 0x17
    31b2:	30 8d       	ldd	r19, Z+24	; 0x18
    31b4:	88 85       	ldd	r24, Y+8	; 0x08
    31b6:	99 85       	ldd	r25, Y+9	; 0x09
    31b8:	01 97       	sbiw	r24, 0x01	; 1
    31ba:	82 0f       	add	r24, r18
    31bc:	93 1f       	adc	r25, r19
    31be:	9b 83       	std	Y+3, r25	; 0x03
    31c0:	8a 83       	std	Y+2, r24	; 0x02
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    31c2:	8e 81       	ldd	r24, Y+6	; 0x06
    31c4:	9f 81       	ldd	r25, Y+7	; 0x07
    31c6:	00 97       	sbiw	r24, 0x00	; 0
    31c8:	51 f1       	breq	.+84     	; 0x321e <prvInitialiseNewTask+0xba>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    31ca:	19 82       	std	Y+1, r1	; 0x01
    31cc:	21 c0       	rjmp	.+66     	; 0x3210 <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    31ce:	89 81       	ldd	r24, Y+1	; 0x01
    31d0:	48 2f       	mov	r20, r24
    31d2:	50 e0       	ldi	r21, 0x00	; 0
    31d4:	89 81       	ldd	r24, Y+1	; 0x01
    31d6:	28 2f       	mov	r18, r24
    31d8:	30 e0       	ldi	r19, 0x00	; 0
    31da:	8e 81       	ldd	r24, Y+6	; 0x06
    31dc:	9f 81       	ldd	r25, Y+7	; 0x07
    31de:	fc 01       	movw	r30, r24
    31e0:	e2 0f       	add	r30, r18
    31e2:	f3 1f       	adc	r31, r19
    31e4:	20 81       	ld	r18, Z
    31e6:	89 89       	ldd	r24, Y+17	; 0x11
    31e8:	9a 89       	ldd	r25, Y+18	; 0x12
    31ea:	84 0f       	add	r24, r20
    31ec:	95 1f       	adc	r25, r21
    31ee:	fc 01       	movw	r30, r24
    31f0:	79 96       	adiw	r30, 0x19	; 25
    31f2:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    31f4:	89 81       	ldd	r24, Y+1	; 0x01
    31f6:	28 2f       	mov	r18, r24
    31f8:	30 e0       	ldi	r19, 0x00	; 0
    31fa:	8e 81       	ldd	r24, Y+6	; 0x06
    31fc:	9f 81       	ldd	r25, Y+7	; 0x07
    31fe:	fc 01       	movw	r30, r24
    3200:	e2 0f       	add	r30, r18
    3202:	f3 1f       	adc	r31, r19
    3204:	80 81       	ld	r24, Z
    3206:	88 23       	and	r24, r24
    3208:	31 f0       	breq	.+12     	; 0x3216 <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    320a:	89 81       	ldd	r24, Y+1	; 0x01
    320c:	8f 5f       	subi	r24, 0xFF	; 255
    320e:	89 83       	std	Y+1, r24	; 0x01
    3210:	89 81       	ldd	r24, Y+1	; 0x01
    3212:	88 30       	cpi	r24, 0x08	; 8
    3214:	e0 f2       	brcs	.-72     	; 0x31ce <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3216:	e9 89       	ldd	r30, Y+17	; 0x11
    3218:	fa 89       	ldd	r31, Y+18	; 0x12
    321a:	10 a2       	std	Z+32, r1	; 0x20
    321c:	03 c0       	rjmp	.+6      	; 0x3224 <prvInitialiseNewTask+0xc0>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    321e:	e9 89       	ldd	r30, Y+17	; 0x11
    3220:	fa 89       	ldd	r31, Y+18	; 0x12
    3222:	11 8e       	std	Z+25, r1	; 0x19
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3224:	8e 85       	ldd	r24, Y+14	; 0x0e
    3226:	84 30       	cpi	r24, 0x04	; 4
    3228:	10 f0       	brcs	.+4      	; 0x322e <prvInitialiseNewTask+0xca>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    322a:	83 e0       	ldi	r24, 0x03	; 3
    322c:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    322e:	e9 89       	ldd	r30, Y+17	; 0x11
    3230:	fa 89       	ldd	r31, Y+18	; 0x12
    3232:	8e 85       	ldd	r24, Y+14	; 0x0e
    3234:	86 8b       	std	Z+22, r24	; 0x16
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    3236:	89 89       	ldd	r24, Y+17	; 0x11
    3238:	9a 89       	ldd	r25, Y+18	; 0x12
    323a:	02 96       	adiw	r24, 0x02	; 2
    323c:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    3240:	89 89       	ldd	r24, Y+17	; 0x11
    3242:	9a 89       	ldd	r25, Y+18	; 0x12
    3244:	0c 96       	adiw	r24, 0x0c	; 12
    3246:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    324a:	e9 89       	ldd	r30, Y+17	; 0x11
    324c:	fa 89       	ldd	r31, Y+18	; 0x12
    324e:	89 89       	ldd	r24, Y+17	; 0x11
    3250:	9a 89       	ldd	r25, Y+18	; 0x12
    3252:	91 87       	std	Z+9, r25	; 0x09
    3254:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3256:	8e 85       	ldd	r24, Y+14	; 0x0e
    3258:	28 2f       	mov	r18, r24
    325a:	30 e0       	ldi	r19, 0x00	; 0
    325c:	84 e0       	ldi	r24, 0x04	; 4
    325e:	90 e0       	ldi	r25, 0x00	; 0
    3260:	82 1b       	sub	r24, r18
    3262:	93 0b       	sbc	r25, r19
    3264:	e9 89       	ldd	r30, Y+17	; 0x11
    3266:	fa 89       	ldd	r31, Y+18	; 0x12
    3268:	95 87       	std	Z+13, r25	; 0x0d
    326a:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    326c:	e9 89       	ldd	r30, Y+17	; 0x11
    326e:	fa 89       	ldd	r31, Y+18	; 0x12
    3270:	89 89       	ldd	r24, Y+17	; 0x11
    3272:	9a 89       	ldd	r25, Y+18	; 0x12
    3274:	93 8b       	std	Z+19, r25	; 0x13
    3276:	82 8b       	std	Z+18, r24	; 0x12
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    3278:	89 89       	ldd	r24, Y+17	; 0x11
    327a:	9a 89       	ldd	r25, Y+18	; 0x12
    327c:	81 96       	adiw	r24, 0x21	; 33
    327e:	60 e0       	ldi	r22, 0x00	; 0
    3280:	70 e0       	ldi	r23, 0x00	; 0
    3282:	44 e0       	ldi	r20, 0x04	; 4
    3284:	50 e0       	ldi	r21, 0x00	; 0
    3286:	0e 94 54 33 	call	0x66a8	; 0x66a8 <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    328a:	89 89       	ldd	r24, Y+17	; 0x11
    328c:	9a 89       	ldd	r25, Y+18	; 0x12
    328e:	85 96       	adiw	r24, 0x25	; 37
    3290:	60 e0       	ldi	r22, 0x00	; 0
    3292:	70 e0       	ldi	r23, 0x00	; 0
    3294:	41 e0       	ldi	r20, 0x01	; 1
    3296:	50 e0       	ldi	r21, 0x00	; 0
    3298:	0e 94 54 33 	call	0x66a8	; 0x66a8 <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    329c:	8a 81       	ldd	r24, Y+2	; 0x02
    329e:	9b 81       	ldd	r25, Y+3	; 0x03
    32a0:	2c 81       	ldd	r18, Y+4	; 0x04
    32a2:	3d 81       	ldd	r19, Y+5	; 0x05
    32a4:	4c 85       	ldd	r20, Y+12	; 0x0c
    32a6:	5d 85       	ldd	r21, Y+13	; 0x0d
    32a8:	b9 01       	movw	r22, r18
    32aa:	0e 94 c9 00 	call	0x192	; 0x192 <pxPortInitialiseStack>
    32ae:	e9 89       	ldd	r30, Y+17	; 0x11
    32b0:	fa 89       	ldd	r31, Y+18	; 0x12
    32b2:	91 83       	std	Z+1, r25	; 0x01
    32b4:	80 83       	st	Z, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    32b6:	8f 85       	ldd	r24, Y+15	; 0x0f
    32b8:	98 89       	ldd	r25, Y+16	; 0x10
    32ba:	00 97       	sbiw	r24, 0x00	; 0
    32bc:	31 f0       	breq	.+12     	; 0x32ca <prvInitialiseNewTask+0x166>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    32be:	ef 85       	ldd	r30, Y+15	; 0x0f
    32c0:	f8 89       	ldd	r31, Y+16	; 0x10
    32c2:	89 89       	ldd	r24, Y+17	; 0x11
    32c4:	9a 89       	ldd	r25, Y+18	; 0x12
    32c6:	91 83       	std	Z+1, r25	; 0x01
    32c8:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    32ca:	64 96       	adiw	r28, 0x14	; 20
    32cc:	0f b6       	in	r0, 0x3f	; 63
    32ce:	f8 94       	cli
    32d0:	de bf       	out	0x3e, r29	; 62
    32d2:	0f be       	out	0x3f, r0	; 63
    32d4:	cd bf       	out	0x3d, r28	; 61
    32d6:	cf 91       	pop	r28
    32d8:	df 91       	pop	r29
    32da:	1f 91       	pop	r17
    32dc:	0f 91       	pop	r16
    32de:	ef 90       	pop	r14
    32e0:	df 90       	pop	r13
    32e2:	cf 90       	pop	r12
    32e4:	bf 90       	pop	r11
    32e6:	af 90       	pop	r10
    32e8:	9f 90       	pop	r9
    32ea:	8f 90       	pop	r8
    32ec:	08 95       	ret

000032ee <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    32ee:	df 93       	push	r29
    32f0:	cf 93       	push	r28
    32f2:	00 d0       	rcall	.+0      	; 0x32f4 <prvAddNewTaskToReadyList+0x6>
    32f4:	00 d0       	rcall	.+0      	; 0x32f6 <prvAddNewTaskToReadyList+0x8>
    32f6:	cd b7       	in	r28, 0x3d	; 61
    32f8:	de b7       	in	r29, 0x3e	; 62
    32fa:	9c 83       	std	Y+4, r25	; 0x04
    32fc:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    32fe:	0f b6       	in	r0, 0x3f	; 63
    3300:	f8 94       	cli
    3302:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    3304:	80 91 a9 06 	lds	r24, 0x06A9
    3308:	8f 5f       	subi	r24, 0xFF	; 255
    330a:	80 93 a9 06 	sts	0x06A9, r24

        if( pxCurrentTCB == NULL )
    330e:	80 91 a6 06 	lds	r24, 0x06A6
    3312:	90 91 a7 06 	lds	r25, 0x06A7
    3316:	00 97       	sbiw	r24, 0x00	; 0
    3318:	69 f4       	brne	.+26     	; 0x3334 <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    331a:	8b 81       	ldd	r24, Y+3	; 0x03
    331c:	9c 81       	ldd	r25, Y+4	; 0x04
    331e:	90 93 a7 06 	sts	0x06A7, r25
    3322:	80 93 a6 06 	sts	0x06A6, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3326:	80 91 a9 06 	lds	r24, 0x06A9
    332a:	81 30       	cpi	r24, 0x01	; 1
    332c:	b9 f4       	brne	.+46     	; 0x335c <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    332e:	0e 94 5b 23 	call	0x46b6	; 0x46b6 <prvInitialiseTaskLists>
    3332:	14 c0       	rjmp	.+40     	; 0x335c <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    3334:	80 91 ad 06 	lds	r24, 0x06AD
    3338:	88 23       	and	r24, r24
    333a:	81 f4       	brne	.+32     	; 0x335c <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    333c:	e0 91 a6 06 	lds	r30, 0x06A6
    3340:	f0 91 a7 06 	lds	r31, 0x06A7
    3344:	96 89       	ldd	r25, Z+22	; 0x16
    3346:	eb 81       	ldd	r30, Y+3	; 0x03
    3348:	fc 81       	ldd	r31, Y+4	; 0x04
    334a:	86 89       	ldd	r24, Z+22	; 0x16
    334c:	89 17       	cp	r24, r25
    334e:	30 f0       	brcs	.+12     	; 0x335c <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    3350:	8b 81       	ldd	r24, Y+3	; 0x03
    3352:	9c 81       	ldd	r25, Y+4	; 0x04
    3354:	90 93 a7 06 	sts	0x06A7, r25
    3358:	80 93 a6 06 	sts	0x06A6, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    335c:	80 91 b2 06 	lds	r24, 0x06B2
    3360:	8f 5f       	subi	r24, 0xFF	; 255
    3362:	80 93 b2 06 	sts	0x06B2, r24
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    3366:	eb 81       	ldd	r30, Y+3	; 0x03
    3368:	fc 81       	ldd	r31, Y+4	; 0x04
    336a:	96 89       	ldd	r25, Z+22	; 0x16
    336c:	80 91 ac 06 	lds	r24, 0x06AC
    3370:	89 17       	cp	r24, r25
    3372:	28 f4       	brcc	.+10     	; 0x337e <prvAddNewTaskToReadyList+0x90>
    3374:	eb 81       	ldd	r30, Y+3	; 0x03
    3376:	fc 81       	ldd	r31, Y+4	; 0x04
    3378:	86 89       	ldd	r24, Z+22	; 0x16
    337a:	80 93 ac 06 	sts	0x06AC, r24
    337e:	eb 81       	ldd	r30, Y+3	; 0x03
    3380:	fc 81       	ldd	r31, Y+4	; 0x04
    3382:	86 89       	ldd	r24, Z+22	; 0x16
    3384:	28 2f       	mov	r18, r24
    3386:	30 e0       	ldi	r19, 0x00	; 0
    3388:	c9 01       	movw	r24, r18
    338a:	88 0f       	add	r24, r24
    338c:	99 1f       	adc	r25, r25
    338e:	88 0f       	add	r24, r24
    3390:	99 1f       	adc	r25, r25
    3392:	88 0f       	add	r24, r24
    3394:	99 1f       	adc	r25, r25
    3396:	82 0f       	add	r24, r18
    3398:	93 1f       	adc	r25, r19
    339a:	fc 01       	movw	r30, r24
    339c:	e8 54       	subi	r30, 0x48	; 72
    339e:	f9 4f       	sbci	r31, 0xF9	; 249
    33a0:	81 81       	ldd	r24, Z+1	; 0x01
    33a2:	92 81       	ldd	r25, Z+2	; 0x02
    33a4:	9a 83       	std	Y+2, r25	; 0x02
    33a6:	89 83       	std	Y+1, r24	; 0x01
    33a8:	eb 81       	ldd	r30, Y+3	; 0x03
    33aa:	fc 81       	ldd	r31, Y+4	; 0x04
    33ac:	89 81       	ldd	r24, Y+1	; 0x01
    33ae:	9a 81       	ldd	r25, Y+2	; 0x02
    33b0:	95 83       	std	Z+5, r25	; 0x05
    33b2:	84 83       	std	Z+4, r24	; 0x04
    33b4:	e9 81       	ldd	r30, Y+1	; 0x01
    33b6:	fa 81       	ldd	r31, Y+2	; 0x02
    33b8:	84 81       	ldd	r24, Z+4	; 0x04
    33ba:	95 81       	ldd	r25, Z+5	; 0x05
    33bc:	eb 81       	ldd	r30, Y+3	; 0x03
    33be:	fc 81       	ldd	r31, Y+4	; 0x04
    33c0:	97 83       	std	Z+7, r25	; 0x07
    33c2:	86 83       	std	Z+6, r24	; 0x06
    33c4:	e9 81       	ldd	r30, Y+1	; 0x01
    33c6:	fa 81       	ldd	r31, Y+2	; 0x02
    33c8:	04 80       	ldd	r0, Z+4	; 0x04
    33ca:	f5 81       	ldd	r31, Z+5	; 0x05
    33cc:	e0 2d       	mov	r30, r0
    33ce:	8b 81       	ldd	r24, Y+3	; 0x03
    33d0:	9c 81       	ldd	r25, Y+4	; 0x04
    33d2:	02 96       	adiw	r24, 0x02	; 2
    33d4:	93 83       	std	Z+3, r25	; 0x03
    33d6:	82 83       	std	Z+2, r24	; 0x02
    33d8:	8b 81       	ldd	r24, Y+3	; 0x03
    33da:	9c 81       	ldd	r25, Y+4	; 0x04
    33dc:	02 96       	adiw	r24, 0x02	; 2
    33de:	e9 81       	ldd	r30, Y+1	; 0x01
    33e0:	fa 81       	ldd	r31, Y+2	; 0x02
    33e2:	95 83       	std	Z+5, r25	; 0x05
    33e4:	84 83       	std	Z+4, r24	; 0x04
    33e6:	eb 81       	ldd	r30, Y+3	; 0x03
    33e8:	fc 81       	ldd	r31, Y+4	; 0x04
    33ea:	86 89       	ldd	r24, Z+22	; 0x16
    33ec:	28 2f       	mov	r18, r24
    33ee:	30 e0       	ldi	r19, 0x00	; 0
    33f0:	c9 01       	movw	r24, r18
    33f2:	88 0f       	add	r24, r24
    33f4:	99 1f       	adc	r25, r25
    33f6:	88 0f       	add	r24, r24
    33f8:	99 1f       	adc	r25, r25
    33fa:	88 0f       	add	r24, r24
    33fc:	99 1f       	adc	r25, r25
    33fe:	82 0f       	add	r24, r18
    3400:	93 1f       	adc	r25, r19
    3402:	88 54       	subi	r24, 0x48	; 72
    3404:	99 4f       	sbci	r25, 0xF9	; 249
    3406:	eb 81       	ldd	r30, Y+3	; 0x03
    3408:	fc 81       	ldd	r31, Y+4	; 0x04
    340a:	93 87       	std	Z+11, r25	; 0x0b
    340c:	82 87       	std	Z+10, r24	; 0x0a
    340e:	eb 81       	ldd	r30, Y+3	; 0x03
    3410:	fc 81       	ldd	r31, Y+4	; 0x04
    3412:	86 89       	ldd	r24, Z+22	; 0x16
    3414:	28 2f       	mov	r18, r24
    3416:	30 e0       	ldi	r19, 0x00	; 0
    3418:	c9 01       	movw	r24, r18
    341a:	88 0f       	add	r24, r24
    341c:	99 1f       	adc	r25, r25
    341e:	88 0f       	add	r24, r24
    3420:	99 1f       	adc	r25, r25
    3422:	88 0f       	add	r24, r24
    3424:	99 1f       	adc	r25, r25
    3426:	82 0f       	add	r24, r18
    3428:	93 1f       	adc	r25, r19
    342a:	fc 01       	movw	r30, r24
    342c:	e8 54       	subi	r30, 0x48	; 72
    342e:	f9 4f       	sbci	r31, 0xF9	; 249
    3430:	80 81       	ld	r24, Z
    3432:	8f 5f       	subi	r24, 0xFF	; 255
    3434:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    3436:	0f 90       	pop	r0
    3438:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    343a:	80 91 ad 06 	lds	r24, 0x06AD
    343e:	88 23       	and	r24, r24
    3440:	61 f0       	breq	.+24     	; 0x345a <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    3442:	e0 91 a6 06 	lds	r30, 0x06A6
    3446:	f0 91 a7 06 	lds	r31, 0x06A7
    344a:	96 89       	ldd	r25, Z+22	; 0x16
    344c:	eb 81       	ldd	r30, Y+3	; 0x03
    344e:	fc 81       	ldd	r31, Y+4	; 0x04
    3450:	86 89       	ldd	r24, Z+22	; 0x16
    3452:	98 17       	cp	r25, r24
    3454:	10 f4       	brcc	.+4      	; 0x345a <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    3456:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    345a:	0f 90       	pop	r0
    345c:	0f 90       	pop	r0
    345e:	0f 90       	pop	r0
    3460:	0f 90       	pop	r0
    3462:	cf 91       	pop	r28
    3464:	df 91       	pop	r29
    3466:	08 95       	ret

00003468 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    3468:	df 93       	push	r29
    346a:	cf 93       	push	r28
    346c:	00 d0       	rcall	.+0      	; 0x346e <vTaskDelete+0x6>
    346e:	00 d0       	rcall	.+0      	; 0x3470 <vTaskDelete+0x8>
    3470:	00 d0       	rcall	.+0      	; 0x3472 <vTaskDelete+0xa>
    3472:	cd b7       	in	r28, 0x3d	; 61
    3474:	de b7       	in	r29, 0x3e	; 62
    3476:	9c 83       	std	Y+4, r25	; 0x04
    3478:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    347a:	0f b6       	in	r0, 0x3f	; 63
    347c:	f8 94       	cli
    347e:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3480:	8b 81       	ldd	r24, Y+3	; 0x03
    3482:	9c 81       	ldd	r25, Y+4	; 0x04
    3484:	00 97       	sbiw	r24, 0x00	; 0
    3486:	39 f4       	brne	.+14     	; 0x3496 <vTaskDelete+0x2e>
    3488:	80 91 a6 06 	lds	r24, 0x06A6
    348c:	90 91 a7 06 	lds	r25, 0x06A7
    3490:	9e 83       	std	Y+6, r25	; 0x06
    3492:	8d 83       	std	Y+5, r24	; 0x05
    3494:	04 c0       	rjmp	.+8      	; 0x349e <vTaskDelete+0x36>
    3496:	8b 81       	ldd	r24, Y+3	; 0x03
    3498:	9c 81       	ldd	r25, Y+4	; 0x04
    349a:	9e 83       	std	Y+6, r25	; 0x06
    349c:	8d 83       	std	Y+5, r24	; 0x05
    349e:	8d 81       	ldd	r24, Y+5	; 0x05
    34a0:	9e 81       	ldd	r25, Y+6	; 0x06
    34a2:	9a 83       	std	Y+2, r25	; 0x02
    34a4:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    34a6:	89 81       	ldd	r24, Y+1	; 0x01
    34a8:	9a 81       	ldd	r25, Y+2	; 0x02
    34aa:	02 96       	adiw	r24, 0x02	; 2
    34ac:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    34b0:	e9 81       	ldd	r30, Y+1	; 0x01
    34b2:	fa 81       	ldd	r31, Y+2	; 0x02
    34b4:	84 89       	ldd	r24, Z+20	; 0x14
    34b6:	95 89       	ldd	r25, Z+21	; 0x15
    34b8:	00 97       	sbiw	r24, 0x00	; 0
    34ba:	29 f0       	breq	.+10     	; 0x34c6 <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    34bc:	89 81       	ldd	r24, Y+1	; 0x01
    34be:	9a 81       	ldd	r25, Y+2	; 0x02
    34c0:	0c 96       	adiw	r24, 0x0c	; 12
    34c2:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    34c6:	80 91 b2 06 	lds	r24, 0x06B2
    34ca:	8f 5f       	subi	r24, 0xFF	; 255
    34cc:	80 93 b2 06 	sts	0x06B2, r24

            if( pxTCB == pxCurrentTCB )
    34d0:	20 91 a6 06 	lds	r18, 0x06A6
    34d4:	30 91 a7 06 	lds	r19, 0x06A7
    34d8:	89 81       	ldd	r24, Y+1	; 0x01
    34da:	9a 81       	ldd	r25, Y+2	; 0x02
    34dc:	82 17       	cp	r24, r18
    34de:	93 07       	cpc	r25, r19
    34e0:	81 f4       	brne	.+32     	; 0x3502 <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    34e2:	89 81       	ldd	r24, Y+1	; 0x01
    34e4:	9a 81       	ldd	r25, Y+2	; 0x02
    34e6:	9c 01       	movw	r18, r24
    34e8:	2e 5f       	subi	r18, 0xFE	; 254
    34ea:	3f 4f       	sbci	r19, 0xFF	; 255
    34ec:	8b ef       	ldi	r24, 0xFB	; 251
    34ee:	96 e0       	ldi	r25, 0x06	; 6
    34f0:	b9 01       	movw	r22, r18
    34f2:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    34f6:	80 91 a8 06 	lds	r24, 0x06A8
    34fa:	8f 5f       	subi	r24, 0xFF	; 255
    34fc:	80 93 a8 06 	sts	0x06A8, r24
    3500:	07 c0       	rjmp	.+14     	; 0x3510 <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    3502:	80 91 a9 06 	lds	r24, 0x06A9
    3506:	81 50       	subi	r24, 0x01	; 1
    3508:	80 93 a9 06 	sts	0x06A9, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    350c:	0e 94 dd 23 	call	0x47ba	; 0x47ba <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    3510:	0f 90       	pop	r0
    3512:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    3514:	20 91 a6 06 	lds	r18, 0x06A6
    3518:	30 91 a7 06 	lds	r19, 0x06A7
    351c:	89 81       	ldd	r24, Y+1	; 0x01
    351e:	9a 81       	ldd	r25, Y+2	; 0x02
    3520:	82 17       	cp	r24, r18
    3522:	93 07       	cpc	r25, r19
    3524:	21 f0       	breq	.+8      	; 0x352e <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    3526:	89 81       	ldd	r24, Y+1	; 0x01
    3528:	9a 81       	ldd	r25, Y+2	; 0x02
    352a:	0e 94 c7 23 	call	0x478e	; 0x478e <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    352e:	80 91 ad 06 	lds	r24, 0x06AD
    3532:	88 23       	and	r24, r24
    3534:	59 f0       	breq	.+22     	; 0x354c <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    3536:	20 91 a6 06 	lds	r18, 0x06A6
    353a:	30 91 a7 06 	lds	r19, 0x06A7
    353e:	89 81       	ldd	r24, Y+1	; 0x01
    3540:	9a 81       	ldd	r25, Y+2	; 0x02
    3542:	82 17       	cp	r24, r18
    3544:	93 07       	cpc	r25, r19
    3546:	11 f4       	brne	.+4      	; 0x354c <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    3548:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    354c:	26 96       	adiw	r28, 0x06	; 6
    354e:	0f b6       	in	r0, 0x3f	; 63
    3550:	f8 94       	cli
    3552:	de bf       	out	0x3e, r29	; 62
    3554:	0f be       	out	0x3f, r0	; 63
    3556:	cd bf       	out	0x3d, r28	; 61
    3558:	cf 91       	pop	r28
    355a:	df 91       	pop	r29
    355c:	08 95       	ret

0000355e <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    355e:	df 93       	push	r29
    3560:	cf 93       	push	r28
    3562:	cd b7       	in	r28, 0x3d	; 61
    3564:	de b7       	in	r29, 0x3e	; 62
    3566:	2a 97       	sbiw	r28, 0x0a	; 10
    3568:	0f b6       	in	r0, 0x3f	; 63
    356a:	f8 94       	cli
    356c:	de bf       	out	0x3e, r29	; 62
    356e:	0f be       	out	0x3f, r0	; 63
    3570:	cd bf       	out	0x3d, r28	; 61
    3572:	98 87       	std	Y+8, r25	; 0x08
    3574:	8f 83       	std	Y+7, r24	; 0x07
    3576:	7a 87       	std	Y+10, r23	; 0x0a
    3578:	69 87       	std	Y+9, r22	; 0x09
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    357a:	1b 82       	std	Y+3, r1	; 0x03

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    357c:	0e 94 8b 1b 	call	0x3716	; 0x3716 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    3580:	80 91 aa 06 	lds	r24, 0x06AA
    3584:	90 91 ab 06 	lds	r25, 0x06AB
    3588:	9a 83       	std	Y+2, r25	; 0x02
    358a:	89 83       	std	Y+1, r24	; 0x01

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    358c:	ef 81       	ldd	r30, Y+7	; 0x07
    358e:	f8 85       	ldd	r31, Y+8	; 0x08
    3590:	20 81       	ld	r18, Z
    3592:	31 81       	ldd	r19, Z+1	; 0x01
    3594:	89 85       	ldd	r24, Y+9	; 0x09
    3596:	9a 85       	ldd	r25, Y+10	; 0x0a
    3598:	82 0f       	add	r24, r18
    359a:	93 1f       	adc	r25, r19
    359c:	9e 83       	std	Y+6, r25	; 0x06
    359e:	8d 83       	std	Y+5, r24	; 0x05

            if( xConstTickCount < *pxPreviousWakeTime )
    35a0:	ef 81       	ldd	r30, Y+7	; 0x07
    35a2:	f8 85       	ldd	r31, Y+8	; 0x08
    35a4:	20 81       	ld	r18, Z
    35a6:	31 81       	ldd	r19, Z+1	; 0x01
    35a8:	89 81       	ldd	r24, Y+1	; 0x01
    35aa:	9a 81       	ldd	r25, Y+2	; 0x02
    35ac:	82 17       	cp	r24, r18
    35ae:	93 07       	cpc	r25, r19
    35b0:	98 f4       	brcc	.+38     	; 0x35d8 <xTaskDelayUntil+0x7a>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    35b2:	ef 81       	ldd	r30, Y+7	; 0x07
    35b4:	f8 85       	ldd	r31, Y+8	; 0x08
    35b6:	20 81       	ld	r18, Z
    35b8:	31 81       	ldd	r19, Z+1	; 0x01
    35ba:	8d 81       	ldd	r24, Y+5	; 0x05
    35bc:	9e 81       	ldd	r25, Y+6	; 0x06
    35be:	82 17       	cp	r24, r18
    35c0:	93 07       	cpc	r25, r19
    35c2:	e0 f4       	brcc	.+56     	; 0x35fc <xTaskDelayUntil+0x9e>
    35c4:	2d 81       	ldd	r18, Y+5	; 0x05
    35c6:	3e 81       	ldd	r19, Y+6	; 0x06
    35c8:	89 81       	ldd	r24, Y+1	; 0x01
    35ca:	9a 81       	ldd	r25, Y+2	; 0x02
    35cc:	82 17       	cp	r24, r18
    35ce:	93 07       	cpc	r25, r19
    35d0:	a8 f4       	brcc	.+42     	; 0x35fc <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    35d2:	81 e0       	ldi	r24, 0x01	; 1
    35d4:	8b 83       	std	Y+3, r24	; 0x03
    35d6:	12 c0       	rjmp	.+36     	; 0x35fc <xTaskDelayUntil+0x9e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    35d8:	ef 81       	ldd	r30, Y+7	; 0x07
    35da:	f8 85       	ldd	r31, Y+8	; 0x08
    35dc:	20 81       	ld	r18, Z
    35de:	31 81       	ldd	r19, Z+1	; 0x01
    35e0:	8d 81       	ldd	r24, Y+5	; 0x05
    35e2:	9e 81       	ldd	r25, Y+6	; 0x06
    35e4:	82 17       	cp	r24, r18
    35e6:	93 07       	cpc	r25, r19
    35e8:	38 f0       	brcs	.+14     	; 0x35f8 <xTaskDelayUntil+0x9a>
    35ea:	2d 81       	ldd	r18, Y+5	; 0x05
    35ec:	3e 81       	ldd	r19, Y+6	; 0x06
    35ee:	89 81       	ldd	r24, Y+1	; 0x01
    35f0:	9a 81       	ldd	r25, Y+2	; 0x02
    35f2:	82 17       	cp	r24, r18
    35f4:	93 07       	cpc	r25, r19
    35f6:	10 f4       	brcc	.+4      	; 0x35fc <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    35f8:	81 e0       	ldi	r24, 0x01	; 1
    35fa:	8b 83       	std	Y+3, r24	; 0x03
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    35fc:	ef 81       	ldd	r30, Y+7	; 0x07
    35fe:	f8 85       	ldd	r31, Y+8	; 0x08
    3600:	8d 81       	ldd	r24, Y+5	; 0x05
    3602:	9e 81       	ldd	r25, Y+6	; 0x06
    3604:	91 83       	std	Z+1, r25	; 0x01
    3606:	80 83       	st	Z, r24

            if( xShouldDelay != pdFALSE )
    3608:	8b 81       	ldd	r24, Y+3	; 0x03
    360a:	88 23       	and	r24, r24
    360c:	49 f0       	breq	.+18     	; 0x3620 <xTaskDelayUntil+0xc2>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    360e:	8d 81       	ldd	r24, Y+5	; 0x05
    3610:	9e 81       	ldd	r25, Y+6	; 0x06
    3612:	29 81       	ldd	r18, Y+1	; 0x01
    3614:	3a 81       	ldd	r19, Y+2	; 0x02
    3616:	82 1b       	sub	r24, r18
    3618:	93 0b       	sbc	r25, r19
    361a:	60 e0       	ldi	r22, 0x00	; 0
    361c:	0e 94 c4 2b 	call	0x5788	; 0x5788 <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    3620:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>
    3624:	8c 83       	std	Y+4, r24	; 0x04

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3626:	8c 81       	ldd	r24, Y+4	; 0x04
    3628:	88 23       	and	r24, r24
    362a:	11 f4       	brne	.+4      	; 0x3630 <xTaskDelayUntil+0xd2>
        {
            portYIELD_WITHIN_API();
    362c:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    3630:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    3632:	2a 96       	adiw	r28, 0x0a	; 10
    3634:	0f b6       	in	r0, 0x3f	; 63
    3636:	f8 94       	cli
    3638:	de bf       	out	0x3e, r29	; 62
    363a:	0f be       	out	0x3f, r0	; 63
    363c:	cd bf       	out	0x3d, r28	; 61
    363e:	cf 91       	pop	r28
    3640:	df 91       	pop	r29
    3642:	08 95       	ret

00003644 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    3644:	df 93       	push	r29
    3646:	cf 93       	push	r28
    3648:	00 d0       	rcall	.+0      	; 0x364a <vTaskDelay+0x6>
    364a:	0f 92       	push	r0
    364c:	cd b7       	in	r28, 0x3d	; 61
    364e:	de b7       	in	r29, 0x3e	; 62
    3650:	9b 83       	std	Y+3, r25	; 0x03
    3652:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    3654:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    3656:	8a 81       	ldd	r24, Y+2	; 0x02
    3658:	9b 81       	ldd	r25, Y+3	; 0x03
    365a:	00 97       	sbiw	r24, 0x00	; 0
    365c:	51 f0       	breq	.+20     	; 0x3672 <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    365e:	0e 94 8b 1b 	call	0x3716	; 0x3716 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3662:	8a 81       	ldd	r24, Y+2	; 0x02
    3664:	9b 81       	ldd	r25, Y+3	; 0x03
    3666:	60 e0       	ldi	r22, 0x00	; 0
    3668:	0e 94 c4 2b 	call	0x5788	; 0x5788 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    366c:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>
    3670:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3672:	89 81       	ldd	r24, Y+1	; 0x01
    3674:	88 23       	and	r24, r24
    3676:	11 f4       	brne	.+4      	; 0x367c <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    3678:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    367c:	0f 90       	pop	r0
    367e:	0f 90       	pop	r0
    3680:	0f 90       	pop	r0
    3682:	cf 91       	pop	r28
    3684:	df 91       	pop	r29
    3686:	08 95       	ret

00003688 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3688:	ef 92       	push	r14
    368a:	ff 92       	push	r15
    368c:	0f 93       	push	r16
    368e:	df 93       	push	r29
    3690:	cf 93       	push	r28
    3692:	00 d0       	rcall	.+0      	; 0x3694 <vTaskStartScheduler+0xc>
    3694:	cd b7       	in	r28, 0x3d	; 61
    3696:	de b7       	in	r29, 0x3e	; 62
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    3698:	8b e4       	ldi	r24, 0x4B	; 75
    369a:	93 e2       	ldi	r25, 0x23	; 35
    369c:	20 e6       	ldi	r18, 0x60	; 96
    369e:	30 e0       	ldi	r19, 0x00	; 0
    36a0:	e5 eb       	ldi	r30, 0xB5	; 181
    36a2:	f6 e0       	ldi	r31, 0x06	; 6
    36a4:	b9 01       	movw	r22, r18
    36a6:	45 e5       	ldi	r20, 0x55	; 85
    36a8:	50 e0       	ldi	r21, 0x00	; 0
    36aa:	20 e0       	ldi	r18, 0x00	; 0
    36ac:	30 e0       	ldi	r19, 0x00	; 0
    36ae:	00 e0       	ldi	r16, 0x00	; 0
    36b0:	7f 01       	movw	r14, r30
    36b2:	0e 94 3a 18 	call	0x3074	; 0x3074 <xTaskCreate>
    36b6:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
        {
            if( xReturn == pdPASS )
    36b8:	89 81       	ldd	r24, Y+1	; 0x01
    36ba:	81 30       	cpi	r24, 0x01	; 1
    36bc:	19 f4       	brne	.+6      	; 0x36c4 <vTaskStartScheduler+0x3c>
            {
                xReturn = xTimerCreateTimerTask();
    36be:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTimerCreateTimerTask>
    36c2:	89 83       	std	Y+1, r24	; 0x01
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    36c4:	89 81       	ldd	r24, Y+1	; 0x01
    36c6:	81 30       	cpi	r24, 0x01	; 1
    36c8:	81 f4       	brne	.+32     	; 0x36ea <vTaskStartScheduler+0x62>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    36ca:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    36cc:	8f ef       	ldi	r24, 0xFF	; 255
    36ce:	9f ef       	ldi	r25, 0xFF	; 255
    36d0:	90 93 b4 06 	sts	0x06B4, r25
    36d4:	80 93 b3 06 	sts	0x06B3, r24
        xSchedulerRunning = pdTRUE;
    36d8:	81 e0       	ldi	r24, 0x01	; 1
    36da:	80 93 ad 06 	sts	0x06AD, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    36de:	10 92 ab 06 	sts	0x06AB, r1
    36e2:	10 92 aa 06 	sts	0x06AA, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    36e6:	0e 94 4c 02 	call	0x498	; 0x498 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    36ea:	80 91 8a 00 	lds	r24, 0x008A
}
    36ee:	0f 90       	pop	r0
    36f0:	0f 90       	pop	r0
    36f2:	cf 91       	pop	r28
    36f4:	df 91       	pop	r29
    36f6:	0f 91       	pop	r16
    36f8:	ff 90       	pop	r15
    36fa:	ef 90       	pop	r14
    36fc:	08 95       	ret

000036fe <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    36fe:	df 93       	push	r29
    3700:	cf 93       	push	r28
    3702:	cd b7       	in	r28, 0x3d	; 61
    3704:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    3706:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    3708:	10 92 ad 06 	sts	0x06AD, r1
    vPortEndScheduler();
    370c:	0e 94 81 02 	call	0x502	; 0x502 <vPortEndScheduler>
}
    3710:	cf 91       	pop	r28
    3712:	df 91       	pop	r29
    3714:	08 95       	ret

00003716 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3716:	df 93       	push	r29
    3718:	cf 93       	push	r28
    371a:	cd b7       	in	r28, 0x3d	; 61
    371c:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    371e:	80 91 b7 06 	lds	r24, 0x06B7
    3722:	8f 5f       	subi	r24, 0xFF	; 255
    3724:	80 93 b7 06 	sts	0x06B7, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    3728:	cf 91       	pop	r28
    372a:	df 91       	pop	r29
    372c:	08 95       	ret

0000372e <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    372e:	df 93       	push	r29
    3730:	cf 93       	push	r28
    3732:	cd b7       	in	r28, 0x3d	; 61
    3734:	de b7       	in	r29, 0x3e	; 62
    3736:	2b 97       	sbiw	r28, 0x0b	; 11
    3738:	0f b6       	in	r0, 0x3f	; 63
    373a:	f8 94       	cli
    373c:	de bf       	out	0x3e, r29	; 62
    373e:	0f be       	out	0x3f, r0	; 63
    3740:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    3742:	1b 86       	std	Y+11, r1	; 0x0b
    3744:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    3746:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    3748:	0f b6       	in	r0, 0x3f	; 63
    374a:	f8 94       	cli
    374c:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    374e:	80 91 b7 06 	lds	r24, 0x06B7
    3752:	81 50       	subi	r24, 0x01	; 1
    3754:	80 93 b7 06 	sts	0x06B7, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3758:	80 91 b7 06 	lds	r24, 0x06B7
    375c:	88 23       	and	r24, r24
    375e:	09 f0       	breq	.+2      	; 0x3762 <xTaskResumeAll+0x34>
    3760:	2a c1       	rjmp	.+596    	; 0x39b6 <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3762:	80 91 a9 06 	lds	r24, 0x06A9
    3766:	88 23       	and	r24, r24
    3768:	09 f4       	brne	.+2      	; 0x376c <xTaskResumeAll+0x3e>
    376a:	25 c1       	rjmp	.+586    	; 0x39b6 <xTaskResumeAll+0x288>
    376c:	f3 c0       	rjmp	.+486    	; 0x3954 <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    376e:	e0 91 f7 06 	lds	r30, 0x06F7
    3772:	f0 91 f8 06 	lds	r31, 0x06F8
    3776:	86 81       	ldd	r24, Z+6	; 0x06
    3778:	97 81       	ldd	r25, Z+7	; 0x07
    377a:	9b 87       	std	Y+11, r25	; 0x0b
    377c:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    377e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3780:	fb 85       	ldd	r31, Y+11	; 0x0b
    3782:	84 89       	ldd	r24, Z+20	; 0x14
    3784:	95 89       	ldd	r25, Z+21	; 0x15
    3786:	98 87       	std	Y+8, r25	; 0x08
    3788:	8f 83       	std	Y+7, r24	; 0x07
    378a:	ea 85       	ldd	r30, Y+10	; 0x0a
    378c:	fb 85       	ldd	r31, Y+11	; 0x0b
    378e:	a6 85       	ldd	r26, Z+14	; 0x0e
    3790:	b7 85       	ldd	r27, Z+15	; 0x0f
    3792:	ea 85       	ldd	r30, Y+10	; 0x0a
    3794:	fb 85       	ldd	r31, Y+11	; 0x0b
    3796:	80 89       	ldd	r24, Z+16	; 0x10
    3798:	91 89       	ldd	r25, Z+17	; 0x11
    379a:	15 96       	adiw	r26, 0x05	; 5
    379c:	9c 93       	st	X, r25
    379e:	8e 93       	st	-X, r24
    37a0:	14 97       	sbiw	r26, 0x04	; 4
    37a2:	ea 85       	ldd	r30, Y+10	; 0x0a
    37a4:	fb 85       	ldd	r31, Y+11	; 0x0b
    37a6:	a0 89       	ldd	r26, Z+16	; 0x10
    37a8:	b1 89       	ldd	r27, Z+17	; 0x11
    37aa:	ea 85       	ldd	r30, Y+10	; 0x0a
    37ac:	fb 85       	ldd	r31, Y+11	; 0x0b
    37ae:	86 85       	ldd	r24, Z+14	; 0x0e
    37b0:	97 85       	ldd	r25, Z+15	; 0x0f
    37b2:	13 96       	adiw	r26, 0x03	; 3
    37b4:	9c 93       	st	X, r25
    37b6:	8e 93       	st	-X, r24
    37b8:	12 97       	sbiw	r26, 0x02	; 2
    37ba:	ef 81       	ldd	r30, Y+7	; 0x07
    37bc:	f8 85       	ldd	r31, Y+8	; 0x08
    37be:	21 81       	ldd	r18, Z+1	; 0x01
    37c0:	32 81       	ldd	r19, Z+2	; 0x02
    37c2:	8a 85       	ldd	r24, Y+10	; 0x0a
    37c4:	9b 85       	ldd	r25, Y+11	; 0x0b
    37c6:	0c 96       	adiw	r24, 0x0c	; 12
    37c8:	28 17       	cp	r18, r24
    37ca:	39 07       	cpc	r19, r25
    37cc:	41 f4       	brne	.+16     	; 0x37de <xTaskResumeAll+0xb0>
    37ce:	ea 85       	ldd	r30, Y+10	; 0x0a
    37d0:	fb 85       	ldd	r31, Y+11	; 0x0b
    37d2:	80 89       	ldd	r24, Z+16	; 0x10
    37d4:	91 89       	ldd	r25, Z+17	; 0x11
    37d6:	ef 81       	ldd	r30, Y+7	; 0x07
    37d8:	f8 85       	ldd	r31, Y+8	; 0x08
    37da:	92 83       	std	Z+2, r25	; 0x02
    37dc:	81 83       	std	Z+1, r24	; 0x01
    37de:	ea 85       	ldd	r30, Y+10	; 0x0a
    37e0:	fb 85       	ldd	r31, Y+11	; 0x0b
    37e2:	15 8a       	std	Z+21, r1	; 0x15
    37e4:	14 8a       	std	Z+20, r1	; 0x14
    37e6:	ef 81       	ldd	r30, Y+7	; 0x07
    37e8:	f8 85       	ldd	r31, Y+8	; 0x08
    37ea:	80 81       	ld	r24, Z
    37ec:	81 50       	subi	r24, 0x01	; 1
    37ee:	ef 81       	ldd	r30, Y+7	; 0x07
    37f0:	f8 85       	ldd	r31, Y+8	; 0x08
    37f2:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    37f4:	ea 85       	ldd	r30, Y+10	; 0x0a
    37f6:	fb 85       	ldd	r31, Y+11	; 0x0b
    37f8:	82 85       	ldd	r24, Z+10	; 0x0a
    37fa:	93 85       	ldd	r25, Z+11	; 0x0b
    37fc:	9e 83       	std	Y+6, r25	; 0x06
    37fe:	8d 83       	std	Y+5, r24	; 0x05
    3800:	ea 85       	ldd	r30, Y+10	; 0x0a
    3802:	fb 85       	ldd	r31, Y+11	; 0x0b
    3804:	a4 81       	ldd	r26, Z+4	; 0x04
    3806:	b5 81       	ldd	r27, Z+5	; 0x05
    3808:	ea 85       	ldd	r30, Y+10	; 0x0a
    380a:	fb 85       	ldd	r31, Y+11	; 0x0b
    380c:	86 81       	ldd	r24, Z+6	; 0x06
    380e:	97 81       	ldd	r25, Z+7	; 0x07
    3810:	15 96       	adiw	r26, 0x05	; 5
    3812:	9c 93       	st	X, r25
    3814:	8e 93       	st	-X, r24
    3816:	14 97       	sbiw	r26, 0x04	; 4
    3818:	ea 85       	ldd	r30, Y+10	; 0x0a
    381a:	fb 85       	ldd	r31, Y+11	; 0x0b
    381c:	a6 81       	ldd	r26, Z+6	; 0x06
    381e:	b7 81       	ldd	r27, Z+7	; 0x07
    3820:	ea 85       	ldd	r30, Y+10	; 0x0a
    3822:	fb 85       	ldd	r31, Y+11	; 0x0b
    3824:	84 81       	ldd	r24, Z+4	; 0x04
    3826:	95 81       	ldd	r25, Z+5	; 0x05
    3828:	13 96       	adiw	r26, 0x03	; 3
    382a:	9c 93       	st	X, r25
    382c:	8e 93       	st	-X, r24
    382e:	12 97       	sbiw	r26, 0x02	; 2
    3830:	ed 81       	ldd	r30, Y+5	; 0x05
    3832:	fe 81       	ldd	r31, Y+6	; 0x06
    3834:	21 81       	ldd	r18, Z+1	; 0x01
    3836:	32 81       	ldd	r19, Z+2	; 0x02
    3838:	8a 85       	ldd	r24, Y+10	; 0x0a
    383a:	9b 85       	ldd	r25, Y+11	; 0x0b
    383c:	02 96       	adiw	r24, 0x02	; 2
    383e:	28 17       	cp	r18, r24
    3840:	39 07       	cpc	r19, r25
    3842:	41 f4       	brne	.+16     	; 0x3854 <xTaskResumeAll+0x126>
    3844:	ea 85       	ldd	r30, Y+10	; 0x0a
    3846:	fb 85       	ldd	r31, Y+11	; 0x0b
    3848:	86 81       	ldd	r24, Z+6	; 0x06
    384a:	97 81       	ldd	r25, Z+7	; 0x07
    384c:	ed 81       	ldd	r30, Y+5	; 0x05
    384e:	fe 81       	ldd	r31, Y+6	; 0x06
    3850:	92 83       	std	Z+2, r25	; 0x02
    3852:	81 83       	std	Z+1, r24	; 0x01
    3854:	ea 85       	ldd	r30, Y+10	; 0x0a
    3856:	fb 85       	ldd	r31, Y+11	; 0x0b
    3858:	13 86       	std	Z+11, r1	; 0x0b
    385a:	12 86       	std	Z+10, r1	; 0x0a
    385c:	ed 81       	ldd	r30, Y+5	; 0x05
    385e:	fe 81       	ldd	r31, Y+6	; 0x06
    3860:	80 81       	ld	r24, Z
    3862:	81 50       	subi	r24, 0x01	; 1
    3864:	ed 81       	ldd	r30, Y+5	; 0x05
    3866:	fe 81       	ldd	r31, Y+6	; 0x06
    3868:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    386a:	ea 85       	ldd	r30, Y+10	; 0x0a
    386c:	fb 85       	ldd	r31, Y+11	; 0x0b
    386e:	96 89       	ldd	r25, Z+22	; 0x16
    3870:	80 91 ac 06 	lds	r24, 0x06AC
    3874:	89 17       	cp	r24, r25
    3876:	28 f4       	brcc	.+10     	; 0x3882 <xTaskResumeAll+0x154>
    3878:	ea 85       	ldd	r30, Y+10	; 0x0a
    387a:	fb 85       	ldd	r31, Y+11	; 0x0b
    387c:	86 89       	ldd	r24, Z+22	; 0x16
    387e:	80 93 ac 06 	sts	0x06AC, r24
    3882:	ea 85       	ldd	r30, Y+10	; 0x0a
    3884:	fb 85       	ldd	r31, Y+11	; 0x0b
    3886:	86 89       	ldd	r24, Z+22	; 0x16
    3888:	28 2f       	mov	r18, r24
    388a:	30 e0       	ldi	r19, 0x00	; 0
    388c:	c9 01       	movw	r24, r18
    388e:	88 0f       	add	r24, r24
    3890:	99 1f       	adc	r25, r25
    3892:	88 0f       	add	r24, r24
    3894:	99 1f       	adc	r25, r25
    3896:	88 0f       	add	r24, r24
    3898:	99 1f       	adc	r25, r25
    389a:	82 0f       	add	r24, r18
    389c:	93 1f       	adc	r25, r19
    389e:	fc 01       	movw	r30, r24
    38a0:	e8 54       	subi	r30, 0x48	; 72
    38a2:	f9 4f       	sbci	r31, 0xF9	; 249
    38a4:	81 81       	ldd	r24, Z+1	; 0x01
    38a6:	92 81       	ldd	r25, Z+2	; 0x02
    38a8:	9c 83       	std	Y+4, r25	; 0x04
    38aa:	8b 83       	std	Y+3, r24	; 0x03
    38ac:	ea 85       	ldd	r30, Y+10	; 0x0a
    38ae:	fb 85       	ldd	r31, Y+11	; 0x0b
    38b0:	8b 81       	ldd	r24, Y+3	; 0x03
    38b2:	9c 81       	ldd	r25, Y+4	; 0x04
    38b4:	95 83       	std	Z+5, r25	; 0x05
    38b6:	84 83       	std	Z+4, r24	; 0x04
    38b8:	eb 81       	ldd	r30, Y+3	; 0x03
    38ba:	fc 81       	ldd	r31, Y+4	; 0x04
    38bc:	84 81       	ldd	r24, Z+4	; 0x04
    38be:	95 81       	ldd	r25, Z+5	; 0x05
    38c0:	ea 85       	ldd	r30, Y+10	; 0x0a
    38c2:	fb 85       	ldd	r31, Y+11	; 0x0b
    38c4:	97 83       	std	Z+7, r25	; 0x07
    38c6:	86 83       	std	Z+6, r24	; 0x06
    38c8:	eb 81       	ldd	r30, Y+3	; 0x03
    38ca:	fc 81       	ldd	r31, Y+4	; 0x04
    38cc:	04 80       	ldd	r0, Z+4	; 0x04
    38ce:	f5 81       	ldd	r31, Z+5	; 0x05
    38d0:	e0 2d       	mov	r30, r0
    38d2:	8a 85       	ldd	r24, Y+10	; 0x0a
    38d4:	9b 85       	ldd	r25, Y+11	; 0x0b
    38d6:	02 96       	adiw	r24, 0x02	; 2
    38d8:	93 83       	std	Z+3, r25	; 0x03
    38da:	82 83       	std	Z+2, r24	; 0x02
    38dc:	8a 85       	ldd	r24, Y+10	; 0x0a
    38de:	9b 85       	ldd	r25, Y+11	; 0x0b
    38e0:	02 96       	adiw	r24, 0x02	; 2
    38e2:	eb 81       	ldd	r30, Y+3	; 0x03
    38e4:	fc 81       	ldd	r31, Y+4	; 0x04
    38e6:	95 83       	std	Z+5, r25	; 0x05
    38e8:	84 83       	std	Z+4, r24	; 0x04
    38ea:	ea 85       	ldd	r30, Y+10	; 0x0a
    38ec:	fb 85       	ldd	r31, Y+11	; 0x0b
    38ee:	86 89       	ldd	r24, Z+22	; 0x16
    38f0:	28 2f       	mov	r18, r24
    38f2:	30 e0       	ldi	r19, 0x00	; 0
    38f4:	c9 01       	movw	r24, r18
    38f6:	88 0f       	add	r24, r24
    38f8:	99 1f       	adc	r25, r25
    38fa:	88 0f       	add	r24, r24
    38fc:	99 1f       	adc	r25, r25
    38fe:	88 0f       	add	r24, r24
    3900:	99 1f       	adc	r25, r25
    3902:	82 0f       	add	r24, r18
    3904:	93 1f       	adc	r25, r19
    3906:	88 54       	subi	r24, 0x48	; 72
    3908:	99 4f       	sbci	r25, 0xF9	; 249
    390a:	ea 85       	ldd	r30, Y+10	; 0x0a
    390c:	fb 85       	ldd	r31, Y+11	; 0x0b
    390e:	93 87       	std	Z+11, r25	; 0x0b
    3910:	82 87       	std	Z+10, r24	; 0x0a
    3912:	ea 85       	ldd	r30, Y+10	; 0x0a
    3914:	fb 85       	ldd	r31, Y+11	; 0x0b
    3916:	86 89       	ldd	r24, Z+22	; 0x16
    3918:	28 2f       	mov	r18, r24
    391a:	30 e0       	ldi	r19, 0x00	; 0
    391c:	c9 01       	movw	r24, r18
    391e:	88 0f       	add	r24, r24
    3920:	99 1f       	adc	r25, r25
    3922:	88 0f       	add	r24, r24
    3924:	99 1f       	adc	r25, r25
    3926:	88 0f       	add	r24, r24
    3928:	99 1f       	adc	r25, r25
    392a:	82 0f       	add	r24, r18
    392c:	93 1f       	adc	r25, r19
    392e:	fc 01       	movw	r30, r24
    3930:	e8 54       	subi	r30, 0x48	; 72
    3932:	f9 4f       	sbci	r31, 0xF9	; 249
    3934:	80 81       	ld	r24, Z
    3936:	8f 5f       	subi	r24, 0xFF	; 255
    3938:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    393a:	ea 85       	ldd	r30, Y+10	; 0x0a
    393c:	fb 85       	ldd	r31, Y+11	; 0x0b
    393e:	96 89       	ldd	r25, Z+22	; 0x16
    3940:	e0 91 a6 06 	lds	r30, 0x06A6
    3944:	f0 91 a7 06 	lds	r31, 0x06A7
    3948:	86 89       	ldd	r24, Z+22	; 0x16
    394a:	98 17       	cp	r25, r24
    394c:	18 f0       	brcs	.+6      	; 0x3954 <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    394e:	81 e0       	ldi	r24, 0x01	; 1
    3950:	80 93 b0 06 	sts	0x06B0, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3954:	80 91 f2 06 	lds	r24, 0x06F2
    3958:	88 23       	and	r24, r24
    395a:	09 f0       	breq	.+2      	; 0x395e <xTaskResumeAll+0x230>
    395c:	08 cf       	rjmp	.-496    	; 0x376e <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    395e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3960:	9b 85       	ldd	r25, Y+11	; 0x0b
    3962:	00 97       	sbiw	r24, 0x00	; 0
    3964:	11 f0       	breq	.+4      	; 0x396a <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    3966:	0e 94 dd 23 	call	0x47ba	; 0x47ba <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    396a:	80 91 ae 06 	lds	r24, 0x06AE
    396e:	90 91 af 06 	lds	r25, 0x06AF
    3972:	9a 83       	std	Y+2, r25	; 0x02
    3974:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    3976:	89 81       	ldd	r24, Y+1	; 0x01
    3978:	9a 81       	ldd	r25, Y+2	; 0x02
    397a:	00 97       	sbiw	r24, 0x00	; 0
    397c:	a1 f0       	breq	.+40     	; 0x39a6 <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    397e:	0e 94 64 1d 	call	0x3ac8	; 0x3ac8 <xTaskIncrementTick>
    3982:	88 23       	and	r24, r24
    3984:	19 f0       	breq	.+6      	; 0x398c <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    3986:	81 e0       	ldi	r24, 0x01	; 1
    3988:	80 93 b0 06 	sts	0x06B0, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    398c:	89 81       	ldd	r24, Y+1	; 0x01
    398e:	9a 81       	ldd	r25, Y+2	; 0x02
    3990:	01 97       	sbiw	r24, 0x01	; 1
    3992:	9a 83       	std	Y+2, r25	; 0x02
    3994:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    3996:	89 81       	ldd	r24, Y+1	; 0x01
    3998:	9a 81       	ldd	r25, Y+2	; 0x02
    399a:	00 97       	sbiw	r24, 0x00	; 0
    399c:	81 f7       	brne	.-32     	; 0x397e <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    399e:	10 92 af 06 	sts	0x06AF, r1
    39a2:	10 92 ae 06 	sts	0x06AE, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    39a6:	80 91 b0 06 	lds	r24, 0x06B0
    39aa:	88 23       	and	r24, r24
    39ac:	21 f0       	breq	.+8      	; 0x39b6 <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    39ae:	81 e0       	ldi	r24, 0x01	; 1
    39b0:	89 87       	std	Y+9, r24	; 0x09
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    39b2:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    39b6:	0f 90       	pop	r0
    39b8:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    39ba:	89 85       	ldd	r24, Y+9	; 0x09
}
    39bc:	2b 96       	adiw	r28, 0x0b	; 11
    39be:	0f b6       	in	r0, 0x3f	; 63
    39c0:	f8 94       	cli
    39c2:	de bf       	out	0x3e, r29	; 62
    39c4:	0f be       	out	0x3f, r0	; 63
    39c6:	cd bf       	out	0x3d, r28	; 61
    39c8:	cf 91       	pop	r28
    39ca:	df 91       	pop	r29
    39cc:	08 95       	ret

000039ce <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    39ce:	df 93       	push	r29
    39d0:	cf 93       	push	r28
    39d2:	00 d0       	rcall	.+0      	; 0x39d4 <xTaskGetTickCount+0x6>
    39d4:	cd b7       	in	r28, 0x3d	; 61
    39d6:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    39d8:	0f b6       	in	r0, 0x3f	; 63
    39da:	f8 94       	cli
    39dc:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    39de:	80 91 aa 06 	lds	r24, 0x06AA
    39e2:	90 91 ab 06 	lds	r25, 0x06AB
    39e6:	9a 83       	std	Y+2, r25	; 0x02
    39e8:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    39ea:	0f 90       	pop	r0
    39ec:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    39ee:	89 81       	ldd	r24, Y+1	; 0x01
    39f0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    39f2:	0f 90       	pop	r0
    39f4:	0f 90       	pop	r0
    39f6:	cf 91       	pop	r28
    39f8:	df 91       	pop	r29
    39fa:	08 95       	ret

000039fc <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    39fc:	df 93       	push	r29
    39fe:	cf 93       	push	r28
    3a00:	00 d0       	rcall	.+0      	; 0x3a02 <xTaskGetTickCountFromISR+0x6>
    3a02:	0f 92       	push	r0
    3a04:	cd b7       	in	r28, 0x3d	; 61
    3a06:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    3a08:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    3a0a:	80 91 aa 06 	lds	r24, 0x06AA
    3a0e:	90 91 ab 06 	lds	r25, 0x06AB
    3a12:	9b 83       	std	Y+3, r25	; 0x03
    3a14:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3a16:	8a 81       	ldd	r24, Y+2	; 0x02
    3a18:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3a1a:	0f 90       	pop	r0
    3a1c:	0f 90       	pop	r0
    3a1e:	0f 90       	pop	r0
    3a20:	cf 91       	pop	r28
    3a22:	df 91       	pop	r29
    3a24:	08 95       	ret

00003a26 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3a26:	df 93       	push	r29
    3a28:	cf 93       	push	r28
    3a2a:	cd b7       	in	r28, 0x3d	; 61
    3a2c:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    3a2e:	80 91 a9 06 	lds	r24, 0x06A9
}
    3a32:	cf 91       	pop	r28
    3a34:	df 91       	pop	r29
    3a36:	08 95       	ret

00003a38 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3a38:	df 93       	push	r29
    3a3a:	cf 93       	push	r28
    3a3c:	00 d0       	rcall	.+0      	; 0x3a3e <pcTaskGetName+0x6>
    3a3e:	00 d0       	rcall	.+0      	; 0x3a40 <pcTaskGetName+0x8>
    3a40:	00 d0       	rcall	.+0      	; 0x3a42 <pcTaskGetName+0xa>
    3a42:	cd b7       	in	r28, 0x3d	; 61
    3a44:	de b7       	in	r29, 0x3e	; 62
    3a46:	9c 83       	std	Y+4, r25	; 0x04
    3a48:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    3a4a:	8b 81       	ldd	r24, Y+3	; 0x03
    3a4c:	9c 81       	ldd	r25, Y+4	; 0x04
    3a4e:	00 97       	sbiw	r24, 0x00	; 0
    3a50:	39 f4       	brne	.+14     	; 0x3a60 <pcTaskGetName+0x28>
    3a52:	80 91 a6 06 	lds	r24, 0x06A6
    3a56:	90 91 a7 06 	lds	r25, 0x06A7
    3a5a:	9e 83       	std	Y+6, r25	; 0x06
    3a5c:	8d 83       	std	Y+5, r24	; 0x05
    3a5e:	04 c0       	rjmp	.+8      	; 0x3a68 <pcTaskGetName+0x30>
    3a60:	8b 81       	ldd	r24, Y+3	; 0x03
    3a62:	9c 81       	ldd	r25, Y+4	; 0x04
    3a64:	9e 83       	std	Y+6, r25	; 0x06
    3a66:	8d 83       	std	Y+5, r24	; 0x05
    3a68:	8d 81       	ldd	r24, Y+5	; 0x05
    3a6a:	9e 81       	ldd	r25, Y+6	; 0x06
    3a6c:	9a 83       	std	Y+2, r25	; 0x02
    3a6e:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    3a70:	89 81       	ldd	r24, Y+1	; 0x01
    3a72:	9a 81       	ldd	r25, Y+2	; 0x02
    3a74:	49 96       	adiw	r24, 0x19	; 25
}
    3a76:	26 96       	adiw	r28, 0x06	; 6
    3a78:	0f b6       	in	r0, 0x3f	; 63
    3a7a:	f8 94       	cli
    3a7c:	de bf       	out	0x3e, r29	; 62
    3a7e:	0f be       	out	0x3f, r0	; 63
    3a80:	cd bf       	out	0x3d, r28	; 61
    3a82:	cf 91       	pop	r28
    3a84:	df 91       	pop	r29
    3a86:	08 95       	ret

00003a88 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    3a88:	df 93       	push	r29
    3a8a:	cf 93       	push	r28
    3a8c:	00 d0       	rcall	.+0      	; 0x3a8e <xTaskCatchUpTicks+0x6>
    3a8e:	0f 92       	push	r0
    3a90:	cd b7       	in	r28, 0x3d	; 61
    3a92:	de b7       	in	r29, 0x3e	; 62
    3a94:	9b 83       	std	Y+3, r25	; 0x03
    3a96:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    3a98:	0e 94 8b 1b 	call	0x3716	; 0x3716 <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
    3a9c:	20 91 ae 06 	lds	r18, 0x06AE
    3aa0:	30 91 af 06 	lds	r19, 0x06AF
    3aa4:	8a 81       	ldd	r24, Y+2	; 0x02
    3aa6:	9b 81       	ldd	r25, Y+3	; 0x03
    3aa8:	82 0f       	add	r24, r18
    3aaa:	93 1f       	adc	r25, r19
    3aac:	90 93 af 06 	sts	0x06AF, r25
    3ab0:	80 93 ae 06 	sts	0x06AE, r24
    xYieldOccurred = xTaskResumeAll();
    3ab4:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>
    3ab8:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    3aba:	89 81       	ldd	r24, Y+1	; 0x01
}
    3abc:	0f 90       	pop	r0
    3abe:	0f 90       	pop	r0
    3ac0:	0f 90       	pop	r0
    3ac2:	cf 91       	pop	r28
    3ac4:	df 91       	pop	r29
    3ac6:	08 95       	ret

00003ac8 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3ac8:	df 93       	push	r29
    3aca:	cf 93       	push	r28
    3acc:	cd b7       	in	r28, 0x3d	; 61
    3ace:	de b7       	in	r29, 0x3e	; 62
    3ad0:	2f 97       	sbiw	r28, 0x0f	; 15
    3ad2:	0f b6       	in	r0, 0x3f	; 63
    3ad4:	f8 94       	cli
    3ad6:	de bf       	out	0x3e, r29	; 62
    3ad8:	0f be       	out	0x3f, r0	; 63
    3ada:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    3adc:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3ade:	80 91 b7 06 	lds	r24, 0x06B7
    3ae2:	88 23       	and	r24, r24
    3ae4:	09 f0       	breq	.+2      	; 0x3ae8 <xTaskIncrementTick+0x20>
    3ae6:	74 c1       	rjmp	.+744    	; 0x3dd0 <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    3ae8:	80 91 aa 06 	lds	r24, 0x06AA
    3aec:	90 91 ab 06 	lds	r25, 0x06AB
    3af0:	01 96       	adiw	r24, 0x01	; 1
    3af2:	9a 87       	std	Y+10, r25	; 0x0a
    3af4:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    3af6:	89 85       	ldd	r24, Y+9	; 0x09
    3af8:	9a 85       	ldd	r25, Y+10	; 0x0a
    3afa:	90 93 ab 06 	sts	0x06AB, r25
    3afe:	80 93 aa 06 	sts	0x06AA, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    3b02:	89 85       	ldd	r24, Y+9	; 0x09
    3b04:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b06:	00 97       	sbiw	r24, 0x00	; 0
    3b08:	d9 f4       	brne	.+54     	; 0x3b40 <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    3b0a:	80 91 ee 06 	lds	r24, 0x06EE
    3b0e:	90 91 ef 06 	lds	r25, 0x06EF
    3b12:	98 87       	std	Y+8, r25	; 0x08
    3b14:	8f 83       	std	Y+7, r24	; 0x07
    3b16:	80 91 f0 06 	lds	r24, 0x06F0
    3b1a:	90 91 f1 06 	lds	r25, 0x06F1
    3b1e:	90 93 ef 06 	sts	0x06EF, r25
    3b22:	80 93 ee 06 	sts	0x06EE, r24
    3b26:	8f 81       	ldd	r24, Y+7	; 0x07
    3b28:	98 85       	ldd	r25, Y+8	; 0x08
    3b2a:	90 93 f1 06 	sts	0x06F1, r25
    3b2e:	80 93 f0 06 	sts	0x06F0, r24
    3b32:	80 91 b1 06 	lds	r24, 0x06B1
    3b36:	8f 5f       	subi	r24, 0xFF	; 255
    3b38:	80 93 b1 06 	sts	0x06B1, r24
    3b3c:	0e 94 dd 23 	call	0x47ba	; 0x47ba <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    3b40:	20 91 b3 06 	lds	r18, 0x06B3
    3b44:	30 91 b4 06 	lds	r19, 0x06B4
    3b48:	89 85       	ldd	r24, Y+9	; 0x09
    3b4a:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b4c:	82 17       	cp	r24, r18
    3b4e:	93 07       	cpc	r25, r19
    3b50:	08 f4       	brcc	.+2      	; 0x3b54 <xTaskIncrementTick+0x8c>
    3b52:	1f c1       	rjmp	.+574    	; 0x3d92 <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3b54:	e0 91 ee 06 	lds	r30, 0x06EE
    3b58:	f0 91 ef 06 	lds	r31, 0x06EF
    3b5c:	80 81       	ld	r24, Z
    3b5e:	88 23       	and	r24, r24
    3b60:	39 f4       	brne	.+14     	; 0x3b70 <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3b62:	8f ef       	ldi	r24, 0xFF	; 255
    3b64:	9f ef       	ldi	r25, 0xFF	; 255
    3b66:	90 93 b4 06 	sts	0x06B4, r25
    3b6a:	80 93 b3 06 	sts	0x06B3, r24
    3b6e:	11 c1       	rjmp	.+546    	; 0x3d92 <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3b70:	e0 91 ee 06 	lds	r30, 0x06EE
    3b74:	f0 91 ef 06 	lds	r31, 0x06EF
    3b78:	05 80       	ldd	r0, Z+5	; 0x05
    3b7a:	f6 81       	ldd	r31, Z+6	; 0x06
    3b7c:	e0 2d       	mov	r30, r0
    3b7e:	86 81       	ldd	r24, Z+6	; 0x06
    3b80:	97 81       	ldd	r25, Z+7	; 0x07
    3b82:	9f 87       	std	Y+15, r25	; 0x0f
    3b84:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    3b86:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b88:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b8a:	82 81       	ldd	r24, Z+2	; 0x02
    3b8c:	93 81       	ldd	r25, Z+3	; 0x03
    3b8e:	9d 87       	std	Y+13, r25	; 0x0d
    3b90:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    3b92:	29 85       	ldd	r18, Y+9	; 0x09
    3b94:	3a 85       	ldd	r19, Y+10	; 0x0a
    3b96:	8c 85       	ldd	r24, Y+12	; 0x0c
    3b98:	9d 85       	ldd	r25, Y+13	; 0x0d
    3b9a:	28 17       	cp	r18, r24
    3b9c:	39 07       	cpc	r19, r25
    3b9e:	38 f4       	brcc	.+14     	; 0x3bae <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    3ba0:	8c 85       	ldd	r24, Y+12	; 0x0c
    3ba2:	9d 85       	ldd	r25, Y+13	; 0x0d
    3ba4:	90 93 b4 06 	sts	0x06B4, r25
    3ba8:	80 93 b3 06 	sts	0x06B3, r24
    3bac:	f2 c0       	rjmp	.+484    	; 0x3d92 <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3bae:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bb0:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bb2:	82 85       	ldd	r24, Z+10	; 0x0a
    3bb4:	93 85       	ldd	r25, Z+11	; 0x0b
    3bb6:	9e 83       	std	Y+6, r25	; 0x06
    3bb8:	8d 83       	std	Y+5, r24	; 0x05
    3bba:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bbc:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bbe:	a4 81       	ldd	r26, Z+4	; 0x04
    3bc0:	b5 81       	ldd	r27, Z+5	; 0x05
    3bc2:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bc4:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bc6:	86 81       	ldd	r24, Z+6	; 0x06
    3bc8:	97 81       	ldd	r25, Z+7	; 0x07
    3bca:	15 96       	adiw	r26, 0x05	; 5
    3bcc:	9c 93       	st	X, r25
    3bce:	8e 93       	st	-X, r24
    3bd0:	14 97       	sbiw	r26, 0x04	; 4
    3bd2:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bd4:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bd6:	a6 81       	ldd	r26, Z+6	; 0x06
    3bd8:	b7 81       	ldd	r27, Z+7	; 0x07
    3bda:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bdc:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bde:	84 81       	ldd	r24, Z+4	; 0x04
    3be0:	95 81       	ldd	r25, Z+5	; 0x05
    3be2:	13 96       	adiw	r26, 0x03	; 3
    3be4:	9c 93       	st	X, r25
    3be6:	8e 93       	st	-X, r24
    3be8:	12 97       	sbiw	r26, 0x02	; 2
    3bea:	ed 81       	ldd	r30, Y+5	; 0x05
    3bec:	fe 81       	ldd	r31, Y+6	; 0x06
    3bee:	21 81       	ldd	r18, Z+1	; 0x01
    3bf0:	32 81       	ldd	r19, Z+2	; 0x02
    3bf2:	8e 85       	ldd	r24, Y+14	; 0x0e
    3bf4:	9f 85       	ldd	r25, Y+15	; 0x0f
    3bf6:	02 96       	adiw	r24, 0x02	; 2
    3bf8:	28 17       	cp	r18, r24
    3bfa:	39 07       	cpc	r19, r25
    3bfc:	41 f4       	brne	.+16     	; 0x3c0e <xTaskIncrementTick+0x146>
    3bfe:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c00:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c02:	86 81       	ldd	r24, Z+6	; 0x06
    3c04:	97 81       	ldd	r25, Z+7	; 0x07
    3c06:	ed 81       	ldd	r30, Y+5	; 0x05
    3c08:	fe 81       	ldd	r31, Y+6	; 0x06
    3c0a:	92 83       	std	Z+2, r25	; 0x02
    3c0c:	81 83       	std	Z+1, r24	; 0x01
    3c0e:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c10:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c12:	13 86       	std	Z+11, r1	; 0x0b
    3c14:	12 86       	std	Z+10, r1	; 0x0a
    3c16:	ed 81       	ldd	r30, Y+5	; 0x05
    3c18:	fe 81       	ldd	r31, Y+6	; 0x06
    3c1a:	80 81       	ld	r24, Z
    3c1c:	81 50       	subi	r24, 0x01	; 1
    3c1e:	ed 81       	ldd	r30, Y+5	; 0x05
    3c20:	fe 81       	ldd	r31, Y+6	; 0x06
    3c22:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3c24:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c26:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c28:	84 89       	ldd	r24, Z+20	; 0x14
    3c2a:	95 89       	ldd	r25, Z+21	; 0x15
    3c2c:	00 97       	sbiw	r24, 0x00	; 0
    3c2e:	d9 f1       	breq	.+118    	; 0x3ca6 <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3c30:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c32:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c34:	84 89       	ldd	r24, Z+20	; 0x14
    3c36:	95 89       	ldd	r25, Z+21	; 0x15
    3c38:	9c 83       	std	Y+4, r25	; 0x04
    3c3a:	8b 83       	std	Y+3, r24	; 0x03
    3c3c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c3e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c40:	a6 85       	ldd	r26, Z+14	; 0x0e
    3c42:	b7 85       	ldd	r27, Z+15	; 0x0f
    3c44:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c46:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c48:	80 89       	ldd	r24, Z+16	; 0x10
    3c4a:	91 89       	ldd	r25, Z+17	; 0x11
    3c4c:	15 96       	adiw	r26, 0x05	; 5
    3c4e:	9c 93       	st	X, r25
    3c50:	8e 93       	st	-X, r24
    3c52:	14 97       	sbiw	r26, 0x04	; 4
    3c54:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c56:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c58:	a0 89       	ldd	r26, Z+16	; 0x10
    3c5a:	b1 89       	ldd	r27, Z+17	; 0x11
    3c5c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c5e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c60:	86 85       	ldd	r24, Z+14	; 0x0e
    3c62:	97 85       	ldd	r25, Z+15	; 0x0f
    3c64:	13 96       	adiw	r26, 0x03	; 3
    3c66:	9c 93       	st	X, r25
    3c68:	8e 93       	st	-X, r24
    3c6a:	12 97       	sbiw	r26, 0x02	; 2
    3c6c:	eb 81       	ldd	r30, Y+3	; 0x03
    3c6e:	fc 81       	ldd	r31, Y+4	; 0x04
    3c70:	21 81       	ldd	r18, Z+1	; 0x01
    3c72:	32 81       	ldd	r19, Z+2	; 0x02
    3c74:	8e 85       	ldd	r24, Y+14	; 0x0e
    3c76:	9f 85       	ldd	r25, Y+15	; 0x0f
    3c78:	0c 96       	adiw	r24, 0x0c	; 12
    3c7a:	28 17       	cp	r18, r24
    3c7c:	39 07       	cpc	r19, r25
    3c7e:	41 f4       	brne	.+16     	; 0x3c90 <xTaskIncrementTick+0x1c8>
    3c80:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c82:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c84:	80 89       	ldd	r24, Z+16	; 0x10
    3c86:	91 89       	ldd	r25, Z+17	; 0x11
    3c88:	eb 81       	ldd	r30, Y+3	; 0x03
    3c8a:	fc 81       	ldd	r31, Y+4	; 0x04
    3c8c:	92 83       	std	Z+2, r25	; 0x02
    3c8e:	81 83       	std	Z+1, r24	; 0x01
    3c90:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c92:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c94:	15 8a       	std	Z+21, r1	; 0x15
    3c96:	14 8a       	std	Z+20, r1	; 0x14
    3c98:	eb 81       	ldd	r30, Y+3	; 0x03
    3c9a:	fc 81       	ldd	r31, Y+4	; 0x04
    3c9c:	80 81       	ld	r24, Z
    3c9e:	81 50       	subi	r24, 0x01	; 1
    3ca0:	eb 81       	ldd	r30, Y+3	; 0x03
    3ca2:	fc 81       	ldd	r31, Y+4	; 0x04
    3ca4:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    3ca6:	ee 85       	ldd	r30, Y+14	; 0x0e
    3ca8:	ff 85       	ldd	r31, Y+15	; 0x0f
    3caa:	96 89       	ldd	r25, Z+22	; 0x16
    3cac:	80 91 ac 06 	lds	r24, 0x06AC
    3cb0:	89 17       	cp	r24, r25
    3cb2:	28 f4       	brcc	.+10     	; 0x3cbe <xTaskIncrementTick+0x1f6>
    3cb4:	ee 85       	ldd	r30, Y+14	; 0x0e
    3cb6:	ff 85       	ldd	r31, Y+15	; 0x0f
    3cb8:	86 89       	ldd	r24, Z+22	; 0x16
    3cba:	80 93 ac 06 	sts	0x06AC, r24
    3cbe:	ee 85       	ldd	r30, Y+14	; 0x0e
    3cc0:	ff 85       	ldd	r31, Y+15	; 0x0f
    3cc2:	86 89       	ldd	r24, Z+22	; 0x16
    3cc4:	28 2f       	mov	r18, r24
    3cc6:	30 e0       	ldi	r19, 0x00	; 0
    3cc8:	c9 01       	movw	r24, r18
    3cca:	88 0f       	add	r24, r24
    3ccc:	99 1f       	adc	r25, r25
    3cce:	88 0f       	add	r24, r24
    3cd0:	99 1f       	adc	r25, r25
    3cd2:	88 0f       	add	r24, r24
    3cd4:	99 1f       	adc	r25, r25
    3cd6:	82 0f       	add	r24, r18
    3cd8:	93 1f       	adc	r25, r19
    3cda:	fc 01       	movw	r30, r24
    3cdc:	e8 54       	subi	r30, 0x48	; 72
    3cde:	f9 4f       	sbci	r31, 0xF9	; 249
    3ce0:	81 81       	ldd	r24, Z+1	; 0x01
    3ce2:	92 81       	ldd	r25, Z+2	; 0x02
    3ce4:	9a 83       	std	Y+2, r25	; 0x02
    3ce6:	89 83       	std	Y+1, r24	; 0x01
    3ce8:	ee 85       	ldd	r30, Y+14	; 0x0e
    3cea:	ff 85       	ldd	r31, Y+15	; 0x0f
    3cec:	89 81       	ldd	r24, Y+1	; 0x01
    3cee:	9a 81       	ldd	r25, Y+2	; 0x02
    3cf0:	95 83       	std	Z+5, r25	; 0x05
    3cf2:	84 83       	std	Z+4, r24	; 0x04
    3cf4:	e9 81       	ldd	r30, Y+1	; 0x01
    3cf6:	fa 81       	ldd	r31, Y+2	; 0x02
    3cf8:	84 81       	ldd	r24, Z+4	; 0x04
    3cfa:	95 81       	ldd	r25, Z+5	; 0x05
    3cfc:	ee 85       	ldd	r30, Y+14	; 0x0e
    3cfe:	ff 85       	ldd	r31, Y+15	; 0x0f
    3d00:	97 83       	std	Z+7, r25	; 0x07
    3d02:	86 83       	std	Z+6, r24	; 0x06
    3d04:	e9 81       	ldd	r30, Y+1	; 0x01
    3d06:	fa 81       	ldd	r31, Y+2	; 0x02
    3d08:	04 80       	ldd	r0, Z+4	; 0x04
    3d0a:	f5 81       	ldd	r31, Z+5	; 0x05
    3d0c:	e0 2d       	mov	r30, r0
    3d0e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3d10:	9f 85       	ldd	r25, Y+15	; 0x0f
    3d12:	02 96       	adiw	r24, 0x02	; 2
    3d14:	93 83       	std	Z+3, r25	; 0x03
    3d16:	82 83       	std	Z+2, r24	; 0x02
    3d18:	8e 85       	ldd	r24, Y+14	; 0x0e
    3d1a:	9f 85       	ldd	r25, Y+15	; 0x0f
    3d1c:	02 96       	adiw	r24, 0x02	; 2
    3d1e:	e9 81       	ldd	r30, Y+1	; 0x01
    3d20:	fa 81       	ldd	r31, Y+2	; 0x02
    3d22:	95 83       	std	Z+5, r25	; 0x05
    3d24:	84 83       	std	Z+4, r24	; 0x04
    3d26:	ee 85       	ldd	r30, Y+14	; 0x0e
    3d28:	ff 85       	ldd	r31, Y+15	; 0x0f
    3d2a:	86 89       	ldd	r24, Z+22	; 0x16
    3d2c:	28 2f       	mov	r18, r24
    3d2e:	30 e0       	ldi	r19, 0x00	; 0
    3d30:	c9 01       	movw	r24, r18
    3d32:	88 0f       	add	r24, r24
    3d34:	99 1f       	adc	r25, r25
    3d36:	88 0f       	add	r24, r24
    3d38:	99 1f       	adc	r25, r25
    3d3a:	88 0f       	add	r24, r24
    3d3c:	99 1f       	adc	r25, r25
    3d3e:	82 0f       	add	r24, r18
    3d40:	93 1f       	adc	r25, r19
    3d42:	88 54       	subi	r24, 0x48	; 72
    3d44:	99 4f       	sbci	r25, 0xF9	; 249
    3d46:	ee 85       	ldd	r30, Y+14	; 0x0e
    3d48:	ff 85       	ldd	r31, Y+15	; 0x0f
    3d4a:	93 87       	std	Z+11, r25	; 0x0b
    3d4c:	82 87       	std	Z+10, r24	; 0x0a
    3d4e:	ee 85       	ldd	r30, Y+14	; 0x0e
    3d50:	ff 85       	ldd	r31, Y+15	; 0x0f
    3d52:	86 89       	ldd	r24, Z+22	; 0x16
    3d54:	28 2f       	mov	r18, r24
    3d56:	30 e0       	ldi	r19, 0x00	; 0
    3d58:	c9 01       	movw	r24, r18
    3d5a:	88 0f       	add	r24, r24
    3d5c:	99 1f       	adc	r25, r25
    3d5e:	88 0f       	add	r24, r24
    3d60:	99 1f       	adc	r25, r25
    3d62:	88 0f       	add	r24, r24
    3d64:	99 1f       	adc	r25, r25
    3d66:	82 0f       	add	r24, r18
    3d68:	93 1f       	adc	r25, r19
    3d6a:	fc 01       	movw	r30, r24
    3d6c:	e8 54       	subi	r30, 0x48	; 72
    3d6e:	f9 4f       	sbci	r31, 0xF9	; 249
    3d70:	80 81       	ld	r24, Z
    3d72:	8f 5f       	subi	r24, 0xFF	; 255
    3d74:	80 83       	st	Z, r24
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3d76:	ee 85       	ldd	r30, Y+14	; 0x0e
    3d78:	ff 85       	ldd	r31, Y+15	; 0x0f
    3d7a:	96 89       	ldd	r25, Z+22	; 0x16
    3d7c:	e0 91 a6 06 	lds	r30, 0x06A6
    3d80:	f0 91 a7 06 	lds	r31, 0x06A7
    3d84:	86 89       	ldd	r24, Z+22	; 0x16
    3d86:	98 17       	cp	r25, r24
    3d88:	08 f4       	brcc	.+2      	; 0x3d8c <xTaskIncrementTick+0x2c4>
    3d8a:	e4 ce       	rjmp	.-568    	; 0x3b54 <xTaskIncrementTick+0x8c>
                            {
                                xSwitchRequired = pdTRUE;
    3d8c:	81 e0       	ldi	r24, 0x01	; 1
    3d8e:	8b 87       	std	Y+11, r24	; 0x0b
    3d90:	e1 ce       	rjmp	.-574    	; 0x3b54 <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3d92:	e0 91 a6 06 	lds	r30, 0x06A6
    3d96:	f0 91 a7 06 	lds	r31, 0x06A7
    3d9a:	86 89       	ldd	r24, Z+22	; 0x16
    3d9c:	28 2f       	mov	r18, r24
    3d9e:	30 e0       	ldi	r19, 0x00	; 0
    3da0:	c9 01       	movw	r24, r18
    3da2:	88 0f       	add	r24, r24
    3da4:	99 1f       	adc	r25, r25
    3da6:	88 0f       	add	r24, r24
    3da8:	99 1f       	adc	r25, r25
    3daa:	88 0f       	add	r24, r24
    3dac:	99 1f       	adc	r25, r25
    3dae:	82 0f       	add	r24, r18
    3db0:	93 1f       	adc	r25, r19
    3db2:	fc 01       	movw	r30, r24
    3db4:	e8 54       	subi	r30, 0x48	; 72
    3db6:	f9 4f       	sbci	r31, 0xF9	; 249
    3db8:	80 81       	ld	r24, Z
    3dba:	82 30       	cpi	r24, 0x02	; 2
    3dbc:	10 f0       	brcs	.+4      	; 0x3dc2 <xTaskIncrementTick+0x2fa>
                {
                    xSwitchRequired = pdTRUE;
    3dbe:	81 e0       	ldi	r24, 0x01	; 1
    3dc0:	8b 87       	std	Y+11, r24	; 0x0b
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    3dc2:	80 91 b0 06 	lds	r24, 0x06B0
    3dc6:	88 23       	and	r24, r24
    3dc8:	61 f0       	breq	.+24     	; 0x3de2 <xTaskIncrementTick+0x31a>
                {
                    xSwitchRequired = pdTRUE;
    3dca:	81 e0       	ldi	r24, 0x01	; 1
    3dcc:	8b 87       	std	Y+11, r24	; 0x0b
    3dce:	09 c0       	rjmp	.+18     	; 0x3de2 <xTaskIncrementTick+0x31a>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    3dd0:	80 91 ae 06 	lds	r24, 0x06AE
    3dd4:	90 91 af 06 	lds	r25, 0x06AF
    3dd8:	01 96       	adiw	r24, 0x01	; 1
    3dda:	90 93 af 06 	sts	0x06AF, r25
    3dde:	80 93 ae 06 	sts	0x06AE, r24
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
    3de2:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    3de4:	2f 96       	adiw	r28, 0x0f	; 15
    3de6:	0f b6       	in	r0, 0x3f	; 63
    3de8:	f8 94       	cli
    3dea:	de bf       	out	0x3e, r29	; 62
    3dec:	0f be       	out	0x3f, r0	; 63
    3dee:	cd bf       	out	0x3d, r28	; 61
    3df0:	cf 91       	pop	r28
    3df2:	df 91       	pop	r29
    3df4:	08 95       	ret

00003df6 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3df6:	df 93       	push	r29
    3df8:	cf 93       	push	r28
    3dfa:	00 d0       	rcall	.+0      	; 0x3dfc <vTaskSwitchContext+0x6>
    3dfc:	0f 92       	push	r0
    3dfe:	cd b7       	in	r28, 0x3d	; 61
    3e00:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3e02:	80 91 b7 06 	lds	r24, 0x06B7
    3e06:	88 23       	and	r24, r24
    3e08:	21 f0       	breq	.+8      	; 0x3e12 <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    3e0a:	81 e0       	ldi	r24, 0x01	; 1
    3e0c:	80 93 b0 06 	sts	0x06B0, r24
    3e10:	59 c0       	rjmp	.+178    	; 0x3ec4 <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    3e12:	10 92 b0 06 	sts	0x06B0, r1
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3e16:	80 91 ac 06 	lds	r24, 0x06AC
    3e1a:	8b 83       	std	Y+3, r24	; 0x03
    3e1c:	03 c0       	rjmp	.+6      	; 0x3e24 <vTaskSwitchContext+0x2e>
    3e1e:	8b 81       	ldd	r24, Y+3	; 0x03
    3e20:	81 50       	subi	r24, 0x01	; 1
    3e22:	8b 83       	std	Y+3, r24	; 0x03
    3e24:	8b 81       	ldd	r24, Y+3	; 0x03
    3e26:	28 2f       	mov	r18, r24
    3e28:	30 e0       	ldi	r19, 0x00	; 0
    3e2a:	c9 01       	movw	r24, r18
    3e2c:	88 0f       	add	r24, r24
    3e2e:	99 1f       	adc	r25, r25
    3e30:	88 0f       	add	r24, r24
    3e32:	99 1f       	adc	r25, r25
    3e34:	88 0f       	add	r24, r24
    3e36:	99 1f       	adc	r25, r25
    3e38:	82 0f       	add	r24, r18
    3e3a:	93 1f       	adc	r25, r19
    3e3c:	fc 01       	movw	r30, r24
    3e3e:	e8 54       	subi	r30, 0x48	; 72
    3e40:	f9 4f       	sbci	r31, 0xF9	; 249
    3e42:	80 81       	ld	r24, Z
    3e44:	88 23       	and	r24, r24
    3e46:	59 f3       	breq	.-42     	; 0x3e1e <vTaskSwitchContext+0x28>
    3e48:	8b 81       	ldd	r24, Y+3	; 0x03
    3e4a:	28 2f       	mov	r18, r24
    3e4c:	30 e0       	ldi	r19, 0x00	; 0
    3e4e:	c9 01       	movw	r24, r18
    3e50:	88 0f       	add	r24, r24
    3e52:	99 1f       	adc	r25, r25
    3e54:	88 0f       	add	r24, r24
    3e56:	99 1f       	adc	r25, r25
    3e58:	88 0f       	add	r24, r24
    3e5a:	99 1f       	adc	r25, r25
    3e5c:	82 0f       	add	r24, r18
    3e5e:	93 1f       	adc	r25, r19
    3e60:	88 54       	subi	r24, 0x48	; 72
    3e62:	99 4f       	sbci	r25, 0xF9	; 249
    3e64:	9a 83       	std	Y+2, r25	; 0x02
    3e66:	89 83       	std	Y+1, r24	; 0x01
    3e68:	e9 81       	ldd	r30, Y+1	; 0x01
    3e6a:	fa 81       	ldd	r31, Y+2	; 0x02
    3e6c:	01 80       	ldd	r0, Z+1	; 0x01
    3e6e:	f2 81       	ldd	r31, Z+2	; 0x02
    3e70:	e0 2d       	mov	r30, r0
    3e72:	82 81       	ldd	r24, Z+2	; 0x02
    3e74:	93 81       	ldd	r25, Z+3	; 0x03
    3e76:	e9 81       	ldd	r30, Y+1	; 0x01
    3e78:	fa 81       	ldd	r31, Y+2	; 0x02
    3e7a:	92 83       	std	Z+2, r25	; 0x02
    3e7c:	81 83       	std	Z+1, r24	; 0x01
    3e7e:	e9 81       	ldd	r30, Y+1	; 0x01
    3e80:	fa 81       	ldd	r31, Y+2	; 0x02
    3e82:	21 81       	ldd	r18, Z+1	; 0x01
    3e84:	32 81       	ldd	r19, Z+2	; 0x02
    3e86:	89 81       	ldd	r24, Y+1	; 0x01
    3e88:	9a 81       	ldd	r25, Y+2	; 0x02
    3e8a:	03 96       	adiw	r24, 0x03	; 3
    3e8c:	28 17       	cp	r18, r24
    3e8e:	39 07       	cpc	r19, r25
    3e90:	59 f4       	brne	.+22     	; 0x3ea8 <vTaskSwitchContext+0xb2>
    3e92:	e9 81       	ldd	r30, Y+1	; 0x01
    3e94:	fa 81       	ldd	r31, Y+2	; 0x02
    3e96:	01 80       	ldd	r0, Z+1	; 0x01
    3e98:	f2 81       	ldd	r31, Z+2	; 0x02
    3e9a:	e0 2d       	mov	r30, r0
    3e9c:	82 81       	ldd	r24, Z+2	; 0x02
    3e9e:	93 81       	ldd	r25, Z+3	; 0x03
    3ea0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ea2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ea4:	92 83       	std	Z+2, r25	; 0x02
    3ea6:	81 83       	std	Z+1, r24	; 0x01
    3ea8:	e9 81       	ldd	r30, Y+1	; 0x01
    3eaa:	fa 81       	ldd	r31, Y+2	; 0x02
    3eac:	01 80       	ldd	r0, Z+1	; 0x01
    3eae:	f2 81       	ldd	r31, Z+2	; 0x02
    3eb0:	e0 2d       	mov	r30, r0
    3eb2:	86 81       	ldd	r24, Z+6	; 0x06
    3eb4:	97 81       	ldd	r25, Z+7	; 0x07
    3eb6:	90 93 a7 06 	sts	0x06A7, r25
    3eba:	80 93 a6 06 	sts	0x06A6, r24
    3ebe:	8b 81       	ldd	r24, Y+3	; 0x03
    3ec0:	80 93 ac 06 	sts	0x06AC, r24
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    3ec4:	0f 90       	pop	r0
    3ec6:	0f 90       	pop	r0
    3ec8:	0f 90       	pop	r0
    3eca:	cf 91       	pop	r28
    3ecc:	df 91       	pop	r29
    3ece:	08 95       	ret

00003ed0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    3ed0:	df 93       	push	r29
    3ed2:	cf 93       	push	r28
    3ed4:	00 d0       	rcall	.+0      	; 0x3ed6 <vTaskPlaceOnEventList+0x6>
    3ed6:	00 d0       	rcall	.+0      	; 0x3ed8 <vTaskPlaceOnEventList+0x8>
    3ed8:	cd b7       	in	r28, 0x3d	; 61
    3eda:	de b7       	in	r29, 0x3e	; 62
    3edc:	9a 83       	std	Y+2, r25	; 0x02
    3ede:	89 83       	std	Y+1, r24	; 0x01
    3ee0:	7c 83       	std	Y+4, r23	; 0x04
    3ee2:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3ee4:	80 91 a6 06 	lds	r24, 0x06A6
    3ee8:	90 91 a7 06 	lds	r25, 0x06A7
    3eec:	9c 01       	movw	r18, r24
    3eee:	24 5f       	subi	r18, 0xF4	; 244
    3ef0:	3f 4f       	sbci	r19, 0xFF	; 255
    3ef2:	89 81       	ldd	r24, Y+1	; 0x01
    3ef4:	9a 81       	ldd	r25, Y+2	; 0x02
    3ef6:	b9 01       	movw	r22, r18
    3ef8:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3efc:	8b 81       	ldd	r24, Y+3	; 0x03
    3efe:	9c 81       	ldd	r25, Y+4	; 0x04
    3f00:	61 e0       	ldi	r22, 0x01	; 1
    3f02:	0e 94 c4 2b 	call	0x5788	; 0x5788 <prvAddCurrentTaskToDelayedList>
}
    3f06:	0f 90       	pop	r0
    3f08:	0f 90       	pop	r0
    3f0a:	0f 90       	pop	r0
    3f0c:	0f 90       	pop	r0
    3f0e:	cf 91       	pop	r28
    3f10:	df 91       	pop	r29
    3f12:	08 95       	ret

00003f14 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    3f14:	df 93       	push	r29
    3f16:	cf 93       	push	r28
    3f18:	cd b7       	in	r28, 0x3d	; 61
    3f1a:	de b7       	in	r29, 0x3e	; 62
    3f1c:	28 97       	sbiw	r28, 0x08	; 8
    3f1e:	0f b6       	in	r0, 0x3f	; 63
    3f20:	f8 94       	cli
    3f22:	de bf       	out	0x3e, r29	; 62
    3f24:	0f be       	out	0x3f, r0	; 63
    3f26:	cd bf       	out	0x3d, r28	; 61
    3f28:	9c 83       	std	Y+4, r25	; 0x04
    3f2a:	8b 83       	std	Y+3, r24	; 0x03
    3f2c:	7e 83       	std	Y+6, r23	; 0x06
    3f2e:	6d 83       	std	Y+5, r22	; 0x05
    3f30:	58 87       	std	Y+8, r21	; 0x08
    3f32:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3f34:	e0 91 a6 06 	lds	r30, 0x06A6
    3f38:	f0 91 a7 06 	lds	r31, 0x06A7
    3f3c:	8d 81       	ldd	r24, Y+5	; 0x05
    3f3e:	9e 81       	ldd	r25, Y+6	; 0x06
    3f40:	90 68       	ori	r25, 0x80	; 128
    3f42:	95 87       	std	Z+13, r25	; 0x0d
    3f44:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3f46:	eb 81       	ldd	r30, Y+3	; 0x03
    3f48:	fc 81       	ldd	r31, Y+4	; 0x04
    3f4a:	81 81       	ldd	r24, Z+1	; 0x01
    3f4c:	92 81       	ldd	r25, Z+2	; 0x02
    3f4e:	9a 83       	std	Y+2, r25	; 0x02
    3f50:	89 83       	std	Y+1, r24	; 0x01
    3f52:	e0 91 a6 06 	lds	r30, 0x06A6
    3f56:	f0 91 a7 06 	lds	r31, 0x06A7
    3f5a:	89 81       	ldd	r24, Y+1	; 0x01
    3f5c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f5e:	97 87       	std	Z+15, r25	; 0x0f
    3f60:	86 87       	std	Z+14, r24	; 0x0e
    3f62:	a0 91 a6 06 	lds	r26, 0x06A6
    3f66:	b0 91 a7 06 	lds	r27, 0x06A7
    3f6a:	e9 81       	ldd	r30, Y+1	; 0x01
    3f6c:	fa 81       	ldd	r31, Y+2	; 0x02
    3f6e:	84 81       	ldd	r24, Z+4	; 0x04
    3f70:	95 81       	ldd	r25, Z+5	; 0x05
    3f72:	51 96       	adiw	r26, 0x11	; 17
    3f74:	9c 93       	st	X, r25
    3f76:	8e 93       	st	-X, r24
    3f78:	50 97       	sbiw	r26, 0x10	; 16
    3f7a:	e9 81       	ldd	r30, Y+1	; 0x01
    3f7c:	fa 81       	ldd	r31, Y+2	; 0x02
    3f7e:	04 80       	ldd	r0, Z+4	; 0x04
    3f80:	f5 81       	ldd	r31, Z+5	; 0x05
    3f82:	e0 2d       	mov	r30, r0
    3f84:	80 91 a6 06 	lds	r24, 0x06A6
    3f88:	90 91 a7 06 	lds	r25, 0x06A7
    3f8c:	0c 96       	adiw	r24, 0x0c	; 12
    3f8e:	93 83       	std	Z+3, r25	; 0x03
    3f90:	82 83       	std	Z+2, r24	; 0x02
    3f92:	80 91 a6 06 	lds	r24, 0x06A6
    3f96:	90 91 a7 06 	lds	r25, 0x06A7
    3f9a:	0c 96       	adiw	r24, 0x0c	; 12
    3f9c:	e9 81       	ldd	r30, Y+1	; 0x01
    3f9e:	fa 81       	ldd	r31, Y+2	; 0x02
    3fa0:	95 83       	std	Z+5, r25	; 0x05
    3fa2:	84 83       	std	Z+4, r24	; 0x04
    3fa4:	e0 91 a6 06 	lds	r30, 0x06A6
    3fa8:	f0 91 a7 06 	lds	r31, 0x06A7
    3fac:	8b 81       	ldd	r24, Y+3	; 0x03
    3fae:	9c 81       	ldd	r25, Y+4	; 0x04
    3fb0:	95 8b       	std	Z+21, r25	; 0x15
    3fb2:	84 8b       	std	Z+20, r24	; 0x14
    3fb4:	eb 81       	ldd	r30, Y+3	; 0x03
    3fb6:	fc 81       	ldd	r31, Y+4	; 0x04
    3fb8:	80 81       	ld	r24, Z
    3fba:	8f 5f       	subi	r24, 0xFF	; 255
    3fbc:	eb 81       	ldd	r30, Y+3	; 0x03
    3fbe:	fc 81       	ldd	r31, Y+4	; 0x04
    3fc0:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3fc2:	8f 81       	ldd	r24, Y+7	; 0x07
    3fc4:	98 85       	ldd	r25, Y+8	; 0x08
    3fc6:	61 e0       	ldi	r22, 0x01	; 1
    3fc8:	0e 94 c4 2b 	call	0x5788	; 0x5788 <prvAddCurrentTaskToDelayedList>
}
    3fcc:	28 96       	adiw	r28, 0x08	; 8
    3fce:	0f b6       	in	r0, 0x3f	; 63
    3fd0:	f8 94       	cli
    3fd2:	de bf       	out	0x3e, r29	; 62
    3fd4:	0f be       	out	0x3f, r0	; 63
    3fd6:	cd bf       	out	0x3d, r28	; 61
    3fd8:	cf 91       	pop	r28
    3fda:	df 91       	pop	r29
    3fdc:	08 95       	ret

00003fde <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
    3fde:	df 93       	push	r29
    3fe0:	cf 93       	push	r28
    3fe2:	cd b7       	in	r28, 0x3d	; 61
    3fe4:	de b7       	in	r29, 0x3e	; 62
    3fe6:	27 97       	sbiw	r28, 0x07	; 7
    3fe8:	0f b6       	in	r0, 0x3f	; 63
    3fea:	f8 94       	cli
    3fec:	de bf       	out	0x3e, r29	; 62
    3fee:	0f be       	out	0x3f, r0	; 63
    3ff0:	cd bf       	out	0x3d, r28	; 61
    3ff2:	9c 83       	std	Y+4, r25	; 0x04
    3ff4:	8b 83       	std	Y+3, r24	; 0x03
    3ff6:	7e 83       	std	Y+6, r23	; 0x06
    3ff8:	6d 83       	std	Y+5, r22	; 0x05
    3ffa:	4f 83       	std	Y+7, r20	; 0x07

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3ffc:	eb 81       	ldd	r30, Y+3	; 0x03
    3ffe:	fc 81       	ldd	r31, Y+4	; 0x04
    4000:	81 81       	ldd	r24, Z+1	; 0x01
    4002:	92 81       	ldd	r25, Z+2	; 0x02
    4004:	9a 83       	std	Y+2, r25	; 0x02
    4006:	89 83       	std	Y+1, r24	; 0x01
    4008:	e0 91 a6 06 	lds	r30, 0x06A6
    400c:	f0 91 a7 06 	lds	r31, 0x06A7
    4010:	89 81       	ldd	r24, Y+1	; 0x01
    4012:	9a 81       	ldd	r25, Y+2	; 0x02
    4014:	97 87       	std	Z+15, r25	; 0x0f
    4016:	86 87       	std	Z+14, r24	; 0x0e
    4018:	a0 91 a6 06 	lds	r26, 0x06A6
    401c:	b0 91 a7 06 	lds	r27, 0x06A7
    4020:	e9 81       	ldd	r30, Y+1	; 0x01
    4022:	fa 81       	ldd	r31, Y+2	; 0x02
    4024:	84 81       	ldd	r24, Z+4	; 0x04
    4026:	95 81       	ldd	r25, Z+5	; 0x05
    4028:	51 96       	adiw	r26, 0x11	; 17
    402a:	9c 93       	st	X, r25
    402c:	8e 93       	st	-X, r24
    402e:	50 97       	sbiw	r26, 0x10	; 16
    4030:	e9 81       	ldd	r30, Y+1	; 0x01
    4032:	fa 81       	ldd	r31, Y+2	; 0x02
    4034:	04 80       	ldd	r0, Z+4	; 0x04
    4036:	f5 81       	ldd	r31, Z+5	; 0x05
    4038:	e0 2d       	mov	r30, r0
    403a:	80 91 a6 06 	lds	r24, 0x06A6
    403e:	90 91 a7 06 	lds	r25, 0x06A7
    4042:	0c 96       	adiw	r24, 0x0c	; 12
    4044:	93 83       	std	Z+3, r25	; 0x03
    4046:	82 83       	std	Z+2, r24	; 0x02
    4048:	80 91 a6 06 	lds	r24, 0x06A6
    404c:	90 91 a7 06 	lds	r25, 0x06A7
    4050:	0c 96       	adiw	r24, 0x0c	; 12
    4052:	e9 81       	ldd	r30, Y+1	; 0x01
    4054:	fa 81       	ldd	r31, Y+2	; 0x02
    4056:	95 83       	std	Z+5, r25	; 0x05
    4058:	84 83       	std	Z+4, r24	; 0x04
    405a:	e0 91 a6 06 	lds	r30, 0x06A6
    405e:	f0 91 a7 06 	lds	r31, 0x06A7
    4062:	8b 81       	ldd	r24, Y+3	; 0x03
    4064:	9c 81       	ldd	r25, Y+4	; 0x04
    4066:	95 8b       	std	Z+21, r25	; 0x15
    4068:	84 8b       	std	Z+20, r24	; 0x14
    406a:	eb 81       	ldd	r30, Y+3	; 0x03
    406c:	fc 81       	ldd	r31, Y+4	; 0x04
    406e:	80 81       	ld	r24, Z
    4070:	8f 5f       	subi	r24, 0xFF	; 255
    4072:	eb 81       	ldd	r30, Y+3	; 0x03
    4074:	fc 81       	ldd	r31, Y+4	; 0x04
    4076:	80 83       	st	Z, r24

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
    4078:	8f 81       	ldd	r24, Y+7	; 0x07
    407a:	88 23       	and	r24, r24
    407c:	21 f0       	breq	.+8      	; 0x4086 <vTaskPlaceOnEventListRestricted+0xa8>
        {
            xTicksToWait = portMAX_DELAY;
    407e:	8f ef       	ldi	r24, 0xFF	; 255
    4080:	9f ef       	ldi	r25, 0xFF	; 255
    4082:	9e 83       	std	Y+6, r25	; 0x06
    4084:	8d 83       	std	Y+5, r24	; 0x05
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    4086:	8d 81       	ldd	r24, Y+5	; 0x05
    4088:	9e 81       	ldd	r25, Y+6	; 0x06
    408a:	6f 81       	ldd	r22, Y+7	; 0x07
    408c:	0e 94 c4 2b 	call	0x5788	; 0x5788 <prvAddCurrentTaskToDelayedList>
    }
    4090:	27 96       	adiw	r28, 0x07	; 7
    4092:	0f b6       	in	r0, 0x3f	; 63
    4094:	f8 94       	cli
    4096:	de bf       	out	0x3e, r29	; 62
    4098:	0f be       	out	0x3f, r0	; 63
    409a:	cd bf       	out	0x3d, r28	; 61
    409c:	cf 91       	pop	r28
    409e:	df 91       	pop	r29
    40a0:	08 95       	ret

000040a2 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    40a2:	df 93       	push	r29
    40a4:	cf 93       	push	r28
    40a6:	cd b7       	in	r28, 0x3d	; 61
    40a8:	de b7       	in	r29, 0x3e	; 62
    40aa:	2d 97       	sbiw	r28, 0x0d	; 13
    40ac:	0f b6       	in	r0, 0x3f	; 63
    40ae:	f8 94       	cli
    40b0:	de bf       	out	0x3e, r29	; 62
    40b2:	0f be       	out	0x3f, r0	; 63
    40b4:	cd bf       	out	0x3d, r28	; 61
    40b6:	9d 87       	std	Y+13, r25	; 0x0d
    40b8:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    40ba:	ec 85       	ldd	r30, Y+12	; 0x0c
    40bc:	fd 85       	ldd	r31, Y+13	; 0x0d
    40be:	05 80       	ldd	r0, Z+5	; 0x05
    40c0:	f6 81       	ldd	r31, Z+6	; 0x06
    40c2:	e0 2d       	mov	r30, r0
    40c4:	86 81       	ldd	r24, Z+6	; 0x06
    40c6:	97 81       	ldd	r25, Z+7	; 0x07
    40c8:	9b 87       	std	Y+11, r25	; 0x0b
    40ca:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    40cc:	ea 85       	ldd	r30, Y+10	; 0x0a
    40ce:	fb 85       	ldd	r31, Y+11	; 0x0b
    40d0:	84 89       	ldd	r24, Z+20	; 0x14
    40d2:	95 89       	ldd	r25, Z+21	; 0x15
    40d4:	98 87       	std	Y+8, r25	; 0x08
    40d6:	8f 83       	std	Y+7, r24	; 0x07
    40d8:	ea 85       	ldd	r30, Y+10	; 0x0a
    40da:	fb 85       	ldd	r31, Y+11	; 0x0b
    40dc:	a6 85       	ldd	r26, Z+14	; 0x0e
    40de:	b7 85       	ldd	r27, Z+15	; 0x0f
    40e0:	ea 85       	ldd	r30, Y+10	; 0x0a
    40e2:	fb 85       	ldd	r31, Y+11	; 0x0b
    40e4:	80 89       	ldd	r24, Z+16	; 0x10
    40e6:	91 89       	ldd	r25, Z+17	; 0x11
    40e8:	15 96       	adiw	r26, 0x05	; 5
    40ea:	9c 93       	st	X, r25
    40ec:	8e 93       	st	-X, r24
    40ee:	14 97       	sbiw	r26, 0x04	; 4
    40f0:	ea 85       	ldd	r30, Y+10	; 0x0a
    40f2:	fb 85       	ldd	r31, Y+11	; 0x0b
    40f4:	a0 89       	ldd	r26, Z+16	; 0x10
    40f6:	b1 89       	ldd	r27, Z+17	; 0x11
    40f8:	ea 85       	ldd	r30, Y+10	; 0x0a
    40fa:	fb 85       	ldd	r31, Y+11	; 0x0b
    40fc:	86 85       	ldd	r24, Z+14	; 0x0e
    40fe:	97 85       	ldd	r25, Z+15	; 0x0f
    4100:	13 96       	adiw	r26, 0x03	; 3
    4102:	9c 93       	st	X, r25
    4104:	8e 93       	st	-X, r24
    4106:	12 97       	sbiw	r26, 0x02	; 2
    4108:	ef 81       	ldd	r30, Y+7	; 0x07
    410a:	f8 85       	ldd	r31, Y+8	; 0x08
    410c:	21 81       	ldd	r18, Z+1	; 0x01
    410e:	32 81       	ldd	r19, Z+2	; 0x02
    4110:	8a 85       	ldd	r24, Y+10	; 0x0a
    4112:	9b 85       	ldd	r25, Y+11	; 0x0b
    4114:	0c 96       	adiw	r24, 0x0c	; 12
    4116:	28 17       	cp	r18, r24
    4118:	39 07       	cpc	r19, r25
    411a:	41 f4       	brne	.+16     	; 0x412c <xTaskRemoveFromEventList+0x8a>
    411c:	ea 85       	ldd	r30, Y+10	; 0x0a
    411e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4120:	80 89       	ldd	r24, Z+16	; 0x10
    4122:	91 89       	ldd	r25, Z+17	; 0x11
    4124:	ef 81       	ldd	r30, Y+7	; 0x07
    4126:	f8 85       	ldd	r31, Y+8	; 0x08
    4128:	92 83       	std	Z+2, r25	; 0x02
    412a:	81 83       	std	Z+1, r24	; 0x01
    412c:	ea 85       	ldd	r30, Y+10	; 0x0a
    412e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4130:	15 8a       	std	Z+21, r1	; 0x15
    4132:	14 8a       	std	Z+20, r1	; 0x14
    4134:	ef 81       	ldd	r30, Y+7	; 0x07
    4136:	f8 85       	ldd	r31, Y+8	; 0x08
    4138:	80 81       	ld	r24, Z
    413a:	81 50       	subi	r24, 0x01	; 1
    413c:	ef 81       	ldd	r30, Y+7	; 0x07
    413e:	f8 85       	ldd	r31, Y+8	; 0x08
    4140:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4142:	80 91 b7 06 	lds	r24, 0x06B7
    4146:	88 23       	and	r24, r24
    4148:	09 f0       	breq	.+2      	; 0x414c <xTaskRemoveFromEventList+0xaa>
    414a:	a4 c0       	rjmp	.+328    	; 0x4294 <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    414c:	ea 85       	ldd	r30, Y+10	; 0x0a
    414e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4150:	82 85       	ldd	r24, Z+10	; 0x0a
    4152:	93 85       	ldd	r25, Z+11	; 0x0b
    4154:	9e 83       	std	Y+6, r25	; 0x06
    4156:	8d 83       	std	Y+5, r24	; 0x05
    4158:	ea 85       	ldd	r30, Y+10	; 0x0a
    415a:	fb 85       	ldd	r31, Y+11	; 0x0b
    415c:	a4 81       	ldd	r26, Z+4	; 0x04
    415e:	b5 81       	ldd	r27, Z+5	; 0x05
    4160:	ea 85       	ldd	r30, Y+10	; 0x0a
    4162:	fb 85       	ldd	r31, Y+11	; 0x0b
    4164:	86 81       	ldd	r24, Z+6	; 0x06
    4166:	97 81       	ldd	r25, Z+7	; 0x07
    4168:	15 96       	adiw	r26, 0x05	; 5
    416a:	9c 93       	st	X, r25
    416c:	8e 93       	st	-X, r24
    416e:	14 97       	sbiw	r26, 0x04	; 4
    4170:	ea 85       	ldd	r30, Y+10	; 0x0a
    4172:	fb 85       	ldd	r31, Y+11	; 0x0b
    4174:	a6 81       	ldd	r26, Z+6	; 0x06
    4176:	b7 81       	ldd	r27, Z+7	; 0x07
    4178:	ea 85       	ldd	r30, Y+10	; 0x0a
    417a:	fb 85       	ldd	r31, Y+11	; 0x0b
    417c:	84 81       	ldd	r24, Z+4	; 0x04
    417e:	95 81       	ldd	r25, Z+5	; 0x05
    4180:	13 96       	adiw	r26, 0x03	; 3
    4182:	9c 93       	st	X, r25
    4184:	8e 93       	st	-X, r24
    4186:	12 97       	sbiw	r26, 0x02	; 2
    4188:	ed 81       	ldd	r30, Y+5	; 0x05
    418a:	fe 81       	ldd	r31, Y+6	; 0x06
    418c:	21 81       	ldd	r18, Z+1	; 0x01
    418e:	32 81       	ldd	r19, Z+2	; 0x02
    4190:	8a 85       	ldd	r24, Y+10	; 0x0a
    4192:	9b 85       	ldd	r25, Y+11	; 0x0b
    4194:	02 96       	adiw	r24, 0x02	; 2
    4196:	28 17       	cp	r18, r24
    4198:	39 07       	cpc	r19, r25
    419a:	41 f4       	brne	.+16     	; 0x41ac <xTaskRemoveFromEventList+0x10a>
    419c:	ea 85       	ldd	r30, Y+10	; 0x0a
    419e:	fb 85       	ldd	r31, Y+11	; 0x0b
    41a0:	86 81       	ldd	r24, Z+6	; 0x06
    41a2:	97 81       	ldd	r25, Z+7	; 0x07
    41a4:	ed 81       	ldd	r30, Y+5	; 0x05
    41a6:	fe 81       	ldd	r31, Y+6	; 0x06
    41a8:	92 83       	std	Z+2, r25	; 0x02
    41aa:	81 83       	std	Z+1, r24	; 0x01
    41ac:	ea 85       	ldd	r30, Y+10	; 0x0a
    41ae:	fb 85       	ldd	r31, Y+11	; 0x0b
    41b0:	13 86       	std	Z+11, r1	; 0x0b
    41b2:	12 86       	std	Z+10, r1	; 0x0a
    41b4:	ed 81       	ldd	r30, Y+5	; 0x05
    41b6:	fe 81       	ldd	r31, Y+6	; 0x06
    41b8:	80 81       	ld	r24, Z
    41ba:	81 50       	subi	r24, 0x01	; 1
    41bc:	ed 81       	ldd	r30, Y+5	; 0x05
    41be:	fe 81       	ldd	r31, Y+6	; 0x06
    41c0:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    41c2:	ea 85       	ldd	r30, Y+10	; 0x0a
    41c4:	fb 85       	ldd	r31, Y+11	; 0x0b
    41c6:	96 89       	ldd	r25, Z+22	; 0x16
    41c8:	80 91 ac 06 	lds	r24, 0x06AC
    41cc:	89 17       	cp	r24, r25
    41ce:	28 f4       	brcc	.+10     	; 0x41da <xTaskRemoveFromEventList+0x138>
    41d0:	ea 85       	ldd	r30, Y+10	; 0x0a
    41d2:	fb 85       	ldd	r31, Y+11	; 0x0b
    41d4:	86 89       	ldd	r24, Z+22	; 0x16
    41d6:	80 93 ac 06 	sts	0x06AC, r24
    41da:	ea 85       	ldd	r30, Y+10	; 0x0a
    41dc:	fb 85       	ldd	r31, Y+11	; 0x0b
    41de:	86 89       	ldd	r24, Z+22	; 0x16
    41e0:	28 2f       	mov	r18, r24
    41e2:	30 e0       	ldi	r19, 0x00	; 0
    41e4:	c9 01       	movw	r24, r18
    41e6:	88 0f       	add	r24, r24
    41e8:	99 1f       	adc	r25, r25
    41ea:	88 0f       	add	r24, r24
    41ec:	99 1f       	adc	r25, r25
    41ee:	88 0f       	add	r24, r24
    41f0:	99 1f       	adc	r25, r25
    41f2:	82 0f       	add	r24, r18
    41f4:	93 1f       	adc	r25, r19
    41f6:	fc 01       	movw	r30, r24
    41f8:	e8 54       	subi	r30, 0x48	; 72
    41fa:	f9 4f       	sbci	r31, 0xF9	; 249
    41fc:	81 81       	ldd	r24, Z+1	; 0x01
    41fe:	92 81       	ldd	r25, Z+2	; 0x02
    4200:	9c 83       	std	Y+4, r25	; 0x04
    4202:	8b 83       	std	Y+3, r24	; 0x03
    4204:	ea 85       	ldd	r30, Y+10	; 0x0a
    4206:	fb 85       	ldd	r31, Y+11	; 0x0b
    4208:	8b 81       	ldd	r24, Y+3	; 0x03
    420a:	9c 81       	ldd	r25, Y+4	; 0x04
    420c:	95 83       	std	Z+5, r25	; 0x05
    420e:	84 83       	std	Z+4, r24	; 0x04
    4210:	eb 81       	ldd	r30, Y+3	; 0x03
    4212:	fc 81       	ldd	r31, Y+4	; 0x04
    4214:	84 81       	ldd	r24, Z+4	; 0x04
    4216:	95 81       	ldd	r25, Z+5	; 0x05
    4218:	ea 85       	ldd	r30, Y+10	; 0x0a
    421a:	fb 85       	ldd	r31, Y+11	; 0x0b
    421c:	97 83       	std	Z+7, r25	; 0x07
    421e:	86 83       	std	Z+6, r24	; 0x06
    4220:	eb 81       	ldd	r30, Y+3	; 0x03
    4222:	fc 81       	ldd	r31, Y+4	; 0x04
    4224:	04 80       	ldd	r0, Z+4	; 0x04
    4226:	f5 81       	ldd	r31, Z+5	; 0x05
    4228:	e0 2d       	mov	r30, r0
    422a:	8a 85       	ldd	r24, Y+10	; 0x0a
    422c:	9b 85       	ldd	r25, Y+11	; 0x0b
    422e:	02 96       	adiw	r24, 0x02	; 2
    4230:	93 83       	std	Z+3, r25	; 0x03
    4232:	82 83       	std	Z+2, r24	; 0x02
    4234:	8a 85       	ldd	r24, Y+10	; 0x0a
    4236:	9b 85       	ldd	r25, Y+11	; 0x0b
    4238:	02 96       	adiw	r24, 0x02	; 2
    423a:	eb 81       	ldd	r30, Y+3	; 0x03
    423c:	fc 81       	ldd	r31, Y+4	; 0x04
    423e:	95 83       	std	Z+5, r25	; 0x05
    4240:	84 83       	std	Z+4, r24	; 0x04
    4242:	ea 85       	ldd	r30, Y+10	; 0x0a
    4244:	fb 85       	ldd	r31, Y+11	; 0x0b
    4246:	86 89       	ldd	r24, Z+22	; 0x16
    4248:	28 2f       	mov	r18, r24
    424a:	30 e0       	ldi	r19, 0x00	; 0
    424c:	c9 01       	movw	r24, r18
    424e:	88 0f       	add	r24, r24
    4250:	99 1f       	adc	r25, r25
    4252:	88 0f       	add	r24, r24
    4254:	99 1f       	adc	r25, r25
    4256:	88 0f       	add	r24, r24
    4258:	99 1f       	adc	r25, r25
    425a:	82 0f       	add	r24, r18
    425c:	93 1f       	adc	r25, r19
    425e:	88 54       	subi	r24, 0x48	; 72
    4260:	99 4f       	sbci	r25, 0xF9	; 249
    4262:	ea 85       	ldd	r30, Y+10	; 0x0a
    4264:	fb 85       	ldd	r31, Y+11	; 0x0b
    4266:	93 87       	std	Z+11, r25	; 0x0b
    4268:	82 87       	std	Z+10, r24	; 0x0a
    426a:	ea 85       	ldd	r30, Y+10	; 0x0a
    426c:	fb 85       	ldd	r31, Y+11	; 0x0b
    426e:	86 89       	ldd	r24, Z+22	; 0x16
    4270:	28 2f       	mov	r18, r24
    4272:	30 e0       	ldi	r19, 0x00	; 0
    4274:	c9 01       	movw	r24, r18
    4276:	88 0f       	add	r24, r24
    4278:	99 1f       	adc	r25, r25
    427a:	88 0f       	add	r24, r24
    427c:	99 1f       	adc	r25, r25
    427e:	88 0f       	add	r24, r24
    4280:	99 1f       	adc	r25, r25
    4282:	82 0f       	add	r24, r18
    4284:	93 1f       	adc	r25, r19
    4286:	fc 01       	movw	r30, r24
    4288:	e8 54       	subi	r30, 0x48	; 72
    428a:	f9 4f       	sbci	r31, 0xF9	; 249
    428c:	80 81       	ld	r24, Z
    428e:	8f 5f       	subi	r24, 0xFF	; 255
    4290:	80 83       	st	Z, r24
    4292:	30 c0       	rjmp	.+96     	; 0x42f4 <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4294:	80 91 f3 06 	lds	r24, 0x06F3
    4298:	90 91 f4 06 	lds	r25, 0x06F4
    429c:	9a 83       	std	Y+2, r25	; 0x02
    429e:	89 83       	std	Y+1, r24	; 0x01
    42a0:	ea 85       	ldd	r30, Y+10	; 0x0a
    42a2:	fb 85       	ldd	r31, Y+11	; 0x0b
    42a4:	89 81       	ldd	r24, Y+1	; 0x01
    42a6:	9a 81       	ldd	r25, Y+2	; 0x02
    42a8:	97 87       	std	Z+15, r25	; 0x0f
    42aa:	86 87       	std	Z+14, r24	; 0x0e
    42ac:	e9 81       	ldd	r30, Y+1	; 0x01
    42ae:	fa 81       	ldd	r31, Y+2	; 0x02
    42b0:	84 81       	ldd	r24, Z+4	; 0x04
    42b2:	95 81       	ldd	r25, Z+5	; 0x05
    42b4:	ea 85       	ldd	r30, Y+10	; 0x0a
    42b6:	fb 85       	ldd	r31, Y+11	; 0x0b
    42b8:	91 8b       	std	Z+17, r25	; 0x11
    42ba:	80 8b       	std	Z+16, r24	; 0x10
    42bc:	e9 81       	ldd	r30, Y+1	; 0x01
    42be:	fa 81       	ldd	r31, Y+2	; 0x02
    42c0:	04 80       	ldd	r0, Z+4	; 0x04
    42c2:	f5 81       	ldd	r31, Z+5	; 0x05
    42c4:	e0 2d       	mov	r30, r0
    42c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    42c8:	9b 85       	ldd	r25, Y+11	; 0x0b
    42ca:	0c 96       	adiw	r24, 0x0c	; 12
    42cc:	93 83       	std	Z+3, r25	; 0x03
    42ce:	82 83       	std	Z+2, r24	; 0x02
    42d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    42d2:	9b 85       	ldd	r25, Y+11	; 0x0b
    42d4:	0c 96       	adiw	r24, 0x0c	; 12
    42d6:	e9 81       	ldd	r30, Y+1	; 0x01
    42d8:	fa 81       	ldd	r31, Y+2	; 0x02
    42da:	95 83       	std	Z+5, r25	; 0x05
    42dc:	84 83       	std	Z+4, r24	; 0x04
    42de:	ea 85       	ldd	r30, Y+10	; 0x0a
    42e0:	fb 85       	ldd	r31, Y+11	; 0x0b
    42e2:	82 ef       	ldi	r24, 0xF2	; 242
    42e4:	96 e0       	ldi	r25, 0x06	; 6
    42e6:	95 8b       	std	Z+21, r25	; 0x15
    42e8:	84 8b       	std	Z+20, r24	; 0x14
    42ea:	80 91 f2 06 	lds	r24, 0x06F2
    42ee:	8f 5f       	subi	r24, 0xFF	; 255
    42f0:	80 93 f2 06 	sts	0x06F2, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    42f4:	ea 85       	ldd	r30, Y+10	; 0x0a
    42f6:	fb 85       	ldd	r31, Y+11	; 0x0b
    42f8:	96 89       	ldd	r25, Z+22	; 0x16
    42fa:	e0 91 a6 06 	lds	r30, 0x06A6
    42fe:	f0 91 a7 06 	lds	r31, 0x06A7
    4302:	86 89       	ldd	r24, Z+22	; 0x16
    4304:	89 17       	cp	r24, r25
    4306:	30 f4       	brcc	.+12     	; 0x4314 <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    4308:	81 e0       	ldi	r24, 0x01	; 1
    430a:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    430c:	81 e0       	ldi	r24, 0x01	; 1
    430e:	80 93 b0 06 	sts	0x06B0, r24
    4312:	01 c0       	rjmp	.+2      	; 0x4316 <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    4314:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    4316:	89 85       	ldd	r24, Y+9	; 0x09
}
    4318:	2d 96       	adiw	r28, 0x0d	; 13
    431a:	0f b6       	in	r0, 0x3f	; 63
    431c:	f8 94       	cli
    431e:	de bf       	out	0x3e, r29	; 62
    4320:	0f be       	out	0x3f, r0	; 63
    4322:	cd bf       	out	0x3d, r28	; 61
    4324:	cf 91       	pop	r28
    4326:	df 91       	pop	r29
    4328:	08 95       	ret

0000432a <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    432a:	df 93       	push	r29
    432c:	cf 93       	push	r28
    432e:	cd b7       	in	r28, 0x3d	; 61
    4330:	de b7       	in	r29, 0x3e	; 62
    4332:	2c 97       	sbiw	r28, 0x0c	; 12
    4334:	0f b6       	in	r0, 0x3f	; 63
    4336:	f8 94       	cli
    4338:	de bf       	out	0x3e, r29	; 62
    433a:	0f be       	out	0x3f, r0	; 63
    433c:	cd bf       	out	0x3d, r28	; 61
    433e:	9a 87       	std	Y+10, r25	; 0x0a
    4340:	89 87       	std	Y+9, r24	; 0x09
    4342:	7c 87       	std	Y+12, r23	; 0x0c
    4344:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4346:	8b 85       	ldd	r24, Y+11	; 0x0b
    4348:	9c 85       	ldd	r25, Y+12	; 0x0c
    434a:	90 68       	ori	r25, 0x80	; 128
    434c:	e9 85       	ldd	r30, Y+9	; 0x09
    434e:	fa 85       	ldd	r31, Y+10	; 0x0a
    4350:	91 83       	std	Z+1, r25	; 0x01
    4352:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4354:	e9 85       	ldd	r30, Y+9	; 0x09
    4356:	fa 85       	ldd	r31, Y+10	; 0x0a
    4358:	86 81       	ldd	r24, Z+6	; 0x06
    435a:	97 81       	ldd	r25, Z+7	; 0x07
    435c:	98 87       	std	Y+8, r25	; 0x08
    435e:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    4360:	e9 85       	ldd	r30, Y+9	; 0x09
    4362:	fa 85       	ldd	r31, Y+10	; 0x0a
    4364:	80 85       	ldd	r24, Z+8	; 0x08
    4366:	91 85       	ldd	r25, Z+9	; 0x09
    4368:	9e 83       	std	Y+6, r25	; 0x06
    436a:	8d 83       	std	Y+5, r24	; 0x05
    436c:	e9 85       	ldd	r30, Y+9	; 0x09
    436e:	fa 85       	ldd	r31, Y+10	; 0x0a
    4370:	a2 81       	ldd	r26, Z+2	; 0x02
    4372:	b3 81       	ldd	r27, Z+3	; 0x03
    4374:	e9 85       	ldd	r30, Y+9	; 0x09
    4376:	fa 85       	ldd	r31, Y+10	; 0x0a
    4378:	84 81       	ldd	r24, Z+4	; 0x04
    437a:	95 81       	ldd	r25, Z+5	; 0x05
    437c:	15 96       	adiw	r26, 0x05	; 5
    437e:	9c 93       	st	X, r25
    4380:	8e 93       	st	-X, r24
    4382:	14 97       	sbiw	r26, 0x04	; 4
    4384:	e9 85       	ldd	r30, Y+9	; 0x09
    4386:	fa 85       	ldd	r31, Y+10	; 0x0a
    4388:	a4 81       	ldd	r26, Z+4	; 0x04
    438a:	b5 81       	ldd	r27, Z+5	; 0x05
    438c:	e9 85       	ldd	r30, Y+9	; 0x09
    438e:	fa 85       	ldd	r31, Y+10	; 0x0a
    4390:	82 81       	ldd	r24, Z+2	; 0x02
    4392:	93 81       	ldd	r25, Z+3	; 0x03
    4394:	13 96       	adiw	r26, 0x03	; 3
    4396:	9c 93       	st	X, r25
    4398:	8e 93       	st	-X, r24
    439a:	12 97       	sbiw	r26, 0x02	; 2
    439c:	ed 81       	ldd	r30, Y+5	; 0x05
    439e:	fe 81       	ldd	r31, Y+6	; 0x06
    43a0:	21 81       	ldd	r18, Z+1	; 0x01
    43a2:	32 81       	ldd	r19, Z+2	; 0x02
    43a4:	89 85       	ldd	r24, Y+9	; 0x09
    43a6:	9a 85       	ldd	r25, Y+10	; 0x0a
    43a8:	28 17       	cp	r18, r24
    43aa:	39 07       	cpc	r19, r25
    43ac:	41 f4       	brne	.+16     	; 0x43be <vTaskRemoveFromUnorderedEventList+0x94>
    43ae:	e9 85       	ldd	r30, Y+9	; 0x09
    43b0:	fa 85       	ldd	r31, Y+10	; 0x0a
    43b2:	84 81       	ldd	r24, Z+4	; 0x04
    43b4:	95 81       	ldd	r25, Z+5	; 0x05
    43b6:	ed 81       	ldd	r30, Y+5	; 0x05
    43b8:	fe 81       	ldd	r31, Y+6	; 0x06
    43ba:	92 83       	std	Z+2, r25	; 0x02
    43bc:	81 83       	std	Z+1, r24	; 0x01
    43be:	e9 85       	ldd	r30, Y+9	; 0x09
    43c0:	fa 85       	ldd	r31, Y+10	; 0x0a
    43c2:	11 86       	std	Z+9, r1	; 0x09
    43c4:	10 86       	std	Z+8, r1	; 0x08
    43c6:	ed 81       	ldd	r30, Y+5	; 0x05
    43c8:	fe 81       	ldd	r31, Y+6	; 0x06
    43ca:	80 81       	ld	r24, Z
    43cc:	81 50       	subi	r24, 0x01	; 1
    43ce:	ed 81       	ldd	r30, Y+5	; 0x05
    43d0:	fe 81       	ldd	r31, Y+6	; 0x06
    43d2:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    43d4:	ef 81       	ldd	r30, Y+7	; 0x07
    43d6:	f8 85       	ldd	r31, Y+8	; 0x08
    43d8:	82 85       	ldd	r24, Z+10	; 0x0a
    43da:	93 85       	ldd	r25, Z+11	; 0x0b
    43dc:	9c 83       	std	Y+4, r25	; 0x04
    43de:	8b 83       	std	Y+3, r24	; 0x03
    43e0:	ef 81       	ldd	r30, Y+7	; 0x07
    43e2:	f8 85       	ldd	r31, Y+8	; 0x08
    43e4:	a4 81       	ldd	r26, Z+4	; 0x04
    43e6:	b5 81       	ldd	r27, Z+5	; 0x05
    43e8:	ef 81       	ldd	r30, Y+7	; 0x07
    43ea:	f8 85       	ldd	r31, Y+8	; 0x08
    43ec:	86 81       	ldd	r24, Z+6	; 0x06
    43ee:	97 81       	ldd	r25, Z+7	; 0x07
    43f0:	15 96       	adiw	r26, 0x05	; 5
    43f2:	9c 93       	st	X, r25
    43f4:	8e 93       	st	-X, r24
    43f6:	14 97       	sbiw	r26, 0x04	; 4
    43f8:	ef 81       	ldd	r30, Y+7	; 0x07
    43fa:	f8 85       	ldd	r31, Y+8	; 0x08
    43fc:	a6 81       	ldd	r26, Z+6	; 0x06
    43fe:	b7 81       	ldd	r27, Z+7	; 0x07
    4400:	ef 81       	ldd	r30, Y+7	; 0x07
    4402:	f8 85       	ldd	r31, Y+8	; 0x08
    4404:	84 81       	ldd	r24, Z+4	; 0x04
    4406:	95 81       	ldd	r25, Z+5	; 0x05
    4408:	13 96       	adiw	r26, 0x03	; 3
    440a:	9c 93       	st	X, r25
    440c:	8e 93       	st	-X, r24
    440e:	12 97       	sbiw	r26, 0x02	; 2
    4410:	eb 81       	ldd	r30, Y+3	; 0x03
    4412:	fc 81       	ldd	r31, Y+4	; 0x04
    4414:	21 81       	ldd	r18, Z+1	; 0x01
    4416:	32 81       	ldd	r19, Z+2	; 0x02
    4418:	8f 81       	ldd	r24, Y+7	; 0x07
    441a:	98 85       	ldd	r25, Y+8	; 0x08
    441c:	02 96       	adiw	r24, 0x02	; 2
    441e:	28 17       	cp	r18, r24
    4420:	39 07       	cpc	r19, r25
    4422:	41 f4       	brne	.+16     	; 0x4434 <vTaskRemoveFromUnorderedEventList+0x10a>
    4424:	ef 81       	ldd	r30, Y+7	; 0x07
    4426:	f8 85       	ldd	r31, Y+8	; 0x08
    4428:	86 81       	ldd	r24, Z+6	; 0x06
    442a:	97 81       	ldd	r25, Z+7	; 0x07
    442c:	eb 81       	ldd	r30, Y+3	; 0x03
    442e:	fc 81       	ldd	r31, Y+4	; 0x04
    4430:	92 83       	std	Z+2, r25	; 0x02
    4432:	81 83       	std	Z+1, r24	; 0x01
    4434:	ef 81       	ldd	r30, Y+7	; 0x07
    4436:	f8 85       	ldd	r31, Y+8	; 0x08
    4438:	13 86       	std	Z+11, r1	; 0x0b
    443a:	12 86       	std	Z+10, r1	; 0x0a
    443c:	eb 81       	ldd	r30, Y+3	; 0x03
    443e:	fc 81       	ldd	r31, Y+4	; 0x04
    4440:	80 81       	ld	r24, Z
    4442:	81 50       	subi	r24, 0x01	; 1
    4444:	eb 81       	ldd	r30, Y+3	; 0x03
    4446:	fc 81       	ldd	r31, Y+4	; 0x04
    4448:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    444a:	ef 81       	ldd	r30, Y+7	; 0x07
    444c:	f8 85       	ldd	r31, Y+8	; 0x08
    444e:	96 89       	ldd	r25, Z+22	; 0x16
    4450:	80 91 ac 06 	lds	r24, 0x06AC
    4454:	89 17       	cp	r24, r25
    4456:	28 f4       	brcc	.+10     	; 0x4462 <vTaskRemoveFromUnorderedEventList+0x138>
    4458:	ef 81       	ldd	r30, Y+7	; 0x07
    445a:	f8 85       	ldd	r31, Y+8	; 0x08
    445c:	86 89       	ldd	r24, Z+22	; 0x16
    445e:	80 93 ac 06 	sts	0x06AC, r24
    4462:	ef 81       	ldd	r30, Y+7	; 0x07
    4464:	f8 85       	ldd	r31, Y+8	; 0x08
    4466:	86 89       	ldd	r24, Z+22	; 0x16
    4468:	28 2f       	mov	r18, r24
    446a:	30 e0       	ldi	r19, 0x00	; 0
    446c:	c9 01       	movw	r24, r18
    446e:	88 0f       	add	r24, r24
    4470:	99 1f       	adc	r25, r25
    4472:	88 0f       	add	r24, r24
    4474:	99 1f       	adc	r25, r25
    4476:	88 0f       	add	r24, r24
    4478:	99 1f       	adc	r25, r25
    447a:	82 0f       	add	r24, r18
    447c:	93 1f       	adc	r25, r19
    447e:	fc 01       	movw	r30, r24
    4480:	e8 54       	subi	r30, 0x48	; 72
    4482:	f9 4f       	sbci	r31, 0xF9	; 249
    4484:	81 81       	ldd	r24, Z+1	; 0x01
    4486:	92 81       	ldd	r25, Z+2	; 0x02
    4488:	9a 83       	std	Y+2, r25	; 0x02
    448a:	89 83       	std	Y+1, r24	; 0x01
    448c:	ef 81       	ldd	r30, Y+7	; 0x07
    448e:	f8 85       	ldd	r31, Y+8	; 0x08
    4490:	89 81       	ldd	r24, Y+1	; 0x01
    4492:	9a 81       	ldd	r25, Y+2	; 0x02
    4494:	95 83       	std	Z+5, r25	; 0x05
    4496:	84 83       	std	Z+4, r24	; 0x04
    4498:	e9 81       	ldd	r30, Y+1	; 0x01
    449a:	fa 81       	ldd	r31, Y+2	; 0x02
    449c:	84 81       	ldd	r24, Z+4	; 0x04
    449e:	95 81       	ldd	r25, Z+5	; 0x05
    44a0:	ef 81       	ldd	r30, Y+7	; 0x07
    44a2:	f8 85       	ldd	r31, Y+8	; 0x08
    44a4:	97 83       	std	Z+7, r25	; 0x07
    44a6:	86 83       	std	Z+6, r24	; 0x06
    44a8:	e9 81       	ldd	r30, Y+1	; 0x01
    44aa:	fa 81       	ldd	r31, Y+2	; 0x02
    44ac:	04 80       	ldd	r0, Z+4	; 0x04
    44ae:	f5 81       	ldd	r31, Z+5	; 0x05
    44b0:	e0 2d       	mov	r30, r0
    44b2:	8f 81       	ldd	r24, Y+7	; 0x07
    44b4:	98 85       	ldd	r25, Y+8	; 0x08
    44b6:	02 96       	adiw	r24, 0x02	; 2
    44b8:	93 83       	std	Z+3, r25	; 0x03
    44ba:	82 83       	std	Z+2, r24	; 0x02
    44bc:	8f 81       	ldd	r24, Y+7	; 0x07
    44be:	98 85       	ldd	r25, Y+8	; 0x08
    44c0:	02 96       	adiw	r24, 0x02	; 2
    44c2:	e9 81       	ldd	r30, Y+1	; 0x01
    44c4:	fa 81       	ldd	r31, Y+2	; 0x02
    44c6:	95 83       	std	Z+5, r25	; 0x05
    44c8:	84 83       	std	Z+4, r24	; 0x04
    44ca:	ef 81       	ldd	r30, Y+7	; 0x07
    44cc:	f8 85       	ldd	r31, Y+8	; 0x08
    44ce:	86 89       	ldd	r24, Z+22	; 0x16
    44d0:	28 2f       	mov	r18, r24
    44d2:	30 e0       	ldi	r19, 0x00	; 0
    44d4:	c9 01       	movw	r24, r18
    44d6:	88 0f       	add	r24, r24
    44d8:	99 1f       	adc	r25, r25
    44da:	88 0f       	add	r24, r24
    44dc:	99 1f       	adc	r25, r25
    44de:	88 0f       	add	r24, r24
    44e0:	99 1f       	adc	r25, r25
    44e2:	82 0f       	add	r24, r18
    44e4:	93 1f       	adc	r25, r19
    44e6:	88 54       	subi	r24, 0x48	; 72
    44e8:	99 4f       	sbci	r25, 0xF9	; 249
    44ea:	ef 81       	ldd	r30, Y+7	; 0x07
    44ec:	f8 85       	ldd	r31, Y+8	; 0x08
    44ee:	93 87       	std	Z+11, r25	; 0x0b
    44f0:	82 87       	std	Z+10, r24	; 0x0a
    44f2:	ef 81       	ldd	r30, Y+7	; 0x07
    44f4:	f8 85       	ldd	r31, Y+8	; 0x08
    44f6:	86 89       	ldd	r24, Z+22	; 0x16
    44f8:	28 2f       	mov	r18, r24
    44fa:	30 e0       	ldi	r19, 0x00	; 0
    44fc:	c9 01       	movw	r24, r18
    44fe:	88 0f       	add	r24, r24
    4500:	99 1f       	adc	r25, r25
    4502:	88 0f       	add	r24, r24
    4504:	99 1f       	adc	r25, r25
    4506:	88 0f       	add	r24, r24
    4508:	99 1f       	adc	r25, r25
    450a:	82 0f       	add	r24, r18
    450c:	93 1f       	adc	r25, r19
    450e:	fc 01       	movw	r30, r24
    4510:	e8 54       	subi	r30, 0x48	; 72
    4512:	f9 4f       	sbci	r31, 0xF9	; 249
    4514:	80 81       	ld	r24, Z
    4516:	8f 5f       	subi	r24, 0xFF	; 255
    4518:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    451a:	ef 81       	ldd	r30, Y+7	; 0x07
    451c:	f8 85       	ldd	r31, Y+8	; 0x08
    451e:	96 89       	ldd	r25, Z+22	; 0x16
    4520:	e0 91 a6 06 	lds	r30, 0x06A6
    4524:	f0 91 a7 06 	lds	r31, 0x06A7
    4528:	86 89       	ldd	r24, Z+22	; 0x16
    452a:	89 17       	cp	r24, r25
    452c:	18 f4       	brcc	.+6      	; 0x4534 <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    452e:	81 e0       	ldi	r24, 0x01	; 1
    4530:	80 93 b0 06 	sts	0x06B0, r24
    }
}
    4534:	2c 96       	adiw	r28, 0x0c	; 12
    4536:	0f b6       	in	r0, 0x3f	; 63
    4538:	f8 94       	cli
    453a:	de bf       	out	0x3e, r29	; 62
    453c:	0f be       	out	0x3f, r0	; 63
    453e:	cd bf       	out	0x3d, r28	; 61
    4540:	cf 91       	pop	r28
    4542:	df 91       	pop	r29
    4544:	08 95       	ret

00004546 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4546:	df 93       	push	r29
    4548:	cf 93       	push	r28
    454a:	00 d0       	rcall	.+0      	; 0x454c <vTaskSetTimeOutState+0x6>
    454c:	cd b7       	in	r28, 0x3d	; 61
    454e:	de b7       	in	r29, 0x3e	; 62
    4550:	9a 83       	std	Y+2, r25	; 0x02
    4552:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    4554:	0f b6       	in	r0, 0x3f	; 63
    4556:	f8 94       	cli
    4558:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    455a:	80 91 b1 06 	lds	r24, 0x06B1
    455e:	e9 81       	ldd	r30, Y+1	; 0x01
    4560:	fa 81       	ldd	r31, Y+2	; 0x02
    4562:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    4564:	80 91 aa 06 	lds	r24, 0x06AA
    4568:	90 91 ab 06 	lds	r25, 0x06AB
    456c:	e9 81       	ldd	r30, Y+1	; 0x01
    456e:	fa 81       	ldd	r31, Y+2	; 0x02
    4570:	92 83       	std	Z+2, r25	; 0x02
    4572:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    4574:	0f 90       	pop	r0
    4576:	0f be       	out	0x3f, r0	; 63
}
    4578:	0f 90       	pop	r0
    457a:	0f 90       	pop	r0
    457c:	cf 91       	pop	r28
    457e:	df 91       	pop	r29
    4580:	08 95       	ret

00004582 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4582:	df 93       	push	r29
    4584:	cf 93       	push	r28
    4586:	00 d0       	rcall	.+0      	; 0x4588 <vTaskInternalSetTimeOutState+0x6>
    4588:	cd b7       	in	r28, 0x3d	; 61
    458a:	de b7       	in	r29, 0x3e	; 62
    458c:	9a 83       	std	Y+2, r25	; 0x02
    458e:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    4590:	80 91 b1 06 	lds	r24, 0x06B1
    4594:	e9 81       	ldd	r30, Y+1	; 0x01
    4596:	fa 81       	ldd	r31, Y+2	; 0x02
    4598:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    459a:	80 91 aa 06 	lds	r24, 0x06AA
    459e:	90 91 ab 06 	lds	r25, 0x06AB
    45a2:	e9 81       	ldd	r30, Y+1	; 0x01
    45a4:	fa 81       	ldd	r31, Y+2	; 0x02
    45a6:	92 83       	std	Z+2, r25	; 0x02
    45a8:	81 83       	std	Z+1, r24	; 0x01
}
    45aa:	0f 90       	pop	r0
    45ac:	0f 90       	pop	r0
    45ae:	cf 91       	pop	r28
    45b0:	df 91       	pop	r29
    45b2:	08 95       	ret

000045b4 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    45b4:	df 93       	push	r29
    45b6:	cf 93       	push	r28
    45b8:	cd b7       	in	r28, 0x3d	; 61
    45ba:	de b7       	in	r29, 0x3e	; 62
    45bc:	29 97       	sbiw	r28, 0x09	; 9
    45be:	0f b6       	in	r0, 0x3f	; 63
    45c0:	f8 94       	cli
    45c2:	de bf       	out	0x3e, r29	; 62
    45c4:	0f be       	out	0x3f, r0	; 63
    45c6:	cd bf       	out	0x3d, r28	; 61
    45c8:	9f 83       	std	Y+7, r25	; 0x07
    45ca:	8e 83       	std	Y+6, r24	; 0x06
    45cc:	79 87       	std	Y+9, r23	; 0x09
    45ce:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    45d0:	0f b6       	in	r0, 0x3f	; 63
    45d2:	f8 94       	cli
    45d4:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    45d6:	80 91 aa 06 	lds	r24, 0x06AA
    45da:	90 91 ab 06 	lds	r25, 0x06AB
    45de:	9c 83       	std	Y+4, r25	; 0x04
    45e0:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    45e2:	ee 81       	ldd	r30, Y+6	; 0x06
    45e4:	ff 81       	ldd	r31, Y+7	; 0x07
    45e6:	21 81       	ldd	r18, Z+1	; 0x01
    45e8:	32 81       	ldd	r19, Z+2	; 0x02
    45ea:	8b 81       	ldd	r24, Y+3	; 0x03
    45ec:	9c 81       	ldd	r25, Y+4	; 0x04
    45ee:	82 1b       	sub	r24, r18
    45f0:	93 0b       	sbc	r25, r19
    45f2:	9a 83       	std	Y+2, r25	; 0x02
    45f4:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    45f6:	ee 81       	ldd	r30, Y+6	; 0x06
    45f8:	ff 81       	ldd	r31, Y+7	; 0x07
    45fa:	90 81       	ld	r25, Z
    45fc:	80 91 b1 06 	lds	r24, 0x06B1
    4600:	98 17       	cp	r25, r24
    4602:	81 f0       	breq	.+32     	; 0x4624 <xTaskCheckForTimeOut+0x70>
    4604:	ee 81       	ldd	r30, Y+6	; 0x06
    4606:	ff 81       	ldd	r31, Y+7	; 0x07
    4608:	21 81       	ldd	r18, Z+1	; 0x01
    460a:	32 81       	ldd	r19, Z+2	; 0x02
    460c:	8b 81       	ldd	r24, Y+3	; 0x03
    460e:	9c 81       	ldd	r25, Y+4	; 0x04
    4610:	82 17       	cp	r24, r18
    4612:	93 07       	cpc	r25, r19
    4614:	38 f0       	brcs	.+14     	; 0x4624 <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    4616:	81 e0       	ldi	r24, 0x01	; 1
    4618:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    461a:	e8 85       	ldd	r30, Y+8	; 0x08
    461c:	f9 85       	ldd	r31, Y+9	; 0x09
    461e:	11 82       	std	Z+1, r1	; 0x01
    4620:	10 82       	st	Z, r1
    4622:	23 c0       	rjmp	.+70     	; 0x466a <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4624:	e8 85       	ldd	r30, Y+8	; 0x08
    4626:	f9 85       	ldd	r31, Y+9	; 0x09
    4628:	20 81       	ld	r18, Z
    462a:	31 81       	ldd	r19, Z+1	; 0x01
    462c:	89 81       	ldd	r24, Y+1	; 0x01
    462e:	9a 81       	ldd	r25, Y+2	; 0x02
    4630:	82 17       	cp	r24, r18
    4632:	93 07       	cpc	r25, r19
    4634:	a0 f4       	brcc	.+40     	; 0x465e <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    4636:	e8 85       	ldd	r30, Y+8	; 0x08
    4638:	f9 85       	ldd	r31, Y+9	; 0x09
    463a:	20 81       	ld	r18, Z
    463c:	31 81       	ldd	r19, Z+1	; 0x01
    463e:	89 81       	ldd	r24, Y+1	; 0x01
    4640:	9a 81       	ldd	r25, Y+2	; 0x02
    4642:	a9 01       	movw	r20, r18
    4644:	48 1b       	sub	r20, r24
    4646:	59 0b       	sbc	r21, r25
    4648:	ca 01       	movw	r24, r20
    464a:	e8 85       	ldd	r30, Y+8	; 0x08
    464c:	f9 85       	ldd	r31, Y+9	; 0x09
    464e:	91 83       	std	Z+1, r25	; 0x01
    4650:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    4652:	8e 81       	ldd	r24, Y+6	; 0x06
    4654:	9f 81       	ldd	r25, Y+7	; 0x07
    4656:	0e 94 c1 22 	call	0x4582	; 0x4582 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    465a:	1d 82       	std	Y+5, r1	; 0x05
    465c:	06 c0       	rjmp	.+12     	; 0x466a <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    465e:	e8 85       	ldd	r30, Y+8	; 0x08
    4660:	f9 85       	ldd	r31, Y+9	; 0x09
    4662:	11 82       	std	Z+1, r1	; 0x01
    4664:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    4666:	81 e0       	ldi	r24, 0x01	; 1
    4668:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    466a:	0f 90       	pop	r0
    466c:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    466e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4670:	29 96       	adiw	r28, 0x09	; 9
    4672:	0f b6       	in	r0, 0x3f	; 63
    4674:	f8 94       	cli
    4676:	de bf       	out	0x3e, r29	; 62
    4678:	0f be       	out	0x3f, r0	; 63
    467a:	cd bf       	out	0x3d, r28	; 61
    467c:	cf 91       	pop	r28
    467e:	df 91       	pop	r29
    4680:	08 95       	ret

00004682 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4682:	df 93       	push	r29
    4684:	cf 93       	push	r28
    4686:	cd b7       	in	r28, 0x3d	; 61
    4688:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    468a:	81 e0       	ldi	r24, 0x01	; 1
    468c:	80 93 b0 06 	sts	0x06B0, r24
}
    4690:	cf 91       	pop	r28
    4692:	df 91       	pop	r29
    4694:	08 95       	ret

00004696 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4696:	df 93       	push	r29
    4698:	cf 93       	push	r28
    469a:	00 d0       	rcall	.+0      	; 0x469c <prvIdleTask+0x6>
    469c:	cd b7       	in	r28, 0x3d	; 61
    469e:	de b7       	in	r29, 0x3e	; 62
    46a0:	9a 83       	std	Y+2, r25	; 0x02
    46a2:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    46a4:	0e 94 98 23 	call	0x4730	; 0x4730 <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    46a8:	80 91 b8 06 	lds	r24, 0x06B8
    46ac:	82 30       	cpi	r24, 0x02	; 2
    46ae:	d0 f3       	brcs	.-12     	; 0x46a4 <prvIdleTask+0xe>
                {
                    taskYIELD();
    46b0:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    46b4:	f7 cf       	rjmp	.-18     	; 0x46a4 <prvIdleTask+0xe>

000046b6 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    46b6:	df 93       	push	r29
    46b8:	cf 93       	push	r28
    46ba:	0f 92       	push	r0
    46bc:	cd b7       	in	r28, 0x3d	; 61
    46be:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    46c0:	19 82       	std	Y+1, r1	; 0x01
    46c2:	13 c0       	rjmp	.+38     	; 0x46ea <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    46c4:	89 81       	ldd	r24, Y+1	; 0x01
    46c6:	28 2f       	mov	r18, r24
    46c8:	30 e0       	ldi	r19, 0x00	; 0
    46ca:	c9 01       	movw	r24, r18
    46cc:	88 0f       	add	r24, r24
    46ce:	99 1f       	adc	r25, r25
    46d0:	88 0f       	add	r24, r24
    46d2:	99 1f       	adc	r25, r25
    46d4:	88 0f       	add	r24, r24
    46d6:	99 1f       	adc	r25, r25
    46d8:	82 0f       	add	r24, r18
    46da:	93 1f       	adc	r25, r19
    46dc:	88 54       	subi	r24, 0x48	; 72
    46de:	99 4f       	sbci	r25, 0xF9	; 249
    46e0:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    46e4:	89 81       	ldd	r24, Y+1	; 0x01
    46e6:	8f 5f       	subi	r24, 0xFF	; 255
    46e8:	89 83       	std	Y+1, r24	; 0x01
    46ea:	89 81       	ldd	r24, Y+1	; 0x01
    46ec:	84 30       	cpi	r24, 0x04	; 4
    46ee:	50 f3       	brcs	.-44     	; 0x46c4 <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    46f0:	8c ed       	ldi	r24, 0xDC	; 220
    46f2:	96 e0       	ldi	r25, 0x06	; 6
    46f4:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    46f8:	85 ee       	ldi	r24, 0xE5	; 229
    46fa:	96 e0       	ldi	r25, 0x06	; 6
    46fc:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <vListInitialise>
    vListInitialise( &xPendingReadyList );
    4700:	82 ef       	ldi	r24, 0xF2	; 242
    4702:	96 e0       	ldi	r25, 0x06	; 6
    4704:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    4708:	8b ef       	ldi	r24, 0xFB	; 251
    470a:	96 e0       	ldi	r25, 0x06	; 6
    470c:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    4710:	8c ed       	ldi	r24, 0xDC	; 220
    4712:	96 e0       	ldi	r25, 0x06	; 6
    4714:	90 93 ef 06 	sts	0x06EF, r25
    4718:	80 93 ee 06 	sts	0x06EE, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    471c:	85 ee       	ldi	r24, 0xE5	; 229
    471e:	96 e0       	ldi	r25, 0x06	; 6
    4720:	90 93 f1 06 	sts	0x06F1, r25
    4724:	80 93 f0 06 	sts	0x06F0, r24
}
    4728:	0f 90       	pop	r0
    472a:	cf 91       	pop	r28
    472c:	df 91       	pop	r29
    472e:	08 95       	ret

00004730 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4730:	df 93       	push	r29
    4732:	cf 93       	push	r28
    4734:	00 d0       	rcall	.+0      	; 0x4736 <prvCheckTasksWaitingTermination+0x6>
    4736:	cd b7       	in	r28, 0x3d	; 61
    4738:	de b7       	in	r29, 0x3e	; 62
    473a:	20 c0       	rjmp	.+64     	; 0x477c <prvCheckTasksWaitingTermination+0x4c>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    473c:	0f b6       	in	r0, 0x3f	; 63
    473e:	f8 94       	cli
    4740:	0f 92       	push	r0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4742:	e0 91 00 07 	lds	r30, 0x0700
    4746:	f0 91 01 07 	lds	r31, 0x0701
    474a:	86 81       	ldd	r24, Z+6	; 0x06
    474c:	97 81       	ldd	r25, Z+7	; 0x07
    474e:	9a 83       	std	Y+2, r25	; 0x02
    4750:	89 83       	std	Y+1, r24	; 0x01
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4752:	89 81       	ldd	r24, Y+1	; 0x01
    4754:	9a 81       	ldd	r25, Y+2	; 0x02
    4756:	02 96       	adiw	r24, 0x02	; 2
    4758:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <uxListRemove>
                    --uxCurrentNumberOfTasks;
    475c:	80 91 a9 06 	lds	r24, 0x06A9
    4760:	81 50       	subi	r24, 0x01	; 1
    4762:	80 93 a9 06 	sts	0x06A9, r24
                    --uxDeletedTasksWaitingCleanUp;
    4766:	80 91 a8 06 	lds	r24, 0x06A8
    476a:	81 50       	subi	r24, 0x01	; 1
    476c:	80 93 a8 06 	sts	0x06A8, r24
                }
                taskEXIT_CRITICAL();
    4770:	0f 90       	pop	r0
    4772:	0f be       	out	0x3f, r0	; 63

                prvDeleteTCB( pxTCB );
    4774:	89 81       	ldd	r24, Y+1	; 0x01
    4776:	9a 81       	ldd	r25, Y+2	; 0x02
    4778:	0e 94 c7 23 	call	0x478e	; 0x478e <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    477c:	80 91 a8 06 	lds	r24, 0x06A8
    4780:	88 23       	and	r24, r24
    4782:	e1 f6       	brne	.-72     	; 0x473c <prvCheckTasksWaitingTermination+0xc>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    4784:	0f 90       	pop	r0
    4786:	0f 90       	pop	r0
    4788:	cf 91       	pop	r28
    478a:	df 91       	pop	r29
    478c:	08 95       	ret

0000478e <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    478e:	df 93       	push	r29
    4790:	cf 93       	push	r28
    4792:	00 d0       	rcall	.+0      	; 0x4794 <prvDeleteTCB+0x6>
    4794:	cd b7       	in	r28, 0x3d	; 61
    4796:	de b7       	in	r29, 0x3e	; 62
    4798:	9a 83       	std	Y+2, r25	; 0x02
    479a:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    479c:	e9 81       	ldd	r30, Y+1	; 0x01
    479e:	fa 81       	ldd	r31, Y+2	; 0x02
    47a0:	87 89       	ldd	r24, Z+23	; 0x17
    47a2:	90 8d       	ldd	r25, Z+24	; 0x18
    47a4:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                vPortFree( pxTCB );
    47a8:	89 81       	ldd	r24, Y+1	; 0x01
    47aa:	9a 81       	ldd	r25, Y+2	; 0x02
    47ac:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    47b0:	0f 90       	pop	r0
    47b2:	0f 90       	pop	r0
    47b4:	cf 91       	pop	r28
    47b6:	df 91       	pop	r29
    47b8:	08 95       	ret

000047ba <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    47ba:	df 93       	push	r29
    47bc:	cf 93       	push	r28
    47be:	cd b7       	in	r28, 0x3d	; 61
    47c0:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    47c2:	e0 91 ee 06 	lds	r30, 0x06EE
    47c6:	f0 91 ef 06 	lds	r31, 0x06EF
    47ca:	80 81       	ld	r24, Z
    47cc:	88 23       	and	r24, r24
    47ce:	39 f4       	brne	.+14     	; 0x47de <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    47d0:	8f ef       	ldi	r24, 0xFF	; 255
    47d2:	9f ef       	ldi	r25, 0xFF	; 255
    47d4:	90 93 b4 06 	sts	0x06B4, r25
    47d8:	80 93 b3 06 	sts	0x06B3, r24
    47dc:	0d c0       	rjmp	.+26     	; 0x47f8 <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    47de:	e0 91 ee 06 	lds	r30, 0x06EE
    47e2:	f0 91 ef 06 	lds	r31, 0x06EF
    47e6:	05 80       	ldd	r0, Z+5	; 0x05
    47e8:	f6 81       	ldd	r31, Z+6	; 0x06
    47ea:	e0 2d       	mov	r30, r0
    47ec:	80 81       	ld	r24, Z
    47ee:	91 81       	ldd	r25, Z+1	; 0x01
    47f0:	90 93 b4 06 	sts	0x06B4, r25
    47f4:	80 93 b3 06 	sts	0x06B3, r24
    }
}
    47f8:	cf 91       	pop	r28
    47fa:	df 91       	pop	r29
    47fc:	08 95       	ret

000047fe <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
    47fe:	df 93       	push	r29
    4800:	cf 93       	push	r28
    4802:	0f 92       	push	r0
    4804:	cd b7       	in	r28, 0x3d	; 61
    4806:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
    4808:	80 91 ad 06 	lds	r24, 0x06AD
    480c:	88 23       	and	r24, r24
    480e:	19 f4       	brne	.+6      	; 0x4816 <xTaskGetSchedulerState+0x18>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
    4810:	81 e0       	ldi	r24, 0x01	; 1
    4812:	89 83       	std	Y+1, r24	; 0x01
    4814:	08 c0       	rjmp	.+16     	; 0x4826 <xTaskGetSchedulerState+0x28>
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4816:	80 91 b7 06 	lds	r24, 0x06B7
    481a:	88 23       	and	r24, r24
    481c:	19 f4       	brne	.+6      	; 0x4824 <xTaskGetSchedulerState+0x26>
            {
                xReturn = taskSCHEDULER_RUNNING;
    481e:	82 e0       	ldi	r24, 0x02	; 2
    4820:	89 83       	std	Y+1, r24	; 0x01
    4822:	01 c0       	rjmp	.+2      	; 0x4826 <xTaskGetSchedulerState+0x28>
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
    4824:	19 82       	std	Y+1, r1	; 0x01
            }
        }

        return xReturn;
    4826:	89 81       	ldd	r24, Y+1	; 0x01
    }
    4828:	0f 90       	pop	r0
    482a:	cf 91       	pop	r28
    482c:	df 91       	pop	r29
    482e:	08 95       	ret

00004830 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4830:	df 93       	push	r29
    4832:	cf 93       	push	r28
    4834:	00 d0       	rcall	.+0      	; 0x4836 <uxTaskResetEventItemValue+0x6>
    4836:	cd b7       	in	r28, 0x3d	; 61
    4838:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    483a:	e0 91 a6 06 	lds	r30, 0x06A6
    483e:	f0 91 a7 06 	lds	r31, 0x06A7
    4842:	84 85       	ldd	r24, Z+12	; 0x0c
    4844:	95 85       	ldd	r25, Z+13	; 0x0d
    4846:	9a 83       	std	Y+2, r25	; 0x02
    4848:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    484a:	a0 91 a6 06 	lds	r26, 0x06A6
    484e:	b0 91 a7 06 	lds	r27, 0x06A7
    4852:	e0 91 a6 06 	lds	r30, 0x06A6
    4856:	f0 91 a7 06 	lds	r31, 0x06A7
    485a:	86 89       	ldd	r24, Z+22	; 0x16
    485c:	28 2f       	mov	r18, r24
    485e:	30 e0       	ldi	r19, 0x00	; 0
    4860:	84 e0       	ldi	r24, 0x04	; 4
    4862:	90 e0       	ldi	r25, 0x00	; 0
    4864:	82 1b       	sub	r24, r18
    4866:	93 0b       	sbc	r25, r19
    4868:	1d 96       	adiw	r26, 0x0d	; 13
    486a:	9c 93       	st	X, r25
    486c:	8e 93       	st	-X, r24
    486e:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    4870:	89 81       	ldd	r24, Y+1	; 0x01
    4872:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4874:	0f 90       	pop	r0
    4876:	0f 90       	pop	r0
    4878:	cf 91       	pop	r28
    487a:	df 91       	pop	r29
    487c:	08 95       	ret

0000487e <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    487e:	df 93       	push	r29
    4880:	cf 93       	push	r28
    4882:	cd b7       	in	r28, 0x3d	; 61
    4884:	de b7       	in	r29, 0x3e	; 62
    4886:	28 97       	sbiw	r28, 0x08	; 8
    4888:	0f b6       	in	r0, 0x3f	; 63
    488a:	f8 94       	cli
    488c:	de bf       	out	0x3e, r29	; 62
    488e:	0f be       	out	0x3f, r0	; 63
    4890:	cd bf       	out	0x3d, r28	; 61
    4892:	8d 83       	std	Y+5, r24	; 0x05
    4894:	6e 83       	std	Y+6, r22	; 0x06
    4896:	58 87       	std	Y+8, r21	; 0x08
    4898:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    489a:	0f b6       	in	r0, 0x3f	; 63
    489c:	f8 94       	cli
    489e:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    48a0:	20 91 a6 06 	lds	r18, 0x06A6
    48a4:	30 91 a7 06 	lds	r19, 0x06A7
    48a8:	8d 81       	ldd	r24, Y+5	; 0x05
    48aa:	88 2f       	mov	r24, r24
    48ac:	90 e0       	ldi	r25, 0x00	; 0
    48ae:	88 0f       	add	r24, r24
    48b0:	99 1f       	adc	r25, r25
    48b2:	88 0f       	add	r24, r24
    48b4:	99 1f       	adc	r25, r25
    48b6:	82 0f       	add	r24, r18
    48b8:	93 1f       	adc	r25, r19
    48ba:	fc 01       	movw	r30, r24
    48bc:	b1 96       	adiw	r30, 0x21	; 33
    48be:	80 81       	ld	r24, Z
    48c0:	91 81       	ldd	r25, Z+1	; 0x01
    48c2:	a2 81       	ldd	r26, Z+2	; 0x02
    48c4:	b3 81       	ldd	r27, Z+3	; 0x03
    48c6:	00 97       	sbiw	r24, 0x00	; 0
    48c8:	a1 05       	cpc	r26, r1
    48ca:	b1 05       	cpc	r27, r1
    48cc:	c1 f4       	brne	.+48     	; 0x48fe <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    48ce:	20 91 a6 06 	lds	r18, 0x06A6
    48d2:	30 91 a7 06 	lds	r19, 0x06A7
    48d6:	8d 81       	ldd	r24, Y+5	; 0x05
    48d8:	88 2f       	mov	r24, r24
    48da:	90 e0       	ldi	r25, 0x00	; 0
    48dc:	82 0f       	add	r24, r18
    48de:	93 1f       	adc	r25, r19
    48e0:	fc 01       	movw	r30, r24
    48e2:	b5 96       	adiw	r30, 0x25	; 37
    48e4:	81 e0       	ldi	r24, 0x01	; 1
    48e6:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    48e8:	8f 81       	ldd	r24, Y+7	; 0x07
    48ea:	98 85       	ldd	r25, Y+8	; 0x08
    48ec:	00 97       	sbiw	r24, 0x00	; 0
    48ee:	39 f0       	breq	.+14     	; 0x48fe <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    48f0:	8f 81       	ldd	r24, Y+7	; 0x07
    48f2:	98 85       	ldd	r25, Y+8	; 0x08
    48f4:	61 e0       	ldi	r22, 0x01	; 1
    48f6:	0e 94 c4 2b 	call	0x5788	; 0x5788 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    48fa:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    48fe:	0f 90       	pop	r0
    4900:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4902:	0f b6       	in	r0, 0x3f	; 63
    4904:	f8 94       	cli
    4906:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    4908:	20 91 a6 06 	lds	r18, 0x06A6
    490c:	30 91 a7 06 	lds	r19, 0x06A7
    4910:	8d 81       	ldd	r24, Y+5	; 0x05
    4912:	88 2f       	mov	r24, r24
    4914:	90 e0       	ldi	r25, 0x00	; 0
    4916:	88 0f       	add	r24, r24
    4918:	99 1f       	adc	r25, r25
    491a:	88 0f       	add	r24, r24
    491c:	99 1f       	adc	r25, r25
    491e:	82 0f       	add	r24, r18
    4920:	93 1f       	adc	r25, r19
    4922:	fc 01       	movw	r30, r24
    4924:	b1 96       	adiw	r30, 0x21	; 33
    4926:	80 81       	ld	r24, Z
    4928:	91 81       	ldd	r25, Z+1	; 0x01
    492a:	a2 81       	ldd	r26, Z+2	; 0x02
    492c:	b3 81       	ldd	r27, Z+3	; 0x03
    492e:	89 83       	std	Y+1, r24	; 0x01
    4930:	9a 83       	std	Y+2, r25	; 0x02
    4932:	ab 83       	std	Y+3, r26	; 0x03
    4934:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    4936:	89 81       	ldd	r24, Y+1	; 0x01
    4938:	9a 81       	ldd	r25, Y+2	; 0x02
    493a:	ab 81       	ldd	r26, Y+3	; 0x03
    493c:	bc 81       	ldd	r27, Y+4	; 0x04
    493e:	00 97       	sbiw	r24, 0x00	; 0
    4940:	a1 05       	cpc	r26, r1
    4942:	b1 05       	cpc	r27, r1
    4944:	a9 f1       	breq	.+106    	; 0x49b0 <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    4946:	8e 81       	ldd	r24, Y+6	; 0x06
    4948:	88 23       	and	r24, r24
    494a:	a1 f0       	breq	.+40     	; 0x4974 <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    494c:	20 91 a6 06 	lds	r18, 0x06A6
    4950:	30 91 a7 06 	lds	r19, 0x06A7
    4954:	8d 81       	ldd	r24, Y+5	; 0x05
    4956:	88 2f       	mov	r24, r24
    4958:	90 e0       	ldi	r25, 0x00	; 0
    495a:	88 0f       	add	r24, r24
    495c:	99 1f       	adc	r25, r25
    495e:	88 0f       	add	r24, r24
    4960:	99 1f       	adc	r25, r25
    4962:	82 0f       	add	r24, r18
    4964:	93 1f       	adc	r25, r19
    4966:	fc 01       	movw	r30, r24
    4968:	b1 96       	adiw	r30, 0x21	; 33
    496a:	10 82       	st	Z, r1
    496c:	11 82       	std	Z+1, r1	; 0x01
    496e:	12 82       	std	Z+2, r1	; 0x02
    4970:	13 82       	std	Z+3, r1	; 0x03
    4972:	1e c0       	rjmp	.+60     	; 0x49b0 <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    4974:	e0 91 a6 06 	lds	r30, 0x06A6
    4978:	f0 91 a7 06 	lds	r31, 0x06A7
    497c:	8d 81       	ldd	r24, Y+5	; 0x05
    497e:	68 2f       	mov	r22, r24
    4980:	70 e0       	ldi	r23, 0x00	; 0
    4982:	89 81       	ldd	r24, Y+1	; 0x01
    4984:	9a 81       	ldd	r25, Y+2	; 0x02
    4986:	ab 81       	ldd	r26, Y+3	; 0x03
    4988:	bc 81       	ldd	r27, Y+4	; 0x04
    498a:	9c 01       	movw	r18, r24
    498c:	ad 01       	movw	r20, r26
    498e:	21 50       	subi	r18, 0x01	; 1
    4990:	30 40       	sbci	r19, 0x00	; 0
    4992:	40 40       	sbci	r20, 0x00	; 0
    4994:	50 40       	sbci	r21, 0x00	; 0
    4996:	cb 01       	movw	r24, r22
    4998:	88 0f       	add	r24, r24
    499a:	99 1f       	adc	r25, r25
    499c:	88 0f       	add	r24, r24
    499e:	99 1f       	adc	r25, r25
    49a0:	8e 0f       	add	r24, r30
    49a2:	9f 1f       	adc	r25, r31
    49a4:	fc 01       	movw	r30, r24
    49a6:	b1 96       	adiw	r30, 0x21	; 33
    49a8:	20 83       	st	Z, r18
    49aa:	31 83       	std	Z+1, r19	; 0x01
    49ac:	42 83       	std	Z+2, r20	; 0x02
    49ae:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    49b0:	20 91 a6 06 	lds	r18, 0x06A6
    49b4:	30 91 a7 06 	lds	r19, 0x06A7
    49b8:	8d 81       	ldd	r24, Y+5	; 0x05
    49ba:	88 2f       	mov	r24, r24
    49bc:	90 e0       	ldi	r25, 0x00	; 0
    49be:	82 0f       	add	r24, r18
    49c0:	93 1f       	adc	r25, r19
    49c2:	fc 01       	movw	r30, r24
    49c4:	b5 96       	adiw	r30, 0x25	; 37
    49c6:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    49c8:	0f 90       	pop	r0
    49ca:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    49cc:	89 81       	ldd	r24, Y+1	; 0x01
    49ce:	9a 81       	ldd	r25, Y+2	; 0x02
    49d0:	ab 81       	ldd	r26, Y+3	; 0x03
    49d2:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    49d4:	bc 01       	movw	r22, r24
    49d6:	cd 01       	movw	r24, r26
    49d8:	28 96       	adiw	r28, 0x08	; 8
    49da:	0f b6       	in	r0, 0x3f	; 63
    49dc:	f8 94       	cli
    49de:	de bf       	out	0x3e, r29	; 62
    49e0:	0f be       	out	0x3f, r0	; 63
    49e2:	cd bf       	out	0x3d, r28	; 61
    49e4:	cf 91       	pop	r28
    49e6:	df 91       	pop	r29
    49e8:	08 95       	ret

000049ea <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    49ea:	cf 92       	push	r12
    49ec:	df 92       	push	r13
    49ee:	ef 92       	push	r14
    49f0:	ff 92       	push	r15
    49f2:	0f 93       	push	r16
    49f4:	1f 93       	push	r17
    49f6:	df 93       	push	r29
    49f8:	cf 93       	push	r28
    49fa:	cd b7       	in	r28, 0x3d	; 61
    49fc:	de b7       	in	r29, 0x3e	; 62
    49fe:	2e 97       	sbiw	r28, 0x0e	; 14
    4a00:	0f b6       	in	r0, 0x3f	; 63
    4a02:	f8 94       	cli
    4a04:	de bf       	out	0x3e, r29	; 62
    4a06:	0f be       	out	0x3f, r0	; 63
    4a08:	cd bf       	out	0x3d, r28	; 61
    4a0a:	8a 83       	std	Y+2, r24	; 0x02
    4a0c:	4b 83       	std	Y+3, r20	; 0x03
    4a0e:	5c 83       	std	Y+4, r21	; 0x04
    4a10:	6d 83       	std	Y+5, r22	; 0x05
    4a12:	7e 83       	std	Y+6, r23	; 0x06
    4a14:	0f 83       	std	Y+7, r16	; 0x07
    4a16:	18 87       	std	Y+8, r17	; 0x08
    4a18:	29 87       	std	Y+9, r18	; 0x09
    4a1a:	3a 87       	std	Y+10, r19	; 0x0a
    4a1c:	fc 86       	std	Y+12, r15	; 0x0c
    4a1e:	eb 86       	std	Y+11, r14	; 0x0b
    4a20:	de 86       	std	Y+14, r13	; 0x0e
    4a22:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    4a24:	0f b6       	in	r0, 0x3f	; 63
    4a26:	f8 94       	cli
    4a28:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    4a2a:	20 91 a6 06 	lds	r18, 0x06A6
    4a2e:	30 91 a7 06 	lds	r19, 0x06A7
    4a32:	8a 81       	ldd	r24, Y+2	; 0x02
    4a34:	88 2f       	mov	r24, r24
    4a36:	90 e0       	ldi	r25, 0x00	; 0
    4a38:	82 0f       	add	r24, r18
    4a3a:	93 1f       	adc	r25, r19
    4a3c:	fc 01       	movw	r30, r24
    4a3e:	b5 96       	adiw	r30, 0x25	; 37
    4a40:	80 81       	ld	r24, Z
    4a42:	82 30       	cpi	r24, 0x02	; 2
    4a44:	09 f4       	brne	.+2      	; 0x4a48 <xTaskGenericNotifyWait+0x5e>
    4a46:	47 c0       	rjmp	.+142    	; 0x4ad6 <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    4a48:	60 91 a6 06 	lds	r22, 0x06A6
    4a4c:	70 91 a7 06 	lds	r23, 0x06A7
    4a50:	8a 81       	ldd	r24, Y+2	; 0x02
    4a52:	08 2f       	mov	r16, r24
    4a54:	10 e0       	ldi	r17, 0x00	; 0
    4a56:	8a 81       	ldd	r24, Y+2	; 0x02
    4a58:	88 2f       	mov	r24, r24
    4a5a:	90 e0       	ldi	r25, 0x00	; 0
    4a5c:	88 0f       	add	r24, r24
    4a5e:	99 1f       	adc	r25, r25
    4a60:	88 0f       	add	r24, r24
    4a62:	99 1f       	adc	r25, r25
    4a64:	86 0f       	add	r24, r22
    4a66:	97 1f       	adc	r25, r23
    4a68:	fc 01       	movw	r30, r24
    4a6a:	b1 96       	adiw	r30, 0x21	; 33
    4a6c:	20 81       	ld	r18, Z
    4a6e:	31 81       	ldd	r19, Z+1	; 0x01
    4a70:	42 81       	ldd	r20, Z+2	; 0x02
    4a72:	53 81       	ldd	r21, Z+3	; 0x03
    4a74:	8b 81       	ldd	r24, Y+3	; 0x03
    4a76:	9c 81       	ldd	r25, Y+4	; 0x04
    4a78:	ad 81       	ldd	r26, Y+5	; 0x05
    4a7a:	be 81       	ldd	r27, Y+6	; 0x06
    4a7c:	80 95       	com	r24
    4a7e:	90 95       	com	r25
    4a80:	a0 95       	com	r26
    4a82:	b0 95       	com	r27
    4a84:	28 23       	and	r18, r24
    4a86:	39 23       	and	r19, r25
    4a88:	4a 23       	and	r20, r26
    4a8a:	5b 23       	and	r21, r27
    4a8c:	c8 01       	movw	r24, r16
    4a8e:	88 0f       	add	r24, r24
    4a90:	99 1f       	adc	r25, r25
    4a92:	88 0f       	add	r24, r24
    4a94:	99 1f       	adc	r25, r25
    4a96:	86 0f       	add	r24, r22
    4a98:	97 1f       	adc	r25, r23
    4a9a:	fc 01       	movw	r30, r24
    4a9c:	b1 96       	adiw	r30, 0x21	; 33
    4a9e:	20 83       	st	Z, r18
    4aa0:	31 83       	std	Z+1, r19	; 0x01
    4aa2:	42 83       	std	Z+2, r20	; 0x02
    4aa4:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4aa6:	20 91 a6 06 	lds	r18, 0x06A6
    4aaa:	30 91 a7 06 	lds	r19, 0x06A7
    4aae:	8a 81       	ldd	r24, Y+2	; 0x02
    4ab0:	88 2f       	mov	r24, r24
    4ab2:	90 e0       	ldi	r25, 0x00	; 0
    4ab4:	82 0f       	add	r24, r18
    4ab6:	93 1f       	adc	r25, r19
    4ab8:	fc 01       	movw	r30, r24
    4aba:	b5 96       	adiw	r30, 0x25	; 37
    4abc:	81 e0       	ldi	r24, 0x01	; 1
    4abe:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    4ac0:	8d 85       	ldd	r24, Y+13	; 0x0d
    4ac2:	9e 85       	ldd	r25, Y+14	; 0x0e
    4ac4:	00 97       	sbiw	r24, 0x00	; 0
    4ac6:	39 f0       	breq	.+14     	; 0x4ad6 <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4ac8:	8d 85       	ldd	r24, Y+13	; 0x0d
    4aca:	9e 85       	ldd	r25, Y+14	; 0x0e
    4acc:	61 e0       	ldi	r22, 0x01	; 1
    4ace:	0e 94 c4 2b 	call	0x5788	; 0x5788 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    4ad2:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4ad6:	0f 90       	pop	r0
    4ad8:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4ada:	0f b6       	in	r0, 0x3f	; 63
    4adc:	f8 94       	cli
    4ade:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    4ae0:	8b 85       	ldd	r24, Y+11	; 0x0b
    4ae2:	9c 85       	ldd	r25, Y+12	; 0x0c
    4ae4:	00 97       	sbiw	r24, 0x00	; 0
    4ae6:	c9 f0       	breq	.+50     	; 0x4b1a <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    4ae8:	20 91 a6 06 	lds	r18, 0x06A6
    4aec:	30 91 a7 06 	lds	r19, 0x06A7
    4af0:	8a 81       	ldd	r24, Y+2	; 0x02
    4af2:	88 2f       	mov	r24, r24
    4af4:	90 e0       	ldi	r25, 0x00	; 0
    4af6:	88 0f       	add	r24, r24
    4af8:	99 1f       	adc	r25, r25
    4afa:	88 0f       	add	r24, r24
    4afc:	99 1f       	adc	r25, r25
    4afe:	82 0f       	add	r24, r18
    4b00:	93 1f       	adc	r25, r19
    4b02:	fc 01       	movw	r30, r24
    4b04:	b1 96       	adiw	r30, 0x21	; 33
    4b06:	80 81       	ld	r24, Z
    4b08:	91 81       	ldd	r25, Z+1	; 0x01
    4b0a:	a2 81       	ldd	r26, Z+2	; 0x02
    4b0c:	b3 81       	ldd	r27, Z+3	; 0x03
    4b0e:	eb 85       	ldd	r30, Y+11	; 0x0b
    4b10:	fc 85       	ldd	r31, Y+12	; 0x0c
    4b12:	80 83       	st	Z, r24
    4b14:	91 83       	std	Z+1, r25	; 0x01
    4b16:	a2 83       	std	Z+2, r26	; 0x02
    4b18:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    4b1a:	20 91 a6 06 	lds	r18, 0x06A6
    4b1e:	30 91 a7 06 	lds	r19, 0x06A7
    4b22:	8a 81       	ldd	r24, Y+2	; 0x02
    4b24:	88 2f       	mov	r24, r24
    4b26:	90 e0       	ldi	r25, 0x00	; 0
    4b28:	82 0f       	add	r24, r18
    4b2a:	93 1f       	adc	r25, r19
    4b2c:	fc 01       	movw	r30, r24
    4b2e:	b5 96       	adiw	r30, 0x25	; 37
    4b30:	80 81       	ld	r24, Z
    4b32:	82 30       	cpi	r24, 0x02	; 2
    4b34:	11 f0       	breq	.+4      	; 0x4b3a <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    4b36:	19 82       	std	Y+1, r1	; 0x01
    4b38:	31 c0       	rjmp	.+98     	; 0x4b9c <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    4b3a:	60 91 a6 06 	lds	r22, 0x06A6
    4b3e:	70 91 a7 06 	lds	r23, 0x06A7
    4b42:	8a 81       	ldd	r24, Y+2	; 0x02
    4b44:	08 2f       	mov	r16, r24
    4b46:	10 e0       	ldi	r17, 0x00	; 0
    4b48:	8a 81       	ldd	r24, Y+2	; 0x02
    4b4a:	88 2f       	mov	r24, r24
    4b4c:	90 e0       	ldi	r25, 0x00	; 0
    4b4e:	88 0f       	add	r24, r24
    4b50:	99 1f       	adc	r25, r25
    4b52:	88 0f       	add	r24, r24
    4b54:	99 1f       	adc	r25, r25
    4b56:	86 0f       	add	r24, r22
    4b58:	97 1f       	adc	r25, r23
    4b5a:	fc 01       	movw	r30, r24
    4b5c:	b1 96       	adiw	r30, 0x21	; 33
    4b5e:	20 81       	ld	r18, Z
    4b60:	31 81       	ldd	r19, Z+1	; 0x01
    4b62:	42 81       	ldd	r20, Z+2	; 0x02
    4b64:	53 81       	ldd	r21, Z+3	; 0x03
    4b66:	8f 81       	ldd	r24, Y+7	; 0x07
    4b68:	98 85       	ldd	r25, Y+8	; 0x08
    4b6a:	a9 85       	ldd	r26, Y+9	; 0x09
    4b6c:	ba 85       	ldd	r27, Y+10	; 0x0a
    4b6e:	80 95       	com	r24
    4b70:	90 95       	com	r25
    4b72:	a0 95       	com	r26
    4b74:	b0 95       	com	r27
    4b76:	28 23       	and	r18, r24
    4b78:	39 23       	and	r19, r25
    4b7a:	4a 23       	and	r20, r26
    4b7c:	5b 23       	and	r21, r27
    4b7e:	c8 01       	movw	r24, r16
    4b80:	88 0f       	add	r24, r24
    4b82:	99 1f       	adc	r25, r25
    4b84:	88 0f       	add	r24, r24
    4b86:	99 1f       	adc	r25, r25
    4b88:	86 0f       	add	r24, r22
    4b8a:	97 1f       	adc	r25, r23
    4b8c:	fc 01       	movw	r30, r24
    4b8e:	b1 96       	adiw	r30, 0x21	; 33
    4b90:	20 83       	st	Z, r18
    4b92:	31 83       	std	Z+1, r19	; 0x01
    4b94:	42 83       	std	Z+2, r20	; 0x02
    4b96:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    4b98:	81 e0       	ldi	r24, 0x01	; 1
    4b9a:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    4b9c:	20 91 a6 06 	lds	r18, 0x06A6
    4ba0:	30 91 a7 06 	lds	r19, 0x06A7
    4ba4:	8a 81       	ldd	r24, Y+2	; 0x02
    4ba6:	88 2f       	mov	r24, r24
    4ba8:	90 e0       	ldi	r25, 0x00	; 0
    4baa:	82 0f       	add	r24, r18
    4bac:	93 1f       	adc	r25, r19
    4bae:	fc 01       	movw	r30, r24
    4bb0:	b5 96       	adiw	r30, 0x25	; 37
    4bb2:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    4bb4:	0f 90       	pop	r0
    4bb6:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    4bb8:	89 81       	ldd	r24, Y+1	; 0x01
    }
    4bba:	2e 96       	adiw	r28, 0x0e	; 14
    4bbc:	0f b6       	in	r0, 0x3f	; 63
    4bbe:	f8 94       	cli
    4bc0:	de bf       	out	0x3e, r29	; 62
    4bc2:	0f be       	out	0x3f, r0	; 63
    4bc4:	cd bf       	out	0x3d, r28	; 61
    4bc6:	cf 91       	pop	r28
    4bc8:	df 91       	pop	r29
    4bca:	1f 91       	pop	r17
    4bcc:	0f 91       	pop	r16
    4bce:	ff 90       	pop	r15
    4bd0:	ef 90       	pop	r14
    4bd2:	df 90       	pop	r13
    4bd4:	cf 90       	pop	r12
    4bd6:	08 95       	ret

00004bd8 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    4bd8:	ef 92       	push	r14
    4bda:	ff 92       	push	r15
    4bdc:	0f 93       	push	r16
    4bde:	1f 93       	push	r17
    4be0:	df 93       	push	r29
    4be2:	cf 93       	push	r28
    4be4:	cd b7       	in	r28, 0x3d	; 61
    4be6:	de b7       	in	r29, 0x3e	; 62
    4be8:	64 97       	sbiw	r28, 0x14	; 20
    4bea:	0f b6       	in	r0, 0x3f	; 63
    4bec:	f8 94       	cli
    4bee:	de bf       	out	0x3e, r29	; 62
    4bf0:	0f be       	out	0x3f, r0	; 63
    4bf2:	cd bf       	out	0x3d, r28	; 61
    4bf4:	9a 87       	std	Y+10, r25	; 0x0a
    4bf6:	89 87       	std	Y+9, r24	; 0x09
    4bf8:	6b 87       	std	Y+11, r22	; 0x0b
    4bfa:	2c 87       	std	Y+12, r18	; 0x0c
    4bfc:	3d 87       	std	Y+13, r19	; 0x0d
    4bfe:	4e 87       	std	Y+14, r20	; 0x0e
    4c00:	5f 87       	std	Y+15, r21	; 0x0f
    4c02:	08 8b       	std	Y+16, r16	; 0x10
    4c04:	fa 8a       	std	Y+18, r15	; 0x12
    4c06:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    4c08:	81 e0       	ldi	r24, 0x01	; 1
    4c0a:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    4c0c:	89 85       	ldd	r24, Y+9	; 0x09
    4c0e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4c10:	98 87       	std	Y+8, r25	; 0x08
    4c12:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    4c14:	0f b6       	in	r0, 0x3f	; 63
    4c16:	f8 94       	cli
    4c18:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    4c1a:	89 89       	ldd	r24, Y+17	; 0x11
    4c1c:	9a 89       	ldd	r25, Y+18	; 0x12
    4c1e:	00 97       	sbiw	r24, 0x00	; 0
    4c20:	b9 f0       	breq	.+46     	; 0x4c50 <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    4c22:	8b 85       	ldd	r24, Y+11	; 0x0b
    4c24:	88 2f       	mov	r24, r24
    4c26:	90 e0       	ldi	r25, 0x00	; 0
    4c28:	2f 81       	ldd	r18, Y+7	; 0x07
    4c2a:	38 85       	ldd	r19, Y+8	; 0x08
    4c2c:	88 0f       	add	r24, r24
    4c2e:	99 1f       	adc	r25, r25
    4c30:	88 0f       	add	r24, r24
    4c32:	99 1f       	adc	r25, r25
    4c34:	82 0f       	add	r24, r18
    4c36:	93 1f       	adc	r25, r19
    4c38:	fc 01       	movw	r30, r24
    4c3a:	b1 96       	adiw	r30, 0x21	; 33
    4c3c:	80 81       	ld	r24, Z
    4c3e:	91 81       	ldd	r25, Z+1	; 0x01
    4c40:	a2 81       	ldd	r26, Z+2	; 0x02
    4c42:	b3 81       	ldd	r27, Z+3	; 0x03
    4c44:	e9 89       	ldd	r30, Y+17	; 0x11
    4c46:	fa 89       	ldd	r31, Y+18	; 0x12
    4c48:	80 83       	st	Z, r24
    4c4a:	91 83       	std	Z+1, r25	; 0x01
    4c4c:	a2 83       	std	Z+2, r26	; 0x02
    4c4e:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4c50:	8b 85       	ldd	r24, Y+11	; 0x0b
    4c52:	28 2f       	mov	r18, r24
    4c54:	30 e0       	ldi	r19, 0x00	; 0
    4c56:	8f 81       	ldd	r24, Y+7	; 0x07
    4c58:	98 85       	ldd	r25, Y+8	; 0x08
    4c5a:	82 0f       	add	r24, r18
    4c5c:	93 1f       	adc	r25, r19
    4c5e:	fc 01       	movw	r30, r24
    4c60:	b5 96       	adiw	r30, 0x25	; 37
    4c62:	80 81       	ld	r24, Z
    4c64:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    4c66:	8b 85       	ldd	r24, Y+11	; 0x0b
    4c68:	28 2f       	mov	r18, r24
    4c6a:	30 e0       	ldi	r19, 0x00	; 0
    4c6c:	8f 81       	ldd	r24, Y+7	; 0x07
    4c6e:	98 85       	ldd	r25, Y+8	; 0x08
    4c70:	82 0f       	add	r24, r18
    4c72:	93 1f       	adc	r25, r19
    4c74:	fc 01       	movw	r30, r24
    4c76:	b5 96       	adiw	r30, 0x25	; 37
    4c78:	82 e0       	ldi	r24, 0x02	; 2
    4c7a:	80 83       	st	Z, r24

            switch( eAction )
    4c7c:	88 89       	ldd	r24, Y+16	; 0x10
    4c7e:	28 2f       	mov	r18, r24
    4c80:	30 e0       	ldi	r19, 0x00	; 0
    4c82:	3c 8b       	std	Y+20, r19	; 0x14
    4c84:	2b 8b       	std	Y+19, r18	; 0x13
    4c86:	8b 89       	ldd	r24, Y+19	; 0x13
    4c88:	9c 89       	ldd	r25, Y+20	; 0x14
    4c8a:	82 30       	cpi	r24, 0x02	; 2
    4c8c:	91 05       	cpc	r25, r1
    4c8e:	09 f4       	brne	.+2      	; 0x4c92 <xTaskGenericNotify+0xba>
    4c90:	46 c0       	rjmp	.+140    	; 0x4d1e <xTaskGenericNotify+0x146>
    4c92:	2b 89       	ldd	r18, Y+19	; 0x13
    4c94:	3c 89       	ldd	r19, Y+20	; 0x14
    4c96:	23 30       	cpi	r18, 0x03	; 3
    4c98:	31 05       	cpc	r19, r1
    4c9a:	34 f4       	brge	.+12     	; 0x4ca8 <xTaskGenericNotify+0xd0>
    4c9c:	8b 89       	ldd	r24, Y+19	; 0x13
    4c9e:	9c 89       	ldd	r25, Y+20	; 0x14
    4ca0:	81 30       	cpi	r24, 0x01	; 1
    4ca2:	91 05       	cpc	r25, r1
    4ca4:	71 f0       	breq	.+28     	; 0x4cc2 <xTaskGenericNotify+0xea>
    4ca6:	93 c0       	rjmp	.+294    	; 0x4dce <xTaskGenericNotify+0x1f6>
    4ca8:	2b 89       	ldd	r18, Y+19	; 0x13
    4caa:	3c 89       	ldd	r19, Y+20	; 0x14
    4cac:	23 30       	cpi	r18, 0x03	; 3
    4cae:	31 05       	cpc	r19, r1
    4cb0:	09 f4       	brne	.+2      	; 0x4cb4 <xTaskGenericNotify+0xdc>
    4cb2:	5d c0       	rjmp	.+186    	; 0x4d6e <xTaskGenericNotify+0x196>
    4cb4:	8b 89       	ldd	r24, Y+19	; 0x13
    4cb6:	9c 89       	ldd	r25, Y+20	; 0x14
    4cb8:	84 30       	cpi	r24, 0x04	; 4
    4cba:	91 05       	cpc	r25, r1
    4cbc:	09 f4       	brne	.+2      	; 0x4cc0 <xTaskGenericNotify+0xe8>
    4cbe:	6d c0       	rjmp	.+218    	; 0x4d9a <xTaskGenericNotify+0x1c2>
    4cc0:	86 c0       	rjmp	.+268    	; 0x4dce <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    4cc2:	8b 85       	ldd	r24, Y+11	; 0x0b
    4cc4:	08 2f       	mov	r16, r24
    4cc6:	10 e0       	ldi	r17, 0x00	; 0
    4cc8:	8b 85       	ldd	r24, Y+11	; 0x0b
    4cca:	88 2f       	mov	r24, r24
    4ccc:	90 e0       	ldi	r25, 0x00	; 0
    4cce:	2f 81       	ldd	r18, Y+7	; 0x07
    4cd0:	38 85       	ldd	r19, Y+8	; 0x08
    4cd2:	88 0f       	add	r24, r24
    4cd4:	99 1f       	adc	r25, r25
    4cd6:	88 0f       	add	r24, r24
    4cd8:	99 1f       	adc	r25, r25
    4cda:	82 0f       	add	r24, r18
    4cdc:	93 1f       	adc	r25, r19
    4cde:	fc 01       	movw	r30, r24
    4ce0:	b1 96       	adiw	r30, 0x21	; 33
    4ce2:	20 81       	ld	r18, Z
    4ce4:	31 81       	ldd	r19, Z+1	; 0x01
    4ce6:	42 81       	ldd	r20, Z+2	; 0x02
    4ce8:	53 81       	ldd	r21, Z+3	; 0x03
    4cea:	8c 85       	ldd	r24, Y+12	; 0x0c
    4cec:	9d 85       	ldd	r25, Y+13	; 0x0d
    4cee:	ae 85       	ldd	r26, Y+14	; 0x0e
    4cf0:	bf 85       	ldd	r27, Y+15	; 0x0f
    4cf2:	ba 01       	movw	r22, r20
    4cf4:	a9 01       	movw	r20, r18
    4cf6:	48 2b       	or	r20, r24
    4cf8:	59 2b       	or	r21, r25
    4cfa:	6a 2b       	or	r22, r26
    4cfc:	7b 2b       	or	r23, r27
    4cfe:	2f 81       	ldd	r18, Y+7	; 0x07
    4d00:	38 85       	ldd	r19, Y+8	; 0x08
    4d02:	c8 01       	movw	r24, r16
    4d04:	88 0f       	add	r24, r24
    4d06:	99 1f       	adc	r25, r25
    4d08:	88 0f       	add	r24, r24
    4d0a:	99 1f       	adc	r25, r25
    4d0c:	82 0f       	add	r24, r18
    4d0e:	93 1f       	adc	r25, r19
    4d10:	fc 01       	movw	r30, r24
    4d12:	b1 96       	adiw	r30, 0x21	; 33
    4d14:	40 83       	st	Z, r20
    4d16:	51 83       	std	Z+1, r21	; 0x01
    4d18:	62 83       	std	Z+2, r22	; 0x02
    4d1a:	73 83       	std	Z+3, r23	; 0x03
    4d1c:	58 c0       	rjmp	.+176    	; 0x4dce <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    4d1e:	8b 85       	ldd	r24, Y+11	; 0x0b
    4d20:	08 2f       	mov	r16, r24
    4d22:	10 e0       	ldi	r17, 0x00	; 0
    4d24:	2f 81       	ldd	r18, Y+7	; 0x07
    4d26:	38 85       	ldd	r19, Y+8	; 0x08
    4d28:	c8 01       	movw	r24, r16
    4d2a:	88 0f       	add	r24, r24
    4d2c:	99 1f       	adc	r25, r25
    4d2e:	88 0f       	add	r24, r24
    4d30:	99 1f       	adc	r25, r25
    4d32:	82 0f       	add	r24, r18
    4d34:	93 1f       	adc	r25, r19
    4d36:	fc 01       	movw	r30, r24
    4d38:	b1 96       	adiw	r30, 0x21	; 33
    4d3a:	80 81       	ld	r24, Z
    4d3c:	91 81       	ldd	r25, Z+1	; 0x01
    4d3e:	a2 81       	ldd	r26, Z+2	; 0x02
    4d40:	b3 81       	ldd	r27, Z+3	; 0x03
    4d42:	ac 01       	movw	r20, r24
    4d44:	bd 01       	movw	r22, r26
    4d46:	4f 5f       	subi	r20, 0xFF	; 255
    4d48:	5f 4f       	sbci	r21, 0xFF	; 255
    4d4a:	6f 4f       	sbci	r22, 0xFF	; 255
    4d4c:	7f 4f       	sbci	r23, 0xFF	; 255
    4d4e:	2f 81       	ldd	r18, Y+7	; 0x07
    4d50:	38 85       	ldd	r19, Y+8	; 0x08
    4d52:	c8 01       	movw	r24, r16
    4d54:	88 0f       	add	r24, r24
    4d56:	99 1f       	adc	r25, r25
    4d58:	88 0f       	add	r24, r24
    4d5a:	99 1f       	adc	r25, r25
    4d5c:	82 0f       	add	r24, r18
    4d5e:	93 1f       	adc	r25, r19
    4d60:	fc 01       	movw	r30, r24
    4d62:	b1 96       	adiw	r30, 0x21	; 33
    4d64:	40 83       	st	Z, r20
    4d66:	51 83       	std	Z+1, r21	; 0x01
    4d68:	62 83       	std	Z+2, r22	; 0x02
    4d6a:	73 83       	std	Z+3, r23	; 0x03
    4d6c:	30 c0       	rjmp	.+96     	; 0x4dce <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4d6e:	8b 85       	ldd	r24, Y+11	; 0x0b
    4d70:	88 2f       	mov	r24, r24
    4d72:	90 e0       	ldi	r25, 0x00	; 0
    4d74:	2f 81       	ldd	r18, Y+7	; 0x07
    4d76:	38 85       	ldd	r19, Y+8	; 0x08
    4d78:	88 0f       	add	r24, r24
    4d7a:	99 1f       	adc	r25, r25
    4d7c:	88 0f       	add	r24, r24
    4d7e:	99 1f       	adc	r25, r25
    4d80:	82 0f       	add	r24, r18
    4d82:	93 1f       	adc	r25, r19
    4d84:	fc 01       	movw	r30, r24
    4d86:	b1 96       	adiw	r30, 0x21	; 33
    4d88:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d8a:	9d 85       	ldd	r25, Y+13	; 0x0d
    4d8c:	ae 85       	ldd	r26, Y+14	; 0x0e
    4d8e:	bf 85       	ldd	r27, Y+15	; 0x0f
    4d90:	80 83       	st	Z, r24
    4d92:	91 83       	std	Z+1, r25	; 0x01
    4d94:	a2 83       	std	Z+2, r26	; 0x02
    4d96:	b3 83       	std	Z+3, r27	; 0x03
    4d98:	1a c0       	rjmp	.+52     	; 0x4dce <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4d9a:	8d 81       	ldd	r24, Y+5	; 0x05
    4d9c:	82 30       	cpi	r24, 0x02	; 2
    4d9e:	b1 f0       	breq	.+44     	; 0x4dcc <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4da0:	8b 85       	ldd	r24, Y+11	; 0x0b
    4da2:	88 2f       	mov	r24, r24
    4da4:	90 e0       	ldi	r25, 0x00	; 0
    4da6:	2f 81       	ldd	r18, Y+7	; 0x07
    4da8:	38 85       	ldd	r19, Y+8	; 0x08
    4daa:	88 0f       	add	r24, r24
    4dac:	99 1f       	adc	r25, r25
    4dae:	88 0f       	add	r24, r24
    4db0:	99 1f       	adc	r25, r25
    4db2:	82 0f       	add	r24, r18
    4db4:	93 1f       	adc	r25, r19
    4db6:	fc 01       	movw	r30, r24
    4db8:	b1 96       	adiw	r30, 0x21	; 33
    4dba:	8c 85       	ldd	r24, Y+12	; 0x0c
    4dbc:	9d 85       	ldd	r25, Y+13	; 0x0d
    4dbe:	ae 85       	ldd	r26, Y+14	; 0x0e
    4dc0:	bf 85       	ldd	r27, Y+15	; 0x0f
    4dc2:	80 83       	st	Z, r24
    4dc4:	91 83       	std	Z+1, r25	; 0x01
    4dc6:	a2 83       	std	Z+2, r26	; 0x02
    4dc8:	b3 83       	std	Z+3, r27	; 0x03
    4dca:	01 c0       	rjmp	.+2      	; 0x4dce <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    4dcc:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4dce:	8d 81       	ldd	r24, Y+5	; 0x05
    4dd0:	81 30       	cpi	r24, 0x01	; 1
    4dd2:	09 f0       	breq	.+2      	; 0x4dd6 <xTaskGenericNotify+0x1fe>
    4dd4:	af c0       	rjmp	.+350    	; 0x4f34 <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    4dd6:	ef 81       	ldd	r30, Y+7	; 0x07
    4dd8:	f8 85       	ldd	r31, Y+8	; 0x08
    4dda:	82 85       	ldd	r24, Z+10	; 0x0a
    4ddc:	93 85       	ldd	r25, Z+11	; 0x0b
    4dde:	9c 83       	std	Y+4, r25	; 0x04
    4de0:	8b 83       	std	Y+3, r24	; 0x03
    4de2:	ef 81       	ldd	r30, Y+7	; 0x07
    4de4:	f8 85       	ldd	r31, Y+8	; 0x08
    4de6:	a4 81       	ldd	r26, Z+4	; 0x04
    4de8:	b5 81       	ldd	r27, Z+5	; 0x05
    4dea:	ef 81       	ldd	r30, Y+7	; 0x07
    4dec:	f8 85       	ldd	r31, Y+8	; 0x08
    4dee:	86 81       	ldd	r24, Z+6	; 0x06
    4df0:	97 81       	ldd	r25, Z+7	; 0x07
    4df2:	15 96       	adiw	r26, 0x05	; 5
    4df4:	9c 93       	st	X, r25
    4df6:	8e 93       	st	-X, r24
    4df8:	14 97       	sbiw	r26, 0x04	; 4
    4dfa:	ef 81       	ldd	r30, Y+7	; 0x07
    4dfc:	f8 85       	ldd	r31, Y+8	; 0x08
    4dfe:	a6 81       	ldd	r26, Z+6	; 0x06
    4e00:	b7 81       	ldd	r27, Z+7	; 0x07
    4e02:	ef 81       	ldd	r30, Y+7	; 0x07
    4e04:	f8 85       	ldd	r31, Y+8	; 0x08
    4e06:	84 81       	ldd	r24, Z+4	; 0x04
    4e08:	95 81       	ldd	r25, Z+5	; 0x05
    4e0a:	13 96       	adiw	r26, 0x03	; 3
    4e0c:	9c 93       	st	X, r25
    4e0e:	8e 93       	st	-X, r24
    4e10:	12 97       	sbiw	r26, 0x02	; 2
    4e12:	eb 81       	ldd	r30, Y+3	; 0x03
    4e14:	fc 81       	ldd	r31, Y+4	; 0x04
    4e16:	21 81       	ldd	r18, Z+1	; 0x01
    4e18:	32 81       	ldd	r19, Z+2	; 0x02
    4e1a:	8f 81       	ldd	r24, Y+7	; 0x07
    4e1c:	98 85       	ldd	r25, Y+8	; 0x08
    4e1e:	02 96       	adiw	r24, 0x02	; 2
    4e20:	28 17       	cp	r18, r24
    4e22:	39 07       	cpc	r19, r25
    4e24:	41 f4       	brne	.+16     	; 0x4e36 <xTaskGenericNotify+0x25e>
    4e26:	ef 81       	ldd	r30, Y+7	; 0x07
    4e28:	f8 85       	ldd	r31, Y+8	; 0x08
    4e2a:	86 81       	ldd	r24, Z+6	; 0x06
    4e2c:	97 81       	ldd	r25, Z+7	; 0x07
    4e2e:	eb 81       	ldd	r30, Y+3	; 0x03
    4e30:	fc 81       	ldd	r31, Y+4	; 0x04
    4e32:	92 83       	std	Z+2, r25	; 0x02
    4e34:	81 83       	std	Z+1, r24	; 0x01
    4e36:	ef 81       	ldd	r30, Y+7	; 0x07
    4e38:	f8 85       	ldd	r31, Y+8	; 0x08
    4e3a:	13 86       	std	Z+11, r1	; 0x0b
    4e3c:	12 86       	std	Z+10, r1	; 0x0a
    4e3e:	eb 81       	ldd	r30, Y+3	; 0x03
    4e40:	fc 81       	ldd	r31, Y+4	; 0x04
    4e42:	80 81       	ld	r24, Z
    4e44:	81 50       	subi	r24, 0x01	; 1
    4e46:	eb 81       	ldd	r30, Y+3	; 0x03
    4e48:	fc 81       	ldd	r31, Y+4	; 0x04
    4e4a:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    4e4c:	ef 81       	ldd	r30, Y+7	; 0x07
    4e4e:	f8 85       	ldd	r31, Y+8	; 0x08
    4e50:	96 89       	ldd	r25, Z+22	; 0x16
    4e52:	80 91 ac 06 	lds	r24, 0x06AC
    4e56:	89 17       	cp	r24, r25
    4e58:	28 f4       	brcc	.+10     	; 0x4e64 <xTaskGenericNotify+0x28c>
    4e5a:	ef 81       	ldd	r30, Y+7	; 0x07
    4e5c:	f8 85       	ldd	r31, Y+8	; 0x08
    4e5e:	86 89       	ldd	r24, Z+22	; 0x16
    4e60:	80 93 ac 06 	sts	0x06AC, r24
    4e64:	ef 81       	ldd	r30, Y+7	; 0x07
    4e66:	f8 85       	ldd	r31, Y+8	; 0x08
    4e68:	86 89       	ldd	r24, Z+22	; 0x16
    4e6a:	28 2f       	mov	r18, r24
    4e6c:	30 e0       	ldi	r19, 0x00	; 0
    4e6e:	c9 01       	movw	r24, r18
    4e70:	88 0f       	add	r24, r24
    4e72:	99 1f       	adc	r25, r25
    4e74:	88 0f       	add	r24, r24
    4e76:	99 1f       	adc	r25, r25
    4e78:	88 0f       	add	r24, r24
    4e7a:	99 1f       	adc	r25, r25
    4e7c:	82 0f       	add	r24, r18
    4e7e:	93 1f       	adc	r25, r19
    4e80:	fc 01       	movw	r30, r24
    4e82:	e8 54       	subi	r30, 0x48	; 72
    4e84:	f9 4f       	sbci	r31, 0xF9	; 249
    4e86:	81 81       	ldd	r24, Z+1	; 0x01
    4e88:	92 81       	ldd	r25, Z+2	; 0x02
    4e8a:	9a 83       	std	Y+2, r25	; 0x02
    4e8c:	89 83       	std	Y+1, r24	; 0x01
    4e8e:	ef 81       	ldd	r30, Y+7	; 0x07
    4e90:	f8 85       	ldd	r31, Y+8	; 0x08
    4e92:	89 81       	ldd	r24, Y+1	; 0x01
    4e94:	9a 81       	ldd	r25, Y+2	; 0x02
    4e96:	95 83       	std	Z+5, r25	; 0x05
    4e98:	84 83       	std	Z+4, r24	; 0x04
    4e9a:	e9 81       	ldd	r30, Y+1	; 0x01
    4e9c:	fa 81       	ldd	r31, Y+2	; 0x02
    4e9e:	84 81       	ldd	r24, Z+4	; 0x04
    4ea0:	95 81       	ldd	r25, Z+5	; 0x05
    4ea2:	ef 81       	ldd	r30, Y+7	; 0x07
    4ea4:	f8 85       	ldd	r31, Y+8	; 0x08
    4ea6:	97 83       	std	Z+7, r25	; 0x07
    4ea8:	86 83       	std	Z+6, r24	; 0x06
    4eaa:	e9 81       	ldd	r30, Y+1	; 0x01
    4eac:	fa 81       	ldd	r31, Y+2	; 0x02
    4eae:	04 80       	ldd	r0, Z+4	; 0x04
    4eb0:	f5 81       	ldd	r31, Z+5	; 0x05
    4eb2:	e0 2d       	mov	r30, r0
    4eb4:	8f 81       	ldd	r24, Y+7	; 0x07
    4eb6:	98 85       	ldd	r25, Y+8	; 0x08
    4eb8:	02 96       	adiw	r24, 0x02	; 2
    4eba:	93 83       	std	Z+3, r25	; 0x03
    4ebc:	82 83       	std	Z+2, r24	; 0x02
    4ebe:	8f 81       	ldd	r24, Y+7	; 0x07
    4ec0:	98 85       	ldd	r25, Y+8	; 0x08
    4ec2:	02 96       	adiw	r24, 0x02	; 2
    4ec4:	e9 81       	ldd	r30, Y+1	; 0x01
    4ec6:	fa 81       	ldd	r31, Y+2	; 0x02
    4ec8:	95 83       	std	Z+5, r25	; 0x05
    4eca:	84 83       	std	Z+4, r24	; 0x04
    4ecc:	ef 81       	ldd	r30, Y+7	; 0x07
    4ece:	f8 85       	ldd	r31, Y+8	; 0x08
    4ed0:	86 89       	ldd	r24, Z+22	; 0x16
    4ed2:	28 2f       	mov	r18, r24
    4ed4:	30 e0       	ldi	r19, 0x00	; 0
    4ed6:	c9 01       	movw	r24, r18
    4ed8:	88 0f       	add	r24, r24
    4eda:	99 1f       	adc	r25, r25
    4edc:	88 0f       	add	r24, r24
    4ede:	99 1f       	adc	r25, r25
    4ee0:	88 0f       	add	r24, r24
    4ee2:	99 1f       	adc	r25, r25
    4ee4:	82 0f       	add	r24, r18
    4ee6:	93 1f       	adc	r25, r19
    4ee8:	88 54       	subi	r24, 0x48	; 72
    4eea:	99 4f       	sbci	r25, 0xF9	; 249
    4eec:	ef 81       	ldd	r30, Y+7	; 0x07
    4eee:	f8 85       	ldd	r31, Y+8	; 0x08
    4ef0:	93 87       	std	Z+11, r25	; 0x0b
    4ef2:	82 87       	std	Z+10, r24	; 0x0a
    4ef4:	ef 81       	ldd	r30, Y+7	; 0x07
    4ef6:	f8 85       	ldd	r31, Y+8	; 0x08
    4ef8:	86 89       	ldd	r24, Z+22	; 0x16
    4efa:	28 2f       	mov	r18, r24
    4efc:	30 e0       	ldi	r19, 0x00	; 0
    4efe:	c9 01       	movw	r24, r18
    4f00:	88 0f       	add	r24, r24
    4f02:	99 1f       	adc	r25, r25
    4f04:	88 0f       	add	r24, r24
    4f06:	99 1f       	adc	r25, r25
    4f08:	88 0f       	add	r24, r24
    4f0a:	99 1f       	adc	r25, r25
    4f0c:	82 0f       	add	r24, r18
    4f0e:	93 1f       	adc	r25, r19
    4f10:	fc 01       	movw	r30, r24
    4f12:	e8 54       	subi	r30, 0x48	; 72
    4f14:	f9 4f       	sbci	r31, 0xF9	; 249
    4f16:	80 81       	ld	r24, Z
    4f18:	8f 5f       	subi	r24, 0xFF	; 255
    4f1a:	80 83       	st	Z, r24
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4f1c:	ef 81       	ldd	r30, Y+7	; 0x07
    4f1e:	f8 85       	ldd	r31, Y+8	; 0x08
    4f20:	96 89       	ldd	r25, Z+22	; 0x16
    4f22:	e0 91 a6 06 	lds	r30, 0x06A6
    4f26:	f0 91 a7 06 	lds	r31, 0x06A7
    4f2a:	86 89       	ldd	r24, Z+22	; 0x16
    4f2c:	89 17       	cp	r24, r25
    4f2e:	10 f4       	brcc	.+4      	; 0x4f34 <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    4f30:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4f34:	0f 90       	pop	r0
    4f36:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    4f38:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    4f3a:	64 96       	adiw	r28, 0x14	; 20
    4f3c:	0f b6       	in	r0, 0x3f	; 63
    4f3e:	f8 94       	cli
    4f40:	de bf       	out	0x3e, r29	; 62
    4f42:	0f be       	out	0x3f, r0	; 63
    4f44:	cd bf       	out	0x3d, r28	; 61
    4f46:	cf 91       	pop	r28
    4f48:	df 91       	pop	r29
    4f4a:	1f 91       	pop	r17
    4f4c:	0f 91       	pop	r16
    4f4e:	ff 90       	pop	r15
    4f50:	ef 90       	pop	r14
    4f52:	08 95       	ret

00004f54 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    4f54:	cf 92       	push	r12
    4f56:	df 92       	push	r13
    4f58:	ef 92       	push	r14
    4f5a:	ff 92       	push	r15
    4f5c:	0f 93       	push	r16
    4f5e:	1f 93       	push	r17
    4f60:	df 93       	push	r29
    4f62:	cf 93       	push	r28
    4f64:	cd b7       	in	r28, 0x3d	; 61
    4f66:	de b7       	in	r29, 0x3e	; 62
    4f68:	69 97       	sbiw	r28, 0x19	; 25
    4f6a:	0f b6       	in	r0, 0x3f	; 63
    4f6c:	f8 94       	cli
    4f6e:	de bf       	out	0x3e, r29	; 62
    4f70:	0f be       	out	0x3f, r0	; 63
    4f72:	cd bf       	out	0x3d, r28	; 61
    4f74:	9d 87       	std	Y+13, r25	; 0x0d
    4f76:	8c 87       	std	Y+12, r24	; 0x0c
    4f78:	6e 87       	std	Y+14, r22	; 0x0e
    4f7a:	2f 87       	std	Y+15, r18	; 0x0f
    4f7c:	38 8b       	std	Y+16, r19	; 0x10
    4f7e:	49 8b       	std	Y+17, r20	; 0x11
    4f80:	5a 8b       	std	Y+18, r21	; 0x12
    4f82:	0b 8b       	std	Y+19, r16	; 0x13
    4f84:	fd 8a       	std	Y+21, r15	; 0x15
    4f86:	ec 8a       	std	Y+20, r14	; 0x14
    4f88:	df 8a       	std	Y+23, r13	; 0x17
    4f8a:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    4f8c:	81 e0       	ldi	r24, 0x01	; 1
    4f8e:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    4f90:	8c 85       	ldd	r24, Y+12	; 0x0c
    4f92:	9d 85       	ldd	r25, Y+13	; 0x0d
    4f94:	9b 87       	std	Y+11, r25	; 0x0b
    4f96:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4f98:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    4f9a:	8c 89       	ldd	r24, Y+20	; 0x14
    4f9c:	9d 89       	ldd	r25, Y+21	; 0x15
    4f9e:	00 97       	sbiw	r24, 0x00	; 0
    4fa0:	b9 f0       	breq	.+46     	; 0x4fd0 <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    4fa2:	8e 85       	ldd	r24, Y+14	; 0x0e
    4fa4:	88 2f       	mov	r24, r24
    4fa6:	90 e0       	ldi	r25, 0x00	; 0
    4fa8:	2a 85       	ldd	r18, Y+10	; 0x0a
    4faa:	3b 85       	ldd	r19, Y+11	; 0x0b
    4fac:	88 0f       	add	r24, r24
    4fae:	99 1f       	adc	r25, r25
    4fb0:	88 0f       	add	r24, r24
    4fb2:	99 1f       	adc	r25, r25
    4fb4:	82 0f       	add	r24, r18
    4fb6:	93 1f       	adc	r25, r19
    4fb8:	fc 01       	movw	r30, r24
    4fba:	b1 96       	adiw	r30, 0x21	; 33
    4fbc:	80 81       	ld	r24, Z
    4fbe:	91 81       	ldd	r25, Z+1	; 0x01
    4fc0:	a2 81       	ldd	r26, Z+2	; 0x02
    4fc2:	b3 81       	ldd	r27, Z+3	; 0x03
    4fc4:	ec 89       	ldd	r30, Y+20	; 0x14
    4fc6:	fd 89       	ldd	r31, Y+21	; 0x15
    4fc8:	80 83       	st	Z, r24
    4fca:	91 83       	std	Z+1, r25	; 0x01
    4fcc:	a2 83       	std	Z+2, r26	; 0x02
    4fce:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4fd0:	8e 85       	ldd	r24, Y+14	; 0x0e
    4fd2:	28 2f       	mov	r18, r24
    4fd4:	30 e0       	ldi	r19, 0x00	; 0
    4fd6:	8a 85       	ldd	r24, Y+10	; 0x0a
    4fd8:	9b 85       	ldd	r25, Y+11	; 0x0b
    4fda:	82 0f       	add	r24, r18
    4fdc:	93 1f       	adc	r25, r19
    4fde:	fc 01       	movw	r30, r24
    4fe0:	b5 96       	adiw	r30, 0x25	; 37
    4fe2:	80 81       	ld	r24, Z
    4fe4:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    4fe6:	8e 85       	ldd	r24, Y+14	; 0x0e
    4fe8:	28 2f       	mov	r18, r24
    4fea:	30 e0       	ldi	r19, 0x00	; 0
    4fec:	8a 85       	ldd	r24, Y+10	; 0x0a
    4fee:	9b 85       	ldd	r25, Y+11	; 0x0b
    4ff0:	82 0f       	add	r24, r18
    4ff2:	93 1f       	adc	r25, r19
    4ff4:	fc 01       	movw	r30, r24
    4ff6:	b5 96       	adiw	r30, 0x25	; 37
    4ff8:	82 e0       	ldi	r24, 0x02	; 2
    4ffa:	80 83       	st	Z, r24

            switch( eAction )
    4ffc:	8b 89       	ldd	r24, Y+19	; 0x13
    4ffe:	28 2f       	mov	r18, r24
    5000:	30 e0       	ldi	r19, 0x00	; 0
    5002:	39 8f       	std	Y+25, r19	; 0x19
    5004:	28 8f       	std	Y+24, r18	; 0x18
    5006:	88 8d       	ldd	r24, Y+24	; 0x18
    5008:	99 8d       	ldd	r25, Y+25	; 0x19
    500a:	82 30       	cpi	r24, 0x02	; 2
    500c:	91 05       	cpc	r25, r1
    500e:	09 f4       	brne	.+2      	; 0x5012 <xTaskGenericNotifyFromISR+0xbe>
    5010:	46 c0       	rjmp	.+140    	; 0x509e <xTaskGenericNotifyFromISR+0x14a>
    5012:	28 8d       	ldd	r18, Y+24	; 0x18
    5014:	39 8d       	ldd	r19, Y+25	; 0x19
    5016:	23 30       	cpi	r18, 0x03	; 3
    5018:	31 05       	cpc	r19, r1
    501a:	34 f4       	brge	.+12     	; 0x5028 <xTaskGenericNotifyFromISR+0xd4>
    501c:	88 8d       	ldd	r24, Y+24	; 0x18
    501e:	99 8d       	ldd	r25, Y+25	; 0x19
    5020:	81 30       	cpi	r24, 0x01	; 1
    5022:	91 05       	cpc	r25, r1
    5024:	71 f0       	breq	.+28     	; 0x5042 <xTaskGenericNotifyFromISR+0xee>
    5026:	93 c0       	rjmp	.+294    	; 0x514e <xTaskGenericNotifyFromISR+0x1fa>
    5028:	28 8d       	ldd	r18, Y+24	; 0x18
    502a:	39 8d       	ldd	r19, Y+25	; 0x19
    502c:	23 30       	cpi	r18, 0x03	; 3
    502e:	31 05       	cpc	r19, r1
    5030:	09 f4       	brne	.+2      	; 0x5034 <xTaskGenericNotifyFromISR+0xe0>
    5032:	5d c0       	rjmp	.+186    	; 0x50ee <xTaskGenericNotifyFromISR+0x19a>
    5034:	88 8d       	ldd	r24, Y+24	; 0x18
    5036:	99 8d       	ldd	r25, Y+25	; 0x19
    5038:	84 30       	cpi	r24, 0x04	; 4
    503a:	91 05       	cpc	r25, r1
    503c:	09 f4       	brne	.+2      	; 0x5040 <xTaskGenericNotifyFromISR+0xec>
    503e:	6d c0       	rjmp	.+218    	; 0x511a <xTaskGenericNotifyFromISR+0x1c6>
    5040:	86 c0       	rjmp	.+268    	; 0x514e <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    5042:	8e 85       	ldd	r24, Y+14	; 0x0e
    5044:	08 2f       	mov	r16, r24
    5046:	10 e0       	ldi	r17, 0x00	; 0
    5048:	8e 85       	ldd	r24, Y+14	; 0x0e
    504a:	88 2f       	mov	r24, r24
    504c:	90 e0       	ldi	r25, 0x00	; 0
    504e:	2a 85       	ldd	r18, Y+10	; 0x0a
    5050:	3b 85       	ldd	r19, Y+11	; 0x0b
    5052:	88 0f       	add	r24, r24
    5054:	99 1f       	adc	r25, r25
    5056:	88 0f       	add	r24, r24
    5058:	99 1f       	adc	r25, r25
    505a:	82 0f       	add	r24, r18
    505c:	93 1f       	adc	r25, r19
    505e:	fc 01       	movw	r30, r24
    5060:	b1 96       	adiw	r30, 0x21	; 33
    5062:	20 81       	ld	r18, Z
    5064:	31 81       	ldd	r19, Z+1	; 0x01
    5066:	42 81       	ldd	r20, Z+2	; 0x02
    5068:	53 81       	ldd	r21, Z+3	; 0x03
    506a:	8f 85       	ldd	r24, Y+15	; 0x0f
    506c:	98 89       	ldd	r25, Y+16	; 0x10
    506e:	a9 89       	ldd	r26, Y+17	; 0x11
    5070:	ba 89       	ldd	r27, Y+18	; 0x12
    5072:	ba 01       	movw	r22, r20
    5074:	a9 01       	movw	r20, r18
    5076:	48 2b       	or	r20, r24
    5078:	59 2b       	or	r21, r25
    507a:	6a 2b       	or	r22, r26
    507c:	7b 2b       	or	r23, r27
    507e:	2a 85       	ldd	r18, Y+10	; 0x0a
    5080:	3b 85       	ldd	r19, Y+11	; 0x0b
    5082:	c8 01       	movw	r24, r16
    5084:	88 0f       	add	r24, r24
    5086:	99 1f       	adc	r25, r25
    5088:	88 0f       	add	r24, r24
    508a:	99 1f       	adc	r25, r25
    508c:	82 0f       	add	r24, r18
    508e:	93 1f       	adc	r25, r19
    5090:	fc 01       	movw	r30, r24
    5092:	b1 96       	adiw	r30, 0x21	; 33
    5094:	40 83       	st	Z, r20
    5096:	51 83       	std	Z+1, r21	; 0x01
    5098:	62 83       	std	Z+2, r22	; 0x02
    509a:	73 83       	std	Z+3, r23	; 0x03
    509c:	58 c0       	rjmp	.+176    	; 0x514e <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    509e:	8e 85       	ldd	r24, Y+14	; 0x0e
    50a0:	08 2f       	mov	r16, r24
    50a2:	10 e0       	ldi	r17, 0x00	; 0
    50a4:	2a 85       	ldd	r18, Y+10	; 0x0a
    50a6:	3b 85       	ldd	r19, Y+11	; 0x0b
    50a8:	c8 01       	movw	r24, r16
    50aa:	88 0f       	add	r24, r24
    50ac:	99 1f       	adc	r25, r25
    50ae:	88 0f       	add	r24, r24
    50b0:	99 1f       	adc	r25, r25
    50b2:	82 0f       	add	r24, r18
    50b4:	93 1f       	adc	r25, r19
    50b6:	fc 01       	movw	r30, r24
    50b8:	b1 96       	adiw	r30, 0x21	; 33
    50ba:	80 81       	ld	r24, Z
    50bc:	91 81       	ldd	r25, Z+1	; 0x01
    50be:	a2 81       	ldd	r26, Z+2	; 0x02
    50c0:	b3 81       	ldd	r27, Z+3	; 0x03
    50c2:	ac 01       	movw	r20, r24
    50c4:	bd 01       	movw	r22, r26
    50c6:	4f 5f       	subi	r20, 0xFF	; 255
    50c8:	5f 4f       	sbci	r21, 0xFF	; 255
    50ca:	6f 4f       	sbci	r22, 0xFF	; 255
    50cc:	7f 4f       	sbci	r23, 0xFF	; 255
    50ce:	2a 85       	ldd	r18, Y+10	; 0x0a
    50d0:	3b 85       	ldd	r19, Y+11	; 0x0b
    50d2:	c8 01       	movw	r24, r16
    50d4:	88 0f       	add	r24, r24
    50d6:	99 1f       	adc	r25, r25
    50d8:	88 0f       	add	r24, r24
    50da:	99 1f       	adc	r25, r25
    50dc:	82 0f       	add	r24, r18
    50de:	93 1f       	adc	r25, r19
    50e0:	fc 01       	movw	r30, r24
    50e2:	b1 96       	adiw	r30, 0x21	; 33
    50e4:	40 83       	st	Z, r20
    50e6:	51 83       	std	Z+1, r21	; 0x01
    50e8:	62 83       	std	Z+2, r22	; 0x02
    50ea:	73 83       	std	Z+3, r23	; 0x03
    50ec:	30 c0       	rjmp	.+96     	; 0x514e <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    50ee:	8e 85       	ldd	r24, Y+14	; 0x0e
    50f0:	88 2f       	mov	r24, r24
    50f2:	90 e0       	ldi	r25, 0x00	; 0
    50f4:	2a 85       	ldd	r18, Y+10	; 0x0a
    50f6:	3b 85       	ldd	r19, Y+11	; 0x0b
    50f8:	88 0f       	add	r24, r24
    50fa:	99 1f       	adc	r25, r25
    50fc:	88 0f       	add	r24, r24
    50fe:	99 1f       	adc	r25, r25
    5100:	82 0f       	add	r24, r18
    5102:	93 1f       	adc	r25, r19
    5104:	fc 01       	movw	r30, r24
    5106:	b1 96       	adiw	r30, 0x21	; 33
    5108:	8f 85       	ldd	r24, Y+15	; 0x0f
    510a:	98 89       	ldd	r25, Y+16	; 0x10
    510c:	a9 89       	ldd	r26, Y+17	; 0x11
    510e:	ba 89       	ldd	r27, Y+18	; 0x12
    5110:	80 83       	st	Z, r24
    5112:	91 83       	std	Z+1, r25	; 0x01
    5114:	a2 83       	std	Z+2, r26	; 0x02
    5116:	b3 83       	std	Z+3, r27	; 0x03
    5118:	1a c0       	rjmp	.+52     	; 0x514e <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    511a:	89 85       	ldd	r24, Y+9	; 0x09
    511c:	82 30       	cpi	r24, 0x02	; 2
    511e:	b1 f0       	breq	.+44     	; 0x514c <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5120:	8e 85       	ldd	r24, Y+14	; 0x0e
    5122:	88 2f       	mov	r24, r24
    5124:	90 e0       	ldi	r25, 0x00	; 0
    5126:	2a 85       	ldd	r18, Y+10	; 0x0a
    5128:	3b 85       	ldd	r19, Y+11	; 0x0b
    512a:	88 0f       	add	r24, r24
    512c:	99 1f       	adc	r25, r25
    512e:	88 0f       	add	r24, r24
    5130:	99 1f       	adc	r25, r25
    5132:	82 0f       	add	r24, r18
    5134:	93 1f       	adc	r25, r19
    5136:	fc 01       	movw	r30, r24
    5138:	b1 96       	adiw	r30, 0x21	; 33
    513a:	8f 85       	ldd	r24, Y+15	; 0x0f
    513c:	98 89       	ldd	r25, Y+16	; 0x10
    513e:	a9 89       	ldd	r26, Y+17	; 0x11
    5140:	ba 89       	ldd	r27, Y+18	; 0x12
    5142:	80 83       	st	Z, r24
    5144:	91 83       	std	Z+1, r25	; 0x01
    5146:	a2 83       	std	Z+2, r26	; 0x02
    5148:	b3 83       	std	Z+3, r27	; 0x03
    514a:	01 c0       	rjmp	.+2      	; 0x514e <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    514c:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    514e:	89 85       	ldd	r24, Y+9	; 0x09
    5150:	81 30       	cpi	r24, 0x01	; 1
    5152:	09 f0       	breq	.+2      	; 0x5156 <xTaskGenericNotifyFromISR+0x202>
    5154:	ee c0       	rjmp	.+476    	; 0x5332 <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5156:	80 91 b7 06 	lds	r24, 0x06B7
    515a:	88 23       	and	r24, r24
    515c:	09 f0       	breq	.+2      	; 0x5160 <xTaskGenericNotifyFromISR+0x20c>
    515e:	a4 c0       	rjmp	.+328    	; 0x52a8 <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5160:	ea 85       	ldd	r30, Y+10	; 0x0a
    5162:	fb 85       	ldd	r31, Y+11	; 0x0b
    5164:	82 85       	ldd	r24, Z+10	; 0x0a
    5166:	93 85       	ldd	r25, Z+11	; 0x0b
    5168:	9e 83       	std	Y+6, r25	; 0x06
    516a:	8d 83       	std	Y+5, r24	; 0x05
    516c:	ea 85       	ldd	r30, Y+10	; 0x0a
    516e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5170:	a4 81       	ldd	r26, Z+4	; 0x04
    5172:	b5 81       	ldd	r27, Z+5	; 0x05
    5174:	ea 85       	ldd	r30, Y+10	; 0x0a
    5176:	fb 85       	ldd	r31, Y+11	; 0x0b
    5178:	86 81       	ldd	r24, Z+6	; 0x06
    517a:	97 81       	ldd	r25, Z+7	; 0x07
    517c:	15 96       	adiw	r26, 0x05	; 5
    517e:	9c 93       	st	X, r25
    5180:	8e 93       	st	-X, r24
    5182:	14 97       	sbiw	r26, 0x04	; 4
    5184:	ea 85       	ldd	r30, Y+10	; 0x0a
    5186:	fb 85       	ldd	r31, Y+11	; 0x0b
    5188:	a6 81       	ldd	r26, Z+6	; 0x06
    518a:	b7 81       	ldd	r27, Z+7	; 0x07
    518c:	ea 85       	ldd	r30, Y+10	; 0x0a
    518e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5190:	84 81       	ldd	r24, Z+4	; 0x04
    5192:	95 81       	ldd	r25, Z+5	; 0x05
    5194:	13 96       	adiw	r26, 0x03	; 3
    5196:	9c 93       	st	X, r25
    5198:	8e 93       	st	-X, r24
    519a:	12 97       	sbiw	r26, 0x02	; 2
    519c:	ed 81       	ldd	r30, Y+5	; 0x05
    519e:	fe 81       	ldd	r31, Y+6	; 0x06
    51a0:	21 81       	ldd	r18, Z+1	; 0x01
    51a2:	32 81       	ldd	r19, Z+2	; 0x02
    51a4:	8a 85       	ldd	r24, Y+10	; 0x0a
    51a6:	9b 85       	ldd	r25, Y+11	; 0x0b
    51a8:	02 96       	adiw	r24, 0x02	; 2
    51aa:	28 17       	cp	r18, r24
    51ac:	39 07       	cpc	r19, r25
    51ae:	41 f4       	brne	.+16     	; 0x51c0 <xTaskGenericNotifyFromISR+0x26c>
    51b0:	ea 85       	ldd	r30, Y+10	; 0x0a
    51b2:	fb 85       	ldd	r31, Y+11	; 0x0b
    51b4:	86 81       	ldd	r24, Z+6	; 0x06
    51b6:	97 81       	ldd	r25, Z+7	; 0x07
    51b8:	ed 81       	ldd	r30, Y+5	; 0x05
    51ba:	fe 81       	ldd	r31, Y+6	; 0x06
    51bc:	92 83       	std	Z+2, r25	; 0x02
    51be:	81 83       	std	Z+1, r24	; 0x01
    51c0:	ea 85       	ldd	r30, Y+10	; 0x0a
    51c2:	fb 85       	ldd	r31, Y+11	; 0x0b
    51c4:	13 86       	std	Z+11, r1	; 0x0b
    51c6:	12 86       	std	Z+10, r1	; 0x0a
    51c8:	ed 81       	ldd	r30, Y+5	; 0x05
    51ca:	fe 81       	ldd	r31, Y+6	; 0x06
    51cc:	80 81       	ld	r24, Z
    51ce:	81 50       	subi	r24, 0x01	; 1
    51d0:	ed 81       	ldd	r30, Y+5	; 0x05
    51d2:	fe 81       	ldd	r31, Y+6	; 0x06
    51d4:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    51d6:	ea 85       	ldd	r30, Y+10	; 0x0a
    51d8:	fb 85       	ldd	r31, Y+11	; 0x0b
    51da:	96 89       	ldd	r25, Z+22	; 0x16
    51dc:	80 91 ac 06 	lds	r24, 0x06AC
    51e0:	89 17       	cp	r24, r25
    51e2:	28 f4       	brcc	.+10     	; 0x51ee <xTaskGenericNotifyFromISR+0x29a>
    51e4:	ea 85       	ldd	r30, Y+10	; 0x0a
    51e6:	fb 85       	ldd	r31, Y+11	; 0x0b
    51e8:	86 89       	ldd	r24, Z+22	; 0x16
    51ea:	80 93 ac 06 	sts	0x06AC, r24
    51ee:	ea 85       	ldd	r30, Y+10	; 0x0a
    51f0:	fb 85       	ldd	r31, Y+11	; 0x0b
    51f2:	86 89       	ldd	r24, Z+22	; 0x16
    51f4:	28 2f       	mov	r18, r24
    51f6:	30 e0       	ldi	r19, 0x00	; 0
    51f8:	c9 01       	movw	r24, r18
    51fa:	88 0f       	add	r24, r24
    51fc:	99 1f       	adc	r25, r25
    51fe:	88 0f       	add	r24, r24
    5200:	99 1f       	adc	r25, r25
    5202:	88 0f       	add	r24, r24
    5204:	99 1f       	adc	r25, r25
    5206:	82 0f       	add	r24, r18
    5208:	93 1f       	adc	r25, r19
    520a:	fc 01       	movw	r30, r24
    520c:	e8 54       	subi	r30, 0x48	; 72
    520e:	f9 4f       	sbci	r31, 0xF9	; 249
    5210:	81 81       	ldd	r24, Z+1	; 0x01
    5212:	92 81       	ldd	r25, Z+2	; 0x02
    5214:	9c 83       	std	Y+4, r25	; 0x04
    5216:	8b 83       	std	Y+3, r24	; 0x03
    5218:	ea 85       	ldd	r30, Y+10	; 0x0a
    521a:	fb 85       	ldd	r31, Y+11	; 0x0b
    521c:	8b 81       	ldd	r24, Y+3	; 0x03
    521e:	9c 81       	ldd	r25, Y+4	; 0x04
    5220:	95 83       	std	Z+5, r25	; 0x05
    5222:	84 83       	std	Z+4, r24	; 0x04
    5224:	eb 81       	ldd	r30, Y+3	; 0x03
    5226:	fc 81       	ldd	r31, Y+4	; 0x04
    5228:	84 81       	ldd	r24, Z+4	; 0x04
    522a:	95 81       	ldd	r25, Z+5	; 0x05
    522c:	ea 85       	ldd	r30, Y+10	; 0x0a
    522e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5230:	97 83       	std	Z+7, r25	; 0x07
    5232:	86 83       	std	Z+6, r24	; 0x06
    5234:	eb 81       	ldd	r30, Y+3	; 0x03
    5236:	fc 81       	ldd	r31, Y+4	; 0x04
    5238:	04 80       	ldd	r0, Z+4	; 0x04
    523a:	f5 81       	ldd	r31, Z+5	; 0x05
    523c:	e0 2d       	mov	r30, r0
    523e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5240:	9b 85       	ldd	r25, Y+11	; 0x0b
    5242:	02 96       	adiw	r24, 0x02	; 2
    5244:	93 83       	std	Z+3, r25	; 0x03
    5246:	82 83       	std	Z+2, r24	; 0x02
    5248:	8a 85       	ldd	r24, Y+10	; 0x0a
    524a:	9b 85       	ldd	r25, Y+11	; 0x0b
    524c:	02 96       	adiw	r24, 0x02	; 2
    524e:	eb 81       	ldd	r30, Y+3	; 0x03
    5250:	fc 81       	ldd	r31, Y+4	; 0x04
    5252:	95 83       	std	Z+5, r25	; 0x05
    5254:	84 83       	std	Z+4, r24	; 0x04
    5256:	ea 85       	ldd	r30, Y+10	; 0x0a
    5258:	fb 85       	ldd	r31, Y+11	; 0x0b
    525a:	86 89       	ldd	r24, Z+22	; 0x16
    525c:	28 2f       	mov	r18, r24
    525e:	30 e0       	ldi	r19, 0x00	; 0
    5260:	c9 01       	movw	r24, r18
    5262:	88 0f       	add	r24, r24
    5264:	99 1f       	adc	r25, r25
    5266:	88 0f       	add	r24, r24
    5268:	99 1f       	adc	r25, r25
    526a:	88 0f       	add	r24, r24
    526c:	99 1f       	adc	r25, r25
    526e:	82 0f       	add	r24, r18
    5270:	93 1f       	adc	r25, r19
    5272:	88 54       	subi	r24, 0x48	; 72
    5274:	99 4f       	sbci	r25, 0xF9	; 249
    5276:	ea 85       	ldd	r30, Y+10	; 0x0a
    5278:	fb 85       	ldd	r31, Y+11	; 0x0b
    527a:	93 87       	std	Z+11, r25	; 0x0b
    527c:	82 87       	std	Z+10, r24	; 0x0a
    527e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5280:	fb 85       	ldd	r31, Y+11	; 0x0b
    5282:	86 89       	ldd	r24, Z+22	; 0x16
    5284:	28 2f       	mov	r18, r24
    5286:	30 e0       	ldi	r19, 0x00	; 0
    5288:	c9 01       	movw	r24, r18
    528a:	88 0f       	add	r24, r24
    528c:	99 1f       	adc	r25, r25
    528e:	88 0f       	add	r24, r24
    5290:	99 1f       	adc	r25, r25
    5292:	88 0f       	add	r24, r24
    5294:	99 1f       	adc	r25, r25
    5296:	82 0f       	add	r24, r18
    5298:	93 1f       	adc	r25, r19
    529a:	fc 01       	movw	r30, r24
    529c:	e8 54       	subi	r30, 0x48	; 72
    529e:	f9 4f       	sbci	r31, 0xF9	; 249
    52a0:	80 81       	ld	r24, Z
    52a2:	8f 5f       	subi	r24, 0xFF	; 255
    52a4:	80 83       	st	Z, r24
    52a6:	30 c0       	rjmp	.+96     	; 0x5308 <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    52a8:	80 91 f3 06 	lds	r24, 0x06F3
    52ac:	90 91 f4 06 	lds	r25, 0x06F4
    52b0:	9a 83       	std	Y+2, r25	; 0x02
    52b2:	89 83       	std	Y+1, r24	; 0x01
    52b4:	ea 85       	ldd	r30, Y+10	; 0x0a
    52b6:	fb 85       	ldd	r31, Y+11	; 0x0b
    52b8:	89 81       	ldd	r24, Y+1	; 0x01
    52ba:	9a 81       	ldd	r25, Y+2	; 0x02
    52bc:	97 87       	std	Z+15, r25	; 0x0f
    52be:	86 87       	std	Z+14, r24	; 0x0e
    52c0:	e9 81       	ldd	r30, Y+1	; 0x01
    52c2:	fa 81       	ldd	r31, Y+2	; 0x02
    52c4:	84 81       	ldd	r24, Z+4	; 0x04
    52c6:	95 81       	ldd	r25, Z+5	; 0x05
    52c8:	ea 85       	ldd	r30, Y+10	; 0x0a
    52ca:	fb 85       	ldd	r31, Y+11	; 0x0b
    52cc:	91 8b       	std	Z+17, r25	; 0x11
    52ce:	80 8b       	std	Z+16, r24	; 0x10
    52d0:	e9 81       	ldd	r30, Y+1	; 0x01
    52d2:	fa 81       	ldd	r31, Y+2	; 0x02
    52d4:	04 80       	ldd	r0, Z+4	; 0x04
    52d6:	f5 81       	ldd	r31, Z+5	; 0x05
    52d8:	e0 2d       	mov	r30, r0
    52da:	8a 85       	ldd	r24, Y+10	; 0x0a
    52dc:	9b 85       	ldd	r25, Y+11	; 0x0b
    52de:	0c 96       	adiw	r24, 0x0c	; 12
    52e0:	93 83       	std	Z+3, r25	; 0x03
    52e2:	82 83       	std	Z+2, r24	; 0x02
    52e4:	8a 85       	ldd	r24, Y+10	; 0x0a
    52e6:	9b 85       	ldd	r25, Y+11	; 0x0b
    52e8:	0c 96       	adiw	r24, 0x0c	; 12
    52ea:	e9 81       	ldd	r30, Y+1	; 0x01
    52ec:	fa 81       	ldd	r31, Y+2	; 0x02
    52ee:	95 83       	std	Z+5, r25	; 0x05
    52f0:	84 83       	std	Z+4, r24	; 0x04
    52f2:	ea 85       	ldd	r30, Y+10	; 0x0a
    52f4:	fb 85       	ldd	r31, Y+11	; 0x0b
    52f6:	82 ef       	ldi	r24, 0xF2	; 242
    52f8:	96 e0       	ldi	r25, 0x06	; 6
    52fa:	95 8b       	std	Z+21, r25	; 0x15
    52fc:	84 8b       	std	Z+20, r24	; 0x14
    52fe:	80 91 f2 06 	lds	r24, 0x06F2
    5302:	8f 5f       	subi	r24, 0xFF	; 255
    5304:	80 93 f2 06 	sts	0x06F2, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5308:	ea 85       	ldd	r30, Y+10	; 0x0a
    530a:	fb 85       	ldd	r31, Y+11	; 0x0b
    530c:	96 89       	ldd	r25, Z+22	; 0x16
    530e:	e0 91 a6 06 	lds	r30, 0x06A6
    5312:	f0 91 a7 06 	lds	r31, 0x06A7
    5316:	86 89       	ldd	r24, Z+22	; 0x16
    5318:	89 17       	cp	r24, r25
    531a:	58 f4       	brcc	.+22     	; 0x5332 <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    531c:	8e 89       	ldd	r24, Y+22	; 0x16
    531e:	9f 89       	ldd	r25, Y+23	; 0x17
    5320:	00 97       	sbiw	r24, 0x00	; 0
    5322:	21 f0       	breq	.+8      	; 0x532c <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5324:	ee 89       	ldd	r30, Y+22	; 0x16
    5326:	ff 89       	ldd	r31, Y+23	; 0x17
    5328:	81 e0       	ldi	r24, 0x01	; 1
    532a:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    532c:	81 e0       	ldi	r24, 0x01	; 1
    532e:	80 93 b0 06 	sts	0x06B0, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    5332:	88 85       	ldd	r24, Y+8	; 0x08
    }
    5334:	69 96       	adiw	r28, 0x19	; 25
    5336:	0f b6       	in	r0, 0x3f	; 63
    5338:	f8 94       	cli
    533a:	de bf       	out	0x3e, r29	; 62
    533c:	0f be       	out	0x3f, r0	; 63
    533e:	cd bf       	out	0x3d, r28	; 61
    5340:	cf 91       	pop	r28
    5342:	df 91       	pop	r29
    5344:	1f 91       	pop	r17
    5346:	0f 91       	pop	r16
    5348:	ff 90       	pop	r15
    534a:	ef 90       	pop	r14
    534c:	df 90       	pop	r13
    534e:	cf 90       	pop	r12
    5350:	08 95       	ret

00005352 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    5352:	0f 93       	push	r16
    5354:	1f 93       	push	r17
    5356:	df 93       	push	r29
    5358:	cf 93       	push	r28
    535a:	cd b7       	in	r28, 0x3d	; 61
    535c:	de b7       	in	r29, 0x3e	; 62
    535e:	2f 97       	sbiw	r28, 0x0f	; 15
    5360:	0f b6       	in	r0, 0x3f	; 63
    5362:	f8 94       	cli
    5364:	de bf       	out	0x3e, r29	; 62
    5366:	0f be       	out	0x3f, r0	; 63
    5368:	cd bf       	out	0x3d, r28	; 61
    536a:	9c 87       	std	Y+12, r25	; 0x0c
    536c:	8b 87       	std	Y+11, r24	; 0x0b
    536e:	6d 87       	std	Y+13, r22	; 0x0d
    5370:	5f 87       	std	Y+15, r21	; 0x0f
    5372:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    5374:	8b 85       	ldd	r24, Y+11	; 0x0b
    5376:	9c 85       	ldd	r25, Y+12	; 0x0c
    5378:	9a 87       	std	Y+10, r25	; 0x0a
    537a:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    537c:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    537e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5380:	28 2f       	mov	r18, r24
    5382:	30 e0       	ldi	r19, 0x00	; 0
    5384:	89 85       	ldd	r24, Y+9	; 0x09
    5386:	9a 85       	ldd	r25, Y+10	; 0x0a
    5388:	82 0f       	add	r24, r18
    538a:	93 1f       	adc	r25, r19
    538c:	fc 01       	movw	r30, r24
    538e:	b5 96       	adiw	r30, 0x25	; 37
    5390:	80 81       	ld	r24, Z
    5392:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    5394:	8d 85       	ldd	r24, Y+13	; 0x0d
    5396:	28 2f       	mov	r18, r24
    5398:	30 e0       	ldi	r19, 0x00	; 0
    539a:	89 85       	ldd	r24, Y+9	; 0x09
    539c:	9a 85       	ldd	r25, Y+10	; 0x0a
    539e:	82 0f       	add	r24, r18
    53a0:	93 1f       	adc	r25, r19
    53a2:	fc 01       	movw	r30, r24
    53a4:	b5 96       	adiw	r30, 0x25	; 37
    53a6:	82 e0       	ldi	r24, 0x02	; 2
    53a8:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    53aa:	8d 85       	ldd	r24, Y+13	; 0x0d
    53ac:	08 2f       	mov	r16, r24
    53ae:	10 e0       	ldi	r17, 0x00	; 0
    53b0:	29 85       	ldd	r18, Y+9	; 0x09
    53b2:	3a 85       	ldd	r19, Y+10	; 0x0a
    53b4:	c8 01       	movw	r24, r16
    53b6:	88 0f       	add	r24, r24
    53b8:	99 1f       	adc	r25, r25
    53ba:	88 0f       	add	r24, r24
    53bc:	99 1f       	adc	r25, r25
    53be:	82 0f       	add	r24, r18
    53c0:	93 1f       	adc	r25, r19
    53c2:	fc 01       	movw	r30, r24
    53c4:	b1 96       	adiw	r30, 0x21	; 33
    53c6:	80 81       	ld	r24, Z
    53c8:	91 81       	ldd	r25, Z+1	; 0x01
    53ca:	a2 81       	ldd	r26, Z+2	; 0x02
    53cc:	b3 81       	ldd	r27, Z+3	; 0x03
    53ce:	ac 01       	movw	r20, r24
    53d0:	bd 01       	movw	r22, r26
    53d2:	4f 5f       	subi	r20, 0xFF	; 255
    53d4:	5f 4f       	sbci	r21, 0xFF	; 255
    53d6:	6f 4f       	sbci	r22, 0xFF	; 255
    53d8:	7f 4f       	sbci	r23, 0xFF	; 255
    53da:	29 85       	ldd	r18, Y+9	; 0x09
    53dc:	3a 85       	ldd	r19, Y+10	; 0x0a
    53de:	c8 01       	movw	r24, r16
    53e0:	88 0f       	add	r24, r24
    53e2:	99 1f       	adc	r25, r25
    53e4:	88 0f       	add	r24, r24
    53e6:	99 1f       	adc	r25, r25
    53e8:	82 0f       	add	r24, r18
    53ea:	93 1f       	adc	r25, r19
    53ec:	fc 01       	movw	r30, r24
    53ee:	b1 96       	adiw	r30, 0x21	; 33
    53f0:	40 83       	st	Z, r20
    53f2:	51 83       	std	Z+1, r21	; 0x01
    53f4:	62 83       	std	Z+2, r22	; 0x02
    53f6:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    53f8:	88 85       	ldd	r24, Y+8	; 0x08
    53fa:	81 30       	cpi	r24, 0x01	; 1
    53fc:	09 f0       	breq	.+2      	; 0x5400 <vTaskGenericNotifyGiveFromISR+0xae>
    53fe:	ee c0       	rjmp	.+476    	; 0x55dc <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5400:	80 91 b7 06 	lds	r24, 0x06B7
    5404:	88 23       	and	r24, r24
    5406:	09 f0       	breq	.+2      	; 0x540a <vTaskGenericNotifyGiveFromISR+0xb8>
    5408:	a4 c0       	rjmp	.+328    	; 0x5552 <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    540a:	e9 85       	ldd	r30, Y+9	; 0x09
    540c:	fa 85       	ldd	r31, Y+10	; 0x0a
    540e:	82 85       	ldd	r24, Z+10	; 0x0a
    5410:	93 85       	ldd	r25, Z+11	; 0x0b
    5412:	9e 83       	std	Y+6, r25	; 0x06
    5414:	8d 83       	std	Y+5, r24	; 0x05
    5416:	e9 85       	ldd	r30, Y+9	; 0x09
    5418:	fa 85       	ldd	r31, Y+10	; 0x0a
    541a:	a4 81       	ldd	r26, Z+4	; 0x04
    541c:	b5 81       	ldd	r27, Z+5	; 0x05
    541e:	e9 85       	ldd	r30, Y+9	; 0x09
    5420:	fa 85       	ldd	r31, Y+10	; 0x0a
    5422:	86 81       	ldd	r24, Z+6	; 0x06
    5424:	97 81       	ldd	r25, Z+7	; 0x07
    5426:	15 96       	adiw	r26, 0x05	; 5
    5428:	9c 93       	st	X, r25
    542a:	8e 93       	st	-X, r24
    542c:	14 97       	sbiw	r26, 0x04	; 4
    542e:	e9 85       	ldd	r30, Y+9	; 0x09
    5430:	fa 85       	ldd	r31, Y+10	; 0x0a
    5432:	a6 81       	ldd	r26, Z+6	; 0x06
    5434:	b7 81       	ldd	r27, Z+7	; 0x07
    5436:	e9 85       	ldd	r30, Y+9	; 0x09
    5438:	fa 85       	ldd	r31, Y+10	; 0x0a
    543a:	84 81       	ldd	r24, Z+4	; 0x04
    543c:	95 81       	ldd	r25, Z+5	; 0x05
    543e:	13 96       	adiw	r26, 0x03	; 3
    5440:	9c 93       	st	X, r25
    5442:	8e 93       	st	-X, r24
    5444:	12 97       	sbiw	r26, 0x02	; 2
    5446:	ed 81       	ldd	r30, Y+5	; 0x05
    5448:	fe 81       	ldd	r31, Y+6	; 0x06
    544a:	21 81       	ldd	r18, Z+1	; 0x01
    544c:	32 81       	ldd	r19, Z+2	; 0x02
    544e:	89 85       	ldd	r24, Y+9	; 0x09
    5450:	9a 85       	ldd	r25, Y+10	; 0x0a
    5452:	02 96       	adiw	r24, 0x02	; 2
    5454:	28 17       	cp	r18, r24
    5456:	39 07       	cpc	r19, r25
    5458:	41 f4       	brne	.+16     	; 0x546a <vTaskGenericNotifyGiveFromISR+0x118>
    545a:	e9 85       	ldd	r30, Y+9	; 0x09
    545c:	fa 85       	ldd	r31, Y+10	; 0x0a
    545e:	86 81       	ldd	r24, Z+6	; 0x06
    5460:	97 81       	ldd	r25, Z+7	; 0x07
    5462:	ed 81       	ldd	r30, Y+5	; 0x05
    5464:	fe 81       	ldd	r31, Y+6	; 0x06
    5466:	92 83       	std	Z+2, r25	; 0x02
    5468:	81 83       	std	Z+1, r24	; 0x01
    546a:	e9 85       	ldd	r30, Y+9	; 0x09
    546c:	fa 85       	ldd	r31, Y+10	; 0x0a
    546e:	13 86       	std	Z+11, r1	; 0x0b
    5470:	12 86       	std	Z+10, r1	; 0x0a
    5472:	ed 81       	ldd	r30, Y+5	; 0x05
    5474:	fe 81       	ldd	r31, Y+6	; 0x06
    5476:	80 81       	ld	r24, Z
    5478:	81 50       	subi	r24, 0x01	; 1
    547a:	ed 81       	ldd	r30, Y+5	; 0x05
    547c:	fe 81       	ldd	r31, Y+6	; 0x06
    547e:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5480:	e9 85       	ldd	r30, Y+9	; 0x09
    5482:	fa 85       	ldd	r31, Y+10	; 0x0a
    5484:	96 89       	ldd	r25, Z+22	; 0x16
    5486:	80 91 ac 06 	lds	r24, 0x06AC
    548a:	89 17       	cp	r24, r25
    548c:	28 f4       	brcc	.+10     	; 0x5498 <vTaskGenericNotifyGiveFromISR+0x146>
    548e:	e9 85       	ldd	r30, Y+9	; 0x09
    5490:	fa 85       	ldd	r31, Y+10	; 0x0a
    5492:	86 89       	ldd	r24, Z+22	; 0x16
    5494:	80 93 ac 06 	sts	0x06AC, r24
    5498:	e9 85       	ldd	r30, Y+9	; 0x09
    549a:	fa 85       	ldd	r31, Y+10	; 0x0a
    549c:	86 89       	ldd	r24, Z+22	; 0x16
    549e:	28 2f       	mov	r18, r24
    54a0:	30 e0       	ldi	r19, 0x00	; 0
    54a2:	c9 01       	movw	r24, r18
    54a4:	88 0f       	add	r24, r24
    54a6:	99 1f       	adc	r25, r25
    54a8:	88 0f       	add	r24, r24
    54aa:	99 1f       	adc	r25, r25
    54ac:	88 0f       	add	r24, r24
    54ae:	99 1f       	adc	r25, r25
    54b0:	82 0f       	add	r24, r18
    54b2:	93 1f       	adc	r25, r19
    54b4:	fc 01       	movw	r30, r24
    54b6:	e8 54       	subi	r30, 0x48	; 72
    54b8:	f9 4f       	sbci	r31, 0xF9	; 249
    54ba:	81 81       	ldd	r24, Z+1	; 0x01
    54bc:	92 81       	ldd	r25, Z+2	; 0x02
    54be:	9c 83       	std	Y+4, r25	; 0x04
    54c0:	8b 83       	std	Y+3, r24	; 0x03
    54c2:	e9 85       	ldd	r30, Y+9	; 0x09
    54c4:	fa 85       	ldd	r31, Y+10	; 0x0a
    54c6:	8b 81       	ldd	r24, Y+3	; 0x03
    54c8:	9c 81       	ldd	r25, Y+4	; 0x04
    54ca:	95 83       	std	Z+5, r25	; 0x05
    54cc:	84 83       	std	Z+4, r24	; 0x04
    54ce:	eb 81       	ldd	r30, Y+3	; 0x03
    54d0:	fc 81       	ldd	r31, Y+4	; 0x04
    54d2:	84 81       	ldd	r24, Z+4	; 0x04
    54d4:	95 81       	ldd	r25, Z+5	; 0x05
    54d6:	e9 85       	ldd	r30, Y+9	; 0x09
    54d8:	fa 85       	ldd	r31, Y+10	; 0x0a
    54da:	97 83       	std	Z+7, r25	; 0x07
    54dc:	86 83       	std	Z+6, r24	; 0x06
    54de:	eb 81       	ldd	r30, Y+3	; 0x03
    54e0:	fc 81       	ldd	r31, Y+4	; 0x04
    54e2:	04 80       	ldd	r0, Z+4	; 0x04
    54e4:	f5 81       	ldd	r31, Z+5	; 0x05
    54e6:	e0 2d       	mov	r30, r0
    54e8:	89 85       	ldd	r24, Y+9	; 0x09
    54ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    54ec:	02 96       	adiw	r24, 0x02	; 2
    54ee:	93 83       	std	Z+3, r25	; 0x03
    54f0:	82 83       	std	Z+2, r24	; 0x02
    54f2:	89 85       	ldd	r24, Y+9	; 0x09
    54f4:	9a 85       	ldd	r25, Y+10	; 0x0a
    54f6:	02 96       	adiw	r24, 0x02	; 2
    54f8:	eb 81       	ldd	r30, Y+3	; 0x03
    54fa:	fc 81       	ldd	r31, Y+4	; 0x04
    54fc:	95 83       	std	Z+5, r25	; 0x05
    54fe:	84 83       	std	Z+4, r24	; 0x04
    5500:	e9 85       	ldd	r30, Y+9	; 0x09
    5502:	fa 85       	ldd	r31, Y+10	; 0x0a
    5504:	86 89       	ldd	r24, Z+22	; 0x16
    5506:	28 2f       	mov	r18, r24
    5508:	30 e0       	ldi	r19, 0x00	; 0
    550a:	c9 01       	movw	r24, r18
    550c:	88 0f       	add	r24, r24
    550e:	99 1f       	adc	r25, r25
    5510:	88 0f       	add	r24, r24
    5512:	99 1f       	adc	r25, r25
    5514:	88 0f       	add	r24, r24
    5516:	99 1f       	adc	r25, r25
    5518:	82 0f       	add	r24, r18
    551a:	93 1f       	adc	r25, r19
    551c:	88 54       	subi	r24, 0x48	; 72
    551e:	99 4f       	sbci	r25, 0xF9	; 249
    5520:	e9 85       	ldd	r30, Y+9	; 0x09
    5522:	fa 85       	ldd	r31, Y+10	; 0x0a
    5524:	93 87       	std	Z+11, r25	; 0x0b
    5526:	82 87       	std	Z+10, r24	; 0x0a
    5528:	e9 85       	ldd	r30, Y+9	; 0x09
    552a:	fa 85       	ldd	r31, Y+10	; 0x0a
    552c:	86 89       	ldd	r24, Z+22	; 0x16
    552e:	28 2f       	mov	r18, r24
    5530:	30 e0       	ldi	r19, 0x00	; 0
    5532:	c9 01       	movw	r24, r18
    5534:	88 0f       	add	r24, r24
    5536:	99 1f       	adc	r25, r25
    5538:	88 0f       	add	r24, r24
    553a:	99 1f       	adc	r25, r25
    553c:	88 0f       	add	r24, r24
    553e:	99 1f       	adc	r25, r25
    5540:	82 0f       	add	r24, r18
    5542:	93 1f       	adc	r25, r19
    5544:	fc 01       	movw	r30, r24
    5546:	e8 54       	subi	r30, 0x48	; 72
    5548:	f9 4f       	sbci	r31, 0xF9	; 249
    554a:	80 81       	ld	r24, Z
    554c:	8f 5f       	subi	r24, 0xFF	; 255
    554e:	80 83       	st	Z, r24
    5550:	30 c0       	rjmp	.+96     	; 0x55b2 <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5552:	80 91 f3 06 	lds	r24, 0x06F3
    5556:	90 91 f4 06 	lds	r25, 0x06F4
    555a:	9a 83       	std	Y+2, r25	; 0x02
    555c:	89 83       	std	Y+1, r24	; 0x01
    555e:	e9 85       	ldd	r30, Y+9	; 0x09
    5560:	fa 85       	ldd	r31, Y+10	; 0x0a
    5562:	89 81       	ldd	r24, Y+1	; 0x01
    5564:	9a 81       	ldd	r25, Y+2	; 0x02
    5566:	97 87       	std	Z+15, r25	; 0x0f
    5568:	86 87       	std	Z+14, r24	; 0x0e
    556a:	e9 81       	ldd	r30, Y+1	; 0x01
    556c:	fa 81       	ldd	r31, Y+2	; 0x02
    556e:	84 81       	ldd	r24, Z+4	; 0x04
    5570:	95 81       	ldd	r25, Z+5	; 0x05
    5572:	e9 85       	ldd	r30, Y+9	; 0x09
    5574:	fa 85       	ldd	r31, Y+10	; 0x0a
    5576:	91 8b       	std	Z+17, r25	; 0x11
    5578:	80 8b       	std	Z+16, r24	; 0x10
    557a:	e9 81       	ldd	r30, Y+1	; 0x01
    557c:	fa 81       	ldd	r31, Y+2	; 0x02
    557e:	04 80       	ldd	r0, Z+4	; 0x04
    5580:	f5 81       	ldd	r31, Z+5	; 0x05
    5582:	e0 2d       	mov	r30, r0
    5584:	89 85       	ldd	r24, Y+9	; 0x09
    5586:	9a 85       	ldd	r25, Y+10	; 0x0a
    5588:	0c 96       	adiw	r24, 0x0c	; 12
    558a:	93 83       	std	Z+3, r25	; 0x03
    558c:	82 83       	std	Z+2, r24	; 0x02
    558e:	89 85       	ldd	r24, Y+9	; 0x09
    5590:	9a 85       	ldd	r25, Y+10	; 0x0a
    5592:	0c 96       	adiw	r24, 0x0c	; 12
    5594:	e9 81       	ldd	r30, Y+1	; 0x01
    5596:	fa 81       	ldd	r31, Y+2	; 0x02
    5598:	95 83       	std	Z+5, r25	; 0x05
    559a:	84 83       	std	Z+4, r24	; 0x04
    559c:	e9 85       	ldd	r30, Y+9	; 0x09
    559e:	fa 85       	ldd	r31, Y+10	; 0x0a
    55a0:	82 ef       	ldi	r24, 0xF2	; 242
    55a2:	96 e0       	ldi	r25, 0x06	; 6
    55a4:	95 8b       	std	Z+21, r25	; 0x15
    55a6:	84 8b       	std	Z+20, r24	; 0x14
    55a8:	80 91 f2 06 	lds	r24, 0x06F2
    55ac:	8f 5f       	subi	r24, 0xFF	; 255
    55ae:	80 93 f2 06 	sts	0x06F2, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    55b2:	e9 85       	ldd	r30, Y+9	; 0x09
    55b4:	fa 85       	ldd	r31, Y+10	; 0x0a
    55b6:	96 89       	ldd	r25, Z+22	; 0x16
    55b8:	e0 91 a6 06 	lds	r30, 0x06A6
    55bc:	f0 91 a7 06 	lds	r31, 0x06A7
    55c0:	86 89       	ldd	r24, Z+22	; 0x16
    55c2:	89 17       	cp	r24, r25
    55c4:	58 f4       	brcc	.+22     	; 0x55dc <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    55c6:	8e 85       	ldd	r24, Y+14	; 0x0e
    55c8:	9f 85       	ldd	r25, Y+15	; 0x0f
    55ca:	00 97       	sbiw	r24, 0x00	; 0
    55cc:	21 f0       	breq	.+8      	; 0x55d6 <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    55ce:	ee 85       	ldd	r30, Y+14	; 0x0e
    55d0:	ff 85       	ldd	r31, Y+15	; 0x0f
    55d2:	81 e0       	ldi	r24, 0x01	; 1
    55d4:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    55d6:	81 e0       	ldi	r24, 0x01	; 1
    55d8:	80 93 b0 06 	sts	0x06B0, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    55dc:	2f 96       	adiw	r28, 0x0f	; 15
    55de:	0f b6       	in	r0, 0x3f	; 63
    55e0:	f8 94       	cli
    55e2:	de bf       	out	0x3e, r29	; 62
    55e4:	0f be       	out	0x3f, r0	; 63
    55e6:	cd bf       	out	0x3d, r28	; 61
    55e8:	cf 91       	pop	r28
    55ea:	df 91       	pop	r29
    55ec:	1f 91       	pop	r17
    55ee:	0f 91       	pop	r16
    55f0:	08 95       	ret

000055f2 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    55f2:	df 93       	push	r29
    55f4:	cf 93       	push	r28
    55f6:	cd b7       	in	r28, 0x3d	; 61
    55f8:	de b7       	in	r29, 0x3e	; 62
    55fa:	28 97       	sbiw	r28, 0x08	; 8
    55fc:	0f b6       	in	r0, 0x3f	; 63
    55fe:	f8 94       	cli
    5600:	de bf       	out	0x3e, r29	; 62
    5602:	0f be       	out	0x3f, r0	; 63
    5604:	cd bf       	out	0x3d, r28	; 61
    5606:	9d 83       	std	Y+5, r25	; 0x05
    5608:	8c 83       	std	Y+4, r24	; 0x04
    560a:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    560c:	8c 81       	ldd	r24, Y+4	; 0x04
    560e:	9d 81       	ldd	r25, Y+5	; 0x05
    5610:	00 97       	sbiw	r24, 0x00	; 0
    5612:	39 f4       	brne	.+14     	; 0x5622 <xTaskGenericNotifyStateClear+0x30>
    5614:	80 91 a6 06 	lds	r24, 0x06A6
    5618:	90 91 a7 06 	lds	r25, 0x06A7
    561c:	98 87       	std	Y+8, r25	; 0x08
    561e:	8f 83       	std	Y+7, r24	; 0x07
    5620:	04 c0       	rjmp	.+8      	; 0x562a <xTaskGenericNotifyStateClear+0x38>
    5622:	8c 81       	ldd	r24, Y+4	; 0x04
    5624:	9d 81       	ldd	r25, Y+5	; 0x05
    5626:	98 87       	std	Y+8, r25	; 0x08
    5628:	8f 83       	std	Y+7, r24	; 0x07
    562a:	8f 81       	ldd	r24, Y+7	; 0x07
    562c:	98 85       	ldd	r25, Y+8	; 0x08
    562e:	9b 83       	std	Y+3, r25	; 0x03
    5630:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    5632:	0f b6       	in	r0, 0x3f	; 63
    5634:	f8 94       	cli
    5636:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    5638:	8e 81       	ldd	r24, Y+6	; 0x06
    563a:	28 2f       	mov	r18, r24
    563c:	30 e0       	ldi	r19, 0x00	; 0
    563e:	8a 81       	ldd	r24, Y+2	; 0x02
    5640:	9b 81       	ldd	r25, Y+3	; 0x03
    5642:	82 0f       	add	r24, r18
    5644:	93 1f       	adc	r25, r19
    5646:	fc 01       	movw	r30, r24
    5648:	b5 96       	adiw	r30, 0x25	; 37
    564a:	80 81       	ld	r24, Z
    564c:	82 30       	cpi	r24, 0x02	; 2
    564e:	69 f4       	brne	.+26     	; 0x566a <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    5650:	8e 81       	ldd	r24, Y+6	; 0x06
    5652:	28 2f       	mov	r18, r24
    5654:	30 e0       	ldi	r19, 0x00	; 0
    5656:	8a 81       	ldd	r24, Y+2	; 0x02
    5658:	9b 81       	ldd	r25, Y+3	; 0x03
    565a:	82 0f       	add	r24, r18
    565c:	93 1f       	adc	r25, r19
    565e:	fc 01       	movw	r30, r24
    5660:	b5 96       	adiw	r30, 0x25	; 37
    5662:	10 82       	st	Z, r1
                xReturn = pdPASS;
    5664:	81 e0       	ldi	r24, 0x01	; 1
    5666:	89 83       	std	Y+1, r24	; 0x01
    5668:	01 c0       	rjmp	.+2      	; 0x566c <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    566a:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    566c:	0f 90       	pop	r0
    566e:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5670:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5672:	28 96       	adiw	r28, 0x08	; 8
    5674:	0f b6       	in	r0, 0x3f	; 63
    5676:	f8 94       	cli
    5678:	de bf       	out	0x3e, r29	; 62
    567a:	0f be       	out	0x3f, r0	; 63
    567c:	cd bf       	out	0x3d, r28	; 61
    567e:	cf 91       	pop	r28
    5680:	df 91       	pop	r29
    5682:	08 95       	ret

00005684 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    5684:	0f 93       	push	r16
    5686:	1f 93       	push	r17
    5688:	df 93       	push	r29
    568a:	cf 93       	push	r28
    568c:	cd b7       	in	r28, 0x3d	; 61
    568e:	de b7       	in	r29, 0x3e	; 62
    5690:	2f 97       	sbiw	r28, 0x0f	; 15
    5692:	0f b6       	in	r0, 0x3f	; 63
    5694:	f8 94       	cli
    5696:	de bf       	out	0x3e, r29	; 62
    5698:	0f be       	out	0x3f, r0	; 63
    569a:	cd bf       	out	0x3d, r28	; 61
    569c:	98 87       	std	Y+8, r25	; 0x08
    569e:	8f 83       	std	Y+7, r24	; 0x07
    56a0:	69 87       	std	Y+9, r22	; 0x09
    56a2:	2a 87       	std	Y+10, r18	; 0x0a
    56a4:	3b 87       	std	Y+11, r19	; 0x0b
    56a6:	4c 87       	std	Y+12, r20	; 0x0c
    56a8:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    56aa:	8f 81       	ldd	r24, Y+7	; 0x07
    56ac:	98 85       	ldd	r25, Y+8	; 0x08
    56ae:	00 97       	sbiw	r24, 0x00	; 0
    56b0:	39 f4       	brne	.+14     	; 0x56c0 <ulTaskGenericNotifyValueClear+0x3c>
    56b2:	80 91 a6 06 	lds	r24, 0x06A6
    56b6:	90 91 a7 06 	lds	r25, 0x06A7
    56ba:	9f 87       	std	Y+15, r25	; 0x0f
    56bc:	8e 87       	std	Y+14, r24	; 0x0e
    56be:	04 c0       	rjmp	.+8      	; 0x56c8 <ulTaskGenericNotifyValueClear+0x44>
    56c0:	8f 81       	ldd	r24, Y+7	; 0x07
    56c2:	98 85       	ldd	r25, Y+8	; 0x08
    56c4:	9f 87       	std	Y+15, r25	; 0x0f
    56c6:	8e 87       	std	Y+14, r24	; 0x0e
    56c8:	8e 85       	ldd	r24, Y+14	; 0x0e
    56ca:	9f 85       	ldd	r25, Y+15	; 0x0f
    56cc:	9e 83       	std	Y+6, r25	; 0x06
    56ce:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    56d0:	0f b6       	in	r0, 0x3f	; 63
    56d2:	f8 94       	cli
    56d4:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    56d6:	89 85       	ldd	r24, Y+9	; 0x09
    56d8:	88 2f       	mov	r24, r24
    56da:	90 e0       	ldi	r25, 0x00	; 0
    56dc:	2d 81       	ldd	r18, Y+5	; 0x05
    56de:	3e 81       	ldd	r19, Y+6	; 0x06
    56e0:	88 0f       	add	r24, r24
    56e2:	99 1f       	adc	r25, r25
    56e4:	88 0f       	add	r24, r24
    56e6:	99 1f       	adc	r25, r25
    56e8:	82 0f       	add	r24, r18
    56ea:	93 1f       	adc	r25, r19
    56ec:	fc 01       	movw	r30, r24
    56ee:	b1 96       	adiw	r30, 0x21	; 33
    56f0:	80 81       	ld	r24, Z
    56f2:	91 81       	ldd	r25, Z+1	; 0x01
    56f4:	a2 81       	ldd	r26, Z+2	; 0x02
    56f6:	b3 81       	ldd	r27, Z+3	; 0x03
    56f8:	89 83       	std	Y+1, r24	; 0x01
    56fa:	9a 83       	std	Y+2, r25	; 0x02
    56fc:	ab 83       	std	Y+3, r26	; 0x03
    56fe:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    5700:	89 85       	ldd	r24, Y+9	; 0x09
    5702:	08 2f       	mov	r16, r24
    5704:	10 e0       	ldi	r17, 0x00	; 0
    5706:	89 85       	ldd	r24, Y+9	; 0x09
    5708:	88 2f       	mov	r24, r24
    570a:	90 e0       	ldi	r25, 0x00	; 0
    570c:	2d 81       	ldd	r18, Y+5	; 0x05
    570e:	3e 81       	ldd	r19, Y+6	; 0x06
    5710:	88 0f       	add	r24, r24
    5712:	99 1f       	adc	r25, r25
    5714:	88 0f       	add	r24, r24
    5716:	99 1f       	adc	r25, r25
    5718:	82 0f       	add	r24, r18
    571a:	93 1f       	adc	r25, r19
    571c:	fc 01       	movw	r30, r24
    571e:	b1 96       	adiw	r30, 0x21	; 33
    5720:	20 81       	ld	r18, Z
    5722:	31 81       	ldd	r19, Z+1	; 0x01
    5724:	42 81       	ldd	r20, Z+2	; 0x02
    5726:	53 81       	ldd	r21, Z+3	; 0x03
    5728:	8a 85       	ldd	r24, Y+10	; 0x0a
    572a:	9b 85       	ldd	r25, Y+11	; 0x0b
    572c:	ac 85       	ldd	r26, Y+12	; 0x0c
    572e:	bd 85       	ldd	r27, Y+13	; 0x0d
    5730:	80 95       	com	r24
    5732:	90 95       	com	r25
    5734:	a0 95       	com	r26
    5736:	b0 95       	com	r27
    5738:	ba 01       	movw	r22, r20
    573a:	a9 01       	movw	r20, r18
    573c:	48 23       	and	r20, r24
    573e:	59 23       	and	r21, r25
    5740:	6a 23       	and	r22, r26
    5742:	7b 23       	and	r23, r27
    5744:	2d 81       	ldd	r18, Y+5	; 0x05
    5746:	3e 81       	ldd	r19, Y+6	; 0x06
    5748:	c8 01       	movw	r24, r16
    574a:	88 0f       	add	r24, r24
    574c:	99 1f       	adc	r25, r25
    574e:	88 0f       	add	r24, r24
    5750:	99 1f       	adc	r25, r25
    5752:	82 0f       	add	r24, r18
    5754:	93 1f       	adc	r25, r19
    5756:	fc 01       	movw	r30, r24
    5758:	b1 96       	adiw	r30, 0x21	; 33
    575a:	40 83       	st	Z, r20
    575c:	51 83       	std	Z+1, r21	; 0x01
    575e:	62 83       	std	Z+2, r22	; 0x02
    5760:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    5762:	0f 90       	pop	r0
    5764:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    5766:	89 81       	ldd	r24, Y+1	; 0x01
    5768:	9a 81       	ldd	r25, Y+2	; 0x02
    576a:	ab 81       	ldd	r26, Y+3	; 0x03
    576c:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    576e:	bc 01       	movw	r22, r24
    5770:	cd 01       	movw	r24, r26
    5772:	2f 96       	adiw	r28, 0x0f	; 15
    5774:	0f b6       	in	r0, 0x3f	; 63
    5776:	f8 94       	cli
    5778:	de bf       	out	0x3e, r29	; 62
    577a:	0f be       	out	0x3f, r0	; 63
    577c:	cd bf       	out	0x3d, r28	; 61
    577e:	cf 91       	pop	r28
    5780:	df 91       	pop	r29
    5782:	1f 91       	pop	r17
    5784:	0f 91       	pop	r16
    5786:	08 95       	ret

00005788 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    5788:	df 93       	push	r29
    578a:	cf 93       	push	r28
    578c:	cd b7       	in	r28, 0x3d	; 61
    578e:	de b7       	in	r29, 0x3e	; 62
    5790:	27 97       	sbiw	r28, 0x07	; 7
    5792:	0f b6       	in	r0, 0x3f	; 63
    5794:	f8 94       	cli
    5796:	de bf       	out	0x3e, r29	; 62
    5798:	0f be       	out	0x3f, r0	; 63
    579a:	cd bf       	out	0x3d, r28	; 61
    579c:	9e 83       	std	Y+6, r25	; 0x06
    579e:	8d 83       	std	Y+5, r24	; 0x05
    57a0:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    57a2:	80 91 aa 06 	lds	r24, 0x06AA
    57a6:	90 91 ab 06 	lds	r25, 0x06AB
    57aa:	9a 83       	std	Y+2, r25	; 0x02
    57ac:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    57ae:	80 91 a6 06 	lds	r24, 0x06A6
    57b2:	90 91 a7 06 	lds	r25, 0x06A7
    57b6:	02 96       	adiw	r24, 0x02	; 2
    57b8:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the kernel
             * will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    57bc:	29 81       	ldd	r18, Y+1	; 0x01
    57be:	3a 81       	ldd	r19, Y+2	; 0x02
    57c0:	8d 81       	ldd	r24, Y+5	; 0x05
    57c2:	9e 81       	ldd	r25, Y+6	; 0x06
    57c4:	82 0f       	add	r24, r18
    57c6:	93 1f       	adc	r25, r19
    57c8:	9c 83       	std	Y+4, r25	; 0x04
    57ca:	8b 83       	std	Y+3, r24	; 0x03

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    57cc:	e0 91 a6 06 	lds	r30, 0x06A6
    57d0:	f0 91 a7 06 	lds	r31, 0x06A7
    57d4:	8b 81       	ldd	r24, Y+3	; 0x03
    57d6:	9c 81       	ldd	r25, Y+4	; 0x04
    57d8:	93 83       	std	Z+3, r25	; 0x03
    57da:	82 83       	std	Z+2, r24	; 0x02

            if( xTimeToWake < xConstTickCount )
    57dc:	2b 81       	ldd	r18, Y+3	; 0x03
    57de:	3c 81       	ldd	r19, Y+4	; 0x04
    57e0:	89 81       	ldd	r24, Y+1	; 0x01
    57e2:	9a 81       	ldd	r25, Y+2	; 0x02
    57e4:	28 17       	cp	r18, r24
    57e6:	39 07       	cpc	r19, r25
    57e8:	70 f4       	brcc	.+28     	; 0x5806 <prvAddCurrentTaskToDelayedList+0x7e>
            {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    57ea:	80 91 f0 06 	lds	r24, 0x06F0
    57ee:	90 91 f1 06 	lds	r25, 0x06F1
    57f2:	20 91 a6 06 	lds	r18, 0x06A6
    57f6:	30 91 a7 06 	lds	r19, 0x06A7
    57fa:	2e 5f       	subi	r18, 0xFE	; 254
    57fc:	3f 4f       	sbci	r19, 0xFF	; 255
    57fe:	b9 01       	movw	r22, r18
    5800:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <vListInsert>
    5804:	1e c0       	rjmp	.+60     	; 0x5842 <prvAddCurrentTaskToDelayedList+0xba>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5806:	40 91 ee 06 	lds	r20, 0x06EE
    580a:	50 91 ef 06 	lds	r21, 0x06EF
    580e:	80 91 a6 06 	lds	r24, 0x06A6
    5812:	90 91 a7 06 	lds	r25, 0x06A7
    5816:	9c 01       	movw	r18, r24
    5818:	2e 5f       	subi	r18, 0xFE	; 254
    581a:	3f 4f       	sbci	r19, 0xFF	; 255
    581c:	ca 01       	movw	r24, r20
    581e:	b9 01       	movw	r22, r18
    5820:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <vListInsert>

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    5824:	20 91 b3 06 	lds	r18, 0x06B3
    5828:	30 91 b4 06 	lds	r19, 0x06B4
    582c:	8b 81       	ldd	r24, Y+3	; 0x03
    582e:	9c 81       	ldd	r25, Y+4	; 0x04
    5830:	82 17       	cp	r24, r18
    5832:	93 07       	cpc	r25, r19
    5834:	30 f4       	brcc	.+12     	; 0x5842 <prvAddCurrentTaskToDelayedList+0xba>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    5836:	8b 81       	ldd	r24, Y+3	; 0x03
    5838:	9c 81       	ldd	r25, Y+4	; 0x04
    583a:	90 93 b4 06 	sts	0x06B4, r25
    583e:	80 93 b3 06 	sts	0x06B3, r24

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    5842:	27 96       	adiw	r28, 0x07	; 7
    5844:	0f b6       	in	r0, 0x3f	; 63
    5846:	f8 94       	cli
    5848:	de bf       	out	0x3e, r29	; 62
    584a:	0f be       	out	0x3f, r0	; 63
    584c:	cd bf       	out	0x3d, r28	; 61
    584e:	cf 91       	pop	r28
    5850:	df 91       	pop	r29
    5852:	08 95       	ret

00005854 <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
    5854:	ef 92       	push	r14
    5856:	ff 92       	push	r15
    5858:	0f 93       	push	r16
    585a:	df 93       	push	r29
    585c:	cf 93       	push	r28
    585e:	0f 92       	push	r0
    5860:	cd b7       	in	r28, 0x3d	; 61
    5862:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn = pdFAIL;
    5864:	19 82       	std	Y+1, r1	; 0x01

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
    5866:	0e 94 e9 30 	call	0x61d2	; 0x61d2 <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
    586a:	80 91 04 07 	lds	r24, 0x0704
    586e:	90 91 05 07 	lds	r25, 0x0705
    5872:	00 97       	sbiw	r24, 0x00	; 0
    5874:	81 f0       	breq	.+32     	; 0x5896 <xTimerCreateTimerTask+0x42>
                        xReturn = pdPASS;
                    }
                }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
    5876:	8b e7       	ldi	r24, 0x7B	; 123
    5878:	9e e2       	ldi	r25, 0x2E	; 46
    587a:	25 e6       	ldi	r18, 0x65	; 101
    587c:	30 e0       	ldi	r19, 0x00	; 0
    587e:	e6 e0       	ldi	r30, 0x06	; 6
    5880:	f7 e0       	ldi	r31, 0x07	; 7
    5882:	b9 01       	movw	r22, r18
    5884:	45 e5       	ldi	r20, 0x55	; 85
    5886:	50 e0       	ldi	r21, 0x00	; 0
    5888:	20 e0       	ldi	r18, 0x00	; 0
    588a:	30 e0       	ldi	r19, 0x00	; 0
    588c:	03 e0       	ldi	r16, 0x03	; 3
    588e:	7f 01       	movw	r14, r30
    5890:	0e 94 3a 18 	call	0x3074	; 0x3074 <xTaskCreate>
    5894:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
        return xReturn;
    5896:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5898:	0f 90       	pop	r0
    589a:	cf 91       	pop	r28
    589c:	df 91       	pop	r29
    589e:	0f 91       	pop	r16
    58a0:	ff 90       	pop	r15
    58a2:	ef 90       	pop	r14
    58a4:	08 95       	ret

000058a6 <xTimerCreate>:
        TimerHandle_t xTimerCreate( const char * const pcTimerName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                    const TickType_t xTimerPeriodInTicks,
                                    const UBaseType_t uxAutoReload,
                                    void * const pvTimerID,
                                    TimerCallbackFunction_t pxCallbackFunction )
        {
    58a6:	ef 92       	push	r14
    58a8:	ff 92       	push	r15
    58aa:	0f 93       	push	r16
    58ac:	1f 93       	push	r17
    58ae:	df 93       	push	r29
    58b0:	cf 93       	push	r28
    58b2:	cd b7       	in	r28, 0x3d	; 61
    58b4:	de b7       	in	r29, 0x3e	; 62
    58b6:	2b 97       	sbiw	r28, 0x0b	; 11
    58b8:	0f b6       	in	r0, 0x3f	; 63
    58ba:	f8 94       	cli
    58bc:	de bf       	out	0x3e, r29	; 62
    58be:	0f be       	out	0x3f, r0	; 63
    58c0:	cd bf       	out	0x3d, r28	; 61
    58c2:	9c 83       	std	Y+4, r25	; 0x04
    58c4:	8b 83       	std	Y+3, r24	; 0x03
    58c6:	7e 83       	std	Y+6, r23	; 0x06
    58c8:	6d 83       	std	Y+5, r22	; 0x05
    58ca:	4f 83       	std	Y+7, r20	; 0x07
    58cc:	39 87       	std	Y+9, r19	; 0x09
    58ce:	28 87       	std	Y+8, r18	; 0x08
    58d0:	1b 87       	std	Y+11, r17	; 0x0b
    58d2:	0a 87       	std	Y+10, r16	; 0x0a
            Timer_t * pxNewTimer;

            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
    58d4:	83 e1       	ldi	r24, 0x13	; 19
    58d6:	90 e0       	ldi	r25, 0x00	; 0
    58d8:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    58dc:	9a 83       	std	Y+2, r25	; 0x02
    58de:	89 83       	std	Y+1, r24	; 0x01

            if( pxNewTimer != NULL )
    58e0:	89 81       	ldd	r24, Y+1	; 0x01
    58e2:	9a 81       	ldd	r25, Y+2	; 0x02
    58e4:	00 97       	sbiw	r24, 0x00	; 0
    58e6:	99 f0       	breq	.+38     	; 0x590e <xTimerCreate+0x68>
            {
                /* Status is thus far zero as the timer is not created statically
                 * and has not been started.  The auto-reload bit may get set in
                 * prvInitialiseNewTimer. */
                pxNewTimer->ucStatus = 0x00;
    58e8:	e9 81       	ldd	r30, Y+1	; 0x01
    58ea:	fa 81       	ldd	r31, Y+2	; 0x02
    58ec:	12 8a       	std	Z+18, r1	; 0x12
                prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
    58ee:	8b 81       	ldd	r24, Y+3	; 0x03
    58f0:	9c 81       	ldd	r25, Y+4	; 0x04
    58f2:	2d 81       	ldd	r18, Y+5	; 0x05
    58f4:	3e 81       	ldd	r19, Y+6	; 0x06
    58f6:	e8 85       	ldd	r30, Y+8	; 0x08
    58f8:	f9 85       	ldd	r31, Y+9	; 0x09
    58fa:	aa 85       	ldd	r26, Y+10	; 0x0a
    58fc:	bb 85       	ldd	r27, Y+11	; 0x0b
    58fe:	e9 80       	ldd	r14, Y+1	; 0x01
    5900:	fa 80       	ldd	r15, Y+2	; 0x02
    5902:	b9 01       	movw	r22, r18
    5904:	4f 81       	ldd	r20, Y+7	; 0x07
    5906:	9f 01       	movw	r18, r30
    5908:	8d 01       	movw	r16, r26
    590a:	0e 94 96 2c 	call	0x592c	; 0x592c <prvInitialiseNewTimer>
            }

            return pxNewTimer;
    590e:	89 81       	ldd	r24, Y+1	; 0x01
    5910:	9a 81       	ldd	r25, Y+2	; 0x02
        }
    5912:	2b 96       	adiw	r28, 0x0b	; 11
    5914:	0f b6       	in	r0, 0x3f	; 63
    5916:	f8 94       	cli
    5918:	de bf       	out	0x3e, r29	; 62
    591a:	0f be       	out	0x3f, r0	; 63
    591c:	cd bf       	out	0x3d, r28	; 61
    591e:	cf 91       	pop	r28
    5920:	df 91       	pop	r29
    5922:	1f 91       	pop	r17
    5924:	0f 91       	pop	r16
    5926:	ff 90       	pop	r15
    5928:	ef 90       	pop	r14
    592a:	08 95       	ret

0000592c <prvInitialiseNewTimer>:
                                       const TickType_t xTimerPeriodInTicks,
                                       const UBaseType_t uxAutoReload,
                                       void * const pvTimerID,
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer )
    {
    592c:	ef 92       	push	r14
    592e:	ff 92       	push	r15
    5930:	0f 93       	push	r16
    5932:	1f 93       	push	r17
    5934:	df 93       	push	r29
    5936:	cf 93       	push	r28
    5938:	cd b7       	in	r28, 0x3d	; 61
    593a:	de b7       	in	r29, 0x3e	; 62
    593c:	2b 97       	sbiw	r28, 0x0b	; 11
    593e:	0f b6       	in	r0, 0x3f	; 63
    5940:	f8 94       	cli
    5942:	de bf       	out	0x3e, r29	; 62
    5944:	0f be       	out	0x3f, r0	; 63
    5946:	cd bf       	out	0x3d, r28	; 61
    5948:	9a 83       	std	Y+2, r25	; 0x02
    594a:	89 83       	std	Y+1, r24	; 0x01
    594c:	7c 83       	std	Y+4, r23	; 0x04
    594e:	6b 83       	std	Y+3, r22	; 0x03
    5950:	4d 83       	std	Y+5, r20	; 0x05
    5952:	3f 83       	std	Y+7, r19	; 0x07
    5954:	2e 83       	std	Y+6, r18	; 0x06
    5956:	19 87       	std	Y+9, r17	; 0x09
    5958:	08 87       	std	Y+8, r16	; 0x08
    595a:	fb 86       	std	Y+11, r15	; 0x0b
    595c:	ea 86       	std	Y+10, r14	; 0x0a
        /* 0 is not a valid value for xTimerPeriodInTicks. */
        configASSERT( ( xTimerPeriodInTicks > 0 ) );

        /* Ensure the infrastructure used by the timer service task has been
         * created/initialised. */
        prvCheckForValidListAndQueue();
    595e:	0e 94 e9 30 	call	0x61d2	; 0x61d2 <prvCheckForValidListAndQueue>

        /* Initialise the timer structure members using the function
         * parameters. */
        pxNewTimer->pcTimerName = pcTimerName;
    5962:	ea 85       	ldd	r30, Y+10	; 0x0a
    5964:	fb 85       	ldd	r31, Y+11	; 0x0b
    5966:	89 81       	ldd	r24, Y+1	; 0x01
    5968:	9a 81       	ldd	r25, Y+2	; 0x02
    596a:	91 83       	std	Z+1, r25	; 0x01
    596c:	80 83       	st	Z, r24
        pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    596e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5970:	fb 85       	ldd	r31, Y+11	; 0x0b
    5972:	8b 81       	ldd	r24, Y+3	; 0x03
    5974:	9c 81       	ldd	r25, Y+4	; 0x04
    5976:	95 87       	std	Z+13, r25	; 0x0d
    5978:	84 87       	std	Z+12, r24	; 0x0c
        pxNewTimer->pvTimerID = pvTimerID;
    597a:	ea 85       	ldd	r30, Y+10	; 0x0a
    597c:	fb 85       	ldd	r31, Y+11	; 0x0b
    597e:	8e 81       	ldd	r24, Y+6	; 0x06
    5980:	9f 81       	ldd	r25, Y+7	; 0x07
    5982:	97 87       	std	Z+15, r25	; 0x0f
    5984:	86 87       	std	Z+14, r24	; 0x0e
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    5986:	ea 85       	ldd	r30, Y+10	; 0x0a
    5988:	fb 85       	ldd	r31, Y+11	; 0x0b
    598a:	88 85       	ldd	r24, Y+8	; 0x08
    598c:	99 85       	ldd	r25, Y+9	; 0x09
    598e:	91 8b       	std	Z+17, r25	; 0x11
    5990:	80 8b       	std	Z+16, r24	; 0x10
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    5992:	8a 85       	ldd	r24, Y+10	; 0x0a
    5994:	9b 85       	ldd	r25, Y+11	; 0x0b
    5996:	02 96       	adiw	r24, 0x02	; 2
    5998:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <vListInitialiseItem>

        if( uxAutoReload != pdFALSE )
    599c:	8d 81       	ldd	r24, Y+5	; 0x05
    599e:	88 23       	and	r24, r24
    59a0:	39 f0       	breq	.+14     	; 0x59b0 <prvInitialiseNewTimer+0x84>
        {
            pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    59a2:	ea 85       	ldd	r30, Y+10	; 0x0a
    59a4:	fb 85       	ldd	r31, Y+11	; 0x0b
    59a6:	82 89       	ldd	r24, Z+18	; 0x12
    59a8:	84 60       	ori	r24, 0x04	; 4
    59aa:	ea 85       	ldd	r30, Y+10	; 0x0a
    59ac:	fb 85       	ldd	r31, Y+11	; 0x0b
    59ae:	82 8b       	std	Z+18, r24	; 0x12
        }

        traceTIMER_CREATE( pxNewTimer );
    }
    59b0:	2b 96       	adiw	r28, 0x0b	; 11
    59b2:	0f b6       	in	r0, 0x3f	; 63
    59b4:	f8 94       	cli
    59b6:	de bf       	out	0x3e, r29	; 62
    59b8:	0f be       	out	0x3f, r0	; 63
    59ba:	cd bf       	out	0x3d, r28	; 61
    59bc:	cf 91       	pop	r28
    59be:	df 91       	pop	r29
    59c0:	1f 91       	pop	r17
    59c2:	0f 91       	pop	r16
    59c4:	ff 90       	pop	r15
    59c6:	ef 90       	pop	r14
    59c8:	08 95       	ret

000059ca <xTimerGenericCommand>:
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
    59ca:	0f 93       	push	r16
    59cc:	1f 93       	push	r17
    59ce:	df 93       	push	r29
    59d0:	cf 93       	push	r28
    59d2:	cd b7       	in	r28, 0x3d	; 61
    59d4:	de b7       	in	r29, 0x3e	; 62
    59d6:	2f 97       	sbiw	r28, 0x0f	; 15
    59d8:	0f b6       	in	r0, 0x3f	; 63
    59da:	f8 94       	cli
    59dc:	de bf       	out	0x3e, r29	; 62
    59de:	0f be       	out	0x3f, r0	; 63
    59e0:	cd bf       	out	0x3d, r28	; 61
    59e2:	98 87       	std	Y+8, r25	; 0x08
    59e4:	8f 83       	std	Y+7, r24	; 0x07
    59e6:	69 87       	std	Y+9, r22	; 0x09
    59e8:	5b 87       	std	Y+11, r21	; 0x0b
    59ea:	4a 87       	std	Y+10, r20	; 0x0a
    59ec:	3d 87       	std	Y+13, r19	; 0x0d
    59ee:	2c 87       	std	Y+12, r18	; 0x0c
    59f0:	1f 87       	std	Y+15, r17	; 0x0f
    59f2:	0e 87       	std	Y+14, r16	; 0x0e
        BaseType_t xReturn = pdFAIL;
    59f4:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTimer );

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
    59f6:	80 91 04 07 	lds	r24, 0x0704
    59fa:	90 91 05 07 	lds	r25, 0x0705
    59fe:	00 97       	sbiw	r24, 0x00	; 0
    5a00:	e9 f1       	breq	.+122    	; 0x5a7c <xTimerGenericCommand+0xb2>
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
    5a02:	89 85       	ldd	r24, Y+9	; 0x09
    5a04:	8a 83       	std	Y+2, r24	; 0x02
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    5a06:	8a 85       	ldd	r24, Y+10	; 0x0a
    5a08:	9b 85       	ldd	r25, Y+11	; 0x0b
    5a0a:	9c 83       	std	Y+4, r25	; 0x04
    5a0c:	8b 83       	std	Y+3, r24	; 0x03
            xMessage.u.xTimerParameters.pxTimer = xTimer;
    5a0e:	8f 81       	ldd	r24, Y+7	; 0x07
    5a10:	98 85       	ldd	r25, Y+8	; 0x08
    5a12:	9e 83       	std	Y+6, r25	; 0x06
    5a14:	8d 83       	std	Y+5, r24	; 0x05

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    5a16:	89 85       	ldd	r24, Y+9	; 0x09
    5a18:	86 30       	cpi	r24, 0x06	; 6
    5a1a:	14 f5       	brge	.+68     	; 0x5a60 <xTimerGenericCommand+0x96>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    5a1c:	0e 94 ff 23 	call	0x47fe	; 0x47fe <xTaskGetSchedulerState>
    5a20:	82 30       	cpi	r24, 0x02	; 2
    5a22:	79 f4       	brne	.+30     	; 0x5a42 <xTimerGenericCommand+0x78>
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    5a24:	80 91 04 07 	lds	r24, 0x0704
    5a28:	90 91 05 07 	lds	r25, 0x0705
    5a2c:	9e 01       	movw	r18, r28
    5a2e:	2e 5f       	subi	r18, 0xFE	; 254
    5a30:	3f 4f       	sbci	r19, 0xFF	; 255
    5a32:	4e 85       	ldd	r20, Y+14	; 0x0e
    5a34:	5f 85       	ldd	r21, Y+15	; 0x0f
    5a36:	b9 01       	movw	r22, r18
    5a38:	20 e0       	ldi	r18, 0x00	; 0
    5a3a:	0e 94 3e 10 	call	0x207c	; 0x207c <xQueueGenericSend>
    5a3e:	89 83       	std	Y+1, r24	; 0x01
    5a40:	1d c0       	rjmp	.+58     	; 0x5a7c <xTimerGenericCommand+0xb2>
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    5a42:	80 91 04 07 	lds	r24, 0x0704
    5a46:	90 91 05 07 	lds	r25, 0x0705
    5a4a:	9e 01       	movw	r18, r28
    5a4c:	2e 5f       	subi	r18, 0xFE	; 254
    5a4e:	3f 4f       	sbci	r19, 0xFF	; 255
    5a50:	b9 01       	movw	r22, r18
    5a52:	40 e0       	ldi	r20, 0x00	; 0
    5a54:	50 e0       	ldi	r21, 0x00	; 0
    5a56:	20 e0       	ldi	r18, 0x00	; 0
    5a58:	0e 94 3e 10 	call	0x207c	; 0x207c <xQueueGenericSend>
    5a5c:	89 83       	std	Y+1, r24	; 0x01
    5a5e:	0e c0       	rjmp	.+28     	; 0x5a7c <xTimerGenericCommand+0xb2>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    5a60:	80 91 04 07 	lds	r24, 0x0704
    5a64:	90 91 05 07 	lds	r25, 0x0705
    5a68:	9e 01       	movw	r18, r28
    5a6a:	2e 5f       	subi	r18, 0xFE	; 254
    5a6c:	3f 4f       	sbci	r19, 0xFF	; 255
    5a6e:	4c 85       	ldd	r20, Y+12	; 0x0c
    5a70:	5d 85       	ldd	r21, Y+13	; 0x0d
    5a72:	b9 01       	movw	r22, r18
    5a74:	20 e0       	ldi	r18, 0x00	; 0
    5a76:	0e 94 ea 10 	call	0x21d4	; 0x21d4 <xQueueGenericSendFromISR>
    5a7a:	89 83       	std	Y+1, r24	; 0x01
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    5a7c:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5a7e:	2f 96       	adiw	r28, 0x0f	; 15
    5a80:	0f b6       	in	r0, 0x3f	; 63
    5a82:	f8 94       	cli
    5a84:	de bf       	out	0x3e, r29	; 62
    5a86:	0f be       	out	0x3f, r0	; 63
    5a88:	cd bf       	out	0x3d, r28	; 61
    5a8a:	cf 91       	pop	r28
    5a8c:	df 91       	pop	r29
    5a8e:	1f 91       	pop	r17
    5a90:	0f 91       	pop	r16
    5a92:	08 95       	ret

00005a94 <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
    {
    5a94:	df 93       	push	r29
    5a96:	cf 93       	push	r28
    5a98:	cd b7       	in	r28, 0x3d	; 61
    5a9a:	de b7       	in	r29, 0x3e	; 62
        /* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
         * started, then xTimerTaskHandle will be NULL. */
        configASSERT( ( xTimerTaskHandle != NULL ) );
        return xTimerTaskHandle;
    5a9c:	80 91 06 07 	lds	r24, 0x0706
    5aa0:	90 91 07 07 	lds	r25, 0x0707
    }
    5aa4:	cf 91       	pop	r28
    5aa6:	df 91       	pop	r29
    5aa8:	08 95       	ret

00005aaa <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
    {
    5aaa:	df 93       	push	r29
    5aac:	cf 93       	push	r28
    5aae:	00 d0       	rcall	.+0      	; 0x5ab0 <xTimerGetPeriod+0x6>
    5ab0:	00 d0       	rcall	.+0      	; 0x5ab2 <xTimerGetPeriod+0x8>
    5ab2:	cd b7       	in	r28, 0x3d	; 61
    5ab4:	de b7       	in	r29, 0x3e	; 62
    5ab6:	9c 83       	std	Y+4, r25	; 0x04
    5ab8:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    5aba:	8b 81       	ldd	r24, Y+3	; 0x03
    5abc:	9c 81       	ldd	r25, Y+4	; 0x04
    5abe:	9a 83       	std	Y+2, r25	; 0x02
    5ac0:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->xTimerPeriodInTicks;
    5ac2:	e9 81       	ldd	r30, Y+1	; 0x01
    5ac4:	fa 81       	ldd	r31, Y+2	; 0x02
    5ac6:	84 85       	ldd	r24, Z+12	; 0x0c
    5ac8:	95 85       	ldd	r25, Z+13	; 0x0d
    }
    5aca:	0f 90       	pop	r0
    5acc:	0f 90       	pop	r0
    5ace:	0f 90       	pop	r0
    5ad0:	0f 90       	pop	r0
    5ad2:	cf 91       	pop	r28
    5ad4:	df 91       	pop	r29
    5ad6:	08 95       	ret

00005ad8 <vTimerSetReloadMode>:
/*-----------------------------------------------------------*/

    void vTimerSetReloadMode( TimerHandle_t xTimer,
                              const UBaseType_t uxAutoReload )
    {
    5ad8:	df 93       	push	r29
    5ada:	cf 93       	push	r28
    5adc:	00 d0       	rcall	.+0      	; 0x5ade <vTimerSetReloadMode+0x6>
    5ade:	00 d0       	rcall	.+0      	; 0x5ae0 <vTimerSetReloadMode+0x8>
    5ae0:	0f 92       	push	r0
    5ae2:	cd b7       	in	r28, 0x3d	; 61
    5ae4:	de b7       	in	r29, 0x3e	; 62
    5ae6:	9c 83       	std	Y+4, r25	; 0x04
    5ae8:	8b 83       	std	Y+3, r24	; 0x03
    5aea:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * pxTimer = xTimer;
    5aec:	8b 81       	ldd	r24, Y+3	; 0x03
    5aee:	9c 81       	ldd	r25, Y+4	; 0x04
    5af0:	9a 83       	std	Y+2, r25	; 0x02
    5af2:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    5af4:	0f b6       	in	r0, 0x3f	; 63
    5af6:	f8 94       	cli
    5af8:	0f 92       	push	r0
        {
            if( uxAutoReload != pdFALSE )
    5afa:	8d 81       	ldd	r24, Y+5	; 0x05
    5afc:	88 23       	and	r24, r24
    5afe:	41 f0       	breq	.+16     	; 0x5b10 <vTimerSetReloadMode+0x38>
            {
                pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    5b00:	e9 81       	ldd	r30, Y+1	; 0x01
    5b02:	fa 81       	ldd	r31, Y+2	; 0x02
    5b04:	82 89       	ldd	r24, Z+18	; 0x12
    5b06:	84 60       	ori	r24, 0x04	; 4
    5b08:	e9 81       	ldd	r30, Y+1	; 0x01
    5b0a:	fa 81       	ldd	r31, Y+2	; 0x02
    5b0c:	82 8b       	std	Z+18, r24	; 0x12
    5b0e:	07 c0       	rjmp	.+14     	; 0x5b1e <vTimerSetReloadMode+0x46>
            }
            else
            {
                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_AUTORELOAD );
    5b10:	e9 81       	ldd	r30, Y+1	; 0x01
    5b12:	fa 81       	ldd	r31, Y+2	; 0x02
    5b14:	82 89       	ldd	r24, Z+18	; 0x12
    5b16:	8b 7f       	andi	r24, 0xFB	; 251
    5b18:	e9 81       	ldd	r30, Y+1	; 0x01
    5b1a:	fa 81       	ldd	r31, Y+2	; 0x02
    5b1c:	82 8b       	std	Z+18, r24	; 0x12
            }
        }
        taskEXIT_CRITICAL();
    5b1e:	0f 90       	pop	r0
    5b20:	0f be       	out	0x3f, r0	; 63
    }
    5b22:	0f 90       	pop	r0
    5b24:	0f 90       	pop	r0
    5b26:	0f 90       	pop	r0
    5b28:	0f 90       	pop	r0
    5b2a:	0f 90       	pop	r0
    5b2c:	cf 91       	pop	r28
    5b2e:	df 91       	pop	r29
    5b30:	08 95       	ret

00005b32 <uxTimerGetReloadMode>:
/*-----------------------------------------------------------*/

    UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
    {
    5b32:	df 93       	push	r29
    5b34:	cf 93       	push	r28
    5b36:	00 d0       	rcall	.+0      	; 0x5b38 <uxTimerGetReloadMode+0x6>
    5b38:	00 d0       	rcall	.+0      	; 0x5b3a <uxTimerGetReloadMode+0x8>
    5b3a:	0f 92       	push	r0
    5b3c:	cd b7       	in	r28, 0x3d	; 61
    5b3e:	de b7       	in	r29, 0x3e	; 62
    5b40:	9d 83       	std	Y+5, r25	; 0x05
    5b42:	8c 83       	std	Y+4, r24	; 0x04
        Timer_t * pxTimer = xTimer;
    5b44:	8c 81       	ldd	r24, Y+4	; 0x04
    5b46:	9d 81       	ldd	r25, Y+5	; 0x05
    5b48:	9b 83       	std	Y+3, r25	; 0x03
    5b4a:	8a 83       	std	Y+2, r24	; 0x02
        UBaseType_t uxReturn;

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    5b4c:	0f b6       	in	r0, 0x3f	; 63
    5b4e:	f8 94       	cli
    5b50:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
    5b52:	ea 81       	ldd	r30, Y+2	; 0x02
    5b54:	fb 81       	ldd	r31, Y+3	; 0x03
    5b56:	82 89       	ldd	r24, Z+18	; 0x12
    5b58:	88 2f       	mov	r24, r24
    5b5a:	90 e0       	ldi	r25, 0x00	; 0
    5b5c:	84 70       	andi	r24, 0x04	; 4
    5b5e:	90 70       	andi	r25, 0x00	; 0
    5b60:	00 97       	sbiw	r24, 0x00	; 0
    5b62:	11 f4       	brne	.+4      	; 0x5b68 <uxTimerGetReloadMode+0x36>
            {
                /* Not an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdFALSE;
    5b64:	19 82       	std	Y+1, r1	; 0x01
    5b66:	02 c0       	rjmp	.+4      	; 0x5b6c <uxTimerGetReloadMode+0x3a>
            }
            else
            {
                /* Is an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdTRUE;
    5b68:	81 e0       	ldi	r24, 0x01	; 1
    5b6a:	89 83       	std	Y+1, r24	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    5b6c:	0f 90       	pop	r0
    5b6e:	0f be       	out	0x3f, r0	; 63

        return uxReturn;
    5b70:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5b72:	0f 90       	pop	r0
    5b74:	0f 90       	pop	r0
    5b76:	0f 90       	pop	r0
    5b78:	0f 90       	pop	r0
    5b7a:	0f 90       	pop	r0
    5b7c:	cf 91       	pop	r28
    5b7e:	df 91       	pop	r29
    5b80:	08 95       	ret

00005b82 <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
    {
    5b82:	df 93       	push	r29
    5b84:	cf 93       	push	r28
    5b86:	00 d0       	rcall	.+0      	; 0x5b88 <xTimerGetExpiryTime+0x6>
    5b88:	00 d0       	rcall	.+0      	; 0x5b8a <xTimerGetExpiryTime+0x8>
    5b8a:	00 d0       	rcall	.+0      	; 0x5b8c <xTimerGetExpiryTime+0xa>
    5b8c:	cd b7       	in	r28, 0x3d	; 61
    5b8e:	de b7       	in	r29, 0x3e	; 62
    5b90:	9e 83       	std	Y+6, r25	; 0x06
    5b92:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * pxTimer = xTimer;
    5b94:	8d 81       	ldd	r24, Y+5	; 0x05
    5b96:	9e 81       	ldd	r25, Y+6	; 0x06
    5b98:	9c 83       	std	Y+4, r25	; 0x04
    5b9a:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xReturn;

        configASSERT( xTimer );
        xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
    5b9c:	eb 81       	ldd	r30, Y+3	; 0x03
    5b9e:	fc 81       	ldd	r31, Y+4	; 0x04
    5ba0:	82 81       	ldd	r24, Z+2	; 0x02
    5ba2:	93 81       	ldd	r25, Z+3	; 0x03
    5ba4:	9a 83       	std	Y+2, r25	; 0x02
    5ba6:	89 83       	std	Y+1, r24	; 0x01
        return xReturn;
    5ba8:	89 81       	ldd	r24, Y+1	; 0x01
    5baa:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    5bac:	26 96       	adiw	r28, 0x06	; 6
    5bae:	0f b6       	in	r0, 0x3f	; 63
    5bb0:	f8 94       	cli
    5bb2:	de bf       	out	0x3e, r29	; 62
    5bb4:	0f be       	out	0x3f, r0	; 63
    5bb6:	cd bf       	out	0x3d, r28	; 61
    5bb8:	cf 91       	pop	r28
    5bba:	df 91       	pop	r29
    5bbc:	08 95       	ret

00005bbe <pcTimerGetName>:
/*-----------------------------------------------------------*/

    const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
    5bbe:	df 93       	push	r29
    5bc0:	cf 93       	push	r28
    5bc2:	00 d0       	rcall	.+0      	; 0x5bc4 <pcTimerGetName+0x6>
    5bc4:	00 d0       	rcall	.+0      	; 0x5bc6 <pcTimerGetName+0x8>
    5bc6:	cd b7       	in	r28, 0x3d	; 61
    5bc8:	de b7       	in	r29, 0x3e	; 62
    5bca:	9c 83       	std	Y+4, r25	; 0x04
    5bcc:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    5bce:	8b 81       	ldd	r24, Y+3	; 0x03
    5bd0:	9c 81       	ldd	r25, Y+4	; 0x04
    5bd2:	9a 83       	std	Y+2, r25	; 0x02
    5bd4:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->pcTimerName;
    5bd6:	e9 81       	ldd	r30, Y+1	; 0x01
    5bd8:	fa 81       	ldd	r31, Y+2	; 0x02
    5bda:	80 81       	ld	r24, Z
    5bdc:	91 81       	ldd	r25, Z+1	; 0x01
    }
    5bde:	0f 90       	pop	r0
    5be0:	0f 90       	pop	r0
    5be2:	0f 90       	pop	r0
    5be4:	0f 90       	pop	r0
    5be6:	cf 91       	pop	r28
    5be8:	df 91       	pop	r29
    5bea:	08 95       	ret

00005bec <prvReloadTimer>:
/*-----------------------------------------------------------*/

    static void prvReloadTimer( Timer_t * const pxTimer,
                                TickType_t xExpiredTime,
                                const TickType_t xTimeNow )
    {
    5bec:	df 93       	push	r29
    5bee:	cf 93       	push	r28
    5bf0:	00 d0       	rcall	.+0      	; 0x5bf2 <prvReloadTimer+0x6>
    5bf2:	00 d0       	rcall	.+0      	; 0x5bf4 <prvReloadTimer+0x8>
    5bf4:	00 d0       	rcall	.+0      	; 0x5bf6 <prvReloadTimer+0xa>
    5bf6:	cd b7       	in	r28, 0x3d	; 61
    5bf8:	de b7       	in	r29, 0x3e	; 62
    5bfa:	9a 83       	std	Y+2, r25	; 0x02
    5bfc:	89 83       	std	Y+1, r24	; 0x01
    5bfe:	7c 83       	std	Y+4, r23	; 0x04
    5c00:	6b 83       	std	Y+3, r22	; 0x03
    5c02:	5e 83       	std	Y+6, r21	; 0x06
    5c04:	4d 83       	std	Y+5, r20	; 0x05
    5c06:	12 c0       	rjmp	.+36     	; 0x5c2c <prvReloadTimer+0x40>
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
        {
            /* Advance the expiry time. */
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
    5c08:	e9 81       	ldd	r30, Y+1	; 0x01
    5c0a:	fa 81       	ldd	r31, Y+2	; 0x02
    5c0c:	24 85       	ldd	r18, Z+12	; 0x0c
    5c0e:	35 85       	ldd	r19, Z+13	; 0x0d
    5c10:	8b 81       	ldd	r24, Y+3	; 0x03
    5c12:	9c 81       	ldd	r25, Y+4	; 0x04
    5c14:	82 0f       	add	r24, r18
    5c16:	93 1f       	adc	r25, r19
    5c18:	9c 83       	std	Y+4, r25	; 0x04
    5c1a:	8b 83       	std	Y+3, r24	; 0x03

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    5c1c:	e9 81       	ldd	r30, Y+1	; 0x01
    5c1e:	fa 81       	ldd	r31, Y+2	; 0x02
    5c20:	00 88       	ldd	r0, Z+16	; 0x10
    5c22:	f1 89       	ldd	r31, Z+17	; 0x11
    5c24:	e0 2d       	mov	r30, r0
    5c26:	89 81       	ldd	r24, Y+1	; 0x01
    5c28:	9a 81       	ldd	r25, Y+2	; 0x02
    5c2a:	09 95       	icall
                                const TickType_t xTimeNow )
    {
        /* Insert the timer into the appropriate list for the next expiry time.
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
    5c2c:	e9 81       	ldd	r30, Y+1	; 0x01
    5c2e:	fa 81       	ldd	r31, Y+2	; 0x02
    5c30:	24 85       	ldd	r18, Z+12	; 0x0c
    5c32:	35 85       	ldd	r19, Z+13	; 0x0d
    5c34:	8b 81       	ldd	r24, Y+3	; 0x03
    5c36:	9c 81       	ldd	r25, Y+4	; 0x04
    5c38:	a9 01       	movw	r20, r18
    5c3a:	48 0f       	add	r20, r24
    5c3c:	59 1f       	adc	r21, r25
    5c3e:	89 81       	ldd	r24, Y+1	; 0x01
    5c40:	9a 81       	ldd	r25, Y+2	; 0x02
    5c42:	2d 81       	ldd	r18, Y+5	; 0x05
    5c44:	3e 81       	ldd	r19, Y+6	; 0x06
    5c46:	eb 81       	ldd	r30, Y+3	; 0x03
    5c48:	fc 81       	ldd	r31, Y+4	; 0x04
    5c4a:	ba 01       	movw	r22, r20
    5c4c:	a9 01       	movw	r20, r18
    5c4e:	9f 01       	movw	r18, r30
    5c50:	0e 94 4c 2f 	call	0x5e98	; 0x5e98 <prvInsertTimerInActiveList>
    5c54:	88 23       	and	r24, r24
    5c56:	c1 f6       	brne	.-80     	; 0x5c08 <prvReloadTimer+0x1c>

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
        }
    }
    5c58:	26 96       	adiw	r28, 0x06	; 6
    5c5a:	0f b6       	in	r0, 0x3f	; 63
    5c5c:	f8 94       	cli
    5c5e:	de bf       	out	0x3e, r29	; 62
    5c60:	0f be       	out	0x3f, r0	; 63
    5c62:	cd bf       	out	0x3d, r28	; 61
    5c64:	cf 91       	pop	r28
    5c66:	df 91       	pop	r29
    5c68:	08 95       	ret

00005c6a <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
    5c6a:	df 93       	push	r29
    5c6c:	cf 93       	push	r28
    5c6e:	00 d0       	rcall	.+0      	; 0x5c70 <prvProcessExpiredTimer+0x6>
    5c70:	00 d0       	rcall	.+0      	; 0x5c72 <prvProcessExpiredTimer+0x8>
    5c72:	00 d0       	rcall	.+0      	; 0x5c74 <prvProcessExpiredTimer+0xa>
    5c74:	cd b7       	in	r28, 0x3d	; 61
    5c76:	de b7       	in	r29, 0x3e	; 62
    5c78:	9c 83       	std	Y+4, r25	; 0x04
    5c7a:	8b 83       	std	Y+3, r24	; 0x03
    5c7c:	7e 83       	std	Y+6, r23	; 0x06
    5c7e:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5c80:	e0 91 1c 07 	lds	r30, 0x071C
    5c84:	f0 91 1d 07 	lds	r31, 0x071D
    5c88:	05 80       	ldd	r0, Z+5	; 0x05
    5c8a:	f6 81       	ldd	r31, Z+6	; 0x06
    5c8c:	e0 2d       	mov	r30, r0
    5c8e:	86 81       	ldd	r24, Z+6	; 0x06
    5c90:	97 81       	ldd	r25, Z+7	; 0x07
    5c92:	9a 83       	std	Y+2, r25	; 0x02
    5c94:	89 83       	std	Y+1, r24	; 0x01

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    5c96:	89 81       	ldd	r24, Y+1	; 0x01
    5c98:	9a 81       	ldd	r25, Y+2	; 0x02
    5c9a:	02 96       	adiw	r24, 0x02	; 2
    5c9c:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <uxListRemove>

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    5ca0:	e9 81       	ldd	r30, Y+1	; 0x01
    5ca2:	fa 81       	ldd	r31, Y+2	; 0x02
    5ca4:	82 89       	ldd	r24, Z+18	; 0x12
    5ca6:	88 2f       	mov	r24, r24
    5ca8:	90 e0       	ldi	r25, 0x00	; 0
    5caa:	84 70       	andi	r24, 0x04	; 4
    5cac:	90 70       	andi	r25, 0x00	; 0
    5cae:	00 97       	sbiw	r24, 0x00	; 0
    5cb0:	51 f0       	breq	.+20     	; 0x5cc6 <prvProcessExpiredTimer+0x5c>
        {
            prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
    5cb2:	89 81       	ldd	r24, Y+1	; 0x01
    5cb4:	9a 81       	ldd	r25, Y+2	; 0x02
    5cb6:	2b 81       	ldd	r18, Y+3	; 0x03
    5cb8:	3c 81       	ldd	r19, Y+4	; 0x04
    5cba:	4d 81       	ldd	r20, Y+5	; 0x05
    5cbc:	5e 81       	ldd	r21, Y+6	; 0x06
    5cbe:	b9 01       	movw	r22, r18
    5cc0:	0e 94 f6 2d 	call	0x5bec	; 0x5bec <prvReloadTimer>
    5cc4:	07 c0       	rjmp	.+14     	; 0x5cd4 <prvProcessExpiredTimer+0x6a>
        }
        else
        {
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    5cc6:	e9 81       	ldd	r30, Y+1	; 0x01
    5cc8:	fa 81       	ldd	r31, Y+2	; 0x02
    5cca:	82 89       	ldd	r24, Z+18	; 0x12
    5ccc:	8e 7f       	andi	r24, 0xFE	; 254
    5cce:	e9 81       	ldd	r30, Y+1	; 0x01
    5cd0:	fa 81       	ldd	r31, Y+2	; 0x02
    5cd2:	82 8b       	std	Z+18, r24	; 0x12
        }

        /* Call the timer callback. */
        traceTIMER_EXPIRED( pxTimer );
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    5cd4:	e9 81       	ldd	r30, Y+1	; 0x01
    5cd6:	fa 81       	ldd	r31, Y+2	; 0x02
    5cd8:	00 88       	ldd	r0, Z+16	; 0x10
    5cda:	f1 89       	ldd	r31, Z+17	; 0x11
    5cdc:	e0 2d       	mov	r30, r0
    5cde:	89 81       	ldd	r24, Y+1	; 0x01
    5ce0:	9a 81       	ldd	r25, Y+2	; 0x02
    5ce2:	09 95       	icall
    }
    5ce4:	26 96       	adiw	r28, 0x06	; 6
    5ce6:	0f b6       	in	r0, 0x3f	; 63
    5ce8:	f8 94       	cli
    5cea:	de bf       	out	0x3e, r29	; 62
    5cec:	0f be       	out	0x3f, r0	; 63
    5cee:	cd bf       	out	0x3d, r28	; 61
    5cf0:	cf 91       	pop	r28
    5cf2:	df 91       	pop	r29
    5cf4:	08 95       	ret

00005cf6 <prvTimerTask>:
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
    5cf6:	df 93       	push	r29
    5cf8:	cf 93       	push	r28
    5cfa:	00 d0       	rcall	.+0      	; 0x5cfc <prvTimerTask+0x6>
    5cfc:	00 d0       	rcall	.+0      	; 0x5cfe <prvTimerTask+0x8>
    5cfe:	0f 92       	push	r0
    5d00:	cd b7       	in	r28, 0x3d	; 61
    5d02:	de b7       	in	r29, 0x3e	; 62
    5d04:	9d 83       	std	Y+5, r25	; 0x05
    5d06:	8c 83       	std	Y+4, r24	; 0x04

        for( ; ; )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    5d08:	ce 01       	movw	r24, r28
    5d0a:	03 96       	adiw	r24, 0x03	; 3
    5d0c:	0e 94 ea 2e 	call	0x5dd4	; 0x5dd4 <prvGetNextExpireTime>
    5d10:	9a 83       	std	Y+2, r25	; 0x02
    5d12:	89 83       	std	Y+1, r24	; 0x01

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    5d14:	2b 81       	ldd	r18, Y+3	; 0x03
    5d16:	89 81       	ldd	r24, Y+1	; 0x01
    5d18:	9a 81       	ldd	r25, Y+2	; 0x02
    5d1a:	62 2f       	mov	r22, r18
    5d1c:	0e 94 93 2e 	call	0x5d26	; 0x5d26 <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
    5d20:	0e 94 b4 2f 	call	0x5f68	; 0x5f68 <prvProcessReceivedCommands>
    5d24:	f1 cf       	rjmp	.-30     	; 0x5d08 <prvTimerTask+0x12>

00005d26 <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
    5d26:	df 93       	push	r29
    5d28:	cf 93       	push	r28
    5d2a:	00 d0       	rcall	.+0      	; 0x5d2c <prvProcessTimerOrBlockTask+0x6>
    5d2c:	00 d0       	rcall	.+0      	; 0x5d2e <prvProcessTimerOrBlockTask+0x8>
    5d2e:	00 d0       	rcall	.+0      	; 0x5d30 <prvProcessTimerOrBlockTask+0xa>
    5d30:	cd b7       	in	r28, 0x3d	; 61
    5d32:	de b7       	in	r29, 0x3e	; 62
    5d34:	9d 83       	std	Y+5, r25	; 0x05
    5d36:	8c 83       	std	Y+4, r24	; 0x04
    5d38:	6e 83       	std	Y+6, r22	; 0x06
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
    5d3a:	0e 94 8b 1b 	call	0x3716	; 0x3716 <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    5d3e:	ce 01       	movw	r24, r28
    5d40:	03 96       	adiw	r24, 0x03	; 3
    5d42:	0e 94 1e 2f 	call	0x5e3c	; 0x5e3c <prvSampleTimeNow>
    5d46:	9a 83       	std	Y+2, r25	; 0x02
    5d48:	89 83       	std	Y+1, r24	; 0x01

            if( xTimerListsWereSwitched == pdFALSE )
    5d4a:	8b 81       	ldd	r24, Y+3	; 0x03
    5d4c:	88 23       	and	r24, r24
    5d4e:	b9 f5       	brne	.+110    	; 0x5dbe <prvProcessTimerOrBlockTask+0x98>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    5d50:	8e 81       	ldd	r24, Y+6	; 0x06
    5d52:	88 23       	and	r24, r24
    5d54:	89 f4       	brne	.+34     	; 0x5d78 <prvProcessTimerOrBlockTask+0x52>
    5d56:	2c 81       	ldd	r18, Y+4	; 0x04
    5d58:	3d 81       	ldd	r19, Y+5	; 0x05
    5d5a:	89 81       	ldd	r24, Y+1	; 0x01
    5d5c:	9a 81       	ldd	r25, Y+2	; 0x02
    5d5e:	82 17       	cp	r24, r18
    5d60:	93 07       	cpc	r25, r19
    5d62:	50 f0       	brcs	.+20     	; 0x5d78 <prvProcessTimerOrBlockTask+0x52>
                {
                    ( void ) xTaskResumeAll();
    5d64:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    5d68:	8c 81       	ldd	r24, Y+4	; 0x04
    5d6a:	9d 81       	ldd	r25, Y+5	; 0x05
    5d6c:	29 81       	ldd	r18, Y+1	; 0x01
    5d6e:	3a 81       	ldd	r19, Y+2	; 0x02
    5d70:	b9 01       	movw	r22, r18
    5d72:	0e 94 35 2e 	call	0x5c6a	; 0x5c6a <prvProcessExpiredTimer>
    5d76:	25 c0       	rjmp	.+74     	; 0x5dc2 <prvProcessTimerOrBlockTask+0x9c>
                     * time has not been reached yet.  This task should therefore
                     * block to wait for the next expire time or a command to be
                     * received - whichever comes first.  The following line cannot
                     * be reached unless xNextExpireTime > xTimeNow, except in the
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
    5d78:	8e 81       	ldd	r24, Y+6	; 0x06
    5d7a:	88 23       	and	r24, r24
    5d7c:	51 f0       	breq	.+20     	; 0x5d92 <prvProcessTimerOrBlockTask+0x6c>
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    5d7e:	e0 91 1e 07 	lds	r30, 0x071E
    5d82:	f0 91 1f 07 	lds	r31, 0x071F
    5d86:	80 81       	ld	r24, Z
    5d88:	1e 82       	std	Y+6, r1	; 0x06
    5d8a:	88 23       	and	r24, r24
    5d8c:	11 f4       	brne	.+4      	; 0x5d92 <prvProcessTimerOrBlockTask+0x6c>
    5d8e:	81 e0       	ldi	r24, 0x01	; 1
    5d90:	8e 83       	std	Y+6, r24	; 0x06
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    5d92:	40 91 04 07 	lds	r20, 0x0704
    5d96:	50 91 05 07 	lds	r21, 0x0705
    5d9a:	2c 81       	ldd	r18, Y+4	; 0x04
    5d9c:	3d 81       	ldd	r19, Y+5	; 0x05
    5d9e:	89 81       	ldd	r24, Y+1	; 0x01
    5da0:	9a 81       	ldd	r25, Y+2	; 0x02
    5da2:	28 1b       	sub	r18, r24
    5da4:	39 0b       	sbc	r19, r25
    5da6:	ca 01       	movw	r24, r20
    5da8:	b9 01       	movw	r22, r18
    5daa:	4e 81       	ldd	r20, Y+6	; 0x06
    5dac:	0e 94 f7 17 	call	0x2fee	; 0x2fee <vQueueWaitForMessageRestricted>

                    if( xTaskResumeAll() == pdFALSE )
    5db0:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>
    5db4:	88 23       	and	r24, r24
    5db6:	29 f4       	brne	.+10     	; 0x5dc2 <prvProcessTimerOrBlockTask+0x9c>
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
    5db8:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    5dbc:	02 c0       	rjmp	.+4      	; 0x5dc2 <prvProcessTimerOrBlockTask+0x9c>
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
    5dbe:	0e 94 97 1b 	call	0x372e	; 0x372e <xTaskResumeAll>
            }
        }
    }
    5dc2:	26 96       	adiw	r28, 0x06	; 6
    5dc4:	0f b6       	in	r0, 0x3f	; 63
    5dc6:	f8 94       	cli
    5dc8:	de bf       	out	0x3e, r29	; 62
    5dca:	0f be       	out	0x3f, r0	; 63
    5dcc:	cd bf       	out	0x3d, r28	; 61
    5dce:	cf 91       	pop	r28
    5dd0:	df 91       	pop	r29
    5dd2:	08 95       	ret

00005dd4 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
    5dd4:	df 93       	push	r29
    5dd6:	cf 93       	push	r28
    5dd8:	00 d0       	rcall	.+0      	; 0x5dda <prvGetNextExpireTime+0x6>
    5dda:	00 d0       	rcall	.+0      	; 0x5ddc <prvGetNextExpireTime+0x8>
    5ddc:	0f 92       	push	r0
    5dde:	cd b7       	in	r28, 0x3d	; 61
    5de0:	de b7       	in	r29, 0x3e	; 62
    5de2:	9c 83       	std	Y+4, r25	; 0x04
    5de4:	8b 83       	std	Y+3, r24	; 0x03
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    5de6:	e0 91 1c 07 	lds	r30, 0x071C
    5dea:	f0 91 1d 07 	lds	r31, 0x071D
    5dee:	80 81       	ld	r24, Z
    5df0:	1d 82       	std	Y+5, r1	; 0x05
    5df2:	88 23       	and	r24, r24
    5df4:	11 f4       	brne	.+4      	; 0x5dfa <prvGetNextExpireTime+0x26>
    5df6:	81 e0       	ldi	r24, 0x01	; 1
    5df8:	8d 83       	std	Y+5, r24	; 0x05
    5dfa:	eb 81       	ldd	r30, Y+3	; 0x03
    5dfc:	fc 81       	ldd	r31, Y+4	; 0x04
    5dfe:	8d 81       	ldd	r24, Y+5	; 0x05
    5e00:	80 83       	st	Z, r24

        if( *pxListWasEmpty == pdFALSE )
    5e02:	eb 81       	ldd	r30, Y+3	; 0x03
    5e04:	fc 81       	ldd	r31, Y+4	; 0x04
    5e06:	80 81       	ld	r24, Z
    5e08:	88 23       	and	r24, r24
    5e0a:	61 f4       	brne	.+24     	; 0x5e24 <prvGetNextExpireTime+0x50>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    5e0c:	e0 91 1c 07 	lds	r30, 0x071C
    5e10:	f0 91 1d 07 	lds	r31, 0x071D
    5e14:	05 80       	ldd	r0, Z+5	; 0x05
    5e16:	f6 81       	ldd	r31, Z+6	; 0x06
    5e18:	e0 2d       	mov	r30, r0
    5e1a:	80 81       	ld	r24, Z
    5e1c:	91 81       	ldd	r25, Z+1	; 0x01
    5e1e:	9a 83       	std	Y+2, r25	; 0x02
    5e20:	89 83       	std	Y+1, r24	; 0x01
    5e22:	02 c0       	rjmp	.+4      	; 0x5e28 <prvGetNextExpireTime+0x54>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
    5e24:	1a 82       	std	Y+2, r1	; 0x02
    5e26:	19 82       	std	Y+1, r1	; 0x01
        }

        return xNextExpireTime;
    5e28:	89 81       	ldd	r24, Y+1	; 0x01
    5e2a:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    5e2c:	0f 90       	pop	r0
    5e2e:	0f 90       	pop	r0
    5e30:	0f 90       	pop	r0
    5e32:	0f 90       	pop	r0
    5e34:	0f 90       	pop	r0
    5e36:	cf 91       	pop	r28
    5e38:	df 91       	pop	r29
    5e3a:	08 95       	ret

00005e3c <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
    5e3c:	df 93       	push	r29
    5e3e:	cf 93       	push	r28
    5e40:	00 d0       	rcall	.+0      	; 0x5e42 <prvSampleTimeNow+0x6>
    5e42:	00 d0       	rcall	.+0      	; 0x5e44 <prvSampleTimeNow+0x8>
    5e44:	cd b7       	in	r28, 0x3d	; 61
    5e46:	de b7       	in	r29, 0x3e	; 62
    5e48:	9c 83       	std	Y+4, r25	; 0x04
    5e4a:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
    5e4c:	0e 94 e7 1c 	call	0x39ce	; 0x39ce <xTaskGetTickCount>
    5e50:	9a 83       	std	Y+2, r25	; 0x02
    5e52:	89 83       	std	Y+1, r24	; 0x01

        if( xTimeNow < xLastTime )
    5e54:	20 91 08 07 	lds	r18, 0x0708
    5e58:	30 91 09 07 	lds	r19, 0x0709
    5e5c:	89 81       	ldd	r24, Y+1	; 0x01
    5e5e:	9a 81       	ldd	r25, Y+2	; 0x02
    5e60:	82 17       	cp	r24, r18
    5e62:	93 07       	cpc	r25, r19
    5e64:	38 f4       	brcc	.+14     	; 0x5e74 <prvSampleTimeNow+0x38>
        {
            prvSwitchTimerLists();
    5e66:	0e 94 af 30 	call	0x615e	; 0x615e <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
    5e6a:	eb 81       	ldd	r30, Y+3	; 0x03
    5e6c:	fc 81       	ldd	r31, Y+4	; 0x04
    5e6e:	81 e0       	ldi	r24, 0x01	; 1
    5e70:	80 83       	st	Z, r24
    5e72:	03 c0       	rjmp	.+6      	; 0x5e7a <prvSampleTimeNow+0x3e>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
    5e74:	eb 81       	ldd	r30, Y+3	; 0x03
    5e76:	fc 81       	ldd	r31, Y+4	; 0x04
    5e78:	10 82       	st	Z, r1
        }

        xLastTime = xTimeNow;
    5e7a:	89 81       	ldd	r24, Y+1	; 0x01
    5e7c:	9a 81       	ldd	r25, Y+2	; 0x02
    5e7e:	90 93 09 07 	sts	0x0709, r25
    5e82:	80 93 08 07 	sts	0x0708, r24

        return xTimeNow;
    5e86:	89 81       	ldd	r24, Y+1	; 0x01
    5e88:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    5e8a:	0f 90       	pop	r0
    5e8c:	0f 90       	pop	r0
    5e8e:	0f 90       	pop	r0
    5e90:	0f 90       	pop	r0
    5e92:	cf 91       	pop	r28
    5e94:	df 91       	pop	r29
    5e96:	08 95       	ret

00005e98 <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
    5e98:	df 93       	push	r29
    5e9a:	cf 93       	push	r28
    5e9c:	cd b7       	in	r28, 0x3d	; 61
    5e9e:	de b7       	in	r29, 0x3e	; 62
    5ea0:	29 97       	sbiw	r28, 0x09	; 9
    5ea2:	0f b6       	in	r0, 0x3f	; 63
    5ea4:	f8 94       	cli
    5ea6:	de bf       	out	0x3e, r29	; 62
    5ea8:	0f be       	out	0x3f, r0	; 63
    5eaa:	cd bf       	out	0x3d, r28	; 61
    5eac:	9b 83       	std	Y+3, r25	; 0x03
    5eae:	8a 83       	std	Y+2, r24	; 0x02
    5eb0:	7d 83       	std	Y+5, r23	; 0x05
    5eb2:	6c 83       	std	Y+4, r22	; 0x04
    5eb4:	5f 83       	std	Y+7, r21	; 0x07
    5eb6:	4e 83       	std	Y+6, r20	; 0x06
    5eb8:	39 87       	std	Y+9, r19	; 0x09
    5eba:	28 87       	std	Y+8, r18	; 0x08
        BaseType_t xProcessTimerNow = pdFALSE;
    5ebc:	19 82       	std	Y+1, r1	; 0x01

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    5ebe:	ea 81       	ldd	r30, Y+2	; 0x02
    5ec0:	fb 81       	ldd	r31, Y+3	; 0x03
    5ec2:	8c 81       	ldd	r24, Y+4	; 0x04
    5ec4:	9d 81       	ldd	r25, Y+5	; 0x05
    5ec6:	93 83       	std	Z+3, r25	; 0x03
    5ec8:	82 83       	std	Z+2, r24	; 0x02
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    5eca:	ea 81       	ldd	r30, Y+2	; 0x02
    5ecc:	fb 81       	ldd	r31, Y+3	; 0x03
    5ece:	8a 81       	ldd	r24, Y+2	; 0x02
    5ed0:	9b 81       	ldd	r25, Y+3	; 0x03
    5ed2:	91 87       	std	Z+9, r25	; 0x09
    5ed4:	80 87       	std	Z+8, r24	; 0x08

        if( xNextExpiryTime <= xTimeNow )
    5ed6:	2c 81       	ldd	r18, Y+4	; 0x04
    5ed8:	3d 81       	ldd	r19, Y+5	; 0x05
    5eda:	8e 81       	ldd	r24, Y+6	; 0x06
    5edc:	9f 81       	ldd	r25, Y+7	; 0x07
    5ede:	82 17       	cp	r24, r18
    5ee0:	93 07       	cpc	r25, r19
    5ee2:	e0 f0       	brcs	.+56     	; 0x5f1c <prvInsertTimerInActiveList+0x84>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5ee4:	2e 81       	ldd	r18, Y+6	; 0x06
    5ee6:	3f 81       	ldd	r19, Y+7	; 0x07
    5ee8:	88 85       	ldd	r24, Y+8	; 0x08
    5eea:	99 85       	ldd	r25, Y+9	; 0x09
    5eec:	28 1b       	sub	r18, r24
    5eee:	39 0b       	sbc	r19, r25
    5ef0:	ea 81       	ldd	r30, Y+2	; 0x02
    5ef2:	fb 81       	ldd	r31, Y+3	; 0x03
    5ef4:	84 85       	ldd	r24, Z+12	; 0x0c
    5ef6:	95 85       	ldd	r25, Z+13	; 0x0d
    5ef8:	28 17       	cp	r18, r24
    5efa:	39 07       	cpc	r19, r25
    5efc:	18 f0       	brcs	.+6      	; 0x5f04 <prvInsertTimerInActiveList+0x6c>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
    5efe:	81 e0       	ldi	r24, 0x01	; 1
    5f00:	89 83       	std	Y+1, r24	; 0x01
    5f02:	28 c0       	rjmp	.+80     	; 0x5f54 <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    5f04:	80 91 1e 07 	lds	r24, 0x071E
    5f08:	90 91 1f 07 	lds	r25, 0x071F
    5f0c:	2a 81       	ldd	r18, Y+2	; 0x02
    5f0e:	3b 81       	ldd	r19, Y+3	; 0x03
    5f10:	2e 5f       	subi	r18, 0xFE	; 254
    5f12:	3f 4f       	sbci	r19, 0xFF	; 255
    5f14:	b9 01       	movw	r22, r18
    5f16:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <vListInsert>
    5f1a:	1c c0       	rjmp	.+56     	; 0x5f54 <prvInsertTimerInActiveList+0xbc>
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    5f1c:	2e 81       	ldd	r18, Y+6	; 0x06
    5f1e:	3f 81       	ldd	r19, Y+7	; 0x07
    5f20:	88 85       	ldd	r24, Y+8	; 0x08
    5f22:	99 85       	ldd	r25, Y+9	; 0x09
    5f24:	28 17       	cp	r18, r24
    5f26:	39 07       	cpc	r19, r25
    5f28:	50 f4       	brcc	.+20     	; 0x5f3e <prvInsertTimerInActiveList+0xa6>
    5f2a:	2c 81       	ldd	r18, Y+4	; 0x04
    5f2c:	3d 81       	ldd	r19, Y+5	; 0x05
    5f2e:	88 85       	ldd	r24, Y+8	; 0x08
    5f30:	99 85       	ldd	r25, Y+9	; 0x09
    5f32:	28 17       	cp	r18, r24
    5f34:	39 07       	cpc	r19, r25
    5f36:	18 f0       	brcs	.+6      	; 0x5f3e <prvInsertTimerInActiveList+0xa6>
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
    5f38:	81 e0       	ldi	r24, 0x01	; 1
    5f3a:	89 83       	std	Y+1, r24	; 0x01
    5f3c:	0b c0       	rjmp	.+22     	; 0x5f54 <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    5f3e:	80 91 1c 07 	lds	r24, 0x071C
    5f42:	90 91 1d 07 	lds	r25, 0x071D
    5f46:	2a 81       	ldd	r18, Y+2	; 0x02
    5f48:	3b 81       	ldd	r19, Y+3	; 0x03
    5f4a:	2e 5f       	subi	r18, 0xFE	; 254
    5f4c:	3f 4f       	sbci	r19, 0xFF	; 255
    5f4e:	b9 01       	movw	r22, r18
    5f50:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <vListInsert>
            }
        }

        return xProcessTimerNow;
    5f54:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5f56:	29 96       	adiw	r28, 0x09	; 9
    5f58:	0f b6       	in	r0, 0x3f	; 63
    5f5a:	f8 94       	cli
    5f5c:	de bf       	out	0x3e, r29	; 62
    5f5e:	0f be       	out	0x3f, r0	; 63
    5f60:	cd bf       	out	0x3d, r28	; 61
    5f62:	cf 91       	pop	r28
    5f64:	df 91       	pop	r29
    5f66:	08 95       	ret

00005f68 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
    5f68:	df 93       	push	r29
    5f6a:	cf 93       	push	r28
    5f6c:	cd b7       	in	r28, 0x3d	; 61
    5f6e:	de b7       	in	r29, 0x3e	; 62
    5f70:	2c 97       	sbiw	r28, 0x0c	; 12
    5f72:	0f b6       	in	r0, 0x3f	; 63
    5f74:	f8 94       	cli
    5f76:	de bf       	out	0x3e, r29	; 62
    5f78:	0f be       	out	0x3f, r0	; 63
    5f7a:	cd bf       	out	0x3d, r28	; 61
    5f7c:	d8 c0       	rjmp	.+432    	; 0x612e <prvProcessReceivedCommands+0x1c6>
                }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    5f7e:	8d 81       	ldd	r24, Y+5	; 0x05
    5f80:	88 23       	and	r24, r24
    5f82:	0c f4       	brge	.+2      	; 0x5f86 <prvProcessReceivedCommands+0x1e>
    5f84:	d4 c0       	rjmp	.+424    	; 0x612e <prvProcessReceivedCommands+0x1c6>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
    5f86:	88 85       	ldd	r24, Y+8	; 0x08
    5f88:	99 85       	ldd	r25, Y+9	; 0x09
    5f8a:	9c 83       	std	Y+4, r25	; 0x04
    5f8c:	8b 83       	std	Y+3, r24	; 0x03

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    5f8e:	eb 81       	ldd	r30, Y+3	; 0x03
    5f90:	fc 81       	ldd	r31, Y+4	; 0x04
    5f92:	82 85       	ldd	r24, Z+10	; 0x0a
    5f94:	93 85       	ldd	r25, Z+11	; 0x0b
    5f96:	00 97       	sbiw	r24, 0x00	; 0
    5f98:	29 f0       	breq	.+10     	; 0x5fa4 <prvProcessReceivedCommands+0x3c>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    5f9a:	8b 81       	ldd	r24, Y+3	; 0x03
    5f9c:	9c 81       	ldd	r25, Y+4	; 0x04
    5f9e:	02 96       	adiw	r24, 0x02	; 2
    5fa0:	0e 94 98 0e 	call	0x1d30	; 0x1d30 <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    5fa4:	ce 01       	movw	r24, r28
    5fa6:	0a 96       	adiw	r24, 0x0a	; 10
    5fa8:	0e 94 1e 2f 	call	0x5e3c	; 0x5e3c <prvSampleTimeNow>
    5fac:	9a 83       	std	Y+2, r25	; 0x02
    5fae:	89 83       	std	Y+1, r24	; 0x01

                switch( xMessage.xMessageID )
    5fb0:	8d 81       	ldd	r24, Y+5	; 0x05
    5fb2:	28 2f       	mov	r18, r24
    5fb4:	33 27       	eor	r19, r19
    5fb6:	27 fd       	sbrc	r18, 7
    5fb8:	30 95       	com	r19
    5fba:	3c 87       	std	Y+12, r19	; 0x0c
    5fbc:	2b 87       	std	Y+11, r18	; 0x0b
    5fbe:	8b 85       	ldd	r24, Y+11	; 0x0b
    5fc0:	9c 85       	ldd	r25, Y+12	; 0x0c
    5fc2:	85 30       	cpi	r24, 0x05	; 5
    5fc4:	91 05       	cpc	r25, r1
    5fc6:	09 f4       	brne	.+2      	; 0x5fca <prvProcessReceivedCommands+0x62>
    5fc8:	9d c0       	rjmp	.+314    	; 0x6104 <prvProcessReceivedCommands+0x19c>
    5fca:	2b 85       	ldd	r18, Y+11	; 0x0b
    5fcc:	3c 85       	ldd	r19, Y+12	; 0x0c
    5fce:	26 30       	cpi	r18, 0x06	; 6
    5fd0:	31 05       	cpc	r19, r1
    5fd2:	9c f4       	brge	.+38     	; 0x5ffa <prvProcessReceivedCommands+0x92>
    5fd4:	8b 85       	ldd	r24, Y+11	; 0x0b
    5fd6:	9c 85       	ldd	r25, Y+12	; 0x0c
    5fd8:	83 30       	cpi	r24, 0x03	; 3
    5fda:	91 05       	cpc	r25, r1
    5fdc:	09 f4       	brne	.+2      	; 0x5fe0 <prvProcessReceivedCommands+0x78>
    5fde:	68 c0       	rjmp	.+208    	; 0x60b0 <prvProcessReceivedCommands+0x148>
    5fe0:	2b 85       	ldd	r18, Y+11	; 0x0b
    5fe2:	3c 85       	ldd	r19, Y+12	; 0x0c
    5fe4:	24 30       	cpi	r18, 0x04	; 4
    5fe6:	31 05       	cpc	r19, r1
    5fe8:	0c f0       	brlt	.+2      	; 0x5fec <prvProcessReceivedCommands+0x84>
    5fea:	6a c0       	rjmp	.+212    	; 0x60c0 <prvProcessReceivedCommands+0x158>
    5fec:	8b 85       	ldd	r24, Y+11	; 0x0b
    5fee:	9c 85       	ldd	r25, Y+12	; 0x0c
    5ff0:	81 30       	cpi	r24, 0x01	; 1
    5ff2:	91 05       	cpc	r25, r1
    5ff4:	0c f4       	brge	.+2      	; 0x5ff8 <prvProcessReceivedCommands+0x90>
    5ff6:	9b c0       	rjmp	.+310    	; 0x612e <prvProcessReceivedCommands+0x1c6>
    5ff8:	12 c0       	rjmp	.+36     	; 0x601e <prvProcessReceivedCommands+0xb6>
    5ffa:	2b 85       	ldd	r18, Y+11	; 0x0b
    5ffc:	3c 85       	ldd	r19, Y+12	; 0x0c
    5ffe:	28 30       	cpi	r18, 0x08	; 8
    6000:	31 05       	cpc	r19, r1
    6002:	09 f4       	brne	.+2      	; 0x6006 <prvProcessReceivedCommands+0x9e>
    6004:	55 c0       	rjmp	.+170    	; 0x60b0 <prvProcessReceivedCommands+0x148>
    6006:	8b 85       	ldd	r24, Y+11	; 0x0b
    6008:	9c 85       	ldd	r25, Y+12	; 0x0c
    600a:	88 30       	cpi	r24, 0x08	; 8
    600c:	91 05       	cpc	r25, r1
    600e:	3c f0       	brlt	.+14     	; 0x601e <prvProcessReceivedCommands+0xb6>
    6010:	2b 85       	ldd	r18, Y+11	; 0x0b
    6012:	3c 85       	ldd	r19, Y+12	; 0x0c
    6014:	29 30       	cpi	r18, 0x09	; 9
    6016:	31 05       	cpc	r19, r1
    6018:	09 f4       	brne	.+2      	; 0x601c <prvProcessReceivedCommands+0xb4>
    601a:	52 c0       	rjmp	.+164    	; 0x60c0 <prvProcessReceivedCommands+0x158>
    601c:	88 c0       	rjmp	.+272    	; 0x612e <prvProcessReceivedCommands+0x1c6>
                    case tmrCOMMAND_START:
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    601e:	eb 81       	ldd	r30, Y+3	; 0x03
    6020:	fc 81       	ldd	r31, Y+4	; 0x04
    6022:	82 89       	ldd	r24, Z+18	; 0x12
    6024:	81 60       	ori	r24, 0x01	; 1
    6026:	eb 81       	ldd	r30, Y+3	; 0x03
    6028:	fc 81       	ldd	r31, Y+4	; 0x04
    602a:	82 8b       	std	Z+18, r24	; 0x12

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    602c:	2e 81       	ldd	r18, Y+6	; 0x06
    602e:	3f 81       	ldd	r19, Y+7	; 0x07
    6030:	eb 81       	ldd	r30, Y+3	; 0x03
    6032:	fc 81       	ldd	r31, Y+4	; 0x04
    6034:	84 85       	ldd	r24, Z+12	; 0x0c
    6036:	95 85       	ldd	r25, Z+13	; 0x0d
    6038:	a9 01       	movw	r20, r18
    603a:	48 0f       	add	r20, r24
    603c:	59 1f       	adc	r21, r25
    603e:	ee 81       	ldd	r30, Y+6	; 0x06
    6040:	ff 81       	ldd	r31, Y+7	; 0x07
    6042:	8b 81       	ldd	r24, Y+3	; 0x03
    6044:	9c 81       	ldd	r25, Y+4	; 0x04
    6046:	29 81       	ldd	r18, Y+1	; 0x01
    6048:	3a 81       	ldd	r19, Y+2	; 0x02
    604a:	ba 01       	movw	r22, r20
    604c:	a9 01       	movw	r20, r18
    604e:	9f 01       	movw	r18, r30
    6050:	0e 94 4c 2f 	call	0x5e98	; 0x5e98 <prvInsertTimerInActiveList>
    6054:	88 23       	and	r24, r24
    6056:	09 f4       	brne	.+2      	; 0x605a <prvProcessReceivedCommands+0xf2>
    6058:	6a c0       	rjmp	.+212    	; 0x612e <prvProcessReceivedCommands+0x1c6>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    605a:	eb 81       	ldd	r30, Y+3	; 0x03
    605c:	fc 81       	ldd	r31, Y+4	; 0x04
    605e:	82 89       	ldd	r24, Z+18	; 0x12
    6060:	88 2f       	mov	r24, r24
    6062:	90 e0       	ldi	r25, 0x00	; 0
    6064:	84 70       	andi	r24, 0x04	; 4
    6066:	90 70       	andi	r25, 0x00	; 0
    6068:	00 97       	sbiw	r24, 0x00	; 0
    606a:	91 f0       	breq	.+36     	; 0x6090 <prvProcessReceivedCommands+0x128>
                            {
                                prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow );
    606c:	2e 81       	ldd	r18, Y+6	; 0x06
    606e:	3f 81       	ldd	r19, Y+7	; 0x07
    6070:	eb 81       	ldd	r30, Y+3	; 0x03
    6072:	fc 81       	ldd	r31, Y+4	; 0x04
    6074:	84 85       	ldd	r24, Z+12	; 0x0c
    6076:	95 85       	ldd	r25, Z+13	; 0x0d
    6078:	a9 01       	movw	r20, r18
    607a:	48 0f       	add	r20, r24
    607c:	59 1f       	adc	r21, r25
    607e:	8b 81       	ldd	r24, Y+3	; 0x03
    6080:	9c 81       	ldd	r25, Y+4	; 0x04
    6082:	29 81       	ldd	r18, Y+1	; 0x01
    6084:	3a 81       	ldd	r19, Y+2	; 0x02
    6086:	ba 01       	movw	r22, r20
    6088:	a9 01       	movw	r20, r18
    608a:	0e 94 f6 2d 	call	0x5bec	; 0x5bec <prvReloadTimer>
    608e:	07 c0       	rjmp	.+14     	; 0x609e <prvProcessReceivedCommands+0x136>
                            }
                            else
                            {
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    6090:	eb 81       	ldd	r30, Y+3	; 0x03
    6092:	fc 81       	ldd	r31, Y+4	; 0x04
    6094:	82 89       	ldd	r24, Z+18	; 0x12
    6096:	8e 7f       	andi	r24, 0xFE	; 254
    6098:	eb 81       	ldd	r30, Y+3	; 0x03
    609a:	fc 81       	ldd	r31, Y+4	; 0x04
    609c:	82 8b       	std	Z+18, r24	; 0x12
                            }

                            /* Call the timer callback. */
                            traceTIMER_EXPIRED( pxTimer );
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    609e:	eb 81       	ldd	r30, Y+3	; 0x03
    60a0:	fc 81       	ldd	r31, Y+4	; 0x04
    60a2:	00 88       	ldd	r0, Z+16	; 0x10
    60a4:	f1 89       	ldd	r31, Z+17	; 0x11
    60a6:	e0 2d       	mov	r30, r0
    60a8:	8b 81       	ldd	r24, Y+3	; 0x03
    60aa:	9c 81       	ldd	r25, Y+4	; 0x04
    60ac:	09 95       	icall
    60ae:	3f c0       	rjmp	.+126    	; 0x612e <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    60b0:	eb 81       	ldd	r30, Y+3	; 0x03
    60b2:	fc 81       	ldd	r31, Y+4	; 0x04
    60b4:	82 89       	ldd	r24, Z+18	; 0x12
    60b6:	8e 7f       	andi	r24, 0xFE	; 254
    60b8:	eb 81       	ldd	r30, Y+3	; 0x03
    60ba:	fc 81       	ldd	r31, Y+4	; 0x04
    60bc:	82 8b       	std	Z+18, r24	; 0x12
    60be:	37 c0       	rjmp	.+110    	; 0x612e <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    60c0:	eb 81       	ldd	r30, Y+3	; 0x03
    60c2:	fc 81       	ldd	r31, Y+4	; 0x04
    60c4:	82 89       	ldd	r24, Z+18	; 0x12
    60c6:	81 60       	ori	r24, 0x01	; 1
    60c8:	eb 81       	ldd	r30, Y+3	; 0x03
    60ca:	fc 81       	ldd	r31, Y+4	; 0x04
    60cc:	82 8b       	std	Z+18, r24	; 0x12
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    60ce:	8e 81       	ldd	r24, Y+6	; 0x06
    60d0:	9f 81       	ldd	r25, Y+7	; 0x07
    60d2:	eb 81       	ldd	r30, Y+3	; 0x03
    60d4:	fc 81       	ldd	r31, Y+4	; 0x04
    60d6:	95 87       	std	Z+13, r25	; 0x0d
    60d8:	84 87       	std	Z+12, r24	; 0x0c
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    60da:	eb 81       	ldd	r30, Y+3	; 0x03
    60dc:	fc 81       	ldd	r31, Y+4	; 0x04
    60de:	24 85       	ldd	r18, Z+12	; 0x0c
    60e0:	35 85       	ldd	r19, Z+13	; 0x0d
    60e2:	89 81       	ldd	r24, Y+1	; 0x01
    60e4:	9a 81       	ldd	r25, Y+2	; 0x02
    60e6:	a9 01       	movw	r20, r18
    60e8:	48 0f       	add	r20, r24
    60ea:	59 1f       	adc	r21, r25
    60ec:	8b 81       	ldd	r24, Y+3	; 0x03
    60ee:	9c 81       	ldd	r25, Y+4	; 0x04
    60f0:	29 81       	ldd	r18, Y+1	; 0x01
    60f2:	3a 81       	ldd	r19, Y+2	; 0x02
    60f4:	e9 81       	ldd	r30, Y+1	; 0x01
    60f6:	fa 81       	ldd	r31, Y+2	; 0x02
    60f8:	ba 01       	movw	r22, r20
    60fa:	a9 01       	movw	r20, r18
    60fc:	9f 01       	movw	r18, r30
    60fe:	0e 94 4c 2f 	call	0x5e98	; 0x5e98 <prvInsertTimerInActiveList>
    6102:	15 c0       	rjmp	.+42     	; 0x612e <prvProcessReceivedCommands+0x1c6>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                            {
                                /* The timer has already been removed from the active list,
                                 * just free up the memory if the memory was dynamically
                                 * allocated. */
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    6104:	eb 81       	ldd	r30, Y+3	; 0x03
    6106:	fc 81       	ldd	r31, Y+4	; 0x04
    6108:	82 89       	ldd	r24, Z+18	; 0x12
    610a:	88 2f       	mov	r24, r24
    610c:	90 e0       	ldi	r25, 0x00	; 0
    610e:	82 70       	andi	r24, 0x02	; 2
    6110:	90 70       	andi	r25, 0x00	; 0
    6112:	00 97       	sbiw	r24, 0x00	; 0
    6114:	29 f4       	brne	.+10     	; 0x6120 <prvProcessReceivedCommands+0x1b8>
                                {
                                    vPortFree( pxTimer );
    6116:	8b 81       	ldd	r24, Y+3	; 0x03
    6118:	9c 81       	ldd	r25, Y+4	; 0x04
    611a:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
    611e:	07 c0       	rjmp	.+14     	; 0x612e <prvProcessReceivedCommands+0x1c6>
                                }
                                else
                                {
                                    pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    6120:	eb 81       	ldd	r30, Y+3	; 0x03
    6122:	fc 81       	ldd	r31, Y+4	; 0x04
    6124:	82 89       	ldd	r24, Z+18	; 0x12
    6126:	8e 7f       	andi	r24, 0xFE	; 254
    6128:	eb 81       	ldd	r30, Y+3	; 0x03
    612a:	fc 81       	ldd	r31, Y+4	; 0x04
    612c:	82 8b       	std	Z+18, r24	; 0x12
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    612e:	80 91 04 07 	lds	r24, 0x0704
    6132:	90 91 05 07 	lds	r25, 0x0705
    6136:	9e 01       	movw	r18, r28
    6138:	2b 5f       	subi	r18, 0xFB	; 251
    613a:	3f 4f       	sbci	r19, 0xFF	; 255
    613c:	b9 01       	movw	r22, r18
    613e:	40 e0       	ldi	r20, 0x00	; 0
    6140:	50 e0       	ldi	r21, 0x00	; 0
    6142:	0e 94 97 11 	call	0x232e	; 0x232e <xQueueReceive>
    6146:	88 23       	and	r24, r24
    6148:	09 f0       	breq	.+2      	; 0x614c <prvProcessReceivedCommands+0x1e4>
    614a:	19 cf       	rjmp	.-462    	; 0x5f7e <prvProcessReceivedCommands+0x16>
                        /* Don't expect to get here. */
                        break;
                }
            }
        }
    }
    614c:	2c 96       	adiw	r28, 0x0c	; 12
    614e:	0f b6       	in	r0, 0x3f	; 63
    6150:	f8 94       	cli
    6152:	de bf       	out	0x3e, r29	; 62
    6154:	0f be       	out	0x3f, r0	; 63
    6156:	cd bf       	out	0x3d, r28	; 61
    6158:	cf 91       	pop	r28
    615a:	df 91       	pop	r29
    615c:	08 95       	ret

0000615e <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
    615e:	df 93       	push	r29
    6160:	cf 93       	push	r28
    6162:	00 d0       	rcall	.+0      	; 0x6164 <prvSwitchTimerLists+0x6>
    6164:	00 d0       	rcall	.+0      	; 0x6166 <prvSwitchTimerLists+0x8>
    6166:	cd b7       	in	r28, 0x3d	; 61
    6168:	de b7       	in	r29, 0x3e	; 62
    616a:	11 c0       	rjmp	.+34     	; 0x618e <prvSwitchTimerLists+0x30>
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    616c:	e0 91 1c 07 	lds	r30, 0x071C
    6170:	f0 91 1d 07 	lds	r31, 0x071D
    6174:	05 80       	ldd	r0, Z+5	; 0x05
    6176:	f6 81       	ldd	r31, Z+6	; 0x06
    6178:	e0 2d       	mov	r30, r0
    617a:	80 81       	ld	r24, Z
    617c:	91 81       	ldd	r25, Z+1	; 0x01
    617e:	9c 83       	std	Y+4, r25	; 0x04
    6180:	8b 83       	std	Y+3, r24	; 0x03

            /* Process the expired timer.  For auto-reload timers, be careful to
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
    6182:	8b 81       	ldd	r24, Y+3	; 0x03
    6184:	9c 81       	ldd	r25, Y+4	; 0x04
    6186:	6f ef       	ldi	r22, 0xFF	; 255
    6188:	7f ef       	ldi	r23, 0xFF	; 255
    618a:	0e 94 35 2e 	call	0x5c6a	; 0x5c6a <prvProcessExpiredTimer>

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    618e:	e0 91 1c 07 	lds	r30, 0x071C
    6192:	f0 91 1d 07 	lds	r31, 0x071D
    6196:	80 81       	ld	r24, Z
    6198:	88 23       	and	r24, r24
    619a:	41 f7       	brne	.-48     	; 0x616c <prvSwitchTimerLists+0xe>
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
        }

        pxTemp = pxCurrentTimerList;
    619c:	80 91 1c 07 	lds	r24, 0x071C
    61a0:	90 91 1d 07 	lds	r25, 0x071D
    61a4:	9a 83       	std	Y+2, r25	; 0x02
    61a6:	89 83       	std	Y+1, r24	; 0x01
        pxCurrentTimerList = pxOverflowTimerList;
    61a8:	80 91 1e 07 	lds	r24, 0x071E
    61ac:	90 91 1f 07 	lds	r25, 0x071F
    61b0:	90 93 1d 07 	sts	0x071D, r25
    61b4:	80 93 1c 07 	sts	0x071C, r24
        pxOverflowTimerList = pxTemp;
    61b8:	89 81       	ldd	r24, Y+1	; 0x01
    61ba:	9a 81       	ldd	r25, Y+2	; 0x02
    61bc:	90 93 1f 07 	sts	0x071F, r25
    61c0:	80 93 1e 07 	sts	0x071E, r24
    }
    61c4:	0f 90       	pop	r0
    61c6:	0f 90       	pop	r0
    61c8:	0f 90       	pop	r0
    61ca:	0f 90       	pop	r0
    61cc:	cf 91       	pop	r28
    61ce:	df 91       	pop	r29
    61d0:	08 95       	ret

000061d2 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
    61d2:	df 93       	push	r29
    61d4:	cf 93       	push	r28
    61d6:	cd b7       	in	r28, 0x3d	; 61
    61d8:	de b7       	in	r29, 0x3e	; 62
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
    61da:	0f b6       	in	r0, 0x3f	; 63
    61dc:	f8 94       	cli
    61de:	0f 92       	push	r0
        {
            if( xTimerQueue == NULL )
    61e0:	80 91 04 07 	lds	r24, 0x0704
    61e4:	90 91 05 07 	lds	r25, 0x0705
    61e8:	00 97       	sbiw	r24, 0x00	; 0
    61ea:	e9 f4       	brne	.+58     	; 0x6226 <prvCheckForValidListAndQueue+0x54>
            {
                vListInitialise( &xActiveTimerList1 );
    61ec:	8a e0       	ldi	r24, 0x0A	; 10
    61ee:	97 e0       	ldi	r25, 0x07	; 7
    61f0:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
    61f4:	83 e1       	ldi	r24, 0x13	; 19
    61f6:	97 e0       	ldi	r25, 0x07	; 7
    61f8:	0e 94 ae 0d 	call	0x1b5c	; 0x1b5c <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
    61fc:	8a e0       	ldi	r24, 0x0A	; 10
    61fe:	97 e0       	ldi	r25, 0x07	; 7
    6200:	90 93 1d 07 	sts	0x071D, r25
    6204:	80 93 1c 07 	sts	0x071C, r24
                pxOverflowTimerList = &xActiveTimerList2;
    6208:	83 e1       	ldi	r24, 0x13	; 19
    620a:	97 e0       	ldi	r25, 0x07	; 7
    620c:	90 93 1f 07 	sts	0x071F, r25
    6210:	80 93 1e 07 	sts	0x071E, r24

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    6214:	8a e0       	ldi	r24, 0x0A	; 10
    6216:	65 e0       	ldi	r22, 0x05	; 5
    6218:	40 e0       	ldi	r20, 0x00	; 0
    621a:	0e 94 8f 0f 	call	0x1f1e	; 0x1f1e <xQueueGenericCreate>
    621e:	90 93 05 07 	sts	0x0705, r25
    6222:	80 93 04 07 	sts	0x0704, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    6226:	0f 90       	pop	r0
    6228:	0f be       	out	0x3f, r0	; 63
    }
    622a:	cf 91       	pop	r28
    622c:	df 91       	pop	r29
    622e:	08 95       	ret

00006230 <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
    {
    6230:	df 93       	push	r29
    6232:	cf 93       	push	r28
    6234:	00 d0       	rcall	.+0      	; 0x6236 <xTimerIsTimerActive+0x6>
    6236:	00 d0       	rcall	.+0      	; 0x6238 <xTimerIsTimerActive+0x8>
    6238:	0f 92       	push	r0
    623a:	cd b7       	in	r28, 0x3d	; 61
    623c:	de b7       	in	r29, 0x3e	; 62
    623e:	9d 83       	std	Y+5, r25	; 0x05
    6240:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;
        Timer_t * pxTimer = xTimer;
    6242:	8c 81       	ldd	r24, Y+4	; 0x04
    6244:	9d 81       	ldd	r25, Y+5	; 0x05
    6246:	9a 83       	std	Y+2, r25	; 0x02
    6248:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        /* Is the timer in the list of active timers? */
        taskENTER_CRITICAL();
    624a:	0f b6       	in	r0, 0x3f	; 63
    624c:	f8 94       	cli
    624e:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
    6250:	e9 81       	ldd	r30, Y+1	; 0x01
    6252:	fa 81       	ldd	r31, Y+2	; 0x02
    6254:	82 89       	ldd	r24, Z+18	; 0x12
    6256:	88 2f       	mov	r24, r24
    6258:	90 e0       	ldi	r25, 0x00	; 0
    625a:	81 70       	andi	r24, 0x01	; 1
    625c:	90 70       	andi	r25, 0x00	; 0
    625e:	00 97       	sbiw	r24, 0x00	; 0
    6260:	11 f4       	brne	.+4      	; 0x6266 <xTimerIsTimerActive+0x36>
            {
                xReturn = pdFALSE;
    6262:	1b 82       	std	Y+3, r1	; 0x03
    6264:	02 c0       	rjmp	.+4      	; 0x626a <xTimerIsTimerActive+0x3a>
            }
            else
            {
                xReturn = pdTRUE;
    6266:	81 e0       	ldi	r24, 0x01	; 1
    6268:	8b 83       	std	Y+3, r24	; 0x03
            }
        }
        taskEXIT_CRITICAL();
    626a:	0f 90       	pop	r0
    626c:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    626e:	8b 81       	ldd	r24, Y+3	; 0x03
    } /*lint !e818 Can't be pointer to const due to the typedef. */
    6270:	0f 90       	pop	r0
    6272:	0f 90       	pop	r0
    6274:	0f 90       	pop	r0
    6276:	0f 90       	pop	r0
    6278:	0f 90       	pop	r0
    627a:	cf 91       	pop	r28
    627c:	df 91       	pop	r29
    627e:	08 95       	ret

00006280 <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

    void * pvTimerGetTimerID( const TimerHandle_t xTimer )
    {
    6280:	df 93       	push	r29
    6282:	cf 93       	push	r28
    6284:	00 d0       	rcall	.+0      	; 0x6286 <pvTimerGetTimerID+0x6>
    6286:	00 d0       	rcall	.+0      	; 0x6288 <pvTimerGetTimerID+0x8>
    6288:	00 d0       	rcall	.+0      	; 0x628a <pvTimerGetTimerID+0xa>
    628a:	cd b7       	in	r28, 0x3d	; 61
    628c:	de b7       	in	r29, 0x3e	; 62
    628e:	9e 83       	std	Y+6, r25	; 0x06
    6290:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * const pxTimer = xTimer;
    6292:	8d 81       	ldd	r24, Y+5	; 0x05
    6294:	9e 81       	ldd	r25, Y+6	; 0x06
    6296:	9c 83       	std	Y+4, r25	; 0x04
    6298:	8b 83       	std	Y+3, r24	; 0x03
        void * pvReturn;

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    629a:	0f b6       	in	r0, 0x3f	; 63
    629c:	f8 94       	cli
    629e:	0f 92       	push	r0
        {
            pvReturn = pxTimer->pvTimerID;
    62a0:	eb 81       	ldd	r30, Y+3	; 0x03
    62a2:	fc 81       	ldd	r31, Y+4	; 0x04
    62a4:	86 85       	ldd	r24, Z+14	; 0x0e
    62a6:	97 85       	ldd	r25, Z+15	; 0x0f
    62a8:	9a 83       	std	Y+2, r25	; 0x02
    62aa:	89 83       	std	Y+1, r24	; 0x01
        }
        taskEXIT_CRITICAL();
    62ac:	0f 90       	pop	r0
    62ae:	0f be       	out	0x3f, r0	; 63

        return pvReturn;
    62b0:	89 81       	ldd	r24, Y+1	; 0x01
    62b2:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    62b4:	26 96       	adiw	r28, 0x06	; 6
    62b6:	0f b6       	in	r0, 0x3f	; 63
    62b8:	f8 94       	cli
    62ba:	de bf       	out	0x3e, r29	; 62
    62bc:	0f be       	out	0x3f, r0	; 63
    62be:	cd bf       	out	0x3d, r28	; 61
    62c0:	cf 91       	pop	r28
    62c2:	df 91       	pop	r29
    62c4:	08 95       	ret

000062c6 <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

    void vTimerSetTimerID( TimerHandle_t xTimer,
                           void * pvNewID )
    {
    62c6:	df 93       	push	r29
    62c8:	cf 93       	push	r28
    62ca:	00 d0       	rcall	.+0      	; 0x62cc <vTimerSetTimerID+0x6>
    62cc:	00 d0       	rcall	.+0      	; 0x62ce <vTimerSetTimerID+0x8>
    62ce:	00 d0       	rcall	.+0      	; 0x62d0 <vTimerSetTimerID+0xa>
    62d0:	cd b7       	in	r28, 0x3d	; 61
    62d2:	de b7       	in	r29, 0x3e	; 62
    62d4:	9c 83       	std	Y+4, r25	; 0x04
    62d6:	8b 83       	std	Y+3, r24	; 0x03
    62d8:	7e 83       	std	Y+6, r23	; 0x06
    62da:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = xTimer;
    62dc:	8b 81       	ldd	r24, Y+3	; 0x03
    62de:	9c 81       	ldd	r25, Y+4	; 0x04
    62e0:	9a 83       	std	Y+2, r25	; 0x02
    62e2:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    62e4:	0f b6       	in	r0, 0x3f	; 63
    62e6:	f8 94       	cli
    62e8:	0f 92       	push	r0
        {
            pxTimer->pvTimerID = pvNewID;
    62ea:	e9 81       	ldd	r30, Y+1	; 0x01
    62ec:	fa 81       	ldd	r31, Y+2	; 0x02
    62ee:	8d 81       	ldd	r24, Y+5	; 0x05
    62f0:	9e 81       	ldd	r25, Y+6	; 0x06
    62f2:	97 87       	std	Z+15, r25	; 0x0f
    62f4:	86 87       	std	Z+14, r24	; 0x0e
        }
        taskEXIT_CRITICAL();
    62f6:	0f 90       	pop	r0
    62f8:	0f be       	out	0x3f, r0	; 63
    }
    62fa:	26 96       	adiw	r28, 0x06	; 6
    62fc:	0f b6       	in	r0, 0x3f	; 63
    62fe:	f8 94       	cli
    6300:	de bf       	out	0x3e, r29	; 62
    6302:	0f be       	out	0x3f, r0	; 63
    6304:	cd bf       	out	0x3d, r28	; 61
    6306:	cf 91       	pop	r28
    6308:	df 91       	pop	r29
    630a:	08 95       	ret

0000630c <main>:
void toggle_led_mode(void);

TaskHandle_t task2ptr;

int main(void)
{
    630c:	ef 92       	push	r14
    630e:	ff 92       	push	r15
    6310:	0f 93       	push	r16
    6312:	1f 93       	push	r17
    6314:	df 93       	push	r29
    6316:	cf 93       	push	r28
    6318:	cd b7       	in	r28, 0x3d	; 61
    631a:	de b7       	in	r29, 0x3e	; 62


	PWM_INIT();
    631c:	0e 94 cb 32 	call	0x6596	; 0x6596 <PWM_INIT>



	xButtonTimer = xTimerCreate
    6320:	e5 ef       	ldi	r30, 0xF5	; 245
    6322:	f1 e3       	ldi	r31, 0x31	; 49
    6324:	8d e6       	ldi	r24, 0x6D	; 109
    6326:	90 e0       	ldi	r25, 0x00	; 0
    6328:	65 e0       	ldi	r22, 0x05	; 5
    632a:	70 e0       	ldi	r23, 0x00	; 0
    632c:	41 e0       	ldi	r20, 0x01	; 1
    632e:	20 e0       	ldi	r18, 0x00	; 0
    6330:	30 e0       	ldi	r19, 0x00	; 0
    6332:	8f 01       	movw	r16, r30
    6334:	0e 94 53 2c 	call	0x58a6	; 0x58a6 <xTimerCreate>
    6338:	90 93 21 07 	sts	0x0721, r25
    633c:	80 93 20 07 	sts	0x0720, r24
	                     ( void * ) 0,
	                     /* Each timer calls the same callback when
	                     it expires. */
						 get_readings
	                   );
	xLedBlinkingTimer = xTimerCreate
    6340:	e2 ee       	ldi	r30, 0xE2	; 226
    6342:	f1 e3       	ldi	r31, 0x31	; 49
    6344:	8a e7       	ldi	r24, 0x7A	; 122
    6346:	90 e0       	ldi	r25, 0x00	; 0
    6348:	64 ef       	ldi	r22, 0xF4	; 244
    634a:	71 e0       	ldi	r23, 0x01	; 1
    634c:	41 e0       	ldi	r20, 0x01	; 1
    634e:	20 e0       	ldi	r18, 0x00	; 0
    6350:	30 e0       	ldi	r19, 0x00	; 0
    6352:	8f 01       	movw	r16, r30
    6354:	0e 94 53 2c 	call	0x58a6	; 0x58a6 <xTimerCreate>
    6358:	90 93 23 07 	sts	0x0723, r25
    635c:	80 93 22 07 	sts	0x0722, r24
		                     ( void * ) 0,
		                     /* Each timer calls the same callback when
		                     it expires. */
							 toggle_led_mode
		                   );
	xTaskCreate(vState_machine,"first",configMINIMAL_STACK_SIZE,NULL,1,&task1ptr);
    6360:	8c e8       	ldi	r24, 0x8C	; 140
    6362:	92 e3       	ldi	r25, 0x32	; 50
    6364:	24 e8       	ldi	r18, 0x84	; 132
    6366:	30 e0       	ldi	r19, 0x00	; 0
    6368:	ec e2       	ldi	r30, 0x2C	; 44
    636a:	f7 e0       	ldi	r31, 0x07	; 7
    636c:	b9 01       	movw	r22, r18
    636e:	45 e5       	ldi	r20, 0x55	; 85
    6370:	50 e0       	ldi	r21, 0x00	; 0
    6372:	20 e0       	ldi	r18, 0x00	; 0
    6374:	30 e0       	ldi	r19, 0x00	; 0
    6376:	01 e0       	ldi	r16, 0x01	; 1
    6378:	7f 01       	movw	r14, r30
    637a:	0e 94 3a 18 	call	0x3074	; 0x3074 <xTaskCreate>
	xTimerStart(xButtonTimer, 10 );
    637e:	00 91 20 07 	lds	r16, 0x0720
    6382:	10 91 21 07 	lds	r17, 0x0721
    6386:	0e 94 e7 1c 	call	0x39ce	; 0x39ce <xTaskGetTickCount>
    638a:	9c 01       	movw	r18, r24
    638c:	c8 01       	movw	r24, r16
    638e:	61 e0       	ldi	r22, 0x01	; 1
    6390:	a9 01       	movw	r20, r18
    6392:	20 e0       	ldi	r18, 0x00	; 0
    6394:	30 e0       	ldi	r19, 0x00	; 0
    6396:	0a e0       	ldi	r16, 0x0A	; 10
    6398:	10 e0       	ldi	r17, 0x00	; 0
    639a:	0e 94 e5 2c 	call	0x59ca	; 0x59ca <xTimerGenericCommand>
	xTimerStart(xLedBlinkingTimer, 10 );
    639e:	00 91 22 07 	lds	r16, 0x0722
    63a2:	10 91 23 07 	lds	r17, 0x0723
    63a6:	0e 94 e7 1c 	call	0x39ce	; 0x39ce <xTaskGetTickCount>
    63aa:	9c 01       	movw	r18, r24
    63ac:	c8 01       	movw	r24, r16
    63ae:	61 e0       	ldi	r22, 0x01	; 1
    63b0:	a9 01       	movw	r20, r18
    63b2:	20 e0       	ldi	r18, 0x00	; 0
    63b4:	30 e0       	ldi	r19, 0x00	; 0
    63b6:	0a e0       	ldi	r16, 0x0A	; 10
    63b8:	10 e0       	ldi	r17, 0x00	; 0
    63ba:	0e 94 e5 2c 	call	0x59ca	; 0x59ca <xTimerGenericCommand>
	vTaskStartScheduler();
    63be:	0e 94 44 1b 	call	0x3688	; 0x3688 <vTaskStartScheduler>
    63c2:	ff cf       	rjmp	.-2      	; 0x63c2 <main+0xb6>

000063c4 <toggle_led_mode>:


	}
}

void toggle_led_mode(void){
    63c4:	df 93       	push	r29
    63c6:	cf 93       	push	r28
    63c8:	0f 92       	push	r0
    63ca:	cd b7       	in	r28, 0x3d	; 61
    63cc:	de b7       	in	r29, 0x3e	; 62
		led_mode = !led_mode;
    63ce:	80 91 24 07 	lds	r24, 0x0724
    63d2:	19 82       	std	Y+1, r1	; 0x01
    63d4:	88 23       	and	r24, r24
    63d6:	11 f4       	brne	.+4      	; 0x63dc <toggle_led_mode+0x18>
    63d8:	81 e0       	ldi	r24, 0x01	; 1
    63da:	89 83       	std	Y+1, r24	; 0x01
    63dc:	89 81       	ldd	r24, Y+1	; 0x01
    63de:	80 93 24 07 	sts	0x0724, r24
}
    63e2:	0f 90       	pop	r0
    63e4:	cf 91       	pop	r28
    63e6:	df 91       	pop	r29
    63e8:	08 95       	ret

000063ea <get_readings>:
void get_readings(void)
{
    63ea:	df 93       	push	r29
    63ec:	cf 93       	push	r28
    63ee:	00 d0       	rcall	.+0      	; 0x63f0 <get_readings+0x6>
    63f0:	0f 92       	push	r0
    63f2:	cd b7       	in	r28, 0x3d	; 61
    63f4:	de b7       	in	r29, 0x3e	; 62

		ignition_button = READ_IGNITON();
    63f6:	0e 94 3a 07 	call	0xe74	; 0xe74 <READ_IGNITON>
    63fa:	80 93 27 07 	sts	0x0727, r24

		if(!ignition_button){
    63fe:	80 91 27 07 	lds	r24, 0x0727
    6402:	88 23       	and	r24, r24
    6404:	09 f0       	breq	.+2      	; 0x6408 <get_readings+0x1e>
    6406:	7e c0       	rjmp	.+252    	; 0x6504 <get_readings+0x11a>
			uint8_t hazard_data = READ_HAZARD_Button();
    6408:	0e 94 4e 07 	call	0xe9c	; 0xe9c <READ_HAZARD_Button>
    640c:	8b 83       	std	Y+3, r24	; 0x03

			uint8_t right_data = READ_RIGHT_Button();
    640e:	0e 94 62 07 	call	0xec4	; 0xec4 <READ_RIGHT_Button>
    6412:	8a 83       	std	Y+2, r24	; 0x02

			uint8_t left_data = READ_LEFT_Button();
    6414:	0e 94 76 07 	call	0xeec	; 0xeec <READ_LEFT_Button>
    6418:	89 83       	std	Y+1, r24	; 0x01
			if(hazard_data){
    641a:	8b 81       	ldd	r24, Y+3	; 0x03
    641c:	88 23       	and	r24, r24
    641e:	41 f0       	breq	.+16     	; 0x6430 <get_readings+0x46>

					Hazzred_button = 1;
    6420:	81 e0       	ldi	r24, 0x01	; 1
    6422:	80 93 2e 07 	sts	0x072E, r24
					L_button = 0;
    6426:	10 92 2b 07 	sts	0x072B, r1
					R_button = 0;
    642a:	10 92 28 07 	sts	0x0728, r1
    642e:	6e c0       	rjmp	.+220    	; 0x650c <get_readings+0x122>


			}
			else if(right_data){////
    6430:	8a 81       	ldd	r24, Y+2	; 0x02
    6432:	88 23       	and	r24, r24
    6434:	39 f1       	breq	.+78     	; 0x6484 <get_readings+0x9a>
				right_button_pressed_counter++;
    6436:	80 91 31 07 	lds	r24, 0x0731
    643a:	90 91 32 07 	lds	r25, 0x0732
    643e:	01 96       	adiw	r24, 0x01	; 1
    6440:	90 93 32 07 	sts	0x0732, r25
    6444:	80 93 31 07 	sts	0x0731, r24
				hazzred_button_pressed_counter=0;
    6448:	10 92 26 07 	sts	0x0726, r1
    644c:	10 92 25 07 	sts	0x0725, r1
				left_button_pressed_counter=0;
    6450:	10 92 30 07 	sts	0x0730, r1
    6454:	10 92 2f 07 	sts	0x072F, r1
				if(!(right_button_pressed_counter%10)){
    6458:	80 91 31 07 	lds	r24, 0x0731
    645c:	90 91 32 07 	lds	r25, 0x0732
    6460:	2a e0       	ldi	r18, 0x0A	; 10
    6462:	30 e0       	ldi	r19, 0x00	; 0
    6464:	b9 01       	movw	r22, r18
    6466:	0e 94 38 33 	call	0x6670	; 0x6670 <__divmodhi4>
    646a:	00 97       	sbiw	r24, 0x00	; 0
    646c:	09 f0       	breq	.+2      	; 0x6470 <get_readings+0x86>
    646e:	4e c0       	rjmp	.+156    	; 0x650c <get_readings+0x122>
					R_button = 1;
    6470:	81 e0       	ldi	r24, 0x01	; 1
    6472:	80 93 28 07 	sts	0x0728, r24
					Hazzred_button = 0;
    6476:	10 92 2e 07 	sts	0x072E, r1
					L_button = 0;
    647a:	10 92 2b 07 	sts	0x072B, r1
					Stop_PWM2();
    647e:	0e 94 0f 33 	call	0x661e	; 0x661e <Stop_PWM2>
    6482:	44 c0       	rjmp	.+136    	; 0x650c <get_readings+0x122>
				}
			}
			else if(left_data){////
    6484:	89 81       	ldd	r24, Y+1	; 0x01
    6486:	88 23       	and	r24, r24
    6488:	31 f1       	breq	.+76     	; 0x64d6 <get_readings+0xec>
				left_button_pressed_counter++;
    648a:	80 91 2f 07 	lds	r24, 0x072F
    648e:	90 91 30 07 	lds	r25, 0x0730
    6492:	01 96       	adiw	r24, 0x01	; 1
    6494:	90 93 30 07 	sts	0x0730, r25
    6498:	80 93 2f 07 	sts	0x072F, r24
				hazzred_button_pressed_counter=0;
    649c:	10 92 26 07 	sts	0x0726, r1
    64a0:	10 92 25 07 	sts	0x0725, r1
				right_button_pressed_counter=0;
    64a4:	10 92 32 07 	sts	0x0732, r1
    64a8:	10 92 31 07 	sts	0x0731, r1
				if(!(left_button_pressed_counter%10)){
    64ac:	80 91 2f 07 	lds	r24, 0x072F
    64b0:	90 91 30 07 	lds	r25, 0x0730
    64b4:	2a e0       	ldi	r18, 0x0A	; 10
    64b6:	30 e0       	ldi	r19, 0x00	; 0
    64b8:	b9 01       	movw	r22, r18
    64ba:	0e 94 38 33 	call	0x6670	; 0x6670 <__divmodhi4>
    64be:	00 97       	sbiw	r24, 0x00	; 0
    64c0:	29 f5       	brne	.+74     	; 0x650c <get_readings+0x122>
					L_button = 1;
    64c2:	81 e0       	ldi	r24, 0x01	; 1
    64c4:	80 93 2b 07 	sts	0x072B, r24
					R_button = 0;
    64c8:	10 92 28 07 	sts	0x0728, r1
					Hazzred_button = 0;
    64cc:	10 92 2e 07 	sts	0x072E, r1
					Stop_PWM1();
    64d0:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <Stop_PWM1>
    64d4:	1b c0       	rjmp	.+54     	; 0x650c <get_readings+0x122>

				}
			}
			else{
				/*neutral state*/
				Stop_PWM1();
    64d6:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <Stop_PWM1>

				Stop_PWM2();
    64da:	0e 94 0f 33 	call	0x661e	; 0x661e <Stop_PWM2>

				hazzred_button_pressed_counter=0;
    64de:	10 92 26 07 	sts	0x0726, r1
    64e2:	10 92 25 07 	sts	0x0725, r1
				right_button_pressed_counter=0;
    64e6:	10 92 32 07 	sts	0x0732, r1
    64ea:	10 92 31 07 	sts	0x0731, r1
				left_button_pressed_counter=0;
    64ee:	10 92 30 07 	sts	0x0730, r1
    64f2:	10 92 2f 07 	sts	0x072F, r1
				L_button = 0;
    64f6:	10 92 2b 07 	sts	0x072B, r1
				R_button = 0;
    64fa:	10 92 28 07 	sts	0x0728, r1
				Hazzred_button = 0;
    64fe:	10 92 2e 07 	sts	0x072E, r1
    6502:	04 c0       	rjmp	.+8      	; 0x650c <get_readings+0x122>

			}
		}else{
			Stop_PWM1();
    6504:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <Stop_PWM1>
			Stop_PWM2();
    6508:	0e 94 0f 33 	call	0x661e	; 0x661e <Stop_PWM2>
		}
//	}
}
    650c:	0f 90       	pop	r0
    650e:	0f 90       	pop	r0
    6510:	0f 90       	pop	r0
    6512:	cf 91       	pop	r28
    6514:	df 91       	pop	r29
    6516:	08 95       	ret

00006518 <vState_machine>:


void vState_machine(void)
{
    6518:	df 93       	push	r29
    651a:	cf 93       	push	r28
    651c:	cd b7       	in	r28, 0x3d	; 61
    651e:	de b7       	in	r29, 0x3e	; 62
	while(1)
	{

		if(!ignition_button){
    6520:	80 91 27 07 	lds	r24, 0x0727
    6524:	88 23       	and	r24, r24
    6526:	e1 f7       	brne	.-8      	; 0x6520 <vState_machine+0x8>


			if(Hazzred_button){
    6528:	80 91 2e 07 	lds	r24, 0x072E
    652c:	88 23       	and	r24, r24
    652e:	29 f0       	breq	.+10     	; 0x653a <vState_machine+0x22>
//				DIO_SetPinVal(DIO_PORTC , Pin6 , HIGH);
				vBlink_Right();
    6530:	0e 94 ab 32 	call	0x6556	; 0x6556 <vBlink_Right>
				Blink_LEFT();
    6534:	0e 94 bb 32 	call	0x6576	; 0x6576 <Blink_LEFT>
    6538:	f3 cf       	rjmp	.-26     	; 0x6520 <vState_machine+0x8>
//				DIO_SetPinVal(DIO_PORTC , Pin3 , HIGH);
			}
			else if(R_button ){
    653a:	80 91 28 07 	lds	r24, 0x0728
    653e:	88 23       	and	r24, r24
    6540:	19 f0       	breq	.+6      	; 0x6548 <vState_machine+0x30>
//				DIO_SetPinVal(DIO_PORTC , Pin3 , LOW);
				vBlink_Right();
    6542:	0e 94 ab 32 	call	0x6556	; 0x6556 <vBlink_Right>
    6546:	ec cf       	rjmp	.-40     	; 0x6520 <vState_machine+0x8>


			}
			else if(L_button ){
    6548:	80 91 2b 07 	lds	r24, 0x072B
    654c:	88 23       	and	r24, r24
    654e:	41 f3       	breq	.-48     	; 0x6520 <vState_machine+0x8>
//				DIO_SetPinVal(DIO_PORTC , Pin6, LOW);
				Blink_LEFT();
    6550:	0e 94 bb 32 	call	0x6576	; 0x6576 <Blink_LEFT>
    6554:	e5 cf       	rjmp	.-54     	; 0x6520 <vState_machine+0x8>

00006556 <vBlink_Right>:
			}
		}

	}
}
void vBlink_Right(void ){
    6556:	df 93       	push	r29
    6558:	cf 93       	push	r28
    655a:	cd b7       	in	r28, 0x3d	; 61
    655c:	de b7       	in	r29, 0x3e	; 62

		if(led_mode){
    655e:	80 91 24 07 	lds	r24, 0x0724
    6562:	88 23       	and	r24, r24
    6564:	19 f0       	breq	.+6      	; 0x656c <vBlink_Right+0x16>
			Start_PWM1();
    6566:	0e 94 dc 32 	call	0x65b8	; 0x65b8 <Start_PWM1>
    656a:	02 c0       	rjmp	.+4      	; 0x6570 <vBlink_Right+0x1a>

		}else{
			Stop_PWM1();
    656c:	0e 94 fa 32 	call	0x65f4	; 0x65f4 <Stop_PWM1>

	}


}
    6570:	cf 91       	pop	r28
    6572:	df 91       	pop	r29
    6574:	08 95       	ret

00006576 <Blink_LEFT>:

void Blink_LEFT(void){
    6576:	df 93       	push	r29
    6578:	cf 93       	push	r28
    657a:	cd b7       	in	r28, 0x3d	; 61
    657c:	de b7       	in	r29, 0x3e	; 62


		if(led_mode){
    657e:	80 91 24 07 	lds	r24, 0x0724
    6582:	88 23       	and	r24, r24
    6584:	19 f0       	breq	.+6      	; 0x658c <Blink_LEFT+0x16>


			Start_PWM2();
    6586:	0e 94 eb 32 	call	0x65d6	; 0x65d6 <Start_PWM2>
    658a:	02 c0       	rjmp	.+4      	; 0x6590 <Blink_LEFT+0x1a>

		}else{

			Stop_PWM2();
    658c:	0e 94 0f 33 	call	0x661e	; 0x661e <Stop_PWM2>



		}
//	}
}
    6590:	cf 91       	pop	r28
    6592:	df 91       	pop	r29
    6594:	08 95       	ret

00006596 <PWM_INIT>:
void PWM_INIT(void){
    6596:	df 93       	push	r29
    6598:	cf 93       	push	r28
    659a:	cd b7       	in	r28, 0x3d	; 61
    659c:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTB ,Pin3, OUTPUT);
    659e:	81 e0       	ldi	r24, 0x01	; 1
    65a0:	63 e0       	ldi	r22, 0x03	; 3
    65a2:	43 e0       	ldi	r20, 0x03	; 3
    65a4:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	DIO_SetPinDir(DIO_PORTD ,Pin7, OUTPUT);
    65a8:	83 e0       	ldi	r24, 0x03	; 3
    65aa:	67 e0       	ldi	r22, 0x07	; 7
    65ac:	43 e0       	ldi	r20, 0x03	; 3
    65ae:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
}
    65b2:	cf 91       	pop	r28
    65b4:	df 91       	pop	r29
    65b6:	08 95       	ret

000065b8 <Start_PWM1>:
void Start_PWM1(void){
    65b8:	df 93       	push	r29
    65ba:	cf 93       	push	r28
    65bc:	cd b7       	in	r28, 0x3d	; 61
    65be:	de b7       	in	r29, 0x3e	; 62
	TCCR0 = (1<<WGM00) | (1<<WGM01) | (1<<COM01) | (1<<CS00);
    65c0:	e3 e5       	ldi	r30, 0x53	; 83
    65c2:	f0 e0       	ldi	r31, 0x00	; 0
    65c4:	89 e6       	ldi	r24, 0x69	; 105
    65c6:	80 83       	st	Z, r24
	OCR0 = 204;
    65c8:	ec e5       	ldi	r30, 0x5C	; 92
    65ca:	f0 e0       	ldi	r31, 0x00	; 0
    65cc:	8c ec       	ldi	r24, 0xCC	; 204
    65ce:	80 83       	st	Z, r24
}
    65d0:	cf 91       	pop	r28
    65d2:	df 91       	pop	r29
    65d4:	08 95       	ret

000065d6 <Start_PWM2>:
void Start_PWM2(void){
    65d6:	df 93       	push	r29
    65d8:	cf 93       	push	r28
    65da:	cd b7       	in	r28, 0x3d	; 61
    65dc:	de b7       	in	r29, 0x3e	; 62
	TCCR2 = (1<<WGM20) | (1<<WGM21) | (1<<COM21) | (1<<CS20);
    65de:	e5 e4       	ldi	r30, 0x45	; 69
    65e0:	f0 e0       	ldi	r31, 0x00	; 0
    65e2:	89 e6       	ldi	r24, 0x69	; 105
    65e4:	80 83       	st	Z, r24
	OCR2 = 204;
    65e6:	e3 e4       	ldi	r30, 0x43	; 67
    65e8:	f0 e0       	ldi	r31, 0x00	; 0
    65ea:	8c ec       	ldi	r24, 0xCC	; 204
    65ec:	80 83       	st	Z, r24
}
    65ee:	cf 91       	pop	r28
    65f0:	df 91       	pop	r29
    65f2:	08 95       	ret

000065f4 <Stop_PWM1>:
void Stop_PWM1(void){
    65f4:	df 93       	push	r29
    65f6:	cf 93       	push	r28
    65f8:	cd b7       	in	r28, 0x3d	; 61
    65fa:	de b7       	in	r29, 0x3e	; 62
	TCCR0 &=~ (1<<COM01);
    65fc:	a3 e5       	ldi	r26, 0x53	; 83
    65fe:	b0 e0       	ldi	r27, 0x00	; 0
    6600:	e3 e5       	ldi	r30, 0x53	; 83
    6602:	f0 e0       	ldi	r31, 0x00	; 0
    6604:	80 81       	ld	r24, Z
    6606:	8f 7d       	andi	r24, 0xDF	; 223
    6608:	8c 93       	st	X, r24
	TCCR0 &=~ (1<<CS00);
    660a:	a3 e5       	ldi	r26, 0x53	; 83
    660c:	b0 e0       	ldi	r27, 0x00	; 0
    660e:	e3 e5       	ldi	r30, 0x53	; 83
    6610:	f0 e0       	ldi	r31, 0x00	; 0
    6612:	80 81       	ld	r24, Z
    6614:	8e 7f       	andi	r24, 0xFE	; 254
    6616:	8c 93       	st	X, r24
}
    6618:	cf 91       	pop	r28
    661a:	df 91       	pop	r29
    661c:	08 95       	ret

0000661e <Stop_PWM2>:
void Stop_PWM2(void){
    661e:	df 93       	push	r29
    6620:	cf 93       	push	r28
    6622:	cd b7       	in	r28, 0x3d	; 61
    6624:	de b7       	in	r29, 0x3e	; 62
	TCCR2 &=~ (1<<COM21);
    6626:	a5 e4       	ldi	r26, 0x45	; 69
    6628:	b0 e0       	ldi	r27, 0x00	; 0
    662a:	e5 e4       	ldi	r30, 0x45	; 69
    662c:	f0 e0       	ldi	r31, 0x00	; 0
    662e:	80 81       	ld	r24, Z
    6630:	8f 7d       	andi	r24, 0xDF	; 223
    6632:	8c 93       	st	X, r24
	TCCR2 &=~ (1<<CS20);
    6634:	a5 e4       	ldi	r26, 0x45	; 69
    6636:	b0 e0       	ldi	r27, 0x00	; 0
    6638:	e5 e4       	ldi	r30, 0x45	; 69
    663a:	f0 e0       	ldi	r31, 0x00	; 0
    663c:	80 81       	ld	r24, Z
    663e:	8e 7f       	andi	r24, 0xFE	; 254
    6640:	8c 93       	st	X, r24
}
    6642:	cf 91       	pop	r28
    6644:	df 91       	pop	r29
    6646:	08 95       	ret

00006648 <__udivmodhi4>:
    6648:	aa 1b       	sub	r26, r26
    664a:	bb 1b       	sub	r27, r27
    664c:	51 e1       	ldi	r21, 0x11	; 17
    664e:	07 c0       	rjmp	.+14     	; 0x665e <__udivmodhi4_ep>

00006650 <__udivmodhi4_loop>:
    6650:	aa 1f       	adc	r26, r26
    6652:	bb 1f       	adc	r27, r27
    6654:	a6 17       	cp	r26, r22
    6656:	b7 07       	cpc	r27, r23
    6658:	10 f0       	brcs	.+4      	; 0x665e <__udivmodhi4_ep>
    665a:	a6 1b       	sub	r26, r22
    665c:	b7 0b       	sbc	r27, r23

0000665e <__udivmodhi4_ep>:
    665e:	88 1f       	adc	r24, r24
    6660:	99 1f       	adc	r25, r25
    6662:	5a 95       	dec	r21
    6664:	a9 f7       	brne	.-22     	; 0x6650 <__udivmodhi4_loop>
    6666:	80 95       	com	r24
    6668:	90 95       	com	r25
    666a:	bc 01       	movw	r22, r24
    666c:	cd 01       	movw	r24, r26
    666e:	08 95       	ret

00006670 <__divmodhi4>:
    6670:	97 fb       	bst	r25, 7
    6672:	09 2e       	mov	r0, r25
    6674:	07 26       	eor	r0, r23
    6676:	0a d0       	rcall	.+20     	; 0x668c <__divmodhi4_neg1>
    6678:	77 fd       	sbrc	r23, 7
    667a:	04 d0       	rcall	.+8      	; 0x6684 <__divmodhi4_neg2>
    667c:	e5 df       	rcall	.-54     	; 0x6648 <__udivmodhi4>
    667e:	06 d0       	rcall	.+12     	; 0x668c <__divmodhi4_neg1>
    6680:	00 20       	and	r0, r0
    6682:	1a f4       	brpl	.+6      	; 0x668a <__divmodhi4_exit>

00006684 <__divmodhi4_neg2>:
    6684:	70 95       	com	r23
    6686:	61 95       	neg	r22
    6688:	7f 4f       	sbci	r23, 0xFF	; 255

0000668a <__divmodhi4_exit>:
    668a:	08 95       	ret

0000668c <__divmodhi4_neg1>:
    668c:	f6 f7       	brtc	.-4      	; 0x668a <__divmodhi4_exit>
    668e:	90 95       	com	r25
    6690:	81 95       	neg	r24
    6692:	9f 4f       	sbci	r25, 0xFF	; 255
    6694:	08 95       	ret

00006696 <memcpy>:
    6696:	fb 01       	movw	r30, r22
    6698:	dc 01       	movw	r26, r24
    669a:	02 c0       	rjmp	.+4      	; 0x66a0 <memcpy+0xa>
    669c:	01 90       	ld	r0, Z+
    669e:	0d 92       	st	X+, r0
    66a0:	41 50       	subi	r20, 0x01	; 1
    66a2:	50 40       	sbci	r21, 0x00	; 0
    66a4:	d8 f7       	brcc	.-10     	; 0x669c <memcpy+0x6>
    66a6:	08 95       	ret

000066a8 <memset>:
    66a8:	dc 01       	movw	r26, r24
    66aa:	01 c0       	rjmp	.+2      	; 0x66ae <memset+0x6>
    66ac:	6d 93       	st	X+, r22
    66ae:	41 50       	subi	r20, 0x01	; 1
    66b0:	50 40       	sbci	r21, 0x00	; 0
    66b2:	e0 f7       	brcc	.-8      	; 0x66ac <memset+0x4>
    66b4:	08 95       	ret

000066b6 <_exit>:
    66b6:	f8 94       	cli

000066b8 <__stop_program>:
    66b8:	ff cf       	rjmp	.-2      	; 0x66b8 <__stop_program>
