
RTOS_2023.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007944  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000052  00800060  00007944  000079d8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000006c3  008000b2  008000b2  00007a2a  2**0
                  ALLOC
  3 .stab         0000a284  00000000  00000000  00007a2c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00006125  00000000  00000000  00011cb0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 9a 03 	jmp	0x734	; 0x734 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e4 e4       	ldi	r30, 0x44	; 68
      68:	f9 e7       	ldi	r31, 0x79	; 121
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a2 3b       	cpi	r26, 0xB2	; 178
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a2 eb       	ldi	r26, 0xB2	; 178
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 37       	cpi	r26, 0x75	; 117
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 19 38 	call	0x7032	; 0x7032 <main>
      8a:	0c 94 a0 3c 	jmp	0x7940	; 0x7940 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <pvPortMalloc+0x6>
      98:	00 d0       	rcall	.+0      	; 0x9a <pvPortMalloc+0x8>
      9a:	cd b7       	in	r28, 0x3d	; 61
      9c:	de b7       	in	r29, 0x3e	; 62
      9e:	9c 83       	std	Y+4, r25	; 0x04
      a0:	8b 83       	std	Y+3, r24	; 0x03
    void * pvReturn = NULL;
      a2:	1a 82       	std	Y+2, r1	; 0x02
      a4:	19 82       	std	Y+1, r1	; 0x01
                }
            }
        }
    #endif

    vTaskSuspendAll();
      a6:	0e 94 30 1c 	call	0x3860	; 0x3860 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
      aa:	80 91 b4 00 	lds	r24, 0x00B4
      ae:	90 91 b5 00 	lds	r25, 0x00B5
      b2:	00 97       	sbiw	r24, 0x00	; 0
      b4:	31 f4       	brne	.+12     	; 0xc2 <pvPortMalloc+0x30>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
      b6:	86 eb       	ldi	r24, 0xB6	; 182
      b8:	90 e0       	ldi	r25, 0x00	; 0
      ba:	90 93 b5 00 	sts	0x00B5, r25
      be:	80 93 b4 00 	sts	0x00B4, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
      c2:	8b 81       	ldd	r24, Y+3	; 0x03
      c4:	9c 81       	ldd	r25, Y+4	; 0x04
      c6:	00 97       	sbiw	r24, 0x00	; 0
      c8:	99 f1       	breq	.+102    	; 0x130 <pvPortMalloc+0x9e>
      ca:	80 91 b2 00 	lds	r24, 0x00B2
      ce:	90 91 b3 00 	lds	r25, 0x00B3
      d2:	2b 81       	ldd	r18, Y+3	; 0x03
      d4:	3c 81       	ldd	r19, Y+4	; 0x04
      d6:	82 0f       	add	r24, r18
      d8:	93 1f       	adc	r25, r19
      da:	25 e0       	ldi	r18, 0x05	; 5
      dc:	8b 3d       	cpi	r24, 0xDB	; 219
      de:	92 07       	cpc	r25, r18
      e0:	38 f5       	brcc	.+78     	; 0x130 <pvPortMalloc+0x9e>
      e2:	20 91 b2 00 	lds	r18, 0x00B2
      e6:	30 91 b3 00 	lds	r19, 0x00B3
      ea:	8b 81       	ldd	r24, Y+3	; 0x03
      ec:	9c 81       	ldd	r25, Y+4	; 0x04
      ee:	28 0f       	add	r18, r24
      f0:	39 1f       	adc	r19, r25
      f2:	80 91 b2 00 	lds	r24, 0x00B2
      f6:	90 91 b3 00 	lds	r25, 0x00B3
      fa:	82 17       	cp	r24, r18
      fc:	93 07       	cpc	r25, r19
      fe:	c0 f4       	brcc	.+48     	; 0x130 <pvPortMalloc+0x9e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
     100:	20 91 b4 00 	lds	r18, 0x00B4
     104:	30 91 b5 00 	lds	r19, 0x00B5
     108:	80 91 b2 00 	lds	r24, 0x00B2
     10c:	90 91 b3 00 	lds	r25, 0x00B3
     110:	82 0f       	add	r24, r18
     112:	93 1f       	adc	r25, r19
     114:	9a 83       	std	Y+2, r25	; 0x02
     116:	89 83       	std	Y+1, r24	; 0x01
            xNextFreeByte += xWantedSize;
     118:	20 91 b2 00 	lds	r18, 0x00B2
     11c:	30 91 b3 00 	lds	r19, 0x00B3
     120:	8b 81       	ldd	r24, Y+3	; 0x03
     122:	9c 81       	ldd	r25, Y+4	; 0x04
     124:	82 0f       	add	r24, r18
     126:	93 1f       	adc	r25, r19
     128:	90 93 b3 00 	sts	0x00B3, r25
     12c:	80 93 b2 00 	sts	0x00B2, r24
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
     130:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
     134:	89 81       	ldd	r24, Y+1	; 0x01
     136:	9a 81       	ldd	r25, Y+2	; 0x02
}
     138:	0f 90       	pop	r0
     13a:	0f 90       	pop	r0
     13c:	0f 90       	pop	r0
     13e:	0f 90       	pop	r0
     140:	cf 91       	pop	r28
     142:	df 91       	pop	r29
     144:	08 95       	ret

00000146 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
     146:	df 93       	push	r29
     148:	cf 93       	push	r28
     14a:	00 d0       	rcall	.+0      	; 0x14c <vPortFree+0x6>
     14c:	cd b7       	in	r28, 0x3d	; 61
     14e:	de b7       	in	r29, 0x3e	; 62
     150:	9a 83       	std	Y+2, r25	; 0x02
     152:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
     154:	0f 90       	pop	r0
     156:	0f 90       	pop	r0
     158:	cf 91       	pop	r28
     15a:	df 91       	pop	r29
     15c:	08 95       	ret

0000015e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     15e:	df 93       	push	r29
     160:	cf 93       	push	r28
     162:	cd b7       	in	r28, 0x3d	; 61
     164:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
     166:	10 92 b3 00 	sts	0x00B3, r1
     16a:	10 92 b2 00 	sts	0x00B2, r1
}
     16e:	cf 91       	pop	r28
     170:	df 91       	pop	r29
     172:	08 95       	ret

00000174 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     174:	df 93       	push	r29
     176:	cf 93       	push	r28
     178:	cd b7       	in	r28, 0x3d	; 61
     17a:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     17c:	20 91 b2 00 	lds	r18, 0x00B2
     180:	30 91 b3 00 	lds	r19, 0x00B3
     184:	8b ed       	ldi	r24, 0xDB	; 219
     186:	95 e0       	ldi	r25, 0x05	; 5
     188:	82 1b       	sub	r24, r18
     18a:	93 0b       	sbc	r25, r19
}
     18c:	cf 91       	pop	r28
     18e:	df 91       	pop	r29
     190:	08 95       	ret

00000192 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     192:	df 93       	push	r29
     194:	cf 93       	push	r28
     196:	cd b7       	in	r28, 0x3d	; 61
     198:	de b7       	in	r29, 0x3e	; 62
     19a:	28 97       	sbiw	r28, 0x08	; 8
     19c:	0f b6       	in	r0, 0x3f	; 63
     19e:	f8 94       	cli
     1a0:	de bf       	out	0x3e, r29	; 62
     1a2:	0f be       	out	0x3f, r0	; 63
     1a4:	cd bf       	out	0x3d, r28	; 61
     1a6:	9c 83       	std	Y+4, r25	; 0x04
     1a8:	8b 83       	std	Y+3, r24	; 0x03
     1aa:	7e 83       	std	Y+6, r23	; 0x06
     1ac:	6d 83       	std	Y+5, r22	; 0x05
     1ae:	58 87       	std	Y+8, r21	; 0x08
     1b0:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     1b2:	eb 81       	ldd	r30, Y+3	; 0x03
     1b4:	fc 81       	ldd	r31, Y+4	; 0x04
     1b6:	81 e1       	ldi	r24, 0x11	; 17
     1b8:	80 83       	st	Z, r24
	pxTopOfStack--;
     1ba:	8b 81       	ldd	r24, Y+3	; 0x03
     1bc:	9c 81       	ldd	r25, Y+4	; 0x04
     1be:	01 97       	sbiw	r24, 0x01	; 1
     1c0:	9c 83       	std	Y+4, r25	; 0x04
     1c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     1c4:	eb 81       	ldd	r30, Y+3	; 0x03
     1c6:	fc 81       	ldd	r31, Y+4	; 0x04
     1c8:	82 e2       	ldi	r24, 0x22	; 34
     1ca:	80 83       	st	Z, r24
	pxTopOfStack--;
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	01 97       	sbiw	r24, 0x01	; 1
     1d2:	9c 83       	std	Y+4, r25	; 0x04
     1d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     1d6:	eb 81       	ldd	r30, Y+3	; 0x03
     1d8:	fc 81       	ldd	r31, Y+4	; 0x04
     1da:	83 e3       	ldi	r24, 0x33	; 51
     1dc:	80 83       	st	Z, r24
	pxTopOfStack--;
     1de:	8b 81       	ldd	r24, Y+3	; 0x03
     1e0:	9c 81       	ldd	r25, Y+4	; 0x04
     1e2:	01 97       	sbiw	r24, 0x01	; 1
     1e4:	9c 83       	std	Y+4, r25	; 0x04
     1e6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     1e8:	8d 81       	ldd	r24, Y+5	; 0x05
     1ea:	9e 81       	ldd	r25, Y+6	; 0x06
     1ec:	9a 83       	std	Y+2, r25	; 0x02
     1ee:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     1f0:	89 81       	ldd	r24, Y+1	; 0x01
     1f2:	eb 81       	ldd	r30, Y+3	; 0x03
     1f4:	fc 81       	ldd	r31, Y+4	; 0x04
     1f6:	80 83       	st	Z, r24
	pxTopOfStack--;
     1f8:	8b 81       	ldd	r24, Y+3	; 0x03
     1fa:	9c 81       	ldd	r25, Y+4	; 0x04
     1fc:	01 97       	sbiw	r24, 0x01	; 1
     1fe:	9c 83       	std	Y+4, r25	; 0x04
     200:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     202:	89 81       	ldd	r24, Y+1	; 0x01
     204:	9a 81       	ldd	r25, Y+2	; 0x02
     206:	89 2f       	mov	r24, r25
     208:	99 27       	eor	r25, r25
     20a:	9a 83       	std	Y+2, r25	; 0x02
     20c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     20e:	89 81       	ldd	r24, Y+1	; 0x01
     210:	eb 81       	ldd	r30, Y+3	; 0x03
     212:	fc 81       	ldd	r31, Y+4	; 0x04
     214:	80 83       	st	Z, r24
	pxTopOfStack--;
     216:	8b 81       	ldd	r24, Y+3	; 0x03
     218:	9c 81       	ldd	r25, Y+4	; 0x04
     21a:	01 97       	sbiw	r24, 0x01	; 1
     21c:	9c 83       	std	Y+4, r25	; 0x04
     21e:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     220:	eb 81       	ldd	r30, Y+3	; 0x03
     222:	fc 81       	ldd	r31, Y+4	; 0x04
     224:	10 82       	st	Z, r1
	pxTopOfStack--;
     226:	8b 81       	ldd	r24, Y+3	; 0x03
     228:	9c 81       	ldd	r25, Y+4	; 0x04
     22a:	01 97       	sbiw	r24, 0x01	; 1
     22c:	9c 83       	std	Y+4, r25	; 0x04
     22e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     230:	eb 81       	ldd	r30, Y+3	; 0x03
     232:	fc 81       	ldd	r31, Y+4	; 0x04
     234:	80 e8       	ldi	r24, 0x80	; 128
     236:	80 83       	st	Z, r24
	pxTopOfStack--;
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	01 97       	sbiw	r24, 0x01	; 1
     23e:	9c 83       	std	Y+4, r25	; 0x04
     240:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     242:	eb 81       	ldd	r30, Y+3	; 0x03
     244:	fc 81       	ldd	r31, Y+4	; 0x04
     246:	10 82       	st	Z, r1
	pxTopOfStack--;
     248:	8b 81       	ldd	r24, Y+3	; 0x03
     24a:	9c 81       	ldd	r25, Y+4	; 0x04
     24c:	01 97       	sbiw	r24, 0x01	; 1
     24e:	9c 83       	std	Y+4, r25	; 0x04
     250:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     252:	eb 81       	ldd	r30, Y+3	; 0x03
     254:	fc 81       	ldd	r31, Y+4	; 0x04
     256:	82 e0       	ldi	r24, 0x02	; 2
     258:	80 83       	st	Z, r24
	pxTopOfStack--;
     25a:	8b 81       	ldd	r24, Y+3	; 0x03
     25c:	9c 81       	ldd	r25, Y+4	; 0x04
     25e:	01 97       	sbiw	r24, 0x01	; 1
     260:	9c 83       	std	Y+4, r25	; 0x04
     262:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     264:	eb 81       	ldd	r30, Y+3	; 0x03
     266:	fc 81       	ldd	r31, Y+4	; 0x04
     268:	83 e0       	ldi	r24, 0x03	; 3
     26a:	80 83       	st	Z, r24
	pxTopOfStack--;
     26c:	8b 81       	ldd	r24, Y+3	; 0x03
     26e:	9c 81       	ldd	r25, Y+4	; 0x04
     270:	01 97       	sbiw	r24, 0x01	; 1
     272:	9c 83       	std	Y+4, r25	; 0x04
     274:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     276:	eb 81       	ldd	r30, Y+3	; 0x03
     278:	fc 81       	ldd	r31, Y+4	; 0x04
     27a:	84 e0       	ldi	r24, 0x04	; 4
     27c:	80 83       	st	Z, r24
	pxTopOfStack--;
     27e:	8b 81       	ldd	r24, Y+3	; 0x03
     280:	9c 81       	ldd	r25, Y+4	; 0x04
     282:	01 97       	sbiw	r24, 0x01	; 1
     284:	9c 83       	std	Y+4, r25	; 0x04
     286:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     288:	eb 81       	ldd	r30, Y+3	; 0x03
     28a:	fc 81       	ldd	r31, Y+4	; 0x04
     28c:	85 e0       	ldi	r24, 0x05	; 5
     28e:	80 83       	st	Z, r24
	pxTopOfStack--;
     290:	8b 81       	ldd	r24, Y+3	; 0x03
     292:	9c 81       	ldd	r25, Y+4	; 0x04
     294:	01 97       	sbiw	r24, 0x01	; 1
     296:	9c 83       	std	Y+4, r25	; 0x04
     298:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     29a:	eb 81       	ldd	r30, Y+3	; 0x03
     29c:	fc 81       	ldd	r31, Y+4	; 0x04
     29e:	86 e0       	ldi	r24, 0x06	; 6
     2a0:	80 83       	st	Z, r24
	pxTopOfStack--;
     2a2:	8b 81       	ldd	r24, Y+3	; 0x03
     2a4:	9c 81       	ldd	r25, Y+4	; 0x04
     2a6:	01 97       	sbiw	r24, 0x01	; 1
     2a8:	9c 83       	std	Y+4, r25	; 0x04
     2aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     2ac:	eb 81       	ldd	r30, Y+3	; 0x03
     2ae:	fc 81       	ldd	r31, Y+4	; 0x04
     2b0:	87 e0       	ldi	r24, 0x07	; 7
     2b2:	80 83       	st	Z, r24
	pxTopOfStack--;
     2b4:	8b 81       	ldd	r24, Y+3	; 0x03
     2b6:	9c 81       	ldd	r25, Y+4	; 0x04
     2b8:	01 97       	sbiw	r24, 0x01	; 1
     2ba:	9c 83       	std	Y+4, r25	; 0x04
     2bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     2be:	eb 81       	ldd	r30, Y+3	; 0x03
     2c0:	fc 81       	ldd	r31, Y+4	; 0x04
     2c2:	88 e0       	ldi	r24, 0x08	; 8
     2c4:	80 83       	st	Z, r24
	pxTopOfStack--;
     2c6:	8b 81       	ldd	r24, Y+3	; 0x03
     2c8:	9c 81       	ldd	r25, Y+4	; 0x04
     2ca:	01 97       	sbiw	r24, 0x01	; 1
     2cc:	9c 83       	std	Y+4, r25	; 0x04
     2ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     2d0:	eb 81       	ldd	r30, Y+3	; 0x03
     2d2:	fc 81       	ldd	r31, Y+4	; 0x04
     2d4:	89 e0       	ldi	r24, 0x09	; 9
     2d6:	80 83       	st	Z, r24
	pxTopOfStack--;
     2d8:	8b 81       	ldd	r24, Y+3	; 0x03
     2da:	9c 81       	ldd	r25, Y+4	; 0x04
     2dc:	01 97       	sbiw	r24, 0x01	; 1
     2de:	9c 83       	std	Y+4, r25	; 0x04
     2e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     2e2:	eb 81       	ldd	r30, Y+3	; 0x03
     2e4:	fc 81       	ldd	r31, Y+4	; 0x04
     2e6:	80 e1       	ldi	r24, 0x10	; 16
     2e8:	80 83       	st	Z, r24
	pxTopOfStack--;
     2ea:	8b 81       	ldd	r24, Y+3	; 0x03
     2ec:	9c 81       	ldd	r25, Y+4	; 0x04
     2ee:	01 97       	sbiw	r24, 0x01	; 1
     2f0:	9c 83       	std	Y+4, r25	; 0x04
     2f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     2f4:	eb 81       	ldd	r30, Y+3	; 0x03
     2f6:	fc 81       	ldd	r31, Y+4	; 0x04
     2f8:	81 e1       	ldi	r24, 0x11	; 17
     2fa:	80 83       	st	Z, r24
	pxTopOfStack--;
     2fc:	8b 81       	ldd	r24, Y+3	; 0x03
     2fe:	9c 81       	ldd	r25, Y+4	; 0x04
     300:	01 97       	sbiw	r24, 0x01	; 1
     302:	9c 83       	std	Y+4, r25	; 0x04
     304:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     306:	eb 81       	ldd	r30, Y+3	; 0x03
     308:	fc 81       	ldd	r31, Y+4	; 0x04
     30a:	82 e1       	ldi	r24, 0x12	; 18
     30c:	80 83       	st	Z, r24
	pxTopOfStack--;
     30e:	8b 81       	ldd	r24, Y+3	; 0x03
     310:	9c 81       	ldd	r25, Y+4	; 0x04
     312:	01 97       	sbiw	r24, 0x01	; 1
     314:	9c 83       	std	Y+4, r25	; 0x04
     316:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     318:	eb 81       	ldd	r30, Y+3	; 0x03
     31a:	fc 81       	ldd	r31, Y+4	; 0x04
     31c:	83 e1       	ldi	r24, 0x13	; 19
     31e:	80 83       	st	Z, r24
	pxTopOfStack--;
     320:	8b 81       	ldd	r24, Y+3	; 0x03
     322:	9c 81       	ldd	r25, Y+4	; 0x04
     324:	01 97       	sbiw	r24, 0x01	; 1
     326:	9c 83       	std	Y+4, r25	; 0x04
     328:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     32a:	eb 81       	ldd	r30, Y+3	; 0x03
     32c:	fc 81       	ldd	r31, Y+4	; 0x04
     32e:	84 e1       	ldi	r24, 0x14	; 20
     330:	80 83       	st	Z, r24
	pxTopOfStack--;
     332:	8b 81       	ldd	r24, Y+3	; 0x03
     334:	9c 81       	ldd	r25, Y+4	; 0x04
     336:	01 97       	sbiw	r24, 0x01	; 1
     338:	9c 83       	std	Y+4, r25	; 0x04
     33a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     33c:	eb 81       	ldd	r30, Y+3	; 0x03
     33e:	fc 81       	ldd	r31, Y+4	; 0x04
     340:	85 e1       	ldi	r24, 0x15	; 21
     342:	80 83       	st	Z, r24
	pxTopOfStack--;
     344:	8b 81       	ldd	r24, Y+3	; 0x03
     346:	9c 81       	ldd	r25, Y+4	; 0x04
     348:	01 97       	sbiw	r24, 0x01	; 1
     34a:	9c 83       	std	Y+4, r25	; 0x04
     34c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     34e:	eb 81       	ldd	r30, Y+3	; 0x03
     350:	fc 81       	ldd	r31, Y+4	; 0x04
     352:	86 e1       	ldi	r24, 0x16	; 22
     354:	80 83       	st	Z, r24
	pxTopOfStack--;
     356:	8b 81       	ldd	r24, Y+3	; 0x03
     358:	9c 81       	ldd	r25, Y+4	; 0x04
     35a:	01 97       	sbiw	r24, 0x01	; 1
     35c:	9c 83       	std	Y+4, r25	; 0x04
     35e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     360:	eb 81       	ldd	r30, Y+3	; 0x03
     362:	fc 81       	ldd	r31, Y+4	; 0x04
     364:	87 e1       	ldi	r24, 0x17	; 23
     366:	80 83       	st	Z, r24
	pxTopOfStack--;
     368:	8b 81       	ldd	r24, Y+3	; 0x03
     36a:	9c 81       	ldd	r25, Y+4	; 0x04
     36c:	01 97       	sbiw	r24, 0x01	; 1
     36e:	9c 83       	std	Y+4, r25	; 0x04
     370:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     372:	eb 81       	ldd	r30, Y+3	; 0x03
     374:	fc 81       	ldd	r31, Y+4	; 0x04
     376:	88 e1       	ldi	r24, 0x18	; 24
     378:	80 83       	st	Z, r24
	pxTopOfStack--;
     37a:	8b 81       	ldd	r24, Y+3	; 0x03
     37c:	9c 81       	ldd	r25, Y+4	; 0x04
     37e:	01 97       	sbiw	r24, 0x01	; 1
     380:	9c 83       	std	Y+4, r25	; 0x04
     382:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     384:	eb 81       	ldd	r30, Y+3	; 0x03
     386:	fc 81       	ldd	r31, Y+4	; 0x04
     388:	89 e1       	ldi	r24, 0x19	; 25
     38a:	80 83       	st	Z, r24
	pxTopOfStack--;
     38c:	8b 81       	ldd	r24, Y+3	; 0x03
     38e:	9c 81       	ldd	r25, Y+4	; 0x04
     390:	01 97       	sbiw	r24, 0x01	; 1
     392:	9c 83       	std	Y+4, r25	; 0x04
     394:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     396:	eb 81       	ldd	r30, Y+3	; 0x03
     398:	fc 81       	ldd	r31, Y+4	; 0x04
     39a:	80 e2       	ldi	r24, 0x20	; 32
     39c:	80 83       	st	Z, r24
	pxTopOfStack--;
     39e:	8b 81       	ldd	r24, Y+3	; 0x03
     3a0:	9c 81       	ldd	r25, Y+4	; 0x04
     3a2:	01 97       	sbiw	r24, 0x01	; 1
     3a4:	9c 83       	std	Y+4, r25	; 0x04
     3a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     3a8:	eb 81       	ldd	r30, Y+3	; 0x03
     3aa:	fc 81       	ldd	r31, Y+4	; 0x04
     3ac:	81 e2       	ldi	r24, 0x21	; 33
     3ae:	80 83       	st	Z, r24
	pxTopOfStack--;
     3b0:	8b 81       	ldd	r24, Y+3	; 0x03
     3b2:	9c 81       	ldd	r25, Y+4	; 0x04
     3b4:	01 97       	sbiw	r24, 0x01	; 1
     3b6:	9c 83       	std	Y+4, r25	; 0x04
     3b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     3ba:	eb 81       	ldd	r30, Y+3	; 0x03
     3bc:	fc 81       	ldd	r31, Y+4	; 0x04
     3be:	82 e2       	ldi	r24, 0x22	; 34
     3c0:	80 83       	st	Z, r24
	pxTopOfStack--;
     3c2:	8b 81       	ldd	r24, Y+3	; 0x03
     3c4:	9c 81       	ldd	r25, Y+4	; 0x04
     3c6:	01 97       	sbiw	r24, 0x01	; 1
     3c8:	9c 83       	std	Y+4, r25	; 0x04
     3ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     3cc:	eb 81       	ldd	r30, Y+3	; 0x03
     3ce:	fc 81       	ldd	r31, Y+4	; 0x04
     3d0:	83 e2       	ldi	r24, 0x23	; 35
     3d2:	80 83       	st	Z, r24
	pxTopOfStack--;
     3d4:	8b 81       	ldd	r24, Y+3	; 0x03
     3d6:	9c 81       	ldd	r25, Y+4	; 0x04
     3d8:	01 97       	sbiw	r24, 0x01	; 1
     3da:	9c 83       	std	Y+4, r25	; 0x04
     3dc:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     3de:	8f 81       	ldd	r24, Y+7	; 0x07
     3e0:	98 85       	ldd	r25, Y+8	; 0x08
     3e2:	9a 83       	std	Y+2, r25	; 0x02
     3e4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     3e6:	89 81       	ldd	r24, Y+1	; 0x01
     3e8:	eb 81       	ldd	r30, Y+3	; 0x03
     3ea:	fc 81       	ldd	r31, Y+4	; 0x04
     3ec:	80 83       	st	Z, r24
	pxTopOfStack--;
     3ee:	8b 81       	ldd	r24, Y+3	; 0x03
     3f0:	9c 81       	ldd	r25, Y+4	; 0x04
     3f2:	01 97       	sbiw	r24, 0x01	; 1
     3f4:	9c 83       	std	Y+4, r25	; 0x04
     3f6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     3f8:	89 81       	ldd	r24, Y+1	; 0x01
     3fa:	9a 81       	ldd	r25, Y+2	; 0x02
     3fc:	89 2f       	mov	r24, r25
     3fe:	99 27       	eor	r25, r25
     400:	9a 83       	std	Y+2, r25	; 0x02
     402:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     404:	89 81       	ldd	r24, Y+1	; 0x01
     406:	eb 81       	ldd	r30, Y+3	; 0x03
     408:	fc 81       	ldd	r31, Y+4	; 0x04
     40a:	80 83       	st	Z, r24
	pxTopOfStack--;
     40c:	8b 81       	ldd	r24, Y+3	; 0x03
     40e:	9c 81       	ldd	r25, Y+4	; 0x04
     410:	01 97       	sbiw	r24, 0x01	; 1
     412:	9c 83       	std	Y+4, r25	; 0x04
     414:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     416:	eb 81       	ldd	r30, Y+3	; 0x03
     418:	fc 81       	ldd	r31, Y+4	; 0x04
     41a:	86 e2       	ldi	r24, 0x26	; 38
     41c:	80 83       	st	Z, r24
	pxTopOfStack--;
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	9c 81       	ldd	r25, Y+4	; 0x04
     422:	01 97       	sbiw	r24, 0x01	; 1
     424:	9c 83       	std	Y+4, r25	; 0x04
     426:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     428:	eb 81       	ldd	r30, Y+3	; 0x03
     42a:	fc 81       	ldd	r31, Y+4	; 0x04
     42c:	87 e2       	ldi	r24, 0x27	; 39
     42e:	80 83       	st	Z, r24
	pxTopOfStack--;
     430:	8b 81       	ldd	r24, Y+3	; 0x03
     432:	9c 81       	ldd	r25, Y+4	; 0x04
     434:	01 97       	sbiw	r24, 0x01	; 1
     436:	9c 83       	std	Y+4, r25	; 0x04
     438:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     43a:	eb 81       	ldd	r30, Y+3	; 0x03
     43c:	fc 81       	ldd	r31, Y+4	; 0x04
     43e:	88 e2       	ldi	r24, 0x28	; 40
     440:	80 83       	st	Z, r24
	pxTopOfStack--;
     442:	8b 81       	ldd	r24, Y+3	; 0x03
     444:	9c 81       	ldd	r25, Y+4	; 0x04
     446:	01 97       	sbiw	r24, 0x01	; 1
     448:	9c 83       	std	Y+4, r25	; 0x04
     44a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     44c:	eb 81       	ldd	r30, Y+3	; 0x03
     44e:	fc 81       	ldd	r31, Y+4	; 0x04
     450:	89 e2       	ldi	r24, 0x29	; 41
     452:	80 83       	st	Z, r24
	pxTopOfStack--;
     454:	8b 81       	ldd	r24, Y+3	; 0x03
     456:	9c 81       	ldd	r25, Y+4	; 0x04
     458:	01 97       	sbiw	r24, 0x01	; 1
     45a:	9c 83       	std	Y+4, r25	; 0x04
     45c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     45e:	eb 81       	ldd	r30, Y+3	; 0x03
     460:	fc 81       	ldd	r31, Y+4	; 0x04
     462:	80 e3       	ldi	r24, 0x30	; 48
     464:	80 83       	st	Z, r24
	pxTopOfStack--;
     466:	8b 81       	ldd	r24, Y+3	; 0x03
     468:	9c 81       	ldd	r25, Y+4	; 0x04
     46a:	01 97       	sbiw	r24, 0x01	; 1
     46c:	9c 83       	std	Y+4, r25	; 0x04
     46e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     470:	eb 81       	ldd	r30, Y+3	; 0x03
     472:	fc 81       	ldd	r31, Y+4	; 0x04
     474:	81 e3       	ldi	r24, 0x31	; 49
     476:	80 83       	st	Z, r24
	pxTopOfStack--;
     478:	8b 81       	ldd	r24, Y+3	; 0x03
     47a:	9c 81       	ldd	r25, Y+4	; 0x04
     47c:	01 97       	sbiw	r24, 0x01	; 1
     47e:	9c 83       	std	Y+4, r25	; 0x04
     480:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     482:	8b 81       	ldd	r24, Y+3	; 0x03
     484:	9c 81       	ldd	r25, Y+4	; 0x04
}
     486:	28 96       	adiw	r28, 0x08	; 8
     488:	0f b6       	in	r0, 0x3f	; 63
     48a:	f8 94       	cli
     48c:	de bf       	out	0x3e, r29	; 62
     48e:	0f be       	out	0x3f, r0	; 63
     490:	cd bf       	out	0x3d, r28	; 61
     492:	cf 91       	pop	r28
     494:	df 91       	pop	r29
     496:	08 95       	ret

00000498 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     498:	df 93       	push	r29
     49a:	cf 93       	push	r28
     49c:	cd b7       	in	r28, 0x3d	; 61
     49e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     4a0:	0e 94 3e 03 	call	0x67c	; 0x67c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     4a4:	a0 91 cc 06 	lds	r26, 0x06CC
     4a8:	b0 91 cd 06 	lds	r27, 0x06CD
     4ac:	cd 91       	ld	r28, X+
     4ae:	cd bf       	out	0x3d, r28	; 61
     4b0:	dd 91       	ld	r29, X+
     4b2:	de bf       	out	0x3e, r29	; 62
     4b4:	ff 91       	pop	r31
     4b6:	ef 91       	pop	r30
     4b8:	df 91       	pop	r29
     4ba:	cf 91       	pop	r28
     4bc:	bf 91       	pop	r27
     4be:	af 91       	pop	r26
     4c0:	9f 91       	pop	r25
     4c2:	8f 91       	pop	r24
     4c4:	7f 91       	pop	r23
     4c6:	6f 91       	pop	r22
     4c8:	5f 91       	pop	r21
     4ca:	4f 91       	pop	r20
     4cc:	3f 91       	pop	r19
     4ce:	2f 91       	pop	r18
     4d0:	1f 91       	pop	r17
     4d2:	0f 91       	pop	r16
     4d4:	ff 90       	pop	r15
     4d6:	ef 90       	pop	r14
     4d8:	df 90       	pop	r13
     4da:	cf 90       	pop	r12
     4dc:	bf 90       	pop	r11
     4de:	af 90       	pop	r10
     4e0:	9f 90       	pop	r9
     4e2:	8f 90       	pop	r8
     4e4:	7f 90       	pop	r7
     4e6:	6f 90       	pop	r6
     4e8:	5f 90       	pop	r5
     4ea:	4f 90       	pop	r4
     4ec:	3f 90       	pop	r3
     4ee:	2f 90       	pop	r2
     4f0:	1f 90       	pop	r1
     4f2:	0f 90       	pop	r0
     4f4:	0f be       	out	0x3f, r0	; 63
     4f6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     4f8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     4fa:	81 e0       	ldi	r24, 0x01	; 1
}
     4fc:	cf 91       	pop	r28
     4fe:	df 91       	pop	r29
     500:	08 95       	ret

00000502 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     502:	df 93       	push	r29
     504:	cf 93       	push	r28
     506:	cd b7       	in	r28, 0x3d	; 61
     508:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     50a:	cf 91       	pop	r28
     50c:	df 91       	pop	r29
     50e:	08 95       	ret

00000510 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     510:	0f 92       	push	r0
     512:	0f b6       	in	r0, 0x3f	; 63
     514:	f8 94       	cli
     516:	0f 92       	push	r0
     518:	1f 92       	push	r1
     51a:	11 24       	eor	r1, r1
     51c:	2f 92       	push	r2
     51e:	3f 92       	push	r3
     520:	4f 92       	push	r4
     522:	5f 92       	push	r5
     524:	6f 92       	push	r6
     526:	7f 92       	push	r7
     528:	8f 92       	push	r8
     52a:	9f 92       	push	r9
     52c:	af 92       	push	r10
     52e:	bf 92       	push	r11
     530:	cf 92       	push	r12
     532:	df 92       	push	r13
     534:	ef 92       	push	r14
     536:	ff 92       	push	r15
     538:	0f 93       	push	r16
     53a:	1f 93       	push	r17
     53c:	2f 93       	push	r18
     53e:	3f 93       	push	r19
     540:	4f 93       	push	r20
     542:	5f 93       	push	r21
     544:	6f 93       	push	r22
     546:	7f 93       	push	r23
     548:	8f 93       	push	r24
     54a:	9f 93       	push	r25
     54c:	af 93       	push	r26
     54e:	bf 93       	push	r27
     550:	cf 93       	push	r28
     552:	df 93       	push	r29
     554:	ef 93       	push	r30
     556:	ff 93       	push	r31
     558:	a0 91 cc 06 	lds	r26, 0x06CC
     55c:	b0 91 cd 06 	lds	r27, 0x06CD
     560:	0d b6       	in	r0, 0x3d	; 61
     562:	0d 92       	st	X+, r0
     564:	0e b6       	in	r0, 0x3e	; 62
     566:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     568:	0e 94 50 20 	call	0x40a0	; 0x40a0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     56c:	a0 91 cc 06 	lds	r26, 0x06CC
     570:	b0 91 cd 06 	lds	r27, 0x06CD
     574:	cd 91       	ld	r28, X+
     576:	cd bf       	out	0x3d, r28	; 61
     578:	dd 91       	ld	r29, X+
     57a:	de bf       	out	0x3e, r29	; 62
     57c:	ff 91       	pop	r31
     57e:	ef 91       	pop	r30
     580:	df 91       	pop	r29
     582:	cf 91       	pop	r28
     584:	bf 91       	pop	r27
     586:	af 91       	pop	r26
     588:	9f 91       	pop	r25
     58a:	8f 91       	pop	r24
     58c:	7f 91       	pop	r23
     58e:	6f 91       	pop	r22
     590:	5f 91       	pop	r21
     592:	4f 91       	pop	r20
     594:	3f 91       	pop	r19
     596:	2f 91       	pop	r18
     598:	1f 91       	pop	r17
     59a:	0f 91       	pop	r16
     59c:	ff 90       	pop	r15
     59e:	ef 90       	pop	r14
     5a0:	df 90       	pop	r13
     5a2:	cf 90       	pop	r12
     5a4:	bf 90       	pop	r11
     5a6:	af 90       	pop	r10
     5a8:	9f 90       	pop	r9
     5aa:	8f 90       	pop	r8
     5ac:	7f 90       	pop	r7
     5ae:	6f 90       	pop	r6
     5b0:	5f 90       	pop	r5
     5b2:	4f 90       	pop	r4
     5b4:	3f 90       	pop	r3
     5b6:	2f 90       	pop	r2
     5b8:	1f 90       	pop	r1
     5ba:	0f 90       	pop	r0
     5bc:	0f be       	out	0x3f, r0	; 63
     5be:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5c0:	08 95       	ret

000005c2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     5c2:	0f 92       	push	r0
     5c4:	0f b6       	in	r0, 0x3f	; 63
     5c6:	f8 94       	cli
     5c8:	0f 92       	push	r0
     5ca:	1f 92       	push	r1
     5cc:	11 24       	eor	r1, r1
     5ce:	2f 92       	push	r2
     5d0:	3f 92       	push	r3
     5d2:	4f 92       	push	r4
     5d4:	5f 92       	push	r5
     5d6:	6f 92       	push	r6
     5d8:	7f 92       	push	r7
     5da:	8f 92       	push	r8
     5dc:	9f 92       	push	r9
     5de:	af 92       	push	r10
     5e0:	bf 92       	push	r11
     5e2:	cf 92       	push	r12
     5e4:	df 92       	push	r13
     5e6:	ef 92       	push	r14
     5e8:	ff 92       	push	r15
     5ea:	0f 93       	push	r16
     5ec:	1f 93       	push	r17
     5ee:	2f 93       	push	r18
     5f0:	3f 93       	push	r19
     5f2:	4f 93       	push	r20
     5f4:	5f 93       	push	r21
     5f6:	6f 93       	push	r22
     5f8:	7f 93       	push	r23
     5fa:	8f 93       	push	r24
     5fc:	9f 93       	push	r25
     5fe:	af 93       	push	r26
     600:	bf 93       	push	r27
     602:	cf 93       	push	r28
     604:	df 93       	push	r29
     606:	ef 93       	push	r30
     608:	ff 93       	push	r31
     60a:	a0 91 cc 06 	lds	r26, 0x06CC
     60e:	b0 91 cd 06 	lds	r27, 0x06CD
     612:	0d b6       	in	r0, 0x3d	; 61
     614:	0d 92       	st	X+, r0
     616:	0e b6       	in	r0, 0x3e	; 62
     618:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     61a:	0e 94 b9 1e 	call	0x3d72	; 0x3d72 <xTaskIncrementTick>
     61e:	88 23       	and	r24, r24
     620:	11 f0       	breq	.+4      	; 0x626 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     622:	0e 94 50 20 	call	0x40a0	; 0x40a0 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     626:	a0 91 cc 06 	lds	r26, 0x06CC
     62a:	b0 91 cd 06 	lds	r27, 0x06CD
     62e:	cd 91       	ld	r28, X+
     630:	cd bf       	out	0x3d, r28	; 61
     632:	dd 91       	ld	r29, X+
     634:	de bf       	out	0x3e, r29	; 62
     636:	ff 91       	pop	r31
     638:	ef 91       	pop	r30
     63a:	df 91       	pop	r29
     63c:	cf 91       	pop	r28
     63e:	bf 91       	pop	r27
     640:	af 91       	pop	r26
     642:	9f 91       	pop	r25
     644:	8f 91       	pop	r24
     646:	7f 91       	pop	r23
     648:	6f 91       	pop	r22
     64a:	5f 91       	pop	r21
     64c:	4f 91       	pop	r20
     64e:	3f 91       	pop	r19
     650:	2f 91       	pop	r18
     652:	1f 91       	pop	r17
     654:	0f 91       	pop	r16
     656:	ff 90       	pop	r15
     658:	ef 90       	pop	r14
     65a:	df 90       	pop	r13
     65c:	cf 90       	pop	r12
     65e:	bf 90       	pop	r11
     660:	af 90       	pop	r10
     662:	9f 90       	pop	r9
     664:	8f 90       	pop	r8
     666:	7f 90       	pop	r7
     668:	6f 90       	pop	r6
     66a:	5f 90       	pop	r5
     66c:	4f 90       	pop	r4
     66e:	3f 90       	pop	r3
     670:	2f 90       	pop	r2
     672:	1f 90       	pop	r1
     674:	0f 90       	pop	r0
     676:	0f be       	out	0x3f, r0	; 63
     678:	0f 90       	pop	r0

	asm volatile ( "ret" );
     67a:	08 95       	ret

0000067c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     67c:	df 93       	push	r29
     67e:	cf 93       	push	r28
     680:	00 d0       	rcall	.+0      	; 0x682 <prvSetupTimerInterrupt+0x6>
     682:	00 d0       	rcall	.+0      	; 0x684 <prvSetupTimerInterrupt+0x8>
     684:	00 d0       	rcall	.+0      	; 0x686 <prvSetupTimerInterrupt+0xa>
     686:	cd b7       	in	r28, 0x3d	; 61
     688:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     68a:	80 e4       	ldi	r24, 0x40	; 64
     68c:	9f e1       	ldi	r25, 0x1F	; 31
     68e:	a0 e0       	ldi	r26, 0x00	; 0
     690:	b0 e0       	ldi	r27, 0x00	; 0
     692:	8b 83       	std	Y+3, r24	; 0x03
     694:	9c 83       	std	Y+4, r25	; 0x04
     696:	ad 83       	std	Y+5, r26	; 0x05
     698:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     69a:	8b 81       	ldd	r24, Y+3	; 0x03
     69c:	9c 81       	ldd	r25, Y+4	; 0x04
     69e:	ad 81       	ldd	r26, Y+5	; 0x05
     6a0:	be 81       	ldd	r27, Y+6	; 0x06
     6a2:	68 94       	set
     6a4:	15 f8       	bld	r1, 5
     6a6:	b6 95       	lsr	r27
     6a8:	a7 95       	ror	r26
     6aa:	97 95       	ror	r25
     6ac:	87 95       	ror	r24
     6ae:	16 94       	lsr	r1
     6b0:	d1 f7       	brne	.-12     	; 0x6a6 <prvSetupTimerInterrupt+0x2a>
     6b2:	8b 83       	std	Y+3, r24	; 0x03
     6b4:	9c 83       	std	Y+4, r25	; 0x04
     6b6:	ad 83       	std	Y+5, r26	; 0x05
     6b8:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     6ba:	8b 81       	ldd	r24, Y+3	; 0x03
     6bc:	9c 81       	ldd	r25, Y+4	; 0x04
     6be:	ad 81       	ldd	r26, Y+5	; 0x05
     6c0:	be 81       	ldd	r27, Y+6	; 0x06
     6c2:	01 97       	sbiw	r24, 0x01	; 1
     6c4:	a1 09       	sbc	r26, r1
     6c6:	b1 09       	sbc	r27, r1
     6c8:	8b 83       	std	Y+3, r24	; 0x03
     6ca:	9c 83       	std	Y+4, r25	; 0x04
     6cc:	ad 83       	std	Y+5, r26	; 0x05
     6ce:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     6d0:	8b 81       	ldd	r24, Y+3	; 0x03
     6d2:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     6d4:	8b 81       	ldd	r24, Y+3	; 0x03
     6d6:	9c 81       	ldd	r25, Y+4	; 0x04
     6d8:	ad 81       	ldd	r26, Y+5	; 0x05
     6da:	be 81       	ldd	r27, Y+6	; 0x06
     6dc:	89 2f       	mov	r24, r25
     6de:	9a 2f       	mov	r25, r26
     6e0:	ab 2f       	mov	r26, r27
     6e2:	bb 27       	eor	r27, r27
     6e4:	8b 83       	std	Y+3, r24	; 0x03
     6e6:	9c 83       	std	Y+4, r25	; 0x04
     6e8:	ad 83       	std	Y+5, r26	; 0x05
     6ea:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     6ec:	8b 81       	ldd	r24, Y+3	; 0x03
     6ee:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     6f0:	eb e4       	ldi	r30, 0x4B	; 75
     6f2:	f0 e0       	ldi	r31, 0x00	; 0
     6f4:	8a 81       	ldd	r24, Y+2	; 0x02
     6f6:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     6f8:	ea e4       	ldi	r30, 0x4A	; 74
     6fa:	f0 e0       	ldi	r31, 0x00	; 0
     6fc:	89 81       	ldd	r24, Y+1	; 0x01
     6fe:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     700:	8b e0       	ldi	r24, 0x0B	; 11
     702:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     704:	ee e4       	ldi	r30, 0x4E	; 78
     706:	f0 e0       	ldi	r31, 0x00	; 0
     708:	89 81       	ldd	r24, Y+1	; 0x01
     70a:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     70c:	e9 e5       	ldi	r30, 0x59	; 89
     70e:	f0 e0       	ldi	r31, 0x00	; 0
     710:	80 81       	ld	r24, Z
     712:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     714:	89 81       	ldd	r24, Y+1	; 0x01
     716:	80 61       	ori	r24, 0x10	; 16
     718:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
     71a:	e9 e5       	ldi	r30, 0x59	; 89
     71c:	f0 e0       	ldi	r31, 0x00	; 0
     71e:	89 81       	ldd	r24, Y+1	; 0x01
     720:	80 83       	st	Z, r24
}
     722:	26 96       	adiw	r28, 0x06	; 6
     724:	0f b6       	in	r0, 0x3f	; 63
     726:	f8 94       	cli
     728:	de bf       	out	0x3e, r29	; 62
     72a:	0f be       	out	0x3f, r0	; 63
     72c:	cd bf       	out	0x3d, r28	; 61
     72e:	cf 91       	pop	r28
     730:	df 91       	pop	r29
     732:	08 95       	ret

00000734 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     734:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vPortYieldFromTick>
		asm volatile ( "reti" );
     738:	18 95       	reti

0000073a <DIO_SetPinDir>:


#include "DIO.h"

void DIO_SetPinDir(uint8_t port ,uint8_t pin, uint8_t dir)
{
     73a:	df 93       	push	r29
     73c:	cf 93       	push	r28
     73e:	cd b7       	in	r28, 0x3d	; 61
     740:	de b7       	in	r29, 0x3e	; 62
     742:	2d 97       	sbiw	r28, 0x0d	; 13
     744:	0f b6       	in	r0, 0x3f	; 63
     746:	f8 94       	cli
     748:	de bf       	out	0x3e, r29	; 62
     74a:	0f be       	out	0x3f, r0	; 63
     74c:	cd bf       	out	0x3d, r28	; 61
     74e:	89 83       	std	Y+1, r24	; 0x01
     750:	6a 83       	std	Y+2, r22	; 0x02
     752:	4b 83       	std	Y+3, r20	; 0x03
	switch (port)
     754:	89 81       	ldd	r24, Y+1	; 0x01
     756:	28 2f       	mov	r18, r24
     758:	30 e0       	ldi	r19, 0x00	; 0
     75a:	3d 87       	std	Y+13, r19	; 0x0d
     75c:	2c 87       	std	Y+12, r18	; 0x0c
     75e:	8c 85       	ldd	r24, Y+12	; 0x0c
     760:	9d 85       	ldd	r25, Y+13	; 0x0d
     762:	81 30       	cpi	r24, 0x01	; 1
     764:	91 05       	cpc	r25, r1
     766:	09 f4       	brne	.+2      	; 0x76a <DIO_SetPinDir+0x30>
     768:	44 c0       	rjmp	.+136    	; 0x7f2 <DIO_SetPinDir+0xb8>
     76a:	2c 85       	ldd	r18, Y+12	; 0x0c
     76c:	3d 85       	ldd	r19, Y+13	; 0x0d
     76e:	22 30       	cpi	r18, 0x02	; 2
     770:	31 05       	cpc	r19, r1
     772:	2c f4       	brge	.+10     	; 0x77e <DIO_SetPinDir+0x44>
     774:	8c 85       	ldd	r24, Y+12	; 0x0c
     776:	9d 85       	ldd	r25, Y+13	; 0x0d
     778:	00 97       	sbiw	r24, 0x00	; 0
     77a:	71 f0       	breq	.+28     	; 0x798 <DIO_SetPinDir+0x5e>
     77c:	c2 c0       	rjmp	.+388    	; 0x902 <__stack+0xa3>
     77e:	2c 85       	ldd	r18, Y+12	; 0x0c
     780:	3d 85       	ldd	r19, Y+13	; 0x0d
     782:	22 30       	cpi	r18, 0x02	; 2
     784:	31 05       	cpc	r19, r1
     786:	09 f4       	brne	.+2      	; 0x78a <DIO_SetPinDir+0x50>
     788:	62 c0       	rjmp	.+196    	; 0x84e <DIO_SetPinDir+0x114>
     78a:	8c 85       	ldd	r24, Y+12	; 0x0c
     78c:	9d 85       	ldd	r25, Y+13	; 0x0d
     78e:	83 30       	cpi	r24, 0x03	; 3
     790:	91 05       	cpc	r25, r1
     792:	09 f4       	brne	.+2      	; 0x796 <DIO_SetPinDir+0x5c>
     794:	89 c0       	rjmp	.+274    	; 0x8a8 <__stack+0x49>
     796:	b5 c0       	rjmp	.+362    	; 0x902 <__stack+0xa3>
	{
		case DIO_PORTA:
		(dir == OUTPUT)? (SET_BIT(DDRA,pin)):(CLR_BIT(DDRA,pin));
     798:	8b 81       	ldd	r24, Y+3	; 0x03
     79a:	83 30       	cpi	r24, 0x03	; 3
     79c:	a9 f4       	brne	.+42     	; 0x7c8 <DIO_SetPinDir+0x8e>
     79e:	aa e3       	ldi	r26, 0x3A	; 58
     7a0:	b0 e0       	ldi	r27, 0x00	; 0
     7a2:	ea e3       	ldi	r30, 0x3A	; 58
     7a4:	f0 e0       	ldi	r31, 0x00	; 0
     7a6:	80 81       	ld	r24, Z
     7a8:	48 2f       	mov	r20, r24
     7aa:	8a 81       	ldd	r24, Y+2	; 0x02
     7ac:	28 2f       	mov	r18, r24
     7ae:	30 e0       	ldi	r19, 0x00	; 0
     7b0:	81 e0       	ldi	r24, 0x01	; 1
     7b2:	90 e0       	ldi	r25, 0x00	; 0
     7b4:	02 2e       	mov	r0, r18
     7b6:	02 c0       	rjmp	.+4      	; 0x7bc <DIO_SetPinDir+0x82>
     7b8:	88 0f       	add	r24, r24
     7ba:	99 1f       	adc	r25, r25
     7bc:	0a 94       	dec	r0
     7be:	e2 f7       	brpl	.-8      	; 0x7b8 <DIO_SetPinDir+0x7e>
     7c0:	84 2b       	or	r24, r20
     7c2:	8c 93       	st	X, r24
     7c4:	9c 91       	ld	r25, X
     7c6:	9d c0       	rjmp	.+314    	; 0x902 <__stack+0xa3>
     7c8:	aa e3       	ldi	r26, 0x3A	; 58
     7ca:	b0 e0       	ldi	r27, 0x00	; 0
     7cc:	ea e3       	ldi	r30, 0x3A	; 58
     7ce:	f0 e0       	ldi	r31, 0x00	; 0
     7d0:	80 81       	ld	r24, Z
     7d2:	48 2f       	mov	r20, r24
     7d4:	8a 81       	ldd	r24, Y+2	; 0x02
     7d6:	28 2f       	mov	r18, r24
     7d8:	30 e0       	ldi	r19, 0x00	; 0
     7da:	81 e0       	ldi	r24, 0x01	; 1
     7dc:	90 e0       	ldi	r25, 0x00	; 0
     7de:	02 c0       	rjmp	.+4      	; 0x7e4 <DIO_SetPinDir+0xaa>
     7e0:	88 0f       	add	r24, r24
     7e2:	99 1f       	adc	r25, r25
     7e4:	2a 95       	dec	r18
     7e6:	e2 f7       	brpl	.-8      	; 0x7e0 <DIO_SetPinDir+0xa6>
     7e8:	80 95       	com	r24
     7ea:	84 23       	and	r24, r20
     7ec:	8c 93       	st	X, r24
     7ee:	2c 91       	ld	r18, X
     7f0:	88 c0       	rjmp	.+272    	; 0x902 <__stack+0xa3>
		break;

		case DIO_PORTB:
		(dir == OUTPUT)? (SET_BIT(DDRB,pin)):(CLR_BIT(DDRB,pin));
     7f2:	8b 81       	ldd	r24, Y+3	; 0x03
     7f4:	83 30       	cpi	r24, 0x03	; 3
     7f6:	a9 f4       	brne	.+42     	; 0x822 <DIO_SetPinDir+0xe8>
     7f8:	a7 e3       	ldi	r26, 0x37	; 55
     7fa:	b0 e0       	ldi	r27, 0x00	; 0
     7fc:	e7 e3       	ldi	r30, 0x37	; 55
     7fe:	f0 e0       	ldi	r31, 0x00	; 0
     800:	80 81       	ld	r24, Z
     802:	48 2f       	mov	r20, r24
     804:	8a 81       	ldd	r24, Y+2	; 0x02
     806:	28 2f       	mov	r18, r24
     808:	30 e0       	ldi	r19, 0x00	; 0
     80a:	81 e0       	ldi	r24, 0x01	; 1
     80c:	90 e0       	ldi	r25, 0x00	; 0
     80e:	02 2e       	mov	r0, r18
     810:	02 c0       	rjmp	.+4      	; 0x816 <DIO_SetPinDir+0xdc>
     812:	88 0f       	add	r24, r24
     814:	99 1f       	adc	r25, r25
     816:	0a 94       	dec	r0
     818:	e2 f7       	brpl	.-8      	; 0x812 <DIO_SetPinDir+0xd8>
     81a:	84 2b       	or	r24, r20
     81c:	8c 93       	st	X, r24
     81e:	3c 91       	ld	r19, X
     820:	70 c0       	rjmp	.+224    	; 0x902 <__stack+0xa3>
     822:	a7 e3       	ldi	r26, 0x37	; 55
     824:	b0 e0       	ldi	r27, 0x00	; 0
     826:	e7 e3       	ldi	r30, 0x37	; 55
     828:	f0 e0       	ldi	r31, 0x00	; 0
     82a:	80 81       	ld	r24, Z
     82c:	48 2f       	mov	r20, r24
     82e:	8a 81       	ldd	r24, Y+2	; 0x02
     830:	28 2f       	mov	r18, r24
     832:	30 e0       	ldi	r19, 0x00	; 0
     834:	81 e0       	ldi	r24, 0x01	; 1
     836:	90 e0       	ldi	r25, 0x00	; 0
     838:	02 2e       	mov	r0, r18
     83a:	02 c0       	rjmp	.+4      	; 0x840 <DIO_SetPinDir+0x106>
     83c:	88 0f       	add	r24, r24
     83e:	99 1f       	adc	r25, r25
     840:	0a 94       	dec	r0
     842:	e2 f7       	brpl	.-8      	; 0x83c <DIO_SetPinDir+0x102>
     844:	80 95       	com	r24
     846:	84 23       	and	r24, r20
     848:	8c 93       	st	X, r24
     84a:	8c 91       	ld	r24, X
     84c:	5a c0       	rjmp	.+180    	; 0x902 <__stack+0xa3>
		break;

		case DIO_PORTC:
		(dir == OUTPUT)? (SET_BIT(DDRC,pin)):(CLR_BIT(DDRC,pin));
     84e:	8b 81       	ldd	r24, Y+3	; 0x03
     850:	83 30       	cpi	r24, 0x03	; 3
     852:	a9 f4       	brne	.+42     	; 0x87e <__stack+0x1f>
     854:	a4 e3       	ldi	r26, 0x34	; 52
     856:	b0 e0       	ldi	r27, 0x00	; 0
     858:	e4 e3       	ldi	r30, 0x34	; 52
     85a:	f0 e0       	ldi	r31, 0x00	; 0
     85c:	80 81       	ld	r24, Z
     85e:	48 2f       	mov	r20, r24
     860:	8a 81       	ldd	r24, Y+2	; 0x02
     862:	28 2f       	mov	r18, r24
     864:	30 e0       	ldi	r19, 0x00	; 0
     866:	81 e0       	ldi	r24, 0x01	; 1
     868:	90 e0       	ldi	r25, 0x00	; 0
     86a:	02 2e       	mov	r0, r18
     86c:	02 c0       	rjmp	.+4      	; 0x872 <__stack+0x13>
     86e:	88 0f       	add	r24, r24
     870:	99 1f       	adc	r25, r25
     872:	0a 94       	dec	r0
     874:	e2 f7       	brpl	.-8      	; 0x86e <__stack+0xf>
     876:	84 2b       	or	r24, r20
     878:	8c 93       	st	X, r24
     87a:	9c 91       	ld	r25, X
     87c:	42 c0       	rjmp	.+132    	; 0x902 <__stack+0xa3>
     87e:	a4 e3       	ldi	r26, 0x34	; 52
     880:	b0 e0       	ldi	r27, 0x00	; 0
     882:	e4 e3       	ldi	r30, 0x34	; 52
     884:	f0 e0       	ldi	r31, 0x00	; 0
     886:	80 81       	ld	r24, Z
     888:	48 2f       	mov	r20, r24
     88a:	8a 81       	ldd	r24, Y+2	; 0x02
     88c:	28 2f       	mov	r18, r24
     88e:	30 e0       	ldi	r19, 0x00	; 0
     890:	81 e0       	ldi	r24, 0x01	; 1
     892:	90 e0       	ldi	r25, 0x00	; 0
     894:	02 c0       	rjmp	.+4      	; 0x89a <__stack+0x3b>
     896:	88 0f       	add	r24, r24
     898:	99 1f       	adc	r25, r25
     89a:	2a 95       	dec	r18
     89c:	e2 f7       	brpl	.-8      	; 0x896 <__stack+0x37>
     89e:	80 95       	com	r24
     8a0:	84 23       	and	r24, r20
     8a2:	8c 93       	st	X, r24
     8a4:	2c 91       	ld	r18, X
     8a6:	2d c0       	rjmp	.+90     	; 0x902 <__stack+0xa3>
		break;

		case DIO_PORTD:
		(dir == OUTPUT)? (SET_BIT(DDRD,pin)):(CLR_BIT(DDRD,pin));
     8a8:	8b 81       	ldd	r24, Y+3	; 0x03
     8aa:	83 30       	cpi	r24, 0x03	; 3
     8ac:	a9 f4       	brne	.+42     	; 0x8d8 <__stack+0x79>
     8ae:	a1 e3       	ldi	r26, 0x31	; 49
     8b0:	b0 e0       	ldi	r27, 0x00	; 0
     8b2:	e1 e3       	ldi	r30, 0x31	; 49
     8b4:	f0 e0       	ldi	r31, 0x00	; 0
     8b6:	80 81       	ld	r24, Z
     8b8:	48 2f       	mov	r20, r24
     8ba:	8a 81       	ldd	r24, Y+2	; 0x02
     8bc:	28 2f       	mov	r18, r24
     8be:	30 e0       	ldi	r19, 0x00	; 0
     8c0:	81 e0       	ldi	r24, 0x01	; 1
     8c2:	90 e0       	ldi	r25, 0x00	; 0
     8c4:	02 2e       	mov	r0, r18
     8c6:	02 c0       	rjmp	.+4      	; 0x8cc <__stack+0x6d>
     8c8:	88 0f       	add	r24, r24
     8ca:	99 1f       	adc	r25, r25
     8cc:	0a 94       	dec	r0
     8ce:	e2 f7       	brpl	.-8      	; 0x8c8 <__stack+0x69>
     8d0:	84 2b       	or	r24, r20
     8d2:	8c 93       	st	X, r24
     8d4:	3c 91       	ld	r19, X
     8d6:	15 c0       	rjmp	.+42     	; 0x902 <__stack+0xa3>
     8d8:	a1 e3       	ldi	r26, 0x31	; 49
     8da:	b0 e0       	ldi	r27, 0x00	; 0
     8dc:	e1 e3       	ldi	r30, 0x31	; 49
     8de:	f0 e0       	ldi	r31, 0x00	; 0
     8e0:	80 81       	ld	r24, Z
     8e2:	48 2f       	mov	r20, r24
     8e4:	8a 81       	ldd	r24, Y+2	; 0x02
     8e6:	28 2f       	mov	r18, r24
     8e8:	30 e0       	ldi	r19, 0x00	; 0
     8ea:	81 e0       	ldi	r24, 0x01	; 1
     8ec:	90 e0       	ldi	r25, 0x00	; 0
     8ee:	02 2e       	mov	r0, r18
     8f0:	02 c0       	rjmp	.+4      	; 0x8f6 <__stack+0x97>
     8f2:	88 0f       	add	r24, r24
     8f4:	99 1f       	adc	r25, r25
     8f6:	0a 94       	dec	r0
     8f8:	e2 f7       	brpl	.-8      	; 0x8f2 <__stack+0x93>
     8fa:	80 95       	com	r24
     8fc:	84 23       	and	r24, r20
     8fe:	8c 93       	st	X, r24
     900:	8c 91       	ld	r24, X
		break;
	}
}
     902:	2d 96       	adiw	r28, 0x0d	; 13
     904:	0f b6       	in	r0, 0x3f	; 63
     906:	f8 94       	cli
     908:	de bf       	out	0x3e, r29	; 62
     90a:	0f be       	out	0x3f, r0	; 63
     90c:	cd bf       	out	0x3d, r28	; 61
     90e:	cf 91       	pop	r28
     910:	df 91       	pop	r29
     912:	08 95       	ret

00000914 <DIO_SetPinVal>:


void DIO_SetPinVal(uint8_t port ,uint8_t pin , uint8_t val)
{
     914:	df 93       	push	r29
     916:	cf 93       	push	r28
     918:	cd b7       	in	r28, 0x3d	; 61
     91a:	de b7       	in	r29, 0x3e	; 62
     91c:	2d 97       	sbiw	r28, 0x0d	; 13
     91e:	0f b6       	in	r0, 0x3f	; 63
     920:	f8 94       	cli
     922:	de bf       	out	0x3e, r29	; 62
     924:	0f be       	out	0x3f, r0	; 63
     926:	cd bf       	out	0x3d, r28	; 61
     928:	89 83       	std	Y+1, r24	; 0x01
     92a:	6a 83       	std	Y+2, r22	; 0x02
     92c:	4b 83       	std	Y+3, r20	; 0x03
	switch (port)
     92e:	89 81       	ldd	r24, Y+1	; 0x01
     930:	28 2f       	mov	r18, r24
     932:	30 e0       	ldi	r19, 0x00	; 0
     934:	3d 87       	std	Y+13, r19	; 0x0d
     936:	2c 87       	std	Y+12, r18	; 0x0c
     938:	8c 85       	ldd	r24, Y+12	; 0x0c
     93a:	9d 85       	ldd	r25, Y+13	; 0x0d
     93c:	81 30       	cpi	r24, 0x01	; 1
     93e:	91 05       	cpc	r25, r1
     940:	09 f4       	brne	.+2      	; 0x944 <DIO_SetPinVal+0x30>
     942:	44 c0       	rjmp	.+136    	; 0x9cc <DIO_SetPinVal+0xb8>
     944:	2c 85       	ldd	r18, Y+12	; 0x0c
     946:	3d 85       	ldd	r19, Y+13	; 0x0d
     948:	22 30       	cpi	r18, 0x02	; 2
     94a:	31 05       	cpc	r19, r1
     94c:	2c f4       	brge	.+10     	; 0x958 <DIO_SetPinVal+0x44>
     94e:	8c 85       	ldd	r24, Y+12	; 0x0c
     950:	9d 85       	ldd	r25, Y+13	; 0x0d
     952:	00 97       	sbiw	r24, 0x00	; 0
     954:	71 f0       	breq	.+28     	; 0x972 <DIO_SetPinVal+0x5e>
     956:	c2 c0       	rjmp	.+388    	; 0xadc <DIO_SetPinVal+0x1c8>
     958:	2c 85       	ldd	r18, Y+12	; 0x0c
     95a:	3d 85       	ldd	r19, Y+13	; 0x0d
     95c:	22 30       	cpi	r18, 0x02	; 2
     95e:	31 05       	cpc	r19, r1
     960:	09 f4       	brne	.+2      	; 0x964 <DIO_SetPinVal+0x50>
     962:	62 c0       	rjmp	.+196    	; 0xa28 <DIO_SetPinVal+0x114>
     964:	8c 85       	ldd	r24, Y+12	; 0x0c
     966:	9d 85       	ldd	r25, Y+13	; 0x0d
     968:	83 30       	cpi	r24, 0x03	; 3
     96a:	91 05       	cpc	r25, r1
     96c:	09 f4       	brne	.+2      	; 0x970 <DIO_SetPinVal+0x5c>
     96e:	89 c0       	rjmp	.+274    	; 0xa82 <DIO_SetPinVal+0x16e>
     970:	b5 c0       	rjmp	.+362    	; 0xadc <DIO_SetPinVal+0x1c8>
	{
		case DIO_PORTA:
		(val == HIGH)? (SET_BIT(PORTA,pin)):(CLR_BIT(PORTA,pin));
     972:	8b 81       	ldd	r24, Y+3	; 0x03
     974:	81 30       	cpi	r24, 0x01	; 1
     976:	a9 f4       	brne	.+42     	; 0x9a2 <DIO_SetPinVal+0x8e>
     978:	ab e3       	ldi	r26, 0x3B	; 59
     97a:	b0 e0       	ldi	r27, 0x00	; 0
     97c:	eb e3       	ldi	r30, 0x3B	; 59
     97e:	f0 e0       	ldi	r31, 0x00	; 0
     980:	80 81       	ld	r24, Z
     982:	48 2f       	mov	r20, r24
     984:	8a 81       	ldd	r24, Y+2	; 0x02
     986:	28 2f       	mov	r18, r24
     988:	30 e0       	ldi	r19, 0x00	; 0
     98a:	81 e0       	ldi	r24, 0x01	; 1
     98c:	90 e0       	ldi	r25, 0x00	; 0
     98e:	02 2e       	mov	r0, r18
     990:	02 c0       	rjmp	.+4      	; 0x996 <DIO_SetPinVal+0x82>
     992:	88 0f       	add	r24, r24
     994:	99 1f       	adc	r25, r25
     996:	0a 94       	dec	r0
     998:	e2 f7       	brpl	.-8      	; 0x992 <DIO_SetPinVal+0x7e>
     99a:	84 2b       	or	r24, r20
     99c:	8c 93       	st	X, r24
     99e:	9c 91       	ld	r25, X
     9a0:	9d c0       	rjmp	.+314    	; 0xadc <DIO_SetPinVal+0x1c8>
     9a2:	ab e3       	ldi	r26, 0x3B	; 59
     9a4:	b0 e0       	ldi	r27, 0x00	; 0
     9a6:	eb e3       	ldi	r30, 0x3B	; 59
     9a8:	f0 e0       	ldi	r31, 0x00	; 0
     9aa:	80 81       	ld	r24, Z
     9ac:	48 2f       	mov	r20, r24
     9ae:	8a 81       	ldd	r24, Y+2	; 0x02
     9b0:	28 2f       	mov	r18, r24
     9b2:	30 e0       	ldi	r19, 0x00	; 0
     9b4:	81 e0       	ldi	r24, 0x01	; 1
     9b6:	90 e0       	ldi	r25, 0x00	; 0
     9b8:	02 c0       	rjmp	.+4      	; 0x9be <DIO_SetPinVal+0xaa>
     9ba:	88 0f       	add	r24, r24
     9bc:	99 1f       	adc	r25, r25
     9be:	2a 95       	dec	r18
     9c0:	e2 f7       	brpl	.-8      	; 0x9ba <DIO_SetPinVal+0xa6>
     9c2:	80 95       	com	r24
     9c4:	84 23       	and	r24, r20
     9c6:	8c 93       	st	X, r24
     9c8:	2c 91       	ld	r18, X
     9ca:	88 c0       	rjmp	.+272    	; 0xadc <DIO_SetPinVal+0x1c8>
		break;

		case DIO_PORTB:
		(val == HIGH)? (SET_BIT(PORTB,pin)):(CLR_BIT(PORTB,pin));
     9cc:	8b 81       	ldd	r24, Y+3	; 0x03
     9ce:	81 30       	cpi	r24, 0x01	; 1
     9d0:	a9 f4       	brne	.+42     	; 0x9fc <DIO_SetPinVal+0xe8>
     9d2:	a8 e3       	ldi	r26, 0x38	; 56
     9d4:	b0 e0       	ldi	r27, 0x00	; 0
     9d6:	e8 e3       	ldi	r30, 0x38	; 56
     9d8:	f0 e0       	ldi	r31, 0x00	; 0
     9da:	80 81       	ld	r24, Z
     9dc:	48 2f       	mov	r20, r24
     9de:	8a 81       	ldd	r24, Y+2	; 0x02
     9e0:	28 2f       	mov	r18, r24
     9e2:	30 e0       	ldi	r19, 0x00	; 0
     9e4:	81 e0       	ldi	r24, 0x01	; 1
     9e6:	90 e0       	ldi	r25, 0x00	; 0
     9e8:	02 2e       	mov	r0, r18
     9ea:	02 c0       	rjmp	.+4      	; 0x9f0 <DIO_SetPinVal+0xdc>
     9ec:	88 0f       	add	r24, r24
     9ee:	99 1f       	adc	r25, r25
     9f0:	0a 94       	dec	r0
     9f2:	e2 f7       	brpl	.-8      	; 0x9ec <DIO_SetPinVal+0xd8>
     9f4:	84 2b       	or	r24, r20
     9f6:	8c 93       	st	X, r24
     9f8:	3c 91       	ld	r19, X
     9fa:	70 c0       	rjmp	.+224    	; 0xadc <DIO_SetPinVal+0x1c8>
     9fc:	a8 e3       	ldi	r26, 0x38	; 56
     9fe:	b0 e0       	ldi	r27, 0x00	; 0
     a00:	e8 e3       	ldi	r30, 0x38	; 56
     a02:	f0 e0       	ldi	r31, 0x00	; 0
     a04:	80 81       	ld	r24, Z
     a06:	48 2f       	mov	r20, r24
     a08:	8a 81       	ldd	r24, Y+2	; 0x02
     a0a:	28 2f       	mov	r18, r24
     a0c:	30 e0       	ldi	r19, 0x00	; 0
     a0e:	81 e0       	ldi	r24, 0x01	; 1
     a10:	90 e0       	ldi	r25, 0x00	; 0
     a12:	02 2e       	mov	r0, r18
     a14:	02 c0       	rjmp	.+4      	; 0xa1a <DIO_SetPinVal+0x106>
     a16:	88 0f       	add	r24, r24
     a18:	99 1f       	adc	r25, r25
     a1a:	0a 94       	dec	r0
     a1c:	e2 f7       	brpl	.-8      	; 0xa16 <DIO_SetPinVal+0x102>
     a1e:	80 95       	com	r24
     a20:	84 23       	and	r24, r20
     a22:	8c 93       	st	X, r24
     a24:	8c 91       	ld	r24, X
     a26:	5a c0       	rjmp	.+180    	; 0xadc <DIO_SetPinVal+0x1c8>
		break;

		case DIO_PORTC:
		(val == HIGH)? (SET_BIT(PORTC,pin)):(CLR_BIT(PORTC,pin));
     a28:	8b 81       	ldd	r24, Y+3	; 0x03
     a2a:	81 30       	cpi	r24, 0x01	; 1
     a2c:	a9 f4       	brne	.+42     	; 0xa58 <DIO_SetPinVal+0x144>
     a2e:	a5 e3       	ldi	r26, 0x35	; 53
     a30:	b0 e0       	ldi	r27, 0x00	; 0
     a32:	e5 e3       	ldi	r30, 0x35	; 53
     a34:	f0 e0       	ldi	r31, 0x00	; 0
     a36:	80 81       	ld	r24, Z
     a38:	48 2f       	mov	r20, r24
     a3a:	8a 81       	ldd	r24, Y+2	; 0x02
     a3c:	28 2f       	mov	r18, r24
     a3e:	30 e0       	ldi	r19, 0x00	; 0
     a40:	81 e0       	ldi	r24, 0x01	; 1
     a42:	90 e0       	ldi	r25, 0x00	; 0
     a44:	02 2e       	mov	r0, r18
     a46:	02 c0       	rjmp	.+4      	; 0xa4c <DIO_SetPinVal+0x138>
     a48:	88 0f       	add	r24, r24
     a4a:	99 1f       	adc	r25, r25
     a4c:	0a 94       	dec	r0
     a4e:	e2 f7       	brpl	.-8      	; 0xa48 <DIO_SetPinVal+0x134>
     a50:	84 2b       	or	r24, r20
     a52:	8c 93       	st	X, r24
     a54:	9c 91       	ld	r25, X
     a56:	42 c0       	rjmp	.+132    	; 0xadc <DIO_SetPinVal+0x1c8>
     a58:	a5 e3       	ldi	r26, 0x35	; 53
     a5a:	b0 e0       	ldi	r27, 0x00	; 0
     a5c:	e5 e3       	ldi	r30, 0x35	; 53
     a5e:	f0 e0       	ldi	r31, 0x00	; 0
     a60:	80 81       	ld	r24, Z
     a62:	48 2f       	mov	r20, r24
     a64:	8a 81       	ldd	r24, Y+2	; 0x02
     a66:	28 2f       	mov	r18, r24
     a68:	30 e0       	ldi	r19, 0x00	; 0
     a6a:	81 e0       	ldi	r24, 0x01	; 1
     a6c:	90 e0       	ldi	r25, 0x00	; 0
     a6e:	02 c0       	rjmp	.+4      	; 0xa74 <DIO_SetPinVal+0x160>
     a70:	88 0f       	add	r24, r24
     a72:	99 1f       	adc	r25, r25
     a74:	2a 95       	dec	r18
     a76:	e2 f7       	brpl	.-8      	; 0xa70 <DIO_SetPinVal+0x15c>
     a78:	80 95       	com	r24
     a7a:	84 23       	and	r24, r20
     a7c:	8c 93       	st	X, r24
     a7e:	2c 91       	ld	r18, X
     a80:	2d c0       	rjmp	.+90     	; 0xadc <DIO_SetPinVal+0x1c8>
		break;

		case DIO_PORTD:
		(val == HIGH)? (SET_BIT(PORTD,pin)):(CLR_BIT(PORTD,pin));
     a82:	8b 81       	ldd	r24, Y+3	; 0x03
     a84:	81 30       	cpi	r24, 0x01	; 1
     a86:	a9 f4       	brne	.+42     	; 0xab2 <DIO_SetPinVal+0x19e>
     a88:	a2 e3       	ldi	r26, 0x32	; 50
     a8a:	b0 e0       	ldi	r27, 0x00	; 0
     a8c:	e2 e3       	ldi	r30, 0x32	; 50
     a8e:	f0 e0       	ldi	r31, 0x00	; 0
     a90:	80 81       	ld	r24, Z
     a92:	48 2f       	mov	r20, r24
     a94:	8a 81       	ldd	r24, Y+2	; 0x02
     a96:	28 2f       	mov	r18, r24
     a98:	30 e0       	ldi	r19, 0x00	; 0
     a9a:	81 e0       	ldi	r24, 0x01	; 1
     a9c:	90 e0       	ldi	r25, 0x00	; 0
     a9e:	02 2e       	mov	r0, r18
     aa0:	02 c0       	rjmp	.+4      	; 0xaa6 <DIO_SetPinVal+0x192>
     aa2:	88 0f       	add	r24, r24
     aa4:	99 1f       	adc	r25, r25
     aa6:	0a 94       	dec	r0
     aa8:	e2 f7       	brpl	.-8      	; 0xaa2 <DIO_SetPinVal+0x18e>
     aaa:	84 2b       	or	r24, r20
     aac:	8c 93       	st	X, r24
     aae:	3c 91       	ld	r19, X
     ab0:	15 c0       	rjmp	.+42     	; 0xadc <DIO_SetPinVal+0x1c8>
     ab2:	a2 e3       	ldi	r26, 0x32	; 50
     ab4:	b0 e0       	ldi	r27, 0x00	; 0
     ab6:	e2 e3       	ldi	r30, 0x32	; 50
     ab8:	f0 e0       	ldi	r31, 0x00	; 0
     aba:	80 81       	ld	r24, Z
     abc:	48 2f       	mov	r20, r24
     abe:	8a 81       	ldd	r24, Y+2	; 0x02
     ac0:	28 2f       	mov	r18, r24
     ac2:	30 e0       	ldi	r19, 0x00	; 0
     ac4:	81 e0       	ldi	r24, 0x01	; 1
     ac6:	90 e0       	ldi	r25, 0x00	; 0
     ac8:	02 2e       	mov	r0, r18
     aca:	02 c0       	rjmp	.+4      	; 0xad0 <DIO_SetPinVal+0x1bc>
     acc:	88 0f       	add	r24, r24
     ace:	99 1f       	adc	r25, r25
     ad0:	0a 94       	dec	r0
     ad2:	e2 f7       	brpl	.-8      	; 0xacc <DIO_SetPinVal+0x1b8>
     ad4:	80 95       	com	r24
     ad6:	84 23       	and	r24, r20
     ad8:	8c 93       	st	X, r24
     ada:	8c 91       	ld	r24, X
		break;
	}
}
     adc:	2d 96       	adiw	r28, 0x0d	; 13
     ade:	0f b6       	in	r0, 0x3f	; 63
     ae0:	f8 94       	cli
     ae2:	de bf       	out	0x3e, r29	; 62
     ae4:	0f be       	out	0x3f, r0	; 63
     ae6:	cd bf       	out	0x3d, r28	; 61
     ae8:	cf 91       	pop	r28
     aea:	df 91       	pop	r29
     aec:	08 95       	ret

00000aee <DIO_GetPinVal>:


uint8_t  DIO_GetPinVal(uint8_t port ,uint8_t pin)
{
     aee:	df 93       	push	r29
     af0:	cf 93       	push	r28
     af2:	00 d0       	rcall	.+0      	; 0xaf4 <DIO_GetPinVal+0x6>
     af4:	00 d0       	rcall	.+0      	; 0xaf6 <DIO_GetPinVal+0x8>
     af6:	00 d0       	rcall	.+0      	; 0xaf8 <DIO_GetPinVal+0xa>
     af8:	cd b7       	in	r28, 0x3d	; 61
     afa:	de b7       	in	r29, 0x3e	; 62
     afc:	89 83       	std	Y+1, r24	; 0x01
     afe:	6a 83       	std	Y+2, r22	; 0x02
	switch(port)
     b00:	89 81       	ldd	r24, Y+1	; 0x01
     b02:	28 2f       	mov	r18, r24
     b04:	30 e0       	ldi	r19, 0x00	; 0
     b06:	3d 83       	std	Y+5, r19	; 0x05
     b08:	2c 83       	std	Y+4, r18	; 0x04
     b0a:	4c 81       	ldd	r20, Y+4	; 0x04
     b0c:	5d 81       	ldd	r21, Y+5	; 0x05
     b0e:	41 30       	cpi	r20, 0x01	; 1
     b10:	51 05       	cpc	r21, r1
     b12:	49 f1       	breq	.+82     	; 0xb66 <DIO_GetPinVal+0x78>
     b14:	8c 81       	ldd	r24, Y+4	; 0x04
     b16:	9d 81       	ldd	r25, Y+5	; 0x05
     b18:	82 30       	cpi	r24, 0x02	; 2
     b1a:	91 05       	cpc	r25, r1
     b1c:	34 f4       	brge	.+12     	; 0xb2a <DIO_GetPinVal+0x3c>
     b1e:	2c 81       	ldd	r18, Y+4	; 0x04
     b20:	3d 81       	ldd	r19, Y+5	; 0x05
     b22:	21 15       	cp	r18, r1
     b24:	31 05       	cpc	r19, r1
     b26:	61 f0       	breq	.+24     	; 0xb40 <DIO_GetPinVal+0x52>
     b28:	57 c0       	rjmp	.+174    	; 0xbd8 <DIO_GetPinVal+0xea>
     b2a:	4c 81       	ldd	r20, Y+4	; 0x04
     b2c:	5d 81       	ldd	r21, Y+5	; 0x05
     b2e:	42 30       	cpi	r20, 0x02	; 2
     b30:	51 05       	cpc	r21, r1
     b32:	61 f1       	breq	.+88     	; 0xb8c <DIO_GetPinVal+0x9e>
     b34:	8c 81       	ldd	r24, Y+4	; 0x04
     b36:	9d 81       	ldd	r25, Y+5	; 0x05
     b38:	83 30       	cpi	r24, 0x03	; 3
     b3a:	91 05       	cpc	r25, r1
     b3c:	d1 f1       	breq	.+116    	; 0xbb2 <DIO_GetPinVal+0xc4>
     b3e:	4c c0       	rjmp	.+152    	; 0xbd8 <DIO_GetPinVal+0xea>
	{
		case  DIO_PORTA :
			return GET_BIT(PINA,pin);
     b40:	e9 e3       	ldi	r30, 0x39	; 57
     b42:	f0 e0       	ldi	r31, 0x00	; 0
     b44:	80 81       	ld	r24, Z
     b46:	28 2f       	mov	r18, r24
     b48:	30 e0       	ldi	r19, 0x00	; 0
     b4a:	8a 81       	ldd	r24, Y+2	; 0x02
     b4c:	88 2f       	mov	r24, r24
     b4e:	90 e0       	ldi	r25, 0x00	; 0
     b50:	a9 01       	movw	r20, r18
     b52:	02 c0       	rjmp	.+4      	; 0xb58 <DIO_GetPinVal+0x6a>
     b54:	55 95       	asr	r21
     b56:	47 95       	ror	r20
     b58:	8a 95       	dec	r24
     b5a:	e2 f7       	brpl	.-8      	; 0xb54 <DIO_GetPinVal+0x66>
     b5c:	ca 01       	movw	r24, r20
     b5e:	58 2f       	mov	r21, r24
     b60:	51 70       	andi	r21, 0x01	; 1
     b62:	5b 83       	std	Y+3, r21	; 0x03
     b64:	3a c0       	rjmp	.+116    	; 0xbda <DIO_GetPinVal+0xec>
			break;
		case  DIO_PORTB :
			return GET_BIT(PINB,pin);
     b66:	e6 e3       	ldi	r30, 0x36	; 54
     b68:	f0 e0       	ldi	r31, 0x00	; 0
     b6a:	80 81       	ld	r24, Z
     b6c:	28 2f       	mov	r18, r24
     b6e:	30 e0       	ldi	r19, 0x00	; 0
     b70:	8a 81       	ldd	r24, Y+2	; 0x02
     b72:	88 2f       	mov	r24, r24
     b74:	90 e0       	ldi	r25, 0x00	; 0
     b76:	a9 01       	movw	r20, r18
     b78:	02 c0       	rjmp	.+4      	; 0xb7e <DIO_GetPinVal+0x90>
     b7a:	55 95       	asr	r21
     b7c:	47 95       	ror	r20
     b7e:	8a 95       	dec	r24
     b80:	e2 f7       	brpl	.-8      	; 0xb7a <DIO_GetPinVal+0x8c>
     b82:	ca 01       	movw	r24, r20
     b84:	58 2f       	mov	r21, r24
     b86:	51 70       	andi	r21, 0x01	; 1
     b88:	5b 83       	std	Y+3, r21	; 0x03
     b8a:	27 c0       	rjmp	.+78     	; 0xbda <DIO_GetPinVal+0xec>
			break;
		case  DIO_PORTC :
			return GET_BIT(PINC,pin);
     b8c:	e3 e3       	ldi	r30, 0x33	; 51
     b8e:	f0 e0       	ldi	r31, 0x00	; 0
     b90:	80 81       	ld	r24, Z
     b92:	28 2f       	mov	r18, r24
     b94:	30 e0       	ldi	r19, 0x00	; 0
     b96:	8a 81       	ldd	r24, Y+2	; 0x02
     b98:	88 2f       	mov	r24, r24
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	a9 01       	movw	r20, r18
     b9e:	02 c0       	rjmp	.+4      	; 0xba4 <DIO_GetPinVal+0xb6>
     ba0:	55 95       	asr	r21
     ba2:	47 95       	ror	r20
     ba4:	8a 95       	dec	r24
     ba6:	e2 f7       	brpl	.-8      	; 0xba0 <DIO_GetPinVal+0xb2>
     ba8:	ca 01       	movw	r24, r20
     baa:	58 2f       	mov	r21, r24
     bac:	51 70       	andi	r21, 0x01	; 1
     bae:	5b 83       	std	Y+3, r21	; 0x03
     bb0:	14 c0       	rjmp	.+40     	; 0xbda <DIO_GetPinVal+0xec>
			break;
		case  DIO_PORTD :
			return GET_BIT(PIND,pin);
     bb2:	e0 e3       	ldi	r30, 0x30	; 48
     bb4:	f0 e0       	ldi	r31, 0x00	; 0
     bb6:	80 81       	ld	r24, Z
     bb8:	28 2f       	mov	r18, r24
     bba:	30 e0       	ldi	r19, 0x00	; 0
     bbc:	8a 81       	ldd	r24, Y+2	; 0x02
     bbe:	88 2f       	mov	r24, r24
     bc0:	90 e0       	ldi	r25, 0x00	; 0
     bc2:	a9 01       	movw	r20, r18
     bc4:	02 c0       	rjmp	.+4      	; 0xbca <DIO_GetPinVal+0xdc>
     bc6:	55 95       	asr	r21
     bc8:	47 95       	ror	r20
     bca:	8a 95       	dec	r24
     bcc:	e2 f7       	brpl	.-8      	; 0xbc6 <DIO_GetPinVal+0xd8>
     bce:	ca 01       	movw	r24, r20
     bd0:	58 2f       	mov	r21, r24
     bd2:	51 70       	andi	r21, 0x01	; 1
     bd4:	5b 83       	std	Y+3, r21	; 0x03
     bd6:	01 c0       	rjmp	.+2      	; 0xbda <DIO_GetPinVal+0xec>
     bd8:	02 c0       	rjmp	.+4      	; 0xbde <DIO_GetPinVal+0xf0>
			break;
	}
}
     bda:	8b 81       	ldd	r24, Y+3	; 0x03
     bdc:	8e 83       	std	Y+6, r24	; 0x06
     bde:	8e 81       	ldd	r24, Y+6	; 0x06
     be0:	26 96       	adiw	r28, 0x06	; 6
     be2:	0f b6       	in	r0, 0x3f	; 63
     be4:	f8 94       	cli
     be6:	de bf       	out	0x3e, r29	; 62
     be8:	0f be       	out	0x3f, r0	; 63
     bea:	cd bf       	out	0x3d, r28	; 61
     bec:	cf 91       	pop	r28
     bee:	df 91       	pop	r29
     bf0:	08 95       	ret

00000bf2 <DIO_TogPinVal>:


void  DIO_TogPinVal(uint8_t port ,uint8_t pin)
{
     bf2:	df 93       	push	r29
     bf4:	cf 93       	push	r28
     bf6:	00 d0       	rcall	.+0      	; 0xbf8 <DIO_TogPinVal+0x6>
     bf8:	00 d0       	rcall	.+0      	; 0xbfa <DIO_TogPinVal+0x8>
     bfa:	cd b7       	in	r28, 0x3d	; 61
     bfc:	de b7       	in	r29, 0x3e	; 62
     bfe:	89 83       	std	Y+1, r24	; 0x01
     c00:	6a 83       	std	Y+2, r22	; 0x02
	switch(port)
     c02:	89 81       	ldd	r24, Y+1	; 0x01
     c04:	28 2f       	mov	r18, r24
     c06:	30 e0       	ldi	r19, 0x00	; 0
     c08:	3c 83       	std	Y+4, r19	; 0x04
     c0a:	2b 83       	std	Y+3, r18	; 0x03
     c0c:	8b 81       	ldd	r24, Y+3	; 0x03
     c0e:	9c 81       	ldd	r25, Y+4	; 0x04
     c10:	81 30       	cpi	r24, 0x01	; 1
     c12:	91 05       	cpc	r25, r1
     c14:	49 f1       	breq	.+82     	; 0xc68 <DIO_TogPinVal+0x76>
     c16:	2b 81       	ldd	r18, Y+3	; 0x03
     c18:	3c 81       	ldd	r19, Y+4	; 0x04
     c1a:	22 30       	cpi	r18, 0x02	; 2
     c1c:	31 05       	cpc	r19, r1
     c1e:	2c f4       	brge	.+10     	; 0xc2a <DIO_TogPinVal+0x38>
     c20:	8b 81       	ldd	r24, Y+3	; 0x03
     c22:	9c 81       	ldd	r25, Y+4	; 0x04
     c24:	00 97       	sbiw	r24, 0x00	; 0
     c26:	61 f0       	breq	.+24     	; 0xc40 <DIO_TogPinVal+0x4e>
     c28:	5a c0       	rjmp	.+180    	; 0xcde <DIO_TogPinVal+0xec>
     c2a:	2b 81       	ldd	r18, Y+3	; 0x03
     c2c:	3c 81       	ldd	r19, Y+4	; 0x04
     c2e:	22 30       	cpi	r18, 0x02	; 2
     c30:	31 05       	cpc	r19, r1
     c32:	71 f1       	breq	.+92     	; 0xc90 <DIO_TogPinVal+0x9e>
     c34:	8b 81       	ldd	r24, Y+3	; 0x03
     c36:	9c 81       	ldd	r25, Y+4	; 0x04
     c38:	83 30       	cpi	r24, 0x03	; 3
     c3a:	91 05       	cpc	r25, r1
     c3c:	e9 f1       	breq	.+122    	; 0xcb8 <DIO_TogPinVal+0xc6>
     c3e:	4f c0       	rjmp	.+158    	; 0xcde <DIO_TogPinVal+0xec>
	{
		case  DIO_PORTA :	TOG_BIT(PORTA,pin);
     c40:	ab e3       	ldi	r26, 0x3B	; 59
     c42:	b0 e0       	ldi	r27, 0x00	; 0
     c44:	eb e3       	ldi	r30, 0x3B	; 59
     c46:	f0 e0       	ldi	r31, 0x00	; 0
     c48:	80 81       	ld	r24, Z
     c4a:	48 2f       	mov	r20, r24
     c4c:	8a 81       	ldd	r24, Y+2	; 0x02
     c4e:	28 2f       	mov	r18, r24
     c50:	30 e0       	ldi	r19, 0x00	; 0
     c52:	81 e0       	ldi	r24, 0x01	; 1
     c54:	90 e0       	ldi	r25, 0x00	; 0
     c56:	02 2e       	mov	r0, r18
     c58:	02 c0       	rjmp	.+4      	; 0xc5e <DIO_TogPinVal+0x6c>
     c5a:	88 0f       	add	r24, r24
     c5c:	99 1f       	adc	r25, r25
     c5e:	0a 94       	dec	r0
     c60:	e2 f7       	brpl	.-8      	; 0xc5a <DIO_TogPinVal+0x68>
     c62:	84 27       	eor	r24, r20
     c64:	8c 93       	st	X, r24
     c66:	3b c0       	rjmp	.+118    	; 0xcde <DIO_TogPinVal+0xec>
		break;
		case  DIO_PORTB :   TOG_BIT(PORTB,pin);
     c68:	a8 e3       	ldi	r26, 0x38	; 56
     c6a:	b0 e0       	ldi	r27, 0x00	; 0
     c6c:	e8 e3       	ldi	r30, 0x38	; 56
     c6e:	f0 e0       	ldi	r31, 0x00	; 0
     c70:	80 81       	ld	r24, Z
     c72:	48 2f       	mov	r20, r24
     c74:	8a 81       	ldd	r24, Y+2	; 0x02
     c76:	28 2f       	mov	r18, r24
     c78:	30 e0       	ldi	r19, 0x00	; 0
     c7a:	81 e0       	ldi	r24, 0x01	; 1
     c7c:	90 e0       	ldi	r25, 0x00	; 0
     c7e:	02 2e       	mov	r0, r18
     c80:	02 c0       	rjmp	.+4      	; 0xc86 <DIO_TogPinVal+0x94>
     c82:	88 0f       	add	r24, r24
     c84:	99 1f       	adc	r25, r25
     c86:	0a 94       	dec	r0
     c88:	e2 f7       	brpl	.-8      	; 0xc82 <DIO_TogPinVal+0x90>
     c8a:	84 27       	eor	r24, r20
     c8c:	8c 93       	st	X, r24
     c8e:	27 c0       	rjmp	.+78     	; 0xcde <DIO_TogPinVal+0xec>
		break;
		case  DIO_PORTC :   TOG_BIT(PORTC,pin);
     c90:	a5 e3       	ldi	r26, 0x35	; 53
     c92:	b0 e0       	ldi	r27, 0x00	; 0
     c94:	e5 e3       	ldi	r30, 0x35	; 53
     c96:	f0 e0       	ldi	r31, 0x00	; 0
     c98:	80 81       	ld	r24, Z
     c9a:	48 2f       	mov	r20, r24
     c9c:	8a 81       	ldd	r24, Y+2	; 0x02
     c9e:	28 2f       	mov	r18, r24
     ca0:	30 e0       	ldi	r19, 0x00	; 0
     ca2:	81 e0       	ldi	r24, 0x01	; 1
     ca4:	90 e0       	ldi	r25, 0x00	; 0
     ca6:	02 2e       	mov	r0, r18
     ca8:	02 c0       	rjmp	.+4      	; 0xcae <DIO_TogPinVal+0xbc>
     caa:	88 0f       	add	r24, r24
     cac:	99 1f       	adc	r25, r25
     cae:	0a 94       	dec	r0
     cb0:	e2 f7       	brpl	.-8      	; 0xcaa <DIO_TogPinVal+0xb8>
     cb2:	84 27       	eor	r24, r20
     cb4:	8c 93       	st	X, r24
     cb6:	13 c0       	rjmp	.+38     	; 0xcde <DIO_TogPinVal+0xec>
		break;
		case  DIO_PORTD :   TOG_BIT(PORTD,pin);
     cb8:	a2 e3       	ldi	r26, 0x32	; 50
     cba:	b0 e0       	ldi	r27, 0x00	; 0
     cbc:	e2 e3       	ldi	r30, 0x32	; 50
     cbe:	f0 e0       	ldi	r31, 0x00	; 0
     cc0:	80 81       	ld	r24, Z
     cc2:	48 2f       	mov	r20, r24
     cc4:	8a 81       	ldd	r24, Y+2	; 0x02
     cc6:	28 2f       	mov	r18, r24
     cc8:	30 e0       	ldi	r19, 0x00	; 0
     cca:	81 e0       	ldi	r24, 0x01	; 1
     ccc:	90 e0       	ldi	r25, 0x00	; 0
     cce:	02 2e       	mov	r0, r18
     cd0:	02 c0       	rjmp	.+4      	; 0xcd6 <DIO_TogPinVal+0xe4>
     cd2:	88 0f       	add	r24, r24
     cd4:	99 1f       	adc	r25, r25
     cd6:	0a 94       	dec	r0
     cd8:	e2 f7       	brpl	.-8      	; 0xcd2 <DIO_TogPinVal+0xe0>
     cda:	84 27       	eor	r24, r20
     cdc:	8c 93       	st	X, r24
		break;
	}
}
     cde:	0f 90       	pop	r0
     ce0:	0f 90       	pop	r0
     ce2:	0f 90       	pop	r0
     ce4:	0f 90       	pop	r0
     ce6:	cf 91       	pop	r28
     ce8:	df 91       	pop	r29
     cea:	08 95       	ret

00000cec <PWM_INIT>:
 *  Created on: Feb 11, 2023
 *      Author: wario
 */

#include"PWM.h"
void PWM_INIT(void){
     cec:	df 93       	push	r29
     cee:	cf 93       	push	r28
     cf0:	cd b7       	in	r28, 0x3d	; 61
     cf2:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTB ,Pin3, OUTPUT);
     cf4:	81 e0       	ldi	r24, 0x01	; 1
     cf6:	63 e0       	ldi	r22, 0x03	; 3
     cf8:	43 e0       	ldi	r20, 0x03	; 3
     cfa:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	DIO_SetPinDir(DIO_PORTD ,Pin7, OUTPUT);
     cfe:	83 e0       	ldi	r24, 0x03	; 3
     d00:	67 e0       	ldi	r22, 0x07	; 7
     d02:	43 e0       	ldi	r20, 0x03	; 3
     d04:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
}
     d08:	cf 91       	pop	r28
     d0a:	df 91       	pop	r29
     d0c:	08 95       	ret

00000d0e <Start_PWM1>:
void Start_PWM1(void){
     d0e:	df 93       	push	r29
     d10:	cf 93       	push	r28
     d12:	cd b7       	in	r28, 0x3d	; 61
     d14:	de b7       	in	r29, 0x3e	; 62
	TCCR0 = (1<<WGM00) | (1<<WGM01) | (1<<COM01) | (1<<CS00);
     d16:	e3 e5       	ldi	r30, 0x53	; 83
     d18:	f0 e0       	ldi	r31, 0x00	; 0
     d1a:	89 e6       	ldi	r24, 0x69	; 105
     d1c:	80 83       	st	Z, r24
	OCR0 = 204;
     d1e:	ec e5       	ldi	r30, 0x5C	; 92
     d20:	f0 e0       	ldi	r31, 0x00	; 0
     d22:	8c ec       	ldi	r24, 0xCC	; 204
     d24:	80 83       	st	Z, r24
}
     d26:	cf 91       	pop	r28
     d28:	df 91       	pop	r29
     d2a:	08 95       	ret

00000d2c <Start_PWM2>:
void Start_PWM2(void){
     d2c:	df 93       	push	r29
     d2e:	cf 93       	push	r28
     d30:	cd b7       	in	r28, 0x3d	; 61
     d32:	de b7       	in	r29, 0x3e	; 62
	TCCR2 = (1<<WGM20) | (1<<WGM21) | (1<<COM21) | (1<<CS20);
     d34:	e5 e4       	ldi	r30, 0x45	; 69
     d36:	f0 e0       	ldi	r31, 0x00	; 0
     d38:	89 e6       	ldi	r24, 0x69	; 105
     d3a:	80 83       	st	Z, r24
	OCR2 = 204;
     d3c:	e3 e4       	ldi	r30, 0x43	; 67
     d3e:	f0 e0       	ldi	r31, 0x00	; 0
     d40:	8c ec       	ldi	r24, 0xCC	; 204
     d42:	80 83       	st	Z, r24
}
     d44:	cf 91       	pop	r28
     d46:	df 91       	pop	r29
     d48:	08 95       	ret

00000d4a <Stop_PWM1>:
void Stop_PWM1(void){
     d4a:	df 93       	push	r29
     d4c:	cf 93       	push	r28
     d4e:	cd b7       	in	r28, 0x3d	; 61
     d50:	de b7       	in	r29, 0x3e	; 62
	TCCR0 &=~ (1<<COM01);
     d52:	a3 e5       	ldi	r26, 0x53	; 83
     d54:	b0 e0       	ldi	r27, 0x00	; 0
     d56:	e3 e5       	ldi	r30, 0x53	; 83
     d58:	f0 e0       	ldi	r31, 0x00	; 0
     d5a:	80 81       	ld	r24, Z
     d5c:	8f 7d       	andi	r24, 0xDF	; 223
     d5e:	8c 93       	st	X, r24
	TCCR0 &=~ (1<<CS00);
     d60:	a3 e5       	ldi	r26, 0x53	; 83
     d62:	b0 e0       	ldi	r27, 0x00	; 0
     d64:	e3 e5       	ldi	r30, 0x53	; 83
     d66:	f0 e0       	ldi	r31, 0x00	; 0
     d68:	80 81       	ld	r24, Z
     d6a:	8e 7f       	andi	r24, 0xFE	; 254
     d6c:	8c 93       	st	X, r24
}
     d6e:	cf 91       	pop	r28
     d70:	df 91       	pop	r29
     d72:	08 95       	ret

00000d74 <Stop_PWM2>:
void Stop_PWM2(void){
     d74:	df 93       	push	r29
     d76:	cf 93       	push	r28
     d78:	cd b7       	in	r28, 0x3d	; 61
     d7a:	de b7       	in	r29, 0x3e	; 62
	TCCR2 &=~ (1<<COM21);
     d7c:	a5 e4       	ldi	r26, 0x45	; 69
     d7e:	b0 e0       	ldi	r27, 0x00	; 0
     d80:	e5 e4       	ldi	r30, 0x45	; 69
     d82:	f0 e0       	ldi	r31, 0x00	; 0
     d84:	80 81       	ld	r24, Z
     d86:	8f 7d       	andi	r24, 0xDF	; 223
     d88:	8c 93       	st	X, r24
	TCCR2 &=~ (1<<CS20);
     d8a:	a5 e4       	ldi	r26, 0x45	; 69
     d8c:	b0 e0       	ldi	r27, 0x00	; 0
     d8e:	e5 e4       	ldi	r30, 0x45	; 69
     d90:	f0 e0       	ldi	r31, 0x00	; 0
     d92:	80 81       	ld	r24, Z
     d94:	8e 7f       	andi	r24, 0xFE	; 254
     d96:	8c 93       	st	X, r24
}
     d98:	cf 91       	pop	r28
     d9a:	df 91       	pop	r29
     d9c:	08 95       	ret

00000d9e <READ_IGNITON>:
 *
 *  Created on: Feb 11, 2023
 *      Author: wario
 */
#include "Btn_Handler.h"
uint8_t READ_IGNITON(void){
     d9e:	df 93       	push	r29
     da0:	cf 93       	push	r28
     da2:	0f 92       	push	r0
     da4:	cd b7       	in	r28, 0x3d	; 61
     da6:	de b7       	in	r29, 0x3e	; 62

	DIO_SetPinDir(DIO_PORTA ,Pin0, INPUT);
     da8:	80 e0       	ldi	r24, 0x00	; 0
     daa:	60 e0       	ldi	r22, 0x00	; 0
     dac:	42 e0       	ldi	r20, 0x02	; 2
     dae:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	uint8_t IGNITION_data = DIO_GetPinVal(DIO_PORTA ,Pin0) ;
     db2:	80 e0       	ldi	r24, 0x00	; 0
     db4:	60 e0       	ldi	r22, 0x00	; 0
     db6:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_GetPinVal>
     dba:	89 83       	std	Y+1, r24	; 0x01
	return IGNITION_data;
     dbc:	89 81       	ldd	r24, Y+1	; 0x01
}
     dbe:	0f 90       	pop	r0
     dc0:	cf 91       	pop	r28
     dc2:	df 91       	pop	r29
     dc4:	08 95       	ret

00000dc6 <READ_HAZARD_Button>:
uint8_t READ_HAZARD_Button(void){
     dc6:	df 93       	push	r29
     dc8:	cf 93       	push	r28
     dca:	0f 92       	push	r0
     dcc:	cd b7       	in	r28, 0x3d	; 61
     dce:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTA ,Pin1, INPUT);
     dd0:	80 e0       	ldi	r24, 0x00	; 0
     dd2:	61 e0       	ldi	r22, 0x01	; 1
     dd4:	42 e0       	ldi	r20, 0x02	; 2
     dd6:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	uint8_t HAZARD_data = DIO_GetPinVal(DIO_PORTA ,Pin1) ;
     dda:	80 e0       	ldi	r24, 0x00	; 0
     ddc:	61 e0       	ldi	r22, 0x01	; 1
     dde:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_GetPinVal>
     de2:	89 83       	std	Y+1, r24	; 0x01
	 return pressed ;
	 }else{
	 return unpressed;
	 }
	 */
	return HAZARD_data;
     de4:	89 81       	ldd	r24, Y+1	; 0x01
}
     de6:	0f 90       	pop	r0
     de8:	cf 91       	pop	r28
     dea:	df 91       	pop	r29
     dec:	08 95       	ret

00000dee <READ_RIGHT_Button>:
uint8_t READ_RIGHT_Button(void){
     dee:	df 93       	push	r29
     df0:	cf 93       	push	r28
     df2:	0f 92       	push	r0
     df4:	cd b7       	in	r28, 0x3d	; 61
     df6:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTA ,Pin2, INPUT);
     df8:	80 e0       	ldi	r24, 0x00	; 0
     dfa:	62 e0       	ldi	r22, 0x02	; 2
     dfc:	42 e0       	ldi	r20, 0x02	; 2
     dfe:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	uint8_t right_data  = DIO_GetPinVal(DIO_PORTA ,Pin2) ;
     e02:	80 e0       	ldi	r24, 0x00	; 0
     e04:	62 e0       	ldi	r22, 0x02	; 2
     e06:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_GetPinVal>
     e0a:	89 83       	std	Y+1, r24	; 0x01
	return right_data ;
     e0c:	89 81       	ldd	r24, Y+1	; 0x01
}
     e0e:	0f 90       	pop	r0
     e10:	cf 91       	pop	r28
     e12:	df 91       	pop	r29
     e14:	08 95       	ret

00000e16 <READ_LEFT_Button>:
uint8_t READ_LEFT_Button(void){
     e16:	df 93       	push	r29
     e18:	cf 93       	push	r28
     e1a:	0f 92       	push	r0
     e1c:	cd b7       	in	r28, 0x3d	; 61
     e1e:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTA ,Pin3, INPUT);
     e20:	80 e0       	ldi	r24, 0x00	; 0
     e22:	63 e0       	ldi	r22, 0x03	; 3
     e24:	42 e0       	ldi	r20, 0x02	; 2
     e26:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	uint8_t right_data  = DIO_GetPinVal(DIO_PORTA ,Pin3) ;
     e2a:	80 e0       	ldi	r24, 0x00	; 0
     e2c:	63 e0       	ldi	r22, 0x03	; 3
     e2e:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_GetPinVal>
     e32:	89 83       	std	Y+1, r24	; 0x01
	return right_data;
     e34:	89 81       	ldd	r24, Y+1	; 0x01

}
     e36:	0f 90       	pop	r0
     e38:	cf 91       	pop	r28
     e3a:	df 91       	pop	r29
     e3c:	08 95       	ret

00000e3e <vBlink_Right>:
 */

#include"LED.h"
#include"PWM.h"

void vBlink_Right(char led_mode ){
     e3e:	df 93       	push	r29
     e40:	cf 93       	push	r28
     e42:	0f 92       	push	r0
     e44:	cd b7       	in	r28, 0x3d	; 61
     e46:	de b7       	in	r29, 0x3e	; 62
     e48:	89 83       	std	Y+1, r24	; 0x01
		if(led_mode){
     e4a:	89 81       	ldd	r24, Y+1	; 0x01
     e4c:	88 23       	and	r24, r24
     e4e:	19 f0       	breq	.+6      	; 0xe56 <vBlink_Right+0x18>
			Start_PWM1();
     e50:	0e 94 87 06 	call	0xd0e	; 0xd0e <Start_PWM1>
     e54:	02 c0       	rjmp	.+4      	; 0xe5a <vBlink_Right+0x1c>
		}else{
			Stop_PWM1();
     e56:	0e 94 a5 06 	call	0xd4a	; 0xd4a <Stop_PWM1>
	}
}
     e5a:	0f 90       	pop	r0
     e5c:	cf 91       	pop	r28
     e5e:	df 91       	pop	r29
     e60:	08 95       	ret

00000e62 <Blink_LEFT>:

void Blink_LEFT(char led_mode){
     e62:	df 93       	push	r29
     e64:	cf 93       	push	r28
     e66:	0f 92       	push	r0
     e68:	cd b7       	in	r28, 0x3d	; 61
     e6a:	de b7       	in	r29, 0x3e	; 62
     e6c:	89 83       	std	Y+1, r24	; 0x01
		if(led_mode){
     e6e:	89 81       	ldd	r24, Y+1	; 0x01
     e70:	88 23       	and	r24, r24
     e72:	19 f0       	breq	.+6      	; 0xe7a <Blink_LEFT+0x18>
			Start_PWM2();
     e74:	0e 94 96 06 	call	0xd2c	; 0xd2c <Start_PWM2>
     e78:	02 c0       	rjmp	.+4      	; 0xe7e <Blink_LEFT+0x1c>
		}else{
			Stop_PWM2();
     e7a:	0e 94 ba 06 	call	0xd74	; 0xd74 <Stop_PWM2>
		}
}
     e7e:	0f 90       	pop	r0
     e80:	cf 91       	pop	r28
     e82:	df 91       	pop	r29
     e84:	08 95       	ret

00000e86 <Stop_Blinking_Right>:
void Stop_Blinking_Right(void){
     e86:	df 93       	push	r29
     e88:	cf 93       	push	r28
     e8a:	cd b7       	in	r28, 0x3d	; 61
     e8c:	de b7       	in	r29, 0x3e	; 62
	Stop_PWM1();
     e8e:	0e 94 a5 06 	call	0xd4a	; 0xd4a <Stop_PWM1>
}
     e92:	cf 91       	pop	r28
     e94:	df 91       	pop	r29
     e96:	08 95       	ret

00000e98 <Stop_Blinking_Left>:
void Stop_Blinking_Left(void){
     e98:	df 93       	push	r29
     e9a:	cf 93       	push	r28
     e9c:	cd b7       	in	r28, 0x3d	; 61
     e9e:	de b7       	in	r29, 0x3e	; 62
	Stop_PWM2();
     ea0:	0e 94 ba 06 	call	0xd74	; 0xd74 <Stop_PWM2>
}
     ea4:	cf 91       	pop	r28
     ea6:	df 91       	pop	r29
     ea8:	08 95       	ret

00000eaa <xCoRoutineCreate>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode,
                                 UBaseType_t uxPriority,
                                 UBaseType_t uxIndex )
    {
     eaa:	df 93       	push	r29
     eac:	cf 93       	push	r28
     eae:	cd b7       	in	r28, 0x3d	; 61
     eb0:	de b7       	in	r29, 0x3e	; 62
     eb2:	27 97       	sbiw	r28, 0x07	; 7
     eb4:	0f b6       	in	r0, 0x3f	; 63
     eb6:	f8 94       	cli
     eb8:	de bf       	out	0x3e, r29	; 62
     eba:	0f be       	out	0x3f, r0	; 63
     ebc:	cd bf       	out	0x3d, r28	; 61
     ebe:	9d 83       	std	Y+5, r25	; 0x05
     ec0:	8c 83       	std	Y+4, r24	; 0x04
     ec2:	6e 83       	std	Y+6, r22	; 0x06
     ec4:	4f 83       	std	Y+7, r20	; 0x07
        BaseType_t xReturn;
        CRCB_t * pxCoRoutine;

        /* Allocate the memory that will store the co-routine control block. */
        pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     ec6:	8a e1       	ldi	r24, 0x1A	; 26
     ec8:	90 e0       	ldi	r25, 0x00	; 0
     eca:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     ece:	9a 83       	std	Y+2, r25	; 0x02
     ed0:	89 83       	std	Y+1, r24	; 0x01

        if( pxCoRoutine )
     ed2:	89 81       	ldd	r24, Y+1	; 0x01
     ed4:	9a 81       	ldd	r25, Y+2	; 0x02
     ed6:	00 97       	sbiw	r24, 0x00	; 0
     ed8:	09 f4       	brne	.+2      	; 0xedc <xCoRoutineCreate+0x32>
     eda:	6f c0       	rjmp	.+222    	; 0xfba <xCoRoutineCreate+0x110>
        {
            /* If pxCurrentCoRoutine is NULL then this is the first co-routine to
            * be created and the co-routine data structures need initialising. */
            if( pxCurrentCoRoutine == NULL )
     edc:	80 91 96 06 	lds	r24, 0x0696
     ee0:	90 91 97 06 	lds	r25, 0x0697
     ee4:	00 97       	sbiw	r24, 0x00	; 0
     ee6:	41 f4       	brne	.+16     	; 0xef8 <xCoRoutineCreate+0x4e>
            {
                pxCurrentCoRoutine = pxCoRoutine;
     ee8:	89 81       	ldd	r24, Y+1	; 0x01
     eea:	9a 81       	ldd	r25, Y+2	; 0x02
     eec:	90 93 97 06 	sts	0x0697, r25
     ef0:	80 93 96 06 	sts	0x0696, r24
                prvInitialiseCoRoutineLists();
     ef4:	0e 94 c3 09 	call	0x1386	; 0x1386 <prvInitialiseCoRoutineLists>
            }

            /* Check the priority is within limits. */
            if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     ef8:	8e 81       	ldd	r24, Y+6	; 0x06
     efa:	82 30       	cpi	r24, 0x02	; 2
     efc:	10 f0       	brcs	.+4      	; 0xf02 <xCoRoutineCreate+0x58>
            {
                uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     efe:	81 e0       	ldi	r24, 0x01	; 1
     f00:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Fill out the co-routine control block from the function parameters. */
            pxCoRoutine->uxState = corINITIAL_STATE;
     f02:	e9 81       	ldd	r30, Y+1	; 0x01
     f04:	fa 81       	ldd	r31, Y+2	; 0x02
     f06:	11 8e       	std	Z+25, r1	; 0x19
     f08:	10 8e       	std	Z+24, r1	; 0x18
            pxCoRoutine->uxPriority = uxPriority;
     f0a:	e9 81       	ldd	r30, Y+1	; 0x01
     f0c:	fa 81       	ldd	r31, Y+2	; 0x02
     f0e:	8e 81       	ldd	r24, Y+6	; 0x06
     f10:	86 8b       	std	Z+22, r24	; 0x16
            pxCoRoutine->uxIndex = uxIndex;
     f12:	e9 81       	ldd	r30, Y+1	; 0x01
     f14:	fa 81       	ldd	r31, Y+2	; 0x02
     f16:	8f 81       	ldd	r24, Y+7	; 0x07
     f18:	87 8b       	std	Z+23, r24	; 0x17
            pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     f1a:	e9 81       	ldd	r30, Y+1	; 0x01
     f1c:	fa 81       	ldd	r31, Y+2	; 0x02
     f1e:	8c 81       	ldd	r24, Y+4	; 0x04
     f20:	9d 81       	ldd	r25, Y+5	; 0x05
     f22:	91 83       	std	Z+1, r25	; 0x01
     f24:	80 83       	st	Z, r24

            /* Initialise all the other co-routine control block parameters. */
            vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     f26:	89 81       	ldd	r24, Y+1	; 0x01
     f28:	9a 81       	ldd	r25, Y+2	; 0x02
     f2a:	02 96       	adiw	r24, 0x02	; 2
     f2c:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <vListInitialiseItem>
            vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     f30:	89 81       	ldd	r24, Y+1	; 0x01
     f32:	9a 81       	ldd	r25, Y+2	; 0x02
     f34:	0c 96       	adiw	r24, 0x0c	; 12
     f36:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <vListInitialiseItem>

            /* Set the co-routine control block as a link back from the ListItem_t.
             * This is so we can get back to the containing CRCB from a generic item
             * in a list. */
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     f3a:	e9 81       	ldd	r30, Y+1	; 0x01
     f3c:	fa 81       	ldd	r31, Y+2	; 0x02
     f3e:	89 81       	ldd	r24, Y+1	; 0x01
     f40:	9a 81       	ldd	r25, Y+2	; 0x02
     f42:	91 87       	std	Z+9, r25	; 0x09
     f44:	80 87       	std	Z+8, r24	; 0x08
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     f46:	e9 81       	ldd	r30, Y+1	; 0x01
     f48:	fa 81       	ldd	r31, Y+2	; 0x02
     f4a:	89 81       	ldd	r24, Y+1	; 0x01
     f4c:	9a 81       	ldd	r25, Y+2	; 0x02
     f4e:	93 8b       	std	Z+19, r25	; 0x13
     f50:	82 8b       	std	Z+18, r24	; 0x12

            /* Event lists are always in priority order. */
            listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     f52:	8e 81       	ldd	r24, Y+6	; 0x06
     f54:	28 2f       	mov	r18, r24
     f56:	30 e0       	ldi	r19, 0x00	; 0
     f58:	82 e0       	ldi	r24, 0x02	; 2
     f5a:	90 e0       	ldi	r25, 0x00	; 0
     f5c:	82 1b       	sub	r24, r18
     f5e:	93 0b       	sbc	r25, r19
     f60:	e9 81       	ldd	r30, Y+1	; 0x01
     f62:	fa 81       	ldd	r31, Y+2	; 0x02
     f64:	95 87       	std	Z+13, r25	; 0x0d
     f66:	84 87       	std	Z+12, r24	; 0x0c

            /* Now the co-routine has been initialised it can be added to the ready
             * list at the correct priority. */
            prvAddCoRoutineToReadyQueue( pxCoRoutine );
     f68:	e9 81       	ldd	r30, Y+1	; 0x01
     f6a:	fa 81       	ldd	r31, Y+2	; 0x02
     f6c:	96 89       	ldd	r25, Z+22	; 0x16
     f6e:	80 91 98 06 	lds	r24, 0x0698
     f72:	89 17       	cp	r24, r25
     f74:	28 f4       	brcc	.+10     	; 0xf80 <xCoRoutineCreate+0xd6>
     f76:	e9 81       	ldd	r30, Y+1	; 0x01
     f78:	fa 81       	ldd	r31, Y+2	; 0x02
     f7a:	86 89       	ldd	r24, Z+22	; 0x16
     f7c:	80 93 98 06 	sts	0x0698, r24
     f80:	e9 81       	ldd	r30, Y+1	; 0x01
     f82:	fa 81       	ldd	r31, Y+2	; 0x02
     f84:	86 89       	ldd	r24, Z+22	; 0x16
     f86:	28 2f       	mov	r18, r24
     f88:	30 e0       	ldi	r19, 0x00	; 0
     f8a:	c9 01       	movw	r24, r18
     f8c:	88 0f       	add	r24, r24
     f8e:	99 1f       	adc	r25, r25
     f90:	88 0f       	add	r24, r24
     f92:	99 1f       	adc	r25, r25
     f94:	88 0f       	add	r24, r24
     f96:	99 1f       	adc	r25, r25
     f98:	82 0f       	add	r24, r18
     f9a:	93 1f       	adc	r25, r19
     f9c:	ac 01       	movw	r20, r24
     f9e:	41 56       	subi	r20, 0x61	; 97
     fa0:	59 4f       	sbci	r21, 0xF9	; 249
     fa2:	89 81       	ldd	r24, Y+1	; 0x01
     fa4:	9a 81       	ldd	r25, Y+2	; 0x02
     fa6:	9c 01       	movw	r18, r24
     fa8:	2e 5f       	subi	r18, 0xFE	; 254
     faa:	3f 4f       	sbci	r19, 0xFF	; 255
     fac:	ca 01       	movw	r24, r20
     fae:	b9 01       	movw	r22, r18
     fb0:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>

            xReturn = pdPASS;
     fb4:	81 e0       	ldi	r24, 0x01	; 1
     fb6:	8b 83       	std	Y+3, r24	; 0x03
     fb8:	02 c0       	rjmp	.+4      	; 0xfbe <xCoRoutineCreate+0x114>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     fba:	8f ef       	ldi	r24, 0xFF	; 255
     fbc:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
     fbe:	8b 81       	ldd	r24, Y+3	; 0x03
    }
     fc0:	27 96       	adiw	r28, 0x07	; 7
     fc2:	0f b6       	in	r0, 0x3f	; 63
     fc4:	f8 94       	cli
     fc6:	de bf       	out	0x3e, r29	; 62
     fc8:	0f be       	out	0x3f, r0	; 63
     fca:	cd bf       	out	0x3d, r28	; 61
     fcc:	cf 91       	pop	r28
     fce:	df 91       	pop	r29
     fd0:	08 95       	ret

00000fd2 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

    void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay,
                                     List_t * pxEventList )
    {
     fd2:	df 93       	push	r29
     fd4:	cf 93       	push	r28
     fd6:	00 d0       	rcall	.+0      	; 0xfd8 <vCoRoutineAddToDelayedList+0x6>
     fd8:	00 d0       	rcall	.+0      	; 0xfda <vCoRoutineAddToDelayedList+0x8>
     fda:	00 d0       	rcall	.+0      	; 0xfdc <vCoRoutineAddToDelayedList+0xa>
     fdc:	cd b7       	in	r28, 0x3d	; 61
     fde:	de b7       	in	r29, 0x3e	; 62
     fe0:	9c 83       	std	Y+4, r25	; 0x04
     fe2:	8b 83       	std	Y+3, r24	; 0x03
     fe4:	7e 83       	std	Y+6, r23	; 0x06
     fe6:	6d 83       	std	Y+5, r22	; 0x05
        TickType_t xTimeToWake;

        /* Calculate the time to wake - this may overflow but this is
         * not a problem. */
        xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     fe8:	20 91 99 06 	lds	r18, 0x0699
     fec:	30 91 9a 06 	lds	r19, 0x069A
     ff0:	8b 81       	ldd	r24, Y+3	; 0x03
     ff2:	9c 81       	ldd	r25, Y+4	; 0x04
     ff4:	82 0f       	add	r24, r18
     ff6:	93 1f       	adc	r25, r19
     ff8:	9a 83       	std	Y+2, r25	; 0x02
     ffa:	89 83       	std	Y+1, r24	; 0x01

        /* We must remove ourselves from the ready list before adding
         * ourselves to the blocked list as the same list item is used for
         * both lists. */
        ( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     ffc:	80 91 96 06 	lds	r24, 0x0696
    1000:	90 91 97 06 	lds	r25, 0x0697
    1004:	02 96       	adiw	r24, 0x02	; 2
    1006:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <uxListRemove>

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    100a:	e0 91 96 06 	lds	r30, 0x0696
    100e:	f0 91 97 06 	lds	r31, 0x0697
    1012:	89 81       	ldd	r24, Y+1	; 0x01
    1014:	9a 81       	ldd	r25, Y+2	; 0x02
    1016:	93 83       	std	Z+3, r25	; 0x03
    1018:	82 83       	std	Z+2, r24	; 0x02

        if( xTimeToWake < xCoRoutineTickCount )
    101a:	20 91 99 06 	lds	r18, 0x0699
    101e:	30 91 9a 06 	lds	r19, 0x069A
    1022:	89 81       	ldd	r24, Y+1	; 0x01
    1024:	9a 81       	ldd	r25, Y+2	; 0x02
    1026:	82 17       	cp	r24, r18
    1028:	93 07       	cpc	r25, r19
    102a:	70 f4       	brcc	.+28     	; 0x1048 <vCoRoutineAddToDelayedList+0x76>
        {
            /* Wake time has overflowed.  Place this item in the
             * overflow list. */
            vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    102c:	80 91 94 06 	lds	r24, 0x0694
    1030:	90 91 95 06 	lds	r25, 0x0695
    1034:	20 91 96 06 	lds	r18, 0x0696
    1038:	30 91 97 06 	lds	r19, 0x0697
    103c:	2e 5f       	subi	r18, 0xFE	; 254
    103e:	3f 4f       	sbci	r19, 0xFF	; 255
    1040:	b9 01       	movw	r22, r18
    1042:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <vListInsert>
    1046:	0d c0       	rjmp	.+26     	; 0x1062 <vCoRoutineAddToDelayedList+0x90>
        }
        else
        {
            /* The wake time has not overflowed, so we can use the
             * current block list. */
            vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1048:	80 91 92 06 	lds	r24, 0x0692
    104c:	90 91 93 06 	lds	r25, 0x0693
    1050:	20 91 96 06 	lds	r18, 0x0696
    1054:	30 91 97 06 	lds	r19, 0x0697
    1058:	2e 5f       	subi	r18, 0xFE	; 254
    105a:	3f 4f       	sbci	r19, 0xFF	; 255
    105c:	b9 01       	movw	r22, r18
    105e:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <vListInsert>
        }

        if( pxEventList )
    1062:	8d 81       	ldd	r24, Y+5	; 0x05
    1064:	9e 81       	ldd	r25, Y+6	; 0x06
    1066:	00 97       	sbiw	r24, 0x00	; 0
    1068:	61 f0       	breq	.+24     	; 0x1082 <vCoRoutineAddToDelayedList+0xb0>
        {
            /* Also add the co-routine to an event list.  If this is done then the
             * function must be called with interrupts disabled. */
            vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    106a:	80 91 96 06 	lds	r24, 0x0696
    106e:	90 91 97 06 	lds	r25, 0x0697
    1072:	9c 01       	movw	r18, r24
    1074:	24 5f       	subi	r18, 0xF4	; 244
    1076:	3f 4f       	sbci	r19, 0xFF	; 255
    1078:	8d 81       	ldd	r24, Y+5	; 0x05
    107a:	9e 81       	ldd	r25, Y+6	; 0x06
    107c:	b9 01       	movw	r22, r18
    107e:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <vListInsert>
        }
    }
    1082:	26 96       	adiw	r28, 0x06	; 6
    1084:	0f b6       	in	r0, 0x3f	; 63
    1086:	f8 94       	cli
    1088:	de bf       	out	0x3e, r29	; 62
    108a:	0f be       	out	0x3f, r0	; 63
    108c:	cd bf       	out	0x3d, r28	; 61
    108e:	cf 91       	pop	r28
    1090:	df 91       	pop	r29
    1092:	08 95       	ret

00001094 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

    static void prvCheckPendingReadyList( void )
    {
    1094:	df 93       	push	r29
    1096:	cf 93       	push	r28
    1098:	00 d0       	rcall	.+0      	; 0x109a <prvCheckPendingReadyList+0x6>
    109a:	cd b7       	in	r28, 0x3d	; 61
    109c:	de b7       	in	r29, 0x3e	; 62
    109e:	3a c0       	rjmp	.+116    	; 0x1114 <prvCheckPendingReadyList+0x80>
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
        {
            CRCB_t * pxUnblockedCRCB;

            /* The pending ready list can be accessed by an ISR. */
            portDISABLE_INTERRUPTS();
    10a0:	f8 94       	cli
            {
                pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyCoRoutineList ) );
    10a2:	e0 91 c8 06 	lds	r30, 0x06C8
    10a6:	f0 91 c9 06 	lds	r31, 0x06C9
    10aa:	86 81       	ldd	r24, Z+6	; 0x06
    10ac:	97 81       	ldd	r25, Z+7	; 0x07
    10ae:	9a 83       	std	Y+2, r25	; 0x02
    10b0:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    10b2:	89 81       	ldd	r24, Y+1	; 0x01
    10b4:	9a 81       	ldd	r25, Y+2	; 0x02
    10b6:	0c 96       	adiw	r24, 0x0c	; 12
    10b8:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <uxListRemove>
            }
            portENABLE_INTERRUPTS();
    10bc:	78 94       	sei

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    10be:	89 81       	ldd	r24, Y+1	; 0x01
    10c0:	9a 81       	ldd	r25, Y+2	; 0x02
    10c2:	02 96       	adiw	r24, 0x02	; 2
    10c4:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <uxListRemove>
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    10c8:	e9 81       	ldd	r30, Y+1	; 0x01
    10ca:	fa 81       	ldd	r31, Y+2	; 0x02
    10cc:	96 89       	ldd	r25, Z+22	; 0x16
    10ce:	80 91 98 06 	lds	r24, 0x0698
    10d2:	89 17       	cp	r24, r25
    10d4:	28 f4       	brcc	.+10     	; 0x10e0 <prvCheckPendingReadyList+0x4c>
    10d6:	e9 81       	ldd	r30, Y+1	; 0x01
    10d8:	fa 81       	ldd	r31, Y+2	; 0x02
    10da:	86 89       	ldd	r24, Z+22	; 0x16
    10dc:	80 93 98 06 	sts	0x0698, r24
    10e0:	e9 81       	ldd	r30, Y+1	; 0x01
    10e2:	fa 81       	ldd	r31, Y+2	; 0x02
    10e4:	86 89       	ldd	r24, Z+22	; 0x16
    10e6:	28 2f       	mov	r18, r24
    10e8:	30 e0       	ldi	r19, 0x00	; 0
    10ea:	c9 01       	movw	r24, r18
    10ec:	88 0f       	add	r24, r24
    10ee:	99 1f       	adc	r25, r25
    10f0:	88 0f       	add	r24, r24
    10f2:	99 1f       	adc	r25, r25
    10f4:	88 0f       	add	r24, r24
    10f6:	99 1f       	adc	r25, r25
    10f8:	82 0f       	add	r24, r18
    10fa:	93 1f       	adc	r25, r19
    10fc:	ac 01       	movw	r20, r24
    10fe:	41 56       	subi	r20, 0x61	; 97
    1100:	59 4f       	sbci	r21, 0xF9	; 249
    1102:	89 81       	ldd	r24, Y+1	; 0x01
    1104:	9a 81       	ldd	r25, Y+2	; 0x02
    1106:	9c 01       	movw	r18, r24
    1108:	2e 5f       	subi	r18, 0xFE	; 254
    110a:	3f 4f       	sbci	r19, 0xFF	; 255
    110c:	ca 01       	movw	r24, r20
    110e:	b9 01       	movw	r22, r18
    1110:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>
    static void prvCheckPendingReadyList( void )
    {
        /* Are there any co-routines waiting to get moved to the ready list?  These
         * are co-routines that have been readied by an ISR.  The ISR cannot access
         * the ready lists itself. */
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1114:	80 91 c3 06 	lds	r24, 0x06C3
    1118:	88 23       	and	r24, r24
    111a:	09 f0       	breq	.+2      	; 0x111e <prvCheckPendingReadyList+0x8a>
    111c:	c1 cf       	rjmp	.-126    	; 0x10a0 <prvCheckPendingReadyList+0xc>
            portENABLE_INTERRUPTS();

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
        }
    }
    111e:	0f 90       	pop	r0
    1120:	0f 90       	pop	r0
    1122:	cf 91       	pop	r28
    1124:	df 91       	pop	r29
    1126:	08 95       	ret

00001128 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

    static void prvCheckDelayedList( void )
    {
    1128:	df 93       	push	r29
    112a:	cf 93       	push	r28
    112c:	00 d0       	rcall	.+0      	; 0x112e <prvCheckDelayedList+0x6>
    112e:	00 d0       	rcall	.+0      	; 0x1130 <prvCheckDelayedList+0x8>
    1130:	cd b7       	in	r28, 0x3d	; 61
    1132:	de b7       	in	r29, 0x3e	; 62
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1134:	0e 94 8c 1d 	call	0x3b18	; 0x3b18 <xTaskGetTickCount>
    1138:	20 91 9b 06 	lds	r18, 0x069B
    113c:	30 91 9c 06 	lds	r19, 0x069C
    1140:	82 1b       	sub	r24, r18
    1142:	93 0b       	sbc	r25, r19
    1144:	90 93 9e 06 	sts	0x069E, r25
    1148:	80 93 9d 06 	sts	0x069D, r24
    114c:	85 c0       	rjmp	.+266    	; 0x1258 <prvCheckDelayedList+0x130>

        while( xPassedTicks )
        {
            xCoRoutineTickCount++;
    114e:	80 91 99 06 	lds	r24, 0x0699
    1152:	90 91 9a 06 	lds	r25, 0x069A
    1156:	01 96       	adiw	r24, 0x01	; 1
    1158:	90 93 9a 06 	sts	0x069A, r25
    115c:	80 93 99 06 	sts	0x0699, r24
            xPassedTicks--;
    1160:	80 91 9d 06 	lds	r24, 0x069D
    1164:	90 91 9e 06 	lds	r25, 0x069E
    1168:	01 97       	sbiw	r24, 0x01	; 1
    116a:	90 93 9e 06 	sts	0x069E, r25
    116e:	80 93 9d 06 	sts	0x069D, r24

            /* If the tick count has overflowed we need to swap the ready lists. */
            if( xCoRoutineTickCount == 0 )
    1172:	80 91 99 06 	lds	r24, 0x0699
    1176:	90 91 9a 06 	lds	r25, 0x069A
    117a:	00 97       	sbiw	r24, 0x00	; 0
    117c:	09 f0       	breq	.+2      	; 0x1180 <prvCheckDelayedList+0x58>
    117e:	64 c0       	rjmp	.+200    	; 0x1248 <prvCheckDelayedList+0x120>
            {
                List_t * pxTemp;

                /* Tick count has overflowed so we need to swap the delay lists.  If there are
                 * any items in pxDelayedCoRoutineList here then there is an error! */
                pxTemp = pxDelayedCoRoutineList;
    1180:	80 91 92 06 	lds	r24, 0x0692
    1184:	90 91 93 06 	lds	r25, 0x0693
    1188:	9a 83       	std	Y+2, r25	; 0x02
    118a:	89 83       	std	Y+1, r24	; 0x01
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    118c:	80 91 94 06 	lds	r24, 0x0694
    1190:	90 91 95 06 	lds	r25, 0x0695
    1194:	90 93 93 06 	sts	0x0693, r25
    1198:	80 93 92 06 	sts	0x0692, r24
                pxOverflowDelayedCoRoutineList = pxTemp;
    119c:	89 81       	ldd	r24, Y+1	; 0x01
    119e:	9a 81       	ldd	r25, Y+2	; 0x02
    11a0:	90 93 95 06 	sts	0x0695, r25
    11a4:	80 93 94 06 	sts	0x0694, r24
    11a8:	4f c0       	rjmp	.+158    	; 0x1248 <prvCheckDelayedList+0x120>
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
            {
                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    11aa:	e0 91 92 06 	lds	r30, 0x0692
    11ae:	f0 91 93 06 	lds	r31, 0x0693
    11b2:	05 80       	ldd	r0, Z+5	; 0x05
    11b4:	f6 81       	ldd	r31, Z+6	; 0x06
    11b6:	e0 2d       	mov	r30, r0
    11b8:	86 81       	ldd	r24, Z+6	; 0x06
    11ba:	97 81       	ldd	r25, Z+7	; 0x07
    11bc:	9c 83       	std	Y+4, r25	; 0x04
    11be:	8b 83       	std	Y+3, r24	; 0x03

                if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    11c0:	eb 81       	ldd	r30, Y+3	; 0x03
    11c2:	fc 81       	ldd	r31, Y+4	; 0x04
    11c4:	22 81       	ldd	r18, Z+2	; 0x02
    11c6:	33 81       	ldd	r19, Z+3	; 0x03
    11c8:	80 91 99 06 	lds	r24, 0x0699
    11cc:	90 91 9a 06 	lds	r25, 0x069A
    11d0:	82 17       	cp	r24, r18
    11d2:	93 07       	cpc	r25, r19
    11d4:	08 f4       	brcc	.+2      	; 0x11d8 <prvCheckDelayedList+0xb0>
    11d6:	40 c0       	rjmp	.+128    	; 0x1258 <prvCheckDelayedList+0x130>
                {
                    /* Timeout not yet expired. */
                    break;
                }

                portDISABLE_INTERRUPTS();
    11d8:	f8 94       	cli
                    /* The event could have occurred just before this critical
                     *  section.  If this is the case then the generic list item will
                     *  have been moved to the pending ready list and the following
                     *  line is still valid.  Also the pvContainer parameter will have
                     *  been set to NULL so the following lines are also valid. */
                    ( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    11da:	8b 81       	ldd	r24, Y+3	; 0x03
    11dc:	9c 81       	ldd	r25, Y+4	; 0x04
    11de:	02 96       	adiw	r24, 0x02	; 2
    11e0:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <uxListRemove>

                    /* Is the co-routine waiting on an event also? */
                    if( pxCRCB->xEventListItem.pxContainer )
    11e4:	eb 81       	ldd	r30, Y+3	; 0x03
    11e6:	fc 81       	ldd	r31, Y+4	; 0x04
    11e8:	84 89       	ldd	r24, Z+20	; 0x14
    11ea:	95 89       	ldd	r25, Z+21	; 0x15
    11ec:	00 97       	sbiw	r24, 0x00	; 0
    11ee:	29 f0       	breq	.+10     	; 0x11fa <prvCheckDelayedList+0xd2>
                    {
                        ( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    11f0:	8b 81       	ldd	r24, Y+3	; 0x03
    11f2:	9c 81       	ldd	r25, Y+4	; 0x04
    11f4:	0c 96       	adiw	r24, 0x0c	; 12
    11f6:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <uxListRemove>
                    }
                }
                portENABLE_INTERRUPTS();
    11fa:	78 94       	sei

                prvAddCoRoutineToReadyQueue( pxCRCB );
    11fc:	eb 81       	ldd	r30, Y+3	; 0x03
    11fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1200:	96 89       	ldd	r25, Z+22	; 0x16
    1202:	80 91 98 06 	lds	r24, 0x0698
    1206:	89 17       	cp	r24, r25
    1208:	28 f4       	brcc	.+10     	; 0x1214 <prvCheckDelayedList+0xec>
    120a:	eb 81       	ldd	r30, Y+3	; 0x03
    120c:	fc 81       	ldd	r31, Y+4	; 0x04
    120e:	86 89       	ldd	r24, Z+22	; 0x16
    1210:	80 93 98 06 	sts	0x0698, r24
    1214:	eb 81       	ldd	r30, Y+3	; 0x03
    1216:	fc 81       	ldd	r31, Y+4	; 0x04
    1218:	86 89       	ldd	r24, Z+22	; 0x16
    121a:	28 2f       	mov	r18, r24
    121c:	30 e0       	ldi	r19, 0x00	; 0
    121e:	c9 01       	movw	r24, r18
    1220:	88 0f       	add	r24, r24
    1222:	99 1f       	adc	r25, r25
    1224:	88 0f       	add	r24, r24
    1226:	99 1f       	adc	r25, r25
    1228:	88 0f       	add	r24, r24
    122a:	99 1f       	adc	r25, r25
    122c:	82 0f       	add	r24, r18
    122e:	93 1f       	adc	r25, r19
    1230:	ac 01       	movw	r20, r24
    1232:	41 56       	subi	r20, 0x61	; 97
    1234:	59 4f       	sbci	r21, 0xF9	; 249
    1236:	8b 81       	ldd	r24, Y+3	; 0x03
    1238:	9c 81       	ldd	r25, Y+4	; 0x04
    123a:	9c 01       	movw	r18, r24
    123c:	2e 5f       	subi	r18, 0xFE	; 254
    123e:	3f 4f       	sbci	r19, 0xFF	; 255
    1240:	ca 01       	movw	r24, r20
    1242:	b9 01       	movw	r22, r18
    1244:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
                pxOverflowDelayedCoRoutineList = pxTemp;
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1248:	e0 91 92 06 	lds	r30, 0x0692
    124c:	f0 91 93 06 	lds	r31, 0x0693
    1250:	80 81       	ld	r24, Z
    1252:	88 23       	and	r24, r24
    1254:	09 f0       	breq	.+2      	; 0x1258 <prvCheckDelayedList+0x130>
    1256:	a9 cf       	rjmp	.-174    	; 0x11aa <prvCheckDelayedList+0x82>
    {
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;

        while( xPassedTicks )
    1258:	80 91 9d 06 	lds	r24, 0x069D
    125c:	90 91 9e 06 	lds	r25, 0x069E
    1260:	00 97       	sbiw	r24, 0x00	; 0
    1262:	09 f0       	breq	.+2      	; 0x1266 <prvCheckDelayedList+0x13e>
    1264:	74 cf       	rjmp	.-280    	; 0x114e <prvCheckDelayedList+0x26>

                prvAddCoRoutineToReadyQueue( pxCRCB );
            }
        }

        xLastTickCount = xCoRoutineTickCount;
    1266:	80 91 99 06 	lds	r24, 0x0699
    126a:	90 91 9a 06 	lds	r25, 0x069A
    126e:	90 93 9c 06 	sts	0x069C, r25
    1272:	80 93 9b 06 	sts	0x069B, r24
    }
    1276:	0f 90       	pop	r0
    1278:	0f 90       	pop	r0
    127a:	0f 90       	pop	r0
    127c:	0f 90       	pop	r0
    127e:	cf 91       	pop	r28
    1280:	df 91       	pop	r29
    1282:	08 95       	ret

00001284 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

    void vCoRoutineSchedule( void )
    {
    1284:	df 93       	push	r29
    1286:	cf 93       	push	r28
    1288:	00 d0       	rcall	.+0      	; 0x128a <vCoRoutineSchedule+0x6>
    128a:	cd b7       	in	r28, 0x3d	; 61
    128c:	de b7       	in	r29, 0x3e	; 62
        /* Only run a co-routine after prvInitialiseCoRoutineLists() has been
         * called.  prvInitialiseCoRoutineLists() is called automatically when a
         * co-routine is created. */
        if( pxDelayedCoRoutineList != NULL )
    128e:	80 91 92 06 	lds	r24, 0x0692
    1292:	90 91 93 06 	lds	r25, 0x0693
    1296:	00 97       	sbiw	r24, 0x00	; 0
    1298:	09 f4       	brne	.+2      	; 0x129c <vCoRoutineSchedule+0x18>
    129a:	70 c0       	rjmp	.+224    	; 0x137c <vCoRoutineSchedule+0xf8>
        {
            /* See if any co-routines readied by events need moving to the ready lists. */
            prvCheckPendingReadyList();
    129c:	0e 94 4a 08 	call	0x1094	; 0x1094 <prvCheckPendingReadyList>

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();
    12a0:	0e 94 94 08 	call	0x1128	; 0x1128 <prvCheckDelayedList>
    12a4:	0a c0       	rjmp	.+20     	; 0x12ba <vCoRoutineSchedule+0x36>

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
            {
                if( uxTopCoRoutineReadyPriority == 0 )
    12a6:	80 91 98 06 	lds	r24, 0x0698
    12aa:	88 23       	and	r24, r24
    12ac:	09 f4       	brne	.+2      	; 0x12b0 <vCoRoutineSchedule+0x2c>
    12ae:	66 c0       	rjmp	.+204    	; 0x137c <vCoRoutineSchedule+0xf8>
                {
                    /* No more co-routines to check. */
                    return;
                }

                --uxTopCoRoutineReadyPriority;
    12b0:	80 91 98 06 	lds	r24, 0x0698
    12b4:	81 50       	subi	r24, 0x01	; 1
    12b6:	80 93 98 06 	sts	0x0698, r24

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    12ba:	80 91 98 06 	lds	r24, 0x0698
    12be:	28 2f       	mov	r18, r24
    12c0:	30 e0       	ldi	r19, 0x00	; 0
    12c2:	c9 01       	movw	r24, r18
    12c4:	88 0f       	add	r24, r24
    12c6:	99 1f       	adc	r25, r25
    12c8:	88 0f       	add	r24, r24
    12ca:	99 1f       	adc	r25, r25
    12cc:	88 0f       	add	r24, r24
    12ce:	99 1f       	adc	r25, r25
    12d0:	82 0f       	add	r24, r18
    12d2:	93 1f       	adc	r25, r19
    12d4:	fc 01       	movw	r30, r24
    12d6:	e1 56       	subi	r30, 0x61	; 97
    12d8:	f9 4f       	sbci	r31, 0xF9	; 249
    12da:	80 81       	ld	r24, Z
    12dc:	88 23       	and	r24, r24
    12de:	19 f3       	breq	.-58     	; 0x12a6 <vCoRoutineSchedule+0x22>
                --uxTopCoRoutineReadyPriority;
            }

            /* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
             * of the same priority get an equal share of the processor time. */
            listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    12e0:	80 91 98 06 	lds	r24, 0x0698
    12e4:	28 2f       	mov	r18, r24
    12e6:	30 e0       	ldi	r19, 0x00	; 0
    12e8:	c9 01       	movw	r24, r18
    12ea:	88 0f       	add	r24, r24
    12ec:	99 1f       	adc	r25, r25
    12ee:	88 0f       	add	r24, r24
    12f0:	99 1f       	adc	r25, r25
    12f2:	88 0f       	add	r24, r24
    12f4:	99 1f       	adc	r25, r25
    12f6:	82 0f       	add	r24, r18
    12f8:	93 1f       	adc	r25, r19
    12fa:	81 56       	subi	r24, 0x61	; 97
    12fc:	99 4f       	sbci	r25, 0xF9	; 249
    12fe:	9a 83       	std	Y+2, r25	; 0x02
    1300:	89 83       	std	Y+1, r24	; 0x01
    1302:	e9 81       	ldd	r30, Y+1	; 0x01
    1304:	fa 81       	ldd	r31, Y+2	; 0x02
    1306:	01 80       	ldd	r0, Z+1	; 0x01
    1308:	f2 81       	ldd	r31, Z+2	; 0x02
    130a:	e0 2d       	mov	r30, r0
    130c:	82 81       	ldd	r24, Z+2	; 0x02
    130e:	93 81       	ldd	r25, Z+3	; 0x03
    1310:	e9 81       	ldd	r30, Y+1	; 0x01
    1312:	fa 81       	ldd	r31, Y+2	; 0x02
    1314:	92 83       	std	Z+2, r25	; 0x02
    1316:	81 83       	std	Z+1, r24	; 0x01
    1318:	e9 81       	ldd	r30, Y+1	; 0x01
    131a:	fa 81       	ldd	r31, Y+2	; 0x02
    131c:	21 81       	ldd	r18, Z+1	; 0x01
    131e:	32 81       	ldd	r19, Z+2	; 0x02
    1320:	89 81       	ldd	r24, Y+1	; 0x01
    1322:	9a 81       	ldd	r25, Y+2	; 0x02
    1324:	03 96       	adiw	r24, 0x03	; 3
    1326:	28 17       	cp	r18, r24
    1328:	39 07       	cpc	r19, r25
    132a:	59 f4       	brne	.+22     	; 0x1342 <vCoRoutineSchedule+0xbe>
    132c:	e9 81       	ldd	r30, Y+1	; 0x01
    132e:	fa 81       	ldd	r31, Y+2	; 0x02
    1330:	01 80       	ldd	r0, Z+1	; 0x01
    1332:	f2 81       	ldd	r31, Z+2	; 0x02
    1334:	e0 2d       	mov	r30, r0
    1336:	82 81       	ldd	r24, Z+2	; 0x02
    1338:	93 81       	ldd	r25, Z+3	; 0x03
    133a:	e9 81       	ldd	r30, Y+1	; 0x01
    133c:	fa 81       	ldd	r31, Y+2	; 0x02
    133e:	92 83       	std	Z+2, r25	; 0x02
    1340:	81 83       	std	Z+1, r24	; 0x01
    1342:	e9 81       	ldd	r30, Y+1	; 0x01
    1344:	fa 81       	ldd	r31, Y+2	; 0x02
    1346:	01 80       	ldd	r0, Z+1	; 0x01
    1348:	f2 81       	ldd	r31, Z+2	; 0x02
    134a:	e0 2d       	mov	r30, r0
    134c:	86 81       	ldd	r24, Z+6	; 0x06
    134e:	97 81       	ldd	r25, Z+7	; 0x07
    1350:	90 93 97 06 	sts	0x0697, r25
    1354:	80 93 96 06 	sts	0x0696, r24

            /* Call the co-routine. */
            ( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1358:	e0 91 96 06 	lds	r30, 0x0696
    135c:	f0 91 97 06 	lds	r31, 0x0697
    1360:	40 81       	ld	r20, Z
    1362:	51 81       	ldd	r21, Z+1	; 0x01
    1364:	80 91 96 06 	lds	r24, 0x0696
    1368:	90 91 97 06 	lds	r25, 0x0697
    136c:	e0 91 96 06 	lds	r30, 0x0696
    1370:	f0 91 97 06 	lds	r31, 0x0697
    1374:	27 89       	ldd	r18, Z+23	; 0x17
    1376:	62 2f       	mov	r22, r18
    1378:	fa 01       	movw	r30, r20
    137a:	09 95       	icall
        }
    }
    137c:	0f 90       	pop	r0
    137e:	0f 90       	pop	r0
    1380:	cf 91       	pop	r28
    1382:	df 91       	pop	r29
    1384:	08 95       	ret

00001386 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

    static void prvInitialiseCoRoutineLists( void )
    {
    1386:	df 93       	push	r29
    1388:	cf 93       	push	r28
    138a:	0f 92       	push	r0
    138c:	cd b7       	in	r28, 0x3d	; 61
    138e:	de b7       	in	r29, 0x3e	; 62
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1390:	19 82       	std	Y+1, r1	; 0x01
    1392:	13 c0       	rjmp	.+38     	; 0x13ba <prvInitialiseCoRoutineLists+0x34>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1394:	89 81       	ldd	r24, Y+1	; 0x01
    1396:	28 2f       	mov	r18, r24
    1398:	30 e0       	ldi	r19, 0x00	; 0
    139a:	c9 01       	movw	r24, r18
    139c:	88 0f       	add	r24, r24
    139e:	99 1f       	adc	r25, r25
    13a0:	88 0f       	add	r24, r24
    13a2:	99 1f       	adc	r25, r25
    13a4:	88 0f       	add	r24, r24
    13a6:	99 1f       	adc	r25, r25
    13a8:	82 0f       	add	r24, r18
    13aa:	93 1f       	adc	r25, r19
    13ac:	81 56       	subi	r24, 0x61	; 97
    13ae:	99 4f       	sbci	r25, 0xF9	; 249
    13b0:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <vListInitialise>

    static void prvInitialiseCoRoutineLists( void )
    {
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    13b4:	89 81       	ldd	r24, Y+1	; 0x01
    13b6:	8f 5f       	subi	r24, 0xFF	; 255
    13b8:	89 83       	std	Y+1, r24	; 0x01
    13ba:	89 81       	ldd	r24, Y+1	; 0x01
    13bc:	82 30       	cpi	r24, 0x02	; 2
    13be:	50 f3       	brcs	.-44     	; 0x1394 <prvInitialiseCoRoutineLists+0xe>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
        }

        vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    13c0:	81 eb       	ldi	r24, 0xB1	; 177
    13c2:	96 e0       	ldi	r25, 0x06	; 6
    13c4:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <vListInitialise>
        vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    13c8:	8a eb       	ldi	r24, 0xBA	; 186
    13ca:	96 e0       	ldi	r25, 0x06	; 6
    13cc:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <vListInitialise>
        vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    13d0:	83 ec       	ldi	r24, 0xC3	; 195
    13d2:	96 e0       	ldi	r25, 0x06	; 6
    13d4:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <vListInitialise>

        /* Start with pxDelayedCoRoutineList using list1 and the
         * pxOverflowDelayedCoRoutineList using list2. */
        pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    13d8:	81 eb       	ldi	r24, 0xB1	; 177
    13da:	96 e0       	ldi	r25, 0x06	; 6
    13dc:	90 93 93 06 	sts	0x0693, r25
    13e0:	80 93 92 06 	sts	0x0692, r24
        pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    13e4:	8a eb       	ldi	r24, 0xBA	; 186
    13e6:	96 e0       	ldi	r25, 0x06	; 6
    13e8:	90 93 95 06 	sts	0x0695, r25
    13ec:	80 93 94 06 	sts	0x0694, r24
    }
    13f0:	0f 90       	pop	r0
    13f2:	cf 91       	pop	r28
    13f4:	df 91       	pop	r29
    13f6:	08 95       	ret

000013f8 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineRemoveFromEventList( const List_t * pxEventList )
    {
    13f8:	df 93       	push	r29
    13fa:	cf 93       	push	r28
    13fc:	00 d0       	rcall	.+0      	; 0x13fe <xCoRoutineRemoveFromEventList+0x6>
    13fe:	00 d0       	rcall	.+0      	; 0x1400 <xCoRoutineRemoveFromEventList+0x8>
    1400:	0f 92       	push	r0
    1402:	cd b7       	in	r28, 0x3d	; 61
    1404:	de b7       	in	r29, 0x3e	; 62
    1406:	9d 83       	std	Y+5, r25	; 0x05
    1408:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;

        /* This function is called from within an interrupt.  It can only access
         * event lists and the pending ready list.  This function assumes that a
         * check has already been made to ensure pxEventList is not empty. */
        pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    140a:	ec 81       	ldd	r30, Y+4	; 0x04
    140c:	fd 81       	ldd	r31, Y+5	; 0x05
    140e:	05 80       	ldd	r0, Z+5	; 0x05
    1410:	f6 81       	ldd	r31, Z+6	; 0x06
    1412:	e0 2d       	mov	r30, r0
    1414:	86 81       	ldd	r24, Z+6	; 0x06
    1416:	97 81       	ldd	r25, Z+7	; 0x07
    1418:	9b 83       	std	Y+3, r25	; 0x03
    141a:	8a 83       	std	Y+2, r24	; 0x02
        ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    141c:	8a 81       	ldd	r24, Y+2	; 0x02
    141e:	9b 81       	ldd	r25, Y+3	; 0x03
    1420:	0c 96       	adiw	r24, 0x0c	; 12
    1422:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <uxListRemove>
        vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1426:	8a 81       	ldd	r24, Y+2	; 0x02
    1428:	9b 81       	ldd	r25, Y+3	; 0x03
    142a:	9c 01       	movw	r18, r24
    142c:	24 5f       	subi	r18, 0xF4	; 244
    142e:	3f 4f       	sbci	r19, 0xFF	; 255
    1430:	83 ec       	ldi	r24, 0xC3	; 195
    1432:	96 e0       	ldi	r25, 0x06	; 6
    1434:	b9 01       	movw	r22, r18
    1436:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>

        if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    143a:	ea 81       	ldd	r30, Y+2	; 0x02
    143c:	fb 81       	ldd	r31, Y+3	; 0x03
    143e:	96 89       	ldd	r25, Z+22	; 0x16
    1440:	e0 91 96 06 	lds	r30, 0x0696
    1444:	f0 91 97 06 	lds	r31, 0x0697
    1448:	86 89       	ldd	r24, Z+22	; 0x16
    144a:	98 17       	cp	r25, r24
    144c:	18 f0       	brcs	.+6      	; 0x1454 <xCoRoutineRemoveFromEventList+0x5c>
        {
            xReturn = pdTRUE;
    144e:	81 e0       	ldi	r24, 0x01	; 1
    1450:	89 83       	std	Y+1, r24	; 0x01
    1452:	01 c0       	rjmp	.+2      	; 0x1456 <xCoRoutineRemoveFromEventList+0x5e>
        }
        else
        {
            xReturn = pdFALSE;
    1454:	19 82       	std	Y+1, r1	; 0x01
        }

        return xReturn;
    1456:	89 81       	ldd	r24, Y+1	; 0x01
    }
    1458:	0f 90       	pop	r0
    145a:	0f 90       	pop	r0
    145c:	0f 90       	pop	r0
    145e:	0f 90       	pop	r0
    1460:	0f 90       	pop	r0
    1462:	cf 91       	pop	r28
    1464:	df 91       	pop	r29
    1466:	08 95       	ret

00001468 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    1468:	df 93       	push	r29
    146a:	cf 93       	push	r28
    146c:	00 d0       	rcall	.+0      	; 0x146e <xEventGroupCreate+0x6>
    146e:	cd b7       	in	r28, 0x3d	; 61
    1470:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1472:	8c e0       	ldi	r24, 0x0C	; 12
    1474:	90 e0       	ldi	r25, 0x00	; 0
    1476:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    147a:	9a 83       	std	Y+2, r25	; 0x02
    147c:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
    147e:	89 81       	ldd	r24, Y+1	; 0x01
    1480:	9a 81       	ldd	r25, Y+2	; 0x02
    1482:	00 97       	sbiw	r24, 0x00	; 0
    1484:	49 f0       	breq	.+18     	; 0x1498 <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
    1486:	e9 81       	ldd	r30, Y+1	; 0x01
    1488:	fa 81       	ldd	r31, Y+2	; 0x02
    148a:	11 82       	std	Z+1, r1	; 0x01
    148c:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    148e:	89 81       	ldd	r24, Y+1	; 0x01
    1490:	9a 81       	ldd	r25, Y+2	; 0x02
    1492:	02 96       	adiw	r24, 0x02	; 2
    1494:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    1498:	89 81       	ldd	r24, Y+1	; 0x01
    149a:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    149c:	0f 90       	pop	r0
    149e:	0f 90       	pop	r0
    14a0:	cf 91       	pop	r28
    14a2:	df 91       	pop	r29
    14a4:	08 95       	ret

000014a6 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    14a6:	df 93       	push	r29
    14a8:	cf 93       	push	r28
    14aa:	cd b7       	in	r28, 0x3d	; 61
    14ac:	de b7       	in	r29, 0x3e	; 62
    14ae:	60 97       	sbiw	r28, 0x10	; 16
    14b0:	0f b6       	in	r0, 0x3f	; 63
    14b2:	f8 94       	cli
    14b4:	de bf       	out	0x3e, r29	; 62
    14b6:	0f be       	out	0x3f, r0	; 63
    14b8:	cd bf       	out	0x3d, r28	; 61
    14ba:	9a 87       	std	Y+10, r25	; 0x0a
    14bc:	89 87       	std	Y+9, r24	; 0x09
    14be:	7c 87       	std	Y+12, r23	; 0x0c
    14c0:	6b 87       	std	Y+11, r22	; 0x0b
    14c2:	5e 87       	std	Y+14, r21	; 0x0e
    14c4:	4d 87       	std	Y+13, r20	; 0x0d
    14c6:	38 8b       	std	Y+16, r19	; 0x10
    14c8:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    14ca:	89 85       	ldd	r24, Y+9	; 0x09
    14cc:	9a 85       	ldd	r25, Y+10	; 0x0a
    14ce:	9c 83       	std	Y+4, r25	; 0x04
    14d0:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    14d2:	19 82       	std	Y+1, r1	; 0x01
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    14d4:	0e 94 30 1c 	call	0x3860	; 0x3860 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    14d8:	eb 81       	ldd	r30, Y+3	; 0x03
    14da:	fc 81       	ldd	r31, Y+4	; 0x04
    14dc:	80 81       	ld	r24, Z
    14de:	91 81       	ldd	r25, Z+1	; 0x01
    14e0:	98 87       	std	Y+8, r25	; 0x08
    14e2:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    14e4:	89 85       	ldd	r24, Y+9	; 0x09
    14e6:	9a 85       	ldd	r25, Y+10	; 0x0a
    14e8:	2b 85       	ldd	r18, Y+11	; 0x0b
    14ea:	3c 85       	ldd	r19, Y+12	; 0x0c
    14ec:	b9 01       	movw	r22, r18
    14ee:	0e 94 2a 0c 	call	0x1854	; 0x1854 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    14f2:	2f 81       	ldd	r18, Y+7	; 0x07
    14f4:	38 85       	ldd	r19, Y+8	; 0x08
    14f6:	8b 85       	ldd	r24, Y+11	; 0x0b
    14f8:	9c 85       	ldd	r25, Y+12	; 0x0c
    14fa:	28 2b       	or	r18, r24
    14fc:	39 2b       	or	r19, r25
    14fe:	8d 85       	ldd	r24, Y+13	; 0x0d
    1500:	9e 85       	ldd	r25, Y+14	; 0x0e
    1502:	28 23       	and	r18, r24
    1504:	39 23       	and	r19, r25
    1506:	8d 85       	ldd	r24, Y+13	; 0x0d
    1508:	9e 85       	ldd	r25, Y+14	; 0x0e
    150a:	28 17       	cp	r18, r24
    150c:	39 07       	cpc	r19, r25
    150e:	c9 f4       	brne	.+50     	; 0x1542 <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1510:	2f 81       	ldd	r18, Y+7	; 0x07
    1512:	38 85       	ldd	r19, Y+8	; 0x08
    1514:	8b 85       	ldd	r24, Y+11	; 0x0b
    1516:	9c 85       	ldd	r25, Y+12	; 0x0c
    1518:	82 2b       	or	r24, r18
    151a:	93 2b       	or	r25, r19
    151c:	9e 83       	std	Y+6, r25	; 0x06
    151e:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1520:	eb 81       	ldd	r30, Y+3	; 0x03
    1522:	fc 81       	ldd	r31, Y+4	; 0x04
    1524:	20 81       	ld	r18, Z
    1526:	31 81       	ldd	r19, Z+1	; 0x01
    1528:	8d 85       	ldd	r24, Y+13	; 0x0d
    152a:	9e 85       	ldd	r25, Y+14	; 0x0e
    152c:	80 95       	com	r24
    152e:	90 95       	com	r25
    1530:	82 23       	and	r24, r18
    1532:	93 23       	and	r25, r19
    1534:	eb 81       	ldd	r30, Y+3	; 0x03
    1536:	fc 81       	ldd	r31, Y+4	; 0x04
    1538:	91 83       	std	Z+1, r25	; 0x01
    153a:	80 83       	st	Z, r24

            xTicksToWait = 0;
    153c:	18 8a       	std	Y+16, r1	; 0x10
    153e:	1f 86       	std	Y+15, r1	; 0x0f
    1540:	1e c0       	rjmp	.+60     	; 0x157e <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    1542:	8f 85       	ldd	r24, Y+15	; 0x0f
    1544:	98 89       	ldd	r25, Y+16	; 0x10
    1546:	00 97       	sbiw	r24, 0x00	; 0
    1548:	91 f0       	breq	.+36     	; 0x156e <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    154a:	8b 81       	ldd	r24, Y+3	; 0x03
    154c:	9c 81       	ldd	r25, Y+4	; 0x04
    154e:	bc 01       	movw	r22, r24
    1550:	6e 5f       	subi	r22, 0xFE	; 254
    1552:	7f 4f       	sbci	r23, 0xFF	; 255
    1554:	8d 85       	ldd	r24, Y+13	; 0x0d
    1556:	9e 85       	ldd	r25, Y+14	; 0x0e
    1558:	9c 01       	movw	r18, r24
    155a:	35 60       	ori	r19, 0x05	; 5
    155c:	4f 85       	ldd	r20, Y+15	; 0x0f
    155e:	58 89       	ldd	r21, Y+16	; 0x10
    1560:	cb 01       	movw	r24, r22
    1562:	b9 01       	movw	r22, r18
    1564:	0e 94 4b 21 	call	0x4296	; 0x4296 <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    1568:	1e 82       	std	Y+6, r1	; 0x06
    156a:	1d 82       	std	Y+5, r1	; 0x05
    156c:	08 c0       	rjmp	.+16     	; 0x157e <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    156e:	eb 81       	ldd	r30, Y+3	; 0x03
    1570:	fc 81       	ldd	r31, Y+4	; 0x04
    1572:	80 81       	ld	r24, Z
    1574:	91 81       	ldd	r25, Z+1	; 0x01
    1576:	9e 83       	std	Y+6, r25	; 0x06
    1578:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
    157a:	81 e0       	ldi	r24, 0x01	; 1
    157c:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    157e:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>
    1582:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
    1584:	8f 85       	ldd	r24, Y+15	; 0x0f
    1586:	98 89       	ldd	r25, Y+16	; 0x10
    1588:	00 97       	sbiw	r24, 0x00	; 0
    158a:	09 f4       	brne	.+2      	; 0x158e <xEventGroupSync+0xe8>
    158c:	3a c0       	rjmp	.+116    	; 0x1602 <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
    158e:	8a 81       	ldd	r24, Y+2	; 0x02
    1590:	88 23       	and	r24, r24
    1592:	11 f4       	brne	.+4      	; 0x1598 <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
    1594:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1598:	0e 94 c7 29 	call	0x538e	; 0x538e <uxTaskResetEventItemValue>
    159c:	9e 83       	std	Y+6, r25	; 0x06
    159e:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    15a0:	8d 81       	ldd	r24, Y+5	; 0x05
    15a2:	9e 81       	ldd	r25, Y+6	; 0x06
    15a4:	80 70       	andi	r24, 0x00	; 0
    15a6:	92 70       	andi	r25, 0x02	; 2
    15a8:	00 97       	sbiw	r24, 0x00	; 0
    15aa:	31 f5       	brne	.+76     	; 0x15f8 <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    15ac:	0f b6       	in	r0, 0x3f	; 63
    15ae:	f8 94       	cli
    15b0:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    15b2:	eb 81       	ldd	r30, Y+3	; 0x03
    15b4:	fc 81       	ldd	r31, Y+4	; 0x04
    15b6:	80 81       	ld	r24, Z
    15b8:	91 81       	ldd	r25, Z+1	; 0x01
    15ba:	9e 83       	std	Y+6, r25	; 0x06
    15bc:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    15be:	2d 81       	ldd	r18, Y+5	; 0x05
    15c0:	3e 81       	ldd	r19, Y+6	; 0x06
    15c2:	8d 85       	ldd	r24, Y+13	; 0x0d
    15c4:	9e 85       	ldd	r25, Y+14	; 0x0e
    15c6:	28 23       	and	r18, r24
    15c8:	39 23       	and	r19, r25
    15ca:	8d 85       	ldd	r24, Y+13	; 0x0d
    15cc:	9e 85       	ldd	r25, Y+14	; 0x0e
    15ce:	28 17       	cp	r18, r24
    15d0:	39 07       	cpc	r19, r25
    15d2:	71 f4       	brne	.+28     	; 0x15f0 <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    15d4:	eb 81       	ldd	r30, Y+3	; 0x03
    15d6:	fc 81       	ldd	r31, Y+4	; 0x04
    15d8:	20 81       	ld	r18, Z
    15da:	31 81       	ldd	r19, Z+1	; 0x01
    15dc:	8d 85       	ldd	r24, Y+13	; 0x0d
    15de:	9e 85       	ldd	r25, Y+14	; 0x0e
    15e0:	80 95       	com	r24
    15e2:	90 95       	com	r25
    15e4:	82 23       	and	r24, r18
    15e6:	93 23       	and	r25, r19
    15e8:	eb 81       	ldd	r30, Y+3	; 0x03
    15ea:	fc 81       	ldd	r31, Y+4	; 0x04
    15ec:	91 83       	std	Z+1, r25	; 0x01
    15ee:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    15f0:	0f 90       	pop	r0
    15f2:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
    15f4:	81 e0       	ldi	r24, 0x01	; 1
    15f6:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    15f8:	8d 81       	ldd	r24, Y+5	; 0x05
    15fa:	9e 81       	ldd	r25, Y+6	; 0x06
    15fc:	90 70       	andi	r25, 0x00	; 0
    15fe:	9e 83       	std	Y+6, r25	; 0x06
    1600:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    1602:	8d 81       	ldd	r24, Y+5	; 0x05
    1604:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1606:	60 96       	adiw	r28, 0x10	; 16
    1608:	0f b6       	in	r0, 0x3f	; 63
    160a:	f8 94       	cli
    160c:	de bf       	out	0x3e, r29	; 62
    160e:	0f be       	out	0x3f, r0	; 63
    1610:	cd bf       	out	0x3d, r28	; 61
    1612:	cf 91       	pop	r28
    1614:	df 91       	pop	r29
    1616:	08 95       	ret

00001618 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    1618:	0f 93       	push	r16
    161a:	1f 93       	push	r17
    161c:	df 93       	push	r29
    161e:	cf 93       	push	r28
    1620:	cd b7       	in	r28, 0x3d	; 61
    1622:	de b7       	in	r29, 0x3e	; 62
    1624:	63 97       	sbiw	r28, 0x13	; 19
    1626:	0f b6       	in	r0, 0x3f	; 63
    1628:	f8 94       	cli
    162a:	de bf       	out	0x3e, r29	; 62
    162c:	0f be       	out	0x3f, r0	; 63
    162e:	cd bf       	out	0x3d, r28	; 61
    1630:	9d 87       	std	Y+13, r25	; 0x0d
    1632:	8c 87       	std	Y+12, r24	; 0x0c
    1634:	7f 87       	std	Y+15, r23	; 0x0f
    1636:	6e 87       	std	Y+14, r22	; 0x0e
    1638:	48 8b       	std	Y+16, r20	; 0x10
    163a:	29 8b       	std	Y+17, r18	; 0x11
    163c:	1b 8b       	std	Y+19, r17	; 0x13
    163e:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
    1640:	8c 85       	ldd	r24, Y+12	; 0x0c
    1642:	9d 85       	ldd	r25, Y+13	; 0x0d
    1644:	9b 87       	std	Y+11, r25	; 0x0b
    1646:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
    1648:	1f 82       	std	Y+7, r1	; 0x07
    164a:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    164c:	1b 82       	std	Y+3, r1	; 0x03
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    164e:	0e 94 30 1c 	call	0x3860	; 0x3860 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1652:	ea 85       	ldd	r30, Y+10	; 0x0a
    1654:	fb 85       	ldd	r31, Y+11	; 0x0b
    1656:	80 81       	ld	r24, Z
    1658:	91 81       	ldd	r25, Z+1	; 0x01
    165a:	9a 83       	std	Y+2, r25	; 0x02
    165c:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    165e:	89 81       	ldd	r24, Y+1	; 0x01
    1660:	9a 81       	ldd	r25, Y+2	; 0x02
    1662:	2e 85       	ldd	r18, Y+14	; 0x0e
    1664:	3f 85       	ldd	r19, Y+15	; 0x0f
    1666:	b9 01       	movw	r22, r18
    1668:	49 89       	ldd	r20, Y+17	; 0x11
    166a:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <prvTestWaitCondition>
    166e:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
    1670:	8d 81       	ldd	r24, Y+5	; 0x05
    1672:	88 23       	and	r24, r24
    1674:	c1 f0       	breq	.+48     	; 0x16a6 <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    1676:	89 81       	ldd	r24, Y+1	; 0x01
    1678:	9a 81       	ldd	r25, Y+2	; 0x02
    167a:	99 87       	std	Y+9, r25	; 0x09
    167c:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
    167e:	1b 8a       	std	Y+19, r1	; 0x13
    1680:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    1682:	88 89       	ldd	r24, Y+16	; 0x10
    1684:	88 23       	and	r24, r24
    1686:	e9 f1       	breq	.+122    	; 0x1702 <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1688:	ea 85       	ldd	r30, Y+10	; 0x0a
    168a:	fb 85       	ldd	r31, Y+11	; 0x0b
    168c:	20 81       	ld	r18, Z
    168e:	31 81       	ldd	r19, Z+1	; 0x01
    1690:	8e 85       	ldd	r24, Y+14	; 0x0e
    1692:	9f 85       	ldd	r25, Y+15	; 0x0f
    1694:	80 95       	com	r24
    1696:	90 95       	com	r25
    1698:	82 23       	and	r24, r18
    169a:	93 23       	and	r25, r19
    169c:	ea 85       	ldd	r30, Y+10	; 0x0a
    169e:	fb 85       	ldd	r31, Y+11	; 0x0b
    16a0:	91 83       	std	Z+1, r25	; 0x01
    16a2:	80 83       	st	Z, r24
    16a4:	2e c0       	rjmp	.+92     	; 0x1702 <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    16a6:	8a 89       	ldd	r24, Y+18	; 0x12
    16a8:	9b 89       	ldd	r25, Y+19	; 0x13
    16aa:	00 97       	sbiw	r24, 0x00	; 0
    16ac:	39 f4       	brne	.+14     	; 0x16bc <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    16ae:	89 81       	ldd	r24, Y+1	; 0x01
    16b0:	9a 81       	ldd	r25, Y+2	; 0x02
    16b2:	99 87       	std	Y+9, r25	; 0x09
    16b4:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
    16b6:	81 e0       	ldi	r24, 0x01	; 1
    16b8:	8b 83       	std	Y+3, r24	; 0x03
    16ba:	23 c0       	rjmp	.+70     	; 0x1702 <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    16bc:	88 89       	ldd	r24, Y+16	; 0x10
    16be:	88 23       	and	r24, r24
    16c0:	29 f0       	breq	.+10     	; 0x16cc <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    16c2:	8e 81       	ldd	r24, Y+6	; 0x06
    16c4:	9f 81       	ldd	r25, Y+7	; 0x07
    16c6:	91 60       	ori	r25, 0x01	; 1
    16c8:	9f 83       	std	Y+7, r25	; 0x07
    16ca:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    16cc:	89 89       	ldd	r24, Y+17	; 0x11
    16ce:	88 23       	and	r24, r24
    16d0:	29 f0       	breq	.+10     	; 0x16dc <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    16d2:	8e 81       	ldd	r24, Y+6	; 0x06
    16d4:	9f 81       	ldd	r25, Y+7	; 0x07
    16d6:	94 60       	ori	r25, 0x04	; 4
    16d8:	9f 83       	std	Y+7, r25	; 0x07
    16da:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    16dc:	8a 85       	ldd	r24, Y+10	; 0x0a
    16de:	9b 85       	ldd	r25, Y+11	; 0x0b
    16e0:	bc 01       	movw	r22, r24
    16e2:	6e 5f       	subi	r22, 0xFE	; 254
    16e4:	7f 4f       	sbci	r23, 0xFF	; 255
    16e6:	2e 85       	ldd	r18, Y+14	; 0x0e
    16e8:	3f 85       	ldd	r19, Y+15	; 0x0f
    16ea:	8e 81       	ldd	r24, Y+6	; 0x06
    16ec:	9f 81       	ldd	r25, Y+7	; 0x07
    16ee:	28 2b       	or	r18, r24
    16f0:	39 2b       	or	r19, r25
    16f2:	4a 89       	ldd	r20, Y+18	; 0x12
    16f4:	5b 89       	ldd	r21, Y+19	; 0x13
    16f6:	cb 01       	movw	r24, r22
    16f8:	b9 01       	movw	r22, r18
    16fa:	0e 94 4b 21 	call	0x4296	; 0x4296 <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    16fe:	19 86       	std	Y+9, r1	; 0x09
    1700:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    1702:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>
    1706:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
    1708:	8a 89       	ldd	r24, Y+18	; 0x12
    170a:	9b 89       	ldd	r25, Y+19	; 0x13
    170c:	00 97       	sbiw	r24, 0x00	; 0
    170e:	09 f4       	brne	.+2      	; 0x1712 <xEventGroupWaitBits+0xfa>
    1710:	3c c0       	rjmp	.+120    	; 0x178a <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
    1712:	8c 81       	ldd	r24, Y+4	; 0x04
    1714:	88 23       	and	r24, r24
    1716:	11 f4       	brne	.+4      	; 0x171c <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
    1718:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    171c:	0e 94 c7 29 	call	0x538e	; 0x538e <uxTaskResetEventItemValue>
    1720:	99 87       	std	Y+9, r25	; 0x09
    1722:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1724:	88 85       	ldd	r24, Y+8	; 0x08
    1726:	99 85       	ldd	r25, Y+9	; 0x09
    1728:	80 70       	andi	r24, 0x00	; 0
    172a:	92 70       	andi	r25, 0x02	; 2
    172c:	00 97       	sbiw	r24, 0x00	; 0
    172e:	41 f5       	brne	.+80     	; 0x1780 <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
    1730:	0f b6       	in	r0, 0x3f	; 63
    1732:	f8 94       	cli
    1734:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1736:	ea 85       	ldd	r30, Y+10	; 0x0a
    1738:	fb 85       	ldd	r31, Y+11	; 0x0b
    173a:	80 81       	ld	r24, Z
    173c:	91 81       	ldd	r25, Z+1	; 0x01
    173e:	99 87       	std	Y+9, r25	; 0x09
    1740:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    1742:	88 85       	ldd	r24, Y+8	; 0x08
    1744:	99 85       	ldd	r25, Y+9	; 0x09
    1746:	2e 85       	ldd	r18, Y+14	; 0x0e
    1748:	3f 85       	ldd	r19, Y+15	; 0x0f
    174a:	b9 01       	movw	r22, r18
    174c:	49 89       	ldd	r20, Y+17	; 0x11
    174e:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <prvTestWaitCondition>
    1752:	88 23       	and	r24, r24
    1754:	89 f0       	breq	.+34     	; 0x1778 <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
    1756:	88 89       	ldd	r24, Y+16	; 0x10
    1758:	88 23       	and	r24, r24
    175a:	71 f0       	breq	.+28     	; 0x1778 <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    175c:	ea 85       	ldd	r30, Y+10	; 0x0a
    175e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1760:	20 81       	ld	r18, Z
    1762:	31 81       	ldd	r19, Z+1	; 0x01
    1764:	8e 85       	ldd	r24, Y+14	; 0x0e
    1766:	9f 85       	ldd	r25, Y+15	; 0x0f
    1768:	80 95       	com	r24
    176a:	90 95       	com	r25
    176c:	82 23       	and	r24, r18
    176e:	93 23       	and	r25, r19
    1770:	ea 85       	ldd	r30, Y+10	; 0x0a
    1772:	fb 85       	ldd	r31, Y+11	; 0x0b
    1774:	91 83       	std	Z+1, r25	; 0x01
    1776:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    1778:	81 e0       	ldi	r24, 0x01	; 1
    177a:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    177c:	0f 90       	pop	r0
    177e:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1780:	88 85       	ldd	r24, Y+8	; 0x08
    1782:	99 85       	ldd	r25, Y+9	; 0x09
    1784:	90 70       	andi	r25, 0x00	; 0
    1786:	99 87       	std	Y+9, r25	; 0x09
    1788:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    178a:	88 85       	ldd	r24, Y+8	; 0x08
    178c:	99 85       	ldd	r25, Y+9	; 0x09
}
    178e:	63 96       	adiw	r28, 0x13	; 19
    1790:	0f b6       	in	r0, 0x3f	; 63
    1792:	f8 94       	cli
    1794:	de bf       	out	0x3e, r29	; 62
    1796:	0f be       	out	0x3f, r0	; 63
    1798:	cd bf       	out	0x3d, r28	; 61
    179a:	cf 91       	pop	r28
    179c:	df 91       	pop	r29
    179e:	1f 91       	pop	r17
    17a0:	0f 91       	pop	r16
    17a2:	08 95       	ret

000017a4 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    17a4:	df 93       	push	r29
    17a6:	cf 93       	push	r28
    17a8:	cd b7       	in	r28, 0x3d	; 61
    17aa:	de b7       	in	r29, 0x3e	; 62
    17ac:	28 97       	sbiw	r28, 0x08	; 8
    17ae:	0f b6       	in	r0, 0x3f	; 63
    17b0:	f8 94       	cli
    17b2:	de bf       	out	0x3e, r29	; 62
    17b4:	0f be       	out	0x3f, r0	; 63
    17b6:	cd bf       	out	0x3d, r28	; 61
    17b8:	9e 83       	std	Y+6, r25	; 0x06
    17ba:	8d 83       	std	Y+5, r24	; 0x05
    17bc:	78 87       	std	Y+8, r23	; 0x08
    17be:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    17c0:	8d 81       	ldd	r24, Y+5	; 0x05
    17c2:	9e 81       	ldd	r25, Y+6	; 0x06
    17c4:	9c 83       	std	Y+4, r25	; 0x04
    17c6:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    17c8:	0f b6       	in	r0, 0x3f	; 63
    17ca:	f8 94       	cli
    17cc:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    17ce:	eb 81       	ldd	r30, Y+3	; 0x03
    17d0:	fc 81       	ldd	r31, Y+4	; 0x04
    17d2:	80 81       	ld	r24, Z
    17d4:	91 81       	ldd	r25, Z+1	; 0x01
    17d6:	9a 83       	std	Y+2, r25	; 0x02
    17d8:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    17da:	eb 81       	ldd	r30, Y+3	; 0x03
    17dc:	fc 81       	ldd	r31, Y+4	; 0x04
    17de:	20 81       	ld	r18, Z
    17e0:	31 81       	ldd	r19, Z+1	; 0x01
    17e2:	8f 81       	ldd	r24, Y+7	; 0x07
    17e4:	98 85       	ldd	r25, Y+8	; 0x08
    17e6:	80 95       	com	r24
    17e8:	90 95       	com	r25
    17ea:	82 23       	and	r24, r18
    17ec:	93 23       	and	r25, r19
    17ee:	eb 81       	ldd	r30, Y+3	; 0x03
    17f0:	fc 81       	ldd	r31, Y+4	; 0x04
    17f2:	91 83       	std	Z+1, r25	; 0x01
    17f4:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    17f6:	0f 90       	pop	r0
    17f8:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    17fa:	89 81       	ldd	r24, Y+1	; 0x01
    17fc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    17fe:	28 96       	adiw	r28, 0x08	; 8
    1800:	0f b6       	in	r0, 0x3f	; 63
    1802:	f8 94       	cli
    1804:	de bf       	out	0x3e, r29	; 62
    1806:	0f be       	out	0x3f, r0	; 63
    1808:	cd bf       	out	0x3d, r28	; 61
    180a:	cf 91       	pop	r28
    180c:	df 91       	pop	r29
    180e:	08 95       	ret

00001810 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    1810:	df 93       	push	r29
    1812:	cf 93       	push	r28
    1814:	cd b7       	in	r28, 0x3d	; 61
    1816:	de b7       	in	r29, 0x3e	; 62
    1818:	27 97       	sbiw	r28, 0x07	; 7
    181a:	0f b6       	in	r0, 0x3f	; 63
    181c:	f8 94       	cli
    181e:	de bf       	out	0x3e, r29	; 62
    1820:	0f be       	out	0x3f, r0	; 63
    1822:	cd bf       	out	0x3d, r28	; 61
    1824:	9f 83       	std	Y+7, r25	; 0x07
    1826:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    1828:	8e 81       	ldd	r24, Y+6	; 0x06
    182a:	9f 81       	ldd	r25, Y+7	; 0x07
    182c:	9c 83       	std	Y+4, r25	; 0x04
    182e:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1830:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    1832:	eb 81       	ldd	r30, Y+3	; 0x03
    1834:	fc 81       	ldd	r31, Y+4	; 0x04
    1836:	80 81       	ld	r24, Z
    1838:	91 81       	ldd	r25, Z+1	; 0x01
    183a:	9a 83       	std	Y+2, r25	; 0x02
    183c:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    183e:	89 81       	ldd	r24, Y+1	; 0x01
    1840:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    1842:	27 96       	adiw	r28, 0x07	; 7
    1844:	0f b6       	in	r0, 0x3f	; 63
    1846:	f8 94       	cli
    1848:	de bf       	out	0x3e, r29	; 62
    184a:	0f be       	out	0x3f, r0	; 63
    184c:	cd bf       	out	0x3d, r28	; 61
    184e:	cf 91       	pop	r28
    1850:	df 91       	pop	r29
    1852:	08 95       	ret

00001854 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    1854:	df 93       	push	r29
    1856:	cf 93       	push	r28
    1858:	cd b7       	in	r28, 0x3d	; 61
    185a:	de b7       	in	r29, 0x3e	; 62
    185c:	65 97       	sbiw	r28, 0x15	; 21
    185e:	0f b6       	in	r0, 0x3f	; 63
    1860:	f8 94       	cli
    1862:	de bf       	out	0x3e, r29	; 62
    1864:	0f be       	out	0x3f, r0	; 63
    1866:	cd bf       	out	0x3d, r28	; 61
    1868:	9b 8b       	std	Y+19, r25	; 0x13
    186a:	8a 8b       	std	Y+18, r24	; 0x12
    186c:	7d 8b       	std	Y+21, r23	; 0x15
    186e:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    1870:	19 86       	std	Y+9, r1	; 0x09
    1872:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    1874:	8a 89       	ldd	r24, Y+18	; 0x12
    1876:	9b 89       	ldd	r25, Y+19	; 0x13
    1878:	9b 83       	std	Y+3, r25	; 0x03
    187a:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    187c:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    187e:	8a 81       	ldd	r24, Y+2	; 0x02
    1880:	9b 81       	ldd	r25, Y+3	; 0x03
    1882:	02 96       	adiw	r24, 0x02	; 2
    1884:	9b 87       	std	Y+11, r25	; 0x0b
    1886:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1888:	8a 85       	ldd	r24, Y+10	; 0x0a
    188a:	9b 85       	ldd	r25, Y+11	; 0x0b
    188c:	03 96       	adiw	r24, 0x03	; 3
    188e:	9d 87       	std	Y+13, r25	; 0x0d
    1890:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    1892:	0e 94 30 1c 	call	0x3860	; 0x3860 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    1896:	ea 85       	ldd	r30, Y+10	; 0x0a
    1898:	fb 85       	ldd	r31, Y+11	; 0x0b
    189a:	85 81       	ldd	r24, Z+5	; 0x05
    189c:	96 81       	ldd	r25, Z+6	; 0x06
    189e:	99 8b       	std	Y+17, r25	; 0x11
    18a0:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    18a2:	ea 81       	ldd	r30, Y+2	; 0x02
    18a4:	fb 81       	ldd	r31, Y+3	; 0x03
    18a6:	20 81       	ld	r18, Z
    18a8:	31 81       	ldd	r19, Z+1	; 0x01
    18aa:	8c 89       	ldd	r24, Y+20	; 0x14
    18ac:	9d 89       	ldd	r25, Y+21	; 0x15
    18ae:	82 2b       	or	r24, r18
    18b0:	93 2b       	or	r25, r19
    18b2:	ea 81       	ldd	r30, Y+2	; 0x02
    18b4:	fb 81       	ldd	r31, Y+3	; 0x03
    18b6:	91 83       	std	Z+1, r25	; 0x01
    18b8:	80 83       	st	Z, r24
    18ba:	59 c0       	rjmp	.+178    	; 0x196e <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    18bc:	e8 89       	ldd	r30, Y+16	; 0x10
    18be:	f9 89       	ldd	r31, Y+17	; 0x11
    18c0:	82 81       	ldd	r24, Z+2	; 0x02
    18c2:	93 81       	ldd	r25, Z+3	; 0x03
    18c4:	9f 87       	std	Y+15, r25	; 0x0f
    18c6:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    18c8:	e8 89       	ldd	r30, Y+16	; 0x10
    18ca:	f9 89       	ldd	r31, Y+17	; 0x11
    18cc:	80 81       	ld	r24, Z
    18ce:	91 81       	ldd	r25, Z+1	; 0x01
    18d0:	9f 83       	std	Y+7, r25	; 0x07
    18d2:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    18d4:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    18d6:	8e 81       	ldd	r24, Y+6	; 0x06
    18d8:	9f 81       	ldd	r25, Y+7	; 0x07
    18da:	80 70       	andi	r24, 0x00	; 0
    18dc:	9d 83       	std	Y+5, r25	; 0x05
    18de:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    18e0:	8e 81       	ldd	r24, Y+6	; 0x06
    18e2:	9f 81       	ldd	r25, Y+7	; 0x07
    18e4:	90 70       	andi	r25, 0x00	; 0
    18e6:	9f 83       	std	Y+7, r25	; 0x07
    18e8:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    18ea:	8c 81       	ldd	r24, Y+4	; 0x04
    18ec:	9d 81       	ldd	r25, Y+5	; 0x05
    18ee:	80 70       	andi	r24, 0x00	; 0
    18f0:	94 70       	andi	r25, 0x04	; 4
    18f2:	00 97       	sbiw	r24, 0x00	; 0
    18f4:	69 f4       	brne	.+26     	; 0x1910 <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    18f6:	ea 81       	ldd	r30, Y+2	; 0x02
    18f8:	fb 81       	ldd	r31, Y+3	; 0x03
    18fa:	20 81       	ld	r18, Z
    18fc:	31 81       	ldd	r19, Z+1	; 0x01
    18fe:	8e 81       	ldd	r24, Y+6	; 0x06
    1900:	9f 81       	ldd	r25, Y+7	; 0x07
    1902:	82 23       	and	r24, r18
    1904:	93 23       	and	r25, r19
    1906:	00 97       	sbiw	r24, 0x00	; 0
    1908:	91 f0       	breq	.+36     	; 0x192e <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    190a:	81 e0       	ldi	r24, 0x01	; 1
    190c:	89 83       	std	Y+1, r24	; 0x01
    190e:	0f c0       	rjmp	.+30     	; 0x192e <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    1910:	ea 81       	ldd	r30, Y+2	; 0x02
    1912:	fb 81       	ldd	r31, Y+3	; 0x03
    1914:	20 81       	ld	r18, Z
    1916:	31 81       	ldd	r19, Z+1	; 0x01
    1918:	8e 81       	ldd	r24, Y+6	; 0x06
    191a:	9f 81       	ldd	r25, Y+7	; 0x07
    191c:	28 23       	and	r18, r24
    191e:	39 23       	and	r19, r25
    1920:	8e 81       	ldd	r24, Y+6	; 0x06
    1922:	9f 81       	ldd	r25, Y+7	; 0x07
    1924:	28 17       	cp	r18, r24
    1926:	39 07       	cpc	r19, r25
    1928:	11 f4       	brne	.+4      	; 0x192e <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    192a:	81 e0       	ldi	r24, 0x01	; 1
    192c:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    192e:	89 81       	ldd	r24, Y+1	; 0x01
    1930:	88 23       	and	r24, r24
    1932:	c9 f0       	breq	.+50     	; 0x1966 <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1934:	8c 81       	ldd	r24, Y+4	; 0x04
    1936:	9d 81       	ldd	r25, Y+5	; 0x05
    1938:	80 70       	andi	r24, 0x00	; 0
    193a:	91 70       	andi	r25, 0x01	; 1
    193c:	00 97       	sbiw	r24, 0x00	; 0
    193e:	41 f0       	breq	.+16     	; 0x1950 <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    1940:	88 85       	ldd	r24, Y+8	; 0x08
    1942:	99 85       	ldd	r25, Y+9	; 0x09
    1944:	2e 81       	ldd	r18, Y+6	; 0x06
    1946:	3f 81       	ldd	r19, Y+7	; 0x07
    1948:	82 2b       	or	r24, r18
    194a:	93 2b       	or	r25, r19
    194c:	99 87       	std	Y+9, r25	; 0x09
    194e:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    1950:	ea 81       	ldd	r30, Y+2	; 0x02
    1952:	fb 81       	ldd	r31, Y+3	; 0x03
    1954:	80 81       	ld	r24, Z
    1956:	91 81       	ldd	r25, Z+1	; 0x01
    1958:	9c 01       	movw	r18, r24
    195a:	32 60       	ori	r19, 0x02	; 2
    195c:	88 89       	ldd	r24, Y+16	; 0x10
    195e:	99 89       	ldd	r25, Y+17	; 0x11
    1960:	b9 01       	movw	r22, r18
    1962:	0e 94 56 23 	call	0x46ac	; 0x46ac <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    1966:	8e 85       	ldd	r24, Y+14	; 0x0e
    1968:	9f 85       	ldd	r25, Y+15	; 0x0f
    196a:	99 8b       	std	Y+17, r25	; 0x11
    196c:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    196e:	28 89       	ldd	r18, Y+16	; 0x10
    1970:	39 89       	ldd	r19, Y+17	; 0x11
    1972:	8c 85       	ldd	r24, Y+12	; 0x0c
    1974:	9d 85       	ldd	r25, Y+13	; 0x0d
    1976:	28 17       	cp	r18, r24
    1978:	39 07       	cpc	r19, r25
    197a:	09 f0       	breq	.+2      	; 0x197e <xEventGroupSetBits+0x12a>
    197c:	9f cf       	rjmp	.-194    	; 0x18bc <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    197e:	ea 81       	ldd	r30, Y+2	; 0x02
    1980:	fb 81       	ldd	r31, Y+3	; 0x03
    1982:	20 81       	ld	r18, Z
    1984:	31 81       	ldd	r19, Z+1	; 0x01
    1986:	88 85       	ldd	r24, Y+8	; 0x08
    1988:	99 85       	ldd	r25, Y+9	; 0x09
    198a:	80 95       	com	r24
    198c:	90 95       	com	r25
    198e:	82 23       	and	r24, r18
    1990:	93 23       	and	r25, r19
    1992:	ea 81       	ldd	r30, Y+2	; 0x02
    1994:	fb 81       	ldd	r31, Y+3	; 0x03
    1996:	91 83       	std	Z+1, r25	; 0x01
    1998:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    199a:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    199e:	ea 81       	ldd	r30, Y+2	; 0x02
    19a0:	fb 81       	ldd	r31, Y+3	; 0x03
    19a2:	80 81       	ld	r24, Z
    19a4:	91 81       	ldd	r25, Z+1	; 0x01
}
    19a6:	65 96       	adiw	r28, 0x15	; 21
    19a8:	0f b6       	in	r0, 0x3f	; 63
    19aa:	f8 94       	cli
    19ac:	de bf       	out	0x3e, r29	; 62
    19ae:	0f be       	out	0x3f, r0	; 63
    19b0:	cd bf       	out	0x3d, r28	; 61
    19b2:	cf 91       	pop	r28
    19b4:	df 91       	pop	r29
    19b6:	08 95       	ret

000019b8 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    19b8:	df 93       	push	r29
    19ba:	cf 93       	push	r28
    19bc:	00 d0       	rcall	.+0      	; 0x19be <vEventGroupDelete+0x6>
    19be:	00 d0       	rcall	.+0      	; 0x19c0 <vEventGroupDelete+0x8>
    19c0:	00 d0       	rcall	.+0      	; 0x19c2 <vEventGroupDelete+0xa>
    19c2:	cd b7       	in	r28, 0x3d	; 61
    19c4:	de b7       	in	r29, 0x3e	; 62
    19c6:	9e 83       	std	Y+6, r25	; 0x06
    19c8:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    19ca:	8d 81       	ldd	r24, Y+5	; 0x05
    19cc:	9e 81       	ldd	r25, Y+6	; 0x06
    19ce:	9c 83       	std	Y+4, r25	; 0x04
    19d0:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    19d2:	8b 81       	ldd	r24, Y+3	; 0x03
    19d4:	9c 81       	ldd	r25, Y+4	; 0x04
    19d6:	02 96       	adiw	r24, 0x02	; 2
    19d8:	9a 83       	std	Y+2, r25	; 0x02
    19da:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    19dc:	0e 94 30 1c 	call	0x3860	; 0x3860 <vTaskSuspendAll>
    19e0:	08 c0       	rjmp	.+16     	; 0x19f2 <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    19e2:	e9 81       	ldd	r30, Y+1	; 0x01
    19e4:	fa 81       	ldd	r31, Y+2	; 0x02
    19e6:	85 81       	ldd	r24, Z+5	; 0x05
    19e8:	96 81       	ldd	r25, Z+6	; 0x06
    19ea:	60 e0       	ldi	r22, 0x00	; 0
    19ec:	72 e0       	ldi	r23, 0x02	; 2
    19ee:	0e 94 56 23 	call	0x46ac	; 0x46ac <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    19f2:	e9 81       	ldd	r30, Y+1	; 0x01
    19f4:	fa 81       	ldd	r31, Y+2	; 0x02
    19f6:	80 81       	ld	r24, Z
    19f8:	88 23       	and	r24, r24
    19fa:	99 f7       	brne	.-26     	; 0x19e2 <vEventGroupDelete+0x2a>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
    19fc:	8b 81       	ldd	r24, Y+3	; 0x03
    19fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1a00:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
    1a04:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>
}
    1a08:	26 96       	adiw	r28, 0x06	; 6
    1a0a:	0f b6       	in	r0, 0x3f	; 63
    1a0c:	f8 94       	cli
    1a0e:	de bf       	out	0x3e, r29	; 62
    1a10:	0f be       	out	0x3f, r0	; 63
    1a12:	cd bf       	out	0x3d, r28	; 61
    1a14:	cf 91       	pop	r28
    1a16:	df 91       	pop	r29
    1a18:	08 95       	ret

00001a1a <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    1a1a:	df 93       	push	r29
    1a1c:	cf 93       	push	r28
    1a1e:	00 d0       	rcall	.+0      	; 0x1a20 <vEventGroupSetBitsCallback+0x6>
    1a20:	00 d0       	rcall	.+0      	; 0x1a22 <vEventGroupSetBitsCallback+0x8>
    1a22:	00 d0       	rcall	.+0      	; 0x1a24 <vEventGroupSetBitsCallback+0xa>
    1a24:	cd b7       	in	r28, 0x3d	; 61
    1a26:	de b7       	in	r29, 0x3e	; 62
    1a28:	9a 83       	std	Y+2, r25	; 0x02
    1a2a:	89 83       	std	Y+1, r24	; 0x01
    1a2c:	4b 83       	std	Y+3, r20	; 0x03
    1a2e:	5c 83       	std	Y+4, r21	; 0x04
    1a30:	6d 83       	std	Y+5, r22	; 0x05
    1a32:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1a34:	89 81       	ldd	r24, Y+1	; 0x01
    1a36:	9a 81       	ldd	r25, Y+2	; 0x02
    1a38:	2b 81       	ldd	r18, Y+3	; 0x03
    1a3a:	3c 81       	ldd	r19, Y+4	; 0x04
    1a3c:	b9 01       	movw	r22, r18
    1a3e:	0e 94 2a 0c 	call	0x1854	; 0x1854 <xEventGroupSetBits>
}
    1a42:	26 96       	adiw	r28, 0x06	; 6
    1a44:	0f b6       	in	r0, 0x3f	; 63
    1a46:	f8 94       	cli
    1a48:	de bf       	out	0x3e, r29	; 62
    1a4a:	0f be       	out	0x3f, r0	; 63
    1a4c:	cd bf       	out	0x3d, r28	; 61
    1a4e:	cf 91       	pop	r28
    1a50:	df 91       	pop	r29
    1a52:	08 95       	ret

00001a54 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    1a54:	df 93       	push	r29
    1a56:	cf 93       	push	r28
    1a58:	00 d0       	rcall	.+0      	; 0x1a5a <vEventGroupClearBitsCallback+0x6>
    1a5a:	00 d0       	rcall	.+0      	; 0x1a5c <vEventGroupClearBitsCallback+0x8>
    1a5c:	00 d0       	rcall	.+0      	; 0x1a5e <vEventGroupClearBitsCallback+0xa>
    1a5e:	cd b7       	in	r28, 0x3d	; 61
    1a60:	de b7       	in	r29, 0x3e	; 62
    1a62:	9a 83       	std	Y+2, r25	; 0x02
    1a64:	89 83       	std	Y+1, r24	; 0x01
    1a66:	4b 83       	std	Y+3, r20	; 0x03
    1a68:	5c 83       	std	Y+4, r21	; 0x04
    1a6a:	6d 83       	std	Y+5, r22	; 0x05
    1a6c:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1a6e:	89 81       	ldd	r24, Y+1	; 0x01
    1a70:	9a 81       	ldd	r25, Y+2	; 0x02
    1a72:	2b 81       	ldd	r18, Y+3	; 0x03
    1a74:	3c 81       	ldd	r19, Y+4	; 0x04
    1a76:	b9 01       	movw	r22, r18
    1a78:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <xEventGroupClearBits>
}
    1a7c:	26 96       	adiw	r28, 0x06	; 6
    1a7e:	0f b6       	in	r0, 0x3f	; 63
    1a80:	f8 94       	cli
    1a82:	de bf       	out	0x3e, r29	; 62
    1a84:	0f be       	out	0x3f, r0	; 63
    1a86:	cd bf       	out	0x3d, r28	; 61
    1a88:	cf 91       	pop	r28
    1a8a:	df 91       	pop	r29
    1a8c:	08 95       	ret

00001a8e <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    1a8e:	df 93       	push	r29
    1a90:	cf 93       	push	r28
    1a92:	00 d0       	rcall	.+0      	; 0x1a94 <prvTestWaitCondition+0x6>
    1a94:	00 d0       	rcall	.+0      	; 0x1a96 <prvTestWaitCondition+0x8>
    1a96:	00 d0       	rcall	.+0      	; 0x1a98 <prvTestWaitCondition+0xa>
    1a98:	cd b7       	in	r28, 0x3d	; 61
    1a9a:	de b7       	in	r29, 0x3e	; 62
    1a9c:	9b 83       	std	Y+3, r25	; 0x03
    1a9e:	8a 83       	std	Y+2, r24	; 0x02
    1aa0:	7d 83       	std	Y+5, r23	; 0x05
    1aa2:	6c 83       	std	Y+4, r22	; 0x04
    1aa4:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    1aa6:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    1aa8:	8e 81       	ldd	r24, Y+6	; 0x06
    1aaa:	88 23       	and	r24, r24
    1aac:	59 f4       	brne	.+22     	; 0x1ac4 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1aae:	8a 81       	ldd	r24, Y+2	; 0x02
    1ab0:	9b 81       	ldd	r25, Y+3	; 0x03
    1ab2:	2c 81       	ldd	r18, Y+4	; 0x04
    1ab4:	3d 81       	ldd	r19, Y+5	; 0x05
    1ab6:	82 23       	and	r24, r18
    1ab8:	93 23       	and	r25, r19
    1aba:	00 97       	sbiw	r24, 0x00	; 0
    1abc:	81 f0       	breq	.+32     	; 0x1ade <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    1abe:	81 e0       	ldi	r24, 0x01	; 1
    1ac0:	89 83       	std	Y+1, r24	; 0x01
    1ac2:	0d c0       	rjmp	.+26     	; 0x1ade <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1ac4:	2a 81       	ldd	r18, Y+2	; 0x02
    1ac6:	3b 81       	ldd	r19, Y+3	; 0x03
    1ac8:	8c 81       	ldd	r24, Y+4	; 0x04
    1aca:	9d 81       	ldd	r25, Y+5	; 0x05
    1acc:	28 23       	and	r18, r24
    1ace:	39 23       	and	r19, r25
    1ad0:	8c 81       	ldd	r24, Y+4	; 0x04
    1ad2:	9d 81       	ldd	r25, Y+5	; 0x05
    1ad4:	28 17       	cp	r18, r24
    1ad6:	39 07       	cpc	r19, r25
    1ad8:	11 f4       	brne	.+4      	; 0x1ade <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    1ada:	81 e0       	ldi	r24, 0x01	; 1
    1adc:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    1ade:	89 81       	ldd	r24, Y+1	; 0x01
}
    1ae0:	26 96       	adiw	r28, 0x06	; 6
    1ae2:	0f b6       	in	r0, 0x3f	; 63
    1ae4:	f8 94       	cli
    1ae6:	de bf       	out	0x3e, r29	; 62
    1ae8:	0f be       	out	0x3f, r0	; 63
    1aea:	cd bf       	out	0x3d, r28	; 61
    1aec:	cf 91       	pop	r28
    1aee:	df 91       	pop	r29
    1af0:	08 95       	ret

00001af2 <uxEventGroupGetNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

    UBaseType_t uxEventGroupGetNumber( void * xEventGroup )
    {
    1af2:	df 93       	push	r29
    1af4:	cf 93       	push	r28
    1af6:	00 d0       	rcall	.+0      	; 0x1af8 <uxEventGroupGetNumber+0x6>
    1af8:	00 d0       	rcall	.+0      	; 0x1afa <uxEventGroupGetNumber+0x8>
    1afa:	0f 92       	push	r0
    1afc:	cd b7       	in	r28, 0x3d	; 61
    1afe:	de b7       	in	r29, 0x3e	; 62
    1b00:	9d 83       	std	Y+5, r25	; 0x05
    1b02:	8c 83       	std	Y+4, r24	; 0x04
        UBaseType_t xReturn;
        EventGroup_t const * pxEventBits = ( EventGroup_t * ) xEventGroup; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */
    1b04:	8c 81       	ldd	r24, Y+4	; 0x04
    1b06:	9d 81       	ldd	r25, Y+5	; 0x05
    1b08:	9a 83       	std	Y+2, r25	; 0x02
    1b0a:	89 83       	std	Y+1, r24	; 0x01

        if( xEventGroup == NULL )
    1b0c:	8c 81       	ldd	r24, Y+4	; 0x04
    1b0e:	9d 81       	ldd	r25, Y+5	; 0x05
    1b10:	00 97       	sbiw	r24, 0x00	; 0
    1b12:	11 f4       	brne	.+4      	; 0x1b18 <uxEventGroupGetNumber+0x26>
        {
            xReturn = 0;
    1b14:	1b 82       	std	Y+3, r1	; 0x03
    1b16:	04 c0       	rjmp	.+8      	; 0x1b20 <uxEventGroupGetNumber+0x2e>
        }
        else
        {
            xReturn = pxEventBits->uxEventGroupNumber;
    1b18:	e9 81       	ldd	r30, Y+1	; 0x01
    1b1a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b1c:	83 85       	ldd	r24, Z+11	; 0x0b
    1b1e:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    1b20:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    1b22:	0f 90       	pop	r0
    1b24:	0f 90       	pop	r0
    1b26:	0f 90       	pop	r0
    1b28:	0f 90       	pop	r0
    1b2a:	0f 90       	pop	r0
    1b2c:	cf 91       	pop	r28
    1b2e:	df 91       	pop	r29
    1b30:	08 95       	ret

00001b32 <vEventGroupSetNumber>:

#if ( configUSE_TRACE_FACILITY == 1 )

    void vEventGroupSetNumber( void * xEventGroup,
                               UBaseType_t uxEventGroupNumber )
    {
    1b32:	df 93       	push	r29
    1b34:	cf 93       	push	r28
    1b36:	00 d0       	rcall	.+0      	; 0x1b38 <vEventGroupSetNumber+0x6>
    1b38:	0f 92       	push	r0
    1b3a:	cd b7       	in	r28, 0x3d	; 61
    1b3c:	de b7       	in	r29, 0x3e	; 62
    1b3e:	9a 83       	std	Y+2, r25	; 0x02
    1b40:	89 83       	std	Y+1, r24	; 0x01
    1b42:	6b 83       	std	Y+3, r22	; 0x03
        ( ( EventGroup_t * ) xEventGroup )->uxEventGroupNumber = uxEventGroupNumber; /*lint !e9087 !e9079 EventGroupHandle_t is a pointer to an EventGroup_t, but EventGroupHandle_t is kept opaque outside of this file for data hiding purposes. */
    1b44:	e9 81       	ldd	r30, Y+1	; 0x01
    1b46:	fa 81       	ldd	r31, Y+2	; 0x02
    1b48:	8b 81       	ldd	r24, Y+3	; 0x03
    1b4a:	83 87       	std	Z+11, r24	; 0x0b
    }
    1b4c:	0f 90       	pop	r0
    1b4e:	0f 90       	pop	r0
    1b50:	0f 90       	pop	r0
    1b52:	cf 91       	pop	r28
    1b54:	df 91       	pop	r29
    1b56:	08 95       	ret

00001b58 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1b58:	df 93       	push	r29
    1b5a:	cf 93       	push	r28
    1b5c:	00 d0       	rcall	.+0      	; 0x1b5e <vListInitialise+0x6>
    1b5e:	cd b7       	in	r28, 0x3d	; 61
    1b60:	de b7       	in	r29, 0x3e	; 62
    1b62:	9a 83       	std	Y+2, r25	; 0x02
    1b64:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b66:	89 81       	ldd	r24, Y+1	; 0x01
    1b68:	9a 81       	ldd	r25, Y+2	; 0x02
    1b6a:	03 96       	adiw	r24, 0x03	; 3
    1b6c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b6e:	fa 81       	ldd	r31, Y+2	; 0x02
    1b70:	92 83       	std	Z+2, r25	; 0x02
    1b72:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    1b74:	e9 81       	ldd	r30, Y+1	; 0x01
    1b76:	fa 81       	ldd	r31, Y+2	; 0x02
    1b78:	8f ef       	ldi	r24, 0xFF	; 255
    1b7a:	9f ef       	ldi	r25, 0xFF	; 255
    1b7c:	94 83       	std	Z+4, r25	; 0x04
    1b7e:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b80:	89 81       	ldd	r24, Y+1	; 0x01
    1b82:	9a 81       	ldd	r25, Y+2	; 0x02
    1b84:	03 96       	adiw	r24, 0x03	; 3
    1b86:	e9 81       	ldd	r30, Y+1	; 0x01
    1b88:	fa 81       	ldd	r31, Y+2	; 0x02
    1b8a:	96 83       	std	Z+6, r25	; 0x06
    1b8c:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b8e:	89 81       	ldd	r24, Y+1	; 0x01
    1b90:	9a 81       	ldd	r25, Y+2	; 0x02
    1b92:	03 96       	adiw	r24, 0x03	; 3
    1b94:	e9 81       	ldd	r30, Y+1	; 0x01
    1b96:	fa 81       	ldd	r31, Y+2	; 0x02
    1b98:	90 87       	std	Z+8, r25	; 0x08
    1b9a:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1b9c:	e9 81       	ldd	r30, Y+1	; 0x01
    1b9e:	fa 81       	ldd	r31, Y+2	; 0x02
    1ba0:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1ba2:	0f 90       	pop	r0
    1ba4:	0f 90       	pop	r0
    1ba6:	cf 91       	pop	r28
    1ba8:	df 91       	pop	r29
    1baa:	08 95       	ret

00001bac <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1bac:	df 93       	push	r29
    1bae:	cf 93       	push	r28
    1bb0:	00 d0       	rcall	.+0      	; 0x1bb2 <vListInitialiseItem+0x6>
    1bb2:	cd b7       	in	r28, 0x3d	; 61
    1bb4:	de b7       	in	r29, 0x3e	; 62
    1bb6:	9a 83       	std	Y+2, r25	; 0x02
    1bb8:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    1bba:	e9 81       	ldd	r30, Y+1	; 0x01
    1bbc:	fa 81       	ldd	r31, Y+2	; 0x02
    1bbe:	11 86       	std	Z+9, r1	; 0x09
    1bc0:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1bc2:	0f 90       	pop	r0
    1bc4:	0f 90       	pop	r0
    1bc6:	cf 91       	pop	r28
    1bc8:	df 91       	pop	r29
    1bca:	08 95       	ret

00001bcc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    1bcc:	df 93       	push	r29
    1bce:	cf 93       	push	r28
    1bd0:	00 d0       	rcall	.+0      	; 0x1bd2 <vListInsertEnd+0x6>
    1bd2:	00 d0       	rcall	.+0      	; 0x1bd4 <vListInsertEnd+0x8>
    1bd4:	00 d0       	rcall	.+0      	; 0x1bd6 <vListInsertEnd+0xa>
    1bd6:	cd b7       	in	r28, 0x3d	; 61
    1bd8:	de b7       	in	r29, 0x3e	; 62
    1bda:	9c 83       	std	Y+4, r25	; 0x04
    1bdc:	8b 83       	std	Y+3, r24	; 0x03
    1bde:	7e 83       	std	Y+6, r23	; 0x06
    1be0:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    1be2:	eb 81       	ldd	r30, Y+3	; 0x03
    1be4:	fc 81       	ldd	r31, Y+4	; 0x04
    1be6:	81 81       	ldd	r24, Z+1	; 0x01
    1be8:	92 81       	ldd	r25, Z+2	; 0x02
    1bea:	9a 83       	std	Y+2, r25	; 0x02
    1bec:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    1bee:	ed 81       	ldd	r30, Y+5	; 0x05
    1bf0:	fe 81       	ldd	r31, Y+6	; 0x06
    1bf2:	89 81       	ldd	r24, Y+1	; 0x01
    1bf4:	9a 81       	ldd	r25, Y+2	; 0x02
    1bf6:	93 83       	std	Z+3, r25	; 0x03
    1bf8:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1bfa:	e9 81       	ldd	r30, Y+1	; 0x01
    1bfc:	fa 81       	ldd	r31, Y+2	; 0x02
    1bfe:	84 81       	ldd	r24, Z+4	; 0x04
    1c00:	95 81       	ldd	r25, Z+5	; 0x05
    1c02:	ed 81       	ldd	r30, Y+5	; 0x05
    1c04:	fe 81       	ldd	r31, Y+6	; 0x06
    1c06:	95 83       	std	Z+5, r25	; 0x05
    1c08:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1c0a:	e9 81       	ldd	r30, Y+1	; 0x01
    1c0c:	fa 81       	ldd	r31, Y+2	; 0x02
    1c0e:	04 80       	ldd	r0, Z+4	; 0x04
    1c10:	f5 81       	ldd	r31, Z+5	; 0x05
    1c12:	e0 2d       	mov	r30, r0
    1c14:	8d 81       	ldd	r24, Y+5	; 0x05
    1c16:	9e 81       	ldd	r25, Y+6	; 0x06
    1c18:	93 83       	std	Z+3, r25	; 0x03
    1c1a:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    1c1c:	e9 81       	ldd	r30, Y+1	; 0x01
    1c1e:	fa 81       	ldd	r31, Y+2	; 0x02
    1c20:	8d 81       	ldd	r24, Y+5	; 0x05
    1c22:	9e 81       	ldd	r25, Y+6	; 0x06
    1c24:	95 83       	std	Z+5, r25	; 0x05
    1c26:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    1c28:	ed 81       	ldd	r30, Y+5	; 0x05
    1c2a:	fe 81       	ldd	r31, Y+6	; 0x06
    1c2c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c2e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c30:	91 87       	std	Z+9, r25	; 0x09
    1c32:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1c34:	eb 81       	ldd	r30, Y+3	; 0x03
    1c36:	fc 81       	ldd	r31, Y+4	; 0x04
    1c38:	80 81       	ld	r24, Z
    1c3a:	8f 5f       	subi	r24, 0xFF	; 255
    1c3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1c40:	80 83       	st	Z, r24
}
    1c42:	26 96       	adiw	r28, 0x06	; 6
    1c44:	0f b6       	in	r0, 0x3f	; 63
    1c46:	f8 94       	cli
    1c48:	de bf       	out	0x3e, r29	; 62
    1c4a:	0f be       	out	0x3f, r0	; 63
    1c4c:	cd bf       	out	0x3d, r28	; 61
    1c4e:	cf 91       	pop	r28
    1c50:	df 91       	pop	r29
    1c52:	08 95       	ret

00001c54 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    1c54:	df 93       	push	r29
    1c56:	cf 93       	push	r28
    1c58:	cd b7       	in	r28, 0x3d	; 61
    1c5a:	de b7       	in	r29, 0x3e	; 62
    1c5c:	28 97       	sbiw	r28, 0x08	; 8
    1c5e:	0f b6       	in	r0, 0x3f	; 63
    1c60:	f8 94       	cli
    1c62:	de bf       	out	0x3e, r29	; 62
    1c64:	0f be       	out	0x3f, r0	; 63
    1c66:	cd bf       	out	0x3d, r28	; 61
    1c68:	9e 83       	std	Y+6, r25	; 0x06
    1c6a:	8d 83       	std	Y+5, r24	; 0x05
    1c6c:	78 87       	std	Y+8, r23	; 0x08
    1c6e:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1c70:	ef 81       	ldd	r30, Y+7	; 0x07
    1c72:	f8 85       	ldd	r31, Y+8	; 0x08
    1c74:	80 81       	ld	r24, Z
    1c76:	91 81       	ldd	r25, Z+1	; 0x01
    1c78:	9a 83       	std	Y+2, r25	; 0x02
    1c7a:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1c7c:	89 81       	ldd	r24, Y+1	; 0x01
    1c7e:	9a 81       	ldd	r25, Y+2	; 0x02
    1c80:	2f ef       	ldi	r18, 0xFF	; 255
    1c82:	8f 3f       	cpi	r24, 0xFF	; 255
    1c84:	92 07       	cpc	r25, r18
    1c86:	39 f4       	brne	.+14     	; 0x1c96 <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1c88:	ed 81       	ldd	r30, Y+5	; 0x05
    1c8a:	fe 81       	ldd	r31, Y+6	; 0x06
    1c8c:	87 81       	ldd	r24, Z+7	; 0x07
    1c8e:	90 85       	ldd	r25, Z+8	; 0x08
    1c90:	9c 83       	std	Y+4, r25	; 0x04
    1c92:	8b 83       	std	Y+3, r24	; 0x03
    1c94:	18 c0       	rjmp	.+48     	; 0x1cc6 <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1c96:	8d 81       	ldd	r24, Y+5	; 0x05
    1c98:	9e 81       	ldd	r25, Y+6	; 0x06
    1c9a:	03 96       	adiw	r24, 0x03	; 3
    1c9c:	9c 83       	std	Y+4, r25	; 0x04
    1c9e:	8b 83       	std	Y+3, r24	; 0x03
    1ca0:	06 c0       	rjmp	.+12     	; 0x1cae <vListInsert+0x5a>
    1ca2:	eb 81       	ldd	r30, Y+3	; 0x03
    1ca4:	fc 81       	ldd	r31, Y+4	; 0x04
    1ca6:	82 81       	ldd	r24, Z+2	; 0x02
    1ca8:	93 81       	ldd	r25, Z+3	; 0x03
    1caa:	9c 83       	std	Y+4, r25	; 0x04
    1cac:	8b 83       	std	Y+3, r24	; 0x03
    1cae:	eb 81       	ldd	r30, Y+3	; 0x03
    1cb0:	fc 81       	ldd	r31, Y+4	; 0x04
    1cb2:	02 80       	ldd	r0, Z+2	; 0x02
    1cb4:	f3 81       	ldd	r31, Z+3	; 0x03
    1cb6:	e0 2d       	mov	r30, r0
    1cb8:	20 81       	ld	r18, Z
    1cba:	31 81       	ldd	r19, Z+1	; 0x01
    1cbc:	89 81       	ldd	r24, Y+1	; 0x01
    1cbe:	9a 81       	ldd	r25, Y+2	; 0x02
    1cc0:	82 17       	cp	r24, r18
    1cc2:	93 07       	cpc	r25, r19
    1cc4:	70 f7       	brcc	.-36     	; 0x1ca2 <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1cc6:	eb 81       	ldd	r30, Y+3	; 0x03
    1cc8:	fc 81       	ldd	r31, Y+4	; 0x04
    1cca:	82 81       	ldd	r24, Z+2	; 0x02
    1ccc:	93 81       	ldd	r25, Z+3	; 0x03
    1cce:	ef 81       	ldd	r30, Y+7	; 0x07
    1cd0:	f8 85       	ldd	r31, Y+8	; 0x08
    1cd2:	93 83       	std	Z+3, r25	; 0x03
    1cd4:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1cd6:	ef 81       	ldd	r30, Y+7	; 0x07
    1cd8:	f8 85       	ldd	r31, Y+8	; 0x08
    1cda:	02 80       	ldd	r0, Z+2	; 0x02
    1cdc:	f3 81       	ldd	r31, Z+3	; 0x03
    1cde:	e0 2d       	mov	r30, r0
    1ce0:	8f 81       	ldd	r24, Y+7	; 0x07
    1ce2:	98 85       	ldd	r25, Y+8	; 0x08
    1ce4:	95 83       	std	Z+5, r25	; 0x05
    1ce6:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1ce8:	ef 81       	ldd	r30, Y+7	; 0x07
    1cea:	f8 85       	ldd	r31, Y+8	; 0x08
    1cec:	8b 81       	ldd	r24, Y+3	; 0x03
    1cee:	9c 81       	ldd	r25, Y+4	; 0x04
    1cf0:	95 83       	std	Z+5, r25	; 0x05
    1cf2:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    1cf4:	eb 81       	ldd	r30, Y+3	; 0x03
    1cf6:	fc 81       	ldd	r31, Y+4	; 0x04
    1cf8:	8f 81       	ldd	r24, Y+7	; 0x07
    1cfa:	98 85       	ldd	r25, Y+8	; 0x08
    1cfc:	93 83       	std	Z+3, r25	; 0x03
    1cfe:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    1d00:	ef 81       	ldd	r30, Y+7	; 0x07
    1d02:	f8 85       	ldd	r31, Y+8	; 0x08
    1d04:	8d 81       	ldd	r24, Y+5	; 0x05
    1d06:	9e 81       	ldd	r25, Y+6	; 0x06
    1d08:	91 87       	std	Z+9, r25	; 0x09
    1d0a:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1d0c:	ed 81       	ldd	r30, Y+5	; 0x05
    1d0e:	fe 81       	ldd	r31, Y+6	; 0x06
    1d10:	80 81       	ld	r24, Z
    1d12:	8f 5f       	subi	r24, 0xFF	; 255
    1d14:	ed 81       	ldd	r30, Y+5	; 0x05
    1d16:	fe 81       	ldd	r31, Y+6	; 0x06
    1d18:	80 83       	st	Z, r24
}
    1d1a:	28 96       	adiw	r28, 0x08	; 8
    1d1c:	0f b6       	in	r0, 0x3f	; 63
    1d1e:	f8 94       	cli
    1d20:	de bf       	out	0x3e, r29	; 62
    1d22:	0f be       	out	0x3f, r0	; 63
    1d24:	cd bf       	out	0x3d, r28	; 61
    1d26:	cf 91       	pop	r28
    1d28:	df 91       	pop	r29
    1d2a:	08 95       	ret

00001d2c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1d2c:	df 93       	push	r29
    1d2e:	cf 93       	push	r28
    1d30:	00 d0       	rcall	.+0      	; 0x1d32 <uxListRemove+0x6>
    1d32:	00 d0       	rcall	.+0      	; 0x1d34 <uxListRemove+0x8>
    1d34:	cd b7       	in	r28, 0x3d	; 61
    1d36:	de b7       	in	r29, 0x3e	; 62
    1d38:	9c 83       	std	Y+4, r25	; 0x04
    1d3a:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    1d3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d40:	80 85       	ldd	r24, Z+8	; 0x08
    1d42:	91 85       	ldd	r25, Z+9	; 0x09
    1d44:	9a 83       	std	Y+2, r25	; 0x02
    1d46:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1d48:	eb 81       	ldd	r30, Y+3	; 0x03
    1d4a:	fc 81       	ldd	r31, Y+4	; 0x04
    1d4c:	a2 81       	ldd	r26, Z+2	; 0x02
    1d4e:	b3 81       	ldd	r27, Z+3	; 0x03
    1d50:	eb 81       	ldd	r30, Y+3	; 0x03
    1d52:	fc 81       	ldd	r31, Y+4	; 0x04
    1d54:	84 81       	ldd	r24, Z+4	; 0x04
    1d56:	95 81       	ldd	r25, Z+5	; 0x05
    1d58:	15 96       	adiw	r26, 0x05	; 5
    1d5a:	9c 93       	st	X, r25
    1d5c:	8e 93       	st	-X, r24
    1d5e:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1d60:	eb 81       	ldd	r30, Y+3	; 0x03
    1d62:	fc 81       	ldd	r31, Y+4	; 0x04
    1d64:	a4 81       	ldd	r26, Z+4	; 0x04
    1d66:	b5 81       	ldd	r27, Z+5	; 0x05
    1d68:	eb 81       	ldd	r30, Y+3	; 0x03
    1d6a:	fc 81       	ldd	r31, Y+4	; 0x04
    1d6c:	82 81       	ldd	r24, Z+2	; 0x02
    1d6e:	93 81       	ldd	r25, Z+3	; 0x03
    1d70:	13 96       	adiw	r26, 0x03	; 3
    1d72:	9c 93       	st	X, r25
    1d74:	8e 93       	st	-X, r24
    1d76:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    1d78:	e9 81       	ldd	r30, Y+1	; 0x01
    1d7a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d7c:	21 81       	ldd	r18, Z+1	; 0x01
    1d7e:	32 81       	ldd	r19, Z+2	; 0x02
    1d80:	8b 81       	ldd	r24, Y+3	; 0x03
    1d82:	9c 81       	ldd	r25, Y+4	; 0x04
    1d84:	28 17       	cp	r18, r24
    1d86:	39 07       	cpc	r19, r25
    1d88:	41 f4       	brne	.+16     	; 0x1d9a <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    1d8a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d8c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d8e:	84 81       	ldd	r24, Z+4	; 0x04
    1d90:	95 81       	ldd	r25, Z+5	; 0x05
    1d92:	e9 81       	ldd	r30, Y+1	; 0x01
    1d94:	fa 81       	ldd	r31, Y+2	; 0x02
    1d96:	92 83       	std	Z+2, r25	; 0x02
    1d98:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    1d9a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d9c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d9e:	11 86       	std	Z+9, r1	; 0x09
    1da0:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    1da2:	e9 81       	ldd	r30, Y+1	; 0x01
    1da4:	fa 81       	ldd	r31, Y+2	; 0x02
    1da6:	80 81       	ld	r24, Z
    1da8:	81 50       	subi	r24, 0x01	; 1
    1daa:	e9 81       	ldd	r30, Y+1	; 0x01
    1dac:	fa 81       	ldd	r31, Y+2	; 0x02
    1dae:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    1db0:	e9 81       	ldd	r30, Y+1	; 0x01
    1db2:	fa 81       	ldd	r31, Y+2	; 0x02
    1db4:	80 81       	ld	r24, Z
}
    1db6:	0f 90       	pop	r0
    1db8:	0f 90       	pop	r0
    1dba:	0f 90       	pop	r0
    1dbc:	0f 90       	pop	r0
    1dbe:	cf 91       	pop	r28
    1dc0:	df 91       	pop	r29
    1dc2:	08 95       	ret

00001dc4 <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    1dc4:	df 93       	push	r29
    1dc6:	cf 93       	push	r28
    1dc8:	00 d0       	rcall	.+0      	; 0x1dca <xQueueGenericReset+0x6>
    1dca:	00 d0       	rcall	.+0      	; 0x1dcc <xQueueGenericReset+0x8>
    1dcc:	00 d0       	rcall	.+0      	; 0x1dce <xQueueGenericReset+0xa>
    1dce:	cd b7       	in	r28, 0x3d	; 61
    1dd0:	de b7       	in	r29, 0x3e	; 62
    1dd2:	9d 83       	std	Y+5, r25	; 0x05
    1dd4:	8c 83       	std	Y+4, r24	; 0x04
    1dd6:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    1dd8:	81 e0       	ldi	r24, 0x01	; 1
    1dda:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    1ddc:	8c 81       	ldd	r24, Y+4	; 0x04
    1dde:	9d 81       	ldd	r25, Y+5	; 0x05
    1de0:	9a 83       	std	Y+2, r25	; 0x02
    1de2:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    1de4:	89 81       	ldd	r24, Y+1	; 0x01
    1de6:	9a 81       	ldd	r25, Y+2	; 0x02
    1de8:	00 97       	sbiw	r24, 0x00	; 0
    1dea:	09 f4       	brne	.+2      	; 0x1dee <xQueueGenericReset+0x2a>
    1dec:	8b c0       	rjmp	.+278    	; 0x1f04 <xQueueGenericReset+0x140>
    1dee:	e9 81       	ldd	r30, Y+1	; 0x01
    1df0:	fa 81       	ldd	r31, Y+2	; 0x02
    1df2:	83 8d       	ldd	r24, Z+27	; 0x1b
    1df4:	88 23       	and	r24, r24
    1df6:	09 f4       	brne	.+2      	; 0x1dfa <xQueueGenericReset+0x36>
    1df8:	85 c0       	rjmp	.+266    	; 0x1f04 <xQueueGenericReset+0x140>
    1dfa:	e9 81       	ldd	r30, Y+1	; 0x01
    1dfc:	fa 81       	ldd	r31, Y+2	; 0x02
    1dfe:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e00:	28 2f       	mov	r18, r24
    1e02:	30 e0       	ldi	r19, 0x00	; 0
    1e04:	8f ef       	ldi	r24, 0xFF	; 255
    1e06:	9f e7       	ldi	r25, 0x7F	; 127
    1e08:	b9 01       	movw	r22, r18
    1e0a:	0e 94 5f 39 	call	0x72be	; 0x72be <__udivmodhi4>
    1e0e:	cb 01       	movw	r24, r22
    1e10:	9c 01       	movw	r18, r24
    1e12:	e9 81       	ldd	r30, Y+1	; 0x01
    1e14:	fa 81       	ldd	r31, Y+2	; 0x02
    1e16:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e18:	88 2f       	mov	r24, r24
    1e1a:	90 e0       	ldi	r25, 0x00	; 0
    1e1c:	28 17       	cp	r18, r24
    1e1e:	39 07       	cpc	r19, r25
    1e20:	08 f4       	brcc	.+2      	; 0x1e24 <xQueueGenericReset+0x60>
    1e22:	70 c0       	rjmp	.+224    	; 0x1f04 <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    1e24:	0f b6       	in	r0, 0x3f	; 63
    1e26:	f8 94       	cli
    1e28:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1e2a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e2c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e2e:	40 81       	ld	r20, Z
    1e30:	51 81       	ldd	r21, Z+1	; 0x01
    1e32:	e9 81       	ldd	r30, Y+1	; 0x01
    1e34:	fa 81       	ldd	r31, Y+2	; 0x02
    1e36:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e38:	28 2f       	mov	r18, r24
    1e3a:	30 e0       	ldi	r19, 0x00	; 0
    1e3c:	e9 81       	ldd	r30, Y+1	; 0x01
    1e3e:	fa 81       	ldd	r31, Y+2	; 0x02
    1e40:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e42:	88 2f       	mov	r24, r24
    1e44:	90 e0       	ldi	r25, 0x00	; 0
    1e46:	bc 01       	movw	r22, r24
    1e48:	26 9f       	mul	r18, r22
    1e4a:	c0 01       	movw	r24, r0
    1e4c:	27 9f       	mul	r18, r23
    1e4e:	90 0d       	add	r25, r0
    1e50:	36 9f       	mul	r19, r22
    1e52:	90 0d       	add	r25, r0
    1e54:	11 24       	eor	r1, r1
    1e56:	84 0f       	add	r24, r20
    1e58:	95 1f       	adc	r25, r21
    1e5a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e5c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e5e:	95 83       	std	Z+5, r25	; 0x05
    1e60:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1e62:	e9 81       	ldd	r30, Y+1	; 0x01
    1e64:	fa 81       	ldd	r31, Y+2	; 0x02
    1e66:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    1e68:	e9 81       	ldd	r30, Y+1	; 0x01
    1e6a:	fa 81       	ldd	r31, Y+2	; 0x02
    1e6c:	80 81       	ld	r24, Z
    1e6e:	91 81       	ldd	r25, Z+1	; 0x01
    1e70:	e9 81       	ldd	r30, Y+1	; 0x01
    1e72:	fa 81       	ldd	r31, Y+2	; 0x02
    1e74:	93 83       	std	Z+3, r25	; 0x03
    1e76:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1e78:	e9 81       	ldd	r30, Y+1	; 0x01
    1e7a:	fa 81       	ldd	r31, Y+2	; 0x02
    1e7c:	40 81       	ld	r20, Z
    1e7e:	51 81       	ldd	r21, Z+1	; 0x01
    1e80:	e9 81       	ldd	r30, Y+1	; 0x01
    1e82:	fa 81       	ldd	r31, Y+2	; 0x02
    1e84:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e86:	88 2f       	mov	r24, r24
    1e88:	90 e0       	ldi	r25, 0x00	; 0
    1e8a:	9c 01       	movw	r18, r24
    1e8c:	21 50       	subi	r18, 0x01	; 1
    1e8e:	30 40       	sbci	r19, 0x00	; 0
    1e90:	e9 81       	ldd	r30, Y+1	; 0x01
    1e92:	fa 81       	ldd	r31, Y+2	; 0x02
    1e94:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e96:	88 2f       	mov	r24, r24
    1e98:	90 e0       	ldi	r25, 0x00	; 0
    1e9a:	bc 01       	movw	r22, r24
    1e9c:	26 9f       	mul	r18, r22
    1e9e:	c0 01       	movw	r24, r0
    1ea0:	27 9f       	mul	r18, r23
    1ea2:	90 0d       	add	r25, r0
    1ea4:	36 9f       	mul	r19, r22
    1ea6:	90 0d       	add	r25, r0
    1ea8:	11 24       	eor	r1, r1
    1eaa:	84 0f       	add	r24, r20
    1eac:	95 1f       	adc	r25, r21
    1eae:	e9 81       	ldd	r30, Y+1	; 0x01
    1eb0:	fa 81       	ldd	r31, Y+2	; 0x02
    1eb2:	97 83       	std	Z+7, r25	; 0x07
    1eb4:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    1eb6:	e9 81       	ldd	r30, Y+1	; 0x01
    1eb8:	fa 81       	ldd	r31, Y+2	; 0x02
    1eba:	8f ef       	ldi	r24, 0xFF	; 255
    1ebc:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    1ebe:	e9 81       	ldd	r30, Y+1	; 0x01
    1ec0:	fa 81       	ldd	r31, Y+2	; 0x02
    1ec2:	8f ef       	ldi	r24, 0xFF	; 255
    1ec4:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    1ec6:	8e 81       	ldd	r24, Y+6	; 0x06
    1ec8:	88 23       	and	r24, r24
    1eca:	79 f4       	brne	.+30     	; 0x1eea <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1ecc:	e9 81       	ldd	r30, Y+1	; 0x01
    1ece:	fa 81       	ldd	r31, Y+2	; 0x02
    1ed0:	80 85       	ldd	r24, Z+8	; 0x08
    1ed2:	88 23       	and	r24, r24
    1ed4:	a1 f0       	breq	.+40     	; 0x1efe <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1ed6:	89 81       	ldd	r24, Y+1	; 0x01
    1ed8:	9a 81       	ldd	r25, Y+2	; 0x02
    1eda:	08 96       	adiw	r24, 0x08	; 8
    1edc:	0e 94 12 22 	call	0x4424	; 0x4424 <xTaskRemoveFromEventList>
    1ee0:	88 23       	and	r24, r24
    1ee2:	69 f0       	breq	.+26     	; 0x1efe <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1ee4:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    1ee8:	0a c0       	rjmp	.+20     	; 0x1efe <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1eea:	89 81       	ldd	r24, Y+1	; 0x01
    1eec:	9a 81       	ldd	r25, Y+2	; 0x02
    1eee:	08 96       	adiw	r24, 0x08	; 8
    1ef0:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1ef4:	89 81       	ldd	r24, Y+1	; 0x01
    1ef6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ef8:	41 96       	adiw	r24, 0x11	; 17
    1efa:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    1efe:	0f 90       	pop	r0
    1f00:	0f be       	out	0x3f, r0	; 63
    1f02:	01 c0       	rjmp	.+2      	; 0x1f06 <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    1f04:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    1f06:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1f08:	26 96       	adiw	r28, 0x06	; 6
    1f0a:	0f b6       	in	r0, 0x3f	; 63
    1f0c:	f8 94       	cli
    1f0e:	de bf       	out	0x3e, r29	; 62
    1f10:	0f be       	out	0x3f, r0	; 63
    1f12:	cd bf       	out	0x3d, r28	; 61
    1f14:	cf 91       	pop	r28
    1f16:	df 91       	pop	r29
    1f18:	08 95       	ret

00001f1a <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    1f1a:	0f 93       	push	r16
    1f1c:	1f 93       	push	r17
    1f1e:	df 93       	push	r29
    1f20:	cf 93       	push	r28
    1f22:	cd b7       	in	r28, 0x3d	; 61
    1f24:	de b7       	in	r29, 0x3e	; 62
    1f26:	29 97       	sbiw	r28, 0x09	; 9
    1f28:	0f b6       	in	r0, 0x3f	; 63
    1f2a:	f8 94       	cli
    1f2c:	de bf       	out	0x3e, r29	; 62
    1f2e:	0f be       	out	0x3f, r0	; 63
    1f30:	cd bf       	out	0x3d, r28	; 61
    1f32:	8f 83       	std	Y+7, r24	; 0x07
    1f34:	68 87       	std	Y+8, r22	; 0x08
    1f36:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    1f38:	1e 82       	std	Y+6, r1	; 0x06
    1f3a:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    1f3c:	8f 81       	ldd	r24, Y+7	; 0x07
    1f3e:	88 23       	and	r24, r24
    1f40:	09 f4       	brne	.+2      	; 0x1f44 <xQueueGenericCreate+0x2a>
    1f42:	52 c0       	rjmp	.+164    	; 0x1fe8 <xQueueGenericCreate+0xce>
    1f44:	8f 81       	ldd	r24, Y+7	; 0x07
    1f46:	28 2f       	mov	r18, r24
    1f48:	30 e0       	ldi	r19, 0x00	; 0
    1f4a:	8f ef       	ldi	r24, 0xFF	; 255
    1f4c:	9f e7       	ldi	r25, 0x7F	; 127
    1f4e:	b9 01       	movw	r22, r18
    1f50:	0e 94 5f 39 	call	0x72be	; 0x72be <__udivmodhi4>
    1f54:	cb 01       	movw	r24, r22
    1f56:	9c 01       	movw	r18, r24
    1f58:	88 85       	ldd	r24, Y+8	; 0x08
    1f5a:	88 2f       	mov	r24, r24
    1f5c:	90 e0       	ldi	r25, 0x00	; 0
    1f5e:	28 17       	cp	r18, r24
    1f60:	39 07       	cpc	r19, r25
    1f62:	08 f4       	brcc	.+2      	; 0x1f66 <xQueueGenericCreate+0x4c>
    1f64:	41 c0       	rjmp	.+130    	; 0x1fe8 <xQueueGenericCreate+0xce>
    1f66:	8f 81       	ldd	r24, Y+7	; 0x07
    1f68:	28 2f       	mov	r18, r24
    1f6a:	30 e0       	ldi	r19, 0x00	; 0
    1f6c:	88 85       	ldd	r24, Y+8	; 0x08
    1f6e:	88 2f       	mov	r24, r24
    1f70:	90 e0       	ldi	r25, 0x00	; 0
    1f72:	ac 01       	movw	r20, r24
    1f74:	24 9f       	mul	r18, r20
    1f76:	c0 01       	movw	r24, r0
    1f78:	25 9f       	mul	r18, r21
    1f7a:	90 0d       	add	r25, r0
    1f7c:	34 9f       	mul	r19, r20
    1f7e:	90 0d       	add	r25, r0
    1f80:	11 24       	eor	r1, r1
    1f82:	5f e7       	ldi	r21, 0x7F	; 127
    1f84:	8f 3d       	cpi	r24, 0xDF	; 223
    1f86:	95 07       	cpc	r25, r21
    1f88:	78 f5       	brcc	.+94     	; 0x1fe8 <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1f8a:	8f 81       	ldd	r24, Y+7	; 0x07
    1f8c:	28 2f       	mov	r18, r24
    1f8e:	30 e0       	ldi	r19, 0x00	; 0
    1f90:	88 85       	ldd	r24, Y+8	; 0x08
    1f92:	88 2f       	mov	r24, r24
    1f94:	90 e0       	ldi	r25, 0x00	; 0
    1f96:	ac 01       	movw	r20, r24
    1f98:	24 9f       	mul	r18, r20
    1f9a:	c0 01       	movw	r24, r0
    1f9c:	25 9f       	mul	r18, r21
    1f9e:	90 0d       	add	r25, r0
    1fa0:	34 9f       	mul	r19, r20
    1fa2:	90 0d       	add	r25, r0
    1fa4:	11 24       	eor	r1, r1
    1fa6:	9c 83       	std	Y+4, r25	; 0x04
    1fa8:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1faa:	8b 81       	ldd	r24, Y+3	; 0x03
    1fac:	9c 81       	ldd	r25, Y+4	; 0x04
    1fae:	81 96       	adiw	r24, 0x21	; 33
    1fb0:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    1fb4:	9e 83       	std	Y+6, r25	; 0x06
    1fb6:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    1fb8:	8d 81       	ldd	r24, Y+5	; 0x05
    1fba:	9e 81       	ldd	r25, Y+6	; 0x06
    1fbc:	00 97       	sbiw	r24, 0x00	; 0
    1fbe:	a1 f0       	breq	.+40     	; 0x1fe8 <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1fc0:	8d 81       	ldd	r24, Y+5	; 0x05
    1fc2:	9e 81       	ldd	r25, Y+6	; 0x06
    1fc4:	9a 83       	std	Y+2, r25	; 0x02
    1fc6:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1fc8:	89 81       	ldd	r24, Y+1	; 0x01
    1fca:	9a 81       	ldd	r25, Y+2	; 0x02
    1fcc:	81 96       	adiw	r24, 0x21	; 33
    1fce:	9a 83       	std	Y+2, r25	; 0x02
    1fd0:	89 83       	std	Y+1, r24	; 0x01
                         * deleted. */
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
                    }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1fd2:	29 81       	ldd	r18, Y+1	; 0x01
    1fd4:	3a 81       	ldd	r19, Y+2	; 0x02
    1fd6:	ed 81       	ldd	r30, Y+5	; 0x05
    1fd8:	fe 81       	ldd	r31, Y+6	; 0x06
    1fda:	8f 81       	ldd	r24, Y+7	; 0x07
    1fdc:	68 85       	ldd	r22, Y+8	; 0x08
    1fde:	a9 01       	movw	r20, r18
    1fe0:	29 85       	ldd	r18, Y+9	; 0x09
    1fe2:	8f 01       	movw	r16, r30
    1fe4:	0e 94 01 10 	call	0x2002	; 0x2002 <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    1fe8:	8d 81       	ldd	r24, Y+5	; 0x05
    1fea:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    1fec:	29 96       	adiw	r28, 0x09	; 9
    1fee:	0f b6       	in	r0, 0x3f	; 63
    1ff0:	f8 94       	cli
    1ff2:	de bf       	out	0x3e, r29	; 62
    1ff4:	0f be       	out	0x3f, r0	; 63
    1ff6:	cd bf       	out	0x3d, r28	; 61
    1ff8:	cf 91       	pop	r28
    1ffa:	df 91       	pop	r29
    1ffc:	1f 91       	pop	r17
    1ffe:	0f 91       	pop	r16
    2000:	08 95       	ret

00002002 <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    2002:	0f 93       	push	r16
    2004:	1f 93       	push	r17
    2006:	df 93       	push	r29
    2008:	cf 93       	push	r28
    200a:	cd b7       	in	r28, 0x3d	; 61
    200c:	de b7       	in	r29, 0x3e	; 62
    200e:	27 97       	sbiw	r28, 0x07	; 7
    2010:	0f b6       	in	r0, 0x3f	; 63
    2012:	f8 94       	cli
    2014:	de bf       	out	0x3e, r29	; 62
    2016:	0f be       	out	0x3f, r0	; 63
    2018:	cd bf       	out	0x3d, r28	; 61
    201a:	89 83       	std	Y+1, r24	; 0x01
    201c:	6a 83       	std	Y+2, r22	; 0x02
    201e:	5c 83       	std	Y+4, r21	; 0x04
    2020:	4b 83       	std	Y+3, r20	; 0x03
    2022:	2d 83       	std	Y+5, r18	; 0x05
    2024:	1f 83       	std	Y+7, r17	; 0x07
    2026:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    2028:	8a 81       	ldd	r24, Y+2	; 0x02
    202a:	88 23       	and	r24, r24
    202c:	39 f4       	brne	.+14     	; 0x203c <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    202e:	8e 81       	ldd	r24, Y+6	; 0x06
    2030:	9f 81       	ldd	r25, Y+7	; 0x07
    2032:	ee 81       	ldd	r30, Y+6	; 0x06
    2034:	ff 81       	ldd	r31, Y+7	; 0x07
    2036:	91 83       	std	Z+1, r25	; 0x01
    2038:	80 83       	st	Z, r24
    203a:	06 c0       	rjmp	.+12     	; 0x2048 <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    203c:	8b 81       	ldd	r24, Y+3	; 0x03
    203e:	9c 81       	ldd	r25, Y+4	; 0x04
    2040:	ee 81       	ldd	r30, Y+6	; 0x06
    2042:	ff 81       	ldd	r31, Y+7	; 0x07
    2044:	91 83       	std	Z+1, r25	; 0x01
    2046:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    2048:	ee 81       	ldd	r30, Y+6	; 0x06
    204a:	ff 81       	ldd	r31, Y+7	; 0x07
    204c:	89 81       	ldd	r24, Y+1	; 0x01
    204e:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    2050:	ee 81       	ldd	r30, Y+6	; 0x06
    2052:	ff 81       	ldd	r31, Y+7	; 0x07
    2054:	8a 81       	ldd	r24, Y+2	; 0x02
    2056:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2058:	8e 81       	ldd	r24, Y+6	; 0x06
    205a:	9f 81       	ldd	r25, Y+7	; 0x07
    205c:	61 e0       	ldi	r22, 0x01	; 1
    205e:	0e 94 e2 0e 	call	0x1dc4	; 0x1dc4 <xQueueGenericReset>

    #if ( configUSE_TRACE_FACILITY == 1 )
        {
            pxNewQueue->ucQueueType = ucQueueType;
    2062:	ee 81       	ldd	r30, Y+6	; 0x06
    2064:	ff 81       	ldd	r31, Y+7	; 0x07
    2066:	8d 81       	ldd	r24, Y+5	; 0x05
    2068:	80 a3       	std	Z+32, r24	; 0x20
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    206a:	27 96       	adiw	r28, 0x07	; 7
    206c:	0f b6       	in	r0, 0x3f	; 63
    206e:	f8 94       	cli
    2070:	de bf       	out	0x3e, r29	; 62
    2072:	0f be       	out	0x3f, r0	; 63
    2074:	cd bf       	out	0x3d, r28	; 61
    2076:	cf 91       	pop	r28
    2078:	df 91       	pop	r29
    207a:	1f 91       	pop	r17
    207c:	0f 91       	pop	r16
    207e:	08 95       	ret

00002080 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    2080:	df 93       	push	r29
    2082:	cf 93       	push	r28
    2084:	cd b7       	in	r28, 0x3d	; 61
    2086:	de b7       	in	r29, 0x3e	; 62
    2088:	2f 97       	sbiw	r28, 0x0f	; 15
    208a:	0f b6       	in	r0, 0x3f	; 63
    208c:	f8 94       	cli
    208e:	de bf       	out	0x3e, r29	; 62
    2090:	0f be       	out	0x3f, r0	; 63
    2092:	cd bf       	out	0x3d, r28	; 61
    2094:	99 87       	std	Y+9, r25	; 0x09
    2096:	88 87       	std	Y+8, r24	; 0x08
    2098:	7b 87       	std	Y+11, r23	; 0x0b
    209a:	6a 87       	std	Y+10, r22	; 0x0a
    209c:	5d 87       	std	Y+13, r21	; 0x0d
    209e:	4c 87       	std	Y+12, r20	; 0x0c
    20a0:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    20a2:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    20a4:	88 85       	ldd	r24, Y+8	; 0x08
    20a6:	99 85       	ldd	r25, Y+9	; 0x09
    20a8:	9a 83       	std	Y+2, r25	; 0x02
    20aa:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    20ac:	0f b6       	in	r0, 0x3f	; 63
    20ae:	f8 94       	cli
    20b0:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    20b2:	e9 81       	ldd	r30, Y+1	; 0x01
    20b4:	fa 81       	ldd	r31, Y+2	; 0x02
    20b6:	92 8d       	ldd	r25, Z+26	; 0x1a
    20b8:	e9 81       	ldd	r30, Y+1	; 0x01
    20ba:	fa 81       	ldd	r31, Y+2	; 0x02
    20bc:	83 8d       	ldd	r24, Z+27	; 0x1b
    20be:	98 17       	cp	r25, r24
    20c0:	18 f0       	brcs	.+6      	; 0x20c8 <xQueueGenericSend+0x48>
    20c2:	8e 85       	ldd	r24, Y+14	; 0x0e
    20c4:	82 30       	cpi	r24, 0x02	; 2
    20c6:	11 f5       	brne	.+68     	; 0x210c <xQueueGenericSend+0x8c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    20c8:	89 81       	ldd	r24, Y+1	; 0x01
    20ca:	9a 81       	ldd	r25, Y+2	; 0x02
    20cc:	2a 85       	ldd	r18, Y+10	; 0x0a
    20ce:	3b 85       	ldd	r19, Y+11	; 0x0b
    20d0:	b9 01       	movw	r22, r18
    20d2:	4e 85       	ldd	r20, Y+14	; 0x0e
    20d4:	0e 94 c7 14 	call	0x298e	; 0x298e <prvCopyDataToQueue>
    20d8:	8b 83       	std	Y+3, r24	; 0x03

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20da:	e9 81       	ldd	r30, Y+1	; 0x01
    20dc:	fa 81       	ldd	r31, Y+2	; 0x02
    20de:	81 89       	ldd	r24, Z+17	; 0x11
    20e0:	88 23       	and	r24, r24
    20e2:	51 f0       	breq	.+20     	; 0x20f8 <xQueueGenericSend+0x78>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20e4:	89 81       	ldd	r24, Y+1	; 0x01
    20e6:	9a 81       	ldd	r25, Y+2	; 0x02
    20e8:	41 96       	adiw	r24, 0x11	; 17
    20ea:	0e 94 12 22 	call	0x4424	; 0x4424 <xTaskRemoveFromEventList>
    20ee:	88 23       	and	r24, r24
    20f0:	41 f0       	breq	.+16     	; 0x2102 <xQueueGenericSend+0x82>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    20f2:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    20f6:	05 c0       	rjmp	.+10     	; 0x2102 <xQueueGenericSend+0x82>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    20f8:	8b 81       	ldd	r24, Y+3	; 0x03
    20fa:	88 23       	and	r24, r24
    20fc:	11 f0       	breq	.+4      	; 0x2102 <xQueueGenericSend+0x82>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    20fe:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    2102:	0f 90       	pop	r0
    2104:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2106:	81 e0       	ldi	r24, 0x01	; 1
    2108:	8f 87       	std	Y+15, r24	; 0x0f
    210a:	5c c0       	rjmp	.+184    	; 0x21c4 <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    210c:	8c 85       	ldd	r24, Y+12	; 0x0c
    210e:	9d 85       	ldd	r25, Y+13	; 0x0d
    2110:	00 97       	sbiw	r24, 0x00	; 0
    2112:	21 f4       	brne	.+8      	; 0x211c <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2114:	0f 90       	pop	r0
    2116:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    2118:	1f 86       	std	Y+15, r1	; 0x0f
    211a:	54 c0       	rjmp	.+168    	; 0x21c4 <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    211c:	8c 81       	ldd	r24, Y+4	; 0x04
    211e:	88 23       	and	r24, r24
    2120:	31 f4       	brne	.+12     	; 0x212e <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2122:	ce 01       	movw	r24, r28
    2124:	05 96       	adiw	r24, 0x05	; 5
    2126:	0e 94 82 24 	call	0x4904	; 0x4904 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    212a:	81 e0       	ldi	r24, 0x01	; 1
    212c:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    212e:	0f 90       	pop	r0
    2130:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2132:	0e 94 30 1c 	call	0x3860	; 0x3860 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2136:	0f b6       	in	r0, 0x3f	; 63
    2138:	f8 94       	cli
    213a:	0f 92       	push	r0
    213c:	e9 81       	ldd	r30, Y+1	; 0x01
    213e:	fa 81       	ldd	r31, Y+2	; 0x02
    2140:	85 8d       	ldd	r24, Z+29	; 0x1d
    2142:	8f 3f       	cpi	r24, 0xFF	; 255
    2144:	19 f4       	brne	.+6      	; 0x214c <xQueueGenericSend+0xcc>
    2146:	e9 81       	ldd	r30, Y+1	; 0x01
    2148:	fa 81       	ldd	r31, Y+2	; 0x02
    214a:	15 8e       	std	Z+29, r1	; 0x1d
    214c:	e9 81       	ldd	r30, Y+1	; 0x01
    214e:	fa 81       	ldd	r31, Y+2	; 0x02
    2150:	86 8d       	ldd	r24, Z+30	; 0x1e
    2152:	8f 3f       	cpi	r24, 0xFF	; 255
    2154:	19 f4       	brne	.+6      	; 0x215c <xQueueGenericSend+0xdc>
    2156:	e9 81       	ldd	r30, Y+1	; 0x01
    2158:	fa 81       	ldd	r31, Y+2	; 0x02
    215a:	16 8e       	std	Z+30, r1	; 0x1e
    215c:	0f 90       	pop	r0
    215e:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2160:	ce 01       	movw	r24, r28
    2162:	05 96       	adiw	r24, 0x05	; 5
    2164:	9e 01       	movw	r18, r28
    2166:	24 5f       	subi	r18, 0xF4	; 244
    2168:	3f 4f       	sbci	r19, 0xFF	; 255
    216a:	b9 01       	movw	r22, r18
    216c:	0e 94 9b 24 	call	0x4936	; 0x4936 <xTaskCheckForTimeOut>
    2170:	88 23       	and	r24, r24
    2172:	09 f5       	brne	.+66     	; 0x21b6 <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2174:	89 81       	ldd	r24, Y+1	; 0x01
    2176:	9a 81       	ldd	r25, Y+2	; 0x02
    2178:	0e 94 43 16 	call	0x2c86	; 0x2c86 <prvIsQueueFull>
    217c:	88 23       	and	r24, r24
    217e:	a1 f0       	breq	.+40     	; 0x21a8 <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2180:	89 81       	ldd	r24, Y+1	; 0x01
    2182:	9a 81       	ldd	r25, Y+2	; 0x02
    2184:	08 96       	adiw	r24, 0x08	; 8
    2186:	2c 85       	ldd	r18, Y+12	; 0x0c
    2188:	3d 85       	ldd	r19, Y+13	; 0x0d
    218a:	b9 01       	movw	r22, r18
    218c:	0e 94 29 21 	call	0x4252	; 0x4252 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    2190:	89 81       	ldd	r24, Y+1	; 0x01
    2192:	9a 81       	ldd	r25, Y+2	; 0x02
    2194:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    2198:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>
    219c:	88 23       	and	r24, r24
    219e:	09 f0       	breq	.+2      	; 0x21a2 <xQueueGenericSend+0x122>
    21a0:	85 cf       	rjmp	.-246    	; 0x20ac <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    21a2:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    21a6:	82 cf       	rjmp	.-252    	; 0x20ac <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    21a8:	89 81       	ldd	r24, Y+1	; 0x01
    21aa:	9a 81       	ldd	r25, Y+2	; 0x02
    21ac:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    21b0:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>
    21b4:	7b cf       	rjmp	.-266    	; 0x20ac <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    21b6:	89 81       	ldd	r24, Y+1	; 0x01
    21b8:	9a 81       	ldd	r25, Y+2	; 0x02
    21ba:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    21be:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    21c2:	1f 86       	std	Y+15, r1	; 0x0f
    21c4:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    21c6:	2f 96       	adiw	r28, 0x0f	; 15
    21c8:	0f b6       	in	r0, 0x3f	; 63
    21ca:	f8 94       	cli
    21cc:	de bf       	out	0x3e, r29	; 62
    21ce:	0f be       	out	0x3f, r0	; 63
    21d0:	cd bf       	out	0x3d, r28	; 61
    21d2:	cf 91       	pop	r28
    21d4:	df 91       	pop	r29
    21d6:	08 95       	ret

000021d8 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    21d8:	df 93       	push	r29
    21da:	cf 93       	push	r28
    21dc:	cd b7       	in	r28, 0x3d	; 61
    21de:	de b7       	in	r29, 0x3e	; 62
    21e0:	2d 97       	sbiw	r28, 0x0d	; 13
    21e2:	0f b6       	in	r0, 0x3f	; 63
    21e4:	f8 94       	cli
    21e6:	de bf       	out	0x3e, r29	; 62
    21e8:	0f be       	out	0x3f, r0	; 63
    21ea:	cd bf       	out	0x3d, r28	; 61
    21ec:	98 87       	std	Y+8, r25	; 0x08
    21ee:	8f 83       	std	Y+7, r24	; 0x07
    21f0:	7a 87       	std	Y+10, r23	; 0x0a
    21f2:	69 87       	std	Y+9, r22	; 0x09
    21f4:	5c 87       	std	Y+12, r21	; 0x0c
    21f6:	4b 87       	std	Y+11, r20	; 0x0b
    21f8:	2d 87       	std	Y+13, r18	; 0x0d
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    21fa:	8f 81       	ldd	r24, Y+7	; 0x07
    21fc:	98 85       	ldd	r25, Y+8	; 0x08
    21fe:	9c 83       	std	Y+4, r25	; 0x04
    2200:	8b 83       	std	Y+3, r24	; 0x03
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2202:	1d 82       	std	Y+5, r1	; 0x05
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2204:	eb 81       	ldd	r30, Y+3	; 0x03
    2206:	fc 81       	ldd	r31, Y+4	; 0x04
    2208:	92 8d       	ldd	r25, Z+26	; 0x1a
    220a:	eb 81       	ldd	r30, Y+3	; 0x03
    220c:	fc 81       	ldd	r31, Y+4	; 0x04
    220e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2210:	98 17       	cp	r25, r24
    2212:	18 f0       	brcs	.+6      	; 0x221a <xQueueGenericSendFromISR+0x42>
    2214:	8d 85       	ldd	r24, Y+13	; 0x0d
    2216:	82 30       	cpi	r24, 0x02	; 2
    2218:	81 f5       	brne	.+96     	; 0x227a <xQueueGenericSendFromISR+0xa2>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    221a:	eb 81       	ldd	r30, Y+3	; 0x03
    221c:	fc 81       	ldd	r31, Y+4	; 0x04
    221e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2220:	8a 83       	std	Y+2, r24	; 0x02
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    2222:	eb 81       	ldd	r30, Y+3	; 0x03
    2224:	fc 81       	ldd	r31, Y+4	; 0x04
    2226:	82 8d       	ldd	r24, Z+26	; 0x1a
    2228:	89 83       	std	Y+1, r24	; 0x01
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    222a:	8b 81       	ldd	r24, Y+3	; 0x03
    222c:	9c 81       	ldd	r25, Y+4	; 0x04
    222e:	29 85       	ldd	r18, Y+9	; 0x09
    2230:	3a 85       	ldd	r19, Y+10	; 0x0a
    2232:	b9 01       	movw	r22, r18
    2234:	4d 85       	ldd	r20, Y+13	; 0x0d
    2236:	0e 94 c7 14 	call	0x298e	; 0x298e <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    223a:	8a 81       	ldd	r24, Y+2	; 0x02
    223c:	8f 3f       	cpi	r24, 0xFF	; 255
    223e:	a9 f4       	brne	.+42     	; 0x226a <xQueueGenericSendFromISR+0x92>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2240:	eb 81       	ldd	r30, Y+3	; 0x03
    2242:	fc 81       	ldd	r31, Y+4	; 0x04
    2244:	81 89       	ldd	r24, Z+17	; 0x11
    2246:	88 23       	and	r24, r24
    2248:	a9 f0       	breq	.+42     	; 0x2274 <xQueueGenericSendFromISR+0x9c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    224a:	8b 81       	ldd	r24, Y+3	; 0x03
    224c:	9c 81       	ldd	r25, Y+4	; 0x04
    224e:	41 96       	adiw	r24, 0x11	; 17
    2250:	0e 94 12 22 	call	0x4424	; 0x4424 <xTaskRemoveFromEventList>
    2254:	88 23       	and	r24, r24
    2256:	71 f0       	breq	.+28     	; 0x2274 <xQueueGenericSendFromISR+0x9c>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    2258:	8b 85       	ldd	r24, Y+11	; 0x0b
    225a:	9c 85       	ldd	r25, Y+12	; 0x0c
    225c:	00 97       	sbiw	r24, 0x00	; 0
    225e:	51 f0       	breq	.+20     	; 0x2274 <xQueueGenericSendFromISR+0x9c>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    2260:	eb 85       	ldd	r30, Y+11	; 0x0b
    2262:	fc 85       	ldd	r31, Y+12	; 0x0c
    2264:	81 e0       	ldi	r24, 0x01	; 1
    2266:	80 83       	st	Z, r24
    2268:	05 c0       	rjmp	.+10     	; 0x2274 <xQueueGenericSendFromISR+0x9c>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    226a:	8a 81       	ldd	r24, Y+2	; 0x02
    226c:	8f 5f       	subi	r24, 0xFF	; 255
    226e:	eb 81       	ldd	r30, Y+3	; 0x03
    2270:	fc 81       	ldd	r31, Y+4	; 0x04
    2272:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    2274:	81 e0       	ldi	r24, 0x01	; 1
    2276:	8e 83       	std	Y+6, r24	; 0x06
    2278:	01 c0       	rjmp	.+2      	; 0x227c <xQueueGenericSendFromISR+0xa4>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    227a:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    227c:	8e 81       	ldd	r24, Y+6	; 0x06
}
    227e:	2d 96       	adiw	r28, 0x0d	; 13
    2280:	0f b6       	in	r0, 0x3f	; 63
    2282:	f8 94       	cli
    2284:	de bf       	out	0x3e, r29	; 62
    2286:	0f be       	out	0x3f, r0	; 63
    2288:	cd bf       	out	0x3d, r28	; 61
    228a:	cf 91       	pop	r28
    228c:	df 91       	pop	r29
    228e:	08 95       	ret

00002290 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    2290:	df 93       	push	r29
    2292:	cf 93       	push	r28
    2294:	cd b7       	in	r28, 0x3d	; 61
    2296:	de b7       	in	r29, 0x3e	; 62
    2298:	2a 97       	sbiw	r28, 0x0a	; 10
    229a:	0f b6       	in	r0, 0x3f	; 63
    229c:	f8 94       	cli
    229e:	de bf       	out	0x3e, r29	; 62
    22a0:	0f be       	out	0x3f, r0	; 63
    22a2:	cd bf       	out	0x3d, r28	; 61
    22a4:	98 87       	std	Y+8, r25	; 0x08
    22a6:	8f 83       	std	Y+7, r24	; 0x07
    22a8:	7a 87       	std	Y+10, r23	; 0x0a
    22aa:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    22ac:	8f 81       	ldd	r24, Y+7	; 0x07
    22ae:	98 85       	ldd	r25, Y+8	; 0x08
    22b0:	9c 83       	std	Y+4, r25	; 0x04
    22b2:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    22b4:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    22b6:	eb 81       	ldd	r30, Y+3	; 0x03
    22b8:	fc 81       	ldd	r31, Y+4	; 0x04
    22ba:	82 8d       	ldd	r24, Z+26	; 0x1a
    22bc:	8a 83       	std	Y+2, r24	; 0x02

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    22be:	eb 81       	ldd	r30, Y+3	; 0x03
    22c0:	fc 81       	ldd	r31, Y+4	; 0x04
    22c2:	93 8d       	ldd	r25, Z+27	; 0x1b
    22c4:	8a 81       	ldd	r24, Y+2	; 0x02
    22c6:	89 17       	cp	r24, r25
    22c8:	48 f5       	brcc	.+82     	; 0x231c <xQueueGiveFromISR+0x8c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    22ca:	eb 81       	ldd	r30, Y+3	; 0x03
    22cc:	fc 81       	ldd	r31, Y+4	; 0x04
    22ce:	86 8d       	ldd	r24, Z+30	; 0x1e
    22d0:	89 83       	std	Y+1, r24	; 0x01
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    22d2:	8a 81       	ldd	r24, Y+2	; 0x02
    22d4:	8f 5f       	subi	r24, 0xFF	; 255
    22d6:	eb 81       	ldd	r30, Y+3	; 0x03
    22d8:	fc 81       	ldd	r31, Y+4	; 0x04
    22da:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    22dc:	89 81       	ldd	r24, Y+1	; 0x01
    22de:	8f 3f       	cpi	r24, 0xFF	; 255
    22e0:	a9 f4       	brne	.+42     	; 0x230c <xQueueGiveFromISR+0x7c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    22e2:	eb 81       	ldd	r30, Y+3	; 0x03
    22e4:	fc 81       	ldd	r31, Y+4	; 0x04
    22e6:	81 89       	ldd	r24, Z+17	; 0x11
    22e8:	88 23       	and	r24, r24
    22ea:	a9 f0       	breq	.+42     	; 0x2316 <xQueueGiveFromISR+0x86>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    22ec:	8b 81       	ldd	r24, Y+3	; 0x03
    22ee:	9c 81       	ldd	r25, Y+4	; 0x04
    22f0:	41 96       	adiw	r24, 0x11	; 17
    22f2:	0e 94 12 22 	call	0x4424	; 0x4424 <xTaskRemoveFromEventList>
    22f6:	88 23       	and	r24, r24
    22f8:	71 f0       	breq	.+28     	; 0x2316 <xQueueGiveFromISR+0x86>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    22fa:	89 85       	ldd	r24, Y+9	; 0x09
    22fc:	9a 85       	ldd	r25, Y+10	; 0x0a
    22fe:	00 97       	sbiw	r24, 0x00	; 0
    2300:	51 f0       	breq	.+20     	; 0x2316 <xQueueGiveFromISR+0x86>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    2302:	e9 85       	ldd	r30, Y+9	; 0x09
    2304:	fa 85       	ldd	r31, Y+10	; 0x0a
    2306:	81 e0       	ldi	r24, 0x01	; 1
    2308:	80 83       	st	Z, r24
    230a:	05 c0       	rjmp	.+10     	; 0x2316 <xQueueGiveFromISR+0x86>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    230c:	89 81       	ldd	r24, Y+1	; 0x01
    230e:	8f 5f       	subi	r24, 0xFF	; 255
    2310:	eb 81       	ldd	r30, Y+3	; 0x03
    2312:	fc 81       	ldd	r31, Y+4	; 0x04
    2314:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    2316:	81 e0       	ldi	r24, 0x01	; 1
    2318:	8e 83       	std	Y+6, r24	; 0x06
    231a:	01 c0       	rjmp	.+2      	; 0x231e <xQueueGiveFromISR+0x8e>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    231c:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    231e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2320:	2a 96       	adiw	r28, 0x0a	; 10
    2322:	0f b6       	in	r0, 0x3f	; 63
    2324:	f8 94       	cli
    2326:	de bf       	out	0x3e, r29	; 62
    2328:	0f be       	out	0x3f, r0	; 63
    232a:	cd bf       	out	0x3d, r28	; 61
    232c:	cf 91       	pop	r28
    232e:	df 91       	pop	r29
    2330:	08 95       	ret

00002332 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    2332:	df 93       	push	r29
    2334:	cf 93       	push	r28
    2336:	cd b7       	in	r28, 0x3d	; 61
    2338:	de b7       	in	r29, 0x3e	; 62
    233a:	2e 97       	sbiw	r28, 0x0e	; 14
    233c:	0f b6       	in	r0, 0x3f	; 63
    233e:	f8 94       	cli
    2340:	de bf       	out	0x3e, r29	; 62
    2342:	0f be       	out	0x3f, r0	; 63
    2344:	cd bf       	out	0x3d, r28	; 61
    2346:	99 87       	std	Y+9, r25	; 0x09
    2348:	88 87       	std	Y+8, r24	; 0x08
    234a:	7b 87       	std	Y+11, r23	; 0x0b
    234c:	6a 87       	std	Y+10, r22	; 0x0a
    234e:	5d 87       	std	Y+13, r21	; 0x0d
    2350:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    2352:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2354:	88 85       	ldd	r24, Y+8	; 0x08
    2356:	99 85       	ldd	r25, Y+9	; 0x09
    2358:	9b 83       	std	Y+3, r25	; 0x03
    235a:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    235c:	0f b6       	in	r0, 0x3f	; 63
    235e:	f8 94       	cli
    2360:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2362:	ea 81       	ldd	r30, Y+2	; 0x02
    2364:	fb 81       	ldd	r31, Y+3	; 0x03
    2366:	82 8d       	ldd	r24, Z+26	; 0x1a
    2368:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    236a:	89 81       	ldd	r24, Y+1	; 0x01
    236c:	88 23       	and	r24, r24
    236e:	f9 f0       	breq	.+62     	; 0x23ae <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2370:	8a 81       	ldd	r24, Y+2	; 0x02
    2372:	9b 81       	ldd	r25, Y+3	; 0x03
    2374:	2a 85       	ldd	r18, Y+10	; 0x0a
    2376:	3b 85       	ldd	r19, Y+11	; 0x0b
    2378:	b9 01       	movw	r22, r18
    237a:	0e 94 6d 15 	call	0x2ada	; 0x2ada <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    237e:	89 81       	ldd	r24, Y+1	; 0x01
    2380:	81 50       	subi	r24, 0x01	; 1
    2382:	ea 81       	ldd	r30, Y+2	; 0x02
    2384:	fb 81       	ldd	r31, Y+3	; 0x03
    2386:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2388:	ea 81       	ldd	r30, Y+2	; 0x02
    238a:	fb 81       	ldd	r31, Y+3	; 0x03
    238c:	80 85       	ldd	r24, Z+8	; 0x08
    238e:	88 23       	and	r24, r24
    2390:	49 f0       	breq	.+18     	; 0x23a4 <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2392:	8a 81       	ldd	r24, Y+2	; 0x02
    2394:	9b 81       	ldd	r25, Y+3	; 0x03
    2396:	08 96       	adiw	r24, 0x08	; 8
    2398:	0e 94 12 22 	call	0x4424	; 0x4424 <xTaskRemoveFromEventList>
    239c:	88 23       	and	r24, r24
    239e:	11 f0       	breq	.+4      	; 0x23a4 <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    23a0:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    23a4:	0f 90       	pop	r0
    23a6:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    23a8:	81 e0       	ldi	r24, 0x01	; 1
    23aa:	8e 87       	std	Y+14, r24	; 0x0e
    23ac:	63 c0       	rjmp	.+198    	; 0x2474 <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    23ae:	8c 85       	ldd	r24, Y+12	; 0x0c
    23b0:	9d 85       	ldd	r25, Y+13	; 0x0d
    23b2:	00 97       	sbiw	r24, 0x00	; 0
    23b4:	21 f4       	brne	.+8      	; 0x23be <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    23b6:	0f 90       	pop	r0
    23b8:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    23ba:	1e 86       	std	Y+14, r1	; 0x0e
    23bc:	5b c0       	rjmp	.+182    	; 0x2474 <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    23be:	8c 81       	ldd	r24, Y+4	; 0x04
    23c0:	88 23       	and	r24, r24
    23c2:	31 f4       	brne	.+12     	; 0x23d0 <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    23c4:	ce 01       	movw	r24, r28
    23c6:	05 96       	adiw	r24, 0x05	; 5
    23c8:	0e 94 82 24 	call	0x4904	; 0x4904 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    23cc:	81 e0       	ldi	r24, 0x01	; 1
    23ce:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    23d0:	0f 90       	pop	r0
    23d2:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    23d4:	0e 94 30 1c 	call	0x3860	; 0x3860 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    23d8:	0f b6       	in	r0, 0x3f	; 63
    23da:	f8 94       	cli
    23dc:	0f 92       	push	r0
    23de:	ea 81       	ldd	r30, Y+2	; 0x02
    23e0:	fb 81       	ldd	r31, Y+3	; 0x03
    23e2:	85 8d       	ldd	r24, Z+29	; 0x1d
    23e4:	8f 3f       	cpi	r24, 0xFF	; 255
    23e6:	19 f4       	brne	.+6      	; 0x23ee <xQueueReceive+0xbc>
    23e8:	ea 81       	ldd	r30, Y+2	; 0x02
    23ea:	fb 81       	ldd	r31, Y+3	; 0x03
    23ec:	15 8e       	std	Z+29, r1	; 0x1d
    23ee:	ea 81       	ldd	r30, Y+2	; 0x02
    23f0:	fb 81       	ldd	r31, Y+3	; 0x03
    23f2:	86 8d       	ldd	r24, Z+30	; 0x1e
    23f4:	8f 3f       	cpi	r24, 0xFF	; 255
    23f6:	19 f4       	brne	.+6      	; 0x23fe <xQueueReceive+0xcc>
    23f8:	ea 81       	ldd	r30, Y+2	; 0x02
    23fa:	fb 81       	ldd	r31, Y+3	; 0x03
    23fc:	16 8e       	std	Z+30, r1	; 0x1e
    23fe:	0f 90       	pop	r0
    2400:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2402:	ce 01       	movw	r24, r28
    2404:	05 96       	adiw	r24, 0x05	; 5
    2406:	9e 01       	movw	r18, r28
    2408:	24 5f       	subi	r18, 0xF4	; 244
    240a:	3f 4f       	sbci	r19, 0xFF	; 255
    240c:	b9 01       	movw	r22, r18
    240e:	0e 94 9b 24 	call	0x4936	; 0x4936 <xTaskCheckForTimeOut>
    2412:	88 23       	and	r24, r24
    2414:	09 f5       	brne	.+66     	; 0x2458 <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2416:	8a 81       	ldd	r24, Y+2	; 0x02
    2418:	9b 81       	ldd	r25, Y+3	; 0x03
    241a:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <prvIsQueueEmpty>
    241e:	88 23       	and	r24, r24
    2420:	a1 f0       	breq	.+40     	; 0x244a <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2422:	8a 81       	ldd	r24, Y+2	; 0x02
    2424:	9b 81       	ldd	r25, Y+3	; 0x03
    2426:	41 96       	adiw	r24, 0x11	; 17
    2428:	2c 85       	ldd	r18, Y+12	; 0x0c
    242a:	3d 85       	ldd	r19, Y+13	; 0x0d
    242c:	b9 01       	movw	r22, r18
    242e:	0e 94 29 21 	call	0x4252	; 0x4252 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2432:	8a 81       	ldd	r24, Y+2	; 0x02
    2434:	9b 81       	ldd	r25, Y+3	; 0x03
    2436:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    243a:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>
    243e:	88 23       	and	r24, r24
    2440:	09 f0       	breq	.+2      	; 0x2444 <xQueueReceive+0x112>
    2442:	8c cf       	rjmp	.-232    	; 0x235c <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    2444:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    2448:	89 cf       	rjmp	.-238    	; 0x235c <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    244a:	8a 81       	ldd	r24, Y+2	; 0x02
    244c:	9b 81       	ldd	r25, Y+3	; 0x03
    244e:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2452:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>
    2456:	82 cf       	rjmp	.-252    	; 0x235c <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    2458:	8a 81       	ldd	r24, Y+2	; 0x02
    245a:	9b 81       	ldd	r25, Y+3	; 0x03
    245c:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2460:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2464:	8a 81       	ldd	r24, Y+2	; 0x02
    2466:	9b 81       	ldd	r25, Y+3	; 0x03
    2468:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <prvIsQueueEmpty>
    246c:	88 23       	and	r24, r24
    246e:	09 f4       	brne	.+2      	; 0x2472 <xQueueReceive+0x140>
    2470:	75 cf       	rjmp	.-278    	; 0x235c <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2472:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2474:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    2476:	2e 96       	adiw	r28, 0x0e	; 14
    2478:	0f b6       	in	r0, 0x3f	; 63
    247a:	f8 94       	cli
    247c:	de bf       	out	0x3e, r29	; 62
    247e:	0f be       	out	0x3f, r0	; 63
    2480:	cd bf       	out	0x3d, r28	; 61
    2482:	cf 91       	pop	r28
    2484:	df 91       	pop	r29
    2486:	08 95       	ret

00002488 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    2488:	df 93       	push	r29
    248a:	cf 93       	push	r28
    248c:	cd b7       	in	r28, 0x3d	; 61
    248e:	de b7       	in	r29, 0x3e	; 62
    2490:	2c 97       	sbiw	r28, 0x0c	; 12
    2492:	0f b6       	in	r0, 0x3f	; 63
    2494:	f8 94       	cli
    2496:	de bf       	out	0x3e, r29	; 62
    2498:	0f be       	out	0x3f, r0	; 63
    249a:	cd bf       	out	0x3d, r28	; 61
    249c:	99 87       	std	Y+9, r25	; 0x09
    249e:	88 87       	std	Y+8, r24	; 0x08
    24a0:	7b 87       	std	Y+11, r23	; 0x0b
    24a2:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    24a4:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    24a6:	88 85       	ldd	r24, Y+8	; 0x08
    24a8:	99 85       	ldd	r25, Y+9	; 0x09
    24aa:	9b 83       	std	Y+3, r25	; 0x03
    24ac:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    24ae:	0f b6       	in	r0, 0x3f	; 63
    24b0:	f8 94       	cli
    24b2:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    24b4:	ea 81       	ldd	r30, Y+2	; 0x02
    24b6:	fb 81       	ldd	r31, Y+3	; 0x03
    24b8:	82 8d       	ldd	r24, Z+26	; 0x1a
    24ba:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    24bc:	89 81       	ldd	r24, Y+1	; 0x01
    24be:	88 23       	and	r24, r24
    24c0:	c1 f0       	breq	.+48     	; 0x24f2 <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    24c2:	89 81       	ldd	r24, Y+1	; 0x01
    24c4:	81 50       	subi	r24, 0x01	; 1
    24c6:	ea 81       	ldd	r30, Y+2	; 0x02
    24c8:	fb 81       	ldd	r31, Y+3	; 0x03
    24ca:	82 8f       	std	Z+26, r24	; 0x1a
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24cc:	ea 81       	ldd	r30, Y+2	; 0x02
    24ce:	fb 81       	ldd	r31, Y+3	; 0x03
    24d0:	80 85       	ldd	r24, Z+8	; 0x08
    24d2:	88 23       	and	r24, r24
    24d4:	49 f0       	breq	.+18     	; 0x24e8 <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    24d6:	8a 81       	ldd	r24, Y+2	; 0x02
    24d8:	9b 81       	ldd	r25, Y+3	; 0x03
    24da:	08 96       	adiw	r24, 0x08	; 8
    24dc:	0e 94 12 22 	call	0x4424	; 0x4424 <xTaskRemoveFromEventList>
    24e0:	88 23       	and	r24, r24
    24e2:	11 f0       	breq	.+4      	; 0x24e8 <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    24e4:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    24e8:	0f 90       	pop	r0
    24ea:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    24ec:	81 e0       	ldi	r24, 0x01	; 1
    24ee:	8c 87       	std	Y+12, r24	; 0x0c
    24f0:	63 c0       	rjmp	.+198    	; 0x25b8 <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    24f2:	8a 85       	ldd	r24, Y+10	; 0x0a
    24f4:	9b 85       	ldd	r25, Y+11	; 0x0b
    24f6:	00 97       	sbiw	r24, 0x00	; 0
    24f8:	21 f4       	brne	.+8      	; 0x2502 <xQueueSemaphoreTake+0x7a>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    24fa:	0f 90       	pop	r0
    24fc:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    24fe:	1c 86       	std	Y+12, r1	; 0x0c
    2500:	5b c0       	rjmp	.+182    	; 0x25b8 <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    2502:	8c 81       	ldd	r24, Y+4	; 0x04
    2504:	88 23       	and	r24, r24
    2506:	31 f4       	brne	.+12     	; 0x2514 <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2508:	ce 01       	movw	r24, r28
    250a:	05 96       	adiw	r24, 0x05	; 5
    250c:	0e 94 82 24 	call	0x4904	; 0x4904 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2510:	81 e0       	ldi	r24, 0x01	; 1
    2512:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2514:	0f 90       	pop	r0
    2516:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2518:	0e 94 30 1c 	call	0x3860	; 0x3860 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    251c:	0f b6       	in	r0, 0x3f	; 63
    251e:	f8 94       	cli
    2520:	0f 92       	push	r0
    2522:	ea 81       	ldd	r30, Y+2	; 0x02
    2524:	fb 81       	ldd	r31, Y+3	; 0x03
    2526:	85 8d       	ldd	r24, Z+29	; 0x1d
    2528:	8f 3f       	cpi	r24, 0xFF	; 255
    252a:	19 f4       	brne	.+6      	; 0x2532 <xQueueSemaphoreTake+0xaa>
    252c:	ea 81       	ldd	r30, Y+2	; 0x02
    252e:	fb 81       	ldd	r31, Y+3	; 0x03
    2530:	15 8e       	std	Z+29, r1	; 0x1d
    2532:	ea 81       	ldd	r30, Y+2	; 0x02
    2534:	fb 81       	ldd	r31, Y+3	; 0x03
    2536:	86 8d       	ldd	r24, Z+30	; 0x1e
    2538:	8f 3f       	cpi	r24, 0xFF	; 255
    253a:	19 f4       	brne	.+6      	; 0x2542 <xQueueSemaphoreTake+0xba>
    253c:	ea 81       	ldd	r30, Y+2	; 0x02
    253e:	fb 81       	ldd	r31, Y+3	; 0x03
    2540:	16 8e       	std	Z+30, r1	; 0x1e
    2542:	0f 90       	pop	r0
    2544:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2546:	ce 01       	movw	r24, r28
    2548:	05 96       	adiw	r24, 0x05	; 5
    254a:	9e 01       	movw	r18, r28
    254c:	26 5f       	subi	r18, 0xF6	; 246
    254e:	3f 4f       	sbci	r19, 0xFF	; 255
    2550:	b9 01       	movw	r22, r18
    2552:	0e 94 9b 24 	call	0x4936	; 0x4936 <xTaskCheckForTimeOut>
    2556:	88 23       	and	r24, r24
    2558:	09 f5       	brne	.+66     	; 0x259c <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    255a:	8a 81       	ldd	r24, Y+2	; 0x02
    255c:	9b 81       	ldd	r25, Y+3	; 0x03
    255e:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <prvIsQueueEmpty>
    2562:	88 23       	and	r24, r24
    2564:	a1 f0       	breq	.+40     	; 0x258e <xQueueSemaphoreTake+0x106>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2566:	8a 81       	ldd	r24, Y+2	; 0x02
    2568:	9b 81       	ldd	r25, Y+3	; 0x03
    256a:	41 96       	adiw	r24, 0x11	; 17
    256c:	2a 85       	ldd	r18, Y+10	; 0x0a
    256e:	3b 85       	ldd	r19, Y+11	; 0x0b
    2570:	b9 01       	movw	r22, r18
    2572:	0e 94 29 21 	call	0x4252	; 0x4252 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2576:	8a 81       	ldd	r24, Y+2	; 0x02
    2578:	9b 81       	ldd	r25, Y+3	; 0x03
    257a:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    257e:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>
    2582:	88 23       	and	r24, r24
    2584:	09 f0       	breq	.+2      	; 0x2588 <xQueueSemaphoreTake+0x100>
    2586:	93 cf       	rjmp	.-218    	; 0x24ae <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    2588:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    258c:	90 cf       	rjmp	.-224    	; 0x24ae <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    258e:	8a 81       	ldd	r24, Y+2	; 0x02
    2590:	9b 81       	ldd	r25, Y+3	; 0x03
    2592:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2596:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>
    259a:	89 cf       	rjmp	.-238    	; 0x24ae <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    259c:	8a 81       	ldd	r24, Y+2	; 0x02
    259e:	9b 81       	ldd	r25, Y+3	; 0x03
    25a0:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    25a4:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    25a8:	8a 81       	ldd	r24, Y+2	; 0x02
    25aa:	9b 81       	ldd	r25, Y+3	; 0x03
    25ac:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <prvIsQueueEmpty>
    25b0:	88 23       	and	r24, r24
    25b2:	09 f4       	brne	.+2      	; 0x25b6 <xQueueSemaphoreTake+0x12e>
    25b4:	7c cf       	rjmp	.-264    	; 0x24ae <xQueueSemaphoreTake+0x26>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    25b6:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    25b8:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    25ba:	2c 96       	adiw	r28, 0x0c	; 12
    25bc:	0f b6       	in	r0, 0x3f	; 63
    25be:	f8 94       	cli
    25c0:	de bf       	out	0x3e, r29	; 62
    25c2:	0f be       	out	0x3f, r0	; 63
    25c4:	cd bf       	out	0x3d, r28	; 61
    25c6:	cf 91       	pop	r28
    25c8:	df 91       	pop	r29
    25ca:	08 95       	ret

000025cc <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    25cc:	df 93       	push	r29
    25ce:	cf 93       	push	r28
    25d0:	cd b7       	in	r28, 0x3d	; 61
    25d2:	de b7       	in	r29, 0x3e	; 62
    25d4:	60 97       	sbiw	r28, 0x10	; 16
    25d6:	0f b6       	in	r0, 0x3f	; 63
    25d8:	f8 94       	cli
    25da:	de bf       	out	0x3e, r29	; 62
    25dc:	0f be       	out	0x3f, r0	; 63
    25de:	cd bf       	out	0x3d, r28	; 61
    25e0:	9b 87       	std	Y+11, r25	; 0x0b
    25e2:	8a 87       	std	Y+10, r24	; 0x0a
    25e4:	7d 87       	std	Y+13, r23	; 0x0d
    25e6:	6c 87       	std	Y+12, r22	; 0x0c
    25e8:	5f 87       	std	Y+15, r21	; 0x0f
    25ea:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    25ec:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    25ee:	8a 85       	ldd	r24, Y+10	; 0x0a
    25f0:	9b 85       	ldd	r25, Y+11	; 0x0b
    25f2:	9b 83       	std	Y+3, r25	; 0x03
    25f4:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    25f6:	0f b6       	in	r0, 0x3f	; 63
    25f8:	f8 94       	cli
    25fa:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    25fc:	ea 81       	ldd	r30, Y+2	; 0x02
    25fe:	fb 81       	ldd	r31, Y+3	; 0x03
    2600:	82 8d       	ldd	r24, Z+26	; 0x1a
    2602:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2604:	89 81       	ldd	r24, Y+1	; 0x01
    2606:	88 23       	and	r24, r24
    2608:	31 f1       	breq	.+76     	; 0x2656 <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    260a:	ea 81       	ldd	r30, Y+2	; 0x02
    260c:	fb 81       	ldd	r31, Y+3	; 0x03
    260e:	86 81       	ldd	r24, Z+6	; 0x06
    2610:	97 81       	ldd	r25, Z+7	; 0x07
    2612:	9d 83       	std	Y+5, r25	; 0x05
    2614:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2616:	8a 81       	ldd	r24, Y+2	; 0x02
    2618:	9b 81       	ldd	r25, Y+3	; 0x03
    261a:	2c 85       	ldd	r18, Y+12	; 0x0c
    261c:	3d 85       	ldd	r19, Y+13	; 0x0d
    261e:	b9 01       	movw	r22, r18
    2620:	0e 94 6d 15 	call	0x2ada	; 0x2ada <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2624:	ea 81       	ldd	r30, Y+2	; 0x02
    2626:	fb 81       	ldd	r31, Y+3	; 0x03
    2628:	8c 81       	ldd	r24, Y+4	; 0x04
    262a:	9d 81       	ldd	r25, Y+5	; 0x05
    262c:	97 83       	std	Z+7, r25	; 0x07
    262e:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2630:	ea 81       	ldd	r30, Y+2	; 0x02
    2632:	fb 81       	ldd	r31, Y+3	; 0x03
    2634:	81 89       	ldd	r24, Z+17	; 0x11
    2636:	88 23       	and	r24, r24
    2638:	49 f0       	breq	.+18     	; 0x264c <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    263a:	8a 81       	ldd	r24, Y+2	; 0x02
    263c:	9b 81       	ldd	r25, Y+3	; 0x03
    263e:	41 96       	adiw	r24, 0x11	; 17
    2640:	0e 94 12 22 	call	0x4424	; 0x4424 <xTaskRemoveFromEventList>
    2644:	88 23       	and	r24, r24
    2646:	11 f0       	breq	.+4      	; 0x264c <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    2648:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    264c:	0f 90       	pop	r0
    264e:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2650:	81 e0       	ldi	r24, 0x01	; 1
    2652:	88 8b       	std	Y+16, r24	; 0x10
    2654:	63 c0       	rjmp	.+198    	; 0x271c <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2656:	8e 85       	ldd	r24, Y+14	; 0x0e
    2658:	9f 85       	ldd	r25, Y+15	; 0x0f
    265a:	00 97       	sbiw	r24, 0x00	; 0
    265c:	21 f4       	brne	.+8      	; 0x2666 <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    265e:	0f 90       	pop	r0
    2660:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2662:	18 8a       	std	Y+16, r1	; 0x10
    2664:	5b c0       	rjmp	.+182    	; 0x271c <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    2666:	8e 81       	ldd	r24, Y+6	; 0x06
    2668:	88 23       	and	r24, r24
    266a:	31 f4       	brne	.+12     	; 0x2678 <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    266c:	ce 01       	movw	r24, r28
    266e:	07 96       	adiw	r24, 0x07	; 7
    2670:	0e 94 82 24 	call	0x4904	; 0x4904 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2674:	81 e0       	ldi	r24, 0x01	; 1
    2676:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2678:	0f 90       	pop	r0
    267a:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    267c:	0e 94 30 1c 	call	0x3860	; 0x3860 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2680:	0f b6       	in	r0, 0x3f	; 63
    2682:	f8 94       	cli
    2684:	0f 92       	push	r0
    2686:	ea 81       	ldd	r30, Y+2	; 0x02
    2688:	fb 81       	ldd	r31, Y+3	; 0x03
    268a:	85 8d       	ldd	r24, Z+29	; 0x1d
    268c:	8f 3f       	cpi	r24, 0xFF	; 255
    268e:	19 f4       	brne	.+6      	; 0x2696 <xQueuePeek+0xca>
    2690:	ea 81       	ldd	r30, Y+2	; 0x02
    2692:	fb 81       	ldd	r31, Y+3	; 0x03
    2694:	15 8e       	std	Z+29, r1	; 0x1d
    2696:	ea 81       	ldd	r30, Y+2	; 0x02
    2698:	fb 81       	ldd	r31, Y+3	; 0x03
    269a:	86 8d       	ldd	r24, Z+30	; 0x1e
    269c:	8f 3f       	cpi	r24, 0xFF	; 255
    269e:	19 f4       	brne	.+6      	; 0x26a6 <xQueuePeek+0xda>
    26a0:	ea 81       	ldd	r30, Y+2	; 0x02
    26a2:	fb 81       	ldd	r31, Y+3	; 0x03
    26a4:	16 8e       	std	Z+30, r1	; 0x1e
    26a6:	0f 90       	pop	r0
    26a8:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    26aa:	ce 01       	movw	r24, r28
    26ac:	07 96       	adiw	r24, 0x07	; 7
    26ae:	9e 01       	movw	r18, r28
    26b0:	22 5f       	subi	r18, 0xF2	; 242
    26b2:	3f 4f       	sbci	r19, 0xFF	; 255
    26b4:	b9 01       	movw	r22, r18
    26b6:	0e 94 9b 24 	call	0x4936	; 0x4936 <xTaskCheckForTimeOut>
    26ba:	88 23       	and	r24, r24
    26bc:	09 f5       	brne	.+66     	; 0x2700 <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    26be:	8a 81       	ldd	r24, Y+2	; 0x02
    26c0:	9b 81       	ldd	r25, Y+3	; 0x03
    26c2:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <prvIsQueueEmpty>
    26c6:	88 23       	and	r24, r24
    26c8:	a1 f0       	breq	.+40     	; 0x26f2 <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    26ca:	8a 81       	ldd	r24, Y+2	; 0x02
    26cc:	9b 81       	ldd	r25, Y+3	; 0x03
    26ce:	41 96       	adiw	r24, 0x11	; 17
    26d0:	2e 85       	ldd	r18, Y+14	; 0x0e
    26d2:	3f 85       	ldd	r19, Y+15	; 0x0f
    26d4:	b9 01       	movw	r22, r18
    26d6:	0e 94 29 21 	call	0x4252	; 0x4252 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    26da:	8a 81       	ldd	r24, Y+2	; 0x02
    26dc:	9b 81       	ldd	r25, Y+3	; 0x03
    26de:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    26e2:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>
    26e6:	88 23       	and	r24, r24
    26e8:	09 f0       	breq	.+2      	; 0x26ec <xQueuePeek+0x120>
    26ea:	85 cf       	rjmp	.-246    	; 0x25f6 <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    26ec:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    26f0:	82 cf       	rjmp	.-252    	; 0x25f6 <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    26f2:	8a 81       	ldd	r24, Y+2	; 0x02
    26f4:	9b 81       	ldd	r25, Y+3	; 0x03
    26f6:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    26fa:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>
    26fe:	7b cf       	rjmp	.-266    	; 0x25f6 <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    2700:	8a 81       	ldd	r24, Y+2	; 0x02
    2702:	9b 81       	ldd	r25, Y+3	; 0x03
    2704:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2708:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    270c:	8a 81       	ldd	r24, Y+2	; 0x02
    270e:	9b 81       	ldd	r25, Y+3	; 0x03
    2710:	0e 94 07 16 	call	0x2c0e	; 0x2c0e <prvIsQueueEmpty>
    2714:	88 23       	and	r24, r24
    2716:	09 f4       	brne	.+2      	; 0x271a <xQueuePeek+0x14e>
    2718:	6e cf       	rjmp	.-292    	; 0x25f6 <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    271a:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    271c:	88 89       	ldd	r24, Y+16	; 0x10
}
    271e:	60 96       	adiw	r28, 0x10	; 16
    2720:	0f b6       	in	r0, 0x3f	; 63
    2722:	f8 94       	cli
    2724:	de bf       	out	0x3e, r29	; 62
    2726:	0f be       	out	0x3f, r0	; 63
    2728:	cd bf       	out	0x3d, r28	; 61
    272a:	cf 91       	pop	r28
    272c:	df 91       	pop	r29
    272e:	08 95       	ret

00002730 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2730:	df 93       	push	r29
    2732:	cf 93       	push	r28
    2734:	cd b7       	in	r28, 0x3d	; 61
    2736:	de b7       	in	r29, 0x3e	; 62
    2738:	2c 97       	sbiw	r28, 0x0c	; 12
    273a:	0f b6       	in	r0, 0x3f	; 63
    273c:	f8 94       	cli
    273e:	de bf       	out	0x3e, r29	; 62
    2740:	0f be       	out	0x3f, r0	; 63
    2742:	cd bf       	out	0x3d, r28	; 61
    2744:	98 87       	std	Y+8, r25	; 0x08
    2746:	8f 83       	std	Y+7, r24	; 0x07
    2748:	7a 87       	std	Y+10, r23	; 0x0a
    274a:	69 87       	std	Y+9, r22	; 0x09
    274c:	5c 87       	std	Y+12, r21	; 0x0c
    274e:	4b 87       	std	Y+11, r20	; 0x0b
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    2750:	8f 81       	ldd	r24, Y+7	; 0x07
    2752:	98 85       	ldd	r25, Y+8	; 0x08
    2754:	9c 83       	std	Y+4, r25	; 0x04
    2756:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2758:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    275a:	eb 81       	ldd	r30, Y+3	; 0x03
    275c:	fc 81       	ldd	r31, Y+4	; 0x04
    275e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2760:	8a 83       	std	Y+2, r24	; 0x02

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2762:	8a 81       	ldd	r24, Y+2	; 0x02
    2764:	88 23       	and	r24, r24
    2766:	81 f1       	breq	.+96     	; 0x27c8 <xQueueReceiveFromISR+0x98>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    2768:	eb 81       	ldd	r30, Y+3	; 0x03
    276a:	fc 81       	ldd	r31, Y+4	; 0x04
    276c:	85 8d       	ldd	r24, Z+29	; 0x1d
    276e:	89 83       	std	Y+1, r24	; 0x01

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2770:	8b 81       	ldd	r24, Y+3	; 0x03
    2772:	9c 81       	ldd	r25, Y+4	; 0x04
    2774:	29 85       	ldd	r18, Y+9	; 0x09
    2776:	3a 85       	ldd	r19, Y+10	; 0x0a
    2778:	b9 01       	movw	r22, r18
    277a:	0e 94 6d 15 	call	0x2ada	; 0x2ada <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    277e:	8a 81       	ldd	r24, Y+2	; 0x02
    2780:	81 50       	subi	r24, 0x01	; 1
    2782:	eb 81       	ldd	r30, Y+3	; 0x03
    2784:	fc 81       	ldd	r31, Y+4	; 0x04
    2786:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    2788:	89 81       	ldd	r24, Y+1	; 0x01
    278a:	8f 3f       	cpi	r24, 0xFF	; 255
    278c:	a9 f4       	brne	.+42     	; 0x27b8 <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    278e:	eb 81       	ldd	r30, Y+3	; 0x03
    2790:	fc 81       	ldd	r31, Y+4	; 0x04
    2792:	80 85       	ldd	r24, Z+8	; 0x08
    2794:	88 23       	and	r24, r24
    2796:	a9 f0       	breq	.+42     	; 0x27c2 <xQueueReceiveFromISR+0x92>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2798:	8b 81       	ldd	r24, Y+3	; 0x03
    279a:	9c 81       	ldd	r25, Y+4	; 0x04
    279c:	08 96       	adiw	r24, 0x08	; 8
    279e:	0e 94 12 22 	call	0x4424	; 0x4424 <xTaskRemoveFromEventList>
    27a2:	88 23       	and	r24, r24
    27a4:	71 f0       	breq	.+28     	; 0x27c2 <xQueueReceiveFromISR+0x92>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    27a6:	8b 85       	ldd	r24, Y+11	; 0x0b
    27a8:	9c 85       	ldd	r25, Y+12	; 0x0c
    27aa:	00 97       	sbiw	r24, 0x00	; 0
    27ac:	51 f0       	breq	.+20     	; 0x27c2 <xQueueReceiveFromISR+0x92>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    27ae:	eb 85       	ldd	r30, Y+11	; 0x0b
    27b0:	fc 85       	ldd	r31, Y+12	; 0x0c
    27b2:	81 e0       	ldi	r24, 0x01	; 1
    27b4:	80 83       	st	Z, r24
    27b6:	05 c0       	rjmp	.+10     	; 0x27c2 <xQueueReceiveFromISR+0x92>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    27b8:	89 81       	ldd	r24, Y+1	; 0x01
    27ba:	8f 5f       	subi	r24, 0xFF	; 255
    27bc:	eb 81       	ldd	r30, Y+3	; 0x03
    27be:	fc 81       	ldd	r31, Y+4	; 0x04
    27c0:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    27c2:	81 e0       	ldi	r24, 0x01	; 1
    27c4:	8e 83       	std	Y+6, r24	; 0x06
    27c6:	01 c0       	rjmp	.+2      	; 0x27ca <xQueueReceiveFromISR+0x9a>
        }
        else
        {
            xReturn = pdFAIL;
    27c8:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    27ca:	8e 81       	ldd	r24, Y+6	; 0x06
}
    27cc:	2c 96       	adiw	r28, 0x0c	; 12
    27ce:	0f b6       	in	r0, 0x3f	; 63
    27d0:	f8 94       	cli
    27d2:	de bf       	out	0x3e, r29	; 62
    27d4:	0f be       	out	0x3f, r0	; 63
    27d6:	cd bf       	out	0x3d, r28	; 61
    27d8:	cf 91       	pop	r28
    27da:	df 91       	pop	r29
    27dc:	08 95       	ret

000027de <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    27de:	df 93       	push	r29
    27e0:	cf 93       	push	r28
    27e2:	cd b7       	in	r28, 0x3d	; 61
    27e4:	de b7       	in	r29, 0x3e	; 62
    27e6:	2a 97       	sbiw	r28, 0x0a	; 10
    27e8:	0f b6       	in	r0, 0x3f	; 63
    27ea:	f8 94       	cli
    27ec:	de bf       	out	0x3e, r29	; 62
    27ee:	0f be       	out	0x3f, r0	; 63
    27f0:	cd bf       	out	0x3d, r28	; 61
    27f2:	98 87       	std	Y+8, r25	; 0x08
    27f4:	8f 83       	std	Y+7, r24	; 0x07
    27f6:	7a 87       	std	Y+10, r23	; 0x0a
    27f8:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    27fa:	8f 81       	ldd	r24, Y+7	; 0x07
    27fc:	98 85       	ldd	r25, Y+8	; 0x08
    27fe:	9a 83       	std	Y+2, r25	; 0x02
    2800:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2802:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2804:	e9 81       	ldd	r30, Y+1	; 0x01
    2806:	fa 81       	ldd	r31, Y+2	; 0x02
    2808:	82 8d       	ldd	r24, Z+26	; 0x1a
    280a:	88 23       	and	r24, r24
    280c:	b1 f0       	breq	.+44     	; 0x283a <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    280e:	e9 81       	ldd	r30, Y+1	; 0x01
    2810:	fa 81       	ldd	r31, Y+2	; 0x02
    2812:	86 81       	ldd	r24, Z+6	; 0x06
    2814:	97 81       	ldd	r25, Z+7	; 0x07
    2816:	9c 83       	std	Y+4, r25	; 0x04
    2818:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    281a:	89 81       	ldd	r24, Y+1	; 0x01
    281c:	9a 81       	ldd	r25, Y+2	; 0x02
    281e:	29 85       	ldd	r18, Y+9	; 0x09
    2820:	3a 85       	ldd	r19, Y+10	; 0x0a
    2822:	b9 01       	movw	r22, r18
    2824:	0e 94 6d 15 	call	0x2ada	; 0x2ada <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2828:	e9 81       	ldd	r30, Y+1	; 0x01
    282a:	fa 81       	ldd	r31, Y+2	; 0x02
    282c:	8b 81       	ldd	r24, Y+3	; 0x03
    282e:	9c 81       	ldd	r25, Y+4	; 0x04
    2830:	97 83       	std	Z+7, r25	; 0x07
    2832:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    2834:	81 e0       	ldi	r24, 0x01	; 1
    2836:	8e 83       	std	Y+6, r24	; 0x06
    2838:	01 c0       	rjmp	.+2      	; 0x283c <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    283a:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    283c:	8e 81       	ldd	r24, Y+6	; 0x06
}
    283e:	2a 96       	adiw	r28, 0x0a	; 10
    2840:	0f b6       	in	r0, 0x3f	; 63
    2842:	f8 94       	cli
    2844:	de bf       	out	0x3e, r29	; 62
    2846:	0f be       	out	0x3f, r0	; 63
    2848:	cd bf       	out	0x3d, r28	; 61
    284a:	cf 91       	pop	r28
    284c:	df 91       	pop	r29
    284e:	08 95       	ret

00002850 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2850:	df 93       	push	r29
    2852:	cf 93       	push	r28
    2854:	00 d0       	rcall	.+0      	; 0x2856 <uxQueueMessagesWaiting+0x6>
    2856:	0f 92       	push	r0
    2858:	cd b7       	in	r28, 0x3d	; 61
    285a:	de b7       	in	r29, 0x3e	; 62
    285c:	9b 83       	std	Y+3, r25	; 0x03
    285e:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    2860:	0f b6       	in	r0, 0x3f	; 63
    2862:	f8 94       	cli
    2864:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2866:	ea 81       	ldd	r30, Y+2	; 0x02
    2868:	fb 81       	ldd	r31, Y+3	; 0x03
    286a:	82 8d       	ldd	r24, Z+26	; 0x1a
    286c:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    286e:	0f 90       	pop	r0
    2870:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2872:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2874:	0f 90       	pop	r0
    2876:	0f 90       	pop	r0
    2878:	0f 90       	pop	r0
    287a:	cf 91       	pop	r28
    287c:	df 91       	pop	r29
    287e:	08 95       	ret

00002880 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2880:	df 93       	push	r29
    2882:	cf 93       	push	r28
    2884:	00 d0       	rcall	.+0      	; 0x2886 <uxQueueSpacesAvailable+0x6>
    2886:	00 d0       	rcall	.+0      	; 0x2888 <uxQueueSpacesAvailable+0x8>
    2888:	0f 92       	push	r0
    288a:	cd b7       	in	r28, 0x3d	; 61
    288c:	de b7       	in	r29, 0x3e	; 62
    288e:	9d 83       	std	Y+5, r25	; 0x05
    2890:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    2892:	8c 81       	ldd	r24, Y+4	; 0x04
    2894:	9d 81       	ldd	r25, Y+5	; 0x05
    2896:	9a 83       	std	Y+2, r25	; 0x02
    2898:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    289a:	0f b6       	in	r0, 0x3f	; 63
    289c:	f8 94       	cli
    289e:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    28a0:	e9 81       	ldd	r30, Y+1	; 0x01
    28a2:	fa 81       	ldd	r31, Y+2	; 0x02
    28a4:	93 8d       	ldd	r25, Z+27	; 0x1b
    28a6:	e9 81       	ldd	r30, Y+1	; 0x01
    28a8:	fa 81       	ldd	r31, Y+2	; 0x02
    28aa:	82 8d       	ldd	r24, Z+26	; 0x1a
    28ac:	29 2f       	mov	r18, r25
    28ae:	28 1b       	sub	r18, r24
    28b0:	82 2f       	mov	r24, r18
    28b2:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    28b4:	0f 90       	pop	r0
    28b6:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    28b8:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    28ba:	0f 90       	pop	r0
    28bc:	0f 90       	pop	r0
    28be:	0f 90       	pop	r0
    28c0:	0f 90       	pop	r0
    28c2:	0f 90       	pop	r0
    28c4:	cf 91       	pop	r28
    28c6:	df 91       	pop	r29
    28c8:	08 95       	ret

000028ca <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    28ca:	df 93       	push	r29
    28cc:	cf 93       	push	r28
    28ce:	00 d0       	rcall	.+0      	; 0x28d0 <uxQueueMessagesWaitingFromISR+0x6>
    28d0:	00 d0       	rcall	.+0      	; 0x28d2 <uxQueueMessagesWaitingFromISR+0x8>
    28d2:	0f 92       	push	r0
    28d4:	cd b7       	in	r28, 0x3d	; 61
    28d6:	de b7       	in	r29, 0x3e	; 62
    28d8:	9d 83       	std	Y+5, r25	; 0x05
    28da:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    28dc:	8c 81       	ldd	r24, Y+4	; 0x04
    28de:	9d 81       	ldd	r25, Y+5	; 0x05
    28e0:	9a 83       	std	Y+2, r25	; 0x02
    28e2:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    28e4:	e9 81       	ldd	r30, Y+1	; 0x01
    28e6:	fa 81       	ldd	r31, Y+2	; 0x02
    28e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    28ea:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    28ec:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    28ee:	0f 90       	pop	r0
    28f0:	0f 90       	pop	r0
    28f2:	0f 90       	pop	r0
    28f4:	0f 90       	pop	r0
    28f6:	0f 90       	pop	r0
    28f8:	cf 91       	pop	r28
    28fa:	df 91       	pop	r29
    28fc:	08 95       	ret

000028fe <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    28fe:	df 93       	push	r29
    2900:	cf 93       	push	r28
    2902:	00 d0       	rcall	.+0      	; 0x2904 <vQueueDelete+0x6>
    2904:	00 d0       	rcall	.+0      	; 0x2906 <vQueueDelete+0x8>
    2906:	cd b7       	in	r28, 0x3d	; 61
    2908:	de b7       	in	r29, 0x3e	; 62
    290a:	9c 83       	std	Y+4, r25	; 0x04
    290c:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    290e:	8b 81       	ldd	r24, Y+3	; 0x03
    2910:	9c 81       	ldd	r25, Y+4	; 0x04
    2912:	9a 83       	std	Y+2, r25	; 0x02
    2914:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    2916:	89 81       	ldd	r24, Y+1	; 0x01
    2918:	9a 81       	ldd	r25, Y+2	; 0x02
    291a:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    291e:	0f 90       	pop	r0
    2920:	0f 90       	pop	r0
    2922:	0f 90       	pop	r0
    2924:	0f 90       	pop	r0
    2926:	cf 91       	pop	r28
    2928:	df 91       	pop	r29
    292a:	08 95       	ret

0000292c <uxQueueGetQueueNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

    UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
    {
    292c:	df 93       	push	r29
    292e:	cf 93       	push	r28
    2930:	00 d0       	rcall	.+0      	; 0x2932 <uxQueueGetQueueNumber+0x6>
    2932:	cd b7       	in	r28, 0x3d	; 61
    2934:	de b7       	in	r29, 0x3e	; 62
    2936:	9a 83       	std	Y+2, r25	; 0x02
    2938:	89 83       	std	Y+1, r24	; 0x01
        return ( ( Queue_t * ) xQueue )->uxQueueNumber;
    293a:	e9 81       	ldd	r30, Y+1	; 0x01
    293c:	fa 81       	ldd	r31, Y+2	; 0x02
    293e:	87 8d       	ldd	r24, Z+31	; 0x1f
    }
    2940:	0f 90       	pop	r0
    2942:	0f 90       	pop	r0
    2944:	cf 91       	pop	r28
    2946:	df 91       	pop	r29
    2948:	08 95       	ret

0000294a <vQueueSetQueueNumber>:

#if ( configUSE_TRACE_FACILITY == 1 )

    void vQueueSetQueueNumber( QueueHandle_t xQueue,
                               UBaseType_t uxQueueNumber )
    {
    294a:	df 93       	push	r29
    294c:	cf 93       	push	r28
    294e:	00 d0       	rcall	.+0      	; 0x2950 <vQueueSetQueueNumber+0x6>
    2950:	0f 92       	push	r0
    2952:	cd b7       	in	r28, 0x3d	; 61
    2954:	de b7       	in	r29, 0x3e	; 62
    2956:	9a 83       	std	Y+2, r25	; 0x02
    2958:	89 83       	std	Y+1, r24	; 0x01
    295a:	6b 83       	std	Y+3, r22	; 0x03
        ( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
    295c:	e9 81       	ldd	r30, Y+1	; 0x01
    295e:	fa 81       	ldd	r31, Y+2	; 0x02
    2960:	8b 81       	ldd	r24, Y+3	; 0x03
    2962:	87 8f       	std	Z+31, r24	; 0x1f
    }
    2964:	0f 90       	pop	r0
    2966:	0f 90       	pop	r0
    2968:	0f 90       	pop	r0
    296a:	cf 91       	pop	r28
    296c:	df 91       	pop	r29
    296e:	08 95       	ret

00002970 <ucQueueGetQueueType>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

    uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
    {
    2970:	df 93       	push	r29
    2972:	cf 93       	push	r28
    2974:	00 d0       	rcall	.+0      	; 0x2976 <ucQueueGetQueueType+0x6>
    2976:	cd b7       	in	r28, 0x3d	; 61
    2978:	de b7       	in	r29, 0x3e	; 62
    297a:	9a 83       	std	Y+2, r25	; 0x02
    297c:	89 83       	std	Y+1, r24	; 0x01
        return ( ( Queue_t * ) xQueue )->ucQueueType;
    297e:	e9 81       	ldd	r30, Y+1	; 0x01
    2980:	fa 81       	ldd	r31, Y+2	; 0x02
    2982:	80 a1       	ldd	r24, Z+32	; 0x20
    }
    2984:	0f 90       	pop	r0
    2986:	0f 90       	pop	r0
    2988:	cf 91       	pop	r28
    298a:	df 91       	pop	r29
    298c:	08 95       	ret

0000298e <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    298e:	df 93       	push	r29
    2990:	cf 93       	push	r28
    2992:	cd b7       	in	r28, 0x3d	; 61
    2994:	de b7       	in	r29, 0x3e	; 62
    2996:	27 97       	sbiw	r28, 0x07	; 7
    2998:	0f b6       	in	r0, 0x3f	; 63
    299a:	f8 94       	cli
    299c:	de bf       	out	0x3e, r29	; 62
    299e:	0f be       	out	0x3f, r0	; 63
    29a0:	cd bf       	out	0x3d, r28	; 61
    29a2:	9c 83       	std	Y+4, r25	; 0x04
    29a4:	8b 83       	std	Y+3, r24	; 0x03
    29a6:	7e 83       	std	Y+6, r23	; 0x06
    29a8:	6d 83       	std	Y+5, r22	; 0x05
    29aa:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    29ac:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    29ae:	eb 81       	ldd	r30, Y+3	; 0x03
    29b0:	fc 81       	ldd	r31, Y+4	; 0x04
    29b2:	82 8d       	ldd	r24, Z+26	; 0x1a
    29b4:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    29b6:	eb 81       	ldd	r30, Y+3	; 0x03
    29b8:	fc 81       	ldd	r31, Y+4	; 0x04
    29ba:	84 8d       	ldd	r24, Z+28	; 0x1c
    29bc:	88 23       	and	r24, r24
    29be:	09 f4       	brne	.+2      	; 0x29c2 <prvCopyDataToQueue+0x34>
    29c0:	7d c0       	rjmp	.+250    	; 0x2abc <prvCopyDataToQueue+0x12e>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    29c2:	8f 81       	ldd	r24, Y+7	; 0x07
    29c4:	88 23       	and	r24, r24
    29c6:	99 f5       	brne	.+102    	; 0x2a2e <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    29c8:	eb 81       	ldd	r30, Y+3	; 0x03
    29ca:	fc 81       	ldd	r31, Y+4	; 0x04
    29cc:	62 81       	ldd	r22, Z+2	; 0x02
    29ce:	73 81       	ldd	r23, Z+3	; 0x03
    29d0:	eb 81       	ldd	r30, Y+3	; 0x03
    29d2:	fc 81       	ldd	r31, Y+4	; 0x04
    29d4:	84 8d       	ldd	r24, Z+28	; 0x1c
    29d6:	48 2f       	mov	r20, r24
    29d8:	50 e0       	ldi	r21, 0x00	; 0
    29da:	2d 81       	ldd	r18, Y+5	; 0x05
    29dc:	3e 81       	ldd	r19, Y+6	; 0x06
    29de:	cb 01       	movw	r24, r22
    29e0:	b9 01       	movw	r22, r18
    29e2:	0e 94 a8 39 	call	0x7350	; 0x7350 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    29e6:	eb 81       	ldd	r30, Y+3	; 0x03
    29e8:	fc 81       	ldd	r31, Y+4	; 0x04
    29ea:	22 81       	ldd	r18, Z+2	; 0x02
    29ec:	33 81       	ldd	r19, Z+3	; 0x03
    29ee:	eb 81       	ldd	r30, Y+3	; 0x03
    29f0:	fc 81       	ldd	r31, Y+4	; 0x04
    29f2:	84 8d       	ldd	r24, Z+28	; 0x1c
    29f4:	88 2f       	mov	r24, r24
    29f6:	90 e0       	ldi	r25, 0x00	; 0
    29f8:	82 0f       	add	r24, r18
    29fa:	93 1f       	adc	r25, r19
    29fc:	eb 81       	ldd	r30, Y+3	; 0x03
    29fe:	fc 81       	ldd	r31, Y+4	; 0x04
    2a00:	93 83       	std	Z+3, r25	; 0x03
    2a02:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2a04:	eb 81       	ldd	r30, Y+3	; 0x03
    2a06:	fc 81       	ldd	r31, Y+4	; 0x04
    2a08:	22 81       	ldd	r18, Z+2	; 0x02
    2a0a:	33 81       	ldd	r19, Z+3	; 0x03
    2a0c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a0e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a10:	84 81       	ldd	r24, Z+4	; 0x04
    2a12:	95 81       	ldd	r25, Z+5	; 0x05
    2a14:	28 17       	cp	r18, r24
    2a16:	39 07       	cpc	r19, r25
    2a18:	08 f4       	brcc	.+2      	; 0x2a1c <prvCopyDataToQueue+0x8e>
    2a1a:	50 c0       	rjmp	.+160    	; 0x2abc <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    2a1c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a1e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a20:	80 81       	ld	r24, Z
    2a22:	91 81       	ldd	r25, Z+1	; 0x01
    2a24:	eb 81       	ldd	r30, Y+3	; 0x03
    2a26:	fc 81       	ldd	r31, Y+4	; 0x04
    2a28:	93 83       	std	Z+3, r25	; 0x03
    2a2a:	82 83       	std	Z+2, r24	; 0x02
    2a2c:	47 c0       	rjmp	.+142    	; 0x2abc <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    2a2e:	eb 81       	ldd	r30, Y+3	; 0x03
    2a30:	fc 81       	ldd	r31, Y+4	; 0x04
    2a32:	66 81       	ldd	r22, Z+6	; 0x06
    2a34:	77 81       	ldd	r23, Z+7	; 0x07
    2a36:	eb 81       	ldd	r30, Y+3	; 0x03
    2a38:	fc 81       	ldd	r31, Y+4	; 0x04
    2a3a:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a3c:	48 2f       	mov	r20, r24
    2a3e:	50 e0       	ldi	r21, 0x00	; 0
    2a40:	2d 81       	ldd	r18, Y+5	; 0x05
    2a42:	3e 81       	ldd	r19, Y+6	; 0x06
    2a44:	cb 01       	movw	r24, r22
    2a46:	b9 01       	movw	r22, r18
    2a48:	0e 94 a8 39 	call	0x7350	; 0x7350 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    2a4c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a4e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a50:	26 81       	ldd	r18, Z+6	; 0x06
    2a52:	37 81       	ldd	r19, Z+7	; 0x07
    2a54:	eb 81       	ldd	r30, Y+3	; 0x03
    2a56:	fc 81       	ldd	r31, Y+4	; 0x04
    2a58:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a5a:	88 2f       	mov	r24, r24
    2a5c:	90 e0       	ldi	r25, 0x00	; 0
    2a5e:	90 95       	com	r25
    2a60:	81 95       	neg	r24
    2a62:	9f 4f       	sbci	r25, 0xFF	; 255
    2a64:	82 0f       	add	r24, r18
    2a66:	93 1f       	adc	r25, r19
    2a68:	eb 81       	ldd	r30, Y+3	; 0x03
    2a6a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a6c:	97 83       	std	Z+7, r25	; 0x07
    2a6e:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2a70:	eb 81       	ldd	r30, Y+3	; 0x03
    2a72:	fc 81       	ldd	r31, Y+4	; 0x04
    2a74:	26 81       	ldd	r18, Z+6	; 0x06
    2a76:	37 81       	ldd	r19, Z+7	; 0x07
    2a78:	eb 81       	ldd	r30, Y+3	; 0x03
    2a7a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a7c:	80 81       	ld	r24, Z
    2a7e:	91 81       	ldd	r25, Z+1	; 0x01
    2a80:	28 17       	cp	r18, r24
    2a82:	39 07       	cpc	r19, r25
    2a84:	90 f4       	brcc	.+36     	; 0x2aaa <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2a86:	eb 81       	ldd	r30, Y+3	; 0x03
    2a88:	fc 81       	ldd	r31, Y+4	; 0x04
    2a8a:	24 81       	ldd	r18, Z+4	; 0x04
    2a8c:	35 81       	ldd	r19, Z+5	; 0x05
    2a8e:	eb 81       	ldd	r30, Y+3	; 0x03
    2a90:	fc 81       	ldd	r31, Y+4	; 0x04
    2a92:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a94:	88 2f       	mov	r24, r24
    2a96:	90 e0       	ldi	r25, 0x00	; 0
    2a98:	90 95       	com	r25
    2a9a:	81 95       	neg	r24
    2a9c:	9f 4f       	sbci	r25, 0xFF	; 255
    2a9e:	82 0f       	add	r24, r18
    2aa0:	93 1f       	adc	r25, r19
    2aa2:	eb 81       	ldd	r30, Y+3	; 0x03
    2aa4:	fc 81       	ldd	r31, Y+4	; 0x04
    2aa6:	97 83       	std	Z+7, r25	; 0x07
    2aa8:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    2aaa:	8f 81       	ldd	r24, Y+7	; 0x07
    2aac:	82 30       	cpi	r24, 0x02	; 2
    2aae:	31 f4       	brne	.+12     	; 0x2abc <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2ab0:	89 81       	ldd	r24, Y+1	; 0x01
    2ab2:	88 23       	and	r24, r24
    2ab4:	19 f0       	breq	.+6      	; 0x2abc <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    2ab6:	89 81       	ldd	r24, Y+1	; 0x01
    2ab8:	81 50       	subi	r24, 0x01	; 1
    2aba:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2abc:	89 81       	ldd	r24, Y+1	; 0x01
    2abe:	8f 5f       	subi	r24, 0xFF	; 255
    2ac0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ac2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ac4:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    2ac6:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2ac8:	27 96       	adiw	r28, 0x07	; 7
    2aca:	0f b6       	in	r0, 0x3f	; 63
    2acc:	f8 94       	cli
    2ace:	de bf       	out	0x3e, r29	; 62
    2ad0:	0f be       	out	0x3f, r0	; 63
    2ad2:	cd bf       	out	0x3d, r28	; 61
    2ad4:	cf 91       	pop	r28
    2ad6:	df 91       	pop	r29
    2ad8:	08 95       	ret

00002ada <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    2ada:	df 93       	push	r29
    2adc:	cf 93       	push	r28
    2ade:	00 d0       	rcall	.+0      	; 0x2ae0 <prvCopyDataFromQueue+0x6>
    2ae0:	00 d0       	rcall	.+0      	; 0x2ae2 <prvCopyDataFromQueue+0x8>
    2ae2:	cd b7       	in	r28, 0x3d	; 61
    2ae4:	de b7       	in	r29, 0x3e	; 62
    2ae6:	9a 83       	std	Y+2, r25	; 0x02
    2ae8:	89 83       	std	Y+1, r24	; 0x01
    2aea:	7c 83       	std	Y+4, r23	; 0x04
    2aec:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2aee:	e9 81       	ldd	r30, Y+1	; 0x01
    2af0:	fa 81       	ldd	r31, Y+2	; 0x02
    2af2:	84 8d       	ldd	r24, Z+28	; 0x1c
    2af4:	88 23       	and	r24, r24
    2af6:	89 f1       	breq	.+98     	; 0x2b5a <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2af8:	e9 81       	ldd	r30, Y+1	; 0x01
    2afa:	fa 81       	ldd	r31, Y+2	; 0x02
    2afc:	26 81       	ldd	r18, Z+6	; 0x06
    2afe:	37 81       	ldd	r19, Z+7	; 0x07
    2b00:	e9 81       	ldd	r30, Y+1	; 0x01
    2b02:	fa 81       	ldd	r31, Y+2	; 0x02
    2b04:	84 8d       	ldd	r24, Z+28	; 0x1c
    2b06:	88 2f       	mov	r24, r24
    2b08:	90 e0       	ldi	r25, 0x00	; 0
    2b0a:	82 0f       	add	r24, r18
    2b0c:	93 1f       	adc	r25, r19
    2b0e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b10:	fa 81       	ldd	r31, Y+2	; 0x02
    2b12:	97 83       	std	Z+7, r25	; 0x07
    2b14:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2b16:	e9 81       	ldd	r30, Y+1	; 0x01
    2b18:	fa 81       	ldd	r31, Y+2	; 0x02
    2b1a:	26 81       	ldd	r18, Z+6	; 0x06
    2b1c:	37 81       	ldd	r19, Z+7	; 0x07
    2b1e:	e9 81       	ldd	r30, Y+1	; 0x01
    2b20:	fa 81       	ldd	r31, Y+2	; 0x02
    2b22:	84 81       	ldd	r24, Z+4	; 0x04
    2b24:	95 81       	ldd	r25, Z+5	; 0x05
    2b26:	28 17       	cp	r18, r24
    2b28:	39 07       	cpc	r19, r25
    2b2a:	40 f0       	brcs	.+16     	; 0x2b3c <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2b2c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b2e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b30:	80 81       	ld	r24, Z
    2b32:	91 81       	ldd	r25, Z+1	; 0x01
    2b34:	e9 81       	ldd	r30, Y+1	; 0x01
    2b36:	fa 81       	ldd	r31, Y+2	; 0x02
    2b38:	97 83       	std	Z+7, r25	; 0x07
    2b3a:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2b3c:	e9 81       	ldd	r30, Y+1	; 0x01
    2b3e:	fa 81       	ldd	r31, Y+2	; 0x02
    2b40:	46 81       	ldd	r20, Z+6	; 0x06
    2b42:	57 81       	ldd	r21, Z+7	; 0x07
    2b44:	e9 81       	ldd	r30, Y+1	; 0x01
    2b46:	fa 81       	ldd	r31, Y+2	; 0x02
    2b48:	84 8d       	ldd	r24, Z+28	; 0x1c
    2b4a:	28 2f       	mov	r18, r24
    2b4c:	30 e0       	ldi	r19, 0x00	; 0
    2b4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2b50:	9c 81       	ldd	r25, Y+4	; 0x04
    2b52:	ba 01       	movw	r22, r20
    2b54:	a9 01       	movw	r20, r18
    2b56:	0e 94 a8 39 	call	0x7350	; 0x7350 <memcpy>
    }
}
    2b5a:	0f 90       	pop	r0
    2b5c:	0f 90       	pop	r0
    2b5e:	0f 90       	pop	r0
    2b60:	0f 90       	pop	r0
    2b62:	cf 91       	pop	r28
    2b64:	df 91       	pop	r29
    2b66:	08 95       	ret

00002b68 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2b68:	df 93       	push	r29
    2b6a:	cf 93       	push	r28
    2b6c:	00 d0       	rcall	.+0      	; 0x2b6e <prvUnlockQueue+0x6>
    2b6e:	00 d0       	rcall	.+0      	; 0x2b70 <prvUnlockQueue+0x8>
    2b70:	cd b7       	in	r28, 0x3d	; 61
    2b72:	de b7       	in	r29, 0x3e	; 62
    2b74:	9c 83       	std	Y+4, r25	; 0x04
    2b76:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    2b78:	0f b6       	in	r0, 0x3f	; 63
    2b7a:	f8 94       	cli
    2b7c:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    2b7e:	eb 81       	ldd	r30, Y+3	; 0x03
    2b80:	fc 81       	ldd	r31, Y+4	; 0x04
    2b82:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b84:	8a 83       	std	Y+2, r24	; 0x02
    2b86:	11 c0       	rjmp	.+34     	; 0x2baa <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2b88:	eb 81       	ldd	r30, Y+3	; 0x03
    2b8a:	fc 81       	ldd	r31, Y+4	; 0x04
    2b8c:	81 89       	ldd	r24, Z+17	; 0x11
    2b8e:	88 23       	and	r24, r24
    2b90:	79 f0       	breq	.+30     	; 0x2bb0 <prvUnlockQueue+0x48>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2b92:	8b 81       	ldd	r24, Y+3	; 0x03
    2b94:	9c 81       	ldd	r25, Y+4	; 0x04
    2b96:	41 96       	adiw	r24, 0x11	; 17
    2b98:	0e 94 12 22 	call	0x4424	; 0x4424 <xTaskRemoveFromEventList>
    2b9c:	88 23       	and	r24, r24
    2b9e:	11 f0       	breq	.+4      	; 0x2ba4 <prvUnlockQueue+0x3c>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    2ba0:	0e 94 02 25 	call	0x4a04	; 0x4a04 <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    2ba4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ba6:	81 50       	subi	r24, 0x01	; 1
    2ba8:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    2baa:	8a 81       	ldd	r24, Y+2	; 0x02
    2bac:	18 16       	cp	r1, r24
    2bae:	64 f3       	brlt	.-40     	; 0x2b88 <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    2bb0:	eb 81       	ldd	r30, Y+3	; 0x03
    2bb2:	fc 81       	ldd	r31, Y+4	; 0x04
    2bb4:	8f ef       	ldi	r24, 0xFF	; 255
    2bb6:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    2bb8:	0f 90       	pop	r0
    2bba:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    2bbc:	0f b6       	in	r0, 0x3f	; 63
    2bbe:	f8 94       	cli
    2bc0:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    2bc2:	eb 81       	ldd	r30, Y+3	; 0x03
    2bc4:	fc 81       	ldd	r31, Y+4	; 0x04
    2bc6:	85 8d       	ldd	r24, Z+29	; 0x1d
    2bc8:	89 83       	std	Y+1, r24	; 0x01
    2bca:	11 c0       	rjmp	.+34     	; 0x2bee <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2bcc:	eb 81       	ldd	r30, Y+3	; 0x03
    2bce:	fc 81       	ldd	r31, Y+4	; 0x04
    2bd0:	80 85       	ldd	r24, Z+8	; 0x08
    2bd2:	88 23       	and	r24, r24
    2bd4:	79 f0       	breq	.+30     	; 0x2bf4 <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2bd6:	8b 81       	ldd	r24, Y+3	; 0x03
    2bd8:	9c 81       	ldd	r25, Y+4	; 0x04
    2bda:	08 96       	adiw	r24, 0x08	; 8
    2bdc:	0e 94 12 22 	call	0x4424	; 0x4424 <xTaskRemoveFromEventList>
    2be0:	88 23       	and	r24, r24
    2be2:	11 f0       	breq	.+4      	; 0x2be8 <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    2be4:	0e 94 02 25 	call	0x4a04	; 0x4a04 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    2be8:	89 81       	ldd	r24, Y+1	; 0x01
    2bea:	81 50       	subi	r24, 0x01	; 1
    2bec:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    2bee:	89 81       	ldd	r24, Y+1	; 0x01
    2bf0:	18 16       	cp	r1, r24
    2bf2:	64 f3       	brlt	.-40     	; 0x2bcc <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    2bf4:	eb 81       	ldd	r30, Y+3	; 0x03
    2bf6:	fc 81       	ldd	r31, Y+4	; 0x04
    2bf8:	8f ef       	ldi	r24, 0xFF	; 255
    2bfa:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    2bfc:	0f 90       	pop	r0
    2bfe:	0f be       	out	0x3f, r0	; 63
}
    2c00:	0f 90       	pop	r0
    2c02:	0f 90       	pop	r0
    2c04:	0f 90       	pop	r0
    2c06:	0f 90       	pop	r0
    2c08:	cf 91       	pop	r28
    2c0a:	df 91       	pop	r29
    2c0c:	08 95       	ret

00002c0e <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    2c0e:	df 93       	push	r29
    2c10:	cf 93       	push	r28
    2c12:	00 d0       	rcall	.+0      	; 0x2c14 <prvIsQueueEmpty+0x6>
    2c14:	0f 92       	push	r0
    2c16:	cd b7       	in	r28, 0x3d	; 61
    2c18:	de b7       	in	r29, 0x3e	; 62
    2c1a:	9b 83       	std	Y+3, r25	; 0x03
    2c1c:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2c1e:	0f b6       	in	r0, 0x3f	; 63
    2c20:	f8 94       	cli
    2c22:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2c24:	ea 81       	ldd	r30, Y+2	; 0x02
    2c26:	fb 81       	ldd	r31, Y+3	; 0x03
    2c28:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c2a:	88 23       	and	r24, r24
    2c2c:	19 f4       	brne	.+6      	; 0x2c34 <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    2c2e:	81 e0       	ldi	r24, 0x01	; 1
    2c30:	89 83       	std	Y+1, r24	; 0x01
    2c32:	01 c0       	rjmp	.+2      	; 0x2c36 <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    2c34:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    2c36:	0f 90       	pop	r0
    2c38:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    2c3a:	89 81       	ldd	r24, Y+1	; 0x01
}
    2c3c:	0f 90       	pop	r0
    2c3e:	0f 90       	pop	r0
    2c40:	0f 90       	pop	r0
    2c42:	cf 91       	pop	r28
    2c44:	df 91       	pop	r29
    2c46:	08 95       	ret

00002c48 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2c48:	df 93       	push	r29
    2c4a:	cf 93       	push	r28
    2c4c:	00 d0       	rcall	.+0      	; 0x2c4e <xQueueIsQueueEmptyFromISR+0x6>
    2c4e:	00 d0       	rcall	.+0      	; 0x2c50 <xQueueIsQueueEmptyFromISR+0x8>
    2c50:	0f 92       	push	r0
    2c52:	cd b7       	in	r28, 0x3d	; 61
    2c54:	de b7       	in	r29, 0x3e	; 62
    2c56:	9d 83       	std	Y+5, r25	; 0x05
    2c58:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    2c5a:	8c 81       	ldd	r24, Y+4	; 0x04
    2c5c:	9d 81       	ldd	r25, Y+5	; 0x05
    2c5e:	9a 83       	std	Y+2, r25	; 0x02
    2c60:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2c62:	e9 81       	ldd	r30, Y+1	; 0x01
    2c64:	fa 81       	ldd	r31, Y+2	; 0x02
    2c66:	82 8d       	ldd	r24, Z+26	; 0x1a
    2c68:	88 23       	and	r24, r24
    2c6a:	19 f4       	brne	.+6      	; 0x2c72 <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    2c6c:	81 e0       	ldi	r24, 0x01	; 1
    2c6e:	8b 83       	std	Y+3, r24	; 0x03
    2c70:	01 c0       	rjmp	.+2      	; 0x2c74 <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    2c72:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    2c74:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2c76:	0f 90       	pop	r0
    2c78:	0f 90       	pop	r0
    2c7a:	0f 90       	pop	r0
    2c7c:	0f 90       	pop	r0
    2c7e:	0f 90       	pop	r0
    2c80:	cf 91       	pop	r28
    2c82:	df 91       	pop	r29
    2c84:	08 95       	ret

00002c86 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    2c86:	df 93       	push	r29
    2c88:	cf 93       	push	r28
    2c8a:	00 d0       	rcall	.+0      	; 0x2c8c <prvIsQueueFull+0x6>
    2c8c:	0f 92       	push	r0
    2c8e:	cd b7       	in	r28, 0x3d	; 61
    2c90:	de b7       	in	r29, 0x3e	; 62
    2c92:	9b 83       	std	Y+3, r25	; 0x03
    2c94:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2c96:	0f b6       	in	r0, 0x3f	; 63
    2c98:	f8 94       	cli
    2c9a:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2c9c:	ea 81       	ldd	r30, Y+2	; 0x02
    2c9e:	fb 81       	ldd	r31, Y+3	; 0x03
    2ca0:	92 8d       	ldd	r25, Z+26	; 0x1a
    2ca2:	ea 81       	ldd	r30, Y+2	; 0x02
    2ca4:	fb 81       	ldd	r31, Y+3	; 0x03
    2ca6:	83 8d       	ldd	r24, Z+27	; 0x1b
    2ca8:	98 17       	cp	r25, r24
    2caa:	19 f4       	brne	.+6      	; 0x2cb2 <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    2cac:	81 e0       	ldi	r24, 0x01	; 1
    2cae:	89 83       	std	Y+1, r24	; 0x01
    2cb0:	01 c0       	rjmp	.+2      	; 0x2cb4 <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    2cb2:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    2cb4:	0f 90       	pop	r0
    2cb6:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    2cb8:	89 81       	ldd	r24, Y+1	; 0x01
}
    2cba:	0f 90       	pop	r0
    2cbc:	0f 90       	pop	r0
    2cbe:	0f 90       	pop	r0
    2cc0:	cf 91       	pop	r28
    2cc2:	df 91       	pop	r29
    2cc4:	08 95       	ret

00002cc6 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2cc6:	df 93       	push	r29
    2cc8:	cf 93       	push	r28
    2cca:	00 d0       	rcall	.+0      	; 0x2ccc <xQueueIsQueueFullFromISR+0x6>
    2ccc:	00 d0       	rcall	.+0      	; 0x2cce <xQueueIsQueueFullFromISR+0x8>
    2cce:	0f 92       	push	r0
    2cd0:	cd b7       	in	r28, 0x3d	; 61
    2cd2:	de b7       	in	r29, 0x3e	; 62
    2cd4:	9d 83       	std	Y+5, r25	; 0x05
    2cd6:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    2cd8:	8c 81       	ldd	r24, Y+4	; 0x04
    2cda:	9d 81       	ldd	r25, Y+5	; 0x05
    2cdc:	9a 83       	std	Y+2, r25	; 0x02
    2cde:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2ce0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ce2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ce4:	92 8d       	ldd	r25, Z+26	; 0x1a
    2ce6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ce8:	fa 81       	ldd	r31, Y+2	; 0x02
    2cea:	83 8d       	ldd	r24, Z+27	; 0x1b
    2cec:	98 17       	cp	r25, r24
    2cee:	19 f4       	brne	.+6      	; 0x2cf6 <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    2cf0:	81 e0       	ldi	r24, 0x01	; 1
    2cf2:	8b 83       	std	Y+3, r24	; 0x03
    2cf4:	01 c0       	rjmp	.+2      	; 0x2cf8 <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    2cf6:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    2cf8:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2cfa:	0f 90       	pop	r0
    2cfc:	0f 90       	pop	r0
    2cfe:	0f 90       	pop	r0
    2d00:	0f 90       	pop	r0
    2d02:	0f 90       	pop	r0
    2d04:	cf 91       	pop	r28
    2d06:	df 91       	pop	r29
    2d08:	08 95       	ret

00002d0a <xQueueCRSend>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSend( QueueHandle_t xQueue,
                             const void * pvItemToQueue,
                             TickType_t xTicksToWait )
    {
    2d0a:	df 93       	push	r29
    2d0c:	cf 93       	push	r28
    2d0e:	cd b7       	in	r28, 0x3d	; 61
    2d10:	de b7       	in	r29, 0x3e	; 62
    2d12:	2a 97       	sbiw	r28, 0x0a	; 10
    2d14:	0f b6       	in	r0, 0x3f	; 63
    2d16:	f8 94       	cli
    2d18:	de bf       	out	0x3e, r29	; 62
    2d1a:	0f be       	out	0x3f, r0	; 63
    2d1c:	cd bf       	out	0x3d, r28	; 61
    2d1e:	9d 83       	std	Y+5, r25	; 0x05
    2d20:	8c 83       	std	Y+4, r24	; 0x04
    2d22:	7f 83       	std	Y+7, r23	; 0x07
    2d24:	6e 83       	std	Y+6, r22	; 0x06
    2d26:	59 87       	std	Y+9, r21	; 0x09
    2d28:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    2d2a:	8c 81       	ldd	r24, Y+4	; 0x04
    2d2c:	9d 81       	ldd	r25, Y+5	; 0x05
    2d2e:	9a 83       	std	Y+2, r25	; 0x02
    2d30:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    2d32:	f8 94       	cli
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2d34:	89 81       	ldd	r24, Y+1	; 0x01
    2d36:	9a 81       	ldd	r25, Y+2	; 0x02
    2d38:	0e 94 43 16 	call	0x2c86	; 0x2c86 <prvIsQueueFull>
    2d3c:	88 23       	and	r24, r24
    2d3e:	a9 f0       	breq	.+42     	; 0x2d6a <xQueueCRSend+0x60>
            {
                /* The queue is full - do we want to block or just leave without
                 * posting? */
                if( xTicksToWait > ( TickType_t ) 0 )
    2d40:	88 85       	ldd	r24, Y+8	; 0x08
    2d42:	99 85       	ldd	r25, Y+9	; 0x09
    2d44:	00 97       	sbiw	r24, 0x00	; 0
    2d46:	71 f0       	breq	.+28     	; 0x2d64 <xQueueCRSend+0x5a>
                {
                    /* As this is called from a coroutine we cannot block directly, but
                     * return indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    2d48:	89 81       	ldd	r24, Y+1	; 0x01
    2d4a:	9a 81       	ldd	r25, Y+2	; 0x02
    2d4c:	9c 01       	movw	r18, r24
    2d4e:	28 5f       	subi	r18, 0xF8	; 248
    2d50:	3f 4f       	sbci	r19, 0xFF	; 255
    2d52:	88 85       	ldd	r24, Y+8	; 0x08
    2d54:	99 85       	ldd	r25, Y+9	; 0x09
    2d56:	b9 01       	movw	r22, r18
    2d58:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    2d5c:	78 94       	sei
                    return errQUEUE_BLOCKED;
    2d5e:	8c ef       	ldi	r24, 0xFC	; 252
    2d60:	8a 87       	std	Y+10, r24	; 0x0a
    2d62:	2a c0       	rjmp	.+84     	; 0x2db8 <xQueueCRSend+0xae>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    2d64:	78 94       	sei
                    return errQUEUE_FULL;
    2d66:	1a 86       	std	Y+10, r1	; 0x0a
    2d68:	27 c0       	rjmp	.+78     	; 0x2db8 <xQueueCRSend+0xae>
                }
            }
        }
        portENABLE_INTERRUPTS();
    2d6a:	78 94       	sei

        portDISABLE_INTERRUPTS();
    2d6c:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2d6e:	e9 81       	ldd	r30, Y+1	; 0x01
    2d70:	fa 81       	ldd	r31, Y+2	; 0x02
    2d72:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d74:	e9 81       	ldd	r30, Y+1	; 0x01
    2d76:	fa 81       	ldd	r31, Y+2	; 0x02
    2d78:	83 8d       	ldd	r24, Z+27	; 0x1b
    2d7a:	98 17       	cp	r25, r24
    2d7c:	c8 f4       	brcc	.+50     	; 0x2db0 <xQueueCRSend+0xa6>
            {
                /* There is room in the queue, copy the data into the queue. */
                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    2d7e:	89 81       	ldd	r24, Y+1	; 0x01
    2d80:	9a 81       	ldd	r25, Y+2	; 0x02
    2d82:	2e 81       	ldd	r18, Y+6	; 0x06
    2d84:	3f 81       	ldd	r19, Y+7	; 0x07
    2d86:	b9 01       	movw	r22, r18
    2d88:	40 e0       	ldi	r20, 0x00	; 0
    2d8a:	0e 94 c7 14 	call	0x298e	; 0x298e <prvCopyDataToQueue>
                xReturn = pdPASS;
    2d8e:	81 e0       	ldi	r24, 0x01	; 1
    2d90:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for data to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2d92:	e9 81       	ldd	r30, Y+1	; 0x01
    2d94:	fa 81       	ldd	r31, Y+2	; 0x02
    2d96:	81 89       	ldd	r24, Z+17	; 0x11
    2d98:	88 23       	and	r24, r24
    2d9a:	59 f0       	breq	.+22     	; 0x2db2 <xQueueCRSend+0xa8>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2d9c:	89 81       	ldd	r24, Y+1	; 0x01
    2d9e:	9a 81       	ldd	r25, Y+2	; 0x02
    2da0:	41 96       	adiw	r24, 0x11	; 17
    2da2:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <xCoRoutineRemoveFromEventList>
    2da6:	88 23       	and	r24, r24
    2da8:	21 f0       	breq	.+8      	; 0x2db2 <xQueueCRSend+0xa8>
                    {
                        /* The co-routine waiting has a higher priority so record
                         * that a yield might be appropriate. */
                        xReturn = errQUEUE_YIELD;
    2daa:	8b ef       	ldi	r24, 0xFB	; 251
    2dac:	8b 83       	std	Y+3, r24	; 0x03
    2dae:	01 c0       	rjmp	.+2      	; 0x2db2 <xQueueCRSend+0xa8>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = errQUEUE_FULL;
    2db0:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    2db2:	78 94       	sei

        return xReturn;
    2db4:	8b 81       	ldd	r24, Y+3	; 0x03
    2db6:	8a 87       	std	Y+10, r24	; 0x0a
    2db8:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    2dba:	2a 96       	adiw	r28, 0x0a	; 10
    2dbc:	0f b6       	in	r0, 0x3f	; 63
    2dbe:	f8 94       	cli
    2dc0:	de bf       	out	0x3e, r29	; 62
    2dc2:	0f be       	out	0x3f, r0	; 63
    2dc4:	cd bf       	out	0x3d, r28	; 61
    2dc6:	cf 91       	pop	r28
    2dc8:	df 91       	pop	r29
    2dca:	08 95       	ret

00002dcc <xQueueCRReceive>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
                                void * pvBuffer,
                                TickType_t xTicksToWait )
    {
    2dcc:	df 93       	push	r29
    2dce:	cf 93       	push	r28
    2dd0:	cd b7       	in	r28, 0x3d	; 61
    2dd2:	de b7       	in	r29, 0x3e	; 62
    2dd4:	2a 97       	sbiw	r28, 0x0a	; 10
    2dd6:	0f b6       	in	r0, 0x3f	; 63
    2dd8:	f8 94       	cli
    2dda:	de bf       	out	0x3e, r29	; 62
    2ddc:	0f be       	out	0x3f, r0	; 63
    2dde:	cd bf       	out	0x3d, r28	; 61
    2de0:	9d 83       	std	Y+5, r25	; 0x05
    2de2:	8c 83       	std	Y+4, r24	; 0x04
    2de4:	7f 83       	std	Y+7, r23	; 0x07
    2de6:	6e 83       	std	Y+6, r22	; 0x06
    2de8:	59 87       	std	Y+9, r21	; 0x09
    2dea:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    2dec:	8c 81       	ldd	r24, Y+4	; 0x04
    2dee:	9d 81       	ldd	r25, Y+5	; 0x05
    2df0:	9a 83       	std	Y+2, r25	; 0x02
    2df2:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already empty we may have to block.  A critical section
         * is required to prevent an interrupt adding something to the queue
         * between the check to see if the queue is empty and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    2df4:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2df6:	e9 81       	ldd	r30, Y+1	; 0x01
    2df8:	fa 81       	ldd	r31, Y+2	; 0x02
    2dfa:	82 8d       	ldd	r24, Z+26	; 0x1a
    2dfc:	88 23       	and	r24, r24
    2dfe:	a9 f4       	brne	.+42     	; 0x2e2a <xQueueCRReceive+0x5e>
            {
                /* There are no messages in the queue, do we want to block or just
                 * leave with nothing? */
                if( xTicksToWait > ( TickType_t ) 0 )
    2e00:	88 85       	ldd	r24, Y+8	; 0x08
    2e02:	99 85       	ldd	r25, Y+9	; 0x09
    2e04:	00 97       	sbiw	r24, 0x00	; 0
    2e06:	71 f0       	breq	.+28     	; 0x2e24 <xQueueCRReceive+0x58>
                {
                    /* As this is a co-routine we cannot block directly, but return
                     * indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    2e08:	89 81       	ldd	r24, Y+1	; 0x01
    2e0a:	9a 81       	ldd	r25, Y+2	; 0x02
    2e0c:	9c 01       	movw	r18, r24
    2e0e:	2f 5e       	subi	r18, 0xEF	; 239
    2e10:	3f 4f       	sbci	r19, 0xFF	; 255
    2e12:	88 85       	ldd	r24, Y+8	; 0x08
    2e14:	99 85       	ldd	r25, Y+9	; 0x09
    2e16:	b9 01       	movw	r22, r18
    2e18:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    2e1c:	78 94       	sei
                    return errQUEUE_BLOCKED;
    2e1e:	8c ef       	ldi	r24, 0xFC	; 252
    2e20:	8a 87       	std	Y+10, r24	; 0x0a
    2e22:	58 c0       	rjmp	.+176    	; 0x2ed4 <xQueueCRReceive+0x108>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    2e24:	78 94       	sei
                    return errQUEUE_FULL;
    2e26:	1a 86       	std	Y+10, r1	; 0x0a
    2e28:	55 c0       	rjmp	.+170    	; 0x2ed4 <xQueueCRReceive+0x108>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portENABLE_INTERRUPTS();
    2e2a:	78 94       	sei

        portDISABLE_INTERRUPTS();
    2e2c:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2e2e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e30:	fa 81       	ldd	r31, Y+2	; 0x02
    2e32:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e34:	88 23       	and	r24, r24
    2e36:	09 f4       	brne	.+2      	; 0x2e3a <xQueueCRReceive+0x6e>
    2e38:	49 c0       	rjmp	.+146    	; 0x2ecc <xQueueCRReceive+0x100>
            {
                /* Data is available from the queue. */
                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    2e3a:	e9 81       	ldd	r30, Y+1	; 0x01
    2e3c:	fa 81       	ldd	r31, Y+2	; 0x02
    2e3e:	26 81       	ldd	r18, Z+6	; 0x06
    2e40:	37 81       	ldd	r19, Z+7	; 0x07
    2e42:	e9 81       	ldd	r30, Y+1	; 0x01
    2e44:	fa 81       	ldd	r31, Y+2	; 0x02
    2e46:	84 8d       	ldd	r24, Z+28	; 0x1c
    2e48:	88 2f       	mov	r24, r24
    2e4a:	90 e0       	ldi	r25, 0x00	; 0
    2e4c:	82 0f       	add	r24, r18
    2e4e:	93 1f       	adc	r25, r19
    2e50:	e9 81       	ldd	r30, Y+1	; 0x01
    2e52:	fa 81       	ldd	r31, Y+2	; 0x02
    2e54:	97 83       	std	Z+7, r25	; 0x07
    2e56:	86 83       	std	Z+6, r24	; 0x06

                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    2e58:	e9 81       	ldd	r30, Y+1	; 0x01
    2e5a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e5c:	26 81       	ldd	r18, Z+6	; 0x06
    2e5e:	37 81       	ldd	r19, Z+7	; 0x07
    2e60:	e9 81       	ldd	r30, Y+1	; 0x01
    2e62:	fa 81       	ldd	r31, Y+2	; 0x02
    2e64:	84 81       	ldd	r24, Z+4	; 0x04
    2e66:	95 81       	ldd	r25, Z+5	; 0x05
    2e68:	28 17       	cp	r18, r24
    2e6a:	39 07       	cpc	r19, r25
    2e6c:	40 f0       	brcs	.+16     	; 0x2e7e <xQueueCRReceive+0xb2>
                {
                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2e6e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e70:	fa 81       	ldd	r31, Y+2	; 0x02
    2e72:	80 81       	ld	r24, Z
    2e74:	91 81       	ldd	r25, Z+1	; 0x01
    2e76:	e9 81       	ldd	r30, Y+1	; 0x01
    2e78:	fa 81       	ldd	r31, Y+2	; 0x02
    2e7a:	97 83       	std	Z+7, r25	; 0x07
    2e7c:	86 83       	std	Z+6, r24	; 0x06
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --( pxQueue->uxMessagesWaiting );
    2e7e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e80:	fa 81       	ldd	r31, Y+2	; 0x02
    2e82:	82 8d       	ldd	r24, Z+26	; 0x1a
    2e84:	81 50       	subi	r24, 0x01	; 1
    2e86:	e9 81       	ldd	r30, Y+1	; 0x01
    2e88:	fa 81       	ldd	r31, Y+2	; 0x02
    2e8a:	82 8f       	std	Z+26, r24	; 0x1a
                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2e8c:	e9 81       	ldd	r30, Y+1	; 0x01
    2e8e:	fa 81       	ldd	r31, Y+2	; 0x02
    2e90:	46 81       	ldd	r20, Z+6	; 0x06
    2e92:	57 81       	ldd	r21, Z+7	; 0x07
    2e94:	e9 81       	ldd	r30, Y+1	; 0x01
    2e96:	fa 81       	ldd	r31, Y+2	; 0x02
    2e98:	84 8d       	ldd	r24, Z+28	; 0x1c
    2e9a:	28 2f       	mov	r18, r24
    2e9c:	30 e0       	ldi	r19, 0x00	; 0
    2e9e:	8e 81       	ldd	r24, Y+6	; 0x06
    2ea0:	9f 81       	ldd	r25, Y+7	; 0x07
    2ea2:	ba 01       	movw	r22, r20
    2ea4:	a9 01       	movw	r20, r18
    2ea6:	0e 94 a8 39 	call	0x7350	; 0x7350 <memcpy>

                xReturn = pdPASS;
    2eaa:	81 e0       	ldi	r24, 0x01	; 1
    2eac:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for space to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2eae:	e9 81       	ldd	r30, Y+1	; 0x01
    2eb0:	fa 81       	ldd	r31, Y+2	; 0x02
    2eb2:	80 85       	ldd	r24, Z+8	; 0x08
    2eb4:	88 23       	and	r24, r24
    2eb6:	59 f0       	breq	.+22     	; 0x2ece <xQueueCRReceive+0x102>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2eb8:	89 81       	ldd	r24, Y+1	; 0x01
    2eba:	9a 81       	ldd	r25, Y+2	; 0x02
    2ebc:	08 96       	adiw	r24, 0x08	; 8
    2ebe:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <xCoRoutineRemoveFromEventList>
    2ec2:	88 23       	and	r24, r24
    2ec4:	21 f0       	breq	.+8      	; 0x2ece <xQueueCRReceive+0x102>
                    {
                        xReturn = errQUEUE_YIELD;
    2ec6:	8b ef       	ldi	r24, 0xFB	; 251
    2ec8:	8b 83       	std	Y+3, r24	; 0x03
    2eca:	01 c0       	rjmp	.+2      	; 0x2ece <xQueueCRReceive+0x102>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = pdFAIL;
    2ecc:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    2ece:	78 94       	sei

        return xReturn;
    2ed0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ed2:	8a 87       	std	Y+10, r24	; 0x0a
    2ed4:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    2ed6:	2a 96       	adiw	r28, 0x0a	; 10
    2ed8:	0f b6       	in	r0, 0x3f	; 63
    2eda:	f8 94       	cli
    2edc:	de bf       	out	0x3e, r29	; 62
    2ede:	0f be       	out	0x3f, r0	; 63
    2ee0:	cd bf       	out	0x3d, r28	; 61
    2ee2:	cf 91       	pop	r28
    2ee4:	df 91       	pop	r29
    2ee6:	08 95       	ret

00002ee8 <xQueueCRSendFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
                                    const void * pvItemToQueue,
                                    BaseType_t xCoRoutinePreviouslyWoken )
    {
    2ee8:	df 93       	push	r29
    2eea:	cf 93       	push	r28
    2eec:	cd b7       	in	r28, 0x3d	; 61
    2eee:	de b7       	in	r29, 0x3e	; 62
    2ef0:	28 97       	sbiw	r28, 0x08	; 8
    2ef2:	0f b6       	in	r0, 0x3f	; 63
    2ef4:	f8 94       	cli
    2ef6:	de bf       	out	0x3e, r29	; 62
    2ef8:	0f be       	out	0x3f, r0	; 63
    2efa:	cd bf       	out	0x3d, r28	; 61
    2efc:	9c 83       	std	Y+4, r25	; 0x04
    2efe:	8b 83       	std	Y+3, r24	; 0x03
    2f00:	7e 83       	std	Y+6, r23	; 0x06
    2f02:	6d 83       	std	Y+5, r22	; 0x05
    2f04:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    2f06:	8b 81       	ldd	r24, Y+3	; 0x03
    2f08:	9c 81       	ldd	r25, Y+4	; 0x04
    2f0a:	9a 83       	std	Y+2, r25	; 0x02
    2f0c:	89 83       	std	Y+1, r24	; 0x01

        /* Cannot block within an ISR so if there is no space on the queue then
         * exit without doing anything. */
        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2f0e:	e9 81       	ldd	r30, Y+1	; 0x01
    2f10:	fa 81       	ldd	r31, Y+2	; 0x02
    2f12:	92 8d       	ldd	r25, Z+26	; 0x1a
    2f14:	e9 81       	ldd	r30, Y+1	; 0x01
    2f16:	fa 81       	ldd	r31, Y+2	; 0x02
    2f18:	83 8d       	ldd	r24, Z+27	; 0x1b
    2f1a:	98 17       	cp	r25, r24
    2f1c:	d0 f4       	brcc	.+52     	; 0x2f52 <xQueueCRSendFromISR+0x6a>
        {
            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    2f1e:	89 81       	ldd	r24, Y+1	; 0x01
    2f20:	9a 81       	ldd	r25, Y+2	; 0x02
    2f22:	2d 81       	ldd	r18, Y+5	; 0x05
    2f24:	3e 81       	ldd	r19, Y+6	; 0x06
    2f26:	b9 01       	movw	r22, r18
    2f28:	40 e0       	ldi	r20, 0x00	; 0
    2f2a:	0e 94 c7 14 	call	0x298e	; 0x298e <prvCopyDataToQueue>

            /* We only want to wake one co-routine per ISR, so check that a
             * co-routine has not already been woken. */
            if( xCoRoutinePreviouslyWoken == pdFALSE )
    2f2e:	8f 81       	ldd	r24, Y+7	; 0x07
    2f30:	88 23       	and	r24, r24
    2f32:	79 f4       	brne	.+30     	; 0x2f52 <xQueueCRSendFromISR+0x6a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2f34:	e9 81       	ldd	r30, Y+1	; 0x01
    2f36:	fa 81       	ldd	r31, Y+2	; 0x02
    2f38:	81 89       	ldd	r24, Z+17	; 0x11
    2f3a:	88 23       	and	r24, r24
    2f3c:	51 f0       	breq	.+20     	; 0x2f52 <xQueueCRSendFromISR+0x6a>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2f3e:	89 81       	ldd	r24, Y+1	; 0x01
    2f40:	9a 81       	ldd	r25, Y+2	; 0x02
    2f42:	41 96       	adiw	r24, 0x11	; 17
    2f44:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <xCoRoutineRemoveFromEventList>
    2f48:	88 23       	and	r24, r24
    2f4a:	19 f0       	breq	.+6      	; 0x2f52 <xQueueCRSendFromISR+0x6a>
                    {
                        return pdTRUE;
    2f4c:	81 e0       	ldi	r24, 0x01	; 1
    2f4e:	88 87       	std	Y+8, r24	; 0x08
    2f50:	02 c0       	rjmp	.+4      	; 0x2f56 <xQueueCRSendFromISR+0x6e>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xCoRoutinePreviouslyWoken;
    2f52:	8f 81       	ldd	r24, Y+7	; 0x07
    2f54:	88 87       	std	Y+8, r24	; 0x08
    2f56:	88 85       	ldd	r24, Y+8	; 0x08
    }
    2f58:	28 96       	adiw	r28, 0x08	; 8
    2f5a:	0f b6       	in	r0, 0x3f	; 63
    2f5c:	f8 94       	cli
    2f5e:	de bf       	out	0x3e, r29	; 62
    2f60:	0f be       	out	0x3f, r0	; 63
    2f62:	cd bf       	out	0x3d, r28	; 61
    2f64:	cf 91       	pop	r28
    2f66:	df 91       	pop	r29
    2f68:	08 95       	ret

00002f6a <xQueueCRReceiveFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
                                       void * pvBuffer,
                                       BaseType_t * pxCoRoutineWoken )
    {
    2f6a:	df 93       	push	r29
    2f6c:	cf 93       	push	r28
    2f6e:	cd b7       	in	r28, 0x3d	; 61
    2f70:	de b7       	in	r29, 0x3e	; 62
    2f72:	29 97       	sbiw	r28, 0x09	; 9
    2f74:	0f b6       	in	r0, 0x3f	; 63
    2f76:	f8 94       	cli
    2f78:	de bf       	out	0x3e, r29	; 62
    2f7a:	0f be       	out	0x3f, r0	; 63
    2f7c:	cd bf       	out	0x3d, r28	; 61
    2f7e:	9d 83       	std	Y+5, r25	; 0x05
    2f80:	8c 83       	std	Y+4, r24	; 0x04
    2f82:	7f 83       	std	Y+7, r23	; 0x07
    2f84:	6e 83       	std	Y+6, r22	; 0x06
    2f86:	59 87       	std	Y+9, r21	; 0x09
    2f88:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    2f8a:	8c 81       	ldd	r24, Y+4	; 0x04
    2f8c:	9d 81       	ldd	r25, Y+5	; 0x05
    2f8e:	9a 83       	std	Y+2, r25	; 0x02
    2f90:	89 83       	std	Y+1, r24	; 0x01

        /* We cannot block from an ISR, so check there is data available. If
         * not then just leave without doing anything. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2f92:	e9 81       	ldd	r30, Y+1	; 0x01
    2f94:	fa 81       	ldd	r31, Y+2	; 0x02
    2f96:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f98:	88 23       	and	r24, r24
    2f9a:	09 f4       	brne	.+2      	; 0x2f9e <xQueueCRReceiveFromISR+0x34>
    2f9c:	50 c0       	rjmp	.+160    	; 0x303e <xQueueCRReceiveFromISR+0xd4>
        {
            /* Copy the data from the queue. */
            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    2f9e:	e9 81       	ldd	r30, Y+1	; 0x01
    2fa0:	fa 81       	ldd	r31, Y+2	; 0x02
    2fa2:	26 81       	ldd	r18, Z+6	; 0x06
    2fa4:	37 81       	ldd	r19, Z+7	; 0x07
    2fa6:	e9 81       	ldd	r30, Y+1	; 0x01
    2fa8:	fa 81       	ldd	r31, Y+2	; 0x02
    2faa:	84 8d       	ldd	r24, Z+28	; 0x1c
    2fac:	88 2f       	mov	r24, r24
    2fae:	90 e0       	ldi	r25, 0x00	; 0
    2fb0:	82 0f       	add	r24, r18
    2fb2:	93 1f       	adc	r25, r19
    2fb4:	e9 81       	ldd	r30, Y+1	; 0x01
    2fb6:	fa 81       	ldd	r31, Y+2	; 0x02
    2fb8:	97 83       	std	Z+7, r25	; 0x07
    2fba:	86 83       	std	Z+6, r24	; 0x06

            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    2fbc:	e9 81       	ldd	r30, Y+1	; 0x01
    2fbe:	fa 81       	ldd	r31, Y+2	; 0x02
    2fc0:	26 81       	ldd	r18, Z+6	; 0x06
    2fc2:	37 81       	ldd	r19, Z+7	; 0x07
    2fc4:	e9 81       	ldd	r30, Y+1	; 0x01
    2fc6:	fa 81       	ldd	r31, Y+2	; 0x02
    2fc8:	84 81       	ldd	r24, Z+4	; 0x04
    2fca:	95 81       	ldd	r25, Z+5	; 0x05
    2fcc:	28 17       	cp	r18, r24
    2fce:	39 07       	cpc	r19, r25
    2fd0:	40 f0       	brcs	.+16     	; 0x2fe2 <xQueueCRReceiveFromISR+0x78>
            {
                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2fd2:	e9 81       	ldd	r30, Y+1	; 0x01
    2fd4:	fa 81       	ldd	r31, Y+2	; 0x02
    2fd6:	80 81       	ld	r24, Z
    2fd8:	91 81       	ldd	r25, Z+1	; 0x01
    2fda:	e9 81       	ldd	r30, Y+1	; 0x01
    2fdc:	fa 81       	ldd	r31, Y+2	; 0x02
    2fde:	97 83       	std	Z+7, r25	; 0x07
    2fe0:	86 83       	std	Z+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            --( pxQueue->uxMessagesWaiting );
    2fe2:	e9 81       	ldd	r30, Y+1	; 0x01
    2fe4:	fa 81       	ldd	r31, Y+2	; 0x02
    2fe6:	82 8d       	ldd	r24, Z+26	; 0x1a
    2fe8:	81 50       	subi	r24, 0x01	; 1
    2fea:	e9 81       	ldd	r30, Y+1	; 0x01
    2fec:	fa 81       	ldd	r31, Y+2	; 0x02
    2fee:	82 8f       	std	Z+26, r24	; 0x1a
            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2ff0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ff2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ff4:	46 81       	ldd	r20, Z+6	; 0x06
    2ff6:	57 81       	ldd	r21, Z+7	; 0x07
    2ff8:	e9 81       	ldd	r30, Y+1	; 0x01
    2ffa:	fa 81       	ldd	r31, Y+2	; 0x02
    2ffc:	84 8d       	ldd	r24, Z+28	; 0x1c
    2ffe:	28 2f       	mov	r18, r24
    3000:	30 e0       	ldi	r19, 0x00	; 0
    3002:	8e 81       	ldd	r24, Y+6	; 0x06
    3004:	9f 81       	ldd	r25, Y+7	; 0x07
    3006:	ba 01       	movw	r22, r20
    3008:	a9 01       	movw	r20, r18
    300a:	0e 94 a8 39 	call	0x7350	; 0x7350 <memcpy>

            if( ( *pxCoRoutineWoken ) == pdFALSE )
    300e:	e8 85       	ldd	r30, Y+8	; 0x08
    3010:	f9 85       	ldd	r31, Y+9	; 0x09
    3012:	80 81       	ld	r24, Z
    3014:	88 23       	and	r24, r24
    3016:	81 f4       	brne	.+32     	; 0x3038 <xQueueCRReceiveFromISR+0xce>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3018:	e9 81       	ldd	r30, Y+1	; 0x01
    301a:	fa 81       	ldd	r31, Y+2	; 0x02
    301c:	80 85       	ldd	r24, Z+8	; 0x08
    301e:	88 23       	and	r24, r24
    3020:	59 f0       	breq	.+22     	; 0x3038 <xQueueCRReceiveFromISR+0xce>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3022:	89 81       	ldd	r24, Y+1	; 0x01
    3024:	9a 81       	ldd	r25, Y+2	; 0x02
    3026:	08 96       	adiw	r24, 0x08	; 8
    3028:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <xCoRoutineRemoveFromEventList>
    302c:	88 23       	and	r24, r24
    302e:	21 f0       	breq	.+8      	; 0x3038 <xQueueCRReceiveFromISR+0xce>
                    {
                        *pxCoRoutineWoken = pdTRUE;
    3030:	e8 85       	ldd	r30, Y+8	; 0x08
    3032:	f9 85       	ldd	r31, Y+9	; 0x09
    3034:	81 e0       	ldi	r24, 0x01	; 1
    3036:	80 83       	st	Z, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
    3038:	81 e0       	ldi	r24, 0x01	; 1
    303a:	8b 83       	std	Y+3, r24	; 0x03
    303c:	01 c0       	rjmp	.+2      	; 0x3040 <xQueueCRReceiveFromISR+0xd6>
        }
        else
        {
            xReturn = pdFAIL;
    303e:	1b 82       	std	Y+3, r1	; 0x03
        }

        return xReturn;
    3040:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    3042:	29 96       	adiw	r28, 0x09	; 9
    3044:	0f b6       	in	r0, 0x3f	; 63
    3046:	f8 94       	cli
    3048:	de bf       	out	0x3e, r29	; 62
    304a:	0f be       	out	0x3f, r0	; 63
    304c:	cd bf       	out	0x3d, r28	; 61
    304e:	cf 91       	pop	r28
    3050:	df 91       	pop	r29
    3052:	08 95       	ret

00003054 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
    3054:	df 93       	push	r29
    3056:	cf 93       	push	r28
    3058:	cd b7       	in	r28, 0x3d	; 61
    305a:	de b7       	in	r29, 0x3e	; 62
    305c:	27 97       	sbiw	r28, 0x07	; 7
    305e:	0f b6       	in	r0, 0x3f	; 63
    3060:	f8 94       	cli
    3062:	de bf       	out	0x3e, r29	; 62
    3064:	0f be       	out	0x3f, r0	; 63
    3066:	cd bf       	out	0x3d, r28	; 61
    3068:	9c 83       	std	Y+4, r25	; 0x04
    306a:	8b 83       	std	Y+3, r24	; 0x03
    306c:	7e 83       	std	Y+6, r23	; 0x06
    306e:	6d 83       	std	Y+5, r22	; 0x05
    3070:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    3072:	8b 81       	ldd	r24, Y+3	; 0x03
    3074:	9c 81       	ldd	r25, Y+4	; 0x04
    3076:	9a 83       	std	Y+2, r25	; 0x02
    3078:	89 83       	std	Y+1, r24	; 0x01
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    307a:	0f b6       	in	r0, 0x3f	; 63
    307c:	f8 94       	cli
    307e:	0f 92       	push	r0
    3080:	e9 81       	ldd	r30, Y+1	; 0x01
    3082:	fa 81       	ldd	r31, Y+2	; 0x02
    3084:	85 8d       	ldd	r24, Z+29	; 0x1d
    3086:	8f 3f       	cpi	r24, 0xFF	; 255
    3088:	19 f4       	brne	.+6      	; 0x3090 <vQueueWaitForMessageRestricted+0x3c>
    308a:	e9 81       	ldd	r30, Y+1	; 0x01
    308c:	fa 81       	ldd	r31, Y+2	; 0x02
    308e:	15 8e       	std	Z+29, r1	; 0x1d
    3090:	e9 81       	ldd	r30, Y+1	; 0x01
    3092:	fa 81       	ldd	r31, Y+2	; 0x02
    3094:	86 8d       	ldd	r24, Z+30	; 0x1e
    3096:	8f 3f       	cpi	r24, 0xFF	; 255
    3098:	19 f4       	brne	.+6      	; 0x30a0 <vQueueWaitForMessageRestricted+0x4c>
    309a:	e9 81       	ldd	r30, Y+1	; 0x01
    309c:	fa 81       	ldd	r31, Y+2	; 0x02
    309e:	16 8e       	std	Z+30, r1	; 0x1e
    30a0:	0f 90       	pop	r0
    30a2:	0f be       	out	0x3f, r0	; 63

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    30a4:	e9 81       	ldd	r30, Y+1	; 0x01
    30a6:	fa 81       	ldd	r31, Y+2	; 0x02
    30a8:	82 8d       	ldd	r24, Z+26	; 0x1a
    30aa:	88 23       	and	r24, r24
    30ac:	49 f4       	brne	.+18     	; 0x30c0 <vQueueWaitForMessageRestricted+0x6c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    30ae:	89 81       	ldd	r24, Y+1	; 0x01
    30b0:	9a 81       	ldd	r25, Y+2	; 0x02
    30b2:	41 96       	adiw	r24, 0x11	; 17
    30b4:	2d 81       	ldd	r18, Y+5	; 0x05
    30b6:	3e 81       	ldd	r19, Y+6	; 0x06
    30b8:	b9 01       	movw	r22, r18
    30ba:	4f 81       	ldd	r20, Y+7	; 0x07
    30bc:	0e 94 b0 21 	call	0x4360	; 0x4360 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
    30c0:	89 81       	ldd	r24, Y+1	; 0x01
    30c2:	9a 81       	ldd	r25, Y+2	; 0x02
    30c4:	0e 94 b4 15 	call	0x2b68	; 0x2b68 <prvUnlockQueue>
    }
    30c8:	27 96       	adiw	r28, 0x07	; 7
    30ca:	0f b6       	in	r0, 0x3f	; 63
    30cc:	f8 94       	cli
    30ce:	de bf       	out	0x3e, r29	; 62
    30d0:	0f be       	out	0x3f, r0	; 63
    30d2:	cd bf       	out	0x3d, r28	; 61
    30d4:	cf 91       	pop	r28
    30d6:	df 91       	pop	r29
    30d8:	08 95       	ret

000030da <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    30da:	8f 92       	push	r8
    30dc:	9f 92       	push	r9
    30de:	af 92       	push	r10
    30e0:	bf 92       	push	r11
    30e2:	cf 92       	push	r12
    30e4:	df 92       	push	r13
    30e6:	ef 92       	push	r14
    30e8:	ff 92       	push	r15
    30ea:	0f 93       	push	r16
    30ec:	1f 93       	push	r17
    30ee:	df 93       	push	r29
    30f0:	cf 93       	push	r28
    30f2:	cd b7       	in	r28, 0x3d	; 61
    30f4:	de b7       	in	r29, 0x3e	; 62
    30f6:	60 97       	sbiw	r28, 0x10	; 16
    30f8:	0f b6       	in	r0, 0x3f	; 63
    30fa:	f8 94       	cli
    30fc:	de bf       	out	0x3e, r29	; 62
    30fe:	0f be       	out	0x3f, r0	; 63
    3100:	cd bf       	out	0x3d, r28	; 61
    3102:	9f 83       	std	Y+7, r25	; 0x07
    3104:	8e 83       	std	Y+6, r24	; 0x06
    3106:	79 87       	std	Y+9, r23	; 0x09
    3108:	68 87       	std	Y+8, r22	; 0x08
    310a:	5b 87       	std	Y+11, r21	; 0x0b
    310c:	4a 87       	std	Y+10, r20	; 0x0a
    310e:	3d 87       	std	Y+13, r19	; 0x0d
    3110:	2c 87       	std	Y+12, r18	; 0x0c
    3112:	0e 87       	std	Y+14, r16	; 0x0e
    3114:	f8 8a       	std	Y+16, r15	; 0x10
    3116:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3118:	8a 85       	ldd	r24, Y+10	; 0x0a
    311a:	9b 85       	ldd	r25, Y+11	; 0x0b
    311c:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    3120:	9a 83       	std	Y+2, r25	; 0x02
    3122:	89 83       	std	Y+1, r24	; 0x01

                if( pxStack != NULL )
    3124:	89 81       	ldd	r24, Y+1	; 0x01
    3126:	9a 81       	ldd	r25, Y+2	; 0x02
    3128:	00 97       	sbiw	r24, 0x00	; 0
    312a:	b1 f0       	breq	.+44     	; 0x3158 <xTaskCreate+0x7e>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    312c:	8c e2       	ldi	r24, 0x2C	; 44
    312e:	90 e0       	ldi	r25, 0x00	; 0
    3130:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    3134:	9d 83       	std	Y+5, r25	; 0x05
    3136:	8c 83       	std	Y+4, r24	; 0x04

                    if( pxNewTCB != NULL )
    3138:	8c 81       	ldd	r24, Y+4	; 0x04
    313a:	9d 81       	ldd	r25, Y+5	; 0x05
    313c:	00 97       	sbiw	r24, 0x00	; 0
    313e:	39 f0       	breq	.+14     	; 0x314e <xTaskCreate+0x74>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    3140:	ec 81       	ldd	r30, Y+4	; 0x04
    3142:	fd 81       	ldd	r31, Y+5	; 0x05
    3144:	89 81       	ldd	r24, Y+1	; 0x01
    3146:	9a 81       	ldd	r25, Y+2	; 0x02
    3148:	90 8f       	std	Z+24, r25	; 0x18
    314a:	87 8b       	std	Z+23, r24	; 0x17
    314c:	07 c0       	rjmp	.+14     	; 0x315c <xTaskCreate+0x82>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFreeStack( pxStack );
    314e:	89 81       	ldd	r24, Y+1	; 0x01
    3150:	9a 81       	ldd	r25, Y+2	; 0x02
    3152:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
    3156:	02 c0       	rjmp	.+4      	; 0x315c <xTaskCreate+0x82>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
    3158:	1d 82       	std	Y+5, r1	; 0x05
    315a:	1c 82       	std	Y+4, r1	; 0x04
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    315c:	8c 81       	ldd	r24, Y+4	; 0x04
    315e:	9d 81       	ldd	r25, Y+5	; 0x05
    3160:	00 97       	sbiw	r24, 0x00	; 0
    3162:	e9 f0       	breq	.+58     	; 0x319e <xTaskCreate+0xc4>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    3164:	8a 85       	ldd	r24, Y+10	; 0x0a
    3166:	9b 85       	ldd	r25, Y+11	; 0x0b
    3168:	9c 01       	movw	r18, r24
    316a:	40 e0       	ldi	r20, 0x00	; 0
    316c:	50 e0       	ldi	r21, 0x00	; 0
    316e:	8e 81       	ldd	r24, Y+6	; 0x06
    3170:	9f 81       	ldd	r25, Y+7	; 0x07
    3172:	68 85       	ldd	r22, Y+8	; 0x08
    3174:	79 85       	ldd	r23, Y+9	; 0x09
    3176:	ec 85       	ldd	r30, Y+12	; 0x0c
    3178:	fd 85       	ldd	r31, Y+13	; 0x0d
    317a:	af 85       	ldd	r26, Y+15	; 0x0f
    317c:	b8 89       	ldd	r27, Y+16	; 0x10
    317e:	ac 80       	ldd	r10, Y+4	; 0x04
    3180:	bd 80       	ldd	r11, Y+5	; 0x05
    3182:	8f 01       	movw	r16, r30
    3184:	ee 84       	ldd	r14, Y+14	; 0x0e
    3186:	6d 01       	movw	r12, r26
    3188:	88 24       	eor	r8, r8
    318a:	99 24       	eor	r9, r9
    318c:	0e 94 e5 18 	call	0x31ca	; 0x31ca <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    3190:	8c 81       	ldd	r24, Y+4	; 0x04
    3192:	9d 81       	ldd	r25, Y+5	; 0x05
    3194:	0e 94 bb 19 	call	0x3376	; 0x3376 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    3198:	81 e0       	ldi	r24, 0x01	; 1
    319a:	8b 83       	std	Y+3, r24	; 0x03
    319c:	02 c0       	rjmp	.+4      	; 0x31a2 <xTaskCreate+0xc8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    319e:	8f ef       	ldi	r24, 0xFF	; 255
    31a0:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    31a2:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    31a4:	60 96       	adiw	r28, 0x10	; 16
    31a6:	0f b6       	in	r0, 0x3f	; 63
    31a8:	f8 94       	cli
    31aa:	de bf       	out	0x3e, r29	; 62
    31ac:	0f be       	out	0x3f, r0	; 63
    31ae:	cd bf       	out	0x3d, r28	; 61
    31b0:	cf 91       	pop	r28
    31b2:	df 91       	pop	r29
    31b4:	1f 91       	pop	r17
    31b6:	0f 91       	pop	r16
    31b8:	ff 90       	pop	r15
    31ba:	ef 90       	pop	r14
    31bc:	df 90       	pop	r13
    31be:	cf 90       	pop	r12
    31c0:	bf 90       	pop	r11
    31c2:	af 90       	pop	r10
    31c4:	9f 90       	pop	r9
    31c6:	8f 90       	pop	r8
    31c8:	08 95       	ret

000031ca <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    31ca:	8f 92       	push	r8
    31cc:	9f 92       	push	r9
    31ce:	af 92       	push	r10
    31d0:	bf 92       	push	r11
    31d2:	cf 92       	push	r12
    31d4:	df 92       	push	r13
    31d6:	ef 92       	push	r14
    31d8:	0f 93       	push	r16
    31da:	1f 93       	push	r17
    31dc:	df 93       	push	r29
    31de:	cf 93       	push	r28
    31e0:	cd b7       	in	r28, 0x3d	; 61
    31e2:	de b7       	in	r29, 0x3e	; 62
    31e4:	64 97       	sbiw	r28, 0x14	; 20
    31e6:	0f b6       	in	r0, 0x3f	; 63
    31e8:	f8 94       	cli
    31ea:	de bf       	out	0x3e, r29	; 62
    31ec:	0f be       	out	0x3f, r0	; 63
    31ee:	cd bf       	out	0x3d, r28	; 61
    31f0:	9d 83       	std	Y+5, r25	; 0x05
    31f2:	8c 83       	std	Y+4, r24	; 0x04
    31f4:	7f 83       	std	Y+7, r23	; 0x07
    31f6:	6e 83       	std	Y+6, r22	; 0x06
    31f8:	28 87       	std	Y+8, r18	; 0x08
    31fa:	39 87       	std	Y+9, r19	; 0x09
    31fc:	4a 87       	std	Y+10, r20	; 0x0a
    31fe:	5b 87       	std	Y+11, r21	; 0x0b
    3200:	1d 87       	std	Y+13, r17	; 0x0d
    3202:	0c 87       	std	Y+12, r16	; 0x0c
    3204:	ee 86       	std	Y+14, r14	; 0x0e
    3206:	d8 8a       	std	Y+16, r13	; 0x10
    3208:	cf 86       	std	Y+15, r12	; 0x0f
    320a:	ba 8a       	std	Y+18, r11	; 0x12
    320c:	a9 8a       	std	Y+17, r10	; 0x11
    320e:	9c 8a       	std	Y+20, r9	; 0x14
    3210:	8b 8a       	std	Y+19, r8	; 0x13

    /* Avoid dependency on memset() if it is not required. */
    #if ( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
        {
            /* Fill the stack with a known value to assist debugging. */
            ( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
    3212:	e9 89       	ldd	r30, Y+17	; 0x11
    3214:	fa 89       	ldd	r31, Y+18	; 0x12
    3216:	87 89       	ldd	r24, Z+23	; 0x17
    3218:	90 8d       	ldd	r25, Z+24	; 0x18
    321a:	28 85       	ldd	r18, Y+8	; 0x08
    321c:	39 85       	ldd	r19, Y+9	; 0x09
    321e:	65 ea       	ldi	r22, 0xA5	; 165
    3220:	70 e0       	ldi	r23, 0x00	; 0
    3222:	a9 01       	movw	r20, r18
    3224:	0e 94 b1 39 	call	0x7362	; 0x7362 <memset>
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    3228:	e9 89       	ldd	r30, Y+17	; 0x11
    322a:	fa 89       	ldd	r31, Y+18	; 0x12
    322c:	27 89       	ldd	r18, Z+23	; 0x17
    322e:	30 8d       	ldd	r19, Z+24	; 0x18
    3230:	88 85       	ldd	r24, Y+8	; 0x08
    3232:	99 85       	ldd	r25, Y+9	; 0x09
    3234:	01 97       	sbiw	r24, 0x01	; 1
    3236:	82 0f       	add	r24, r18
    3238:	93 1f       	adc	r25, r19
    323a:	9b 83       	std	Y+3, r25	; 0x03
    323c:	8a 83       	std	Y+2, r24	; 0x02
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    323e:	8e 81       	ldd	r24, Y+6	; 0x06
    3240:	9f 81       	ldd	r25, Y+7	; 0x07
    3242:	00 97       	sbiw	r24, 0x00	; 0
    3244:	51 f1       	breq	.+84     	; 0x329a <prvInitialiseNewTask+0xd0>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3246:	19 82       	std	Y+1, r1	; 0x01
    3248:	21 c0       	rjmp	.+66     	; 0x328c <prvInitialiseNewTask+0xc2>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    324a:	89 81       	ldd	r24, Y+1	; 0x01
    324c:	48 2f       	mov	r20, r24
    324e:	50 e0       	ldi	r21, 0x00	; 0
    3250:	89 81       	ldd	r24, Y+1	; 0x01
    3252:	28 2f       	mov	r18, r24
    3254:	30 e0       	ldi	r19, 0x00	; 0
    3256:	8e 81       	ldd	r24, Y+6	; 0x06
    3258:	9f 81       	ldd	r25, Y+7	; 0x07
    325a:	fc 01       	movw	r30, r24
    325c:	e2 0f       	add	r30, r18
    325e:	f3 1f       	adc	r31, r19
    3260:	20 81       	ld	r18, Z
    3262:	89 89       	ldd	r24, Y+17	; 0x11
    3264:	9a 89       	ldd	r25, Y+18	; 0x12
    3266:	84 0f       	add	r24, r20
    3268:	95 1f       	adc	r25, r21
    326a:	fc 01       	movw	r30, r24
    326c:	79 96       	adiw	r30, 0x19	; 25
    326e:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    3270:	89 81       	ldd	r24, Y+1	; 0x01
    3272:	28 2f       	mov	r18, r24
    3274:	30 e0       	ldi	r19, 0x00	; 0
    3276:	8e 81       	ldd	r24, Y+6	; 0x06
    3278:	9f 81       	ldd	r25, Y+7	; 0x07
    327a:	fc 01       	movw	r30, r24
    327c:	e2 0f       	add	r30, r18
    327e:	f3 1f       	adc	r31, r19
    3280:	80 81       	ld	r24, Z
    3282:	88 23       	and	r24, r24
    3284:	31 f0       	breq	.+12     	; 0x3292 <prvInitialiseNewTask+0xc8>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3286:	89 81       	ldd	r24, Y+1	; 0x01
    3288:	8f 5f       	subi	r24, 0xFF	; 255
    328a:	89 83       	std	Y+1, r24	; 0x01
    328c:	89 81       	ldd	r24, Y+1	; 0x01
    328e:	88 30       	cpi	r24, 0x08	; 8
    3290:	e0 f2       	brcs	.-72     	; 0x324a <prvInitialiseNewTask+0x80>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    3292:	e9 89       	ldd	r30, Y+17	; 0x11
    3294:	fa 89       	ldd	r31, Y+18	; 0x12
    3296:	10 a2       	std	Z+32, r1	; 0x20
    3298:	03 c0       	rjmp	.+6      	; 0x32a0 <prvInitialiseNewTask+0xd6>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    329a:	e9 89       	ldd	r30, Y+17	; 0x11
    329c:	fa 89       	ldd	r31, Y+18	; 0x12
    329e:	11 8e       	std	Z+25, r1	; 0x19
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    32a0:	8e 85       	ldd	r24, Y+14	; 0x0e
    32a2:	84 30       	cpi	r24, 0x04	; 4
    32a4:	10 f0       	brcs	.+4      	; 0x32aa <prvInitialiseNewTask+0xe0>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    32a6:	83 e0       	ldi	r24, 0x03	; 3
    32a8:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    32aa:	e9 89       	ldd	r30, Y+17	; 0x11
    32ac:	fa 89       	ldd	r31, Y+18	; 0x12
    32ae:	8e 85       	ldd	r24, Y+14	; 0x0e
    32b0:	86 8b       	std	Z+22, r24	; 0x16
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    32b2:	89 89       	ldd	r24, Y+17	; 0x11
    32b4:	9a 89       	ldd	r25, Y+18	; 0x12
    32b6:	02 96       	adiw	r24, 0x02	; 2
    32b8:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    32bc:	89 89       	ldd	r24, Y+17	; 0x11
    32be:	9a 89       	ldd	r25, Y+18	; 0x12
    32c0:	0c 96       	adiw	r24, 0x0c	; 12
    32c2:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    32c6:	e9 89       	ldd	r30, Y+17	; 0x11
    32c8:	fa 89       	ldd	r31, Y+18	; 0x12
    32ca:	89 89       	ldd	r24, Y+17	; 0x11
    32cc:	9a 89       	ldd	r25, Y+18	; 0x12
    32ce:	91 87       	std	Z+9, r25	; 0x09
    32d0:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    32d2:	8e 85       	ldd	r24, Y+14	; 0x0e
    32d4:	28 2f       	mov	r18, r24
    32d6:	30 e0       	ldi	r19, 0x00	; 0
    32d8:	84 e0       	ldi	r24, 0x04	; 4
    32da:	90 e0       	ldi	r25, 0x00	; 0
    32dc:	82 1b       	sub	r24, r18
    32de:	93 0b       	sbc	r25, r19
    32e0:	e9 89       	ldd	r30, Y+17	; 0x11
    32e2:	fa 89       	ldd	r31, Y+18	; 0x12
    32e4:	95 87       	std	Z+13, r25	; 0x0d
    32e6:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    32e8:	e9 89       	ldd	r30, Y+17	; 0x11
    32ea:	fa 89       	ldd	r31, Y+18	; 0x12
    32ec:	89 89       	ldd	r24, Y+17	; 0x11
    32ee:	9a 89       	ldd	r25, Y+18	; 0x12
    32f0:	93 8b       	std	Z+19, r25	; 0x13
    32f2:	82 8b       	std	Z+18, r24	; 0x12
        }
    #endif /* configUSE_APPLICATION_TASK_TAG */

    #if ( configGENERATE_RUN_TIME_STATS == 1 )
        {
            pxNewTCB->ulRunTimeCounter = ( configRUN_TIME_COUNTER_TYPE ) 0;
    32f4:	e9 89       	ldd	r30, Y+17	; 0x11
    32f6:	fa 89       	ldd	r31, Y+18	; 0x12
    32f8:	13 a2       	std	Z+35, r1	; 0x23
    32fa:	14 a2       	std	Z+36, r1	; 0x24
    32fc:	15 a2       	std	Z+37, r1	; 0x25
    32fe:	16 a2       	std	Z+38, r1	; 0x26
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    3300:	89 89       	ldd	r24, Y+17	; 0x11
    3302:	9a 89       	ldd	r25, Y+18	; 0x12
    3304:	87 96       	adiw	r24, 0x27	; 39
    3306:	60 e0       	ldi	r22, 0x00	; 0
    3308:	70 e0       	ldi	r23, 0x00	; 0
    330a:	44 e0       	ldi	r20, 0x04	; 4
    330c:	50 e0       	ldi	r21, 0x00	; 0
    330e:	0e 94 b1 39 	call	0x7362	; 0x7362 <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    3312:	89 89       	ldd	r24, Y+17	; 0x11
    3314:	9a 89       	ldd	r25, Y+18	; 0x12
    3316:	8b 96       	adiw	r24, 0x2b	; 43
    3318:	60 e0       	ldi	r22, 0x00	; 0
    331a:	70 e0       	ldi	r23, 0x00	; 0
    331c:	41 e0       	ldi	r20, 0x01	; 1
    331e:	50 e0       	ldi	r21, 0x00	; 0
    3320:	0e 94 b1 39 	call	0x7362	; 0x7362 <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3324:	8a 81       	ldd	r24, Y+2	; 0x02
    3326:	9b 81       	ldd	r25, Y+3	; 0x03
    3328:	2c 81       	ldd	r18, Y+4	; 0x04
    332a:	3d 81       	ldd	r19, Y+5	; 0x05
    332c:	4c 85       	ldd	r20, Y+12	; 0x0c
    332e:	5d 85       	ldd	r21, Y+13	; 0x0d
    3330:	b9 01       	movw	r22, r18
    3332:	0e 94 c9 00 	call	0x192	; 0x192 <pxPortInitialiseStack>
    3336:	e9 89       	ldd	r30, Y+17	; 0x11
    3338:	fa 89       	ldd	r31, Y+18	; 0x12
    333a:	91 83       	std	Z+1, r25	; 0x01
    333c:	80 83       	st	Z, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    333e:	8f 85       	ldd	r24, Y+15	; 0x0f
    3340:	98 89       	ldd	r25, Y+16	; 0x10
    3342:	00 97       	sbiw	r24, 0x00	; 0
    3344:	31 f0       	breq	.+12     	; 0x3352 <prvInitialiseNewTask+0x188>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3346:	ef 85       	ldd	r30, Y+15	; 0x0f
    3348:	f8 89       	ldd	r31, Y+16	; 0x10
    334a:	89 89       	ldd	r24, Y+17	; 0x11
    334c:	9a 89       	ldd	r25, Y+18	; 0x12
    334e:	91 83       	std	Z+1, r25	; 0x01
    3350:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    3352:	64 96       	adiw	r28, 0x14	; 20
    3354:	0f b6       	in	r0, 0x3f	; 63
    3356:	f8 94       	cli
    3358:	de bf       	out	0x3e, r29	; 62
    335a:	0f be       	out	0x3f, r0	; 63
    335c:	cd bf       	out	0x3d, r28	; 61
    335e:	cf 91       	pop	r28
    3360:	df 91       	pop	r29
    3362:	1f 91       	pop	r17
    3364:	0f 91       	pop	r16
    3366:	ef 90       	pop	r14
    3368:	df 90       	pop	r13
    336a:	cf 90       	pop	r12
    336c:	bf 90       	pop	r11
    336e:	af 90       	pop	r10
    3370:	9f 90       	pop	r9
    3372:	8f 90       	pop	r8
    3374:	08 95       	ret

00003376 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    3376:	df 93       	push	r29
    3378:	cf 93       	push	r28
    337a:	00 d0       	rcall	.+0      	; 0x337c <prvAddNewTaskToReadyList+0x6>
    337c:	00 d0       	rcall	.+0      	; 0x337e <prvAddNewTaskToReadyList+0x8>
    337e:	cd b7       	in	r28, 0x3d	; 61
    3380:	de b7       	in	r29, 0x3e	; 62
    3382:	9c 83       	std	Y+4, r25	; 0x04
    3384:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    3386:	0f b6       	in	r0, 0x3f	; 63
    3388:	f8 94       	cli
    338a:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    338c:	80 91 cf 06 	lds	r24, 0x06CF
    3390:	8f 5f       	subi	r24, 0xFF	; 255
    3392:	80 93 cf 06 	sts	0x06CF, r24

        if( pxCurrentTCB == NULL )
    3396:	80 91 cc 06 	lds	r24, 0x06CC
    339a:	90 91 cd 06 	lds	r25, 0x06CD
    339e:	00 97       	sbiw	r24, 0x00	; 0
    33a0:	69 f4       	brne	.+26     	; 0x33bc <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    33a2:	8b 81       	ldd	r24, Y+3	; 0x03
    33a4:	9c 81       	ldd	r25, Y+4	; 0x04
    33a6:	90 93 cd 06 	sts	0x06CD, r25
    33aa:	80 93 cc 06 	sts	0x06CC, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    33ae:	80 91 cf 06 	lds	r24, 0x06CF
    33b2:	81 30       	cpi	r24, 0x01	; 1
    33b4:	b9 f4       	brne	.+46     	; 0x33e4 <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    33b6:	0e 94 5a 25 	call	0x4ab4	; 0x4ab4 <prvInitialiseTaskLists>
    33ba:	14 c0       	rjmp	.+40     	; 0x33e4 <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    33bc:	80 91 d3 06 	lds	r24, 0x06D3
    33c0:	88 23       	and	r24, r24
    33c2:	81 f4       	brne	.+32     	; 0x33e4 <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    33c4:	e0 91 cc 06 	lds	r30, 0x06CC
    33c8:	f0 91 cd 06 	lds	r31, 0x06CD
    33cc:	96 89       	ldd	r25, Z+22	; 0x16
    33ce:	eb 81       	ldd	r30, Y+3	; 0x03
    33d0:	fc 81       	ldd	r31, Y+4	; 0x04
    33d2:	86 89       	ldd	r24, Z+22	; 0x16
    33d4:	89 17       	cp	r24, r25
    33d6:	30 f0       	brcs	.+12     	; 0x33e4 <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    33d8:	8b 81       	ldd	r24, Y+3	; 0x03
    33da:	9c 81       	ldd	r25, Y+4	; 0x04
    33dc:	90 93 cd 06 	sts	0x06CD, r25
    33e0:	80 93 cc 06 	sts	0x06CC, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    33e4:	80 91 d8 06 	lds	r24, 0x06D8
    33e8:	8f 5f       	subi	r24, 0xFF	; 255
    33ea:	80 93 d8 06 	sts	0x06D8, r24

        #if ( configUSE_TRACE_FACILITY == 1 )
            {
                /* Add a counter into the TCB for tracing only. */
                pxNewTCB->uxTCBNumber = uxTaskNumber;
    33ee:	80 91 d8 06 	lds	r24, 0x06D8
    33f2:	eb 81       	ldd	r30, Y+3	; 0x03
    33f4:	fc 81       	ldd	r31, Y+4	; 0x04
    33f6:	81 a3       	std	Z+33, r24	; 0x21
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    33f8:	eb 81       	ldd	r30, Y+3	; 0x03
    33fa:	fc 81       	ldd	r31, Y+4	; 0x04
    33fc:	96 89       	ldd	r25, Z+22	; 0x16
    33fe:	80 91 d2 06 	lds	r24, 0x06D2
    3402:	89 17       	cp	r24, r25
    3404:	28 f4       	brcc	.+10     	; 0x3410 <prvAddNewTaskToReadyList+0x9a>
    3406:	eb 81       	ldd	r30, Y+3	; 0x03
    3408:	fc 81       	ldd	r31, Y+4	; 0x04
    340a:	86 89       	ldd	r24, Z+22	; 0x16
    340c:	80 93 d2 06 	sts	0x06D2, r24
    3410:	eb 81       	ldd	r30, Y+3	; 0x03
    3412:	fc 81       	ldd	r31, Y+4	; 0x04
    3414:	86 89       	ldd	r24, Z+22	; 0x16
    3416:	28 2f       	mov	r18, r24
    3418:	30 e0       	ldi	r19, 0x00	; 0
    341a:	c9 01       	movw	r24, r18
    341c:	88 0f       	add	r24, r24
    341e:	99 1f       	adc	r25, r25
    3420:	88 0f       	add	r24, r24
    3422:	99 1f       	adc	r25, r25
    3424:	88 0f       	add	r24, r24
    3426:	99 1f       	adc	r25, r25
    3428:	82 0f       	add	r24, r18
    342a:	93 1f       	adc	r25, r19
    342c:	fc 01       	movw	r30, r24
    342e:	ea 51       	subi	r30, 0x1A	; 26
    3430:	f9 4f       	sbci	r31, 0xF9	; 249
    3432:	81 81       	ldd	r24, Z+1	; 0x01
    3434:	92 81       	ldd	r25, Z+2	; 0x02
    3436:	9a 83       	std	Y+2, r25	; 0x02
    3438:	89 83       	std	Y+1, r24	; 0x01
    343a:	eb 81       	ldd	r30, Y+3	; 0x03
    343c:	fc 81       	ldd	r31, Y+4	; 0x04
    343e:	89 81       	ldd	r24, Y+1	; 0x01
    3440:	9a 81       	ldd	r25, Y+2	; 0x02
    3442:	95 83       	std	Z+5, r25	; 0x05
    3444:	84 83       	std	Z+4, r24	; 0x04
    3446:	e9 81       	ldd	r30, Y+1	; 0x01
    3448:	fa 81       	ldd	r31, Y+2	; 0x02
    344a:	84 81       	ldd	r24, Z+4	; 0x04
    344c:	95 81       	ldd	r25, Z+5	; 0x05
    344e:	eb 81       	ldd	r30, Y+3	; 0x03
    3450:	fc 81       	ldd	r31, Y+4	; 0x04
    3452:	97 83       	std	Z+7, r25	; 0x07
    3454:	86 83       	std	Z+6, r24	; 0x06
    3456:	e9 81       	ldd	r30, Y+1	; 0x01
    3458:	fa 81       	ldd	r31, Y+2	; 0x02
    345a:	04 80       	ldd	r0, Z+4	; 0x04
    345c:	f5 81       	ldd	r31, Z+5	; 0x05
    345e:	e0 2d       	mov	r30, r0
    3460:	8b 81       	ldd	r24, Y+3	; 0x03
    3462:	9c 81       	ldd	r25, Y+4	; 0x04
    3464:	02 96       	adiw	r24, 0x02	; 2
    3466:	93 83       	std	Z+3, r25	; 0x03
    3468:	82 83       	std	Z+2, r24	; 0x02
    346a:	8b 81       	ldd	r24, Y+3	; 0x03
    346c:	9c 81       	ldd	r25, Y+4	; 0x04
    346e:	02 96       	adiw	r24, 0x02	; 2
    3470:	e9 81       	ldd	r30, Y+1	; 0x01
    3472:	fa 81       	ldd	r31, Y+2	; 0x02
    3474:	95 83       	std	Z+5, r25	; 0x05
    3476:	84 83       	std	Z+4, r24	; 0x04
    3478:	eb 81       	ldd	r30, Y+3	; 0x03
    347a:	fc 81       	ldd	r31, Y+4	; 0x04
    347c:	86 89       	ldd	r24, Z+22	; 0x16
    347e:	28 2f       	mov	r18, r24
    3480:	30 e0       	ldi	r19, 0x00	; 0
    3482:	c9 01       	movw	r24, r18
    3484:	88 0f       	add	r24, r24
    3486:	99 1f       	adc	r25, r25
    3488:	88 0f       	add	r24, r24
    348a:	99 1f       	adc	r25, r25
    348c:	88 0f       	add	r24, r24
    348e:	99 1f       	adc	r25, r25
    3490:	82 0f       	add	r24, r18
    3492:	93 1f       	adc	r25, r19
    3494:	8a 51       	subi	r24, 0x1A	; 26
    3496:	99 4f       	sbci	r25, 0xF9	; 249
    3498:	eb 81       	ldd	r30, Y+3	; 0x03
    349a:	fc 81       	ldd	r31, Y+4	; 0x04
    349c:	93 87       	std	Z+11, r25	; 0x0b
    349e:	82 87       	std	Z+10, r24	; 0x0a
    34a0:	eb 81       	ldd	r30, Y+3	; 0x03
    34a2:	fc 81       	ldd	r31, Y+4	; 0x04
    34a4:	86 89       	ldd	r24, Z+22	; 0x16
    34a6:	28 2f       	mov	r18, r24
    34a8:	30 e0       	ldi	r19, 0x00	; 0
    34aa:	c9 01       	movw	r24, r18
    34ac:	88 0f       	add	r24, r24
    34ae:	99 1f       	adc	r25, r25
    34b0:	88 0f       	add	r24, r24
    34b2:	99 1f       	adc	r25, r25
    34b4:	88 0f       	add	r24, r24
    34b6:	99 1f       	adc	r25, r25
    34b8:	82 0f       	add	r24, r18
    34ba:	93 1f       	adc	r25, r19
    34bc:	fc 01       	movw	r30, r24
    34be:	ea 51       	subi	r30, 0x1A	; 26
    34c0:	f9 4f       	sbci	r31, 0xF9	; 249
    34c2:	80 81       	ld	r24, Z
    34c4:	8f 5f       	subi	r24, 0xFF	; 255
    34c6:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    34c8:	0f 90       	pop	r0
    34ca:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    34cc:	80 91 d3 06 	lds	r24, 0x06D3
    34d0:	88 23       	and	r24, r24
    34d2:	61 f0       	breq	.+24     	; 0x34ec <prvAddNewTaskToReadyList+0x176>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    34d4:	e0 91 cc 06 	lds	r30, 0x06CC
    34d8:	f0 91 cd 06 	lds	r31, 0x06CD
    34dc:	96 89       	ldd	r25, Z+22	; 0x16
    34de:	eb 81       	ldd	r30, Y+3	; 0x03
    34e0:	fc 81       	ldd	r31, Y+4	; 0x04
    34e2:	86 89       	ldd	r24, Z+22	; 0x16
    34e4:	98 17       	cp	r25, r24
    34e6:	10 f4       	brcc	.+4      	; 0x34ec <prvAddNewTaskToReadyList+0x176>
        {
            taskYIELD_IF_USING_PREEMPTION();
    34e8:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    34ec:	0f 90       	pop	r0
    34ee:	0f 90       	pop	r0
    34f0:	0f 90       	pop	r0
    34f2:	0f 90       	pop	r0
    34f4:	cf 91       	pop	r28
    34f6:	df 91       	pop	r29
    34f8:	08 95       	ret

000034fa <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    34fa:	df 93       	push	r29
    34fc:	cf 93       	push	r28
    34fe:	00 d0       	rcall	.+0      	; 0x3500 <vTaskDelete+0x6>
    3500:	00 d0       	rcall	.+0      	; 0x3502 <vTaskDelete+0x8>
    3502:	00 d0       	rcall	.+0      	; 0x3504 <vTaskDelete+0xa>
    3504:	cd b7       	in	r28, 0x3d	; 61
    3506:	de b7       	in	r29, 0x3e	; 62
    3508:	9c 83       	std	Y+4, r25	; 0x04
    350a:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    350c:	0f b6       	in	r0, 0x3f	; 63
    350e:	f8 94       	cli
    3510:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3512:	8b 81       	ldd	r24, Y+3	; 0x03
    3514:	9c 81       	ldd	r25, Y+4	; 0x04
    3516:	00 97       	sbiw	r24, 0x00	; 0
    3518:	39 f4       	brne	.+14     	; 0x3528 <vTaskDelete+0x2e>
    351a:	80 91 cc 06 	lds	r24, 0x06CC
    351e:	90 91 cd 06 	lds	r25, 0x06CD
    3522:	9e 83       	std	Y+6, r25	; 0x06
    3524:	8d 83       	std	Y+5, r24	; 0x05
    3526:	04 c0       	rjmp	.+8      	; 0x3530 <vTaskDelete+0x36>
    3528:	8b 81       	ldd	r24, Y+3	; 0x03
    352a:	9c 81       	ldd	r25, Y+4	; 0x04
    352c:	9e 83       	std	Y+6, r25	; 0x06
    352e:	8d 83       	std	Y+5, r24	; 0x05
    3530:	8d 81       	ldd	r24, Y+5	; 0x05
    3532:	9e 81       	ldd	r25, Y+6	; 0x06
    3534:	9a 83       	std	Y+2, r25	; 0x02
    3536:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3538:	89 81       	ldd	r24, Y+1	; 0x01
    353a:	9a 81       	ldd	r25, Y+2	; 0x02
    353c:	02 96       	adiw	r24, 0x02	; 2
    353e:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3542:	e9 81       	ldd	r30, Y+1	; 0x01
    3544:	fa 81       	ldd	r31, Y+2	; 0x02
    3546:	84 89       	ldd	r24, Z+20	; 0x14
    3548:	95 89       	ldd	r25, Z+21	; 0x15
    354a:	00 97       	sbiw	r24, 0x00	; 0
    354c:	29 f0       	breq	.+10     	; 0x3558 <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    354e:	89 81       	ldd	r24, Y+1	; 0x01
    3550:	9a 81       	ldd	r25, Y+2	; 0x02
    3552:	0c 96       	adiw	r24, 0x0c	; 12
    3554:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    3558:	80 91 d8 06 	lds	r24, 0x06D8
    355c:	8f 5f       	subi	r24, 0xFF	; 255
    355e:	80 93 d8 06 	sts	0x06D8, r24

            if( pxTCB == pxCurrentTCB )
    3562:	20 91 cc 06 	lds	r18, 0x06CC
    3566:	30 91 cd 06 	lds	r19, 0x06CD
    356a:	89 81       	ldd	r24, Y+1	; 0x01
    356c:	9a 81       	ldd	r25, Y+2	; 0x02
    356e:	82 17       	cp	r24, r18
    3570:	93 07       	cpc	r25, r19
    3572:	81 f4       	brne	.+32     	; 0x3594 <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    3574:	89 81       	ldd	r24, Y+1	; 0x01
    3576:	9a 81       	ldd	r25, Y+2	; 0x02
    3578:	9c 01       	movw	r18, r24
    357a:	2e 5f       	subi	r18, 0xFE	; 254
    357c:	3f 4f       	sbci	r19, 0xFF	; 255
    357e:	89 e2       	ldi	r24, 0x29	; 41
    3580:	97 e0       	ldi	r25, 0x07	; 7
    3582:	b9 01       	movw	r22, r18
    3584:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    3588:	80 91 ce 06 	lds	r24, 0x06CE
    358c:	8f 5f       	subi	r24, 0xFF	; 255
    358e:	80 93 ce 06 	sts	0x06CE, r24
    3592:	07 c0       	rjmp	.+14     	; 0x35a2 <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    3594:	80 91 cf 06 	lds	r24, 0x06CF
    3598:	81 50       	subi	r24, 0x01	; 1
    359a:	80 93 cf 06 	sts	0x06CF, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    359e:	0e 94 2e 27 	call	0x4e5c	; 0x4e5c <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    35a2:	0f 90       	pop	r0
    35a4:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    35a6:	20 91 cc 06 	lds	r18, 0x06CC
    35aa:	30 91 cd 06 	lds	r19, 0x06CD
    35ae:	89 81       	ldd	r24, Y+1	; 0x01
    35b0:	9a 81       	ldd	r25, Y+2	; 0x02
    35b2:	82 17       	cp	r24, r18
    35b4:	93 07       	cpc	r25, r19
    35b6:	21 f0       	breq	.+8      	; 0x35c0 <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    35b8:	89 81       	ldd	r24, Y+1	; 0x01
    35ba:	9a 81       	ldd	r25, Y+2	; 0x02
    35bc:	0e 94 18 27 	call	0x4e30	; 0x4e30 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    35c0:	80 91 d3 06 	lds	r24, 0x06D3
    35c4:	88 23       	and	r24, r24
    35c6:	59 f0       	breq	.+22     	; 0x35de <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    35c8:	20 91 cc 06 	lds	r18, 0x06CC
    35cc:	30 91 cd 06 	lds	r19, 0x06CD
    35d0:	89 81       	ldd	r24, Y+1	; 0x01
    35d2:	9a 81       	ldd	r25, Y+2	; 0x02
    35d4:	82 17       	cp	r24, r18
    35d6:	93 07       	cpc	r25, r19
    35d8:	11 f4       	brne	.+4      	; 0x35de <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    35da:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    35de:	26 96       	adiw	r28, 0x06	; 6
    35e0:	0f b6       	in	r0, 0x3f	; 63
    35e2:	f8 94       	cli
    35e4:	de bf       	out	0x3e, r29	; 62
    35e6:	0f be       	out	0x3f, r0	; 63
    35e8:	cd bf       	out	0x3d, r28	; 61
    35ea:	cf 91       	pop	r28
    35ec:	df 91       	pop	r29
    35ee:	08 95       	ret

000035f0 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    35f0:	df 93       	push	r29
    35f2:	cf 93       	push	r28
    35f4:	cd b7       	in	r28, 0x3d	; 61
    35f6:	de b7       	in	r29, 0x3e	; 62
    35f8:	2a 97       	sbiw	r28, 0x0a	; 10
    35fa:	0f b6       	in	r0, 0x3f	; 63
    35fc:	f8 94       	cli
    35fe:	de bf       	out	0x3e, r29	; 62
    3600:	0f be       	out	0x3f, r0	; 63
    3602:	cd bf       	out	0x3d, r28	; 61
    3604:	98 87       	std	Y+8, r25	; 0x08
    3606:	8f 83       	std	Y+7, r24	; 0x07
    3608:	7a 87       	std	Y+10, r23	; 0x0a
    360a:	69 87       	std	Y+9, r22	; 0x09
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    360c:	1b 82       	std	Y+3, r1	; 0x03

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    360e:	0e 94 30 1c 	call	0x3860	; 0x3860 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    3612:	80 91 d0 06 	lds	r24, 0x06D0
    3616:	90 91 d1 06 	lds	r25, 0x06D1
    361a:	9a 83       	std	Y+2, r25	; 0x02
    361c:	89 83       	std	Y+1, r24	; 0x01

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    361e:	ef 81       	ldd	r30, Y+7	; 0x07
    3620:	f8 85       	ldd	r31, Y+8	; 0x08
    3622:	20 81       	ld	r18, Z
    3624:	31 81       	ldd	r19, Z+1	; 0x01
    3626:	89 85       	ldd	r24, Y+9	; 0x09
    3628:	9a 85       	ldd	r25, Y+10	; 0x0a
    362a:	82 0f       	add	r24, r18
    362c:	93 1f       	adc	r25, r19
    362e:	9e 83       	std	Y+6, r25	; 0x06
    3630:	8d 83       	std	Y+5, r24	; 0x05

            if( xConstTickCount < *pxPreviousWakeTime )
    3632:	ef 81       	ldd	r30, Y+7	; 0x07
    3634:	f8 85       	ldd	r31, Y+8	; 0x08
    3636:	20 81       	ld	r18, Z
    3638:	31 81       	ldd	r19, Z+1	; 0x01
    363a:	89 81       	ldd	r24, Y+1	; 0x01
    363c:	9a 81       	ldd	r25, Y+2	; 0x02
    363e:	82 17       	cp	r24, r18
    3640:	93 07       	cpc	r25, r19
    3642:	98 f4       	brcc	.+38     	; 0x366a <xTaskDelayUntil+0x7a>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    3644:	ef 81       	ldd	r30, Y+7	; 0x07
    3646:	f8 85       	ldd	r31, Y+8	; 0x08
    3648:	20 81       	ld	r18, Z
    364a:	31 81       	ldd	r19, Z+1	; 0x01
    364c:	8d 81       	ldd	r24, Y+5	; 0x05
    364e:	9e 81       	ldd	r25, Y+6	; 0x06
    3650:	82 17       	cp	r24, r18
    3652:	93 07       	cpc	r25, r19
    3654:	e0 f4       	brcc	.+56     	; 0x368e <xTaskDelayUntil+0x9e>
    3656:	2d 81       	ldd	r18, Y+5	; 0x05
    3658:	3e 81       	ldd	r19, Y+6	; 0x06
    365a:	89 81       	ldd	r24, Y+1	; 0x01
    365c:	9a 81       	ldd	r25, Y+2	; 0x02
    365e:	82 17       	cp	r24, r18
    3660:	93 07       	cpc	r25, r19
    3662:	a8 f4       	brcc	.+42     	; 0x368e <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    3664:	81 e0       	ldi	r24, 0x01	; 1
    3666:	8b 83       	std	Y+3, r24	; 0x03
    3668:	12 c0       	rjmp	.+36     	; 0x368e <xTaskDelayUntil+0x9e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    366a:	ef 81       	ldd	r30, Y+7	; 0x07
    366c:	f8 85       	ldd	r31, Y+8	; 0x08
    366e:	20 81       	ld	r18, Z
    3670:	31 81       	ldd	r19, Z+1	; 0x01
    3672:	8d 81       	ldd	r24, Y+5	; 0x05
    3674:	9e 81       	ldd	r25, Y+6	; 0x06
    3676:	82 17       	cp	r24, r18
    3678:	93 07       	cpc	r25, r19
    367a:	38 f0       	brcs	.+14     	; 0x368a <xTaskDelayUntil+0x9a>
    367c:	2d 81       	ldd	r18, Y+5	; 0x05
    367e:	3e 81       	ldd	r19, Y+6	; 0x06
    3680:	89 81       	ldd	r24, Y+1	; 0x01
    3682:	9a 81       	ldd	r25, Y+2	; 0x02
    3684:	82 17       	cp	r24, r18
    3686:	93 07       	cpc	r25, r19
    3688:	10 f4       	brcc	.+4      	; 0x368e <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    368a:	81 e0       	ldi	r24, 0x01	; 1
    368c:	8b 83       	std	Y+3, r24	; 0x03
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    368e:	ef 81       	ldd	r30, Y+7	; 0x07
    3690:	f8 85       	ldd	r31, Y+8	; 0x08
    3692:	8d 81       	ldd	r24, Y+5	; 0x05
    3694:	9e 81       	ldd	r25, Y+6	; 0x06
    3696:	91 83       	std	Z+1, r25	; 0x01
    3698:	80 83       	st	Z, r24

            if( xShouldDelay != pdFALSE )
    369a:	8b 81       	ldd	r24, Y+3	; 0x03
    369c:	88 23       	and	r24, r24
    369e:	49 f0       	breq	.+18     	; 0x36b2 <xTaskDelayUntil+0xc2>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    36a0:	8d 81       	ldd	r24, Y+5	; 0x05
    36a2:	9e 81       	ldd	r25, Y+6	; 0x06
    36a4:	29 81       	ldd	r18, Y+1	; 0x01
    36a6:	3a 81       	ldd	r19, Y+2	; 0x02
    36a8:	82 1b       	sub	r24, r18
    36aa:	93 0b       	sbc	r25, r19
    36ac:	60 e0       	ldi	r22, 0x00	; 0
    36ae:	0e 94 73 31 	call	0x62e6	; 0x62e6 <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    36b2:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>
    36b6:	8c 83       	std	Y+4, r24	; 0x04

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    36b8:	8c 81       	ldd	r24, Y+4	; 0x04
    36ba:	88 23       	and	r24, r24
    36bc:	11 f4       	brne	.+4      	; 0x36c2 <xTaskDelayUntil+0xd2>
        {
            portYIELD_WITHIN_API();
    36be:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    36c2:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    36c4:	2a 96       	adiw	r28, 0x0a	; 10
    36c6:	0f b6       	in	r0, 0x3f	; 63
    36c8:	f8 94       	cli
    36ca:	de bf       	out	0x3e, r29	; 62
    36cc:	0f be       	out	0x3f, r0	; 63
    36ce:	cd bf       	out	0x3d, r28	; 61
    36d0:	cf 91       	pop	r28
    36d2:	df 91       	pop	r29
    36d4:	08 95       	ret

000036d6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    36d6:	df 93       	push	r29
    36d8:	cf 93       	push	r28
    36da:	00 d0       	rcall	.+0      	; 0x36dc <vTaskDelay+0x6>
    36dc:	0f 92       	push	r0
    36de:	cd b7       	in	r28, 0x3d	; 61
    36e0:	de b7       	in	r29, 0x3e	; 62
    36e2:	9b 83       	std	Y+3, r25	; 0x03
    36e4:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    36e6:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    36e8:	8a 81       	ldd	r24, Y+2	; 0x02
    36ea:	9b 81       	ldd	r25, Y+3	; 0x03
    36ec:	00 97       	sbiw	r24, 0x00	; 0
    36ee:	51 f0       	breq	.+20     	; 0x3704 <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    36f0:	0e 94 30 1c 	call	0x3860	; 0x3860 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    36f4:	8a 81       	ldd	r24, Y+2	; 0x02
    36f6:	9b 81       	ldd	r25, Y+3	; 0x03
    36f8:	60 e0       	ldi	r22, 0x00	; 0
    36fa:	0e 94 73 31 	call	0x62e6	; 0x62e6 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    36fe:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>
    3702:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3704:	89 81       	ldd	r24, Y+1	; 0x01
    3706:	88 23       	and	r24, r24
    3708:	11 f4       	brne	.+4      	; 0x370e <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    370a:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    370e:	0f 90       	pop	r0
    3710:	0f 90       	pop	r0
    3712:	0f 90       	pop	r0
    3714:	cf 91       	pop	r28
    3716:	df 91       	pop	r29
    3718:	08 95       	ret

0000371a <eTaskGetState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_xTaskAbortDelay == 1 ) )

    eTaskState eTaskGetState( TaskHandle_t xTask )
    {
    371a:	df 93       	push	r29
    371c:	cf 93       	push	r28
    371e:	cd b7       	in	r28, 0x3d	; 61
    3720:	de b7       	in	r29, 0x3e	; 62
    3722:	2b 97       	sbiw	r28, 0x0b	; 11
    3724:	0f b6       	in	r0, 0x3f	; 63
    3726:	f8 94       	cli
    3728:	de bf       	out	0x3e, r29	; 62
    372a:	0f be       	out	0x3f, r0	; 63
    372c:	cd bf       	out	0x3d, r28	; 61
    372e:	9b 87       	std	Y+11, r25	; 0x0b
    3730:	8a 87       	std	Y+10, r24	; 0x0a
        eTaskState eReturn;
        List_t const * pxStateList, * pxDelayedList, * pxOverflowedDelayedList;
        const TCB_t * const pxTCB = xTask;
    3732:	8a 85       	ldd	r24, Y+10	; 0x0a
    3734:	9b 85       	ldd	r25, Y+11	; 0x0b
    3736:	9a 83       	std	Y+2, r25	; 0x02
    3738:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( pxTCB );

        if( pxTCB == pxCurrentTCB )
    373a:	20 91 cc 06 	lds	r18, 0x06CC
    373e:	30 91 cd 06 	lds	r19, 0x06CD
    3742:	89 81       	ldd	r24, Y+1	; 0x01
    3744:	9a 81       	ldd	r25, Y+2	; 0x02
    3746:	82 17       	cp	r24, r18
    3748:	93 07       	cpc	r25, r19
    374a:	11 f4       	brne	.+4      	; 0x3750 <eTaskGetState+0x36>
        {
            /* The task calling this function is querying its own state. */
            eReturn = eRunning;
    374c:	19 86       	std	Y+9, r1	; 0x09
    374e:	37 c0       	rjmp	.+110    	; 0x37be <eTaskGetState+0xa4>
        }
        else
        {
            taskENTER_CRITICAL();
    3750:	0f b6       	in	r0, 0x3f	; 63
    3752:	f8 94       	cli
    3754:	0f 92       	push	r0
            {
                pxStateList = listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
    3756:	e9 81       	ldd	r30, Y+1	; 0x01
    3758:	fa 81       	ldd	r31, Y+2	; 0x02
    375a:	82 85       	ldd	r24, Z+10	; 0x0a
    375c:	93 85       	ldd	r25, Z+11	; 0x0b
    375e:	98 87       	std	Y+8, r25	; 0x08
    3760:	8f 83       	std	Y+7, r24	; 0x07
                pxDelayedList = pxDelayedTaskList;
    3762:	80 91 1c 07 	lds	r24, 0x071C
    3766:	90 91 1d 07 	lds	r25, 0x071D
    376a:	9e 83       	std	Y+6, r25	; 0x06
    376c:	8d 83       	std	Y+5, r24	; 0x05
                pxOverflowedDelayedList = pxOverflowDelayedTaskList;
    376e:	80 91 1e 07 	lds	r24, 0x071E
    3772:	90 91 1f 07 	lds	r25, 0x071F
    3776:	9c 83       	std	Y+4, r25	; 0x04
    3778:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    377a:	0f 90       	pop	r0
    377c:	0f be       	out	0x3f, r0	; 63

            if( ( pxStateList == pxDelayedList ) || ( pxStateList == pxOverflowedDelayedList ) )
    377e:	2f 81       	ldd	r18, Y+7	; 0x07
    3780:	38 85       	ldd	r19, Y+8	; 0x08
    3782:	8d 81       	ldd	r24, Y+5	; 0x05
    3784:	9e 81       	ldd	r25, Y+6	; 0x06
    3786:	28 17       	cp	r18, r24
    3788:	39 07       	cpc	r19, r25
    378a:	39 f0       	breq	.+14     	; 0x379a <eTaskGetState+0x80>
    378c:	2f 81       	ldd	r18, Y+7	; 0x07
    378e:	38 85       	ldd	r19, Y+8	; 0x08
    3790:	8b 81       	ldd	r24, Y+3	; 0x03
    3792:	9c 81       	ldd	r25, Y+4	; 0x04
    3794:	28 17       	cp	r18, r24
    3796:	39 07       	cpc	r19, r25
    3798:	19 f4       	brne	.+6      	; 0x37a0 <eTaskGetState+0x86>
            {
                /* The task being queried is referenced from one of the Blocked
                 * lists. */
                eReturn = eBlocked;
    379a:	82 e0       	ldi	r24, 0x02	; 2
    379c:	89 87       	std	Y+9, r24	; 0x09
    379e:	0f c0       	rjmp	.+30     	; 0x37be <eTaskGetState+0xa4>
                    }
                }
            #endif /* if ( INCLUDE_vTaskSuspend == 1 ) */

            #if ( INCLUDE_vTaskDelete == 1 )
                else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
    37a0:	8f 81       	ldd	r24, Y+7	; 0x07
    37a2:	98 85       	ldd	r25, Y+8	; 0x08
    37a4:	27 e0       	ldi	r18, 0x07	; 7
    37a6:	89 32       	cpi	r24, 0x29	; 41
    37a8:	92 07       	cpc	r25, r18
    37aa:	21 f0       	breq	.+8      	; 0x37b4 <eTaskGetState+0x9a>
    37ac:	8f 81       	ldd	r24, Y+7	; 0x07
    37ae:	98 85       	ldd	r25, Y+8	; 0x08
    37b0:	00 97       	sbiw	r24, 0x00	; 0
    37b2:	19 f4       	brne	.+6      	; 0x37ba <eTaskGetState+0xa0>
                {
                    /* The task being queried is referenced from the deleted
                     * tasks list, or it is not referenced from any lists at
                     * all. */
                    eReturn = eDeleted;
    37b4:	84 e0       	ldi	r24, 0x04	; 4
    37b6:	89 87       	std	Y+9, r24	; 0x09
    37b8:	02 c0       	rjmp	.+4      	; 0x37be <eTaskGetState+0xa4>

            else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
            {
                /* If the task is not in any other state, it must be in the
                 * Ready (including pending ready) state. */
                eReturn = eReady;
    37ba:	81 e0       	ldi	r24, 0x01	; 1
    37bc:	89 87       	std	Y+9, r24	; 0x09
            }
        }

        return eReturn;
    37be:	89 85       	ldd	r24, Y+9	; 0x09
    } /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    37c0:	2b 96       	adiw	r28, 0x0b	; 11
    37c2:	0f b6       	in	r0, 0x3f	; 63
    37c4:	f8 94       	cli
    37c6:	de bf       	out	0x3e, r29	; 62
    37c8:	0f be       	out	0x3f, r0	; 63
    37ca:	cd bf       	out	0x3d, r28	; 61
    37cc:	cf 91       	pop	r28
    37ce:	df 91       	pop	r29
    37d0:	08 95       	ret

000037d2 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    37d2:	ef 92       	push	r14
    37d4:	ff 92       	push	r15
    37d6:	0f 93       	push	r16
    37d8:	df 93       	push	r29
    37da:	cf 93       	push	r28
    37dc:	00 d0       	rcall	.+0      	; 0x37de <vTaskStartScheduler+0xc>
    37de:	cd b7       	in	r28, 0x3d	; 61
    37e0:	de b7       	in	r29, 0x3e	; 62
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    37e2:	8a e4       	ldi	r24, 0x4A	; 74
    37e4:	95 e2       	ldi	r25, 0x25	; 37
    37e6:	20 e6       	ldi	r18, 0x60	; 96
    37e8:	30 e0       	ldi	r19, 0x00	; 0
    37ea:	eb ed       	ldi	r30, 0xDB	; 219
    37ec:	f6 e0       	ldi	r31, 0x06	; 6
    37ee:	b9 01       	movw	r22, r18
    37f0:	45 e5       	ldi	r20, 0x55	; 85
    37f2:	50 e0       	ldi	r21, 0x00	; 0
    37f4:	20 e0       	ldi	r18, 0x00	; 0
    37f6:	30 e0       	ldi	r19, 0x00	; 0
    37f8:	00 e0       	ldi	r16, 0x00	; 0
    37fa:	7f 01       	movw	r14, r30
    37fc:	0e 94 6d 18 	call	0x30da	; 0x30da <xTaskCreate>
    3800:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
        {
            if( xReturn == pdPASS )
    3802:	89 81       	ldd	r24, Y+1	; 0x01
    3804:	81 30       	cpi	r24, 0x01	; 1
    3806:	19 f4       	brne	.+6      	; 0x380e <vTaskStartScheduler+0x3c>
            {
                xReturn = xTimerCreateTimerTask();
    3808:	0e 94 d9 31 	call	0x63b2	; 0x63b2 <xTimerCreateTimerTask>
    380c:	89 83       	std	Y+1, r24	; 0x01
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    380e:	89 81       	ldd	r24, Y+1	; 0x01
    3810:	81 30       	cpi	r24, 0x01	; 1
    3812:	81 f4       	brne	.+32     	; 0x3834 <vTaskStartScheduler+0x62>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    3814:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    3816:	8f ef       	ldi	r24, 0xFF	; 255
    3818:	9f ef       	ldi	r25, 0xFF	; 255
    381a:	90 93 da 06 	sts	0x06DA, r25
    381e:	80 93 d9 06 	sts	0x06D9, r24
        xSchedulerRunning = pdTRUE;
    3822:	81 e0       	ldi	r24, 0x01	; 1
    3824:	80 93 d3 06 	sts	0x06D3, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    3828:	10 92 d1 06 	sts	0x06D1, r1
    382c:	10 92 d0 06 	sts	0x06D0, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    3830:	0e 94 4c 02 	call	0x498	; 0x498 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    3834:	80 91 b1 00 	lds	r24, 0x00B1
}
    3838:	0f 90       	pop	r0
    383a:	0f 90       	pop	r0
    383c:	cf 91       	pop	r28
    383e:	df 91       	pop	r29
    3840:	0f 91       	pop	r16
    3842:	ff 90       	pop	r15
    3844:	ef 90       	pop	r14
    3846:	08 95       	ret

00003848 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3848:	df 93       	push	r29
    384a:	cf 93       	push	r28
    384c:	cd b7       	in	r28, 0x3d	; 61
    384e:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    3850:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    3852:	10 92 d3 06 	sts	0x06D3, r1
    vPortEndScheduler();
    3856:	0e 94 81 02 	call	0x502	; 0x502 <vPortEndScheduler>
}
    385a:	cf 91       	pop	r28
    385c:	df 91       	pop	r29
    385e:	08 95       	ret

00003860 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    3860:	df 93       	push	r29
    3862:	cf 93       	push	r28
    3864:	cd b7       	in	r28, 0x3d	; 61
    3866:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    3868:	80 91 dd 06 	lds	r24, 0x06DD
    386c:	8f 5f       	subi	r24, 0xFF	; 255
    386e:	80 93 dd 06 	sts	0x06DD, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    3872:	cf 91       	pop	r28
    3874:	df 91       	pop	r29
    3876:	08 95       	ret

00003878 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3878:	df 93       	push	r29
    387a:	cf 93       	push	r28
    387c:	cd b7       	in	r28, 0x3d	; 61
    387e:	de b7       	in	r29, 0x3e	; 62
    3880:	2b 97       	sbiw	r28, 0x0b	; 11
    3882:	0f b6       	in	r0, 0x3f	; 63
    3884:	f8 94       	cli
    3886:	de bf       	out	0x3e, r29	; 62
    3888:	0f be       	out	0x3f, r0	; 63
    388a:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    388c:	1b 86       	std	Y+11, r1	; 0x0b
    388e:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    3890:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    3892:	0f b6       	in	r0, 0x3f	; 63
    3894:	f8 94       	cli
    3896:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    3898:	80 91 dd 06 	lds	r24, 0x06DD
    389c:	81 50       	subi	r24, 0x01	; 1
    389e:	80 93 dd 06 	sts	0x06DD, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    38a2:	80 91 dd 06 	lds	r24, 0x06DD
    38a6:	88 23       	and	r24, r24
    38a8:	09 f0       	breq	.+2      	; 0x38ac <xTaskResumeAll+0x34>
    38aa:	2a c1       	rjmp	.+596    	; 0x3b00 <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    38ac:	80 91 cf 06 	lds	r24, 0x06CF
    38b0:	88 23       	and	r24, r24
    38b2:	09 f4       	brne	.+2      	; 0x38b6 <xTaskResumeAll+0x3e>
    38b4:	25 c1       	rjmp	.+586    	; 0x3b00 <xTaskResumeAll+0x288>
    38b6:	f3 c0       	rjmp	.+486    	; 0x3a9e <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    38b8:	e0 91 25 07 	lds	r30, 0x0725
    38bc:	f0 91 26 07 	lds	r31, 0x0726
    38c0:	86 81       	ldd	r24, Z+6	; 0x06
    38c2:	97 81       	ldd	r25, Z+7	; 0x07
    38c4:	9b 87       	std	Y+11, r25	; 0x0b
    38c6:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    38c8:	ea 85       	ldd	r30, Y+10	; 0x0a
    38ca:	fb 85       	ldd	r31, Y+11	; 0x0b
    38cc:	84 89       	ldd	r24, Z+20	; 0x14
    38ce:	95 89       	ldd	r25, Z+21	; 0x15
    38d0:	98 87       	std	Y+8, r25	; 0x08
    38d2:	8f 83       	std	Y+7, r24	; 0x07
    38d4:	ea 85       	ldd	r30, Y+10	; 0x0a
    38d6:	fb 85       	ldd	r31, Y+11	; 0x0b
    38d8:	a6 85       	ldd	r26, Z+14	; 0x0e
    38da:	b7 85       	ldd	r27, Z+15	; 0x0f
    38dc:	ea 85       	ldd	r30, Y+10	; 0x0a
    38de:	fb 85       	ldd	r31, Y+11	; 0x0b
    38e0:	80 89       	ldd	r24, Z+16	; 0x10
    38e2:	91 89       	ldd	r25, Z+17	; 0x11
    38e4:	15 96       	adiw	r26, 0x05	; 5
    38e6:	9c 93       	st	X, r25
    38e8:	8e 93       	st	-X, r24
    38ea:	14 97       	sbiw	r26, 0x04	; 4
    38ec:	ea 85       	ldd	r30, Y+10	; 0x0a
    38ee:	fb 85       	ldd	r31, Y+11	; 0x0b
    38f0:	a0 89       	ldd	r26, Z+16	; 0x10
    38f2:	b1 89       	ldd	r27, Z+17	; 0x11
    38f4:	ea 85       	ldd	r30, Y+10	; 0x0a
    38f6:	fb 85       	ldd	r31, Y+11	; 0x0b
    38f8:	86 85       	ldd	r24, Z+14	; 0x0e
    38fa:	97 85       	ldd	r25, Z+15	; 0x0f
    38fc:	13 96       	adiw	r26, 0x03	; 3
    38fe:	9c 93       	st	X, r25
    3900:	8e 93       	st	-X, r24
    3902:	12 97       	sbiw	r26, 0x02	; 2
    3904:	ef 81       	ldd	r30, Y+7	; 0x07
    3906:	f8 85       	ldd	r31, Y+8	; 0x08
    3908:	21 81       	ldd	r18, Z+1	; 0x01
    390a:	32 81       	ldd	r19, Z+2	; 0x02
    390c:	8a 85       	ldd	r24, Y+10	; 0x0a
    390e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3910:	0c 96       	adiw	r24, 0x0c	; 12
    3912:	28 17       	cp	r18, r24
    3914:	39 07       	cpc	r19, r25
    3916:	41 f4       	brne	.+16     	; 0x3928 <xTaskResumeAll+0xb0>
    3918:	ea 85       	ldd	r30, Y+10	; 0x0a
    391a:	fb 85       	ldd	r31, Y+11	; 0x0b
    391c:	80 89       	ldd	r24, Z+16	; 0x10
    391e:	91 89       	ldd	r25, Z+17	; 0x11
    3920:	ef 81       	ldd	r30, Y+7	; 0x07
    3922:	f8 85       	ldd	r31, Y+8	; 0x08
    3924:	92 83       	std	Z+2, r25	; 0x02
    3926:	81 83       	std	Z+1, r24	; 0x01
    3928:	ea 85       	ldd	r30, Y+10	; 0x0a
    392a:	fb 85       	ldd	r31, Y+11	; 0x0b
    392c:	15 8a       	std	Z+21, r1	; 0x15
    392e:	14 8a       	std	Z+20, r1	; 0x14
    3930:	ef 81       	ldd	r30, Y+7	; 0x07
    3932:	f8 85       	ldd	r31, Y+8	; 0x08
    3934:	80 81       	ld	r24, Z
    3936:	81 50       	subi	r24, 0x01	; 1
    3938:	ef 81       	ldd	r30, Y+7	; 0x07
    393a:	f8 85       	ldd	r31, Y+8	; 0x08
    393c:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    393e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3940:	fb 85       	ldd	r31, Y+11	; 0x0b
    3942:	82 85       	ldd	r24, Z+10	; 0x0a
    3944:	93 85       	ldd	r25, Z+11	; 0x0b
    3946:	9e 83       	std	Y+6, r25	; 0x06
    3948:	8d 83       	std	Y+5, r24	; 0x05
    394a:	ea 85       	ldd	r30, Y+10	; 0x0a
    394c:	fb 85       	ldd	r31, Y+11	; 0x0b
    394e:	a4 81       	ldd	r26, Z+4	; 0x04
    3950:	b5 81       	ldd	r27, Z+5	; 0x05
    3952:	ea 85       	ldd	r30, Y+10	; 0x0a
    3954:	fb 85       	ldd	r31, Y+11	; 0x0b
    3956:	86 81       	ldd	r24, Z+6	; 0x06
    3958:	97 81       	ldd	r25, Z+7	; 0x07
    395a:	15 96       	adiw	r26, 0x05	; 5
    395c:	9c 93       	st	X, r25
    395e:	8e 93       	st	-X, r24
    3960:	14 97       	sbiw	r26, 0x04	; 4
    3962:	ea 85       	ldd	r30, Y+10	; 0x0a
    3964:	fb 85       	ldd	r31, Y+11	; 0x0b
    3966:	a6 81       	ldd	r26, Z+6	; 0x06
    3968:	b7 81       	ldd	r27, Z+7	; 0x07
    396a:	ea 85       	ldd	r30, Y+10	; 0x0a
    396c:	fb 85       	ldd	r31, Y+11	; 0x0b
    396e:	84 81       	ldd	r24, Z+4	; 0x04
    3970:	95 81       	ldd	r25, Z+5	; 0x05
    3972:	13 96       	adiw	r26, 0x03	; 3
    3974:	9c 93       	st	X, r25
    3976:	8e 93       	st	-X, r24
    3978:	12 97       	sbiw	r26, 0x02	; 2
    397a:	ed 81       	ldd	r30, Y+5	; 0x05
    397c:	fe 81       	ldd	r31, Y+6	; 0x06
    397e:	21 81       	ldd	r18, Z+1	; 0x01
    3980:	32 81       	ldd	r19, Z+2	; 0x02
    3982:	8a 85       	ldd	r24, Y+10	; 0x0a
    3984:	9b 85       	ldd	r25, Y+11	; 0x0b
    3986:	02 96       	adiw	r24, 0x02	; 2
    3988:	28 17       	cp	r18, r24
    398a:	39 07       	cpc	r19, r25
    398c:	41 f4       	brne	.+16     	; 0x399e <xTaskResumeAll+0x126>
    398e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3990:	fb 85       	ldd	r31, Y+11	; 0x0b
    3992:	86 81       	ldd	r24, Z+6	; 0x06
    3994:	97 81       	ldd	r25, Z+7	; 0x07
    3996:	ed 81       	ldd	r30, Y+5	; 0x05
    3998:	fe 81       	ldd	r31, Y+6	; 0x06
    399a:	92 83       	std	Z+2, r25	; 0x02
    399c:	81 83       	std	Z+1, r24	; 0x01
    399e:	ea 85       	ldd	r30, Y+10	; 0x0a
    39a0:	fb 85       	ldd	r31, Y+11	; 0x0b
    39a2:	13 86       	std	Z+11, r1	; 0x0b
    39a4:	12 86       	std	Z+10, r1	; 0x0a
    39a6:	ed 81       	ldd	r30, Y+5	; 0x05
    39a8:	fe 81       	ldd	r31, Y+6	; 0x06
    39aa:	80 81       	ld	r24, Z
    39ac:	81 50       	subi	r24, 0x01	; 1
    39ae:	ed 81       	ldd	r30, Y+5	; 0x05
    39b0:	fe 81       	ldd	r31, Y+6	; 0x06
    39b2:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    39b4:	ea 85       	ldd	r30, Y+10	; 0x0a
    39b6:	fb 85       	ldd	r31, Y+11	; 0x0b
    39b8:	96 89       	ldd	r25, Z+22	; 0x16
    39ba:	80 91 d2 06 	lds	r24, 0x06D2
    39be:	89 17       	cp	r24, r25
    39c0:	28 f4       	brcc	.+10     	; 0x39cc <xTaskResumeAll+0x154>
    39c2:	ea 85       	ldd	r30, Y+10	; 0x0a
    39c4:	fb 85       	ldd	r31, Y+11	; 0x0b
    39c6:	86 89       	ldd	r24, Z+22	; 0x16
    39c8:	80 93 d2 06 	sts	0x06D2, r24
    39cc:	ea 85       	ldd	r30, Y+10	; 0x0a
    39ce:	fb 85       	ldd	r31, Y+11	; 0x0b
    39d0:	86 89       	ldd	r24, Z+22	; 0x16
    39d2:	28 2f       	mov	r18, r24
    39d4:	30 e0       	ldi	r19, 0x00	; 0
    39d6:	c9 01       	movw	r24, r18
    39d8:	88 0f       	add	r24, r24
    39da:	99 1f       	adc	r25, r25
    39dc:	88 0f       	add	r24, r24
    39de:	99 1f       	adc	r25, r25
    39e0:	88 0f       	add	r24, r24
    39e2:	99 1f       	adc	r25, r25
    39e4:	82 0f       	add	r24, r18
    39e6:	93 1f       	adc	r25, r19
    39e8:	fc 01       	movw	r30, r24
    39ea:	ea 51       	subi	r30, 0x1A	; 26
    39ec:	f9 4f       	sbci	r31, 0xF9	; 249
    39ee:	81 81       	ldd	r24, Z+1	; 0x01
    39f0:	92 81       	ldd	r25, Z+2	; 0x02
    39f2:	9c 83       	std	Y+4, r25	; 0x04
    39f4:	8b 83       	std	Y+3, r24	; 0x03
    39f6:	ea 85       	ldd	r30, Y+10	; 0x0a
    39f8:	fb 85       	ldd	r31, Y+11	; 0x0b
    39fa:	8b 81       	ldd	r24, Y+3	; 0x03
    39fc:	9c 81       	ldd	r25, Y+4	; 0x04
    39fe:	95 83       	std	Z+5, r25	; 0x05
    3a00:	84 83       	std	Z+4, r24	; 0x04
    3a02:	eb 81       	ldd	r30, Y+3	; 0x03
    3a04:	fc 81       	ldd	r31, Y+4	; 0x04
    3a06:	84 81       	ldd	r24, Z+4	; 0x04
    3a08:	95 81       	ldd	r25, Z+5	; 0x05
    3a0a:	ea 85       	ldd	r30, Y+10	; 0x0a
    3a0c:	fb 85       	ldd	r31, Y+11	; 0x0b
    3a0e:	97 83       	std	Z+7, r25	; 0x07
    3a10:	86 83       	std	Z+6, r24	; 0x06
    3a12:	eb 81       	ldd	r30, Y+3	; 0x03
    3a14:	fc 81       	ldd	r31, Y+4	; 0x04
    3a16:	04 80       	ldd	r0, Z+4	; 0x04
    3a18:	f5 81       	ldd	r31, Z+5	; 0x05
    3a1a:	e0 2d       	mov	r30, r0
    3a1c:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a1e:	9b 85       	ldd	r25, Y+11	; 0x0b
    3a20:	02 96       	adiw	r24, 0x02	; 2
    3a22:	93 83       	std	Z+3, r25	; 0x03
    3a24:	82 83       	std	Z+2, r24	; 0x02
    3a26:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a28:	9b 85       	ldd	r25, Y+11	; 0x0b
    3a2a:	02 96       	adiw	r24, 0x02	; 2
    3a2c:	eb 81       	ldd	r30, Y+3	; 0x03
    3a2e:	fc 81       	ldd	r31, Y+4	; 0x04
    3a30:	95 83       	std	Z+5, r25	; 0x05
    3a32:	84 83       	std	Z+4, r24	; 0x04
    3a34:	ea 85       	ldd	r30, Y+10	; 0x0a
    3a36:	fb 85       	ldd	r31, Y+11	; 0x0b
    3a38:	86 89       	ldd	r24, Z+22	; 0x16
    3a3a:	28 2f       	mov	r18, r24
    3a3c:	30 e0       	ldi	r19, 0x00	; 0
    3a3e:	c9 01       	movw	r24, r18
    3a40:	88 0f       	add	r24, r24
    3a42:	99 1f       	adc	r25, r25
    3a44:	88 0f       	add	r24, r24
    3a46:	99 1f       	adc	r25, r25
    3a48:	88 0f       	add	r24, r24
    3a4a:	99 1f       	adc	r25, r25
    3a4c:	82 0f       	add	r24, r18
    3a4e:	93 1f       	adc	r25, r19
    3a50:	8a 51       	subi	r24, 0x1A	; 26
    3a52:	99 4f       	sbci	r25, 0xF9	; 249
    3a54:	ea 85       	ldd	r30, Y+10	; 0x0a
    3a56:	fb 85       	ldd	r31, Y+11	; 0x0b
    3a58:	93 87       	std	Z+11, r25	; 0x0b
    3a5a:	82 87       	std	Z+10, r24	; 0x0a
    3a5c:	ea 85       	ldd	r30, Y+10	; 0x0a
    3a5e:	fb 85       	ldd	r31, Y+11	; 0x0b
    3a60:	86 89       	ldd	r24, Z+22	; 0x16
    3a62:	28 2f       	mov	r18, r24
    3a64:	30 e0       	ldi	r19, 0x00	; 0
    3a66:	c9 01       	movw	r24, r18
    3a68:	88 0f       	add	r24, r24
    3a6a:	99 1f       	adc	r25, r25
    3a6c:	88 0f       	add	r24, r24
    3a6e:	99 1f       	adc	r25, r25
    3a70:	88 0f       	add	r24, r24
    3a72:	99 1f       	adc	r25, r25
    3a74:	82 0f       	add	r24, r18
    3a76:	93 1f       	adc	r25, r19
    3a78:	fc 01       	movw	r30, r24
    3a7a:	ea 51       	subi	r30, 0x1A	; 26
    3a7c:	f9 4f       	sbci	r31, 0xF9	; 249
    3a7e:	80 81       	ld	r24, Z
    3a80:	8f 5f       	subi	r24, 0xFF	; 255
    3a82:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3a84:	ea 85       	ldd	r30, Y+10	; 0x0a
    3a86:	fb 85       	ldd	r31, Y+11	; 0x0b
    3a88:	96 89       	ldd	r25, Z+22	; 0x16
    3a8a:	e0 91 cc 06 	lds	r30, 0x06CC
    3a8e:	f0 91 cd 06 	lds	r31, 0x06CD
    3a92:	86 89       	ldd	r24, Z+22	; 0x16
    3a94:	98 17       	cp	r25, r24
    3a96:	18 f0       	brcs	.+6      	; 0x3a9e <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    3a98:	81 e0       	ldi	r24, 0x01	; 1
    3a9a:	80 93 d6 06 	sts	0x06D6, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3a9e:	80 91 20 07 	lds	r24, 0x0720
    3aa2:	88 23       	and	r24, r24
    3aa4:	09 f0       	breq	.+2      	; 0x3aa8 <xTaskResumeAll+0x230>
    3aa6:	08 cf       	rjmp	.-496    	; 0x38b8 <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    3aa8:	8a 85       	ldd	r24, Y+10	; 0x0a
    3aaa:	9b 85       	ldd	r25, Y+11	; 0x0b
    3aac:	00 97       	sbiw	r24, 0x00	; 0
    3aae:	11 f0       	breq	.+4      	; 0x3ab4 <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    3ab0:	0e 94 2e 27 	call	0x4e5c	; 0x4e5c <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    3ab4:	80 91 d4 06 	lds	r24, 0x06D4
    3ab8:	90 91 d5 06 	lds	r25, 0x06D5
    3abc:	9a 83       	std	Y+2, r25	; 0x02
    3abe:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    3ac0:	89 81       	ldd	r24, Y+1	; 0x01
    3ac2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ac4:	00 97       	sbiw	r24, 0x00	; 0
    3ac6:	a1 f0       	breq	.+40     	; 0x3af0 <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    3ac8:	0e 94 b9 1e 	call	0x3d72	; 0x3d72 <xTaskIncrementTick>
    3acc:	88 23       	and	r24, r24
    3ace:	19 f0       	breq	.+6      	; 0x3ad6 <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    3ad0:	81 e0       	ldi	r24, 0x01	; 1
    3ad2:	80 93 d6 06 	sts	0x06D6, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    3ad6:	89 81       	ldd	r24, Y+1	; 0x01
    3ad8:	9a 81       	ldd	r25, Y+2	; 0x02
    3ada:	01 97       	sbiw	r24, 0x01	; 1
    3adc:	9a 83       	std	Y+2, r25	; 0x02
    3ade:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    3ae0:	89 81       	ldd	r24, Y+1	; 0x01
    3ae2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ae4:	00 97       	sbiw	r24, 0x00	; 0
    3ae6:	81 f7       	brne	.-32     	; 0x3ac8 <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    3ae8:	10 92 d5 06 	sts	0x06D5, r1
    3aec:	10 92 d4 06 	sts	0x06D4, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    3af0:	80 91 d6 06 	lds	r24, 0x06D6
    3af4:	88 23       	and	r24, r24
    3af6:	21 f0       	breq	.+8      	; 0x3b00 <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    3af8:	81 e0       	ldi	r24, 0x01	; 1
    3afa:	89 87       	std	Y+9, r24	; 0x09
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    3afc:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    3b00:	0f 90       	pop	r0
    3b02:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    3b04:	89 85       	ldd	r24, Y+9	; 0x09
}
    3b06:	2b 96       	adiw	r28, 0x0b	; 11
    3b08:	0f b6       	in	r0, 0x3f	; 63
    3b0a:	f8 94       	cli
    3b0c:	de bf       	out	0x3e, r29	; 62
    3b0e:	0f be       	out	0x3f, r0	; 63
    3b10:	cd bf       	out	0x3d, r28	; 61
    3b12:	cf 91       	pop	r28
    3b14:	df 91       	pop	r29
    3b16:	08 95       	ret

00003b18 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3b18:	df 93       	push	r29
    3b1a:	cf 93       	push	r28
    3b1c:	00 d0       	rcall	.+0      	; 0x3b1e <xTaskGetTickCount+0x6>
    3b1e:	cd b7       	in	r28, 0x3d	; 61
    3b20:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    3b22:	0f b6       	in	r0, 0x3f	; 63
    3b24:	f8 94       	cli
    3b26:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    3b28:	80 91 d0 06 	lds	r24, 0x06D0
    3b2c:	90 91 d1 06 	lds	r25, 0x06D1
    3b30:	9a 83       	std	Y+2, r25	; 0x02
    3b32:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    3b34:	0f 90       	pop	r0
    3b36:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    3b38:	89 81       	ldd	r24, Y+1	; 0x01
    3b3a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3b3c:	0f 90       	pop	r0
    3b3e:	0f 90       	pop	r0
    3b40:	cf 91       	pop	r28
    3b42:	df 91       	pop	r29
    3b44:	08 95       	ret

00003b46 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3b46:	df 93       	push	r29
    3b48:	cf 93       	push	r28
    3b4a:	00 d0       	rcall	.+0      	; 0x3b4c <xTaskGetTickCountFromISR+0x6>
    3b4c:	0f 92       	push	r0
    3b4e:	cd b7       	in	r28, 0x3d	; 61
    3b50:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    3b52:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    3b54:	80 91 d0 06 	lds	r24, 0x06D0
    3b58:	90 91 d1 06 	lds	r25, 0x06D1
    3b5c:	9b 83       	std	Y+3, r25	; 0x03
    3b5e:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    3b60:	8a 81       	ldd	r24, Y+2	; 0x02
    3b62:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3b64:	0f 90       	pop	r0
    3b66:	0f 90       	pop	r0
    3b68:	0f 90       	pop	r0
    3b6a:	cf 91       	pop	r28
    3b6c:	df 91       	pop	r29
    3b6e:	08 95       	ret

00003b70 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3b70:	df 93       	push	r29
    3b72:	cf 93       	push	r28
    3b74:	cd b7       	in	r28, 0x3d	; 61
    3b76:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    3b78:	80 91 cf 06 	lds	r24, 0x06CF
}
    3b7c:	cf 91       	pop	r28
    3b7e:	df 91       	pop	r29
    3b80:	08 95       	ret

00003b82 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3b82:	df 93       	push	r29
    3b84:	cf 93       	push	r28
    3b86:	00 d0       	rcall	.+0      	; 0x3b88 <pcTaskGetName+0x6>
    3b88:	00 d0       	rcall	.+0      	; 0x3b8a <pcTaskGetName+0x8>
    3b8a:	00 d0       	rcall	.+0      	; 0x3b8c <pcTaskGetName+0xa>
    3b8c:	cd b7       	in	r28, 0x3d	; 61
    3b8e:	de b7       	in	r29, 0x3e	; 62
    3b90:	9c 83       	std	Y+4, r25	; 0x04
    3b92:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    3b94:	8b 81       	ldd	r24, Y+3	; 0x03
    3b96:	9c 81       	ldd	r25, Y+4	; 0x04
    3b98:	00 97       	sbiw	r24, 0x00	; 0
    3b9a:	39 f4       	brne	.+14     	; 0x3baa <pcTaskGetName+0x28>
    3b9c:	80 91 cc 06 	lds	r24, 0x06CC
    3ba0:	90 91 cd 06 	lds	r25, 0x06CD
    3ba4:	9e 83       	std	Y+6, r25	; 0x06
    3ba6:	8d 83       	std	Y+5, r24	; 0x05
    3ba8:	04 c0       	rjmp	.+8      	; 0x3bb2 <pcTaskGetName+0x30>
    3baa:	8b 81       	ldd	r24, Y+3	; 0x03
    3bac:	9c 81       	ldd	r25, Y+4	; 0x04
    3bae:	9e 83       	std	Y+6, r25	; 0x06
    3bb0:	8d 83       	std	Y+5, r24	; 0x05
    3bb2:	8d 81       	ldd	r24, Y+5	; 0x05
    3bb4:	9e 81       	ldd	r25, Y+6	; 0x06
    3bb6:	9a 83       	std	Y+2, r25	; 0x02
    3bb8:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    3bba:	89 81       	ldd	r24, Y+1	; 0x01
    3bbc:	9a 81       	ldd	r25, Y+2	; 0x02
    3bbe:	49 96       	adiw	r24, 0x19	; 25
}
    3bc0:	26 96       	adiw	r28, 0x06	; 6
    3bc2:	0f b6       	in	r0, 0x3f	; 63
    3bc4:	f8 94       	cli
    3bc6:	de bf       	out	0x3e, r29	; 62
    3bc8:	0f be       	out	0x3f, r0	; 63
    3bca:	cd bf       	out	0x3d, r28	; 61
    3bcc:	cf 91       	pop	r28
    3bce:	df 91       	pop	r29
    3bd0:	08 95       	ret

00003bd2 <uxTaskGetSystemState>:
#if ( configUSE_TRACE_FACILITY == 1 )

    UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray,
                                      const UBaseType_t uxArraySize,
                                      configRUN_TIME_COUNTER_TYPE * const pulTotalRunTime )
    {
    3bd2:	df 93       	push	r29
    3bd4:	cf 93       	push	r28
    3bd6:	cd b7       	in	r28, 0x3d	; 61
    3bd8:	de b7       	in	r29, 0x3e	; 62
    3bda:	27 97       	sbiw	r28, 0x07	; 7
    3bdc:	0f b6       	in	r0, 0x3f	; 63
    3bde:	f8 94       	cli
    3be0:	de bf       	out	0x3e, r29	; 62
    3be2:	0f be       	out	0x3f, r0	; 63
    3be4:	cd bf       	out	0x3d, r28	; 61
    3be6:	9c 83       	std	Y+4, r25	; 0x04
    3be8:	8b 83       	std	Y+3, r24	; 0x03
    3bea:	6d 83       	std	Y+5, r22	; 0x05
    3bec:	5f 83       	std	Y+7, r21	; 0x07
    3bee:	4e 83       	std	Y+6, r20	; 0x06
        UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
    3bf0:	1a 82       	std	Y+2, r1	; 0x02
    3bf2:	84 e0       	ldi	r24, 0x04	; 4
    3bf4:	89 83       	std	Y+1, r24	; 0x01

        vTaskSuspendAll();
    3bf6:	0e 94 30 1c 	call	0x3860	; 0x3860 <vTaskSuspendAll>
        {
            /* Is there a space in the array for each task in the system? */
            if( uxArraySize >= uxCurrentNumberOfTasks )
    3bfa:	90 91 cf 06 	lds	r25, 0x06CF
    3bfe:	8d 81       	ldd	r24, Y+5	; 0x05
    3c00:	89 17       	cp	r24, r25
    3c02:	08 f4       	brcc	.+2      	; 0x3c06 <uxTaskGetSystemState+0x34>
    3c04:	8a c0       	rjmp	.+276    	; 0x3d1a <uxTaskGetSystemState+0x148>
            {
                /* Fill in an TaskStatus_t structure with information on each
                 * task in the Ready state. */
                do
                {
                    uxQueue--;
    3c06:	89 81       	ldd	r24, Y+1	; 0x01
    3c08:	81 50       	subi	r24, 0x01	; 1
    3c0a:	89 83       	std	Y+1, r24	; 0x01
                    uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
    3c0c:	8a 81       	ldd	r24, Y+2	; 0x02
    3c0e:	88 2f       	mov	r24, r24
    3c10:	90 e0       	ldi	r25, 0x00	; 0
    3c12:	9c 01       	movw	r18, r24
    3c14:	22 95       	swap	r18
    3c16:	32 95       	swap	r19
    3c18:	30 7f       	andi	r19, 0xF0	; 240
    3c1a:	32 27       	eor	r19, r18
    3c1c:	20 7f       	andi	r18, 0xF0	; 240
    3c1e:	32 27       	eor	r19, r18
    3c20:	8b 81       	ldd	r24, Y+3	; 0x03
    3c22:	9c 81       	ldd	r25, Y+4	; 0x04
    3c24:	ac 01       	movw	r20, r24
    3c26:	42 0f       	add	r20, r18
    3c28:	53 1f       	adc	r21, r19
    3c2a:	89 81       	ldd	r24, Y+1	; 0x01
    3c2c:	28 2f       	mov	r18, r24
    3c2e:	30 e0       	ldi	r19, 0x00	; 0
    3c30:	c9 01       	movw	r24, r18
    3c32:	88 0f       	add	r24, r24
    3c34:	99 1f       	adc	r25, r25
    3c36:	88 0f       	add	r24, r24
    3c38:	99 1f       	adc	r25, r25
    3c3a:	88 0f       	add	r24, r24
    3c3c:	99 1f       	adc	r25, r25
    3c3e:	82 0f       	add	r24, r18
    3c40:	93 1f       	adc	r25, r19
    3c42:	9c 01       	movw	r18, r24
    3c44:	2a 51       	subi	r18, 0x1A	; 26
    3c46:	39 4f       	sbci	r19, 0xF9	; 249
    3c48:	ca 01       	movw	r24, r20
    3c4a:	b9 01       	movw	r22, r18
    3c4c:	41 e0       	ldi	r20, 0x01	; 1
    3c4e:	0e 94 50 26 	call	0x4ca0	; 0x4ca0 <prvListTasksWithinSingleList>
    3c52:	98 2f       	mov	r25, r24
    3c54:	8a 81       	ldd	r24, Y+2	; 0x02
    3c56:	89 0f       	add	r24, r25
    3c58:	8a 83       	std	Y+2, r24	; 0x02
                } while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3c5a:	89 81       	ldd	r24, Y+1	; 0x01
    3c5c:	88 23       	and	r24, r24
    3c5e:	99 f6       	brne	.-90     	; 0x3c06 <uxTaskGetSystemState+0x34>

                /* Fill in an TaskStatus_t structure with information on each
                 * task in the Blocked state. */
                uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
    3c60:	8a 81       	ldd	r24, Y+2	; 0x02
    3c62:	88 2f       	mov	r24, r24
    3c64:	90 e0       	ldi	r25, 0x00	; 0
    3c66:	9c 01       	movw	r18, r24
    3c68:	22 95       	swap	r18
    3c6a:	32 95       	swap	r19
    3c6c:	30 7f       	andi	r19, 0xF0	; 240
    3c6e:	32 27       	eor	r19, r18
    3c70:	20 7f       	andi	r18, 0xF0	; 240
    3c72:	32 27       	eor	r19, r18
    3c74:	8b 81       	ldd	r24, Y+3	; 0x03
    3c76:	9c 81       	ldd	r25, Y+4	; 0x04
    3c78:	82 0f       	add	r24, r18
    3c7a:	93 1f       	adc	r25, r19
    3c7c:	20 91 1c 07 	lds	r18, 0x071C
    3c80:	30 91 1d 07 	lds	r19, 0x071D
    3c84:	b9 01       	movw	r22, r18
    3c86:	42 e0       	ldi	r20, 0x02	; 2
    3c88:	0e 94 50 26 	call	0x4ca0	; 0x4ca0 <prvListTasksWithinSingleList>
    3c8c:	98 2f       	mov	r25, r24
    3c8e:	8a 81       	ldd	r24, Y+2	; 0x02
    3c90:	89 0f       	add	r24, r25
    3c92:	8a 83       	std	Y+2, r24	; 0x02
                uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
    3c94:	8a 81       	ldd	r24, Y+2	; 0x02
    3c96:	88 2f       	mov	r24, r24
    3c98:	90 e0       	ldi	r25, 0x00	; 0
    3c9a:	9c 01       	movw	r18, r24
    3c9c:	22 95       	swap	r18
    3c9e:	32 95       	swap	r19
    3ca0:	30 7f       	andi	r19, 0xF0	; 240
    3ca2:	32 27       	eor	r19, r18
    3ca4:	20 7f       	andi	r18, 0xF0	; 240
    3ca6:	32 27       	eor	r19, r18
    3ca8:	8b 81       	ldd	r24, Y+3	; 0x03
    3caa:	9c 81       	ldd	r25, Y+4	; 0x04
    3cac:	82 0f       	add	r24, r18
    3cae:	93 1f       	adc	r25, r19
    3cb0:	20 91 1e 07 	lds	r18, 0x071E
    3cb4:	30 91 1f 07 	lds	r19, 0x071F
    3cb8:	b9 01       	movw	r22, r18
    3cba:	42 e0       	ldi	r20, 0x02	; 2
    3cbc:	0e 94 50 26 	call	0x4ca0	; 0x4ca0 <prvListTasksWithinSingleList>
    3cc0:	98 2f       	mov	r25, r24
    3cc2:	8a 81       	ldd	r24, Y+2	; 0x02
    3cc4:	89 0f       	add	r24, r25
    3cc6:	8a 83       	std	Y+2, r24	; 0x02

                #if ( INCLUDE_vTaskDelete == 1 )
                    {
                        /* Fill in an TaskStatus_t structure with information on
                         * each task that has been deleted but not yet cleaned up. */
                        uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
    3cc8:	8a 81       	ldd	r24, Y+2	; 0x02
    3cca:	88 2f       	mov	r24, r24
    3ccc:	90 e0       	ldi	r25, 0x00	; 0
    3cce:	9c 01       	movw	r18, r24
    3cd0:	22 95       	swap	r18
    3cd2:	32 95       	swap	r19
    3cd4:	30 7f       	andi	r19, 0xF0	; 240
    3cd6:	32 27       	eor	r19, r18
    3cd8:	20 7f       	andi	r18, 0xF0	; 240
    3cda:	32 27       	eor	r19, r18
    3cdc:	8b 81       	ldd	r24, Y+3	; 0x03
    3cde:	9c 81       	ldd	r25, Y+4	; 0x04
    3ce0:	82 0f       	add	r24, r18
    3ce2:	93 1f       	adc	r25, r19
    3ce4:	29 e2       	ldi	r18, 0x29	; 41
    3ce6:	37 e0       	ldi	r19, 0x07	; 7
    3ce8:	b9 01       	movw	r22, r18
    3cea:	44 e0       	ldi	r20, 0x04	; 4
    3cec:	0e 94 50 26 	call	0x4ca0	; 0x4ca0 <prvListTasksWithinSingleList>
    3cf0:	98 2f       	mov	r25, r24
    3cf2:	8a 81       	ldd	r24, Y+2	; 0x02
    3cf4:	89 0f       	add	r24, r25
    3cf6:	8a 83       	std	Y+2, r24	; 0x02
                    }
                #endif

                #if ( configGENERATE_RUN_TIME_STATS == 1 )
                    {
                        if( pulTotalRunTime != NULL )
    3cf8:	8e 81       	ldd	r24, Y+6	; 0x06
    3cfa:	9f 81       	ldd	r25, Y+7	; 0x07
    3cfc:	00 97       	sbiw	r24, 0x00	; 0
    3cfe:	69 f0       	breq	.+26     	; 0x3d1a <uxTaskGetSystemState+0x148>
                        {
                            #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
                                portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
                            #else
                                *pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
    3d00:	e2 e5       	ldi	r30, 0x52	; 82
    3d02:	f0 e0       	ldi	r31, 0x00	; 0
    3d04:	80 81       	ld	r24, Z
    3d06:	88 2f       	mov	r24, r24
    3d08:	90 e0       	ldi	r25, 0x00	; 0
    3d0a:	a0 e0       	ldi	r26, 0x00	; 0
    3d0c:	b0 e0       	ldi	r27, 0x00	; 0
    3d0e:	ee 81       	ldd	r30, Y+6	; 0x06
    3d10:	ff 81       	ldd	r31, Y+7	; 0x07
    3d12:	80 83       	st	Z, r24
    3d14:	91 83       	std	Z+1, r25	; 0x01
    3d16:	a2 83       	std	Z+2, r26	; 0x02
    3d18:	b3 83       	std	Z+3, r27	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        ( void ) xTaskResumeAll();
    3d1a:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>

        return uxTask;
    3d1e:	8a 81       	ldd	r24, Y+2	; 0x02
    }
    3d20:	27 96       	adiw	r28, 0x07	; 7
    3d22:	0f b6       	in	r0, 0x3f	; 63
    3d24:	f8 94       	cli
    3d26:	de bf       	out	0x3e, r29	; 62
    3d28:	0f be       	out	0x3f, r0	; 63
    3d2a:	cd bf       	out	0x3d, r28	; 61
    3d2c:	cf 91       	pop	r28
    3d2e:	df 91       	pop	r29
    3d30:	08 95       	ret

00003d32 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    3d32:	df 93       	push	r29
    3d34:	cf 93       	push	r28
    3d36:	00 d0       	rcall	.+0      	; 0x3d38 <xTaskCatchUpTicks+0x6>
    3d38:	0f 92       	push	r0
    3d3a:	cd b7       	in	r28, 0x3d	; 61
    3d3c:	de b7       	in	r29, 0x3e	; 62
    3d3e:	9b 83       	std	Y+3, r25	; 0x03
    3d40:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    3d42:	0e 94 30 1c 	call	0x3860	; 0x3860 <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
    3d46:	20 91 d4 06 	lds	r18, 0x06D4
    3d4a:	30 91 d5 06 	lds	r19, 0x06D5
    3d4e:	8a 81       	ldd	r24, Y+2	; 0x02
    3d50:	9b 81       	ldd	r25, Y+3	; 0x03
    3d52:	82 0f       	add	r24, r18
    3d54:	93 1f       	adc	r25, r19
    3d56:	90 93 d5 06 	sts	0x06D5, r25
    3d5a:	80 93 d4 06 	sts	0x06D4, r24
    xYieldOccurred = xTaskResumeAll();
    3d5e:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>
    3d62:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    3d64:	89 81       	ldd	r24, Y+1	; 0x01
}
    3d66:	0f 90       	pop	r0
    3d68:	0f 90       	pop	r0
    3d6a:	0f 90       	pop	r0
    3d6c:	cf 91       	pop	r28
    3d6e:	df 91       	pop	r29
    3d70:	08 95       	ret

00003d72 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3d72:	df 93       	push	r29
    3d74:	cf 93       	push	r28
    3d76:	cd b7       	in	r28, 0x3d	; 61
    3d78:	de b7       	in	r29, 0x3e	; 62
    3d7a:	2f 97       	sbiw	r28, 0x0f	; 15
    3d7c:	0f b6       	in	r0, 0x3f	; 63
    3d7e:	f8 94       	cli
    3d80:	de bf       	out	0x3e, r29	; 62
    3d82:	0f be       	out	0x3f, r0	; 63
    3d84:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    3d86:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3d88:	80 91 dd 06 	lds	r24, 0x06DD
    3d8c:	88 23       	and	r24, r24
    3d8e:	09 f0       	breq	.+2      	; 0x3d92 <xTaskIncrementTick+0x20>
    3d90:	74 c1       	rjmp	.+744    	; 0x407a <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    3d92:	80 91 d0 06 	lds	r24, 0x06D0
    3d96:	90 91 d1 06 	lds	r25, 0x06D1
    3d9a:	01 96       	adiw	r24, 0x01	; 1
    3d9c:	9a 87       	std	Y+10, r25	; 0x0a
    3d9e:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    3da0:	89 85       	ldd	r24, Y+9	; 0x09
    3da2:	9a 85       	ldd	r25, Y+10	; 0x0a
    3da4:	90 93 d1 06 	sts	0x06D1, r25
    3da8:	80 93 d0 06 	sts	0x06D0, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    3dac:	89 85       	ldd	r24, Y+9	; 0x09
    3dae:	9a 85       	ldd	r25, Y+10	; 0x0a
    3db0:	00 97       	sbiw	r24, 0x00	; 0
    3db2:	d9 f4       	brne	.+54     	; 0x3dea <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    3db4:	80 91 1c 07 	lds	r24, 0x071C
    3db8:	90 91 1d 07 	lds	r25, 0x071D
    3dbc:	98 87       	std	Y+8, r25	; 0x08
    3dbe:	8f 83       	std	Y+7, r24	; 0x07
    3dc0:	80 91 1e 07 	lds	r24, 0x071E
    3dc4:	90 91 1f 07 	lds	r25, 0x071F
    3dc8:	90 93 1d 07 	sts	0x071D, r25
    3dcc:	80 93 1c 07 	sts	0x071C, r24
    3dd0:	8f 81       	ldd	r24, Y+7	; 0x07
    3dd2:	98 85       	ldd	r25, Y+8	; 0x08
    3dd4:	90 93 1f 07 	sts	0x071F, r25
    3dd8:	80 93 1e 07 	sts	0x071E, r24
    3ddc:	80 91 d7 06 	lds	r24, 0x06D7
    3de0:	8f 5f       	subi	r24, 0xFF	; 255
    3de2:	80 93 d7 06 	sts	0x06D7, r24
    3de6:	0e 94 2e 27 	call	0x4e5c	; 0x4e5c <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    3dea:	20 91 d9 06 	lds	r18, 0x06D9
    3dee:	30 91 da 06 	lds	r19, 0x06DA
    3df2:	89 85       	ldd	r24, Y+9	; 0x09
    3df4:	9a 85       	ldd	r25, Y+10	; 0x0a
    3df6:	82 17       	cp	r24, r18
    3df8:	93 07       	cpc	r25, r19
    3dfa:	08 f4       	brcc	.+2      	; 0x3dfe <xTaskIncrementTick+0x8c>
    3dfc:	1f c1       	rjmp	.+574    	; 0x403c <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3dfe:	e0 91 1c 07 	lds	r30, 0x071C
    3e02:	f0 91 1d 07 	lds	r31, 0x071D
    3e06:	80 81       	ld	r24, Z
    3e08:	88 23       	and	r24, r24
    3e0a:	39 f4       	brne	.+14     	; 0x3e1a <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3e0c:	8f ef       	ldi	r24, 0xFF	; 255
    3e0e:	9f ef       	ldi	r25, 0xFF	; 255
    3e10:	90 93 da 06 	sts	0x06DA, r25
    3e14:	80 93 d9 06 	sts	0x06D9, r24
    3e18:	11 c1       	rjmp	.+546    	; 0x403c <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3e1a:	e0 91 1c 07 	lds	r30, 0x071C
    3e1e:	f0 91 1d 07 	lds	r31, 0x071D
    3e22:	05 80       	ldd	r0, Z+5	; 0x05
    3e24:	f6 81       	ldd	r31, Z+6	; 0x06
    3e26:	e0 2d       	mov	r30, r0
    3e28:	86 81       	ldd	r24, Z+6	; 0x06
    3e2a:	97 81       	ldd	r25, Z+7	; 0x07
    3e2c:	9f 87       	std	Y+15, r25	; 0x0f
    3e2e:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    3e30:	ee 85       	ldd	r30, Y+14	; 0x0e
    3e32:	ff 85       	ldd	r31, Y+15	; 0x0f
    3e34:	82 81       	ldd	r24, Z+2	; 0x02
    3e36:	93 81       	ldd	r25, Z+3	; 0x03
    3e38:	9d 87       	std	Y+13, r25	; 0x0d
    3e3a:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    3e3c:	29 85       	ldd	r18, Y+9	; 0x09
    3e3e:	3a 85       	ldd	r19, Y+10	; 0x0a
    3e40:	8c 85       	ldd	r24, Y+12	; 0x0c
    3e42:	9d 85       	ldd	r25, Y+13	; 0x0d
    3e44:	28 17       	cp	r18, r24
    3e46:	39 07       	cpc	r19, r25
    3e48:	38 f4       	brcc	.+14     	; 0x3e58 <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    3e4a:	8c 85       	ldd	r24, Y+12	; 0x0c
    3e4c:	9d 85       	ldd	r25, Y+13	; 0x0d
    3e4e:	90 93 da 06 	sts	0x06DA, r25
    3e52:	80 93 d9 06 	sts	0x06D9, r24
    3e56:	f2 c0       	rjmp	.+484    	; 0x403c <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3e58:	ee 85       	ldd	r30, Y+14	; 0x0e
    3e5a:	ff 85       	ldd	r31, Y+15	; 0x0f
    3e5c:	82 85       	ldd	r24, Z+10	; 0x0a
    3e5e:	93 85       	ldd	r25, Z+11	; 0x0b
    3e60:	9e 83       	std	Y+6, r25	; 0x06
    3e62:	8d 83       	std	Y+5, r24	; 0x05
    3e64:	ee 85       	ldd	r30, Y+14	; 0x0e
    3e66:	ff 85       	ldd	r31, Y+15	; 0x0f
    3e68:	a4 81       	ldd	r26, Z+4	; 0x04
    3e6a:	b5 81       	ldd	r27, Z+5	; 0x05
    3e6c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3e6e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3e70:	86 81       	ldd	r24, Z+6	; 0x06
    3e72:	97 81       	ldd	r25, Z+7	; 0x07
    3e74:	15 96       	adiw	r26, 0x05	; 5
    3e76:	9c 93       	st	X, r25
    3e78:	8e 93       	st	-X, r24
    3e7a:	14 97       	sbiw	r26, 0x04	; 4
    3e7c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3e7e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3e80:	a6 81       	ldd	r26, Z+6	; 0x06
    3e82:	b7 81       	ldd	r27, Z+7	; 0x07
    3e84:	ee 85       	ldd	r30, Y+14	; 0x0e
    3e86:	ff 85       	ldd	r31, Y+15	; 0x0f
    3e88:	84 81       	ldd	r24, Z+4	; 0x04
    3e8a:	95 81       	ldd	r25, Z+5	; 0x05
    3e8c:	13 96       	adiw	r26, 0x03	; 3
    3e8e:	9c 93       	st	X, r25
    3e90:	8e 93       	st	-X, r24
    3e92:	12 97       	sbiw	r26, 0x02	; 2
    3e94:	ed 81       	ldd	r30, Y+5	; 0x05
    3e96:	fe 81       	ldd	r31, Y+6	; 0x06
    3e98:	21 81       	ldd	r18, Z+1	; 0x01
    3e9a:	32 81       	ldd	r19, Z+2	; 0x02
    3e9c:	8e 85       	ldd	r24, Y+14	; 0x0e
    3e9e:	9f 85       	ldd	r25, Y+15	; 0x0f
    3ea0:	02 96       	adiw	r24, 0x02	; 2
    3ea2:	28 17       	cp	r18, r24
    3ea4:	39 07       	cpc	r19, r25
    3ea6:	41 f4       	brne	.+16     	; 0x3eb8 <xTaskIncrementTick+0x146>
    3ea8:	ee 85       	ldd	r30, Y+14	; 0x0e
    3eaa:	ff 85       	ldd	r31, Y+15	; 0x0f
    3eac:	86 81       	ldd	r24, Z+6	; 0x06
    3eae:	97 81       	ldd	r25, Z+7	; 0x07
    3eb0:	ed 81       	ldd	r30, Y+5	; 0x05
    3eb2:	fe 81       	ldd	r31, Y+6	; 0x06
    3eb4:	92 83       	std	Z+2, r25	; 0x02
    3eb6:	81 83       	std	Z+1, r24	; 0x01
    3eb8:	ee 85       	ldd	r30, Y+14	; 0x0e
    3eba:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ebc:	13 86       	std	Z+11, r1	; 0x0b
    3ebe:	12 86       	std	Z+10, r1	; 0x0a
    3ec0:	ed 81       	ldd	r30, Y+5	; 0x05
    3ec2:	fe 81       	ldd	r31, Y+6	; 0x06
    3ec4:	80 81       	ld	r24, Z
    3ec6:	81 50       	subi	r24, 0x01	; 1
    3ec8:	ed 81       	ldd	r30, Y+5	; 0x05
    3eca:	fe 81       	ldd	r31, Y+6	; 0x06
    3ecc:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3ece:	ee 85       	ldd	r30, Y+14	; 0x0e
    3ed0:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ed2:	84 89       	ldd	r24, Z+20	; 0x14
    3ed4:	95 89       	ldd	r25, Z+21	; 0x15
    3ed6:	00 97       	sbiw	r24, 0x00	; 0
    3ed8:	d9 f1       	breq	.+118    	; 0x3f50 <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3eda:	ee 85       	ldd	r30, Y+14	; 0x0e
    3edc:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ede:	84 89       	ldd	r24, Z+20	; 0x14
    3ee0:	95 89       	ldd	r25, Z+21	; 0x15
    3ee2:	9c 83       	std	Y+4, r25	; 0x04
    3ee4:	8b 83       	std	Y+3, r24	; 0x03
    3ee6:	ee 85       	ldd	r30, Y+14	; 0x0e
    3ee8:	ff 85       	ldd	r31, Y+15	; 0x0f
    3eea:	a6 85       	ldd	r26, Z+14	; 0x0e
    3eec:	b7 85       	ldd	r27, Z+15	; 0x0f
    3eee:	ee 85       	ldd	r30, Y+14	; 0x0e
    3ef0:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ef2:	80 89       	ldd	r24, Z+16	; 0x10
    3ef4:	91 89       	ldd	r25, Z+17	; 0x11
    3ef6:	15 96       	adiw	r26, 0x05	; 5
    3ef8:	9c 93       	st	X, r25
    3efa:	8e 93       	st	-X, r24
    3efc:	14 97       	sbiw	r26, 0x04	; 4
    3efe:	ee 85       	ldd	r30, Y+14	; 0x0e
    3f00:	ff 85       	ldd	r31, Y+15	; 0x0f
    3f02:	a0 89       	ldd	r26, Z+16	; 0x10
    3f04:	b1 89       	ldd	r27, Z+17	; 0x11
    3f06:	ee 85       	ldd	r30, Y+14	; 0x0e
    3f08:	ff 85       	ldd	r31, Y+15	; 0x0f
    3f0a:	86 85       	ldd	r24, Z+14	; 0x0e
    3f0c:	97 85       	ldd	r25, Z+15	; 0x0f
    3f0e:	13 96       	adiw	r26, 0x03	; 3
    3f10:	9c 93       	st	X, r25
    3f12:	8e 93       	st	-X, r24
    3f14:	12 97       	sbiw	r26, 0x02	; 2
    3f16:	eb 81       	ldd	r30, Y+3	; 0x03
    3f18:	fc 81       	ldd	r31, Y+4	; 0x04
    3f1a:	21 81       	ldd	r18, Z+1	; 0x01
    3f1c:	32 81       	ldd	r19, Z+2	; 0x02
    3f1e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3f20:	9f 85       	ldd	r25, Y+15	; 0x0f
    3f22:	0c 96       	adiw	r24, 0x0c	; 12
    3f24:	28 17       	cp	r18, r24
    3f26:	39 07       	cpc	r19, r25
    3f28:	41 f4       	brne	.+16     	; 0x3f3a <xTaskIncrementTick+0x1c8>
    3f2a:	ee 85       	ldd	r30, Y+14	; 0x0e
    3f2c:	ff 85       	ldd	r31, Y+15	; 0x0f
    3f2e:	80 89       	ldd	r24, Z+16	; 0x10
    3f30:	91 89       	ldd	r25, Z+17	; 0x11
    3f32:	eb 81       	ldd	r30, Y+3	; 0x03
    3f34:	fc 81       	ldd	r31, Y+4	; 0x04
    3f36:	92 83       	std	Z+2, r25	; 0x02
    3f38:	81 83       	std	Z+1, r24	; 0x01
    3f3a:	ee 85       	ldd	r30, Y+14	; 0x0e
    3f3c:	ff 85       	ldd	r31, Y+15	; 0x0f
    3f3e:	15 8a       	std	Z+21, r1	; 0x15
    3f40:	14 8a       	std	Z+20, r1	; 0x14
    3f42:	eb 81       	ldd	r30, Y+3	; 0x03
    3f44:	fc 81       	ldd	r31, Y+4	; 0x04
    3f46:	80 81       	ld	r24, Z
    3f48:	81 50       	subi	r24, 0x01	; 1
    3f4a:	eb 81       	ldd	r30, Y+3	; 0x03
    3f4c:	fc 81       	ldd	r31, Y+4	; 0x04
    3f4e:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    3f50:	ee 85       	ldd	r30, Y+14	; 0x0e
    3f52:	ff 85       	ldd	r31, Y+15	; 0x0f
    3f54:	96 89       	ldd	r25, Z+22	; 0x16
    3f56:	80 91 d2 06 	lds	r24, 0x06D2
    3f5a:	89 17       	cp	r24, r25
    3f5c:	28 f4       	brcc	.+10     	; 0x3f68 <xTaskIncrementTick+0x1f6>
    3f5e:	ee 85       	ldd	r30, Y+14	; 0x0e
    3f60:	ff 85       	ldd	r31, Y+15	; 0x0f
    3f62:	86 89       	ldd	r24, Z+22	; 0x16
    3f64:	80 93 d2 06 	sts	0x06D2, r24
    3f68:	ee 85       	ldd	r30, Y+14	; 0x0e
    3f6a:	ff 85       	ldd	r31, Y+15	; 0x0f
    3f6c:	86 89       	ldd	r24, Z+22	; 0x16
    3f6e:	28 2f       	mov	r18, r24
    3f70:	30 e0       	ldi	r19, 0x00	; 0
    3f72:	c9 01       	movw	r24, r18
    3f74:	88 0f       	add	r24, r24
    3f76:	99 1f       	adc	r25, r25
    3f78:	88 0f       	add	r24, r24
    3f7a:	99 1f       	adc	r25, r25
    3f7c:	88 0f       	add	r24, r24
    3f7e:	99 1f       	adc	r25, r25
    3f80:	82 0f       	add	r24, r18
    3f82:	93 1f       	adc	r25, r19
    3f84:	fc 01       	movw	r30, r24
    3f86:	ea 51       	subi	r30, 0x1A	; 26
    3f88:	f9 4f       	sbci	r31, 0xF9	; 249
    3f8a:	81 81       	ldd	r24, Z+1	; 0x01
    3f8c:	92 81       	ldd	r25, Z+2	; 0x02
    3f8e:	9a 83       	std	Y+2, r25	; 0x02
    3f90:	89 83       	std	Y+1, r24	; 0x01
    3f92:	ee 85       	ldd	r30, Y+14	; 0x0e
    3f94:	ff 85       	ldd	r31, Y+15	; 0x0f
    3f96:	89 81       	ldd	r24, Y+1	; 0x01
    3f98:	9a 81       	ldd	r25, Y+2	; 0x02
    3f9a:	95 83       	std	Z+5, r25	; 0x05
    3f9c:	84 83       	std	Z+4, r24	; 0x04
    3f9e:	e9 81       	ldd	r30, Y+1	; 0x01
    3fa0:	fa 81       	ldd	r31, Y+2	; 0x02
    3fa2:	84 81       	ldd	r24, Z+4	; 0x04
    3fa4:	95 81       	ldd	r25, Z+5	; 0x05
    3fa6:	ee 85       	ldd	r30, Y+14	; 0x0e
    3fa8:	ff 85       	ldd	r31, Y+15	; 0x0f
    3faa:	97 83       	std	Z+7, r25	; 0x07
    3fac:	86 83       	std	Z+6, r24	; 0x06
    3fae:	e9 81       	ldd	r30, Y+1	; 0x01
    3fb0:	fa 81       	ldd	r31, Y+2	; 0x02
    3fb2:	04 80       	ldd	r0, Z+4	; 0x04
    3fb4:	f5 81       	ldd	r31, Z+5	; 0x05
    3fb6:	e0 2d       	mov	r30, r0
    3fb8:	8e 85       	ldd	r24, Y+14	; 0x0e
    3fba:	9f 85       	ldd	r25, Y+15	; 0x0f
    3fbc:	02 96       	adiw	r24, 0x02	; 2
    3fbe:	93 83       	std	Z+3, r25	; 0x03
    3fc0:	82 83       	std	Z+2, r24	; 0x02
    3fc2:	8e 85       	ldd	r24, Y+14	; 0x0e
    3fc4:	9f 85       	ldd	r25, Y+15	; 0x0f
    3fc6:	02 96       	adiw	r24, 0x02	; 2
    3fc8:	e9 81       	ldd	r30, Y+1	; 0x01
    3fca:	fa 81       	ldd	r31, Y+2	; 0x02
    3fcc:	95 83       	std	Z+5, r25	; 0x05
    3fce:	84 83       	std	Z+4, r24	; 0x04
    3fd0:	ee 85       	ldd	r30, Y+14	; 0x0e
    3fd2:	ff 85       	ldd	r31, Y+15	; 0x0f
    3fd4:	86 89       	ldd	r24, Z+22	; 0x16
    3fd6:	28 2f       	mov	r18, r24
    3fd8:	30 e0       	ldi	r19, 0x00	; 0
    3fda:	c9 01       	movw	r24, r18
    3fdc:	88 0f       	add	r24, r24
    3fde:	99 1f       	adc	r25, r25
    3fe0:	88 0f       	add	r24, r24
    3fe2:	99 1f       	adc	r25, r25
    3fe4:	88 0f       	add	r24, r24
    3fe6:	99 1f       	adc	r25, r25
    3fe8:	82 0f       	add	r24, r18
    3fea:	93 1f       	adc	r25, r19
    3fec:	8a 51       	subi	r24, 0x1A	; 26
    3fee:	99 4f       	sbci	r25, 0xF9	; 249
    3ff0:	ee 85       	ldd	r30, Y+14	; 0x0e
    3ff2:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ff4:	93 87       	std	Z+11, r25	; 0x0b
    3ff6:	82 87       	std	Z+10, r24	; 0x0a
    3ff8:	ee 85       	ldd	r30, Y+14	; 0x0e
    3ffa:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ffc:	86 89       	ldd	r24, Z+22	; 0x16
    3ffe:	28 2f       	mov	r18, r24
    4000:	30 e0       	ldi	r19, 0x00	; 0
    4002:	c9 01       	movw	r24, r18
    4004:	88 0f       	add	r24, r24
    4006:	99 1f       	adc	r25, r25
    4008:	88 0f       	add	r24, r24
    400a:	99 1f       	adc	r25, r25
    400c:	88 0f       	add	r24, r24
    400e:	99 1f       	adc	r25, r25
    4010:	82 0f       	add	r24, r18
    4012:	93 1f       	adc	r25, r19
    4014:	fc 01       	movw	r30, r24
    4016:	ea 51       	subi	r30, 0x1A	; 26
    4018:	f9 4f       	sbci	r31, 0xF9	; 249
    401a:	80 81       	ld	r24, Z
    401c:	8f 5f       	subi	r24, 0xFF	; 255
    401e:	80 83       	st	Z, r24
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4020:	ee 85       	ldd	r30, Y+14	; 0x0e
    4022:	ff 85       	ldd	r31, Y+15	; 0x0f
    4024:	96 89       	ldd	r25, Z+22	; 0x16
    4026:	e0 91 cc 06 	lds	r30, 0x06CC
    402a:	f0 91 cd 06 	lds	r31, 0x06CD
    402e:	86 89       	ldd	r24, Z+22	; 0x16
    4030:	98 17       	cp	r25, r24
    4032:	08 f4       	brcc	.+2      	; 0x4036 <xTaskIncrementTick+0x2c4>
    4034:	e4 ce       	rjmp	.-568    	; 0x3dfe <xTaskIncrementTick+0x8c>
                            {
                                xSwitchRequired = pdTRUE;
    4036:	81 e0       	ldi	r24, 0x01	; 1
    4038:	8b 87       	std	Y+11, r24	; 0x0b
    403a:	e1 ce       	rjmp	.-574    	; 0x3dfe <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    403c:	e0 91 cc 06 	lds	r30, 0x06CC
    4040:	f0 91 cd 06 	lds	r31, 0x06CD
    4044:	86 89       	ldd	r24, Z+22	; 0x16
    4046:	28 2f       	mov	r18, r24
    4048:	30 e0       	ldi	r19, 0x00	; 0
    404a:	c9 01       	movw	r24, r18
    404c:	88 0f       	add	r24, r24
    404e:	99 1f       	adc	r25, r25
    4050:	88 0f       	add	r24, r24
    4052:	99 1f       	adc	r25, r25
    4054:	88 0f       	add	r24, r24
    4056:	99 1f       	adc	r25, r25
    4058:	82 0f       	add	r24, r18
    405a:	93 1f       	adc	r25, r19
    405c:	fc 01       	movw	r30, r24
    405e:	ea 51       	subi	r30, 0x1A	; 26
    4060:	f9 4f       	sbci	r31, 0xF9	; 249
    4062:	80 81       	ld	r24, Z
    4064:	82 30       	cpi	r24, 0x02	; 2
    4066:	10 f0       	brcs	.+4      	; 0x406c <xTaskIncrementTick+0x2fa>
                {
                    xSwitchRequired = pdTRUE;
    4068:	81 e0       	ldi	r24, 0x01	; 1
    406a:	8b 87       	std	Y+11, r24	; 0x0b
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    406c:	80 91 d6 06 	lds	r24, 0x06D6
    4070:	88 23       	and	r24, r24
    4072:	61 f0       	breq	.+24     	; 0x408c <xTaskIncrementTick+0x31a>
                {
                    xSwitchRequired = pdTRUE;
    4074:	81 e0       	ldi	r24, 0x01	; 1
    4076:	8b 87       	std	Y+11, r24	; 0x0b
    4078:	09 c0       	rjmp	.+18     	; 0x408c <xTaskIncrementTick+0x31a>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    407a:	80 91 d4 06 	lds	r24, 0x06D4
    407e:	90 91 d5 06 	lds	r25, 0x06D5
    4082:	01 96       	adiw	r24, 0x01	; 1
    4084:	90 93 d5 06 	sts	0x06D5, r25
    4088:	80 93 d4 06 	sts	0x06D4, r24
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
    408c:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    408e:	2f 96       	adiw	r28, 0x0f	; 15
    4090:	0f b6       	in	r0, 0x3f	; 63
    4092:	f8 94       	cli
    4094:	de bf       	out	0x3e, r29	; 62
    4096:	0f be       	out	0x3f, r0	; 63
    4098:	cd bf       	out	0x3d, r28	; 61
    409a:	cf 91       	pop	r28
    409c:	df 91       	pop	r29
    409e:	08 95       	ret

000040a0 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    40a0:	af 92       	push	r10
    40a2:	bf 92       	push	r11
    40a4:	cf 92       	push	r12
    40a6:	df 92       	push	r13
    40a8:	ef 92       	push	r14
    40aa:	ff 92       	push	r15
    40ac:	0f 93       	push	r16
    40ae:	1f 93       	push	r17
    40b0:	df 93       	push	r29
    40b2:	cf 93       	push	r28
    40b4:	00 d0       	rcall	.+0      	; 0x40b6 <vTaskSwitchContext+0x16>
    40b6:	0f 92       	push	r0
    40b8:	cd b7       	in	r28, 0x3d	; 61
    40ba:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    40bc:	80 91 dd 06 	lds	r24, 0x06DD
    40c0:	88 23       	and	r24, r24
    40c2:	21 f0       	breq	.+8      	; 0x40cc <vTaskSwitchContext+0x2c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    40c4:	81 e0       	ldi	r24, 0x01	; 1
    40c6:	80 93 d6 06 	sts	0x06D6, r24
    40ca:	b5 c0       	rjmp	.+362    	; 0x4236 <vTaskSwitchContext+0x196>
    }
    else
    {
        xYieldPending = pdFALSE;
    40cc:	10 92 d6 06 	sts	0x06D6, r1
        #if ( configGENERATE_RUN_TIME_STATS == 1 )
            {
                #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
                    portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
                #else
                    ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
    40d0:	e2 e5       	ldi	r30, 0x52	; 82
    40d2:	f0 e0       	ldi	r31, 0x00	; 0
    40d4:	80 81       	ld	r24, Z
    40d6:	88 2f       	mov	r24, r24
    40d8:	90 e0       	ldi	r25, 0x00	; 0
    40da:	a0 e0       	ldi	r26, 0x00	; 0
    40dc:	b0 e0       	ldi	r27, 0x00	; 0
    40de:	80 93 e2 06 	sts	0x06E2, r24
    40e2:	90 93 e3 06 	sts	0x06E3, r25
    40e6:	a0 93 e4 06 	sts	0x06E4, r26
    40ea:	b0 93 e5 06 	sts	0x06E5, r27
                 * stored in ulTaskSwitchedInTime.  Note that there is no overflow
                 * protection here so count values are only valid until the timer
                 * overflows.  The guard against negative values is to protect
                 * against suspect run time stat counter implementations - which
                 * are provided by the application, not the kernel. */
                if( ulTotalRunTime > ulTaskSwitchedInTime )
    40ee:	20 91 e2 06 	lds	r18, 0x06E2
    40f2:	30 91 e3 06 	lds	r19, 0x06E3
    40f6:	40 91 e4 06 	lds	r20, 0x06E4
    40fa:	50 91 e5 06 	lds	r21, 0x06E5
    40fe:	80 91 de 06 	lds	r24, 0x06DE
    4102:	90 91 df 06 	lds	r25, 0x06DF
    4106:	a0 91 e0 06 	lds	r26, 0x06E0
    410a:	b0 91 e1 06 	lds	r27, 0x06E1
    410e:	82 17       	cp	r24, r18
    4110:	93 07       	cpc	r25, r19
    4112:	a4 07       	cpc	r26, r20
    4114:	b5 07       	cpc	r27, r21
    4116:	40 f5       	brcc	.+80     	; 0x4168 <vTaskSwitchContext+0xc8>
                {
                    pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
    4118:	e0 91 cc 06 	lds	r30, 0x06CC
    411c:	f0 91 cd 06 	lds	r31, 0x06CD
    4120:	e3 a0       	ldd	r14, Z+35	; 0x23
    4122:	f4 a0       	ldd	r15, Z+36	; 0x24
    4124:	05 a1       	ldd	r16, Z+37	; 0x25
    4126:	16 a1       	ldd	r17, Z+38	; 0x26
    4128:	20 91 e2 06 	lds	r18, 0x06E2
    412c:	30 91 e3 06 	lds	r19, 0x06E3
    4130:	40 91 e4 06 	lds	r20, 0x06E4
    4134:	50 91 e5 06 	lds	r21, 0x06E5
    4138:	80 91 de 06 	lds	r24, 0x06DE
    413c:	90 91 df 06 	lds	r25, 0x06DF
    4140:	a0 91 e0 06 	lds	r26, 0x06E0
    4144:	b0 91 e1 06 	lds	r27, 0x06E1
    4148:	59 01       	movw	r10, r18
    414a:	6a 01       	movw	r12, r20
    414c:	a8 1a       	sub	r10, r24
    414e:	b9 0a       	sbc	r11, r25
    4150:	ca 0a       	sbc	r12, r26
    4152:	db 0a       	sbc	r13, r27
    4154:	d6 01       	movw	r26, r12
    4156:	c5 01       	movw	r24, r10
    4158:	8e 0d       	add	r24, r14
    415a:	9f 1d       	adc	r25, r15
    415c:	a0 1f       	adc	r26, r16
    415e:	b1 1f       	adc	r27, r17
    4160:	83 a3       	std	Z+35, r24	; 0x23
    4162:	94 a3       	std	Z+36, r25	; 0x24
    4164:	a5 a3       	std	Z+37, r26	; 0x25
    4166:	b6 a3       	std	Z+38, r27	; 0x26
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                ulTaskSwitchedInTime = ulTotalRunTime;
    4168:	80 91 e2 06 	lds	r24, 0x06E2
    416c:	90 91 e3 06 	lds	r25, 0x06E3
    4170:	a0 91 e4 06 	lds	r26, 0x06E4
    4174:	b0 91 e5 06 	lds	r27, 0x06E5
    4178:	80 93 de 06 	sts	0x06DE, r24
    417c:	90 93 df 06 	sts	0x06DF, r25
    4180:	a0 93 e0 06 	sts	0x06E0, r26
    4184:	b0 93 e1 06 	sts	0x06E1, r27
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4188:	80 91 d2 06 	lds	r24, 0x06D2
    418c:	8b 83       	std	Y+3, r24	; 0x03
    418e:	03 c0       	rjmp	.+6      	; 0x4196 <vTaskSwitchContext+0xf6>
    4190:	8b 81       	ldd	r24, Y+3	; 0x03
    4192:	81 50       	subi	r24, 0x01	; 1
    4194:	8b 83       	std	Y+3, r24	; 0x03
    4196:	8b 81       	ldd	r24, Y+3	; 0x03
    4198:	28 2f       	mov	r18, r24
    419a:	30 e0       	ldi	r19, 0x00	; 0
    419c:	c9 01       	movw	r24, r18
    419e:	88 0f       	add	r24, r24
    41a0:	99 1f       	adc	r25, r25
    41a2:	88 0f       	add	r24, r24
    41a4:	99 1f       	adc	r25, r25
    41a6:	88 0f       	add	r24, r24
    41a8:	99 1f       	adc	r25, r25
    41aa:	82 0f       	add	r24, r18
    41ac:	93 1f       	adc	r25, r19
    41ae:	fc 01       	movw	r30, r24
    41b0:	ea 51       	subi	r30, 0x1A	; 26
    41b2:	f9 4f       	sbci	r31, 0xF9	; 249
    41b4:	80 81       	ld	r24, Z
    41b6:	88 23       	and	r24, r24
    41b8:	59 f3       	breq	.-42     	; 0x4190 <vTaskSwitchContext+0xf0>
    41ba:	8b 81       	ldd	r24, Y+3	; 0x03
    41bc:	28 2f       	mov	r18, r24
    41be:	30 e0       	ldi	r19, 0x00	; 0
    41c0:	c9 01       	movw	r24, r18
    41c2:	88 0f       	add	r24, r24
    41c4:	99 1f       	adc	r25, r25
    41c6:	88 0f       	add	r24, r24
    41c8:	99 1f       	adc	r25, r25
    41ca:	88 0f       	add	r24, r24
    41cc:	99 1f       	adc	r25, r25
    41ce:	82 0f       	add	r24, r18
    41d0:	93 1f       	adc	r25, r19
    41d2:	8a 51       	subi	r24, 0x1A	; 26
    41d4:	99 4f       	sbci	r25, 0xF9	; 249
    41d6:	9a 83       	std	Y+2, r25	; 0x02
    41d8:	89 83       	std	Y+1, r24	; 0x01
    41da:	e9 81       	ldd	r30, Y+1	; 0x01
    41dc:	fa 81       	ldd	r31, Y+2	; 0x02
    41de:	01 80       	ldd	r0, Z+1	; 0x01
    41e0:	f2 81       	ldd	r31, Z+2	; 0x02
    41e2:	e0 2d       	mov	r30, r0
    41e4:	82 81       	ldd	r24, Z+2	; 0x02
    41e6:	93 81       	ldd	r25, Z+3	; 0x03
    41e8:	e9 81       	ldd	r30, Y+1	; 0x01
    41ea:	fa 81       	ldd	r31, Y+2	; 0x02
    41ec:	92 83       	std	Z+2, r25	; 0x02
    41ee:	81 83       	std	Z+1, r24	; 0x01
    41f0:	e9 81       	ldd	r30, Y+1	; 0x01
    41f2:	fa 81       	ldd	r31, Y+2	; 0x02
    41f4:	21 81       	ldd	r18, Z+1	; 0x01
    41f6:	32 81       	ldd	r19, Z+2	; 0x02
    41f8:	89 81       	ldd	r24, Y+1	; 0x01
    41fa:	9a 81       	ldd	r25, Y+2	; 0x02
    41fc:	03 96       	adiw	r24, 0x03	; 3
    41fe:	28 17       	cp	r18, r24
    4200:	39 07       	cpc	r19, r25
    4202:	59 f4       	brne	.+22     	; 0x421a <vTaskSwitchContext+0x17a>
    4204:	e9 81       	ldd	r30, Y+1	; 0x01
    4206:	fa 81       	ldd	r31, Y+2	; 0x02
    4208:	01 80       	ldd	r0, Z+1	; 0x01
    420a:	f2 81       	ldd	r31, Z+2	; 0x02
    420c:	e0 2d       	mov	r30, r0
    420e:	82 81       	ldd	r24, Z+2	; 0x02
    4210:	93 81       	ldd	r25, Z+3	; 0x03
    4212:	e9 81       	ldd	r30, Y+1	; 0x01
    4214:	fa 81       	ldd	r31, Y+2	; 0x02
    4216:	92 83       	std	Z+2, r25	; 0x02
    4218:	81 83       	std	Z+1, r24	; 0x01
    421a:	e9 81       	ldd	r30, Y+1	; 0x01
    421c:	fa 81       	ldd	r31, Y+2	; 0x02
    421e:	01 80       	ldd	r0, Z+1	; 0x01
    4220:	f2 81       	ldd	r31, Z+2	; 0x02
    4222:	e0 2d       	mov	r30, r0
    4224:	86 81       	ldd	r24, Z+6	; 0x06
    4226:	97 81       	ldd	r25, Z+7	; 0x07
    4228:	90 93 cd 06 	sts	0x06CD, r25
    422c:	80 93 cc 06 	sts	0x06CC, r24
    4230:	8b 81       	ldd	r24, Y+3	; 0x03
    4232:	80 93 d2 06 	sts	0x06D2, r24
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    4236:	0f 90       	pop	r0
    4238:	0f 90       	pop	r0
    423a:	0f 90       	pop	r0
    423c:	cf 91       	pop	r28
    423e:	df 91       	pop	r29
    4240:	1f 91       	pop	r17
    4242:	0f 91       	pop	r16
    4244:	ff 90       	pop	r15
    4246:	ef 90       	pop	r14
    4248:	df 90       	pop	r13
    424a:	cf 90       	pop	r12
    424c:	bf 90       	pop	r11
    424e:	af 90       	pop	r10
    4250:	08 95       	ret

00004252 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    4252:	df 93       	push	r29
    4254:	cf 93       	push	r28
    4256:	00 d0       	rcall	.+0      	; 0x4258 <vTaskPlaceOnEventList+0x6>
    4258:	00 d0       	rcall	.+0      	; 0x425a <vTaskPlaceOnEventList+0x8>
    425a:	cd b7       	in	r28, 0x3d	; 61
    425c:	de b7       	in	r29, 0x3e	; 62
    425e:	9a 83       	std	Y+2, r25	; 0x02
    4260:	89 83       	std	Y+1, r24	; 0x01
    4262:	7c 83       	std	Y+4, r23	; 0x04
    4264:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    4266:	80 91 cc 06 	lds	r24, 0x06CC
    426a:	90 91 cd 06 	lds	r25, 0x06CD
    426e:	9c 01       	movw	r18, r24
    4270:	24 5f       	subi	r18, 0xF4	; 244
    4272:	3f 4f       	sbci	r19, 0xFF	; 255
    4274:	89 81       	ldd	r24, Y+1	; 0x01
    4276:	9a 81       	ldd	r25, Y+2	; 0x02
    4278:	b9 01       	movw	r22, r18
    427a:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    427e:	8b 81       	ldd	r24, Y+3	; 0x03
    4280:	9c 81       	ldd	r25, Y+4	; 0x04
    4282:	61 e0       	ldi	r22, 0x01	; 1
    4284:	0e 94 73 31 	call	0x62e6	; 0x62e6 <prvAddCurrentTaskToDelayedList>
}
    4288:	0f 90       	pop	r0
    428a:	0f 90       	pop	r0
    428c:	0f 90       	pop	r0
    428e:	0f 90       	pop	r0
    4290:	cf 91       	pop	r28
    4292:	df 91       	pop	r29
    4294:	08 95       	ret

00004296 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    4296:	df 93       	push	r29
    4298:	cf 93       	push	r28
    429a:	cd b7       	in	r28, 0x3d	; 61
    429c:	de b7       	in	r29, 0x3e	; 62
    429e:	28 97       	sbiw	r28, 0x08	; 8
    42a0:	0f b6       	in	r0, 0x3f	; 63
    42a2:	f8 94       	cli
    42a4:	de bf       	out	0x3e, r29	; 62
    42a6:	0f be       	out	0x3f, r0	; 63
    42a8:	cd bf       	out	0x3d, r28	; 61
    42aa:	9c 83       	std	Y+4, r25	; 0x04
    42ac:	8b 83       	std	Y+3, r24	; 0x03
    42ae:	7e 83       	std	Y+6, r23	; 0x06
    42b0:	6d 83       	std	Y+5, r22	; 0x05
    42b2:	58 87       	std	Y+8, r21	; 0x08
    42b4:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    42b6:	e0 91 cc 06 	lds	r30, 0x06CC
    42ba:	f0 91 cd 06 	lds	r31, 0x06CD
    42be:	8d 81       	ldd	r24, Y+5	; 0x05
    42c0:	9e 81       	ldd	r25, Y+6	; 0x06
    42c2:	90 68       	ori	r25, 0x80	; 128
    42c4:	95 87       	std	Z+13, r25	; 0x0d
    42c6:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    42c8:	eb 81       	ldd	r30, Y+3	; 0x03
    42ca:	fc 81       	ldd	r31, Y+4	; 0x04
    42cc:	81 81       	ldd	r24, Z+1	; 0x01
    42ce:	92 81       	ldd	r25, Z+2	; 0x02
    42d0:	9a 83       	std	Y+2, r25	; 0x02
    42d2:	89 83       	std	Y+1, r24	; 0x01
    42d4:	e0 91 cc 06 	lds	r30, 0x06CC
    42d8:	f0 91 cd 06 	lds	r31, 0x06CD
    42dc:	89 81       	ldd	r24, Y+1	; 0x01
    42de:	9a 81       	ldd	r25, Y+2	; 0x02
    42e0:	97 87       	std	Z+15, r25	; 0x0f
    42e2:	86 87       	std	Z+14, r24	; 0x0e
    42e4:	a0 91 cc 06 	lds	r26, 0x06CC
    42e8:	b0 91 cd 06 	lds	r27, 0x06CD
    42ec:	e9 81       	ldd	r30, Y+1	; 0x01
    42ee:	fa 81       	ldd	r31, Y+2	; 0x02
    42f0:	84 81       	ldd	r24, Z+4	; 0x04
    42f2:	95 81       	ldd	r25, Z+5	; 0x05
    42f4:	51 96       	adiw	r26, 0x11	; 17
    42f6:	9c 93       	st	X, r25
    42f8:	8e 93       	st	-X, r24
    42fa:	50 97       	sbiw	r26, 0x10	; 16
    42fc:	e9 81       	ldd	r30, Y+1	; 0x01
    42fe:	fa 81       	ldd	r31, Y+2	; 0x02
    4300:	04 80       	ldd	r0, Z+4	; 0x04
    4302:	f5 81       	ldd	r31, Z+5	; 0x05
    4304:	e0 2d       	mov	r30, r0
    4306:	80 91 cc 06 	lds	r24, 0x06CC
    430a:	90 91 cd 06 	lds	r25, 0x06CD
    430e:	0c 96       	adiw	r24, 0x0c	; 12
    4310:	93 83       	std	Z+3, r25	; 0x03
    4312:	82 83       	std	Z+2, r24	; 0x02
    4314:	80 91 cc 06 	lds	r24, 0x06CC
    4318:	90 91 cd 06 	lds	r25, 0x06CD
    431c:	0c 96       	adiw	r24, 0x0c	; 12
    431e:	e9 81       	ldd	r30, Y+1	; 0x01
    4320:	fa 81       	ldd	r31, Y+2	; 0x02
    4322:	95 83       	std	Z+5, r25	; 0x05
    4324:	84 83       	std	Z+4, r24	; 0x04
    4326:	e0 91 cc 06 	lds	r30, 0x06CC
    432a:	f0 91 cd 06 	lds	r31, 0x06CD
    432e:	8b 81       	ldd	r24, Y+3	; 0x03
    4330:	9c 81       	ldd	r25, Y+4	; 0x04
    4332:	95 8b       	std	Z+21, r25	; 0x15
    4334:	84 8b       	std	Z+20, r24	; 0x14
    4336:	eb 81       	ldd	r30, Y+3	; 0x03
    4338:	fc 81       	ldd	r31, Y+4	; 0x04
    433a:	80 81       	ld	r24, Z
    433c:	8f 5f       	subi	r24, 0xFF	; 255
    433e:	eb 81       	ldd	r30, Y+3	; 0x03
    4340:	fc 81       	ldd	r31, Y+4	; 0x04
    4342:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4344:	8f 81       	ldd	r24, Y+7	; 0x07
    4346:	98 85       	ldd	r25, Y+8	; 0x08
    4348:	61 e0       	ldi	r22, 0x01	; 1
    434a:	0e 94 73 31 	call	0x62e6	; 0x62e6 <prvAddCurrentTaskToDelayedList>
}
    434e:	28 96       	adiw	r28, 0x08	; 8
    4350:	0f b6       	in	r0, 0x3f	; 63
    4352:	f8 94       	cli
    4354:	de bf       	out	0x3e, r29	; 62
    4356:	0f be       	out	0x3f, r0	; 63
    4358:	cd bf       	out	0x3d, r28	; 61
    435a:	cf 91       	pop	r28
    435c:	df 91       	pop	r29
    435e:	08 95       	ret

00004360 <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
    4360:	df 93       	push	r29
    4362:	cf 93       	push	r28
    4364:	cd b7       	in	r28, 0x3d	; 61
    4366:	de b7       	in	r29, 0x3e	; 62
    4368:	27 97       	sbiw	r28, 0x07	; 7
    436a:	0f b6       	in	r0, 0x3f	; 63
    436c:	f8 94       	cli
    436e:	de bf       	out	0x3e, r29	; 62
    4370:	0f be       	out	0x3f, r0	; 63
    4372:	cd bf       	out	0x3d, r28	; 61
    4374:	9c 83       	std	Y+4, r25	; 0x04
    4376:	8b 83       	std	Y+3, r24	; 0x03
    4378:	7e 83       	std	Y+6, r23	; 0x06
    437a:	6d 83       	std	Y+5, r22	; 0x05
    437c:	4f 83       	std	Y+7, r20	; 0x07

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    437e:	eb 81       	ldd	r30, Y+3	; 0x03
    4380:	fc 81       	ldd	r31, Y+4	; 0x04
    4382:	81 81       	ldd	r24, Z+1	; 0x01
    4384:	92 81       	ldd	r25, Z+2	; 0x02
    4386:	9a 83       	std	Y+2, r25	; 0x02
    4388:	89 83       	std	Y+1, r24	; 0x01
    438a:	e0 91 cc 06 	lds	r30, 0x06CC
    438e:	f0 91 cd 06 	lds	r31, 0x06CD
    4392:	89 81       	ldd	r24, Y+1	; 0x01
    4394:	9a 81       	ldd	r25, Y+2	; 0x02
    4396:	97 87       	std	Z+15, r25	; 0x0f
    4398:	86 87       	std	Z+14, r24	; 0x0e
    439a:	a0 91 cc 06 	lds	r26, 0x06CC
    439e:	b0 91 cd 06 	lds	r27, 0x06CD
    43a2:	e9 81       	ldd	r30, Y+1	; 0x01
    43a4:	fa 81       	ldd	r31, Y+2	; 0x02
    43a6:	84 81       	ldd	r24, Z+4	; 0x04
    43a8:	95 81       	ldd	r25, Z+5	; 0x05
    43aa:	51 96       	adiw	r26, 0x11	; 17
    43ac:	9c 93       	st	X, r25
    43ae:	8e 93       	st	-X, r24
    43b0:	50 97       	sbiw	r26, 0x10	; 16
    43b2:	e9 81       	ldd	r30, Y+1	; 0x01
    43b4:	fa 81       	ldd	r31, Y+2	; 0x02
    43b6:	04 80       	ldd	r0, Z+4	; 0x04
    43b8:	f5 81       	ldd	r31, Z+5	; 0x05
    43ba:	e0 2d       	mov	r30, r0
    43bc:	80 91 cc 06 	lds	r24, 0x06CC
    43c0:	90 91 cd 06 	lds	r25, 0x06CD
    43c4:	0c 96       	adiw	r24, 0x0c	; 12
    43c6:	93 83       	std	Z+3, r25	; 0x03
    43c8:	82 83       	std	Z+2, r24	; 0x02
    43ca:	80 91 cc 06 	lds	r24, 0x06CC
    43ce:	90 91 cd 06 	lds	r25, 0x06CD
    43d2:	0c 96       	adiw	r24, 0x0c	; 12
    43d4:	e9 81       	ldd	r30, Y+1	; 0x01
    43d6:	fa 81       	ldd	r31, Y+2	; 0x02
    43d8:	95 83       	std	Z+5, r25	; 0x05
    43da:	84 83       	std	Z+4, r24	; 0x04
    43dc:	e0 91 cc 06 	lds	r30, 0x06CC
    43e0:	f0 91 cd 06 	lds	r31, 0x06CD
    43e4:	8b 81       	ldd	r24, Y+3	; 0x03
    43e6:	9c 81       	ldd	r25, Y+4	; 0x04
    43e8:	95 8b       	std	Z+21, r25	; 0x15
    43ea:	84 8b       	std	Z+20, r24	; 0x14
    43ec:	eb 81       	ldd	r30, Y+3	; 0x03
    43ee:	fc 81       	ldd	r31, Y+4	; 0x04
    43f0:	80 81       	ld	r24, Z
    43f2:	8f 5f       	subi	r24, 0xFF	; 255
    43f4:	eb 81       	ldd	r30, Y+3	; 0x03
    43f6:	fc 81       	ldd	r31, Y+4	; 0x04
    43f8:	80 83       	st	Z, r24

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
    43fa:	8f 81       	ldd	r24, Y+7	; 0x07
    43fc:	88 23       	and	r24, r24
    43fe:	21 f0       	breq	.+8      	; 0x4408 <vTaskPlaceOnEventListRestricted+0xa8>
        {
            xTicksToWait = portMAX_DELAY;
    4400:	8f ef       	ldi	r24, 0xFF	; 255
    4402:	9f ef       	ldi	r25, 0xFF	; 255
    4404:	9e 83       	std	Y+6, r25	; 0x06
    4406:	8d 83       	std	Y+5, r24	; 0x05
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    4408:	8d 81       	ldd	r24, Y+5	; 0x05
    440a:	9e 81       	ldd	r25, Y+6	; 0x06
    440c:	6f 81       	ldd	r22, Y+7	; 0x07
    440e:	0e 94 73 31 	call	0x62e6	; 0x62e6 <prvAddCurrentTaskToDelayedList>
    }
    4412:	27 96       	adiw	r28, 0x07	; 7
    4414:	0f b6       	in	r0, 0x3f	; 63
    4416:	f8 94       	cli
    4418:	de bf       	out	0x3e, r29	; 62
    441a:	0f be       	out	0x3f, r0	; 63
    441c:	cd bf       	out	0x3d, r28	; 61
    441e:	cf 91       	pop	r28
    4420:	df 91       	pop	r29
    4422:	08 95       	ret

00004424 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4424:	df 93       	push	r29
    4426:	cf 93       	push	r28
    4428:	cd b7       	in	r28, 0x3d	; 61
    442a:	de b7       	in	r29, 0x3e	; 62
    442c:	2d 97       	sbiw	r28, 0x0d	; 13
    442e:	0f b6       	in	r0, 0x3f	; 63
    4430:	f8 94       	cli
    4432:	de bf       	out	0x3e, r29	; 62
    4434:	0f be       	out	0x3f, r0	; 63
    4436:	cd bf       	out	0x3d, r28	; 61
    4438:	9d 87       	std	Y+13, r25	; 0x0d
    443a:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    443c:	ec 85       	ldd	r30, Y+12	; 0x0c
    443e:	fd 85       	ldd	r31, Y+13	; 0x0d
    4440:	05 80       	ldd	r0, Z+5	; 0x05
    4442:	f6 81       	ldd	r31, Z+6	; 0x06
    4444:	e0 2d       	mov	r30, r0
    4446:	86 81       	ldd	r24, Z+6	; 0x06
    4448:	97 81       	ldd	r25, Z+7	; 0x07
    444a:	9b 87       	std	Y+11, r25	; 0x0b
    444c:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    444e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4450:	fb 85       	ldd	r31, Y+11	; 0x0b
    4452:	84 89       	ldd	r24, Z+20	; 0x14
    4454:	95 89       	ldd	r25, Z+21	; 0x15
    4456:	98 87       	std	Y+8, r25	; 0x08
    4458:	8f 83       	std	Y+7, r24	; 0x07
    445a:	ea 85       	ldd	r30, Y+10	; 0x0a
    445c:	fb 85       	ldd	r31, Y+11	; 0x0b
    445e:	a6 85       	ldd	r26, Z+14	; 0x0e
    4460:	b7 85       	ldd	r27, Z+15	; 0x0f
    4462:	ea 85       	ldd	r30, Y+10	; 0x0a
    4464:	fb 85       	ldd	r31, Y+11	; 0x0b
    4466:	80 89       	ldd	r24, Z+16	; 0x10
    4468:	91 89       	ldd	r25, Z+17	; 0x11
    446a:	15 96       	adiw	r26, 0x05	; 5
    446c:	9c 93       	st	X, r25
    446e:	8e 93       	st	-X, r24
    4470:	14 97       	sbiw	r26, 0x04	; 4
    4472:	ea 85       	ldd	r30, Y+10	; 0x0a
    4474:	fb 85       	ldd	r31, Y+11	; 0x0b
    4476:	a0 89       	ldd	r26, Z+16	; 0x10
    4478:	b1 89       	ldd	r27, Z+17	; 0x11
    447a:	ea 85       	ldd	r30, Y+10	; 0x0a
    447c:	fb 85       	ldd	r31, Y+11	; 0x0b
    447e:	86 85       	ldd	r24, Z+14	; 0x0e
    4480:	97 85       	ldd	r25, Z+15	; 0x0f
    4482:	13 96       	adiw	r26, 0x03	; 3
    4484:	9c 93       	st	X, r25
    4486:	8e 93       	st	-X, r24
    4488:	12 97       	sbiw	r26, 0x02	; 2
    448a:	ef 81       	ldd	r30, Y+7	; 0x07
    448c:	f8 85       	ldd	r31, Y+8	; 0x08
    448e:	21 81       	ldd	r18, Z+1	; 0x01
    4490:	32 81       	ldd	r19, Z+2	; 0x02
    4492:	8a 85       	ldd	r24, Y+10	; 0x0a
    4494:	9b 85       	ldd	r25, Y+11	; 0x0b
    4496:	0c 96       	adiw	r24, 0x0c	; 12
    4498:	28 17       	cp	r18, r24
    449a:	39 07       	cpc	r19, r25
    449c:	41 f4       	brne	.+16     	; 0x44ae <xTaskRemoveFromEventList+0x8a>
    449e:	ea 85       	ldd	r30, Y+10	; 0x0a
    44a0:	fb 85       	ldd	r31, Y+11	; 0x0b
    44a2:	80 89       	ldd	r24, Z+16	; 0x10
    44a4:	91 89       	ldd	r25, Z+17	; 0x11
    44a6:	ef 81       	ldd	r30, Y+7	; 0x07
    44a8:	f8 85       	ldd	r31, Y+8	; 0x08
    44aa:	92 83       	std	Z+2, r25	; 0x02
    44ac:	81 83       	std	Z+1, r24	; 0x01
    44ae:	ea 85       	ldd	r30, Y+10	; 0x0a
    44b0:	fb 85       	ldd	r31, Y+11	; 0x0b
    44b2:	15 8a       	std	Z+21, r1	; 0x15
    44b4:	14 8a       	std	Z+20, r1	; 0x14
    44b6:	ef 81       	ldd	r30, Y+7	; 0x07
    44b8:	f8 85       	ldd	r31, Y+8	; 0x08
    44ba:	80 81       	ld	r24, Z
    44bc:	81 50       	subi	r24, 0x01	; 1
    44be:	ef 81       	ldd	r30, Y+7	; 0x07
    44c0:	f8 85       	ldd	r31, Y+8	; 0x08
    44c2:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    44c4:	80 91 dd 06 	lds	r24, 0x06DD
    44c8:	88 23       	and	r24, r24
    44ca:	09 f0       	breq	.+2      	; 0x44ce <xTaskRemoveFromEventList+0xaa>
    44cc:	a4 c0       	rjmp	.+328    	; 0x4616 <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    44ce:	ea 85       	ldd	r30, Y+10	; 0x0a
    44d0:	fb 85       	ldd	r31, Y+11	; 0x0b
    44d2:	82 85       	ldd	r24, Z+10	; 0x0a
    44d4:	93 85       	ldd	r25, Z+11	; 0x0b
    44d6:	9e 83       	std	Y+6, r25	; 0x06
    44d8:	8d 83       	std	Y+5, r24	; 0x05
    44da:	ea 85       	ldd	r30, Y+10	; 0x0a
    44dc:	fb 85       	ldd	r31, Y+11	; 0x0b
    44de:	a4 81       	ldd	r26, Z+4	; 0x04
    44e0:	b5 81       	ldd	r27, Z+5	; 0x05
    44e2:	ea 85       	ldd	r30, Y+10	; 0x0a
    44e4:	fb 85       	ldd	r31, Y+11	; 0x0b
    44e6:	86 81       	ldd	r24, Z+6	; 0x06
    44e8:	97 81       	ldd	r25, Z+7	; 0x07
    44ea:	15 96       	adiw	r26, 0x05	; 5
    44ec:	9c 93       	st	X, r25
    44ee:	8e 93       	st	-X, r24
    44f0:	14 97       	sbiw	r26, 0x04	; 4
    44f2:	ea 85       	ldd	r30, Y+10	; 0x0a
    44f4:	fb 85       	ldd	r31, Y+11	; 0x0b
    44f6:	a6 81       	ldd	r26, Z+6	; 0x06
    44f8:	b7 81       	ldd	r27, Z+7	; 0x07
    44fa:	ea 85       	ldd	r30, Y+10	; 0x0a
    44fc:	fb 85       	ldd	r31, Y+11	; 0x0b
    44fe:	84 81       	ldd	r24, Z+4	; 0x04
    4500:	95 81       	ldd	r25, Z+5	; 0x05
    4502:	13 96       	adiw	r26, 0x03	; 3
    4504:	9c 93       	st	X, r25
    4506:	8e 93       	st	-X, r24
    4508:	12 97       	sbiw	r26, 0x02	; 2
    450a:	ed 81       	ldd	r30, Y+5	; 0x05
    450c:	fe 81       	ldd	r31, Y+6	; 0x06
    450e:	21 81       	ldd	r18, Z+1	; 0x01
    4510:	32 81       	ldd	r19, Z+2	; 0x02
    4512:	8a 85       	ldd	r24, Y+10	; 0x0a
    4514:	9b 85       	ldd	r25, Y+11	; 0x0b
    4516:	02 96       	adiw	r24, 0x02	; 2
    4518:	28 17       	cp	r18, r24
    451a:	39 07       	cpc	r19, r25
    451c:	41 f4       	brne	.+16     	; 0x452e <xTaskRemoveFromEventList+0x10a>
    451e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4520:	fb 85       	ldd	r31, Y+11	; 0x0b
    4522:	86 81       	ldd	r24, Z+6	; 0x06
    4524:	97 81       	ldd	r25, Z+7	; 0x07
    4526:	ed 81       	ldd	r30, Y+5	; 0x05
    4528:	fe 81       	ldd	r31, Y+6	; 0x06
    452a:	92 83       	std	Z+2, r25	; 0x02
    452c:	81 83       	std	Z+1, r24	; 0x01
    452e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4530:	fb 85       	ldd	r31, Y+11	; 0x0b
    4532:	13 86       	std	Z+11, r1	; 0x0b
    4534:	12 86       	std	Z+10, r1	; 0x0a
    4536:	ed 81       	ldd	r30, Y+5	; 0x05
    4538:	fe 81       	ldd	r31, Y+6	; 0x06
    453a:	80 81       	ld	r24, Z
    453c:	81 50       	subi	r24, 0x01	; 1
    453e:	ed 81       	ldd	r30, Y+5	; 0x05
    4540:	fe 81       	ldd	r31, Y+6	; 0x06
    4542:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    4544:	ea 85       	ldd	r30, Y+10	; 0x0a
    4546:	fb 85       	ldd	r31, Y+11	; 0x0b
    4548:	96 89       	ldd	r25, Z+22	; 0x16
    454a:	80 91 d2 06 	lds	r24, 0x06D2
    454e:	89 17       	cp	r24, r25
    4550:	28 f4       	brcc	.+10     	; 0x455c <xTaskRemoveFromEventList+0x138>
    4552:	ea 85       	ldd	r30, Y+10	; 0x0a
    4554:	fb 85       	ldd	r31, Y+11	; 0x0b
    4556:	86 89       	ldd	r24, Z+22	; 0x16
    4558:	80 93 d2 06 	sts	0x06D2, r24
    455c:	ea 85       	ldd	r30, Y+10	; 0x0a
    455e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4560:	86 89       	ldd	r24, Z+22	; 0x16
    4562:	28 2f       	mov	r18, r24
    4564:	30 e0       	ldi	r19, 0x00	; 0
    4566:	c9 01       	movw	r24, r18
    4568:	88 0f       	add	r24, r24
    456a:	99 1f       	adc	r25, r25
    456c:	88 0f       	add	r24, r24
    456e:	99 1f       	adc	r25, r25
    4570:	88 0f       	add	r24, r24
    4572:	99 1f       	adc	r25, r25
    4574:	82 0f       	add	r24, r18
    4576:	93 1f       	adc	r25, r19
    4578:	fc 01       	movw	r30, r24
    457a:	ea 51       	subi	r30, 0x1A	; 26
    457c:	f9 4f       	sbci	r31, 0xF9	; 249
    457e:	81 81       	ldd	r24, Z+1	; 0x01
    4580:	92 81       	ldd	r25, Z+2	; 0x02
    4582:	9c 83       	std	Y+4, r25	; 0x04
    4584:	8b 83       	std	Y+3, r24	; 0x03
    4586:	ea 85       	ldd	r30, Y+10	; 0x0a
    4588:	fb 85       	ldd	r31, Y+11	; 0x0b
    458a:	8b 81       	ldd	r24, Y+3	; 0x03
    458c:	9c 81       	ldd	r25, Y+4	; 0x04
    458e:	95 83       	std	Z+5, r25	; 0x05
    4590:	84 83       	std	Z+4, r24	; 0x04
    4592:	eb 81       	ldd	r30, Y+3	; 0x03
    4594:	fc 81       	ldd	r31, Y+4	; 0x04
    4596:	84 81       	ldd	r24, Z+4	; 0x04
    4598:	95 81       	ldd	r25, Z+5	; 0x05
    459a:	ea 85       	ldd	r30, Y+10	; 0x0a
    459c:	fb 85       	ldd	r31, Y+11	; 0x0b
    459e:	97 83       	std	Z+7, r25	; 0x07
    45a0:	86 83       	std	Z+6, r24	; 0x06
    45a2:	eb 81       	ldd	r30, Y+3	; 0x03
    45a4:	fc 81       	ldd	r31, Y+4	; 0x04
    45a6:	04 80       	ldd	r0, Z+4	; 0x04
    45a8:	f5 81       	ldd	r31, Z+5	; 0x05
    45aa:	e0 2d       	mov	r30, r0
    45ac:	8a 85       	ldd	r24, Y+10	; 0x0a
    45ae:	9b 85       	ldd	r25, Y+11	; 0x0b
    45b0:	02 96       	adiw	r24, 0x02	; 2
    45b2:	93 83       	std	Z+3, r25	; 0x03
    45b4:	82 83       	std	Z+2, r24	; 0x02
    45b6:	8a 85       	ldd	r24, Y+10	; 0x0a
    45b8:	9b 85       	ldd	r25, Y+11	; 0x0b
    45ba:	02 96       	adiw	r24, 0x02	; 2
    45bc:	eb 81       	ldd	r30, Y+3	; 0x03
    45be:	fc 81       	ldd	r31, Y+4	; 0x04
    45c0:	95 83       	std	Z+5, r25	; 0x05
    45c2:	84 83       	std	Z+4, r24	; 0x04
    45c4:	ea 85       	ldd	r30, Y+10	; 0x0a
    45c6:	fb 85       	ldd	r31, Y+11	; 0x0b
    45c8:	86 89       	ldd	r24, Z+22	; 0x16
    45ca:	28 2f       	mov	r18, r24
    45cc:	30 e0       	ldi	r19, 0x00	; 0
    45ce:	c9 01       	movw	r24, r18
    45d0:	88 0f       	add	r24, r24
    45d2:	99 1f       	adc	r25, r25
    45d4:	88 0f       	add	r24, r24
    45d6:	99 1f       	adc	r25, r25
    45d8:	88 0f       	add	r24, r24
    45da:	99 1f       	adc	r25, r25
    45dc:	82 0f       	add	r24, r18
    45de:	93 1f       	adc	r25, r19
    45e0:	8a 51       	subi	r24, 0x1A	; 26
    45e2:	99 4f       	sbci	r25, 0xF9	; 249
    45e4:	ea 85       	ldd	r30, Y+10	; 0x0a
    45e6:	fb 85       	ldd	r31, Y+11	; 0x0b
    45e8:	93 87       	std	Z+11, r25	; 0x0b
    45ea:	82 87       	std	Z+10, r24	; 0x0a
    45ec:	ea 85       	ldd	r30, Y+10	; 0x0a
    45ee:	fb 85       	ldd	r31, Y+11	; 0x0b
    45f0:	86 89       	ldd	r24, Z+22	; 0x16
    45f2:	28 2f       	mov	r18, r24
    45f4:	30 e0       	ldi	r19, 0x00	; 0
    45f6:	c9 01       	movw	r24, r18
    45f8:	88 0f       	add	r24, r24
    45fa:	99 1f       	adc	r25, r25
    45fc:	88 0f       	add	r24, r24
    45fe:	99 1f       	adc	r25, r25
    4600:	88 0f       	add	r24, r24
    4602:	99 1f       	adc	r25, r25
    4604:	82 0f       	add	r24, r18
    4606:	93 1f       	adc	r25, r19
    4608:	fc 01       	movw	r30, r24
    460a:	ea 51       	subi	r30, 0x1A	; 26
    460c:	f9 4f       	sbci	r31, 0xF9	; 249
    460e:	80 81       	ld	r24, Z
    4610:	8f 5f       	subi	r24, 0xFF	; 255
    4612:	80 83       	st	Z, r24
    4614:	30 c0       	rjmp	.+96     	; 0x4676 <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4616:	80 91 21 07 	lds	r24, 0x0721
    461a:	90 91 22 07 	lds	r25, 0x0722
    461e:	9a 83       	std	Y+2, r25	; 0x02
    4620:	89 83       	std	Y+1, r24	; 0x01
    4622:	ea 85       	ldd	r30, Y+10	; 0x0a
    4624:	fb 85       	ldd	r31, Y+11	; 0x0b
    4626:	89 81       	ldd	r24, Y+1	; 0x01
    4628:	9a 81       	ldd	r25, Y+2	; 0x02
    462a:	97 87       	std	Z+15, r25	; 0x0f
    462c:	86 87       	std	Z+14, r24	; 0x0e
    462e:	e9 81       	ldd	r30, Y+1	; 0x01
    4630:	fa 81       	ldd	r31, Y+2	; 0x02
    4632:	84 81       	ldd	r24, Z+4	; 0x04
    4634:	95 81       	ldd	r25, Z+5	; 0x05
    4636:	ea 85       	ldd	r30, Y+10	; 0x0a
    4638:	fb 85       	ldd	r31, Y+11	; 0x0b
    463a:	91 8b       	std	Z+17, r25	; 0x11
    463c:	80 8b       	std	Z+16, r24	; 0x10
    463e:	e9 81       	ldd	r30, Y+1	; 0x01
    4640:	fa 81       	ldd	r31, Y+2	; 0x02
    4642:	04 80       	ldd	r0, Z+4	; 0x04
    4644:	f5 81       	ldd	r31, Z+5	; 0x05
    4646:	e0 2d       	mov	r30, r0
    4648:	8a 85       	ldd	r24, Y+10	; 0x0a
    464a:	9b 85       	ldd	r25, Y+11	; 0x0b
    464c:	0c 96       	adiw	r24, 0x0c	; 12
    464e:	93 83       	std	Z+3, r25	; 0x03
    4650:	82 83       	std	Z+2, r24	; 0x02
    4652:	8a 85       	ldd	r24, Y+10	; 0x0a
    4654:	9b 85       	ldd	r25, Y+11	; 0x0b
    4656:	0c 96       	adiw	r24, 0x0c	; 12
    4658:	e9 81       	ldd	r30, Y+1	; 0x01
    465a:	fa 81       	ldd	r31, Y+2	; 0x02
    465c:	95 83       	std	Z+5, r25	; 0x05
    465e:	84 83       	std	Z+4, r24	; 0x04
    4660:	ea 85       	ldd	r30, Y+10	; 0x0a
    4662:	fb 85       	ldd	r31, Y+11	; 0x0b
    4664:	80 e2       	ldi	r24, 0x20	; 32
    4666:	97 e0       	ldi	r25, 0x07	; 7
    4668:	95 8b       	std	Z+21, r25	; 0x15
    466a:	84 8b       	std	Z+20, r24	; 0x14
    466c:	80 91 20 07 	lds	r24, 0x0720
    4670:	8f 5f       	subi	r24, 0xFF	; 255
    4672:	80 93 20 07 	sts	0x0720, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4676:	ea 85       	ldd	r30, Y+10	; 0x0a
    4678:	fb 85       	ldd	r31, Y+11	; 0x0b
    467a:	96 89       	ldd	r25, Z+22	; 0x16
    467c:	e0 91 cc 06 	lds	r30, 0x06CC
    4680:	f0 91 cd 06 	lds	r31, 0x06CD
    4684:	86 89       	ldd	r24, Z+22	; 0x16
    4686:	89 17       	cp	r24, r25
    4688:	30 f4       	brcc	.+12     	; 0x4696 <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    468a:	81 e0       	ldi	r24, 0x01	; 1
    468c:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    468e:	81 e0       	ldi	r24, 0x01	; 1
    4690:	80 93 d6 06 	sts	0x06D6, r24
    4694:	01 c0       	rjmp	.+2      	; 0x4698 <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    4696:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    4698:	89 85       	ldd	r24, Y+9	; 0x09
}
    469a:	2d 96       	adiw	r28, 0x0d	; 13
    469c:	0f b6       	in	r0, 0x3f	; 63
    469e:	f8 94       	cli
    46a0:	de bf       	out	0x3e, r29	; 62
    46a2:	0f be       	out	0x3f, r0	; 63
    46a4:	cd bf       	out	0x3d, r28	; 61
    46a6:	cf 91       	pop	r28
    46a8:	df 91       	pop	r29
    46aa:	08 95       	ret

000046ac <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    46ac:	df 93       	push	r29
    46ae:	cf 93       	push	r28
    46b0:	cd b7       	in	r28, 0x3d	; 61
    46b2:	de b7       	in	r29, 0x3e	; 62
    46b4:	2c 97       	sbiw	r28, 0x0c	; 12
    46b6:	0f b6       	in	r0, 0x3f	; 63
    46b8:	f8 94       	cli
    46ba:	de bf       	out	0x3e, r29	; 62
    46bc:	0f be       	out	0x3f, r0	; 63
    46be:	cd bf       	out	0x3d, r28	; 61
    46c0:	9a 87       	std	Y+10, r25	; 0x0a
    46c2:	89 87       	std	Y+9, r24	; 0x09
    46c4:	7c 87       	std	Y+12, r23	; 0x0c
    46c6:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    46c8:	8b 85       	ldd	r24, Y+11	; 0x0b
    46ca:	9c 85       	ldd	r25, Y+12	; 0x0c
    46cc:	90 68       	ori	r25, 0x80	; 128
    46ce:	e9 85       	ldd	r30, Y+9	; 0x09
    46d0:	fa 85       	ldd	r31, Y+10	; 0x0a
    46d2:	91 83       	std	Z+1, r25	; 0x01
    46d4:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    46d6:	e9 85       	ldd	r30, Y+9	; 0x09
    46d8:	fa 85       	ldd	r31, Y+10	; 0x0a
    46da:	86 81       	ldd	r24, Z+6	; 0x06
    46dc:	97 81       	ldd	r25, Z+7	; 0x07
    46de:	98 87       	std	Y+8, r25	; 0x08
    46e0:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    46e2:	e9 85       	ldd	r30, Y+9	; 0x09
    46e4:	fa 85       	ldd	r31, Y+10	; 0x0a
    46e6:	80 85       	ldd	r24, Z+8	; 0x08
    46e8:	91 85       	ldd	r25, Z+9	; 0x09
    46ea:	9e 83       	std	Y+6, r25	; 0x06
    46ec:	8d 83       	std	Y+5, r24	; 0x05
    46ee:	e9 85       	ldd	r30, Y+9	; 0x09
    46f0:	fa 85       	ldd	r31, Y+10	; 0x0a
    46f2:	a2 81       	ldd	r26, Z+2	; 0x02
    46f4:	b3 81       	ldd	r27, Z+3	; 0x03
    46f6:	e9 85       	ldd	r30, Y+9	; 0x09
    46f8:	fa 85       	ldd	r31, Y+10	; 0x0a
    46fa:	84 81       	ldd	r24, Z+4	; 0x04
    46fc:	95 81       	ldd	r25, Z+5	; 0x05
    46fe:	15 96       	adiw	r26, 0x05	; 5
    4700:	9c 93       	st	X, r25
    4702:	8e 93       	st	-X, r24
    4704:	14 97       	sbiw	r26, 0x04	; 4
    4706:	e9 85       	ldd	r30, Y+9	; 0x09
    4708:	fa 85       	ldd	r31, Y+10	; 0x0a
    470a:	a4 81       	ldd	r26, Z+4	; 0x04
    470c:	b5 81       	ldd	r27, Z+5	; 0x05
    470e:	e9 85       	ldd	r30, Y+9	; 0x09
    4710:	fa 85       	ldd	r31, Y+10	; 0x0a
    4712:	82 81       	ldd	r24, Z+2	; 0x02
    4714:	93 81       	ldd	r25, Z+3	; 0x03
    4716:	13 96       	adiw	r26, 0x03	; 3
    4718:	9c 93       	st	X, r25
    471a:	8e 93       	st	-X, r24
    471c:	12 97       	sbiw	r26, 0x02	; 2
    471e:	ed 81       	ldd	r30, Y+5	; 0x05
    4720:	fe 81       	ldd	r31, Y+6	; 0x06
    4722:	21 81       	ldd	r18, Z+1	; 0x01
    4724:	32 81       	ldd	r19, Z+2	; 0x02
    4726:	89 85       	ldd	r24, Y+9	; 0x09
    4728:	9a 85       	ldd	r25, Y+10	; 0x0a
    472a:	28 17       	cp	r18, r24
    472c:	39 07       	cpc	r19, r25
    472e:	41 f4       	brne	.+16     	; 0x4740 <vTaskRemoveFromUnorderedEventList+0x94>
    4730:	e9 85       	ldd	r30, Y+9	; 0x09
    4732:	fa 85       	ldd	r31, Y+10	; 0x0a
    4734:	84 81       	ldd	r24, Z+4	; 0x04
    4736:	95 81       	ldd	r25, Z+5	; 0x05
    4738:	ed 81       	ldd	r30, Y+5	; 0x05
    473a:	fe 81       	ldd	r31, Y+6	; 0x06
    473c:	92 83       	std	Z+2, r25	; 0x02
    473e:	81 83       	std	Z+1, r24	; 0x01
    4740:	e9 85       	ldd	r30, Y+9	; 0x09
    4742:	fa 85       	ldd	r31, Y+10	; 0x0a
    4744:	11 86       	std	Z+9, r1	; 0x09
    4746:	10 86       	std	Z+8, r1	; 0x08
    4748:	ed 81       	ldd	r30, Y+5	; 0x05
    474a:	fe 81       	ldd	r31, Y+6	; 0x06
    474c:	80 81       	ld	r24, Z
    474e:	81 50       	subi	r24, 0x01	; 1
    4750:	ed 81       	ldd	r30, Y+5	; 0x05
    4752:	fe 81       	ldd	r31, Y+6	; 0x06
    4754:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    4756:	ef 81       	ldd	r30, Y+7	; 0x07
    4758:	f8 85       	ldd	r31, Y+8	; 0x08
    475a:	82 85       	ldd	r24, Z+10	; 0x0a
    475c:	93 85       	ldd	r25, Z+11	; 0x0b
    475e:	9c 83       	std	Y+4, r25	; 0x04
    4760:	8b 83       	std	Y+3, r24	; 0x03
    4762:	ef 81       	ldd	r30, Y+7	; 0x07
    4764:	f8 85       	ldd	r31, Y+8	; 0x08
    4766:	a4 81       	ldd	r26, Z+4	; 0x04
    4768:	b5 81       	ldd	r27, Z+5	; 0x05
    476a:	ef 81       	ldd	r30, Y+7	; 0x07
    476c:	f8 85       	ldd	r31, Y+8	; 0x08
    476e:	86 81       	ldd	r24, Z+6	; 0x06
    4770:	97 81       	ldd	r25, Z+7	; 0x07
    4772:	15 96       	adiw	r26, 0x05	; 5
    4774:	9c 93       	st	X, r25
    4776:	8e 93       	st	-X, r24
    4778:	14 97       	sbiw	r26, 0x04	; 4
    477a:	ef 81       	ldd	r30, Y+7	; 0x07
    477c:	f8 85       	ldd	r31, Y+8	; 0x08
    477e:	a6 81       	ldd	r26, Z+6	; 0x06
    4780:	b7 81       	ldd	r27, Z+7	; 0x07
    4782:	ef 81       	ldd	r30, Y+7	; 0x07
    4784:	f8 85       	ldd	r31, Y+8	; 0x08
    4786:	84 81       	ldd	r24, Z+4	; 0x04
    4788:	95 81       	ldd	r25, Z+5	; 0x05
    478a:	13 96       	adiw	r26, 0x03	; 3
    478c:	9c 93       	st	X, r25
    478e:	8e 93       	st	-X, r24
    4790:	12 97       	sbiw	r26, 0x02	; 2
    4792:	eb 81       	ldd	r30, Y+3	; 0x03
    4794:	fc 81       	ldd	r31, Y+4	; 0x04
    4796:	21 81       	ldd	r18, Z+1	; 0x01
    4798:	32 81       	ldd	r19, Z+2	; 0x02
    479a:	8f 81       	ldd	r24, Y+7	; 0x07
    479c:	98 85       	ldd	r25, Y+8	; 0x08
    479e:	02 96       	adiw	r24, 0x02	; 2
    47a0:	28 17       	cp	r18, r24
    47a2:	39 07       	cpc	r19, r25
    47a4:	41 f4       	brne	.+16     	; 0x47b6 <vTaskRemoveFromUnorderedEventList+0x10a>
    47a6:	ef 81       	ldd	r30, Y+7	; 0x07
    47a8:	f8 85       	ldd	r31, Y+8	; 0x08
    47aa:	86 81       	ldd	r24, Z+6	; 0x06
    47ac:	97 81       	ldd	r25, Z+7	; 0x07
    47ae:	eb 81       	ldd	r30, Y+3	; 0x03
    47b0:	fc 81       	ldd	r31, Y+4	; 0x04
    47b2:	92 83       	std	Z+2, r25	; 0x02
    47b4:	81 83       	std	Z+1, r24	; 0x01
    47b6:	ef 81       	ldd	r30, Y+7	; 0x07
    47b8:	f8 85       	ldd	r31, Y+8	; 0x08
    47ba:	13 86       	std	Z+11, r1	; 0x0b
    47bc:	12 86       	std	Z+10, r1	; 0x0a
    47be:	eb 81       	ldd	r30, Y+3	; 0x03
    47c0:	fc 81       	ldd	r31, Y+4	; 0x04
    47c2:	80 81       	ld	r24, Z
    47c4:	81 50       	subi	r24, 0x01	; 1
    47c6:	eb 81       	ldd	r30, Y+3	; 0x03
    47c8:	fc 81       	ldd	r31, Y+4	; 0x04
    47ca:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    47cc:	ef 81       	ldd	r30, Y+7	; 0x07
    47ce:	f8 85       	ldd	r31, Y+8	; 0x08
    47d0:	96 89       	ldd	r25, Z+22	; 0x16
    47d2:	80 91 d2 06 	lds	r24, 0x06D2
    47d6:	89 17       	cp	r24, r25
    47d8:	28 f4       	brcc	.+10     	; 0x47e4 <vTaskRemoveFromUnorderedEventList+0x138>
    47da:	ef 81       	ldd	r30, Y+7	; 0x07
    47dc:	f8 85       	ldd	r31, Y+8	; 0x08
    47de:	86 89       	ldd	r24, Z+22	; 0x16
    47e0:	80 93 d2 06 	sts	0x06D2, r24
    47e4:	ef 81       	ldd	r30, Y+7	; 0x07
    47e6:	f8 85       	ldd	r31, Y+8	; 0x08
    47e8:	86 89       	ldd	r24, Z+22	; 0x16
    47ea:	28 2f       	mov	r18, r24
    47ec:	30 e0       	ldi	r19, 0x00	; 0
    47ee:	c9 01       	movw	r24, r18
    47f0:	88 0f       	add	r24, r24
    47f2:	99 1f       	adc	r25, r25
    47f4:	88 0f       	add	r24, r24
    47f6:	99 1f       	adc	r25, r25
    47f8:	88 0f       	add	r24, r24
    47fa:	99 1f       	adc	r25, r25
    47fc:	82 0f       	add	r24, r18
    47fe:	93 1f       	adc	r25, r19
    4800:	fc 01       	movw	r30, r24
    4802:	ea 51       	subi	r30, 0x1A	; 26
    4804:	f9 4f       	sbci	r31, 0xF9	; 249
    4806:	81 81       	ldd	r24, Z+1	; 0x01
    4808:	92 81       	ldd	r25, Z+2	; 0x02
    480a:	9a 83       	std	Y+2, r25	; 0x02
    480c:	89 83       	std	Y+1, r24	; 0x01
    480e:	ef 81       	ldd	r30, Y+7	; 0x07
    4810:	f8 85       	ldd	r31, Y+8	; 0x08
    4812:	89 81       	ldd	r24, Y+1	; 0x01
    4814:	9a 81       	ldd	r25, Y+2	; 0x02
    4816:	95 83       	std	Z+5, r25	; 0x05
    4818:	84 83       	std	Z+4, r24	; 0x04
    481a:	e9 81       	ldd	r30, Y+1	; 0x01
    481c:	fa 81       	ldd	r31, Y+2	; 0x02
    481e:	84 81       	ldd	r24, Z+4	; 0x04
    4820:	95 81       	ldd	r25, Z+5	; 0x05
    4822:	ef 81       	ldd	r30, Y+7	; 0x07
    4824:	f8 85       	ldd	r31, Y+8	; 0x08
    4826:	97 83       	std	Z+7, r25	; 0x07
    4828:	86 83       	std	Z+6, r24	; 0x06
    482a:	e9 81       	ldd	r30, Y+1	; 0x01
    482c:	fa 81       	ldd	r31, Y+2	; 0x02
    482e:	04 80       	ldd	r0, Z+4	; 0x04
    4830:	f5 81       	ldd	r31, Z+5	; 0x05
    4832:	e0 2d       	mov	r30, r0
    4834:	8f 81       	ldd	r24, Y+7	; 0x07
    4836:	98 85       	ldd	r25, Y+8	; 0x08
    4838:	02 96       	adiw	r24, 0x02	; 2
    483a:	93 83       	std	Z+3, r25	; 0x03
    483c:	82 83       	std	Z+2, r24	; 0x02
    483e:	8f 81       	ldd	r24, Y+7	; 0x07
    4840:	98 85       	ldd	r25, Y+8	; 0x08
    4842:	02 96       	adiw	r24, 0x02	; 2
    4844:	e9 81       	ldd	r30, Y+1	; 0x01
    4846:	fa 81       	ldd	r31, Y+2	; 0x02
    4848:	95 83       	std	Z+5, r25	; 0x05
    484a:	84 83       	std	Z+4, r24	; 0x04
    484c:	ef 81       	ldd	r30, Y+7	; 0x07
    484e:	f8 85       	ldd	r31, Y+8	; 0x08
    4850:	86 89       	ldd	r24, Z+22	; 0x16
    4852:	28 2f       	mov	r18, r24
    4854:	30 e0       	ldi	r19, 0x00	; 0
    4856:	c9 01       	movw	r24, r18
    4858:	88 0f       	add	r24, r24
    485a:	99 1f       	adc	r25, r25
    485c:	88 0f       	add	r24, r24
    485e:	99 1f       	adc	r25, r25
    4860:	88 0f       	add	r24, r24
    4862:	99 1f       	adc	r25, r25
    4864:	82 0f       	add	r24, r18
    4866:	93 1f       	adc	r25, r19
    4868:	8a 51       	subi	r24, 0x1A	; 26
    486a:	99 4f       	sbci	r25, 0xF9	; 249
    486c:	ef 81       	ldd	r30, Y+7	; 0x07
    486e:	f8 85       	ldd	r31, Y+8	; 0x08
    4870:	93 87       	std	Z+11, r25	; 0x0b
    4872:	82 87       	std	Z+10, r24	; 0x0a
    4874:	ef 81       	ldd	r30, Y+7	; 0x07
    4876:	f8 85       	ldd	r31, Y+8	; 0x08
    4878:	86 89       	ldd	r24, Z+22	; 0x16
    487a:	28 2f       	mov	r18, r24
    487c:	30 e0       	ldi	r19, 0x00	; 0
    487e:	c9 01       	movw	r24, r18
    4880:	88 0f       	add	r24, r24
    4882:	99 1f       	adc	r25, r25
    4884:	88 0f       	add	r24, r24
    4886:	99 1f       	adc	r25, r25
    4888:	88 0f       	add	r24, r24
    488a:	99 1f       	adc	r25, r25
    488c:	82 0f       	add	r24, r18
    488e:	93 1f       	adc	r25, r19
    4890:	fc 01       	movw	r30, r24
    4892:	ea 51       	subi	r30, 0x1A	; 26
    4894:	f9 4f       	sbci	r31, 0xF9	; 249
    4896:	80 81       	ld	r24, Z
    4898:	8f 5f       	subi	r24, 0xFF	; 255
    489a:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    489c:	ef 81       	ldd	r30, Y+7	; 0x07
    489e:	f8 85       	ldd	r31, Y+8	; 0x08
    48a0:	96 89       	ldd	r25, Z+22	; 0x16
    48a2:	e0 91 cc 06 	lds	r30, 0x06CC
    48a6:	f0 91 cd 06 	lds	r31, 0x06CD
    48aa:	86 89       	ldd	r24, Z+22	; 0x16
    48ac:	89 17       	cp	r24, r25
    48ae:	18 f4       	brcc	.+6      	; 0x48b6 <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    48b0:	81 e0       	ldi	r24, 0x01	; 1
    48b2:	80 93 d6 06 	sts	0x06D6, r24
    }
}
    48b6:	2c 96       	adiw	r28, 0x0c	; 12
    48b8:	0f b6       	in	r0, 0x3f	; 63
    48ba:	f8 94       	cli
    48bc:	de bf       	out	0x3e, r29	; 62
    48be:	0f be       	out	0x3f, r0	; 63
    48c0:	cd bf       	out	0x3d, r28	; 61
    48c2:	cf 91       	pop	r28
    48c4:	df 91       	pop	r29
    48c6:	08 95       	ret

000048c8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    48c8:	df 93       	push	r29
    48ca:	cf 93       	push	r28
    48cc:	00 d0       	rcall	.+0      	; 0x48ce <vTaskSetTimeOutState+0x6>
    48ce:	cd b7       	in	r28, 0x3d	; 61
    48d0:	de b7       	in	r29, 0x3e	; 62
    48d2:	9a 83       	std	Y+2, r25	; 0x02
    48d4:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    48d6:	0f b6       	in	r0, 0x3f	; 63
    48d8:	f8 94       	cli
    48da:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    48dc:	80 91 d7 06 	lds	r24, 0x06D7
    48e0:	e9 81       	ldd	r30, Y+1	; 0x01
    48e2:	fa 81       	ldd	r31, Y+2	; 0x02
    48e4:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    48e6:	80 91 d0 06 	lds	r24, 0x06D0
    48ea:	90 91 d1 06 	lds	r25, 0x06D1
    48ee:	e9 81       	ldd	r30, Y+1	; 0x01
    48f0:	fa 81       	ldd	r31, Y+2	; 0x02
    48f2:	92 83       	std	Z+2, r25	; 0x02
    48f4:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    48f6:	0f 90       	pop	r0
    48f8:	0f be       	out	0x3f, r0	; 63
}
    48fa:	0f 90       	pop	r0
    48fc:	0f 90       	pop	r0
    48fe:	cf 91       	pop	r28
    4900:	df 91       	pop	r29
    4902:	08 95       	ret

00004904 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4904:	df 93       	push	r29
    4906:	cf 93       	push	r28
    4908:	00 d0       	rcall	.+0      	; 0x490a <vTaskInternalSetTimeOutState+0x6>
    490a:	cd b7       	in	r28, 0x3d	; 61
    490c:	de b7       	in	r29, 0x3e	; 62
    490e:	9a 83       	std	Y+2, r25	; 0x02
    4910:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    4912:	80 91 d7 06 	lds	r24, 0x06D7
    4916:	e9 81       	ldd	r30, Y+1	; 0x01
    4918:	fa 81       	ldd	r31, Y+2	; 0x02
    491a:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    491c:	80 91 d0 06 	lds	r24, 0x06D0
    4920:	90 91 d1 06 	lds	r25, 0x06D1
    4924:	e9 81       	ldd	r30, Y+1	; 0x01
    4926:	fa 81       	ldd	r31, Y+2	; 0x02
    4928:	92 83       	std	Z+2, r25	; 0x02
    492a:	81 83       	std	Z+1, r24	; 0x01
}
    492c:	0f 90       	pop	r0
    492e:	0f 90       	pop	r0
    4930:	cf 91       	pop	r28
    4932:	df 91       	pop	r29
    4934:	08 95       	ret

00004936 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    4936:	df 93       	push	r29
    4938:	cf 93       	push	r28
    493a:	cd b7       	in	r28, 0x3d	; 61
    493c:	de b7       	in	r29, 0x3e	; 62
    493e:	29 97       	sbiw	r28, 0x09	; 9
    4940:	0f b6       	in	r0, 0x3f	; 63
    4942:	f8 94       	cli
    4944:	de bf       	out	0x3e, r29	; 62
    4946:	0f be       	out	0x3f, r0	; 63
    4948:	cd bf       	out	0x3d, r28	; 61
    494a:	9f 83       	std	Y+7, r25	; 0x07
    494c:	8e 83       	std	Y+6, r24	; 0x06
    494e:	79 87       	std	Y+9, r23	; 0x09
    4950:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    4952:	0f b6       	in	r0, 0x3f	; 63
    4954:	f8 94       	cli
    4956:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    4958:	80 91 d0 06 	lds	r24, 0x06D0
    495c:	90 91 d1 06 	lds	r25, 0x06D1
    4960:	9c 83       	std	Y+4, r25	; 0x04
    4962:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4964:	ee 81       	ldd	r30, Y+6	; 0x06
    4966:	ff 81       	ldd	r31, Y+7	; 0x07
    4968:	21 81       	ldd	r18, Z+1	; 0x01
    496a:	32 81       	ldd	r19, Z+2	; 0x02
    496c:	8b 81       	ldd	r24, Y+3	; 0x03
    496e:	9c 81       	ldd	r25, Y+4	; 0x04
    4970:	82 1b       	sub	r24, r18
    4972:	93 0b       	sbc	r25, r19
    4974:	9a 83       	std	Y+2, r25	; 0x02
    4976:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4978:	ee 81       	ldd	r30, Y+6	; 0x06
    497a:	ff 81       	ldd	r31, Y+7	; 0x07
    497c:	90 81       	ld	r25, Z
    497e:	80 91 d7 06 	lds	r24, 0x06D7
    4982:	98 17       	cp	r25, r24
    4984:	81 f0       	breq	.+32     	; 0x49a6 <xTaskCheckForTimeOut+0x70>
    4986:	ee 81       	ldd	r30, Y+6	; 0x06
    4988:	ff 81       	ldd	r31, Y+7	; 0x07
    498a:	21 81       	ldd	r18, Z+1	; 0x01
    498c:	32 81       	ldd	r19, Z+2	; 0x02
    498e:	8b 81       	ldd	r24, Y+3	; 0x03
    4990:	9c 81       	ldd	r25, Y+4	; 0x04
    4992:	82 17       	cp	r24, r18
    4994:	93 07       	cpc	r25, r19
    4996:	38 f0       	brcs	.+14     	; 0x49a6 <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    4998:	81 e0       	ldi	r24, 0x01	; 1
    499a:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    499c:	e8 85       	ldd	r30, Y+8	; 0x08
    499e:	f9 85       	ldd	r31, Y+9	; 0x09
    49a0:	11 82       	std	Z+1, r1	; 0x01
    49a2:	10 82       	st	Z, r1
    49a4:	23 c0       	rjmp	.+70     	; 0x49ec <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    49a6:	e8 85       	ldd	r30, Y+8	; 0x08
    49a8:	f9 85       	ldd	r31, Y+9	; 0x09
    49aa:	20 81       	ld	r18, Z
    49ac:	31 81       	ldd	r19, Z+1	; 0x01
    49ae:	89 81       	ldd	r24, Y+1	; 0x01
    49b0:	9a 81       	ldd	r25, Y+2	; 0x02
    49b2:	82 17       	cp	r24, r18
    49b4:	93 07       	cpc	r25, r19
    49b6:	a0 f4       	brcc	.+40     	; 0x49e0 <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    49b8:	e8 85       	ldd	r30, Y+8	; 0x08
    49ba:	f9 85       	ldd	r31, Y+9	; 0x09
    49bc:	20 81       	ld	r18, Z
    49be:	31 81       	ldd	r19, Z+1	; 0x01
    49c0:	89 81       	ldd	r24, Y+1	; 0x01
    49c2:	9a 81       	ldd	r25, Y+2	; 0x02
    49c4:	a9 01       	movw	r20, r18
    49c6:	48 1b       	sub	r20, r24
    49c8:	59 0b       	sbc	r21, r25
    49ca:	ca 01       	movw	r24, r20
    49cc:	e8 85       	ldd	r30, Y+8	; 0x08
    49ce:	f9 85       	ldd	r31, Y+9	; 0x09
    49d0:	91 83       	std	Z+1, r25	; 0x01
    49d2:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    49d4:	8e 81       	ldd	r24, Y+6	; 0x06
    49d6:	9f 81       	ldd	r25, Y+7	; 0x07
    49d8:	0e 94 82 24 	call	0x4904	; 0x4904 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    49dc:	1d 82       	std	Y+5, r1	; 0x05
    49de:	06 c0       	rjmp	.+12     	; 0x49ec <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    49e0:	e8 85       	ldd	r30, Y+8	; 0x08
    49e2:	f9 85       	ldd	r31, Y+9	; 0x09
    49e4:	11 82       	std	Z+1, r1	; 0x01
    49e6:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    49e8:	81 e0       	ldi	r24, 0x01	; 1
    49ea:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    49ec:	0f 90       	pop	r0
    49ee:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    49f0:	8d 81       	ldd	r24, Y+5	; 0x05
}
    49f2:	29 96       	adiw	r28, 0x09	; 9
    49f4:	0f b6       	in	r0, 0x3f	; 63
    49f6:	f8 94       	cli
    49f8:	de bf       	out	0x3e, r29	; 62
    49fa:	0f be       	out	0x3f, r0	; 63
    49fc:	cd bf       	out	0x3d, r28	; 61
    49fe:	cf 91       	pop	r28
    4a00:	df 91       	pop	r29
    4a02:	08 95       	ret

00004a04 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4a04:	df 93       	push	r29
    4a06:	cf 93       	push	r28
    4a08:	cd b7       	in	r28, 0x3d	; 61
    4a0a:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    4a0c:	81 e0       	ldi	r24, 0x01	; 1
    4a0e:	80 93 d6 06 	sts	0x06D6, r24
}
    4a12:	cf 91       	pop	r28
    4a14:	df 91       	pop	r29
    4a16:	08 95       	ret

00004a18 <uxTaskGetTaskNumber>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

    UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
    {
    4a18:	df 93       	push	r29
    4a1a:	cf 93       	push	r28
    4a1c:	00 d0       	rcall	.+0      	; 0x4a1e <uxTaskGetTaskNumber+0x6>
    4a1e:	00 d0       	rcall	.+0      	; 0x4a20 <uxTaskGetTaskNumber+0x8>
    4a20:	0f 92       	push	r0
    4a22:	cd b7       	in	r28, 0x3d	; 61
    4a24:	de b7       	in	r29, 0x3e	; 62
    4a26:	9d 83       	std	Y+5, r25	; 0x05
    4a28:	8c 83       	std	Y+4, r24	; 0x04
        UBaseType_t uxReturn;
        TCB_t const * pxTCB;

        if( xTask != NULL )
    4a2a:	8c 81       	ldd	r24, Y+4	; 0x04
    4a2c:	9d 81       	ldd	r25, Y+5	; 0x05
    4a2e:	00 97       	sbiw	r24, 0x00	; 0
    4a30:	49 f0       	breq	.+18     	; 0x4a44 <uxTaskGetTaskNumber+0x2c>
        {
            pxTCB = xTask;
    4a32:	8c 81       	ldd	r24, Y+4	; 0x04
    4a34:	9d 81       	ldd	r25, Y+5	; 0x05
    4a36:	9a 83       	std	Y+2, r25	; 0x02
    4a38:	89 83       	std	Y+1, r24	; 0x01
            uxReturn = pxTCB->uxTaskNumber;
    4a3a:	e9 81       	ldd	r30, Y+1	; 0x01
    4a3c:	fa 81       	ldd	r31, Y+2	; 0x02
    4a3e:	82 a1       	ldd	r24, Z+34	; 0x22
    4a40:	8b 83       	std	Y+3, r24	; 0x03
    4a42:	01 c0       	rjmp	.+2      	; 0x4a46 <uxTaskGetTaskNumber+0x2e>
        }
        else
        {
            uxReturn = 0U;
    4a44:	1b 82       	std	Y+3, r1	; 0x03
        }

        return uxReturn;
    4a46:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    4a48:	0f 90       	pop	r0
    4a4a:	0f 90       	pop	r0
    4a4c:	0f 90       	pop	r0
    4a4e:	0f 90       	pop	r0
    4a50:	0f 90       	pop	r0
    4a52:	cf 91       	pop	r28
    4a54:	df 91       	pop	r29
    4a56:	08 95       	ret

00004a58 <vTaskSetTaskNumber>:

#if ( configUSE_TRACE_FACILITY == 1 )

    void vTaskSetTaskNumber( TaskHandle_t xTask,
                             const UBaseType_t uxHandle )
    {
    4a58:	df 93       	push	r29
    4a5a:	cf 93       	push	r28
    4a5c:	00 d0       	rcall	.+0      	; 0x4a5e <vTaskSetTaskNumber+0x6>
    4a5e:	00 d0       	rcall	.+0      	; 0x4a60 <vTaskSetTaskNumber+0x8>
    4a60:	0f 92       	push	r0
    4a62:	cd b7       	in	r28, 0x3d	; 61
    4a64:	de b7       	in	r29, 0x3e	; 62
    4a66:	9c 83       	std	Y+4, r25	; 0x04
    4a68:	8b 83       	std	Y+3, r24	; 0x03
    4a6a:	6d 83       	std	Y+5, r22	; 0x05
        TCB_t * pxTCB;

        if( xTask != NULL )
    4a6c:	8b 81       	ldd	r24, Y+3	; 0x03
    4a6e:	9c 81       	ldd	r25, Y+4	; 0x04
    4a70:	00 97       	sbiw	r24, 0x00	; 0
    4a72:	41 f0       	breq	.+16     	; 0x4a84 <vTaskSetTaskNumber+0x2c>
        {
            pxTCB = xTask;
    4a74:	8b 81       	ldd	r24, Y+3	; 0x03
    4a76:	9c 81       	ldd	r25, Y+4	; 0x04
    4a78:	9a 83       	std	Y+2, r25	; 0x02
    4a7a:	89 83       	std	Y+1, r24	; 0x01
            pxTCB->uxTaskNumber = uxHandle;
    4a7c:	e9 81       	ldd	r30, Y+1	; 0x01
    4a7e:	fa 81       	ldd	r31, Y+2	; 0x02
    4a80:	8d 81       	ldd	r24, Y+5	; 0x05
    4a82:	82 a3       	std	Z+34, r24	; 0x22
        }
    }
    4a84:	0f 90       	pop	r0
    4a86:	0f 90       	pop	r0
    4a88:	0f 90       	pop	r0
    4a8a:	0f 90       	pop	r0
    4a8c:	0f 90       	pop	r0
    4a8e:	cf 91       	pop	r28
    4a90:	df 91       	pop	r29
    4a92:	08 95       	ret

00004a94 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4a94:	df 93       	push	r29
    4a96:	cf 93       	push	r28
    4a98:	00 d0       	rcall	.+0      	; 0x4a9a <prvIdleTask+0x6>
    4a9a:	cd b7       	in	r28, 0x3d	; 61
    4a9c:	de b7       	in	r29, 0x3e	; 62
    4a9e:	9a 83       	std	Y+2, r25	; 0x02
    4aa0:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    4aa2:	0e 94 97 25 	call	0x4b2e	; 0x4b2e <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    4aa6:	80 91 e6 06 	lds	r24, 0x06E6
    4aaa:	82 30       	cpi	r24, 0x02	; 2
    4aac:	d0 f3       	brcs	.-12     	; 0x4aa2 <prvIdleTask+0xe>
                {
                    taskYIELD();
    4aae:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    4ab2:	f7 cf       	rjmp	.-18     	; 0x4aa2 <prvIdleTask+0xe>

00004ab4 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4ab4:	df 93       	push	r29
    4ab6:	cf 93       	push	r28
    4ab8:	0f 92       	push	r0
    4aba:	cd b7       	in	r28, 0x3d	; 61
    4abc:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4abe:	19 82       	std	Y+1, r1	; 0x01
    4ac0:	13 c0       	rjmp	.+38     	; 0x4ae8 <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4ac2:	89 81       	ldd	r24, Y+1	; 0x01
    4ac4:	28 2f       	mov	r18, r24
    4ac6:	30 e0       	ldi	r19, 0x00	; 0
    4ac8:	c9 01       	movw	r24, r18
    4aca:	88 0f       	add	r24, r24
    4acc:	99 1f       	adc	r25, r25
    4ace:	88 0f       	add	r24, r24
    4ad0:	99 1f       	adc	r25, r25
    4ad2:	88 0f       	add	r24, r24
    4ad4:	99 1f       	adc	r25, r25
    4ad6:	82 0f       	add	r24, r18
    4ad8:	93 1f       	adc	r25, r19
    4ada:	8a 51       	subi	r24, 0x1A	; 26
    4adc:	99 4f       	sbci	r25, 0xF9	; 249
    4ade:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4ae2:	89 81       	ldd	r24, Y+1	; 0x01
    4ae4:	8f 5f       	subi	r24, 0xFF	; 255
    4ae6:	89 83       	std	Y+1, r24	; 0x01
    4ae8:	89 81       	ldd	r24, Y+1	; 0x01
    4aea:	84 30       	cpi	r24, 0x04	; 4
    4aec:	50 f3       	brcs	.-44     	; 0x4ac2 <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    4aee:	8a e0       	ldi	r24, 0x0A	; 10
    4af0:	97 e0       	ldi	r25, 0x07	; 7
    4af2:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    4af6:	83 e1       	ldi	r24, 0x13	; 19
    4af8:	97 e0       	ldi	r25, 0x07	; 7
    4afa:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    4afe:	80 e2       	ldi	r24, 0x20	; 32
    4b00:	97 e0       	ldi	r25, 0x07	; 7
    4b02:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    4b06:	89 e2       	ldi	r24, 0x29	; 41
    4b08:	97 e0       	ldi	r25, 0x07	; 7
    4b0a:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    4b0e:	8a e0       	ldi	r24, 0x0A	; 10
    4b10:	97 e0       	ldi	r25, 0x07	; 7
    4b12:	90 93 1d 07 	sts	0x071D, r25
    4b16:	80 93 1c 07 	sts	0x071C, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4b1a:	83 e1       	ldi	r24, 0x13	; 19
    4b1c:	97 e0       	ldi	r25, 0x07	; 7
    4b1e:	90 93 1f 07 	sts	0x071F, r25
    4b22:	80 93 1e 07 	sts	0x071E, r24
}
    4b26:	0f 90       	pop	r0
    4b28:	cf 91       	pop	r28
    4b2a:	df 91       	pop	r29
    4b2c:	08 95       	ret

00004b2e <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4b2e:	df 93       	push	r29
    4b30:	cf 93       	push	r28
    4b32:	00 d0       	rcall	.+0      	; 0x4b34 <prvCheckTasksWaitingTermination+0x6>
    4b34:	cd b7       	in	r28, 0x3d	; 61
    4b36:	de b7       	in	r29, 0x3e	; 62
    4b38:	20 c0       	rjmp	.+64     	; 0x4b7a <prvCheckTasksWaitingTermination+0x4c>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    4b3a:	0f b6       	in	r0, 0x3f	; 63
    4b3c:	f8 94       	cli
    4b3e:	0f 92       	push	r0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4b40:	e0 91 2e 07 	lds	r30, 0x072E
    4b44:	f0 91 2f 07 	lds	r31, 0x072F
    4b48:	86 81       	ldd	r24, Z+6	; 0x06
    4b4a:	97 81       	ldd	r25, Z+7	; 0x07
    4b4c:	9a 83       	std	Y+2, r25	; 0x02
    4b4e:	89 83       	std	Y+1, r24	; 0x01
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4b50:	89 81       	ldd	r24, Y+1	; 0x01
    4b52:	9a 81       	ldd	r25, Y+2	; 0x02
    4b54:	02 96       	adiw	r24, 0x02	; 2
    4b56:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <uxListRemove>
                    --uxCurrentNumberOfTasks;
    4b5a:	80 91 cf 06 	lds	r24, 0x06CF
    4b5e:	81 50       	subi	r24, 0x01	; 1
    4b60:	80 93 cf 06 	sts	0x06CF, r24
                    --uxDeletedTasksWaitingCleanUp;
    4b64:	80 91 ce 06 	lds	r24, 0x06CE
    4b68:	81 50       	subi	r24, 0x01	; 1
    4b6a:	80 93 ce 06 	sts	0x06CE, r24
                }
                taskEXIT_CRITICAL();
    4b6e:	0f 90       	pop	r0
    4b70:	0f be       	out	0x3f, r0	; 63

                prvDeleteTCB( pxTCB );
    4b72:	89 81       	ldd	r24, Y+1	; 0x01
    4b74:	9a 81       	ldd	r25, Y+2	; 0x02
    4b76:	0e 94 18 27 	call	0x4e30	; 0x4e30 <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    4b7a:	80 91 ce 06 	lds	r24, 0x06CE
    4b7e:	88 23       	and	r24, r24
    4b80:	e1 f6       	brne	.-72     	; 0x4b3a <prvCheckTasksWaitingTermination+0xc>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    4b82:	0f 90       	pop	r0
    4b84:	0f 90       	pop	r0
    4b86:	cf 91       	pop	r28
    4b88:	df 91       	pop	r29
    4b8a:	08 95       	ret

00004b8c <vTaskGetInfo>:

    void vTaskGetInfo( TaskHandle_t xTask,
                       TaskStatus_t * pxTaskStatus,
                       BaseType_t xGetFreeStackSpace,
                       eTaskState eState )
    {
    4b8c:	df 93       	push	r29
    4b8e:	cf 93       	push	r28
    4b90:	cd b7       	in	r28, 0x3d	; 61
    4b92:	de b7       	in	r29, 0x3e	; 62
    4b94:	2a 97       	sbiw	r28, 0x0a	; 10
    4b96:	0f b6       	in	r0, 0x3f	; 63
    4b98:	f8 94       	cli
    4b9a:	de bf       	out	0x3e, r29	; 62
    4b9c:	0f be       	out	0x3f, r0	; 63
    4b9e:	cd bf       	out	0x3d, r28	; 61
    4ba0:	9c 83       	std	Y+4, r25	; 0x04
    4ba2:	8b 83       	std	Y+3, r24	; 0x03
    4ba4:	7e 83       	std	Y+6, r23	; 0x06
    4ba6:	6d 83       	std	Y+5, r22	; 0x05
    4ba8:	4f 83       	std	Y+7, r20	; 0x07
    4baa:	28 87       	std	Y+8, r18	; 0x08
        TCB_t * pxTCB;

        /* xTask is NULL then get the state of the calling task. */
        pxTCB = prvGetTCBFromHandle( xTask );
    4bac:	8b 81       	ldd	r24, Y+3	; 0x03
    4bae:	9c 81       	ldd	r25, Y+4	; 0x04
    4bb0:	00 97       	sbiw	r24, 0x00	; 0
    4bb2:	39 f4       	brne	.+14     	; 0x4bc2 <vTaskGetInfo+0x36>
    4bb4:	80 91 cc 06 	lds	r24, 0x06CC
    4bb8:	90 91 cd 06 	lds	r25, 0x06CD
    4bbc:	9a 87       	std	Y+10, r25	; 0x0a
    4bbe:	89 87       	std	Y+9, r24	; 0x09
    4bc0:	04 c0       	rjmp	.+8      	; 0x4bca <vTaskGetInfo+0x3e>
    4bc2:	8b 81       	ldd	r24, Y+3	; 0x03
    4bc4:	9c 81       	ldd	r25, Y+4	; 0x04
    4bc6:	9a 87       	std	Y+10, r25	; 0x0a
    4bc8:	89 87       	std	Y+9, r24	; 0x09
    4bca:	89 85       	ldd	r24, Y+9	; 0x09
    4bcc:	9a 85       	ldd	r25, Y+10	; 0x0a
    4bce:	9a 83       	std	Y+2, r25	; 0x02
    4bd0:	89 83       	std	Y+1, r24	; 0x01

        pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
    4bd2:	ed 81       	ldd	r30, Y+5	; 0x05
    4bd4:	fe 81       	ldd	r31, Y+6	; 0x06
    4bd6:	89 81       	ldd	r24, Y+1	; 0x01
    4bd8:	9a 81       	ldd	r25, Y+2	; 0x02
    4bda:	91 83       	std	Z+1, r25	; 0x01
    4bdc:	80 83       	st	Z, r24
        pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName[ 0 ] );
    4bde:	89 81       	ldd	r24, Y+1	; 0x01
    4be0:	9a 81       	ldd	r25, Y+2	; 0x02
    4be2:	49 96       	adiw	r24, 0x19	; 25
    4be4:	ed 81       	ldd	r30, Y+5	; 0x05
    4be6:	fe 81       	ldd	r31, Y+6	; 0x06
    4be8:	93 83       	std	Z+3, r25	; 0x03
    4bea:	82 83       	std	Z+2, r24	; 0x02
        pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
    4bec:	e9 81       	ldd	r30, Y+1	; 0x01
    4bee:	fa 81       	ldd	r31, Y+2	; 0x02
    4bf0:	86 89       	ldd	r24, Z+22	; 0x16
    4bf2:	ed 81       	ldd	r30, Y+5	; 0x05
    4bf4:	fe 81       	ldd	r31, Y+6	; 0x06
    4bf6:	86 83       	std	Z+6, r24	; 0x06
        pxTaskStatus->pxStackBase = pxTCB->pxStack;
    4bf8:	e9 81       	ldd	r30, Y+1	; 0x01
    4bfa:	fa 81       	ldd	r31, Y+2	; 0x02
    4bfc:	87 89       	ldd	r24, Z+23	; 0x17
    4bfe:	90 8d       	ldd	r25, Z+24	; 0x18
    4c00:	ed 81       	ldd	r30, Y+5	; 0x05
    4c02:	fe 81       	ldd	r31, Y+6	; 0x06
    4c04:	95 87       	std	Z+13, r25	; 0x0d
    4c06:	84 87       	std	Z+12, r24	; 0x0c
        pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
    4c08:	e9 81       	ldd	r30, Y+1	; 0x01
    4c0a:	fa 81       	ldd	r31, Y+2	; 0x02
    4c0c:	81 a1       	ldd	r24, Z+33	; 0x21
    4c0e:	ed 81       	ldd	r30, Y+5	; 0x05
    4c10:	fe 81       	ldd	r31, Y+6	; 0x06
    4c12:	84 83       	std	Z+4, r24	; 0x04
            {
                pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
            }
        #else
            {
                pxTaskStatus->uxBasePriority = 0;
    4c14:	ed 81       	ldd	r30, Y+5	; 0x05
    4c16:	fe 81       	ldd	r31, Y+6	; 0x06
    4c18:	17 82       	std	Z+7, r1	; 0x07
            }
        #endif

        #if ( configGENERATE_RUN_TIME_STATS == 1 )
            {
                pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
    4c1a:	e9 81       	ldd	r30, Y+1	; 0x01
    4c1c:	fa 81       	ldd	r31, Y+2	; 0x02
    4c1e:	83 a1       	ldd	r24, Z+35	; 0x23
    4c20:	94 a1       	ldd	r25, Z+36	; 0x24
    4c22:	a5 a1       	ldd	r26, Z+37	; 0x25
    4c24:	b6 a1       	ldd	r27, Z+38	; 0x26
    4c26:	ed 81       	ldd	r30, Y+5	; 0x05
    4c28:	fe 81       	ldd	r31, Y+6	; 0x06
    4c2a:	80 87       	std	Z+8, r24	; 0x08
    4c2c:	91 87       	std	Z+9, r25	; 0x09
    4c2e:	a2 87       	std	Z+10, r26	; 0x0a
    4c30:	b3 87       	std	Z+11, r27	; 0x0b
        #endif

        /* Obtaining the task state is a little fiddly, so is only done if the
         * value of eState passed into this function is eInvalid - otherwise the
         * state is just set to whatever is passed in. */
        if( eState != eInvalid )
    4c32:	88 85       	ldd	r24, Y+8	; 0x08
    4c34:	85 30       	cpi	r24, 0x05	; 5
    4c36:	91 f0       	breq	.+36     	; 0x4c5c <vTaskGetInfo+0xd0>
        {
            if( pxTCB == pxCurrentTCB )
    4c38:	20 91 cc 06 	lds	r18, 0x06CC
    4c3c:	30 91 cd 06 	lds	r19, 0x06CD
    4c40:	89 81       	ldd	r24, Y+1	; 0x01
    4c42:	9a 81       	ldd	r25, Y+2	; 0x02
    4c44:	82 17       	cp	r24, r18
    4c46:	93 07       	cpc	r25, r19
    4c48:	21 f4       	brne	.+8      	; 0x4c52 <vTaskGetInfo+0xc6>
            {
                pxTaskStatus->eCurrentState = eRunning;
    4c4a:	ed 81       	ldd	r30, Y+5	; 0x05
    4c4c:	fe 81       	ldd	r31, Y+6	; 0x06
    4c4e:	15 82       	std	Z+5, r1	; 0x05
    4c50:	0c c0       	rjmp	.+24     	; 0x4c6a <vTaskGetInfo+0xde>
            }
            else
            {
                pxTaskStatus->eCurrentState = eState;
    4c52:	ed 81       	ldd	r30, Y+5	; 0x05
    4c54:	fe 81       	ldd	r31, Y+6	; 0x06
    4c56:	88 85       	ldd	r24, Y+8	; 0x08
    4c58:	85 83       	std	Z+5, r24	; 0x05
    4c5a:	07 c0       	rjmp	.+14     	; 0x4c6a <vTaskGetInfo+0xde>
                #endif /* INCLUDE_vTaskSuspend */
            }
        }
        else
        {
            pxTaskStatus->eCurrentState = eTaskGetState( pxTCB );
    4c5c:	89 81       	ldd	r24, Y+1	; 0x01
    4c5e:	9a 81       	ldd	r25, Y+2	; 0x02
    4c60:	0e 94 8d 1b 	call	0x371a	; 0x371a <eTaskGetState>
    4c64:	ed 81       	ldd	r30, Y+5	; 0x05
    4c66:	fe 81       	ldd	r31, Y+6	; 0x06
    4c68:	85 83       	std	Z+5, r24	; 0x05
        }

        /* Obtaining the stack space takes some time, so the xGetFreeStackSpace
         * parameter is provided to allow it to be skipped. */
        if( xGetFreeStackSpace != pdFALSE )
    4c6a:	8f 81       	ldd	r24, Y+7	; 0x07
    4c6c:	88 23       	and	r24, r24
    4c6e:	59 f0       	breq	.+22     	; 0x4c86 <vTaskGetInfo+0xfa>
                {
                    pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
                }
            #else
                {
                    pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
    4c70:	e9 81       	ldd	r30, Y+1	; 0x01
    4c72:	fa 81       	ldd	r31, Y+2	; 0x02
    4c74:	87 89       	ldd	r24, Z+23	; 0x17
    4c76:	90 8d       	ldd	r25, Z+24	; 0x18
    4c78:	0e 94 ea 26 	call	0x4dd4	; 0x4dd4 <prvTaskCheckFreeStackSpace>
    4c7c:	ed 81       	ldd	r30, Y+5	; 0x05
    4c7e:	fe 81       	ldd	r31, Y+6	; 0x06
    4c80:	97 87       	std	Z+15, r25	; 0x0f
    4c82:	86 87       	std	Z+14, r24	; 0x0e
    4c84:	04 c0       	rjmp	.+8      	; 0x4c8e <vTaskGetInfo+0x102>
                }
            #endif
        }
        else
        {
            pxTaskStatus->usStackHighWaterMark = 0;
    4c86:	ed 81       	ldd	r30, Y+5	; 0x05
    4c88:	fe 81       	ldd	r31, Y+6	; 0x06
    4c8a:	17 86       	std	Z+15, r1	; 0x0f
    4c8c:	16 86       	std	Z+14, r1	; 0x0e
        }
    }
    4c8e:	2a 96       	adiw	r28, 0x0a	; 10
    4c90:	0f b6       	in	r0, 0x3f	; 63
    4c92:	f8 94       	cli
    4c94:	de bf       	out	0x3e, r29	; 62
    4c96:	0f be       	out	0x3f, r0	; 63
    4c98:	cd bf       	out	0x3d, r28	; 61
    4c9a:	cf 91       	pop	r28
    4c9c:	df 91       	pop	r29
    4c9e:	08 95       	ret

00004ca0 <prvListTasksWithinSingleList>:
#if ( configUSE_TRACE_FACILITY == 1 )

    static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t * pxTaskStatusArray,
                                                     List_t * pxList,
                                                     eTaskState eState )
    {
    4ca0:	df 93       	push	r29
    4ca2:	cf 93       	push	r28
    4ca4:	cd b7       	in	r28, 0x3d	; 61
    4ca6:	de b7       	in	r29, 0x3e	; 62
    4ca8:	2e 97       	sbiw	r28, 0x0e	; 14
    4caa:	0f b6       	in	r0, 0x3f	; 63
    4cac:	f8 94       	cli
    4cae:	de bf       	out	0x3e, r29	; 62
    4cb0:	0f be       	out	0x3f, r0	; 63
    4cb2:	cd bf       	out	0x3d, r28	; 61
    4cb4:	9b 87       	std	Y+11, r25	; 0x0b
    4cb6:	8a 87       	std	Y+10, r24	; 0x0a
    4cb8:	7d 87       	std	Y+13, r23	; 0x0d
    4cba:	6c 87       	std	Y+12, r22	; 0x0c
    4cbc:	4e 87       	std	Y+14, r20	; 0x0e
        configLIST_VOLATILE TCB_t * pxNextTCB, * pxFirstTCB;
        UBaseType_t uxTask = 0;
    4cbe:	1d 82       	std	Y+5, r1	; 0x05

        if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
    4cc0:	ec 85       	ldd	r30, Y+12	; 0x0c
    4cc2:	fd 85       	ldd	r31, Y+13	; 0x0d
    4cc4:	80 81       	ld	r24, Z
    4cc6:	88 23       	and	r24, r24
    4cc8:	09 f4       	brne	.+2      	; 0x4ccc <prvListTasksWithinSingleList+0x2c>
    4cca:	7a c0       	rjmp	.+244    	; 0x4dc0 <prvListTasksWithinSingleList+0x120>
        {
            listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4ccc:	8c 85       	ldd	r24, Y+12	; 0x0c
    4cce:	9d 85       	ldd	r25, Y+13	; 0x0d
    4cd0:	9c 83       	std	Y+4, r25	; 0x04
    4cd2:	8b 83       	std	Y+3, r24	; 0x03
    4cd4:	eb 81       	ldd	r30, Y+3	; 0x03
    4cd6:	fc 81       	ldd	r31, Y+4	; 0x04
    4cd8:	01 80       	ldd	r0, Z+1	; 0x01
    4cda:	f2 81       	ldd	r31, Z+2	; 0x02
    4cdc:	e0 2d       	mov	r30, r0
    4cde:	82 81       	ldd	r24, Z+2	; 0x02
    4ce0:	93 81       	ldd	r25, Z+3	; 0x03
    4ce2:	eb 81       	ldd	r30, Y+3	; 0x03
    4ce4:	fc 81       	ldd	r31, Y+4	; 0x04
    4ce6:	92 83       	std	Z+2, r25	; 0x02
    4ce8:	81 83       	std	Z+1, r24	; 0x01
    4cea:	eb 81       	ldd	r30, Y+3	; 0x03
    4cec:	fc 81       	ldd	r31, Y+4	; 0x04
    4cee:	21 81       	ldd	r18, Z+1	; 0x01
    4cf0:	32 81       	ldd	r19, Z+2	; 0x02
    4cf2:	8b 81       	ldd	r24, Y+3	; 0x03
    4cf4:	9c 81       	ldd	r25, Y+4	; 0x04
    4cf6:	03 96       	adiw	r24, 0x03	; 3
    4cf8:	28 17       	cp	r18, r24
    4cfa:	39 07       	cpc	r19, r25
    4cfc:	59 f4       	brne	.+22     	; 0x4d14 <prvListTasksWithinSingleList+0x74>
    4cfe:	eb 81       	ldd	r30, Y+3	; 0x03
    4d00:	fc 81       	ldd	r31, Y+4	; 0x04
    4d02:	01 80       	ldd	r0, Z+1	; 0x01
    4d04:	f2 81       	ldd	r31, Z+2	; 0x02
    4d06:	e0 2d       	mov	r30, r0
    4d08:	82 81       	ldd	r24, Z+2	; 0x02
    4d0a:	93 81       	ldd	r25, Z+3	; 0x03
    4d0c:	eb 81       	ldd	r30, Y+3	; 0x03
    4d0e:	fc 81       	ldd	r31, Y+4	; 0x04
    4d10:	92 83       	std	Z+2, r25	; 0x02
    4d12:	81 83       	std	Z+1, r24	; 0x01
    4d14:	eb 81       	ldd	r30, Y+3	; 0x03
    4d16:	fc 81       	ldd	r31, Y+4	; 0x04
    4d18:	01 80       	ldd	r0, Z+1	; 0x01
    4d1a:	f2 81       	ldd	r31, Z+2	; 0x02
    4d1c:	e0 2d       	mov	r30, r0
    4d1e:	86 81       	ldd	r24, Z+6	; 0x06
    4d20:	97 81       	ldd	r25, Z+7	; 0x07
    4d22:	9f 83       	std	Y+7, r25	; 0x07
    4d24:	8e 83       	std	Y+6, r24	; 0x06
             * pxTaskStatusArray array for each task that is referenced from
             * pxList.  See the definition of TaskStatus_t in task.h for the
             * meaning of each TaskStatus_t structure member. */
            do
            {
                listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4d26:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d28:	9d 85       	ldd	r25, Y+13	; 0x0d
    4d2a:	9a 83       	std	Y+2, r25	; 0x02
    4d2c:	89 83       	std	Y+1, r24	; 0x01
    4d2e:	e9 81       	ldd	r30, Y+1	; 0x01
    4d30:	fa 81       	ldd	r31, Y+2	; 0x02
    4d32:	01 80       	ldd	r0, Z+1	; 0x01
    4d34:	f2 81       	ldd	r31, Z+2	; 0x02
    4d36:	e0 2d       	mov	r30, r0
    4d38:	82 81       	ldd	r24, Z+2	; 0x02
    4d3a:	93 81       	ldd	r25, Z+3	; 0x03
    4d3c:	e9 81       	ldd	r30, Y+1	; 0x01
    4d3e:	fa 81       	ldd	r31, Y+2	; 0x02
    4d40:	92 83       	std	Z+2, r25	; 0x02
    4d42:	81 83       	std	Z+1, r24	; 0x01
    4d44:	e9 81       	ldd	r30, Y+1	; 0x01
    4d46:	fa 81       	ldd	r31, Y+2	; 0x02
    4d48:	21 81       	ldd	r18, Z+1	; 0x01
    4d4a:	32 81       	ldd	r19, Z+2	; 0x02
    4d4c:	89 81       	ldd	r24, Y+1	; 0x01
    4d4e:	9a 81       	ldd	r25, Y+2	; 0x02
    4d50:	03 96       	adiw	r24, 0x03	; 3
    4d52:	28 17       	cp	r18, r24
    4d54:	39 07       	cpc	r19, r25
    4d56:	59 f4       	brne	.+22     	; 0x4d6e <prvListTasksWithinSingleList+0xce>
    4d58:	e9 81       	ldd	r30, Y+1	; 0x01
    4d5a:	fa 81       	ldd	r31, Y+2	; 0x02
    4d5c:	01 80       	ldd	r0, Z+1	; 0x01
    4d5e:	f2 81       	ldd	r31, Z+2	; 0x02
    4d60:	e0 2d       	mov	r30, r0
    4d62:	82 81       	ldd	r24, Z+2	; 0x02
    4d64:	93 81       	ldd	r25, Z+3	; 0x03
    4d66:	e9 81       	ldd	r30, Y+1	; 0x01
    4d68:	fa 81       	ldd	r31, Y+2	; 0x02
    4d6a:	92 83       	std	Z+2, r25	; 0x02
    4d6c:	81 83       	std	Z+1, r24	; 0x01
    4d6e:	e9 81       	ldd	r30, Y+1	; 0x01
    4d70:	fa 81       	ldd	r31, Y+2	; 0x02
    4d72:	01 80       	ldd	r0, Z+1	; 0x01
    4d74:	f2 81       	ldd	r31, Z+2	; 0x02
    4d76:	e0 2d       	mov	r30, r0
    4d78:	86 81       	ldd	r24, Z+6	; 0x06
    4d7a:	97 81       	ldd	r25, Z+7	; 0x07
    4d7c:	99 87       	std	Y+9, r25	; 0x09
    4d7e:	88 87       	std	Y+8, r24	; 0x08
                vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
    4d80:	8d 81       	ldd	r24, Y+5	; 0x05
    4d82:	88 2f       	mov	r24, r24
    4d84:	90 e0       	ldi	r25, 0x00	; 0
    4d86:	9c 01       	movw	r18, r24
    4d88:	22 95       	swap	r18
    4d8a:	32 95       	swap	r19
    4d8c:	30 7f       	andi	r19, 0xF0	; 240
    4d8e:	32 27       	eor	r19, r18
    4d90:	20 7f       	andi	r18, 0xF0	; 240
    4d92:	32 27       	eor	r19, r18
    4d94:	8a 85       	ldd	r24, Y+10	; 0x0a
    4d96:	9b 85       	ldd	r25, Y+11	; 0x0b
    4d98:	28 0f       	add	r18, r24
    4d9a:	39 1f       	adc	r19, r25
    4d9c:	88 85       	ldd	r24, Y+8	; 0x08
    4d9e:	99 85       	ldd	r25, Y+9	; 0x09
    4da0:	b9 01       	movw	r22, r18
    4da2:	41 e0       	ldi	r20, 0x01	; 1
    4da4:	2e 85       	ldd	r18, Y+14	; 0x0e
    4da6:	0e 94 c6 25 	call	0x4b8c	; 0x4b8c <vTaskGetInfo>
                uxTask++;
    4daa:	8d 81       	ldd	r24, Y+5	; 0x05
    4dac:	8f 5f       	subi	r24, 0xFF	; 255
    4dae:	8d 83       	std	Y+5, r24	; 0x05
            } while( pxNextTCB != pxFirstTCB );
    4db0:	28 85       	ldd	r18, Y+8	; 0x08
    4db2:	39 85       	ldd	r19, Y+9	; 0x09
    4db4:	8e 81       	ldd	r24, Y+6	; 0x06
    4db6:	9f 81       	ldd	r25, Y+7	; 0x07
    4db8:	28 17       	cp	r18, r24
    4dba:	39 07       	cpc	r19, r25
    4dbc:	09 f0       	breq	.+2      	; 0x4dc0 <prvListTasksWithinSingleList+0x120>
    4dbe:	b3 cf       	rjmp	.-154    	; 0x4d26 <prvListTasksWithinSingleList+0x86>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return uxTask;
    4dc0:	8d 81       	ldd	r24, Y+5	; 0x05
    }
    4dc2:	2e 96       	adiw	r28, 0x0e	; 14
    4dc4:	0f b6       	in	r0, 0x3f	; 63
    4dc6:	f8 94       	cli
    4dc8:	de bf       	out	0x3e, r29	; 62
    4dca:	0f be       	out	0x3f, r0	; 63
    4dcc:	cd bf       	out	0x3d, r28	; 61
    4dce:	cf 91       	pop	r28
    4dd0:	df 91       	pop	r29
    4dd2:	08 95       	ret

00004dd4 <prvTaskCheckFreeStackSpace>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark2 == 1 ) )

    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
    {
    4dd4:	df 93       	push	r29
    4dd6:	cf 93       	push	r28
    4dd8:	00 d0       	rcall	.+0      	; 0x4dda <prvTaskCheckFreeStackSpace+0x6>
    4dda:	00 d0       	rcall	.+0      	; 0x4ddc <prvTaskCheckFreeStackSpace+0x8>
    4ddc:	00 d0       	rcall	.+0      	; 0x4dde <prvTaskCheckFreeStackSpace+0xa>
    4dde:	cd b7       	in	r28, 0x3d	; 61
    4de0:	de b7       	in	r29, 0x3e	; 62
    4de2:	9e 83       	std	Y+6, r25	; 0x06
    4de4:	8d 83       	std	Y+5, r24	; 0x05
        uint32_t ulCount = 0U;
    4de6:	19 82       	std	Y+1, r1	; 0x01
    4de8:	1a 82       	std	Y+2, r1	; 0x02
    4dea:	1b 82       	std	Y+3, r1	; 0x03
    4dec:	1c 82       	std	Y+4, r1	; 0x04
    4dee:	10 c0       	rjmp	.+32     	; 0x4e10 <prvTaskCheckFreeStackSpace+0x3c>

        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
        {
            pucStackByte -= portSTACK_GROWTH;
    4df0:	8d 81       	ldd	r24, Y+5	; 0x05
    4df2:	9e 81       	ldd	r25, Y+6	; 0x06
    4df4:	01 96       	adiw	r24, 0x01	; 1
    4df6:	9e 83       	std	Y+6, r25	; 0x06
    4df8:	8d 83       	std	Y+5, r24	; 0x05
            ulCount++;
    4dfa:	89 81       	ldd	r24, Y+1	; 0x01
    4dfc:	9a 81       	ldd	r25, Y+2	; 0x02
    4dfe:	ab 81       	ldd	r26, Y+3	; 0x03
    4e00:	bc 81       	ldd	r27, Y+4	; 0x04
    4e02:	01 96       	adiw	r24, 0x01	; 1
    4e04:	a1 1d       	adc	r26, r1
    4e06:	b1 1d       	adc	r27, r1
    4e08:	89 83       	std	Y+1, r24	; 0x01
    4e0a:	9a 83       	std	Y+2, r25	; 0x02
    4e0c:	ab 83       	std	Y+3, r26	; 0x03
    4e0e:	bc 83       	std	Y+4, r27	; 0x04

    static configSTACK_DEPTH_TYPE prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
    {
        uint32_t ulCount = 0U;

        while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
    4e10:	ed 81       	ldd	r30, Y+5	; 0x05
    4e12:	fe 81       	ldd	r31, Y+6	; 0x06
    4e14:	80 81       	ld	r24, Z
    4e16:	85 3a       	cpi	r24, 0xA5	; 165
    4e18:	59 f3       	breq	.-42     	; 0x4df0 <prvTaskCheckFreeStackSpace+0x1c>
            ulCount++;
        }

        ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */

        return ( configSTACK_DEPTH_TYPE ) ulCount;
    4e1a:	89 81       	ldd	r24, Y+1	; 0x01
    4e1c:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    4e1e:	26 96       	adiw	r28, 0x06	; 6
    4e20:	0f b6       	in	r0, 0x3f	; 63
    4e22:	f8 94       	cli
    4e24:	de bf       	out	0x3e, r29	; 62
    4e26:	0f be       	out	0x3f, r0	; 63
    4e28:	cd bf       	out	0x3d, r28	; 61
    4e2a:	cf 91       	pop	r28
    4e2c:	df 91       	pop	r29
    4e2e:	08 95       	ret

00004e30 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    4e30:	df 93       	push	r29
    4e32:	cf 93       	push	r28
    4e34:	00 d0       	rcall	.+0      	; 0x4e36 <prvDeleteTCB+0x6>
    4e36:	cd b7       	in	r28, 0x3d	; 61
    4e38:	de b7       	in	r29, 0x3e	; 62
    4e3a:	9a 83       	std	Y+2, r25	; 0x02
    4e3c:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    4e3e:	e9 81       	ldd	r30, Y+1	; 0x01
    4e40:	fa 81       	ldd	r31, Y+2	; 0x02
    4e42:	87 89       	ldd	r24, Z+23	; 0x17
    4e44:	90 8d       	ldd	r25, Z+24	; 0x18
    4e46:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                vPortFree( pxTCB );
    4e4a:	89 81       	ldd	r24, Y+1	; 0x01
    4e4c:	9a 81       	ldd	r25, Y+2	; 0x02
    4e4e:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    4e52:	0f 90       	pop	r0
    4e54:	0f 90       	pop	r0
    4e56:	cf 91       	pop	r28
    4e58:	df 91       	pop	r29
    4e5a:	08 95       	ret

00004e5c <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4e5c:	df 93       	push	r29
    4e5e:	cf 93       	push	r28
    4e60:	cd b7       	in	r28, 0x3d	; 61
    4e62:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4e64:	e0 91 1c 07 	lds	r30, 0x071C
    4e68:	f0 91 1d 07 	lds	r31, 0x071D
    4e6c:	80 81       	ld	r24, Z
    4e6e:	88 23       	and	r24, r24
    4e70:	39 f4       	brne	.+14     	; 0x4e80 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    4e72:	8f ef       	ldi	r24, 0xFF	; 255
    4e74:	9f ef       	ldi	r25, 0xFF	; 255
    4e76:	90 93 da 06 	sts	0x06DA, r25
    4e7a:	80 93 d9 06 	sts	0x06D9, r24
    4e7e:	0d c0       	rjmp	.+26     	; 0x4e9a <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    4e80:	e0 91 1c 07 	lds	r30, 0x071C
    4e84:	f0 91 1d 07 	lds	r31, 0x071D
    4e88:	05 80       	ldd	r0, Z+5	; 0x05
    4e8a:	f6 81       	ldd	r31, Z+6	; 0x06
    4e8c:	e0 2d       	mov	r30, r0
    4e8e:	80 81       	ld	r24, Z
    4e90:	91 81       	ldd	r25, Z+1	; 0x01
    4e92:	90 93 da 06 	sts	0x06DA, r25
    4e96:	80 93 d9 06 	sts	0x06D9, r24
    }
}
    4e9a:	cf 91       	pop	r28
    4e9c:	df 91       	pop	r29
    4e9e:	08 95       	ret

00004ea0 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
    4ea0:	df 93       	push	r29
    4ea2:	cf 93       	push	r28
    4ea4:	0f 92       	push	r0
    4ea6:	cd b7       	in	r28, 0x3d	; 61
    4ea8:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
    4eaa:	80 91 d3 06 	lds	r24, 0x06D3
    4eae:	88 23       	and	r24, r24
    4eb0:	19 f4       	brne	.+6      	; 0x4eb8 <xTaskGetSchedulerState+0x18>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
    4eb2:	81 e0       	ldi	r24, 0x01	; 1
    4eb4:	89 83       	std	Y+1, r24	; 0x01
    4eb6:	08 c0       	rjmp	.+16     	; 0x4ec8 <xTaskGetSchedulerState+0x28>
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4eb8:	80 91 dd 06 	lds	r24, 0x06DD
    4ebc:	88 23       	and	r24, r24
    4ebe:	19 f4       	brne	.+6      	; 0x4ec6 <xTaskGetSchedulerState+0x26>
            {
                xReturn = taskSCHEDULER_RUNNING;
    4ec0:	82 e0       	ldi	r24, 0x02	; 2
    4ec2:	89 83       	std	Y+1, r24	; 0x01
    4ec4:	01 c0       	rjmp	.+2      	; 0x4ec8 <xTaskGetSchedulerState+0x28>
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
    4ec6:	19 82       	std	Y+1, r1	; 0x01
            }
        }

        return xReturn;
    4ec8:	89 81       	ldd	r24, Y+1	; 0x01
    }
    4eca:	0f 90       	pop	r0
    4ecc:	cf 91       	pop	r28
    4ece:	df 91       	pop	r29
    4ed0:	08 95       	ret

00004ed2 <prvWriteNameToBuffer>:

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )

    static char * prvWriteNameToBuffer( char * pcBuffer,
                                        const char * pcTaskName )
    {
    4ed2:	df 93       	push	r29
    4ed4:	cf 93       	push	r28
    4ed6:	00 d0       	rcall	.+0      	; 0x4ed8 <prvWriteNameToBuffer+0x6>
    4ed8:	00 d0       	rcall	.+0      	; 0x4eda <prvWriteNameToBuffer+0x8>
    4eda:	00 d0       	rcall	.+0      	; 0x4edc <prvWriteNameToBuffer+0xa>
    4edc:	cd b7       	in	r28, 0x3d	; 61
    4ede:	de b7       	in	r29, 0x3e	; 62
    4ee0:	9c 83       	std	Y+4, r25	; 0x04
    4ee2:	8b 83       	std	Y+3, r24	; 0x03
    4ee4:	7e 83       	std	Y+6, r23	; 0x06
    4ee6:	6d 83       	std	Y+5, r22	; 0x05
        size_t x;

        /* Start by copying the entire string. */
        strcpy( pcBuffer, pcTaskName );
    4ee8:	8b 81       	ldd	r24, Y+3	; 0x03
    4eea:	9c 81       	ldd	r25, Y+4	; 0x04
    4eec:	2d 81       	ldd	r18, Y+5	; 0x05
    4eee:	3e 81       	ldd	r19, Y+6	; 0x06
    4ef0:	b9 01       	movw	r22, r18
    4ef2:	0e 94 b8 39 	call	0x7370	; 0x7370 <strcpy>

        /* Pad the end of the string with spaces to ensure columns line up when
         * printed out. */
        for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
    4ef6:	8b 81       	ldd	r24, Y+3	; 0x03
    4ef8:	9c 81       	ldd	r25, Y+4	; 0x04
    4efa:	0e 94 bf 39 	call	0x737e	; 0x737e <strlen>
    4efe:	9a 83       	std	Y+2, r25	; 0x02
    4f00:	89 83       	std	Y+1, r24	; 0x01
    4f02:	0e c0       	rjmp	.+28     	; 0x4f20 <prvWriteNameToBuffer+0x4e>
        {
            pcBuffer[ x ] = ' ';
    4f04:	2b 81       	ldd	r18, Y+3	; 0x03
    4f06:	3c 81       	ldd	r19, Y+4	; 0x04
    4f08:	89 81       	ldd	r24, Y+1	; 0x01
    4f0a:	9a 81       	ldd	r25, Y+2	; 0x02
    4f0c:	f9 01       	movw	r30, r18
    4f0e:	e8 0f       	add	r30, r24
    4f10:	f9 1f       	adc	r31, r25
    4f12:	80 e2       	ldi	r24, 0x20	; 32
    4f14:	80 83       	st	Z, r24
        /* Start by copying the entire string. */
        strcpy( pcBuffer, pcTaskName );

        /* Pad the end of the string with spaces to ensure columns line up when
         * printed out. */
        for( x = strlen( pcBuffer ); x < ( size_t ) ( configMAX_TASK_NAME_LEN - 1 ); x++ )
    4f16:	89 81       	ldd	r24, Y+1	; 0x01
    4f18:	9a 81       	ldd	r25, Y+2	; 0x02
    4f1a:	01 96       	adiw	r24, 0x01	; 1
    4f1c:	9a 83       	std	Y+2, r25	; 0x02
    4f1e:	89 83       	std	Y+1, r24	; 0x01
    4f20:	89 81       	ldd	r24, Y+1	; 0x01
    4f22:	9a 81       	ldd	r25, Y+2	; 0x02
    4f24:	87 30       	cpi	r24, 0x07	; 7
    4f26:	91 05       	cpc	r25, r1
    4f28:	68 f3       	brcs	.-38     	; 0x4f04 <prvWriteNameToBuffer+0x32>
        {
            pcBuffer[ x ] = ' ';
        }

        /* Terminate. */
        pcBuffer[ x ] = ( char ) 0x00;
    4f2a:	2b 81       	ldd	r18, Y+3	; 0x03
    4f2c:	3c 81       	ldd	r19, Y+4	; 0x04
    4f2e:	89 81       	ldd	r24, Y+1	; 0x01
    4f30:	9a 81       	ldd	r25, Y+2	; 0x02
    4f32:	f9 01       	movw	r30, r18
    4f34:	e8 0f       	add	r30, r24
    4f36:	f9 1f       	adc	r31, r25
    4f38:	10 82       	st	Z, r1

        /* Return the new end of string. */
        return &( pcBuffer[ x ] );
    4f3a:	2b 81       	ldd	r18, Y+3	; 0x03
    4f3c:	3c 81       	ldd	r19, Y+4	; 0x04
    4f3e:	89 81       	ldd	r24, Y+1	; 0x01
    4f40:	9a 81       	ldd	r25, Y+2	; 0x02
    4f42:	82 0f       	add	r24, r18
    4f44:	93 1f       	adc	r25, r19
    }
    4f46:	26 96       	adiw	r28, 0x06	; 6
    4f48:	0f b6       	in	r0, 0x3f	; 63
    4f4a:	f8 94       	cli
    4f4c:	de bf       	out	0x3e, r29	; 62
    4f4e:	0f be       	out	0x3f, r0	; 63
    4f50:	cd bf       	out	0x3d, r28	; 61
    4f52:	cf 91       	pop	r28
    4f54:	df 91       	pop	r29
    4f56:	08 95       	ret

00004f58 <vTaskList>:
/*-----------------------------------------------------------*/

#if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    void vTaskList( char * pcWriteBuffer )
    {
    4f58:	df 93       	push	r29
    4f5a:	cf 93       	push	r28
    4f5c:	cd b7       	in	r28, 0x3d	; 61
    4f5e:	de b7       	in	r29, 0x3e	; 62
    4f60:	29 97       	sbiw	r28, 0x09	; 9
    4f62:	0f b6       	in	r0, 0x3f	; 63
    4f64:	f8 94       	cli
    4f66:	de bf       	out	0x3e, r29	; 62
    4f68:	0f be       	out	0x3f, r0	; 63
    4f6a:	cd bf       	out	0x3d, r28	; 61
    4f6c:	9f 83       	std	Y+7, r25	; 0x07
    4f6e:	8e 83       	std	Y+6, r24	; 0x06
         * through a call to vTaskList().
         */


        /* Make sure the write buffer does not contain a string. */
        *pcWriteBuffer = ( char ) 0x00;
    4f70:	ee 81       	ldd	r30, Y+6	; 0x06
    4f72:	ff 81       	ldd	r31, Y+7	; 0x07
    4f74:	10 82       	st	Z, r1

        /* Take a snapshot of the number of tasks in case it changes while this
         * function is executing. */
        uxArraySize = uxCurrentNumberOfTasks;
    4f76:	80 91 cf 06 	lds	r24, 0x06CF
    4f7a:	8b 83       	std	Y+3, r24	; 0x03

        /* Allocate an array index for each task.  NOTE!  if
         * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
         * equate to NULL. */
        pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
    4f7c:	80 91 cf 06 	lds	r24, 0x06CF
    4f80:	88 2f       	mov	r24, r24
    4f82:	90 e0       	ldi	r25, 0x00	; 0
    4f84:	82 95       	swap	r24
    4f86:	92 95       	swap	r25
    4f88:	90 7f       	andi	r25, 0xF0	; 240
    4f8a:	98 27       	eor	r25, r24
    4f8c:	80 7f       	andi	r24, 0xF0	; 240
    4f8e:	98 27       	eor	r25, r24
    4f90:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    4f94:	9d 83       	std	Y+5, r25	; 0x05
    4f96:	8c 83       	std	Y+4, r24	; 0x04

        if( pxTaskStatusArray != NULL )
    4f98:	8c 81       	ldd	r24, Y+4	; 0x04
    4f9a:	9d 81       	ldd	r25, Y+5	; 0x05
    4f9c:	00 97       	sbiw	r24, 0x00	; 0
    4f9e:	09 f4       	brne	.+2      	; 0x4fa2 <vTaskList+0x4a>
    4fa0:	da c0       	rjmp	.+436    	; 0x5156 <vTaskList+0x1fe>
        {
            /* Generate the (binary) data. */
            uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
    4fa2:	8c 81       	ldd	r24, Y+4	; 0x04
    4fa4:	9d 81       	ldd	r25, Y+5	; 0x05
    4fa6:	6b 81       	ldd	r22, Y+3	; 0x03
    4fa8:	40 e0       	ldi	r20, 0x00	; 0
    4faa:	50 e0       	ldi	r21, 0x00	; 0
    4fac:	0e 94 e9 1d 	call	0x3bd2	; 0x3bd2 <uxTaskGetSystemState>
    4fb0:	8b 83       	std	Y+3, r24	; 0x03

            /* Create a human readable table from the binary data. */
            for( x = 0; x < uxArraySize; x++ )
    4fb2:	1a 82       	std	Y+2, r1	; 0x02
    4fb4:	c7 c0       	rjmp	.+398    	; 0x5144 <vTaskList+0x1ec>
            {
                switch( pxTaskStatusArray[ x ].eCurrentState )
    4fb6:	8a 81       	ldd	r24, Y+2	; 0x02
    4fb8:	88 2f       	mov	r24, r24
    4fba:	90 e0       	ldi	r25, 0x00	; 0
    4fbc:	9c 01       	movw	r18, r24
    4fbe:	22 95       	swap	r18
    4fc0:	32 95       	swap	r19
    4fc2:	30 7f       	andi	r19, 0xF0	; 240
    4fc4:	32 27       	eor	r19, r18
    4fc6:	20 7f       	andi	r18, 0xF0	; 240
    4fc8:	32 27       	eor	r19, r18
    4fca:	8c 81       	ldd	r24, Y+4	; 0x04
    4fcc:	9d 81       	ldd	r25, Y+5	; 0x05
    4fce:	fc 01       	movw	r30, r24
    4fd0:	e2 0f       	add	r30, r18
    4fd2:	f3 1f       	adc	r31, r19
    4fd4:	85 81       	ldd	r24, Z+5	; 0x05
    4fd6:	28 2f       	mov	r18, r24
    4fd8:	30 e0       	ldi	r19, 0x00	; 0
    4fda:	39 87       	std	Y+9, r19	; 0x09
    4fdc:	28 87       	std	Y+8, r18	; 0x08
    4fde:	88 85       	ldd	r24, Y+8	; 0x08
    4fe0:	99 85       	ldd	r25, Y+9	; 0x09
    4fe2:	82 30       	cpi	r24, 0x02	; 2
    4fe4:	91 05       	cpc	r25, r1
    4fe6:	01 f1       	breq	.+64     	; 0x5028 <vTaskList+0xd0>
    4fe8:	28 85       	ldd	r18, Y+8	; 0x08
    4fea:	39 85       	ldd	r19, Y+9	; 0x09
    4fec:	23 30       	cpi	r18, 0x03	; 3
    4fee:	31 05       	cpc	r19, r1
    4ff0:	54 f4       	brge	.+20     	; 0x5006 <vTaskList+0xae>
    4ff2:	88 85       	ldd	r24, Y+8	; 0x08
    4ff4:	99 85       	ldd	r25, Y+9	; 0x09
    4ff6:	00 97       	sbiw	r24, 0x00	; 0
    4ff8:	89 f0       	breq	.+34     	; 0x501c <vTaskList+0xc4>
    4ffa:	28 85       	ldd	r18, Y+8	; 0x08
    4ffc:	39 85       	ldd	r19, Y+9	; 0x09
    4ffe:	21 30       	cpi	r18, 0x01	; 1
    5000:	31 05       	cpc	r19, r1
    5002:	79 f0       	breq	.+30     	; 0x5022 <vTaskList+0xca>
    5004:	1a c0       	rjmp	.+52     	; 0x503a <vTaskList+0xe2>
    5006:	88 85       	ldd	r24, Y+8	; 0x08
    5008:	99 85       	ldd	r25, Y+9	; 0x09
    500a:	83 30       	cpi	r24, 0x03	; 3
    500c:	91 05       	cpc	r25, r1
    500e:	79 f0       	breq	.+30     	; 0x502e <vTaskList+0xd6>
    5010:	28 85       	ldd	r18, Y+8	; 0x08
    5012:	39 85       	ldd	r19, Y+9	; 0x09
    5014:	24 30       	cpi	r18, 0x04	; 4
    5016:	31 05       	cpc	r19, r1
    5018:	69 f0       	breq	.+26     	; 0x5034 <vTaskList+0xdc>
    501a:	0f c0       	rjmp	.+30     	; 0x503a <vTaskList+0xe2>
                {
                    case eRunning:
                        cStatus = tskRUNNING_CHAR;
    501c:	88 e5       	ldi	r24, 0x58	; 88
    501e:	89 83       	std	Y+1, r24	; 0x01
    5020:	0d c0       	rjmp	.+26     	; 0x503c <vTaskList+0xe4>
                        break;

                    case eReady:
                        cStatus = tskREADY_CHAR;
    5022:	82 e5       	ldi	r24, 0x52	; 82
    5024:	89 83       	std	Y+1, r24	; 0x01
    5026:	0a c0       	rjmp	.+20     	; 0x503c <vTaskList+0xe4>
                        break;

                    case eBlocked:
                        cStatus = tskBLOCKED_CHAR;
    5028:	82 e4       	ldi	r24, 0x42	; 66
    502a:	89 83       	std	Y+1, r24	; 0x01
    502c:	07 c0       	rjmp	.+14     	; 0x503c <vTaskList+0xe4>
                        break;

                    case eSuspended:
                        cStatus = tskSUSPENDED_CHAR;
    502e:	83 e5       	ldi	r24, 0x53	; 83
    5030:	89 83       	std	Y+1, r24	; 0x01
    5032:	04 c0       	rjmp	.+8      	; 0x503c <vTaskList+0xe4>
                        break;

                    case eDeleted:
                        cStatus = tskDELETED_CHAR;
    5034:	84 e4       	ldi	r24, 0x44	; 68
    5036:	89 83       	std	Y+1, r24	; 0x01
    5038:	01 c0       	rjmp	.+2      	; 0x503c <vTaskList+0xe4>
                        break;

                    case eInvalid: /* Fall through. */
                    default:       /* Should not get here, but it is included
                                    * to prevent static checking errors. */
                        cStatus = ( char ) 0x00;
    503a:	19 82       	std	Y+1, r1	; 0x01
                        break;
                }

                /* Write the task name to the string, padding with spaces so it
                 * can be printed in tabular form more easily. */
                pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
    503c:	8a 81       	ldd	r24, Y+2	; 0x02
    503e:	88 2f       	mov	r24, r24
    5040:	90 e0       	ldi	r25, 0x00	; 0
    5042:	9c 01       	movw	r18, r24
    5044:	22 95       	swap	r18
    5046:	32 95       	swap	r19
    5048:	30 7f       	andi	r19, 0xF0	; 240
    504a:	32 27       	eor	r19, r18
    504c:	20 7f       	andi	r18, 0xF0	; 240
    504e:	32 27       	eor	r19, r18
    5050:	8c 81       	ldd	r24, Y+4	; 0x04
    5052:	9d 81       	ldd	r25, Y+5	; 0x05
    5054:	fc 01       	movw	r30, r24
    5056:	e2 0f       	add	r30, r18
    5058:	f3 1f       	adc	r31, r19
    505a:	22 81       	ldd	r18, Z+2	; 0x02
    505c:	33 81       	ldd	r19, Z+3	; 0x03
    505e:	8e 81       	ldd	r24, Y+6	; 0x06
    5060:	9f 81       	ldd	r25, Y+7	; 0x07
    5062:	b9 01       	movw	r22, r18
    5064:	0e 94 69 27 	call	0x4ed2	; 0x4ed2 <prvWriteNameToBuffer>
    5068:	9f 83       	std	Y+7, r25	; 0x07
    506a:	8e 83       	std	Y+6, r24	; 0x06

                /* Write the rest of the string. */
                sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
    506c:	89 81       	ldd	r24, Y+1	; 0x01
    506e:	68 2f       	mov	r22, r24
    5070:	70 e0       	ldi	r23, 0x00	; 0
    5072:	8a 81       	ldd	r24, Y+2	; 0x02
    5074:	88 2f       	mov	r24, r24
    5076:	90 e0       	ldi	r25, 0x00	; 0
    5078:	9c 01       	movw	r18, r24
    507a:	22 95       	swap	r18
    507c:	32 95       	swap	r19
    507e:	30 7f       	andi	r19, 0xF0	; 240
    5080:	32 27       	eor	r19, r18
    5082:	20 7f       	andi	r18, 0xF0	; 240
    5084:	32 27       	eor	r19, r18
    5086:	8c 81       	ldd	r24, Y+4	; 0x04
    5088:	9d 81       	ldd	r25, Y+5	; 0x05
    508a:	fc 01       	movw	r30, r24
    508c:	e2 0f       	add	r30, r18
    508e:	f3 1f       	adc	r31, r19
    5090:	86 81       	ldd	r24, Z+6	; 0x06
    5092:	a8 2f       	mov	r26, r24
    5094:	b0 e0       	ldi	r27, 0x00	; 0
    5096:	8a 81       	ldd	r24, Y+2	; 0x02
    5098:	88 2f       	mov	r24, r24
    509a:	90 e0       	ldi	r25, 0x00	; 0
    509c:	9c 01       	movw	r18, r24
    509e:	22 95       	swap	r18
    50a0:	32 95       	swap	r19
    50a2:	30 7f       	andi	r19, 0xF0	; 240
    50a4:	32 27       	eor	r19, r18
    50a6:	20 7f       	andi	r18, 0xF0	; 240
    50a8:	32 27       	eor	r19, r18
    50aa:	8c 81       	ldd	r24, Y+4	; 0x04
    50ac:	9d 81       	ldd	r25, Y+5	; 0x05
    50ae:	fc 01       	movw	r30, r24
    50b0:	e2 0f       	add	r30, r18
    50b2:	f3 1f       	adc	r31, r19
    50b4:	46 85       	ldd	r20, Z+14	; 0x0e
    50b6:	57 85       	ldd	r21, Z+15	; 0x0f
    50b8:	8a 81       	ldd	r24, Y+2	; 0x02
    50ba:	88 2f       	mov	r24, r24
    50bc:	90 e0       	ldi	r25, 0x00	; 0
    50be:	9c 01       	movw	r18, r24
    50c0:	22 95       	swap	r18
    50c2:	32 95       	swap	r19
    50c4:	30 7f       	andi	r19, 0xF0	; 240
    50c6:	32 27       	eor	r19, r18
    50c8:	20 7f       	andi	r18, 0xF0	; 240
    50ca:	32 27       	eor	r19, r18
    50cc:	8c 81       	ldd	r24, Y+4	; 0x04
    50ce:	9d 81       	ldd	r25, Y+5	; 0x05
    50d0:	fc 01       	movw	r30, r24
    50d2:	e2 0f       	add	r30, r18
    50d4:	f3 1f       	adc	r31, r19
    50d6:	84 81       	ldd	r24, Z+4	; 0x04
    50d8:	28 2f       	mov	r18, r24
    50da:	30 e0       	ldi	r19, 0x00	; 0
    50dc:	8d b7       	in	r24, 0x3d	; 61
    50de:	9e b7       	in	r25, 0x3e	; 62
    50e0:	0c 97       	sbiw	r24, 0x0c	; 12
    50e2:	0f b6       	in	r0, 0x3f	; 63
    50e4:	f8 94       	cli
    50e6:	9e bf       	out	0x3e, r25	; 62
    50e8:	0f be       	out	0x3f, r0	; 63
    50ea:	8d bf       	out	0x3d, r24	; 61
    50ec:	ed b7       	in	r30, 0x3d	; 61
    50ee:	fe b7       	in	r31, 0x3e	; 62
    50f0:	31 96       	adiw	r30, 0x01	; 1
    50f2:	8e 81       	ldd	r24, Y+6	; 0x06
    50f4:	9f 81       	ldd	r25, Y+7	; 0x07
    50f6:	91 83       	std	Z+1, r25	; 0x01
    50f8:	80 83       	st	Z, r24
    50fa:	85 e6       	ldi	r24, 0x65	; 101
    50fc:	90 e0       	ldi	r25, 0x00	; 0
    50fe:	93 83       	std	Z+3, r25	; 0x03
    5100:	82 83       	std	Z+2, r24	; 0x02
    5102:	75 83       	std	Z+5, r23	; 0x05
    5104:	64 83       	std	Z+4, r22	; 0x04
    5106:	b7 83       	std	Z+7, r27	; 0x07
    5108:	a6 83       	std	Z+6, r26	; 0x06
    510a:	51 87       	std	Z+9, r21	; 0x09
    510c:	40 87       	std	Z+8, r20	; 0x08
    510e:	33 87       	std	Z+11, r19	; 0x0b
    5110:	22 87       	std	Z+10, r18	; 0x0a
    5112:	0e 94 c8 39 	call	0x7390	; 0x7390 <sprintf>
    5116:	2d b7       	in	r18, 0x3d	; 61
    5118:	3e b7       	in	r19, 0x3e	; 62
    511a:	24 5f       	subi	r18, 0xF4	; 244
    511c:	3f 4f       	sbci	r19, 0xFF	; 255
    511e:	0f b6       	in	r0, 0x3f	; 63
    5120:	f8 94       	cli
    5122:	3e bf       	out	0x3e, r19	; 62
    5124:	0f be       	out	0x3f, r0	; 63
    5126:	2d bf       	out	0x3d, r18	; 61
                pcWriteBuffer += strlen( pcWriteBuffer );                                                                                                                                                                                                /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
    5128:	8e 81       	ldd	r24, Y+6	; 0x06
    512a:	9f 81       	ldd	r25, Y+7	; 0x07
    512c:	0e 94 bf 39 	call	0x737e	; 0x737e <strlen>
    5130:	9c 01       	movw	r18, r24
    5132:	8e 81       	ldd	r24, Y+6	; 0x06
    5134:	9f 81       	ldd	r25, Y+7	; 0x07
    5136:	82 0f       	add	r24, r18
    5138:	93 1f       	adc	r25, r19
    513a:	9f 83       	std	Y+7, r25	; 0x07
    513c:	8e 83       	std	Y+6, r24	; 0x06
        {
            /* Generate the (binary) data. */
            uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );

            /* Create a human readable table from the binary data. */
            for( x = 0; x < uxArraySize; x++ )
    513e:	8a 81       	ldd	r24, Y+2	; 0x02
    5140:	8f 5f       	subi	r24, 0xFF	; 255
    5142:	8a 83       	std	Y+2, r24	; 0x02
    5144:	9a 81       	ldd	r25, Y+2	; 0x02
    5146:	8b 81       	ldd	r24, Y+3	; 0x03
    5148:	98 17       	cp	r25, r24
    514a:	08 f4       	brcc	.+2      	; 0x514e <vTaskList+0x1f6>
    514c:	34 cf       	rjmp	.-408    	; 0x4fb6 <vTaskList+0x5e>
                pcWriteBuffer += strlen( pcWriteBuffer );                                                                                                                                                                                                /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
            }

            /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
             * is 0 then vPortFree() will be #defined to nothing. */
            vPortFree( pxTaskStatusArray );
    514e:	8c 81       	ldd	r24, Y+4	; 0x04
    5150:	9d 81       	ldd	r25, Y+5	; 0x05
    5152:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    5156:	29 96       	adiw	r28, 0x09	; 9
    5158:	0f b6       	in	r0, 0x3f	; 63
    515a:	f8 94       	cli
    515c:	de bf       	out	0x3e, r29	; 62
    515e:	0f be       	out	0x3f, r0	; 63
    5160:	cd bf       	out	0x3d, r28	; 61
    5162:	cf 91       	pop	r28
    5164:	df 91       	pop	r29
    5166:	08 95       	ret

00005168 <vTaskGetRunTimeStats>:
/*----------------------------------------------------------*/

#if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

    void vTaskGetRunTimeStats( char * pcWriteBuffer )
    {
    5168:	df 93       	push	r29
    516a:	cf 93       	push	r28
    516c:	cd b7       	in	r28, 0x3d	; 61
    516e:	de b7       	in	r29, 0x3e	; 62
    5170:	2e 97       	sbiw	r28, 0x0e	; 14
    5172:	0f b6       	in	r0, 0x3f	; 63
    5174:	f8 94       	cli
    5176:	de bf       	out	0x3e, r29	; 62
    5178:	0f be       	out	0x3f, r0	; 63
    517a:	cd bf       	out	0x3d, r28	; 61
    517c:	9e 87       	std	Y+14, r25	; 0x0e
    517e:	8d 87       	std	Y+13, r24	; 0x0d
         * directly to get access to raw stats data, rather than indirectly
         * through a call to vTaskGetRunTimeStats().
         */

        /* Make sure the write buffer does not contain a string. */
        *pcWriteBuffer = ( char ) 0x00;
    5180:	ed 85       	ldd	r30, Y+13	; 0x0d
    5182:	fe 85       	ldd	r31, Y+14	; 0x0e
    5184:	10 82       	st	Z, r1

        /* Take a snapshot of the number of tasks in case it changes while this
         * function is executing. */
        uxArraySize = uxCurrentNumberOfTasks;
    5186:	80 91 cf 06 	lds	r24, 0x06CF
    518a:	8e 83       	std	Y+6, r24	; 0x06

        /* Allocate an array index for each task.  NOTE!  If
         * configSUPPORT_DYNAMIC_ALLOCATION is set to 0 then pvPortMalloc() will
         * equate to NULL. */
        pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation allocates a struct that has the alignment requirements of a pointer. */
    518c:	80 91 cf 06 	lds	r24, 0x06CF
    5190:	88 2f       	mov	r24, r24
    5192:	90 e0       	ldi	r25, 0x00	; 0
    5194:	82 95       	swap	r24
    5196:	92 95       	swap	r25
    5198:	90 7f       	andi	r25, 0xF0	; 240
    519a:	98 27       	eor	r25, r24
    519c:	80 7f       	andi	r24, 0xF0	; 240
    519e:	98 27       	eor	r25, r24
    51a0:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    51a4:	98 87       	std	Y+8, r25	; 0x08
    51a6:	8f 83       	std	Y+7, r24	; 0x07

        if( pxTaskStatusArray != NULL )
    51a8:	8f 81       	ldd	r24, Y+7	; 0x07
    51aa:	98 85       	ldd	r25, Y+8	; 0x08
    51ac:	00 97       	sbiw	r24, 0x00	; 0
    51ae:	09 f4       	brne	.+2      	; 0x51b2 <vTaskGetRunTimeStats+0x4a>
    51b0:	e5 c0       	rjmp	.+458    	; 0x537c <vTaskGetRunTimeStats+0x214>
        {
            /* Generate the (binary) data. */
            uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
    51b2:	8f 81       	ldd	r24, Y+7	; 0x07
    51b4:	98 85       	ldd	r25, Y+8	; 0x08
    51b6:	9e 01       	movw	r18, r28
    51b8:	27 5f       	subi	r18, 0xF7	; 247
    51ba:	3f 4f       	sbci	r19, 0xFF	; 255
    51bc:	6e 81       	ldd	r22, Y+6	; 0x06
    51be:	a9 01       	movw	r20, r18
    51c0:	0e 94 e9 1d 	call	0x3bd2	; 0x3bd2 <uxTaskGetSystemState>
    51c4:	8e 83       	std	Y+6, r24	; 0x06

            /* For percentage calculations. */
            ulTotalTime /= 100UL;
    51c6:	89 85       	ldd	r24, Y+9	; 0x09
    51c8:	9a 85       	ldd	r25, Y+10	; 0x0a
    51ca:	ab 85       	ldd	r26, Y+11	; 0x0b
    51cc:	bc 85       	ldd	r27, Y+12	; 0x0c
    51ce:	24 e6       	ldi	r18, 0x64	; 100
    51d0:	30 e0       	ldi	r19, 0x00	; 0
    51d2:	40 e0       	ldi	r20, 0x00	; 0
    51d4:	50 e0       	ldi	r21, 0x00	; 0
    51d6:	bc 01       	movw	r22, r24
    51d8:	cd 01       	movw	r24, r26
    51da:	0e 94 86 39 	call	0x730c	; 0x730c <__udivmodsi4>
    51de:	da 01       	movw	r26, r20
    51e0:	c9 01       	movw	r24, r18
    51e2:	89 87       	std	Y+9, r24	; 0x09
    51e4:	9a 87       	std	Y+10, r25	; 0x0a
    51e6:	ab 87       	std	Y+11, r26	; 0x0b
    51e8:	bc 87       	std	Y+12, r27	; 0x0c

            /* Avoid divide by zero errors. */
            if( ulTotalTime > 0UL )
    51ea:	89 85       	ldd	r24, Y+9	; 0x09
    51ec:	9a 85       	ldd	r25, Y+10	; 0x0a
    51ee:	ab 85       	ldd	r26, Y+11	; 0x0b
    51f0:	bc 85       	ldd	r27, Y+12	; 0x0c
    51f2:	00 97       	sbiw	r24, 0x00	; 0
    51f4:	a1 05       	cpc	r26, r1
    51f6:	b1 05       	cpc	r27, r1
    51f8:	09 f4       	brne	.+2      	; 0x51fc <vTaskGetRunTimeStats+0x94>
    51fa:	bc c0       	rjmp	.+376    	; 0x5374 <vTaskGetRunTimeStats+0x20c>
            {
                /* Create a human readable table from the binary data. */
                for( x = 0; x < uxArraySize; x++ )
    51fc:	1d 82       	std	Y+5, r1	; 0x05
    51fe:	b5 c0       	rjmp	.+362    	; 0x536a <vTaskGetRunTimeStats+0x202>
                {
                    /* What percentage of the total run time has the task used?
                     * This will always be rounded down to the nearest integer.
                     * ulTotalRunTime has already been divided by 100. */
                    ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
    5200:	8d 81       	ldd	r24, Y+5	; 0x05
    5202:	88 2f       	mov	r24, r24
    5204:	90 e0       	ldi	r25, 0x00	; 0
    5206:	9c 01       	movw	r18, r24
    5208:	22 95       	swap	r18
    520a:	32 95       	swap	r19
    520c:	30 7f       	andi	r19, 0xF0	; 240
    520e:	32 27       	eor	r19, r18
    5210:	20 7f       	andi	r18, 0xF0	; 240
    5212:	32 27       	eor	r19, r18
    5214:	8f 81       	ldd	r24, Y+7	; 0x07
    5216:	98 85       	ldd	r25, Y+8	; 0x08
    5218:	fc 01       	movw	r30, r24
    521a:	e2 0f       	add	r30, r18
    521c:	f3 1f       	adc	r31, r19
    521e:	80 85       	ldd	r24, Z+8	; 0x08
    5220:	91 85       	ldd	r25, Z+9	; 0x09
    5222:	a2 85       	ldd	r26, Z+10	; 0x0a
    5224:	b3 85       	ldd	r27, Z+11	; 0x0b
    5226:	29 85       	ldd	r18, Y+9	; 0x09
    5228:	3a 85       	ldd	r19, Y+10	; 0x0a
    522a:	4b 85       	ldd	r20, Y+11	; 0x0b
    522c:	5c 85       	ldd	r21, Y+12	; 0x0c
    522e:	bc 01       	movw	r22, r24
    5230:	cd 01       	movw	r24, r26
    5232:	0e 94 86 39 	call	0x730c	; 0x730c <__udivmodsi4>
    5236:	da 01       	movw	r26, r20
    5238:	c9 01       	movw	r24, r18
    523a:	89 83       	std	Y+1, r24	; 0x01
    523c:	9a 83       	std	Y+2, r25	; 0x02
    523e:	ab 83       	std	Y+3, r26	; 0x03
    5240:	bc 83       	std	Y+4, r27	; 0x04

                    /* Write the task name to the string, padding with
                     * spaces so it can be printed in tabular form more
                     * easily. */
                    pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
    5242:	8d 81       	ldd	r24, Y+5	; 0x05
    5244:	88 2f       	mov	r24, r24
    5246:	90 e0       	ldi	r25, 0x00	; 0
    5248:	9c 01       	movw	r18, r24
    524a:	22 95       	swap	r18
    524c:	32 95       	swap	r19
    524e:	30 7f       	andi	r19, 0xF0	; 240
    5250:	32 27       	eor	r19, r18
    5252:	20 7f       	andi	r18, 0xF0	; 240
    5254:	32 27       	eor	r19, r18
    5256:	8f 81       	ldd	r24, Y+7	; 0x07
    5258:	98 85       	ldd	r25, Y+8	; 0x08
    525a:	fc 01       	movw	r30, r24
    525c:	e2 0f       	add	r30, r18
    525e:	f3 1f       	adc	r31, r19
    5260:	22 81       	ldd	r18, Z+2	; 0x02
    5262:	33 81       	ldd	r19, Z+3	; 0x03
    5264:	8d 85       	ldd	r24, Y+13	; 0x0d
    5266:	9e 85       	ldd	r25, Y+14	; 0x0e
    5268:	b9 01       	movw	r22, r18
    526a:	0e 94 69 27 	call	0x4ed2	; 0x4ed2 <prvWriteNameToBuffer>
    526e:	9e 87       	std	Y+14, r25	; 0x0e
    5270:	8d 87       	std	Y+13, r24	; 0x0d

                    if( ulStatsAsPercentage > 0UL )
    5272:	89 81       	ldd	r24, Y+1	; 0x01
    5274:	9a 81       	ldd	r25, Y+2	; 0x02
    5276:	ab 81       	ldd	r26, Y+3	; 0x03
    5278:	bc 81       	ldd	r27, Y+4	; 0x04
    527a:	00 97       	sbiw	r24, 0x00	; 0
    527c:	a1 05       	cpc	r26, r1
    527e:	b1 05       	cpc	r27, r1
    5280:	c1 f1       	breq	.+112    	; 0x52f2 <vTaskGetRunTimeStats+0x18a>
                            }
                        #else
                            {
                                /* sizeof( int ) == sizeof( long ) so a smaller
                                 * printf() library can be used. */
                                sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
    5282:	8d 81       	ldd	r24, Y+5	; 0x05
    5284:	88 2f       	mov	r24, r24
    5286:	90 e0       	ldi	r25, 0x00	; 0
    5288:	9c 01       	movw	r18, r24
    528a:	22 95       	swap	r18
    528c:	32 95       	swap	r19
    528e:	30 7f       	andi	r19, 0xF0	; 240
    5290:	32 27       	eor	r19, r18
    5292:	20 7f       	andi	r18, 0xF0	; 240
    5294:	32 27       	eor	r19, r18
    5296:	8f 81       	ldd	r24, Y+7	; 0x07
    5298:	98 85       	ldd	r25, Y+8	; 0x08
    529a:	fc 01       	movw	r30, r24
    529c:	e2 0f       	add	r30, r18
    529e:	f3 1f       	adc	r31, r19
    52a0:	80 85       	ldd	r24, Z+8	; 0x08
    52a2:	91 85       	ldd	r25, Z+9	; 0x09
    52a4:	a2 85       	ldd	r26, Z+10	; 0x0a
    52a6:	b3 85       	ldd	r27, Z+11	; 0x0b
    52a8:	9c 01       	movw	r18, r24
    52aa:	49 81       	ldd	r20, Y+1	; 0x01
    52ac:	5a 81       	ldd	r21, Y+2	; 0x02
    52ae:	8d b7       	in	r24, 0x3d	; 61
    52b0:	9e b7       	in	r25, 0x3e	; 62
    52b2:	08 97       	sbiw	r24, 0x08	; 8
    52b4:	0f b6       	in	r0, 0x3f	; 63
    52b6:	f8 94       	cli
    52b8:	9e bf       	out	0x3e, r25	; 62
    52ba:	0f be       	out	0x3f, r0	; 63
    52bc:	8d bf       	out	0x3d, r24	; 61
    52be:	ed b7       	in	r30, 0x3d	; 61
    52c0:	fe b7       	in	r31, 0x3e	; 62
    52c2:	31 96       	adiw	r30, 0x01	; 1
    52c4:	8d 85       	ldd	r24, Y+13	; 0x0d
    52c6:	9e 85       	ldd	r25, Y+14	; 0x0e
    52c8:	91 83       	std	Z+1, r25	; 0x01
    52ca:	80 83       	st	Z, r24
    52cc:	84 e7       	ldi	r24, 0x74	; 116
    52ce:	90 e0       	ldi	r25, 0x00	; 0
    52d0:	93 83       	std	Z+3, r25	; 0x03
    52d2:	82 83       	std	Z+2, r24	; 0x02
    52d4:	35 83       	std	Z+5, r19	; 0x05
    52d6:	24 83       	std	Z+4, r18	; 0x04
    52d8:	57 83       	std	Z+7, r21	; 0x07
    52da:	46 83       	std	Z+6, r20	; 0x06
    52dc:	0e 94 c8 39 	call	0x7390	; 0x7390 <sprintf>
    52e0:	8d b7       	in	r24, 0x3d	; 61
    52e2:	9e b7       	in	r25, 0x3e	; 62
    52e4:	08 96       	adiw	r24, 0x08	; 8
    52e6:	0f b6       	in	r0, 0x3f	; 63
    52e8:	f8 94       	cli
    52ea:	9e bf       	out	0x3e, r25	; 62
    52ec:	0f be       	out	0x3f, r0	; 63
    52ee:	8d bf       	out	0x3d, r24	; 61
    52f0:	2e c0       	rjmp	.+92     	; 0x534e <vTaskGetRunTimeStats+0x1e6>
                            }
                        #else
                            {
                                /* sizeof( int ) == sizeof( long ) so a smaller
                                 * printf() library can be used. */
                                sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter ); /*lint !e586 sprintf() allowed as this is compiled with many compilers and this is a utility function only - not part of the core kernel implementation. */
    52f2:	8d 81       	ldd	r24, Y+5	; 0x05
    52f4:	88 2f       	mov	r24, r24
    52f6:	90 e0       	ldi	r25, 0x00	; 0
    52f8:	9c 01       	movw	r18, r24
    52fa:	22 95       	swap	r18
    52fc:	32 95       	swap	r19
    52fe:	30 7f       	andi	r19, 0xF0	; 240
    5300:	32 27       	eor	r19, r18
    5302:	20 7f       	andi	r18, 0xF0	; 240
    5304:	32 27       	eor	r19, r18
    5306:	8f 81       	ldd	r24, Y+7	; 0x07
    5308:	98 85       	ldd	r25, Y+8	; 0x08
    530a:	fc 01       	movw	r30, r24
    530c:	e2 0f       	add	r30, r18
    530e:	f3 1f       	adc	r31, r19
    5310:	80 85       	ldd	r24, Z+8	; 0x08
    5312:	91 85       	ldd	r25, Z+9	; 0x09
    5314:	a2 85       	ldd	r26, Z+10	; 0x0a
    5316:	b3 85       	ldd	r27, Z+11	; 0x0b
    5318:	9c 01       	movw	r18, r24
    531a:	00 d0       	rcall	.+0      	; 0x531c <vTaskGetRunTimeStats+0x1b4>
    531c:	00 d0       	rcall	.+0      	; 0x531e <vTaskGetRunTimeStats+0x1b6>
    531e:	00 d0       	rcall	.+0      	; 0x5320 <vTaskGetRunTimeStats+0x1b8>
    5320:	ed b7       	in	r30, 0x3d	; 61
    5322:	fe b7       	in	r31, 0x3e	; 62
    5324:	31 96       	adiw	r30, 0x01	; 1
    5326:	8d 85       	ldd	r24, Y+13	; 0x0d
    5328:	9e 85       	ldd	r25, Y+14	; 0x0e
    532a:	91 83       	std	Z+1, r25	; 0x01
    532c:	80 83       	st	Z, r24
    532e:	80 e8       	ldi	r24, 0x80	; 128
    5330:	90 e0       	ldi	r25, 0x00	; 0
    5332:	93 83       	std	Z+3, r25	; 0x03
    5334:	82 83       	std	Z+2, r24	; 0x02
    5336:	35 83       	std	Z+5, r19	; 0x05
    5338:	24 83       	std	Z+4, r18	; 0x04
    533a:	0e 94 c8 39 	call	0x7390	; 0x7390 <sprintf>
    533e:	8d b7       	in	r24, 0x3d	; 61
    5340:	9e b7       	in	r25, 0x3e	; 62
    5342:	06 96       	adiw	r24, 0x06	; 6
    5344:	0f b6       	in	r0, 0x3f	; 63
    5346:	f8 94       	cli
    5348:	9e bf       	out	0x3e, r25	; 62
    534a:	0f be       	out	0x3f, r0	; 63
    534c:	8d bf       	out	0x3d, r24	; 61
                            }
                        #endif
                    }

                    pcWriteBuffer += strlen( pcWriteBuffer ); /*lint !e9016 Pointer arithmetic ok on char pointers especially as in this case where it best denotes the intent of the code. */
    534e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5350:	9e 85       	ldd	r25, Y+14	; 0x0e
    5352:	0e 94 bf 39 	call	0x737e	; 0x737e <strlen>
    5356:	9c 01       	movw	r18, r24
    5358:	8d 85       	ldd	r24, Y+13	; 0x0d
    535a:	9e 85       	ldd	r25, Y+14	; 0x0e
    535c:	82 0f       	add	r24, r18
    535e:	93 1f       	adc	r25, r19
    5360:	9e 87       	std	Y+14, r25	; 0x0e
    5362:	8d 87       	std	Y+13, r24	; 0x0d

            /* Avoid divide by zero errors. */
            if( ulTotalTime > 0UL )
            {
                /* Create a human readable table from the binary data. */
                for( x = 0; x < uxArraySize; x++ )
    5364:	8d 81       	ldd	r24, Y+5	; 0x05
    5366:	8f 5f       	subi	r24, 0xFF	; 255
    5368:	8d 83       	std	Y+5, r24	; 0x05
    536a:	9d 81       	ldd	r25, Y+5	; 0x05
    536c:	8e 81       	ldd	r24, Y+6	; 0x06
    536e:	98 17       	cp	r25, r24
    5370:	08 f4       	brcc	.+2      	; 0x5374 <vTaskGetRunTimeStats+0x20c>
    5372:	46 cf       	rjmp	.-372    	; 0x5200 <vTaskGetRunTimeStats+0x98>
                mtCOVERAGE_TEST_MARKER();
            }

            /* Free the array again.  NOTE!  If configSUPPORT_DYNAMIC_ALLOCATION
             * is 0 then vPortFree() will be #defined to nothing. */
            vPortFree( pxTaskStatusArray );
    5374:	8f 81       	ldd	r24, Y+7	; 0x07
    5376:	98 85       	ldd	r25, Y+8	; 0x08
    5378:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    537c:	2e 96       	adiw	r28, 0x0e	; 14
    537e:	0f b6       	in	r0, 0x3f	; 63
    5380:	f8 94       	cli
    5382:	de bf       	out	0x3e, r29	; 62
    5384:	0f be       	out	0x3f, r0	; 63
    5386:	cd bf       	out	0x3d, r28	; 61
    5388:	cf 91       	pop	r28
    538a:	df 91       	pop	r29
    538c:	08 95       	ret

0000538e <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    538e:	df 93       	push	r29
    5390:	cf 93       	push	r28
    5392:	00 d0       	rcall	.+0      	; 0x5394 <uxTaskResetEventItemValue+0x6>
    5394:	cd b7       	in	r28, 0x3d	; 61
    5396:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    5398:	e0 91 cc 06 	lds	r30, 0x06CC
    539c:	f0 91 cd 06 	lds	r31, 0x06CD
    53a0:	84 85       	ldd	r24, Z+12	; 0x0c
    53a2:	95 85       	ldd	r25, Z+13	; 0x0d
    53a4:	9a 83       	std	Y+2, r25	; 0x02
    53a6:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    53a8:	a0 91 cc 06 	lds	r26, 0x06CC
    53ac:	b0 91 cd 06 	lds	r27, 0x06CD
    53b0:	e0 91 cc 06 	lds	r30, 0x06CC
    53b4:	f0 91 cd 06 	lds	r31, 0x06CD
    53b8:	86 89       	ldd	r24, Z+22	; 0x16
    53ba:	28 2f       	mov	r18, r24
    53bc:	30 e0       	ldi	r19, 0x00	; 0
    53be:	84 e0       	ldi	r24, 0x04	; 4
    53c0:	90 e0       	ldi	r25, 0x00	; 0
    53c2:	82 1b       	sub	r24, r18
    53c4:	93 0b       	sbc	r25, r19
    53c6:	1d 96       	adiw	r26, 0x0d	; 13
    53c8:	9c 93       	st	X, r25
    53ca:	8e 93       	st	-X, r24
    53cc:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    53ce:	89 81       	ldd	r24, Y+1	; 0x01
    53d0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    53d2:	0f 90       	pop	r0
    53d4:	0f 90       	pop	r0
    53d6:	cf 91       	pop	r28
    53d8:	df 91       	pop	r29
    53da:	08 95       	ret

000053dc <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    53dc:	df 93       	push	r29
    53de:	cf 93       	push	r28
    53e0:	cd b7       	in	r28, 0x3d	; 61
    53e2:	de b7       	in	r29, 0x3e	; 62
    53e4:	28 97       	sbiw	r28, 0x08	; 8
    53e6:	0f b6       	in	r0, 0x3f	; 63
    53e8:	f8 94       	cli
    53ea:	de bf       	out	0x3e, r29	; 62
    53ec:	0f be       	out	0x3f, r0	; 63
    53ee:	cd bf       	out	0x3d, r28	; 61
    53f0:	8d 83       	std	Y+5, r24	; 0x05
    53f2:	6e 83       	std	Y+6, r22	; 0x06
    53f4:	58 87       	std	Y+8, r21	; 0x08
    53f6:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    53f8:	0f b6       	in	r0, 0x3f	; 63
    53fa:	f8 94       	cli
    53fc:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    53fe:	20 91 cc 06 	lds	r18, 0x06CC
    5402:	30 91 cd 06 	lds	r19, 0x06CD
    5406:	8d 81       	ldd	r24, Y+5	; 0x05
    5408:	88 2f       	mov	r24, r24
    540a:	90 e0       	ldi	r25, 0x00	; 0
    540c:	88 0f       	add	r24, r24
    540e:	99 1f       	adc	r25, r25
    5410:	88 0f       	add	r24, r24
    5412:	99 1f       	adc	r25, r25
    5414:	82 0f       	add	r24, r18
    5416:	93 1f       	adc	r25, r19
    5418:	fc 01       	movw	r30, r24
    541a:	b7 96       	adiw	r30, 0x27	; 39
    541c:	80 81       	ld	r24, Z
    541e:	91 81       	ldd	r25, Z+1	; 0x01
    5420:	a2 81       	ldd	r26, Z+2	; 0x02
    5422:	b3 81       	ldd	r27, Z+3	; 0x03
    5424:	00 97       	sbiw	r24, 0x00	; 0
    5426:	a1 05       	cpc	r26, r1
    5428:	b1 05       	cpc	r27, r1
    542a:	c1 f4       	brne	.+48     	; 0x545c <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    542c:	20 91 cc 06 	lds	r18, 0x06CC
    5430:	30 91 cd 06 	lds	r19, 0x06CD
    5434:	8d 81       	ldd	r24, Y+5	; 0x05
    5436:	88 2f       	mov	r24, r24
    5438:	90 e0       	ldi	r25, 0x00	; 0
    543a:	82 0f       	add	r24, r18
    543c:	93 1f       	adc	r25, r19
    543e:	fc 01       	movw	r30, r24
    5440:	bb 96       	adiw	r30, 0x2b	; 43
    5442:	81 e0       	ldi	r24, 0x01	; 1
    5444:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    5446:	8f 81       	ldd	r24, Y+7	; 0x07
    5448:	98 85       	ldd	r25, Y+8	; 0x08
    544a:	00 97       	sbiw	r24, 0x00	; 0
    544c:	39 f0       	breq	.+14     	; 0x545c <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    544e:	8f 81       	ldd	r24, Y+7	; 0x07
    5450:	98 85       	ldd	r25, Y+8	; 0x08
    5452:	61 e0       	ldi	r22, 0x01	; 1
    5454:	0e 94 73 31 	call	0x62e6	; 0x62e6 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    5458:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    545c:	0f 90       	pop	r0
    545e:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    5460:	0f b6       	in	r0, 0x3f	; 63
    5462:	f8 94       	cli
    5464:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    5466:	20 91 cc 06 	lds	r18, 0x06CC
    546a:	30 91 cd 06 	lds	r19, 0x06CD
    546e:	8d 81       	ldd	r24, Y+5	; 0x05
    5470:	88 2f       	mov	r24, r24
    5472:	90 e0       	ldi	r25, 0x00	; 0
    5474:	88 0f       	add	r24, r24
    5476:	99 1f       	adc	r25, r25
    5478:	88 0f       	add	r24, r24
    547a:	99 1f       	adc	r25, r25
    547c:	82 0f       	add	r24, r18
    547e:	93 1f       	adc	r25, r19
    5480:	fc 01       	movw	r30, r24
    5482:	b7 96       	adiw	r30, 0x27	; 39
    5484:	80 81       	ld	r24, Z
    5486:	91 81       	ldd	r25, Z+1	; 0x01
    5488:	a2 81       	ldd	r26, Z+2	; 0x02
    548a:	b3 81       	ldd	r27, Z+3	; 0x03
    548c:	89 83       	std	Y+1, r24	; 0x01
    548e:	9a 83       	std	Y+2, r25	; 0x02
    5490:	ab 83       	std	Y+3, r26	; 0x03
    5492:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    5494:	89 81       	ldd	r24, Y+1	; 0x01
    5496:	9a 81       	ldd	r25, Y+2	; 0x02
    5498:	ab 81       	ldd	r26, Y+3	; 0x03
    549a:	bc 81       	ldd	r27, Y+4	; 0x04
    549c:	00 97       	sbiw	r24, 0x00	; 0
    549e:	a1 05       	cpc	r26, r1
    54a0:	b1 05       	cpc	r27, r1
    54a2:	a9 f1       	breq	.+106    	; 0x550e <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    54a4:	8e 81       	ldd	r24, Y+6	; 0x06
    54a6:	88 23       	and	r24, r24
    54a8:	a1 f0       	breq	.+40     	; 0x54d2 <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    54aa:	20 91 cc 06 	lds	r18, 0x06CC
    54ae:	30 91 cd 06 	lds	r19, 0x06CD
    54b2:	8d 81       	ldd	r24, Y+5	; 0x05
    54b4:	88 2f       	mov	r24, r24
    54b6:	90 e0       	ldi	r25, 0x00	; 0
    54b8:	88 0f       	add	r24, r24
    54ba:	99 1f       	adc	r25, r25
    54bc:	88 0f       	add	r24, r24
    54be:	99 1f       	adc	r25, r25
    54c0:	82 0f       	add	r24, r18
    54c2:	93 1f       	adc	r25, r19
    54c4:	fc 01       	movw	r30, r24
    54c6:	b7 96       	adiw	r30, 0x27	; 39
    54c8:	10 82       	st	Z, r1
    54ca:	11 82       	std	Z+1, r1	; 0x01
    54cc:	12 82       	std	Z+2, r1	; 0x02
    54ce:	13 82       	std	Z+3, r1	; 0x03
    54d0:	1e c0       	rjmp	.+60     	; 0x550e <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    54d2:	e0 91 cc 06 	lds	r30, 0x06CC
    54d6:	f0 91 cd 06 	lds	r31, 0x06CD
    54da:	8d 81       	ldd	r24, Y+5	; 0x05
    54dc:	68 2f       	mov	r22, r24
    54de:	70 e0       	ldi	r23, 0x00	; 0
    54e0:	89 81       	ldd	r24, Y+1	; 0x01
    54e2:	9a 81       	ldd	r25, Y+2	; 0x02
    54e4:	ab 81       	ldd	r26, Y+3	; 0x03
    54e6:	bc 81       	ldd	r27, Y+4	; 0x04
    54e8:	9c 01       	movw	r18, r24
    54ea:	ad 01       	movw	r20, r26
    54ec:	21 50       	subi	r18, 0x01	; 1
    54ee:	30 40       	sbci	r19, 0x00	; 0
    54f0:	40 40       	sbci	r20, 0x00	; 0
    54f2:	50 40       	sbci	r21, 0x00	; 0
    54f4:	cb 01       	movw	r24, r22
    54f6:	88 0f       	add	r24, r24
    54f8:	99 1f       	adc	r25, r25
    54fa:	88 0f       	add	r24, r24
    54fc:	99 1f       	adc	r25, r25
    54fe:	8e 0f       	add	r24, r30
    5500:	9f 1f       	adc	r25, r31
    5502:	fc 01       	movw	r30, r24
    5504:	b7 96       	adiw	r30, 0x27	; 39
    5506:	20 83       	st	Z, r18
    5508:	31 83       	std	Z+1, r19	; 0x01
    550a:	42 83       	std	Z+2, r20	; 0x02
    550c:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    550e:	20 91 cc 06 	lds	r18, 0x06CC
    5512:	30 91 cd 06 	lds	r19, 0x06CD
    5516:	8d 81       	ldd	r24, Y+5	; 0x05
    5518:	88 2f       	mov	r24, r24
    551a:	90 e0       	ldi	r25, 0x00	; 0
    551c:	82 0f       	add	r24, r18
    551e:	93 1f       	adc	r25, r19
    5520:	fc 01       	movw	r30, r24
    5522:	bb 96       	adiw	r30, 0x2b	; 43
    5524:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    5526:	0f 90       	pop	r0
    5528:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    552a:	89 81       	ldd	r24, Y+1	; 0x01
    552c:	9a 81       	ldd	r25, Y+2	; 0x02
    552e:	ab 81       	ldd	r26, Y+3	; 0x03
    5530:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    5532:	bc 01       	movw	r22, r24
    5534:	cd 01       	movw	r24, r26
    5536:	28 96       	adiw	r28, 0x08	; 8
    5538:	0f b6       	in	r0, 0x3f	; 63
    553a:	f8 94       	cli
    553c:	de bf       	out	0x3e, r29	; 62
    553e:	0f be       	out	0x3f, r0	; 63
    5540:	cd bf       	out	0x3d, r28	; 61
    5542:	cf 91       	pop	r28
    5544:	df 91       	pop	r29
    5546:	08 95       	ret

00005548 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    5548:	cf 92       	push	r12
    554a:	df 92       	push	r13
    554c:	ef 92       	push	r14
    554e:	ff 92       	push	r15
    5550:	0f 93       	push	r16
    5552:	1f 93       	push	r17
    5554:	df 93       	push	r29
    5556:	cf 93       	push	r28
    5558:	cd b7       	in	r28, 0x3d	; 61
    555a:	de b7       	in	r29, 0x3e	; 62
    555c:	2e 97       	sbiw	r28, 0x0e	; 14
    555e:	0f b6       	in	r0, 0x3f	; 63
    5560:	f8 94       	cli
    5562:	de bf       	out	0x3e, r29	; 62
    5564:	0f be       	out	0x3f, r0	; 63
    5566:	cd bf       	out	0x3d, r28	; 61
    5568:	8a 83       	std	Y+2, r24	; 0x02
    556a:	4b 83       	std	Y+3, r20	; 0x03
    556c:	5c 83       	std	Y+4, r21	; 0x04
    556e:	6d 83       	std	Y+5, r22	; 0x05
    5570:	7e 83       	std	Y+6, r23	; 0x06
    5572:	0f 83       	std	Y+7, r16	; 0x07
    5574:	18 87       	std	Y+8, r17	; 0x08
    5576:	29 87       	std	Y+9, r18	; 0x09
    5578:	3a 87       	std	Y+10, r19	; 0x0a
    557a:	fc 86       	std	Y+12, r15	; 0x0c
    557c:	eb 86       	std	Y+11, r14	; 0x0b
    557e:	de 86       	std	Y+14, r13	; 0x0e
    5580:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    5582:	0f b6       	in	r0, 0x3f	; 63
    5584:	f8 94       	cli
    5586:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    5588:	20 91 cc 06 	lds	r18, 0x06CC
    558c:	30 91 cd 06 	lds	r19, 0x06CD
    5590:	8a 81       	ldd	r24, Y+2	; 0x02
    5592:	88 2f       	mov	r24, r24
    5594:	90 e0       	ldi	r25, 0x00	; 0
    5596:	82 0f       	add	r24, r18
    5598:	93 1f       	adc	r25, r19
    559a:	fc 01       	movw	r30, r24
    559c:	bb 96       	adiw	r30, 0x2b	; 43
    559e:	80 81       	ld	r24, Z
    55a0:	82 30       	cpi	r24, 0x02	; 2
    55a2:	09 f4       	brne	.+2      	; 0x55a6 <xTaskGenericNotifyWait+0x5e>
    55a4:	47 c0       	rjmp	.+142    	; 0x5634 <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    55a6:	60 91 cc 06 	lds	r22, 0x06CC
    55aa:	70 91 cd 06 	lds	r23, 0x06CD
    55ae:	8a 81       	ldd	r24, Y+2	; 0x02
    55b0:	08 2f       	mov	r16, r24
    55b2:	10 e0       	ldi	r17, 0x00	; 0
    55b4:	8a 81       	ldd	r24, Y+2	; 0x02
    55b6:	88 2f       	mov	r24, r24
    55b8:	90 e0       	ldi	r25, 0x00	; 0
    55ba:	88 0f       	add	r24, r24
    55bc:	99 1f       	adc	r25, r25
    55be:	88 0f       	add	r24, r24
    55c0:	99 1f       	adc	r25, r25
    55c2:	86 0f       	add	r24, r22
    55c4:	97 1f       	adc	r25, r23
    55c6:	fc 01       	movw	r30, r24
    55c8:	b7 96       	adiw	r30, 0x27	; 39
    55ca:	20 81       	ld	r18, Z
    55cc:	31 81       	ldd	r19, Z+1	; 0x01
    55ce:	42 81       	ldd	r20, Z+2	; 0x02
    55d0:	53 81       	ldd	r21, Z+3	; 0x03
    55d2:	8b 81       	ldd	r24, Y+3	; 0x03
    55d4:	9c 81       	ldd	r25, Y+4	; 0x04
    55d6:	ad 81       	ldd	r26, Y+5	; 0x05
    55d8:	be 81       	ldd	r27, Y+6	; 0x06
    55da:	80 95       	com	r24
    55dc:	90 95       	com	r25
    55de:	a0 95       	com	r26
    55e0:	b0 95       	com	r27
    55e2:	28 23       	and	r18, r24
    55e4:	39 23       	and	r19, r25
    55e6:	4a 23       	and	r20, r26
    55e8:	5b 23       	and	r21, r27
    55ea:	c8 01       	movw	r24, r16
    55ec:	88 0f       	add	r24, r24
    55ee:	99 1f       	adc	r25, r25
    55f0:	88 0f       	add	r24, r24
    55f2:	99 1f       	adc	r25, r25
    55f4:	86 0f       	add	r24, r22
    55f6:	97 1f       	adc	r25, r23
    55f8:	fc 01       	movw	r30, r24
    55fa:	b7 96       	adiw	r30, 0x27	; 39
    55fc:	20 83       	st	Z, r18
    55fe:	31 83       	std	Z+1, r19	; 0x01
    5600:	42 83       	std	Z+2, r20	; 0x02
    5602:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    5604:	20 91 cc 06 	lds	r18, 0x06CC
    5608:	30 91 cd 06 	lds	r19, 0x06CD
    560c:	8a 81       	ldd	r24, Y+2	; 0x02
    560e:	88 2f       	mov	r24, r24
    5610:	90 e0       	ldi	r25, 0x00	; 0
    5612:	82 0f       	add	r24, r18
    5614:	93 1f       	adc	r25, r19
    5616:	fc 01       	movw	r30, r24
    5618:	bb 96       	adiw	r30, 0x2b	; 43
    561a:	81 e0       	ldi	r24, 0x01	; 1
    561c:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    561e:	8d 85       	ldd	r24, Y+13	; 0x0d
    5620:	9e 85       	ldd	r25, Y+14	; 0x0e
    5622:	00 97       	sbiw	r24, 0x00	; 0
    5624:	39 f0       	breq	.+14     	; 0x5634 <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5626:	8d 85       	ldd	r24, Y+13	; 0x0d
    5628:	9e 85       	ldd	r25, Y+14	; 0x0e
    562a:	61 e0       	ldi	r22, 0x01	; 1
    562c:	0e 94 73 31 	call	0x62e6	; 0x62e6 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    5630:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    5634:	0f 90       	pop	r0
    5636:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    5638:	0f b6       	in	r0, 0x3f	; 63
    563a:	f8 94       	cli
    563c:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    563e:	8b 85       	ldd	r24, Y+11	; 0x0b
    5640:	9c 85       	ldd	r25, Y+12	; 0x0c
    5642:	00 97       	sbiw	r24, 0x00	; 0
    5644:	c9 f0       	breq	.+50     	; 0x5678 <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    5646:	20 91 cc 06 	lds	r18, 0x06CC
    564a:	30 91 cd 06 	lds	r19, 0x06CD
    564e:	8a 81       	ldd	r24, Y+2	; 0x02
    5650:	88 2f       	mov	r24, r24
    5652:	90 e0       	ldi	r25, 0x00	; 0
    5654:	88 0f       	add	r24, r24
    5656:	99 1f       	adc	r25, r25
    5658:	88 0f       	add	r24, r24
    565a:	99 1f       	adc	r25, r25
    565c:	82 0f       	add	r24, r18
    565e:	93 1f       	adc	r25, r19
    5660:	fc 01       	movw	r30, r24
    5662:	b7 96       	adiw	r30, 0x27	; 39
    5664:	80 81       	ld	r24, Z
    5666:	91 81       	ldd	r25, Z+1	; 0x01
    5668:	a2 81       	ldd	r26, Z+2	; 0x02
    566a:	b3 81       	ldd	r27, Z+3	; 0x03
    566c:	eb 85       	ldd	r30, Y+11	; 0x0b
    566e:	fc 85       	ldd	r31, Y+12	; 0x0c
    5670:	80 83       	st	Z, r24
    5672:	91 83       	std	Z+1, r25	; 0x01
    5674:	a2 83       	std	Z+2, r26	; 0x02
    5676:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    5678:	20 91 cc 06 	lds	r18, 0x06CC
    567c:	30 91 cd 06 	lds	r19, 0x06CD
    5680:	8a 81       	ldd	r24, Y+2	; 0x02
    5682:	88 2f       	mov	r24, r24
    5684:	90 e0       	ldi	r25, 0x00	; 0
    5686:	82 0f       	add	r24, r18
    5688:	93 1f       	adc	r25, r19
    568a:	fc 01       	movw	r30, r24
    568c:	bb 96       	adiw	r30, 0x2b	; 43
    568e:	80 81       	ld	r24, Z
    5690:	82 30       	cpi	r24, 0x02	; 2
    5692:	11 f0       	breq	.+4      	; 0x5698 <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    5694:	19 82       	std	Y+1, r1	; 0x01
    5696:	31 c0       	rjmp	.+98     	; 0x56fa <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    5698:	60 91 cc 06 	lds	r22, 0x06CC
    569c:	70 91 cd 06 	lds	r23, 0x06CD
    56a0:	8a 81       	ldd	r24, Y+2	; 0x02
    56a2:	08 2f       	mov	r16, r24
    56a4:	10 e0       	ldi	r17, 0x00	; 0
    56a6:	8a 81       	ldd	r24, Y+2	; 0x02
    56a8:	88 2f       	mov	r24, r24
    56aa:	90 e0       	ldi	r25, 0x00	; 0
    56ac:	88 0f       	add	r24, r24
    56ae:	99 1f       	adc	r25, r25
    56b0:	88 0f       	add	r24, r24
    56b2:	99 1f       	adc	r25, r25
    56b4:	86 0f       	add	r24, r22
    56b6:	97 1f       	adc	r25, r23
    56b8:	fc 01       	movw	r30, r24
    56ba:	b7 96       	adiw	r30, 0x27	; 39
    56bc:	20 81       	ld	r18, Z
    56be:	31 81       	ldd	r19, Z+1	; 0x01
    56c0:	42 81       	ldd	r20, Z+2	; 0x02
    56c2:	53 81       	ldd	r21, Z+3	; 0x03
    56c4:	8f 81       	ldd	r24, Y+7	; 0x07
    56c6:	98 85       	ldd	r25, Y+8	; 0x08
    56c8:	a9 85       	ldd	r26, Y+9	; 0x09
    56ca:	ba 85       	ldd	r27, Y+10	; 0x0a
    56cc:	80 95       	com	r24
    56ce:	90 95       	com	r25
    56d0:	a0 95       	com	r26
    56d2:	b0 95       	com	r27
    56d4:	28 23       	and	r18, r24
    56d6:	39 23       	and	r19, r25
    56d8:	4a 23       	and	r20, r26
    56da:	5b 23       	and	r21, r27
    56dc:	c8 01       	movw	r24, r16
    56de:	88 0f       	add	r24, r24
    56e0:	99 1f       	adc	r25, r25
    56e2:	88 0f       	add	r24, r24
    56e4:	99 1f       	adc	r25, r25
    56e6:	86 0f       	add	r24, r22
    56e8:	97 1f       	adc	r25, r23
    56ea:	fc 01       	movw	r30, r24
    56ec:	b7 96       	adiw	r30, 0x27	; 39
    56ee:	20 83       	st	Z, r18
    56f0:	31 83       	std	Z+1, r19	; 0x01
    56f2:	42 83       	std	Z+2, r20	; 0x02
    56f4:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    56f6:	81 e0       	ldi	r24, 0x01	; 1
    56f8:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    56fa:	20 91 cc 06 	lds	r18, 0x06CC
    56fe:	30 91 cd 06 	lds	r19, 0x06CD
    5702:	8a 81       	ldd	r24, Y+2	; 0x02
    5704:	88 2f       	mov	r24, r24
    5706:	90 e0       	ldi	r25, 0x00	; 0
    5708:	82 0f       	add	r24, r18
    570a:	93 1f       	adc	r25, r19
    570c:	fc 01       	movw	r30, r24
    570e:	bb 96       	adiw	r30, 0x2b	; 43
    5710:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    5712:	0f 90       	pop	r0
    5714:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5716:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5718:	2e 96       	adiw	r28, 0x0e	; 14
    571a:	0f b6       	in	r0, 0x3f	; 63
    571c:	f8 94       	cli
    571e:	de bf       	out	0x3e, r29	; 62
    5720:	0f be       	out	0x3f, r0	; 63
    5722:	cd bf       	out	0x3d, r28	; 61
    5724:	cf 91       	pop	r28
    5726:	df 91       	pop	r29
    5728:	1f 91       	pop	r17
    572a:	0f 91       	pop	r16
    572c:	ff 90       	pop	r15
    572e:	ef 90       	pop	r14
    5730:	df 90       	pop	r13
    5732:	cf 90       	pop	r12
    5734:	08 95       	ret

00005736 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    5736:	ef 92       	push	r14
    5738:	ff 92       	push	r15
    573a:	0f 93       	push	r16
    573c:	1f 93       	push	r17
    573e:	df 93       	push	r29
    5740:	cf 93       	push	r28
    5742:	cd b7       	in	r28, 0x3d	; 61
    5744:	de b7       	in	r29, 0x3e	; 62
    5746:	64 97       	sbiw	r28, 0x14	; 20
    5748:	0f b6       	in	r0, 0x3f	; 63
    574a:	f8 94       	cli
    574c:	de bf       	out	0x3e, r29	; 62
    574e:	0f be       	out	0x3f, r0	; 63
    5750:	cd bf       	out	0x3d, r28	; 61
    5752:	9a 87       	std	Y+10, r25	; 0x0a
    5754:	89 87       	std	Y+9, r24	; 0x09
    5756:	6b 87       	std	Y+11, r22	; 0x0b
    5758:	2c 87       	std	Y+12, r18	; 0x0c
    575a:	3d 87       	std	Y+13, r19	; 0x0d
    575c:	4e 87       	std	Y+14, r20	; 0x0e
    575e:	5f 87       	std	Y+15, r21	; 0x0f
    5760:	08 8b       	std	Y+16, r16	; 0x10
    5762:	fa 8a       	std	Y+18, r15	; 0x12
    5764:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    5766:	81 e0       	ldi	r24, 0x01	; 1
    5768:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    576a:	89 85       	ldd	r24, Y+9	; 0x09
    576c:	9a 85       	ldd	r25, Y+10	; 0x0a
    576e:	98 87       	std	Y+8, r25	; 0x08
    5770:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    5772:	0f b6       	in	r0, 0x3f	; 63
    5774:	f8 94       	cli
    5776:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    5778:	89 89       	ldd	r24, Y+17	; 0x11
    577a:	9a 89       	ldd	r25, Y+18	; 0x12
    577c:	00 97       	sbiw	r24, 0x00	; 0
    577e:	b9 f0       	breq	.+46     	; 0x57ae <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    5780:	8b 85       	ldd	r24, Y+11	; 0x0b
    5782:	88 2f       	mov	r24, r24
    5784:	90 e0       	ldi	r25, 0x00	; 0
    5786:	2f 81       	ldd	r18, Y+7	; 0x07
    5788:	38 85       	ldd	r19, Y+8	; 0x08
    578a:	88 0f       	add	r24, r24
    578c:	99 1f       	adc	r25, r25
    578e:	88 0f       	add	r24, r24
    5790:	99 1f       	adc	r25, r25
    5792:	82 0f       	add	r24, r18
    5794:	93 1f       	adc	r25, r19
    5796:	fc 01       	movw	r30, r24
    5798:	b7 96       	adiw	r30, 0x27	; 39
    579a:	80 81       	ld	r24, Z
    579c:	91 81       	ldd	r25, Z+1	; 0x01
    579e:	a2 81       	ldd	r26, Z+2	; 0x02
    57a0:	b3 81       	ldd	r27, Z+3	; 0x03
    57a2:	e9 89       	ldd	r30, Y+17	; 0x11
    57a4:	fa 89       	ldd	r31, Y+18	; 0x12
    57a6:	80 83       	st	Z, r24
    57a8:	91 83       	std	Z+1, r25	; 0x01
    57aa:	a2 83       	std	Z+2, r26	; 0x02
    57ac:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    57ae:	8b 85       	ldd	r24, Y+11	; 0x0b
    57b0:	28 2f       	mov	r18, r24
    57b2:	30 e0       	ldi	r19, 0x00	; 0
    57b4:	8f 81       	ldd	r24, Y+7	; 0x07
    57b6:	98 85       	ldd	r25, Y+8	; 0x08
    57b8:	82 0f       	add	r24, r18
    57ba:	93 1f       	adc	r25, r19
    57bc:	fc 01       	movw	r30, r24
    57be:	bb 96       	adiw	r30, 0x2b	; 43
    57c0:	80 81       	ld	r24, Z
    57c2:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    57c4:	8b 85       	ldd	r24, Y+11	; 0x0b
    57c6:	28 2f       	mov	r18, r24
    57c8:	30 e0       	ldi	r19, 0x00	; 0
    57ca:	8f 81       	ldd	r24, Y+7	; 0x07
    57cc:	98 85       	ldd	r25, Y+8	; 0x08
    57ce:	82 0f       	add	r24, r18
    57d0:	93 1f       	adc	r25, r19
    57d2:	fc 01       	movw	r30, r24
    57d4:	bb 96       	adiw	r30, 0x2b	; 43
    57d6:	82 e0       	ldi	r24, 0x02	; 2
    57d8:	80 83       	st	Z, r24

            switch( eAction )
    57da:	88 89       	ldd	r24, Y+16	; 0x10
    57dc:	28 2f       	mov	r18, r24
    57de:	30 e0       	ldi	r19, 0x00	; 0
    57e0:	3c 8b       	std	Y+20, r19	; 0x14
    57e2:	2b 8b       	std	Y+19, r18	; 0x13
    57e4:	8b 89       	ldd	r24, Y+19	; 0x13
    57e6:	9c 89       	ldd	r25, Y+20	; 0x14
    57e8:	82 30       	cpi	r24, 0x02	; 2
    57ea:	91 05       	cpc	r25, r1
    57ec:	09 f4       	brne	.+2      	; 0x57f0 <xTaskGenericNotify+0xba>
    57ee:	46 c0       	rjmp	.+140    	; 0x587c <xTaskGenericNotify+0x146>
    57f0:	2b 89       	ldd	r18, Y+19	; 0x13
    57f2:	3c 89       	ldd	r19, Y+20	; 0x14
    57f4:	23 30       	cpi	r18, 0x03	; 3
    57f6:	31 05       	cpc	r19, r1
    57f8:	34 f4       	brge	.+12     	; 0x5806 <xTaskGenericNotify+0xd0>
    57fa:	8b 89       	ldd	r24, Y+19	; 0x13
    57fc:	9c 89       	ldd	r25, Y+20	; 0x14
    57fe:	81 30       	cpi	r24, 0x01	; 1
    5800:	91 05       	cpc	r25, r1
    5802:	71 f0       	breq	.+28     	; 0x5820 <xTaskGenericNotify+0xea>
    5804:	93 c0       	rjmp	.+294    	; 0x592c <xTaskGenericNotify+0x1f6>
    5806:	2b 89       	ldd	r18, Y+19	; 0x13
    5808:	3c 89       	ldd	r19, Y+20	; 0x14
    580a:	23 30       	cpi	r18, 0x03	; 3
    580c:	31 05       	cpc	r19, r1
    580e:	09 f4       	brne	.+2      	; 0x5812 <xTaskGenericNotify+0xdc>
    5810:	5d c0       	rjmp	.+186    	; 0x58cc <xTaskGenericNotify+0x196>
    5812:	8b 89       	ldd	r24, Y+19	; 0x13
    5814:	9c 89       	ldd	r25, Y+20	; 0x14
    5816:	84 30       	cpi	r24, 0x04	; 4
    5818:	91 05       	cpc	r25, r1
    581a:	09 f4       	brne	.+2      	; 0x581e <xTaskGenericNotify+0xe8>
    581c:	6d c0       	rjmp	.+218    	; 0x58f8 <xTaskGenericNotify+0x1c2>
    581e:	86 c0       	rjmp	.+268    	; 0x592c <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    5820:	8b 85       	ldd	r24, Y+11	; 0x0b
    5822:	08 2f       	mov	r16, r24
    5824:	10 e0       	ldi	r17, 0x00	; 0
    5826:	8b 85       	ldd	r24, Y+11	; 0x0b
    5828:	88 2f       	mov	r24, r24
    582a:	90 e0       	ldi	r25, 0x00	; 0
    582c:	2f 81       	ldd	r18, Y+7	; 0x07
    582e:	38 85       	ldd	r19, Y+8	; 0x08
    5830:	88 0f       	add	r24, r24
    5832:	99 1f       	adc	r25, r25
    5834:	88 0f       	add	r24, r24
    5836:	99 1f       	adc	r25, r25
    5838:	82 0f       	add	r24, r18
    583a:	93 1f       	adc	r25, r19
    583c:	fc 01       	movw	r30, r24
    583e:	b7 96       	adiw	r30, 0x27	; 39
    5840:	20 81       	ld	r18, Z
    5842:	31 81       	ldd	r19, Z+1	; 0x01
    5844:	42 81       	ldd	r20, Z+2	; 0x02
    5846:	53 81       	ldd	r21, Z+3	; 0x03
    5848:	8c 85       	ldd	r24, Y+12	; 0x0c
    584a:	9d 85       	ldd	r25, Y+13	; 0x0d
    584c:	ae 85       	ldd	r26, Y+14	; 0x0e
    584e:	bf 85       	ldd	r27, Y+15	; 0x0f
    5850:	ba 01       	movw	r22, r20
    5852:	a9 01       	movw	r20, r18
    5854:	48 2b       	or	r20, r24
    5856:	59 2b       	or	r21, r25
    5858:	6a 2b       	or	r22, r26
    585a:	7b 2b       	or	r23, r27
    585c:	2f 81       	ldd	r18, Y+7	; 0x07
    585e:	38 85       	ldd	r19, Y+8	; 0x08
    5860:	c8 01       	movw	r24, r16
    5862:	88 0f       	add	r24, r24
    5864:	99 1f       	adc	r25, r25
    5866:	88 0f       	add	r24, r24
    5868:	99 1f       	adc	r25, r25
    586a:	82 0f       	add	r24, r18
    586c:	93 1f       	adc	r25, r19
    586e:	fc 01       	movw	r30, r24
    5870:	b7 96       	adiw	r30, 0x27	; 39
    5872:	40 83       	st	Z, r20
    5874:	51 83       	std	Z+1, r21	; 0x01
    5876:	62 83       	std	Z+2, r22	; 0x02
    5878:	73 83       	std	Z+3, r23	; 0x03
    587a:	58 c0       	rjmp	.+176    	; 0x592c <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    587c:	8b 85       	ldd	r24, Y+11	; 0x0b
    587e:	08 2f       	mov	r16, r24
    5880:	10 e0       	ldi	r17, 0x00	; 0
    5882:	2f 81       	ldd	r18, Y+7	; 0x07
    5884:	38 85       	ldd	r19, Y+8	; 0x08
    5886:	c8 01       	movw	r24, r16
    5888:	88 0f       	add	r24, r24
    588a:	99 1f       	adc	r25, r25
    588c:	88 0f       	add	r24, r24
    588e:	99 1f       	adc	r25, r25
    5890:	82 0f       	add	r24, r18
    5892:	93 1f       	adc	r25, r19
    5894:	fc 01       	movw	r30, r24
    5896:	b7 96       	adiw	r30, 0x27	; 39
    5898:	80 81       	ld	r24, Z
    589a:	91 81       	ldd	r25, Z+1	; 0x01
    589c:	a2 81       	ldd	r26, Z+2	; 0x02
    589e:	b3 81       	ldd	r27, Z+3	; 0x03
    58a0:	ac 01       	movw	r20, r24
    58a2:	bd 01       	movw	r22, r26
    58a4:	4f 5f       	subi	r20, 0xFF	; 255
    58a6:	5f 4f       	sbci	r21, 0xFF	; 255
    58a8:	6f 4f       	sbci	r22, 0xFF	; 255
    58aa:	7f 4f       	sbci	r23, 0xFF	; 255
    58ac:	2f 81       	ldd	r18, Y+7	; 0x07
    58ae:	38 85       	ldd	r19, Y+8	; 0x08
    58b0:	c8 01       	movw	r24, r16
    58b2:	88 0f       	add	r24, r24
    58b4:	99 1f       	adc	r25, r25
    58b6:	88 0f       	add	r24, r24
    58b8:	99 1f       	adc	r25, r25
    58ba:	82 0f       	add	r24, r18
    58bc:	93 1f       	adc	r25, r19
    58be:	fc 01       	movw	r30, r24
    58c0:	b7 96       	adiw	r30, 0x27	; 39
    58c2:	40 83       	st	Z, r20
    58c4:	51 83       	std	Z+1, r21	; 0x01
    58c6:	62 83       	std	Z+2, r22	; 0x02
    58c8:	73 83       	std	Z+3, r23	; 0x03
    58ca:	30 c0       	rjmp	.+96     	; 0x592c <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    58cc:	8b 85       	ldd	r24, Y+11	; 0x0b
    58ce:	88 2f       	mov	r24, r24
    58d0:	90 e0       	ldi	r25, 0x00	; 0
    58d2:	2f 81       	ldd	r18, Y+7	; 0x07
    58d4:	38 85       	ldd	r19, Y+8	; 0x08
    58d6:	88 0f       	add	r24, r24
    58d8:	99 1f       	adc	r25, r25
    58da:	88 0f       	add	r24, r24
    58dc:	99 1f       	adc	r25, r25
    58de:	82 0f       	add	r24, r18
    58e0:	93 1f       	adc	r25, r19
    58e2:	fc 01       	movw	r30, r24
    58e4:	b7 96       	adiw	r30, 0x27	; 39
    58e6:	8c 85       	ldd	r24, Y+12	; 0x0c
    58e8:	9d 85       	ldd	r25, Y+13	; 0x0d
    58ea:	ae 85       	ldd	r26, Y+14	; 0x0e
    58ec:	bf 85       	ldd	r27, Y+15	; 0x0f
    58ee:	80 83       	st	Z, r24
    58f0:	91 83       	std	Z+1, r25	; 0x01
    58f2:	a2 83       	std	Z+2, r26	; 0x02
    58f4:	b3 83       	std	Z+3, r27	; 0x03
    58f6:	1a c0       	rjmp	.+52     	; 0x592c <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    58f8:	8d 81       	ldd	r24, Y+5	; 0x05
    58fa:	82 30       	cpi	r24, 0x02	; 2
    58fc:	b1 f0       	breq	.+44     	; 0x592a <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    58fe:	8b 85       	ldd	r24, Y+11	; 0x0b
    5900:	88 2f       	mov	r24, r24
    5902:	90 e0       	ldi	r25, 0x00	; 0
    5904:	2f 81       	ldd	r18, Y+7	; 0x07
    5906:	38 85       	ldd	r19, Y+8	; 0x08
    5908:	88 0f       	add	r24, r24
    590a:	99 1f       	adc	r25, r25
    590c:	88 0f       	add	r24, r24
    590e:	99 1f       	adc	r25, r25
    5910:	82 0f       	add	r24, r18
    5912:	93 1f       	adc	r25, r19
    5914:	fc 01       	movw	r30, r24
    5916:	b7 96       	adiw	r30, 0x27	; 39
    5918:	8c 85       	ldd	r24, Y+12	; 0x0c
    591a:	9d 85       	ldd	r25, Y+13	; 0x0d
    591c:	ae 85       	ldd	r26, Y+14	; 0x0e
    591e:	bf 85       	ldd	r27, Y+15	; 0x0f
    5920:	80 83       	st	Z, r24
    5922:	91 83       	std	Z+1, r25	; 0x01
    5924:	a2 83       	std	Z+2, r26	; 0x02
    5926:	b3 83       	std	Z+3, r27	; 0x03
    5928:	01 c0       	rjmp	.+2      	; 0x592c <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    592a:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    592c:	8d 81       	ldd	r24, Y+5	; 0x05
    592e:	81 30       	cpi	r24, 0x01	; 1
    5930:	09 f0       	breq	.+2      	; 0x5934 <xTaskGenericNotify+0x1fe>
    5932:	af c0       	rjmp	.+350    	; 0x5a92 <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5934:	ef 81       	ldd	r30, Y+7	; 0x07
    5936:	f8 85       	ldd	r31, Y+8	; 0x08
    5938:	82 85       	ldd	r24, Z+10	; 0x0a
    593a:	93 85       	ldd	r25, Z+11	; 0x0b
    593c:	9c 83       	std	Y+4, r25	; 0x04
    593e:	8b 83       	std	Y+3, r24	; 0x03
    5940:	ef 81       	ldd	r30, Y+7	; 0x07
    5942:	f8 85       	ldd	r31, Y+8	; 0x08
    5944:	a4 81       	ldd	r26, Z+4	; 0x04
    5946:	b5 81       	ldd	r27, Z+5	; 0x05
    5948:	ef 81       	ldd	r30, Y+7	; 0x07
    594a:	f8 85       	ldd	r31, Y+8	; 0x08
    594c:	86 81       	ldd	r24, Z+6	; 0x06
    594e:	97 81       	ldd	r25, Z+7	; 0x07
    5950:	15 96       	adiw	r26, 0x05	; 5
    5952:	9c 93       	st	X, r25
    5954:	8e 93       	st	-X, r24
    5956:	14 97       	sbiw	r26, 0x04	; 4
    5958:	ef 81       	ldd	r30, Y+7	; 0x07
    595a:	f8 85       	ldd	r31, Y+8	; 0x08
    595c:	a6 81       	ldd	r26, Z+6	; 0x06
    595e:	b7 81       	ldd	r27, Z+7	; 0x07
    5960:	ef 81       	ldd	r30, Y+7	; 0x07
    5962:	f8 85       	ldd	r31, Y+8	; 0x08
    5964:	84 81       	ldd	r24, Z+4	; 0x04
    5966:	95 81       	ldd	r25, Z+5	; 0x05
    5968:	13 96       	adiw	r26, 0x03	; 3
    596a:	9c 93       	st	X, r25
    596c:	8e 93       	st	-X, r24
    596e:	12 97       	sbiw	r26, 0x02	; 2
    5970:	eb 81       	ldd	r30, Y+3	; 0x03
    5972:	fc 81       	ldd	r31, Y+4	; 0x04
    5974:	21 81       	ldd	r18, Z+1	; 0x01
    5976:	32 81       	ldd	r19, Z+2	; 0x02
    5978:	8f 81       	ldd	r24, Y+7	; 0x07
    597a:	98 85       	ldd	r25, Y+8	; 0x08
    597c:	02 96       	adiw	r24, 0x02	; 2
    597e:	28 17       	cp	r18, r24
    5980:	39 07       	cpc	r19, r25
    5982:	41 f4       	brne	.+16     	; 0x5994 <xTaskGenericNotify+0x25e>
    5984:	ef 81       	ldd	r30, Y+7	; 0x07
    5986:	f8 85       	ldd	r31, Y+8	; 0x08
    5988:	86 81       	ldd	r24, Z+6	; 0x06
    598a:	97 81       	ldd	r25, Z+7	; 0x07
    598c:	eb 81       	ldd	r30, Y+3	; 0x03
    598e:	fc 81       	ldd	r31, Y+4	; 0x04
    5990:	92 83       	std	Z+2, r25	; 0x02
    5992:	81 83       	std	Z+1, r24	; 0x01
    5994:	ef 81       	ldd	r30, Y+7	; 0x07
    5996:	f8 85       	ldd	r31, Y+8	; 0x08
    5998:	13 86       	std	Z+11, r1	; 0x0b
    599a:	12 86       	std	Z+10, r1	; 0x0a
    599c:	eb 81       	ldd	r30, Y+3	; 0x03
    599e:	fc 81       	ldd	r31, Y+4	; 0x04
    59a0:	80 81       	ld	r24, Z
    59a2:	81 50       	subi	r24, 0x01	; 1
    59a4:	eb 81       	ldd	r30, Y+3	; 0x03
    59a6:	fc 81       	ldd	r31, Y+4	; 0x04
    59a8:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    59aa:	ef 81       	ldd	r30, Y+7	; 0x07
    59ac:	f8 85       	ldd	r31, Y+8	; 0x08
    59ae:	96 89       	ldd	r25, Z+22	; 0x16
    59b0:	80 91 d2 06 	lds	r24, 0x06D2
    59b4:	89 17       	cp	r24, r25
    59b6:	28 f4       	brcc	.+10     	; 0x59c2 <xTaskGenericNotify+0x28c>
    59b8:	ef 81       	ldd	r30, Y+7	; 0x07
    59ba:	f8 85       	ldd	r31, Y+8	; 0x08
    59bc:	86 89       	ldd	r24, Z+22	; 0x16
    59be:	80 93 d2 06 	sts	0x06D2, r24
    59c2:	ef 81       	ldd	r30, Y+7	; 0x07
    59c4:	f8 85       	ldd	r31, Y+8	; 0x08
    59c6:	86 89       	ldd	r24, Z+22	; 0x16
    59c8:	28 2f       	mov	r18, r24
    59ca:	30 e0       	ldi	r19, 0x00	; 0
    59cc:	c9 01       	movw	r24, r18
    59ce:	88 0f       	add	r24, r24
    59d0:	99 1f       	adc	r25, r25
    59d2:	88 0f       	add	r24, r24
    59d4:	99 1f       	adc	r25, r25
    59d6:	88 0f       	add	r24, r24
    59d8:	99 1f       	adc	r25, r25
    59da:	82 0f       	add	r24, r18
    59dc:	93 1f       	adc	r25, r19
    59de:	fc 01       	movw	r30, r24
    59e0:	ea 51       	subi	r30, 0x1A	; 26
    59e2:	f9 4f       	sbci	r31, 0xF9	; 249
    59e4:	81 81       	ldd	r24, Z+1	; 0x01
    59e6:	92 81       	ldd	r25, Z+2	; 0x02
    59e8:	9a 83       	std	Y+2, r25	; 0x02
    59ea:	89 83       	std	Y+1, r24	; 0x01
    59ec:	ef 81       	ldd	r30, Y+7	; 0x07
    59ee:	f8 85       	ldd	r31, Y+8	; 0x08
    59f0:	89 81       	ldd	r24, Y+1	; 0x01
    59f2:	9a 81       	ldd	r25, Y+2	; 0x02
    59f4:	95 83       	std	Z+5, r25	; 0x05
    59f6:	84 83       	std	Z+4, r24	; 0x04
    59f8:	e9 81       	ldd	r30, Y+1	; 0x01
    59fa:	fa 81       	ldd	r31, Y+2	; 0x02
    59fc:	84 81       	ldd	r24, Z+4	; 0x04
    59fe:	95 81       	ldd	r25, Z+5	; 0x05
    5a00:	ef 81       	ldd	r30, Y+7	; 0x07
    5a02:	f8 85       	ldd	r31, Y+8	; 0x08
    5a04:	97 83       	std	Z+7, r25	; 0x07
    5a06:	86 83       	std	Z+6, r24	; 0x06
    5a08:	e9 81       	ldd	r30, Y+1	; 0x01
    5a0a:	fa 81       	ldd	r31, Y+2	; 0x02
    5a0c:	04 80       	ldd	r0, Z+4	; 0x04
    5a0e:	f5 81       	ldd	r31, Z+5	; 0x05
    5a10:	e0 2d       	mov	r30, r0
    5a12:	8f 81       	ldd	r24, Y+7	; 0x07
    5a14:	98 85       	ldd	r25, Y+8	; 0x08
    5a16:	02 96       	adiw	r24, 0x02	; 2
    5a18:	93 83       	std	Z+3, r25	; 0x03
    5a1a:	82 83       	std	Z+2, r24	; 0x02
    5a1c:	8f 81       	ldd	r24, Y+7	; 0x07
    5a1e:	98 85       	ldd	r25, Y+8	; 0x08
    5a20:	02 96       	adiw	r24, 0x02	; 2
    5a22:	e9 81       	ldd	r30, Y+1	; 0x01
    5a24:	fa 81       	ldd	r31, Y+2	; 0x02
    5a26:	95 83       	std	Z+5, r25	; 0x05
    5a28:	84 83       	std	Z+4, r24	; 0x04
    5a2a:	ef 81       	ldd	r30, Y+7	; 0x07
    5a2c:	f8 85       	ldd	r31, Y+8	; 0x08
    5a2e:	86 89       	ldd	r24, Z+22	; 0x16
    5a30:	28 2f       	mov	r18, r24
    5a32:	30 e0       	ldi	r19, 0x00	; 0
    5a34:	c9 01       	movw	r24, r18
    5a36:	88 0f       	add	r24, r24
    5a38:	99 1f       	adc	r25, r25
    5a3a:	88 0f       	add	r24, r24
    5a3c:	99 1f       	adc	r25, r25
    5a3e:	88 0f       	add	r24, r24
    5a40:	99 1f       	adc	r25, r25
    5a42:	82 0f       	add	r24, r18
    5a44:	93 1f       	adc	r25, r19
    5a46:	8a 51       	subi	r24, 0x1A	; 26
    5a48:	99 4f       	sbci	r25, 0xF9	; 249
    5a4a:	ef 81       	ldd	r30, Y+7	; 0x07
    5a4c:	f8 85       	ldd	r31, Y+8	; 0x08
    5a4e:	93 87       	std	Z+11, r25	; 0x0b
    5a50:	82 87       	std	Z+10, r24	; 0x0a
    5a52:	ef 81       	ldd	r30, Y+7	; 0x07
    5a54:	f8 85       	ldd	r31, Y+8	; 0x08
    5a56:	86 89       	ldd	r24, Z+22	; 0x16
    5a58:	28 2f       	mov	r18, r24
    5a5a:	30 e0       	ldi	r19, 0x00	; 0
    5a5c:	c9 01       	movw	r24, r18
    5a5e:	88 0f       	add	r24, r24
    5a60:	99 1f       	adc	r25, r25
    5a62:	88 0f       	add	r24, r24
    5a64:	99 1f       	adc	r25, r25
    5a66:	88 0f       	add	r24, r24
    5a68:	99 1f       	adc	r25, r25
    5a6a:	82 0f       	add	r24, r18
    5a6c:	93 1f       	adc	r25, r19
    5a6e:	fc 01       	movw	r30, r24
    5a70:	ea 51       	subi	r30, 0x1A	; 26
    5a72:	f9 4f       	sbci	r31, 0xF9	; 249
    5a74:	80 81       	ld	r24, Z
    5a76:	8f 5f       	subi	r24, 0xFF	; 255
    5a78:	80 83       	st	Z, r24
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5a7a:	ef 81       	ldd	r30, Y+7	; 0x07
    5a7c:	f8 85       	ldd	r31, Y+8	; 0x08
    5a7e:	96 89       	ldd	r25, Z+22	; 0x16
    5a80:	e0 91 cc 06 	lds	r30, 0x06CC
    5a84:	f0 91 cd 06 	lds	r31, 0x06CD
    5a88:	86 89       	ldd	r24, Z+22	; 0x16
    5a8a:	89 17       	cp	r24, r25
    5a8c:	10 f4       	brcc	.+4      	; 0x5a92 <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    5a8e:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    5a92:	0f 90       	pop	r0
    5a94:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5a96:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    5a98:	64 96       	adiw	r28, 0x14	; 20
    5a9a:	0f b6       	in	r0, 0x3f	; 63
    5a9c:	f8 94       	cli
    5a9e:	de bf       	out	0x3e, r29	; 62
    5aa0:	0f be       	out	0x3f, r0	; 63
    5aa2:	cd bf       	out	0x3d, r28	; 61
    5aa4:	cf 91       	pop	r28
    5aa6:	df 91       	pop	r29
    5aa8:	1f 91       	pop	r17
    5aaa:	0f 91       	pop	r16
    5aac:	ff 90       	pop	r15
    5aae:	ef 90       	pop	r14
    5ab0:	08 95       	ret

00005ab2 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    5ab2:	cf 92       	push	r12
    5ab4:	df 92       	push	r13
    5ab6:	ef 92       	push	r14
    5ab8:	ff 92       	push	r15
    5aba:	0f 93       	push	r16
    5abc:	1f 93       	push	r17
    5abe:	df 93       	push	r29
    5ac0:	cf 93       	push	r28
    5ac2:	cd b7       	in	r28, 0x3d	; 61
    5ac4:	de b7       	in	r29, 0x3e	; 62
    5ac6:	69 97       	sbiw	r28, 0x19	; 25
    5ac8:	0f b6       	in	r0, 0x3f	; 63
    5aca:	f8 94       	cli
    5acc:	de bf       	out	0x3e, r29	; 62
    5ace:	0f be       	out	0x3f, r0	; 63
    5ad0:	cd bf       	out	0x3d, r28	; 61
    5ad2:	9d 87       	std	Y+13, r25	; 0x0d
    5ad4:	8c 87       	std	Y+12, r24	; 0x0c
    5ad6:	6e 87       	std	Y+14, r22	; 0x0e
    5ad8:	2f 87       	std	Y+15, r18	; 0x0f
    5ada:	38 8b       	std	Y+16, r19	; 0x10
    5adc:	49 8b       	std	Y+17, r20	; 0x11
    5ade:	5a 8b       	std	Y+18, r21	; 0x12
    5ae0:	0b 8b       	std	Y+19, r16	; 0x13
    5ae2:	fd 8a       	std	Y+21, r15	; 0x15
    5ae4:	ec 8a       	std	Y+20, r14	; 0x14
    5ae6:	df 8a       	std	Y+23, r13	; 0x17
    5ae8:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    5aea:	81 e0       	ldi	r24, 0x01	; 1
    5aec:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    5aee:	8c 85       	ldd	r24, Y+12	; 0x0c
    5af0:	9d 85       	ldd	r25, Y+13	; 0x0d
    5af2:	9b 87       	std	Y+11, r25	; 0x0b
    5af4:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5af6:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    5af8:	8c 89       	ldd	r24, Y+20	; 0x14
    5afa:	9d 89       	ldd	r25, Y+21	; 0x15
    5afc:	00 97       	sbiw	r24, 0x00	; 0
    5afe:	b9 f0       	breq	.+46     	; 0x5b2e <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    5b00:	8e 85       	ldd	r24, Y+14	; 0x0e
    5b02:	88 2f       	mov	r24, r24
    5b04:	90 e0       	ldi	r25, 0x00	; 0
    5b06:	2a 85       	ldd	r18, Y+10	; 0x0a
    5b08:	3b 85       	ldd	r19, Y+11	; 0x0b
    5b0a:	88 0f       	add	r24, r24
    5b0c:	99 1f       	adc	r25, r25
    5b0e:	88 0f       	add	r24, r24
    5b10:	99 1f       	adc	r25, r25
    5b12:	82 0f       	add	r24, r18
    5b14:	93 1f       	adc	r25, r19
    5b16:	fc 01       	movw	r30, r24
    5b18:	b7 96       	adiw	r30, 0x27	; 39
    5b1a:	80 81       	ld	r24, Z
    5b1c:	91 81       	ldd	r25, Z+1	; 0x01
    5b1e:	a2 81       	ldd	r26, Z+2	; 0x02
    5b20:	b3 81       	ldd	r27, Z+3	; 0x03
    5b22:	ec 89       	ldd	r30, Y+20	; 0x14
    5b24:	fd 89       	ldd	r31, Y+21	; 0x15
    5b26:	80 83       	st	Z, r24
    5b28:	91 83       	std	Z+1, r25	; 0x01
    5b2a:	a2 83       	std	Z+2, r26	; 0x02
    5b2c:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5b2e:	8e 85       	ldd	r24, Y+14	; 0x0e
    5b30:	28 2f       	mov	r18, r24
    5b32:	30 e0       	ldi	r19, 0x00	; 0
    5b34:	8a 85       	ldd	r24, Y+10	; 0x0a
    5b36:	9b 85       	ldd	r25, Y+11	; 0x0b
    5b38:	82 0f       	add	r24, r18
    5b3a:	93 1f       	adc	r25, r19
    5b3c:	fc 01       	movw	r30, r24
    5b3e:	bb 96       	adiw	r30, 0x2b	; 43
    5b40:	80 81       	ld	r24, Z
    5b42:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    5b44:	8e 85       	ldd	r24, Y+14	; 0x0e
    5b46:	28 2f       	mov	r18, r24
    5b48:	30 e0       	ldi	r19, 0x00	; 0
    5b4a:	8a 85       	ldd	r24, Y+10	; 0x0a
    5b4c:	9b 85       	ldd	r25, Y+11	; 0x0b
    5b4e:	82 0f       	add	r24, r18
    5b50:	93 1f       	adc	r25, r19
    5b52:	fc 01       	movw	r30, r24
    5b54:	bb 96       	adiw	r30, 0x2b	; 43
    5b56:	82 e0       	ldi	r24, 0x02	; 2
    5b58:	80 83       	st	Z, r24

            switch( eAction )
    5b5a:	8b 89       	ldd	r24, Y+19	; 0x13
    5b5c:	28 2f       	mov	r18, r24
    5b5e:	30 e0       	ldi	r19, 0x00	; 0
    5b60:	39 8f       	std	Y+25, r19	; 0x19
    5b62:	28 8f       	std	Y+24, r18	; 0x18
    5b64:	88 8d       	ldd	r24, Y+24	; 0x18
    5b66:	99 8d       	ldd	r25, Y+25	; 0x19
    5b68:	82 30       	cpi	r24, 0x02	; 2
    5b6a:	91 05       	cpc	r25, r1
    5b6c:	09 f4       	brne	.+2      	; 0x5b70 <xTaskGenericNotifyFromISR+0xbe>
    5b6e:	46 c0       	rjmp	.+140    	; 0x5bfc <xTaskGenericNotifyFromISR+0x14a>
    5b70:	28 8d       	ldd	r18, Y+24	; 0x18
    5b72:	39 8d       	ldd	r19, Y+25	; 0x19
    5b74:	23 30       	cpi	r18, 0x03	; 3
    5b76:	31 05       	cpc	r19, r1
    5b78:	34 f4       	brge	.+12     	; 0x5b86 <xTaskGenericNotifyFromISR+0xd4>
    5b7a:	88 8d       	ldd	r24, Y+24	; 0x18
    5b7c:	99 8d       	ldd	r25, Y+25	; 0x19
    5b7e:	81 30       	cpi	r24, 0x01	; 1
    5b80:	91 05       	cpc	r25, r1
    5b82:	71 f0       	breq	.+28     	; 0x5ba0 <xTaskGenericNotifyFromISR+0xee>
    5b84:	93 c0       	rjmp	.+294    	; 0x5cac <xTaskGenericNotifyFromISR+0x1fa>
    5b86:	28 8d       	ldd	r18, Y+24	; 0x18
    5b88:	39 8d       	ldd	r19, Y+25	; 0x19
    5b8a:	23 30       	cpi	r18, 0x03	; 3
    5b8c:	31 05       	cpc	r19, r1
    5b8e:	09 f4       	brne	.+2      	; 0x5b92 <xTaskGenericNotifyFromISR+0xe0>
    5b90:	5d c0       	rjmp	.+186    	; 0x5c4c <xTaskGenericNotifyFromISR+0x19a>
    5b92:	88 8d       	ldd	r24, Y+24	; 0x18
    5b94:	99 8d       	ldd	r25, Y+25	; 0x19
    5b96:	84 30       	cpi	r24, 0x04	; 4
    5b98:	91 05       	cpc	r25, r1
    5b9a:	09 f4       	brne	.+2      	; 0x5b9e <xTaskGenericNotifyFromISR+0xec>
    5b9c:	6d c0       	rjmp	.+218    	; 0x5c78 <xTaskGenericNotifyFromISR+0x1c6>
    5b9e:	86 c0       	rjmp	.+268    	; 0x5cac <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    5ba0:	8e 85       	ldd	r24, Y+14	; 0x0e
    5ba2:	08 2f       	mov	r16, r24
    5ba4:	10 e0       	ldi	r17, 0x00	; 0
    5ba6:	8e 85       	ldd	r24, Y+14	; 0x0e
    5ba8:	88 2f       	mov	r24, r24
    5baa:	90 e0       	ldi	r25, 0x00	; 0
    5bac:	2a 85       	ldd	r18, Y+10	; 0x0a
    5bae:	3b 85       	ldd	r19, Y+11	; 0x0b
    5bb0:	88 0f       	add	r24, r24
    5bb2:	99 1f       	adc	r25, r25
    5bb4:	88 0f       	add	r24, r24
    5bb6:	99 1f       	adc	r25, r25
    5bb8:	82 0f       	add	r24, r18
    5bba:	93 1f       	adc	r25, r19
    5bbc:	fc 01       	movw	r30, r24
    5bbe:	b7 96       	adiw	r30, 0x27	; 39
    5bc0:	20 81       	ld	r18, Z
    5bc2:	31 81       	ldd	r19, Z+1	; 0x01
    5bc4:	42 81       	ldd	r20, Z+2	; 0x02
    5bc6:	53 81       	ldd	r21, Z+3	; 0x03
    5bc8:	8f 85       	ldd	r24, Y+15	; 0x0f
    5bca:	98 89       	ldd	r25, Y+16	; 0x10
    5bcc:	a9 89       	ldd	r26, Y+17	; 0x11
    5bce:	ba 89       	ldd	r27, Y+18	; 0x12
    5bd0:	ba 01       	movw	r22, r20
    5bd2:	a9 01       	movw	r20, r18
    5bd4:	48 2b       	or	r20, r24
    5bd6:	59 2b       	or	r21, r25
    5bd8:	6a 2b       	or	r22, r26
    5bda:	7b 2b       	or	r23, r27
    5bdc:	2a 85       	ldd	r18, Y+10	; 0x0a
    5bde:	3b 85       	ldd	r19, Y+11	; 0x0b
    5be0:	c8 01       	movw	r24, r16
    5be2:	88 0f       	add	r24, r24
    5be4:	99 1f       	adc	r25, r25
    5be6:	88 0f       	add	r24, r24
    5be8:	99 1f       	adc	r25, r25
    5bea:	82 0f       	add	r24, r18
    5bec:	93 1f       	adc	r25, r19
    5bee:	fc 01       	movw	r30, r24
    5bf0:	b7 96       	adiw	r30, 0x27	; 39
    5bf2:	40 83       	st	Z, r20
    5bf4:	51 83       	std	Z+1, r21	; 0x01
    5bf6:	62 83       	std	Z+2, r22	; 0x02
    5bf8:	73 83       	std	Z+3, r23	; 0x03
    5bfa:	58 c0       	rjmp	.+176    	; 0x5cac <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    5bfc:	8e 85       	ldd	r24, Y+14	; 0x0e
    5bfe:	08 2f       	mov	r16, r24
    5c00:	10 e0       	ldi	r17, 0x00	; 0
    5c02:	2a 85       	ldd	r18, Y+10	; 0x0a
    5c04:	3b 85       	ldd	r19, Y+11	; 0x0b
    5c06:	c8 01       	movw	r24, r16
    5c08:	88 0f       	add	r24, r24
    5c0a:	99 1f       	adc	r25, r25
    5c0c:	88 0f       	add	r24, r24
    5c0e:	99 1f       	adc	r25, r25
    5c10:	82 0f       	add	r24, r18
    5c12:	93 1f       	adc	r25, r19
    5c14:	fc 01       	movw	r30, r24
    5c16:	b7 96       	adiw	r30, 0x27	; 39
    5c18:	80 81       	ld	r24, Z
    5c1a:	91 81       	ldd	r25, Z+1	; 0x01
    5c1c:	a2 81       	ldd	r26, Z+2	; 0x02
    5c1e:	b3 81       	ldd	r27, Z+3	; 0x03
    5c20:	ac 01       	movw	r20, r24
    5c22:	bd 01       	movw	r22, r26
    5c24:	4f 5f       	subi	r20, 0xFF	; 255
    5c26:	5f 4f       	sbci	r21, 0xFF	; 255
    5c28:	6f 4f       	sbci	r22, 0xFF	; 255
    5c2a:	7f 4f       	sbci	r23, 0xFF	; 255
    5c2c:	2a 85       	ldd	r18, Y+10	; 0x0a
    5c2e:	3b 85       	ldd	r19, Y+11	; 0x0b
    5c30:	c8 01       	movw	r24, r16
    5c32:	88 0f       	add	r24, r24
    5c34:	99 1f       	adc	r25, r25
    5c36:	88 0f       	add	r24, r24
    5c38:	99 1f       	adc	r25, r25
    5c3a:	82 0f       	add	r24, r18
    5c3c:	93 1f       	adc	r25, r19
    5c3e:	fc 01       	movw	r30, r24
    5c40:	b7 96       	adiw	r30, 0x27	; 39
    5c42:	40 83       	st	Z, r20
    5c44:	51 83       	std	Z+1, r21	; 0x01
    5c46:	62 83       	std	Z+2, r22	; 0x02
    5c48:	73 83       	std	Z+3, r23	; 0x03
    5c4a:	30 c0       	rjmp	.+96     	; 0x5cac <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5c4c:	8e 85       	ldd	r24, Y+14	; 0x0e
    5c4e:	88 2f       	mov	r24, r24
    5c50:	90 e0       	ldi	r25, 0x00	; 0
    5c52:	2a 85       	ldd	r18, Y+10	; 0x0a
    5c54:	3b 85       	ldd	r19, Y+11	; 0x0b
    5c56:	88 0f       	add	r24, r24
    5c58:	99 1f       	adc	r25, r25
    5c5a:	88 0f       	add	r24, r24
    5c5c:	99 1f       	adc	r25, r25
    5c5e:	82 0f       	add	r24, r18
    5c60:	93 1f       	adc	r25, r19
    5c62:	fc 01       	movw	r30, r24
    5c64:	b7 96       	adiw	r30, 0x27	; 39
    5c66:	8f 85       	ldd	r24, Y+15	; 0x0f
    5c68:	98 89       	ldd	r25, Y+16	; 0x10
    5c6a:	a9 89       	ldd	r26, Y+17	; 0x11
    5c6c:	ba 89       	ldd	r27, Y+18	; 0x12
    5c6e:	80 83       	st	Z, r24
    5c70:	91 83       	std	Z+1, r25	; 0x01
    5c72:	a2 83       	std	Z+2, r26	; 0x02
    5c74:	b3 83       	std	Z+3, r27	; 0x03
    5c76:	1a c0       	rjmp	.+52     	; 0x5cac <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5c78:	89 85       	ldd	r24, Y+9	; 0x09
    5c7a:	82 30       	cpi	r24, 0x02	; 2
    5c7c:	b1 f0       	breq	.+44     	; 0x5caa <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5c7e:	8e 85       	ldd	r24, Y+14	; 0x0e
    5c80:	88 2f       	mov	r24, r24
    5c82:	90 e0       	ldi	r25, 0x00	; 0
    5c84:	2a 85       	ldd	r18, Y+10	; 0x0a
    5c86:	3b 85       	ldd	r19, Y+11	; 0x0b
    5c88:	88 0f       	add	r24, r24
    5c8a:	99 1f       	adc	r25, r25
    5c8c:	88 0f       	add	r24, r24
    5c8e:	99 1f       	adc	r25, r25
    5c90:	82 0f       	add	r24, r18
    5c92:	93 1f       	adc	r25, r19
    5c94:	fc 01       	movw	r30, r24
    5c96:	b7 96       	adiw	r30, 0x27	; 39
    5c98:	8f 85       	ldd	r24, Y+15	; 0x0f
    5c9a:	98 89       	ldd	r25, Y+16	; 0x10
    5c9c:	a9 89       	ldd	r26, Y+17	; 0x11
    5c9e:	ba 89       	ldd	r27, Y+18	; 0x12
    5ca0:	80 83       	st	Z, r24
    5ca2:	91 83       	std	Z+1, r25	; 0x01
    5ca4:	a2 83       	std	Z+2, r26	; 0x02
    5ca6:	b3 83       	std	Z+3, r27	; 0x03
    5ca8:	01 c0       	rjmp	.+2      	; 0x5cac <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    5caa:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5cac:	89 85       	ldd	r24, Y+9	; 0x09
    5cae:	81 30       	cpi	r24, 0x01	; 1
    5cb0:	09 f0       	breq	.+2      	; 0x5cb4 <xTaskGenericNotifyFromISR+0x202>
    5cb2:	ee c0       	rjmp	.+476    	; 0x5e90 <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5cb4:	80 91 dd 06 	lds	r24, 0x06DD
    5cb8:	88 23       	and	r24, r24
    5cba:	09 f0       	breq	.+2      	; 0x5cbe <xTaskGenericNotifyFromISR+0x20c>
    5cbc:	a4 c0       	rjmp	.+328    	; 0x5e06 <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5cbe:	ea 85       	ldd	r30, Y+10	; 0x0a
    5cc0:	fb 85       	ldd	r31, Y+11	; 0x0b
    5cc2:	82 85       	ldd	r24, Z+10	; 0x0a
    5cc4:	93 85       	ldd	r25, Z+11	; 0x0b
    5cc6:	9e 83       	std	Y+6, r25	; 0x06
    5cc8:	8d 83       	std	Y+5, r24	; 0x05
    5cca:	ea 85       	ldd	r30, Y+10	; 0x0a
    5ccc:	fb 85       	ldd	r31, Y+11	; 0x0b
    5cce:	a4 81       	ldd	r26, Z+4	; 0x04
    5cd0:	b5 81       	ldd	r27, Z+5	; 0x05
    5cd2:	ea 85       	ldd	r30, Y+10	; 0x0a
    5cd4:	fb 85       	ldd	r31, Y+11	; 0x0b
    5cd6:	86 81       	ldd	r24, Z+6	; 0x06
    5cd8:	97 81       	ldd	r25, Z+7	; 0x07
    5cda:	15 96       	adiw	r26, 0x05	; 5
    5cdc:	9c 93       	st	X, r25
    5cde:	8e 93       	st	-X, r24
    5ce0:	14 97       	sbiw	r26, 0x04	; 4
    5ce2:	ea 85       	ldd	r30, Y+10	; 0x0a
    5ce4:	fb 85       	ldd	r31, Y+11	; 0x0b
    5ce6:	a6 81       	ldd	r26, Z+6	; 0x06
    5ce8:	b7 81       	ldd	r27, Z+7	; 0x07
    5cea:	ea 85       	ldd	r30, Y+10	; 0x0a
    5cec:	fb 85       	ldd	r31, Y+11	; 0x0b
    5cee:	84 81       	ldd	r24, Z+4	; 0x04
    5cf0:	95 81       	ldd	r25, Z+5	; 0x05
    5cf2:	13 96       	adiw	r26, 0x03	; 3
    5cf4:	9c 93       	st	X, r25
    5cf6:	8e 93       	st	-X, r24
    5cf8:	12 97       	sbiw	r26, 0x02	; 2
    5cfa:	ed 81       	ldd	r30, Y+5	; 0x05
    5cfc:	fe 81       	ldd	r31, Y+6	; 0x06
    5cfe:	21 81       	ldd	r18, Z+1	; 0x01
    5d00:	32 81       	ldd	r19, Z+2	; 0x02
    5d02:	8a 85       	ldd	r24, Y+10	; 0x0a
    5d04:	9b 85       	ldd	r25, Y+11	; 0x0b
    5d06:	02 96       	adiw	r24, 0x02	; 2
    5d08:	28 17       	cp	r18, r24
    5d0a:	39 07       	cpc	r19, r25
    5d0c:	41 f4       	brne	.+16     	; 0x5d1e <xTaskGenericNotifyFromISR+0x26c>
    5d0e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5d10:	fb 85       	ldd	r31, Y+11	; 0x0b
    5d12:	86 81       	ldd	r24, Z+6	; 0x06
    5d14:	97 81       	ldd	r25, Z+7	; 0x07
    5d16:	ed 81       	ldd	r30, Y+5	; 0x05
    5d18:	fe 81       	ldd	r31, Y+6	; 0x06
    5d1a:	92 83       	std	Z+2, r25	; 0x02
    5d1c:	81 83       	std	Z+1, r24	; 0x01
    5d1e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5d20:	fb 85       	ldd	r31, Y+11	; 0x0b
    5d22:	13 86       	std	Z+11, r1	; 0x0b
    5d24:	12 86       	std	Z+10, r1	; 0x0a
    5d26:	ed 81       	ldd	r30, Y+5	; 0x05
    5d28:	fe 81       	ldd	r31, Y+6	; 0x06
    5d2a:	80 81       	ld	r24, Z
    5d2c:	81 50       	subi	r24, 0x01	; 1
    5d2e:	ed 81       	ldd	r30, Y+5	; 0x05
    5d30:	fe 81       	ldd	r31, Y+6	; 0x06
    5d32:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5d34:	ea 85       	ldd	r30, Y+10	; 0x0a
    5d36:	fb 85       	ldd	r31, Y+11	; 0x0b
    5d38:	96 89       	ldd	r25, Z+22	; 0x16
    5d3a:	80 91 d2 06 	lds	r24, 0x06D2
    5d3e:	89 17       	cp	r24, r25
    5d40:	28 f4       	brcc	.+10     	; 0x5d4c <xTaskGenericNotifyFromISR+0x29a>
    5d42:	ea 85       	ldd	r30, Y+10	; 0x0a
    5d44:	fb 85       	ldd	r31, Y+11	; 0x0b
    5d46:	86 89       	ldd	r24, Z+22	; 0x16
    5d48:	80 93 d2 06 	sts	0x06D2, r24
    5d4c:	ea 85       	ldd	r30, Y+10	; 0x0a
    5d4e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5d50:	86 89       	ldd	r24, Z+22	; 0x16
    5d52:	28 2f       	mov	r18, r24
    5d54:	30 e0       	ldi	r19, 0x00	; 0
    5d56:	c9 01       	movw	r24, r18
    5d58:	88 0f       	add	r24, r24
    5d5a:	99 1f       	adc	r25, r25
    5d5c:	88 0f       	add	r24, r24
    5d5e:	99 1f       	adc	r25, r25
    5d60:	88 0f       	add	r24, r24
    5d62:	99 1f       	adc	r25, r25
    5d64:	82 0f       	add	r24, r18
    5d66:	93 1f       	adc	r25, r19
    5d68:	fc 01       	movw	r30, r24
    5d6a:	ea 51       	subi	r30, 0x1A	; 26
    5d6c:	f9 4f       	sbci	r31, 0xF9	; 249
    5d6e:	81 81       	ldd	r24, Z+1	; 0x01
    5d70:	92 81       	ldd	r25, Z+2	; 0x02
    5d72:	9c 83       	std	Y+4, r25	; 0x04
    5d74:	8b 83       	std	Y+3, r24	; 0x03
    5d76:	ea 85       	ldd	r30, Y+10	; 0x0a
    5d78:	fb 85       	ldd	r31, Y+11	; 0x0b
    5d7a:	8b 81       	ldd	r24, Y+3	; 0x03
    5d7c:	9c 81       	ldd	r25, Y+4	; 0x04
    5d7e:	95 83       	std	Z+5, r25	; 0x05
    5d80:	84 83       	std	Z+4, r24	; 0x04
    5d82:	eb 81       	ldd	r30, Y+3	; 0x03
    5d84:	fc 81       	ldd	r31, Y+4	; 0x04
    5d86:	84 81       	ldd	r24, Z+4	; 0x04
    5d88:	95 81       	ldd	r25, Z+5	; 0x05
    5d8a:	ea 85       	ldd	r30, Y+10	; 0x0a
    5d8c:	fb 85       	ldd	r31, Y+11	; 0x0b
    5d8e:	97 83       	std	Z+7, r25	; 0x07
    5d90:	86 83       	std	Z+6, r24	; 0x06
    5d92:	eb 81       	ldd	r30, Y+3	; 0x03
    5d94:	fc 81       	ldd	r31, Y+4	; 0x04
    5d96:	04 80       	ldd	r0, Z+4	; 0x04
    5d98:	f5 81       	ldd	r31, Z+5	; 0x05
    5d9a:	e0 2d       	mov	r30, r0
    5d9c:	8a 85       	ldd	r24, Y+10	; 0x0a
    5d9e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5da0:	02 96       	adiw	r24, 0x02	; 2
    5da2:	93 83       	std	Z+3, r25	; 0x03
    5da4:	82 83       	std	Z+2, r24	; 0x02
    5da6:	8a 85       	ldd	r24, Y+10	; 0x0a
    5da8:	9b 85       	ldd	r25, Y+11	; 0x0b
    5daa:	02 96       	adiw	r24, 0x02	; 2
    5dac:	eb 81       	ldd	r30, Y+3	; 0x03
    5dae:	fc 81       	ldd	r31, Y+4	; 0x04
    5db0:	95 83       	std	Z+5, r25	; 0x05
    5db2:	84 83       	std	Z+4, r24	; 0x04
    5db4:	ea 85       	ldd	r30, Y+10	; 0x0a
    5db6:	fb 85       	ldd	r31, Y+11	; 0x0b
    5db8:	86 89       	ldd	r24, Z+22	; 0x16
    5dba:	28 2f       	mov	r18, r24
    5dbc:	30 e0       	ldi	r19, 0x00	; 0
    5dbe:	c9 01       	movw	r24, r18
    5dc0:	88 0f       	add	r24, r24
    5dc2:	99 1f       	adc	r25, r25
    5dc4:	88 0f       	add	r24, r24
    5dc6:	99 1f       	adc	r25, r25
    5dc8:	88 0f       	add	r24, r24
    5dca:	99 1f       	adc	r25, r25
    5dcc:	82 0f       	add	r24, r18
    5dce:	93 1f       	adc	r25, r19
    5dd0:	8a 51       	subi	r24, 0x1A	; 26
    5dd2:	99 4f       	sbci	r25, 0xF9	; 249
    5dd4:	ea 85       	ldd	r30, Y+10	; 0x0a
    5dd6:	fb 85       	ldd	r31, Y+11	; 0x0b
    5dd8:	93 87       	std	Z+11, r25	; 0x0b
    5dda:	82 87       	std	Z+10, r24	; 0x0a
    5ddc:	ea 85       	ldd	r30, Y+10	; 0x0a
    5dde:	fb 85       	ldd	r31, Y+11	; 0x0b
    5de0:	86 89       	ldd	r24, Z+22	; 0x16
    5de2:	28 2f       	mov	r18, r24
    5de4:	30 e0       	ldi	r19, 0x00	; 0
    5de6:	c9 01       	movw	r24, r18
    5de8:	88 0f       	add	r24, r24
    5dea:	99 1f       	adc	r25, r25
    5dec:	88 0f       	add	r24, r24
    5dee:	99 1f       	adc	r25, r25
    5df0:	88 0f       	add	r24, r24
    5df2:	99 1f       	adc	r25, r25
    5df4:	82 0f       	add	r24, r18
    5df6:	93 1f       	adc	r25, r19
    5df8:	fc 01       	movw	r30, r24
    5dfa:	ea 51       	subi	r30, 0x1A	; 26
    5dfc:	f9 4f       	sbci	r31, 0xF9	; 249
    5dfe:	80 81       	ld	r24, Z
    5e00:	8f 5f       	subi	r24, 0xFF	; 255
    5e02:	80 83       	st	Z, r24
    5e04:	30 c0       	rjmp	.+96     	; 0x5e66 <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    5e06:	80 91 21 07 	lds	r24, 0x0721
    5e0a:	90 91 22 07 	lds	r25, 0x0722
    5e0e:	9a 83       	std	Y+2, r25	; 0x02
    5e10:	89 83       	std	Y+1, r24	; 0x01
    5e12:	ea 85       	ldd	r30, Y+10	; 0x0a
    5e14:	fb 85       	ldd	r31, Y+11	; 0x0b
    5e16:	89 81       	ldd	r24, Y+1	; 0x01
    5e18:	9a 81       	ldd	r25, Y+2	; 0x02
    5e1a:	97 87       	std	Z+15, r25	; 0x0f
    5e1c:	86 87       	std	Z+14, r24	; 0x0e
    5e1e:	e9 81       	ldd	r30, Y+1	; 0x01
    5e20:	fa 81       	ldd	r31, Y+2	; 0x02
    5e22:	84 81       	ldd	r24, Z+4	; 0x04
    5e24:	95 81       	ldd	r25, Z+5	; 0x05
    5e26:	ea 85       	ldd	r30, Y+10	; 0x0a
    5e28:	fb 85       	ldd	r31, Y+11	; 0x0b
    5e2a:	91 8b       	std	Z+17, r25	; 0x11
    5e2c:	80 8b       	std	Z+16, r24	; 0x10
    5e2e:	e9 81       	ldd	r30, Y+1	; 0x01
    5e30:	fa 81       	ldd	r31, Y+2	; 0x02
    5e32:	04 80       	ldd	r0, Z+4	; 0x04
    5e34:	f5 81       	ldd	r31, Z+5	; 0x05
    5e36:	e0 2d       	mov	r30, r0
    5e38:	8a 85       	ldd	r24, Y+10	; 0x0a
    5e3a:	9b 85       	ldd	r25, Y+11	; 0x0b
    5e3c:	0c 96       	adiw	r24, 0x0c	; 12
    5e3e:	93 83       	std	Z+3, r25	; 0x03
    5e40:	82 83       	std	Z+2, r24	; 0x02
    5e42:	8a 85       	ldd	r24, Y+10	; 0x0a
    5e44:	9b 85       	ldd	r25, Y+11	; 0x0b
    5e46:	0c 96       	adiw	r24, 0x0c	; 12
    5e48:	e9 81       	ldd	r30, Y+1	; 0x01
    5e4a:	fa 81       	ldd	r31, Y+2	; 0x02
    5e4c:	95 83       	std	Z+5, r25	; 0x05
    5e4e:	84 83       	std	Z+4, r24	; 0x04
    5e50:	ea 85       	ldd	r30, Y+10	; 0x0a
    5e52:	fb 85       	ldd	r31, Y+11	; 0x0b
    5e54:	80 e2       	ldi	r24, 0x20	; 32
    5e56:	97 e0       	ldi	r25, 0x07	; 7
    5e58:	95 8b       	std	Z+21, r25	; 0x15
    5e5a:	84 8b       	std	Z+20, r24	; 0x14
    5e5c:	80 91 20 07 	lds	r24, 0x0720
    5e60:	8f 5f       	subi	r24, 0xFF	; 255
    5e62:	80 93 20 07 	sts	0x0720, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5e66:	ea 85       	ldd	r30, Y+10	; 0x0a
    5e68:	fb 85       	ldd	r31, Y+11	; 0x0b
    5e6a:	96 89       	ldd	r25, Z+22	; 0x16
    5e6c:	e0 91 cc 06 	lds	r30, 0x06CC
    5e70:	f0 91 cd 06 	lds	r31, 0x06CD
    5e74:	86 89       	ldd	r24, Z+22	; 0x16
    5e76:	89 17       	cp	r24, r25
    5e78:	58 f4       	brcc	.+22     	; 0x5e90 <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    5e7a:	8e 89       	ldd	r24, Y+22	; 0x16
    5e7c:	9f 89       	ldd	r25, Y+23	; 0x17
    5e7e:	00 97       	sbiw	r24, 0x00	; 0
    5e80:	21 f0       	breq	.+8      	; 0x5e8a <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5e82:	ee 89       	ldd	r30, Y+22	; 0x16
    5e84:	ff 89       	ldd	r31, Y+23	; 0x17
    5e86:	81 e0       	ldi	r24, 0x01	; 1
    5e88:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5e8a:	81 e0       	ldi	r24, 0x01	; 1
    5e8c:	80 93 d6 06 	sts	0x06D6, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    5e90:	88 85       	ldd	r24, Y+8	; 0x08
    }
    5e92:	69 96       	adiw	r28, 0x19	; 25
    5e94:	0f b6       	in	r0, 0x3f	; 63
    5e96:	f8 94       	cli
    5e98:	de bf       	out	0x3e, r29	; 62
    5e9a:	0f be       	out	0x3f, r0	; 63
    5e9c:	cd bf       	out	0x3d, r28	; 61
    5e9e:	cf 91       	pop	r28
    5ea0:	df 91       	pop	r29
    5ea2:	1f 91       	pop	r17
    5ea4:	0f 91       	pop	r16
    5ea6:	ff 90       	pop	r15
    5ea8:	ef 90       	pop	r14
    5eaa:	df 90       	pop	r13
    5eac:	cf 90       	pop	r12
    5eae:	08 95       	ret

00005eb0 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    5eb0:	0f 93       	push	r16
    5eb2:	1f 93       	push	r17
    5eb4:	df 93       	push	r29
    5eb6:	cf 93       	push	r28
    5eb8:	cd b7       	in	r28, 0x3d	; 61
    5eba:	de b7       	in	r29, 0x3e	; 62
    5ebc:	2f 97       	sbiw	r28, 0x0f	; 15
    5ebe:	0f b6       	in	r0, 0x3f	; 63
    5ec0:	f8 94       	cli
    5ec2:	de bf       	out	0x3e, r29	; 62
    5ec4:	0f be       	out	0x3f, r0	; 63
    5ec6:	cd bf       	out	0x3d, r28	; 61
    5ec8:	9c 87       	std	Y+12, r25	; 0x0c
    5eca:	8b 87       	std	Y+11, r24	; 0x0b
    5ecc:	6d 87       	std	Y+13, r22	; 0x0d
    5ece:	5f 87       	std	Y+15, r21	; 0x0f
    5ed0:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    5ed2:	8b 85       	ldd	r24, Y+11	; 0x0b
    5ed4:	9c 85       	ldd	r25, Y+12	; 0x0c
    5ed6:	9a 87       	std	Y+10, r25	; 0x0a
    5ed8:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5eda:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5edc:	8d 85       	ldd	r24, Y+13	; 0x0d
    5ede:	28 2f       	mov	r18, r24
    5ee0:	30 e0       	ldi	r19, 0x00	; 0
    5ee2:	89 85       	ldd	r24, Y+9	; 0x09
    5ee4:	9a 85       	ldd	r25, Y+10	; 0x0a
    5ee6:	82 0f       	add	r24, r18
    5ee8:	93 1f       	adc	r25, r19
    5eea:	fc 01       	movw	r30, r24
    5eec:	bb 96       	adiw	r30, 0x2b	; 43
    5eee:	80 81       	ld	r24, Z
    5ef0:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    5ef2:	8d 85       	ldd	r24, Y+13	; 0x0d
    5ef4:	28 2f       	mov	r18, r24
    5ef6:	30 e0       	ldi	r19, 0x00	; 0
    5ef8:	89 85       	ldd	r24, Y+9	; 0x09
    5efa:	9a 85       	ldd	r25, Y+10	; 0x0a
    5efc:	82 0f       	add	r24, r18
    5efe:	93 1f       	adc	r25, r19
    5f00:	fc 01       	movw	r30, r24
    5f02:	bb 96       	adiw	r30, 0x2b	; 43
    5f04:	82 e0       	ldi	r24, 0x02	; 2
    5f06:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    5f08:	8d 85       	ldd	r24, Y+13	; 0x0d
    5f0a:	08 2f       	mov	r16, r24
    5f0c:	10 e0       	ldi	r17, 0x00	; 0
    5f0e:	29 85       	ldd	r18, Y+9	; 0x09
    5f10:	3a 85       	ldd	r19, Y+10	; 0x0a
    5f12:	c8 01       	movw	r24, r16
    5f14:	88 0f       	add	r24, r24
    5f16:	99 1f       	adc	r25, r25
    5f18:	88 0f       	add	r24, r24
    5f1a:	99 1f       	adc	r25, r25
    5f1c:	82 0f       	add	r24, r18
    5f1e:	93 1f       	adc	r25, r19
    5f20:	fc 01       	movw	r30, r24
    5f22:	b7 96       	adiw	r30, 0x27	; 39
    5f24:	80 81       	ld	r24, Z
    5f26:	91 81       	ldd	r25, Z+1	; 0x01
    5f28:	a2 81       	ldd	r26, Z+2	; 0x02
    5f2a:	b3 81       	ldd	r27, Z+3	; 0x03
    5f2c:	ac 01       	movw	r20, r24
    5f2e:	bd 01       	movw	r22, r26
    5f30:	4f 5f       	subi	r20, 0xFF	; 255
    5f32:	5f 4f       	sbci	r21, 0xFF	; 255
    5f34:	6f 4f       	sbci	r22, 0xFF	; 255
    5f36:	7f 4f       	sbci	r23, 0xFF	; 255
    5f38:	29 85       	ldd	r18, Y+9	; 0x09
    5f3a:	3a 85       	ldd	r19, Y+10	; 0x0a
    5f3c:	c8 01       	movw	r24, r16
    5f3e:	88 0f       	add	r24, r24
    5f40:	99 1f       	adc	r25, r25
    5f42:	88 0f       	add	r24, r24
    5f44:	99 1f       	adc	r25, r25
    5f46:	82 0f       	add	r24, r18
    5f48:	93 1f       	adc	r25, r19
    5f4a:	fc 01       	movw	r30, r24
    5f4c:	b7 96       	adiw	r30, 0x27	; 39
    5f4e:	40 83       	st	Z, r20
    5f50:	51 83       	std	Z+1, r21	; 0x01
    5f52:	62 83       	std	Z+2, r22	; 0x02
    5f54:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5f56:	88 85       	ldd	r24, Y+8	; 0x08
    5f58:	81 30       	cpi	r24, 0x01	; 1
    5f5a:	09 f0       	breq	.+2      	; 0x5f5e <vTaskGenericNotifyGiveFromISR+0xae>
    5f5c:	ee c0       	rjmp	.+476    	; 0x613a <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5f5e:	80 91 dd 06 	lds	r24, 0x06DD
    5f62:	88 23       	and	r24, r24
    5f64:	09 f0       	breq	.+2      	; 0x5f68 <vTaskGenericNotifyGiveFromISR+0xb8>
    5f66:	a4 c0       	rjmp	.+328    	; 0x60b0 <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5f68:	e9 85       	ldd	r30, Y+9	; 0x09
    5f6a:	fa 85       	ldd	r31, Y+10	; 0x0a
    5f6c:	82 85       	ldd	r24, Z+10	; 0x0a
    5f6e:	93 85       	ldd	r25, Z+11	; 0x0b
    5f70:	9e 83       	std	Y+6, r25	; 0x06
    5f72:	8d 83       	std	Y+5, r24	; 0x05
    5f74:	e9 85       	ldd	r30, Y+9	; 0x09
    5f76:	fa 85       	ldd	r31, Y+10	; 0x0a
    5f78:	a4 81       	ldd	r26, Z+4	; 0x04
    5f7a:	b5 81       	ldd	r27, Z+5	; 0x05
    5f7c:	e9 85       	ldd	r30, Y+9	; 0x09
    5f7e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5f80:	86 81       	ldd	r24, Z+6	; 0x06
    5f82:	97 81       	ldd	r25, Z+7	; 0x07
    5f84:	15 96       	adiw	r26, 0x05	; 5
    5f86:	9c 93       	st	X, r25
    5f88:	8e 93       	st	-X, r24
    5f8a:	14 97       	sbiw	r26, 0x04	; 4
    5f8c:	e9 85       	ldd	r30, Y+9	; 0x09
    5f8e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5f90:	a6 81       	ldd	r26, Z+6	; 0x06
    5f92:	b7 81       	ldd	r27, Z+7	; 0x07
    5f94:	e9 85       	ldd	r30, Y+9	; 0x09
    5f96:	fa 85       	ldd	r31, Y+10	; 0x0a
    5f98:	84 81       	ldd	r24, Z+4	; 0x04
    5f9a:	95 81       	ldd	r25, Z+5	; 0x05
    5f9c:	13 96       	adiw	r26, 0x03	; 3
    5f9e:	9c 93       	st	X, r25
    5fa0:	8e 93       	st	-X, r24
    5fa2:	12 97       	sbiw	r26, 0x02	; 2
    5fa4:	ed 81       	ldd	r30, Y+5	; 0x05
    5fa6:	fe 81       	ldd	r31, Y+6	; 0x06
    5fa8:	21 81       	ldd	r18, Z+1	; 0x01
    5faa:	32 81       	ldd	r19, Z+2	; 0x02
    5fac:	89 85       	ldd	r24, Y+9	; 0x09
    5fae:	9a 85       	ldd	r25, Y+10	; 0x0a
    5fb0:	02 96       	adiw	r24, 0x02	; 2
    5fb2:	28 17       	cp	r18, r24
    5fb4:	39 07       	cpc	r19, r25
    5fb6:	41 f4       	brne	.+16     	; 0x5fc8 <vTaskGenericNotifyGiveFromISR+0x118>
    5fb8:	e9 85       	ldd	r30, Y+9	; 0x09
    5fba:	fa 85       	ldd	r31, Y+10	; 0x0a
    5fbc:	86 81       	ldd	r24, Z+6	; 0x06
    5fbe:	97 81       	ldd	r25, Z+7	; 0x07
    5fc0:	ed 81       	ldd	r30, Y+5	; 0x05
    5fc2:	fe 81       	ldd	r31, Y+6	; 0x06
    5fc4:	92 83       	std	Z+2, r25	; 0x02
    5fc6:	81 83       	std	Z+1, r24	; 0x01
    5fc8:	e9 85       	ldd	r30, Y+9	; 0x09
    5fca:	fa 85       	ldd	r31, Y+10	; 0x0a
    5fcc:	13 86       	std	Z+11, r1	; 0x0b
    5fce:	12 86       	std	Z+10, r1	; 0x0a
    5fd0:	ed 81       	ldd	r30, Y+5	; 0x05
    5fd2:	fe 81       	ldd	r31, Y+6	; 0x06
    5fd4:	80 81       	ld	r24, Z
    5fd6:	81 50       	subi	r24, 0x01	; 1
    5fd8:	ed 81       	ldd	r30, Y+5	; 0x05
    5fda:	fe 81       	ldd	r31, Y+6	; 0x06
    5fdc:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5fde:	e9 85       	ldd	r30, Y+9	; 0x09
    5fe0:	fa 85       	ldd	r31, Y+10	; 0x0a
    5fe2:	96 89       	ldd	r25, Z+22	; 0x16
    5fe4:	80 91 d2 06 	lds	r24, 0x06D2
    5fe8:	89 17       	cp	r24, r25
    5fea:	28 f4       	brcc	.+10     	; 0x5ff6 <vTaskGenericNotifyGiveFromISR+0x146>
    5fec:	e9 85       	ldd	r30, Y+9	; 0x09
    5fee:	fa 85       	ldd	r31, Y+10	; 0x0a
    5ff0:	86 89       	ldd	r24, Z+22	; 0x16
    5ff2:	80 93 d2 06 	sts	0x06D2, r24
    5ff6:	e9 85       	ldd	r30, Y+9	; 0x09
    5ff8:	fa 85       	ldd	r31, Y+10	; 0x0a
    5ffa:	86 89       	ldd	r24, Z+22	; 0x16
    5ffc:	28 2f       	mov	r18, r24
    5ffe:	30 e0       	ldi	r19, 0x00	; 0
    6000:	c9 01       	movw	r24, r18
    6002:	88 0f       	add	r24, r24
    6004:	99 1f       	adc	r25, r25
    6006:	88 0f       	add	r24, r24
    6008:	99 1f       	adc	r25, r25
    600a:	88 0f       	add	r24, r24
    600c:	99 1f       	adc	r25, r25
    600e:	82 0f       	add	r24, r18
    6010:	93 1f       	adc	r25, r19
    6012:	fc 01       	movw	r30, r24
    6014:	ea 51       	subi	r30, 0x1A	; 26
    6016:	f9 4f       	sbci	r31, 0xF9	; 249
    6018:	81 81       	ldd	r24, Z+1	; 0x01
    601a:	92 81       	ldd	r25, Z+2	; 0x02
    601c:	9c 83       	std	Y+4, r25	; 0x04
    601e:	8b 83       	std	Y+3, r24	; 0x03
    6020:	e9 85       	ldd	r30, Y+9	; 0x09
    6022:	fa 85       	ldd	r31, Y+10	; 0x0a
    6024:	8b 81       	ldd	r24, Y+3	; 0x03
    6026:	9c 81       	ldd	r25, Y+4	; 0x04
    6028:	95 83       	std	Z+5, r25	; 0x05
    602a:	84 83       	std	Z+4, r24	; 0x04
    602c:	eb 81       	ldd	r30, Y+3	; 0x03
    602e:	fc 81       	ldd	r31, Y+4	; 0x04
    6030:	84 81       	ldd	r24, Z+4	; 0x04
    6032:	95 81       	ldd	r25, Z+5	; 0x05
    6034:	e9 85       	ldd	r30, Y+9	; 0x09
    6036:	fa 85       	ldd	r31, Y+10	; 0x0a
    6038:	97 83       	std	Z+7, r25	; 0x07
    603a:	86 83       	std	Z+6, r24	; 0x06
    603c:	eb 81       	ldd	r30, Y+3	; 0x03
    603e:	fc 81       	ldd	r31, Y+4	; 0x04
    6040:	04 80       	ldd	r0, Z+4	; 0x04
    6042:	f5 81       	ldd	r31, Z+5	; 0x05
    6044:	e0 2d       	mov	r30, r0
    6046:	89 85       	ldd	r24, Y+9	; 0x09
    6048:	9a 85       	ldd	r25, Y+10	; 0x0a
    604a:	02 96       	adiw	r24, 0x02	; 2
    604c:	93 83       	std	Z+3, r25	; 0x03
    604e:	82 83       	std	Z+2, r24	; 0x02
    6050:	89 85       	ldd	r24, Y+9	; 0x09
    6052:	9a 85       	ldd	r25, Y+10	; 0x0a
    6054:	02 96       	adiw	r24, 0x02	; 2
    6056:	eb 81       	ldd	r30, Y+3	; 0x03
    6058:	fc 81       	ldd	r31, Y+4	; 0x04
    605a:	95 83       	std	Z+5, r25	; 0x05
    605c:	84 83       	std	Z+4, r24	; 0x04
    605e:	e9 85       	ldd	r30, Y+9	; 0x09
    6060:	fa 85       	ldd	r31, Y+10	; 0x0a
    6062:	86 89       	ldd	r24, Z+22	; 0x16
    6064:	28 2f       	mov	r18, r24
    6066:	30 e0       	ldi	r19, 0x00	; 0
    6068:	c9 01       	movw	r24, r18
    606a:	88 0f       	add	r24, r24
    606c:	99 1f       	adc	r25, r25
    606e:	88 0f       	add	r24, r24
    6070:	99 1f       	adc	r25, r25
    6072:	88 0f       	add	r24, r24
    6074:	99 1f       	adc	r25, r25
    6076:	82 0f       	add	r24, r18
    6078:	93 1f       	adc	r25, r19
    607a:	8a 51       	subi	r24, 0x1A	; 26
    607c:	99 4f       	sbci	r25, 0xF9	; 249
    607e:	e9 85       	ldd	r30, Y+9	; 0x09
    6080:	fa 85       	ldd	r31, Y+10	; 0x0a
    6082:	93 87       	std	Z+11, r25	; 0x0b
    6084:	82 87       	std	Z+10, r24	; 0x0a
    6086:	e9 85       	ldd	r30, Y+9	; 0x09
    6088:	fa 85       	ldd	r31, Y+10	; 0x0a
    608a:	86 89       	ldd	r24, Z+22	; 0x16
    608c:	28 2f       	mov	r18, r24
    608e:	30 e0       	ldi	r19, 0x00	; 0
    6090:	c9 01       	movw	r24, r18
    6092:	88 0f       	add	r24, r24
    6094:	99 1f       	adc	r25, r25
    6096:	88 0f       	add	r24, r24
    6098:	99 1f       	adc	r25, r25
    609a:	88 0f       	add	r24, r24
    609c:	99 1f       	adc	r25, r25
    609e:	82 0f       	add	r24, r18
    60a0:	93 1f       	adc	r25, r19
    60a2:	fc 01       	movw	r30, r24
    60a4:	ea 51       	subi	r30, 0x1A	; 26
    60a6:	f9 4f       	sbci	r31, 0xF9	; 249
    60a8:	80 81       	ld	r24, Z
    60aa:	8f 5f       	subi	r24, 0xFF	; 255
    60ac:	80 83       	st	Z, r24
    60ae:	30 c0       	rjmp	.+96     	; 0x6110 <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    60b0:	80 91 21 07 	lds	r24, 0x0721
    60b4:	90 91 22 07 	lds	r25, 0x0722
    60b8:	9a 83       	std	Y+2, r25	; 0x02
    60ba:	89 83       	std	Y+1, r24	; 0x01
    60bc:	e9 85       	ldd	r30, Y+9	; 0x09
    60be:	fa 85       	ldd	r31, Y+10	; 0x0a
    60c0:	89 81       	ldd	r24, Y+1	; 0x01
    60c2:	9a 81       	ldd	r25, Y+2	; 0x02
    60c4:	97 87       	std	Z+15, r25	; 0x0f
    60c6:	86 87       	std	Z+14, r24	; 0x0e
    60c8:	e9 81       	ldd	r30, Y+1	; 0x01
    60ca:	fa 81       	ldd	r31, Y+2	; 0x02
    60cc:	84 81       	ldd	r24, Z+4	; 0x04
    60ce:	95 81       	ldd	r25, Z+5	; 0x05
    60d0:	e9 85       	ldd	r30, Y+9	; 0x09
    60d2:	fa 85       	ldd	r31, Y+10	; 0x0a
    60d4:	91 8b       	std	Z+17, r25	; 0x11
    60d6:	80 8b       	std	Z+16, r24	; 0x10
    60d8:	e9 81       	ldd	r30, Y+1	; 0x01
    60da:	fa 81       	ldd	r31, Y+2	; 0x02
    60dc:	04 80       	ldd	r0, Z+4	; 0x04
    60de:	f5 81       	ldd	r31, Z+5	; 0x05
    60e0:	e0 2d       	mov	r30, r0
    60e2:	89 85       	ldd	r24, Y+9	; 0x09
    60e4:	9a 85       	ldd	r25, Y+10	; 0x0a
    60e6:	0c 96       	adiw	r24, 0x0c	; 12
    60e8:	93 83       	std	Z+3, r25	; 0x03
    60ea:	82 83       	std	Z+2, r24	; 0x02
    60ec:	89 85       	ldd	r24, Y+9	; 0x09
    60ee:	9a 85       	ldd	r25, Y+10	; 0x0a
    60f0:	0c 96       	adiw	r24, 0x0c	; 12
    60f2:	e9 81       	ldd	r30, Y+1	; 0x01
    60f4:	fa 81       	ldd	r31, Y+2	; 0x02
    60f6:	95 83       	std	Z+5, r25	; 0x05
    60f8:	84 83       	std	Z+4, r24	; 0x04
    60fa:	e9 85       	ldd	r30, Y+9	; 0x09
    60fc:	fa 85       	ldd	r31, Y+10	; 0x0a
    60fe:	80 e2       	ldi	r24, 0x20	; 32
    6100:	97 e0       	ldi	r25, 0x07	; 7
    6102:	95 8b       	std	Z+21, r25	; 0x15
    6104:	84 8b       	std	Z+20, r24	; 0x14
    6106:	80 91 20 07 	lds	r24, 0x0720
    610a:	8f 5f       	subi	r24, 0xFF	; 255
    610c:	80 93 20 07 	sts	0x0720, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    6110:	e9 85       	ldd	r30, Y+9	; 0x09
    6112:	fa 85       	ldd	r31, Y+10	; 0x0a
    6114:	96 89       	ldd	r25, Z+22	; 0x16
    6116:	e0 91 cc 06 	lds	r30, 0x06CC
    611a:	f0 91 cd 06 	lds	r31, 0x06CD
    611e:	86 89       	ldd	r24, Z+22	; 0x16
    6120:	89 17       	cp	r24, r25
    6122:	58 f4       	brcc	.+22     	; 0x613a <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    6124:	8e 85       	ldd	r24, Y+14	; 0x0e
    6126:	9f 85       	ldd	r25, Y+15	; 0x0f
    6128:	00 97       	sbiw	r24, 0x00	; 0
    612a:	21 f0       	breq	.+8      	; 0x6134 <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    612c:	ee 85       	ldd	r30, Y+14	; 0x0e
    612e:	ff 85       	ldd	r31, Y+15	; 0x0f
    6130:	81 e0       	ldi	r24, 0x01	; 1
    6132:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    6134:	81 e0       	ldi	r24, 0x01	; 1
    6136:	80 93 d6 06 	sts	0x06D6, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    613a:	2f 96       	adiw	r28, 0x0f	; 15
    613c:	0f b6       	in	r0, 0x3f	; 63
    613e:	f8 94       	cli
    6140:	de bf       	out	0x3e, r29	; 62
    6142:	0f be       	out	0x3f, r0	; 63
    6144:	cd bf       	out	0x3d, r28	; 61
    6146:	cf 91       	pop	r28
    6148:	df 91       	pop	r29
    614a:	1f 91       	pop	r17
    614c:	0f 91       	pop	r16
    614e:	08 95       	ret

00006150 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    6150:	df 93       	push	r29
    6152:	cf 93       	push	r28
    6154:	cd b7       	in	r28, 0x3d	; 61
    6156:	de b7       	in	r29, 0x3e	; 62
    6158:	28 97       	sbiw	r28, 0x08	; 8
    615a:	0f b6       	in	r0, 0x3f	; 63
    615c:	f8 94       	cli
    615e:	de bf       	out	0x3e, r29	; 62
    6160:	0f be       	out	0x3f, r0	; 63
    6162:	cd bf       	out	0x3d, r28	; 61
    6164:	9d 83       	std	Y+5, r25	; 0x05
    6166:	8c 83       	std	Y+4, r24	; 0x04
    6168:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    616a:	8c 81       	ldd	r24, Y+4	; 0x04
    616c:	9d 81       	ldd	r25, Y+5	; 0x05
    616e:	00 97       	sbiw	r24, 0x00	; 0
    6170:	39 f4       	brne	.+14     	; 0x6180 <xTaskGenericNotifyStateClear+0x30>
    6172:	80 91 cc 06 	lds	r24, 0x06CC
    6176:	90 91 cd 06 	lds	r25, 0x06CD
    617a:	98 87       	std	Y+8, r25	; 0x08
    617c:	8f 83       	std	Y+7, r24	; 0x07
    617e:	04 c0       	rjmp	.+8      	; 0x6188 <xTaskGenericNotifyStateClear+0x38>
    6180:	8c 81       	ldd	r24, Y+4	; 0x04
    6182:	9d 81       	ldd	r25, Y+5	; 0x05
    6184:	98 87       	std	Y+8, r25	; 0x08
    6186:	8f 83       	std	Y+7, r24	; 0x07
    6188:	8f 81       	ldd	r24, Y+7	; 0x07
    618a:	98 85       	ldd	r25, Y+8	; 0x08
    618c:	9b 83       	std	Y+3, r25	; 0x03
    618e:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    6190:	0f b6       	in	r0, 0x3f	; 63
    6192:	f8 94       	cli
    6194:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    6196:	8e 81       	ldd	r24, Y+6	; 0x06
    6198:	28 2f       	mov	r18, r24
    619a:	30 e0       	ldi	r19, 0x00	; 0
    619c:	8a 81       	ldd	r24, Y+2	; 0x02
    619e:	9b 81       	ldd	r25, Y+3	; 0x03
    61a0:	82 0f       	add	r24, r18
    61a2:	93 1f       	adc	r25, r19
    61a4:	fc 01       	movw	r30, r24
    61a6:	bb 96       	adiw	r30, 0x2b	; 43
    61a8:	80 81       	ld	r24, Z
    61aa:	82 30       	cpi	r24, 0x02	; 2
    61ac:	69 f4       	brne	.+26     	; 0x61c8 <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    61ae:	8e 81       	ldd	r24, Y+6	; 0x06
    61b0:	28 2f       	mov	r18, r24
    61b2:	30 e0       	ldi	r19, 0x00	; 0
    61b4:	8a 81       	ldd	r24, Y+2	; 0x02
    61b6:	9b 81       	ldd	r25, Y+3	; 0x03
    61b8:	82 0f       	add	r24, r18
    61ba:	93 1f       	adc	r25, r19
    61bc:	fc 01       	movw	r30, r24
    61be:	bb 96       	adiw	r30, 0x2b	; 43
    61c0:	10 82       	st	Z, r1
                xReturn = pdPASS;
    61c2:	81 e0       	ldi	r24, 0x01	; 1
    61c4:	89 83       	std	Y+1, r24	; 0x01
    61c6:	01 c0       	rjmp	.+2      	; 0x61ca <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    61c8:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    61ca:	0f 90       	pop	r0
    61cc:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    61ce:	89 81       	ldd	r24, Y+1	; 0x01
    }
    61d0:	28 96       	adiw	r28, 0x08	; 8
    61d2:	0f b6       	in	r0, 0x3f	; 63
    61d4:	f8 94       	cli
    61d6:	de bf       	out	0x3e, r29	; 62
    61d8:	0f be       	out	0x3f, r0	; 63
    61da:	cd bf       	out	0x3d, r28	; 61
    61dc:	cf 91       	pop	r28
    61de:	df 91       	pop	r29
    61e0:	08 95       	ret

000061e2 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    61e2:	0f 93       	push	r16
    61e4:	1f 93       	push	r17
    61e6:	df 93       	push	r29
    61e8:	cf 93       	push	r28
    61ea:	cd b7       	in	r28, 0x3d	; 61
    61ec:	de b7       	in	r29, 0x3e	; 62
    61ee:	2f 97       	sbiw	r28, 0x0f	; 15
    61f0:	0f b6       	in	r0, 0x3f	; 63
    61f2:	f8 94       	cli
    61f4:	de bf       	out	0x3e, r29	; 62
    61f6:	0f be       	out	0x3f, r0	; 63
    61f8:	cd bf       	out	0x3d, r28	; 61
    61fa:	98 87       	std	Y+8, r25	; 0x08
    61fc:	8f 83       	std	Y+7, r24	; 0x07
    61fe:	69 87       	std	Y+9, r22	; 0x09
    6200:	2a 87       	std	Y+10, r18	; 0x0a
    6202:	3b 87       	std	Y+11, r19	; 0x0b
    6204:	4c 87       	std	Y+12, r20	; 0x0c
    6206:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    6208:	8f 81       	ldd	r24, Y+7	; 0x07
    620a:	98 85       	ldd	r25, Y+8	; 0x08
    620c:	00 97       	sbiw	r24, 0x00	; 0
    620e:	39 f4       	brne	.+14     	; 0x621e <ulTaskGenericNotifyValueClear+0x3c>
    6210:	80 91 cc 06 	lds	r24, 0x06CC
    6214:	90 91 cd 06 	lds	r25, 0x06CD
    6218:	9f 87       	std	Y+15, r25	; 0x0f
    621a:	8e 87       	std	Y+14, r24	; 0x0e
    621c:	04 c0       	rjmp	.+8      	; 0x6226 <ulTaskGenericNotifyValueClear+0x44>
    621e:	8f 81       	ldd	r24, Y+7	; 0x07
    6220:	98 85       	ldd	r25, Y+8	; 0x08
    6222:	9f 87       	std	Y+15, r25	; 0x0f
    6224:	8e 87       	std	Y+14, r24	; 0x0e
    6226:	8e 85       	ldd	r24, Y+14	; 0x0e
    6228:	9f 85       	ldd	r25, Y+15	; 0x0f
    622a:	9e 83       	std	Y+6, r25	; 0x06
    622c:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    622e:	0f b6       	in	r0, 0x3f	; 63
    6230:	f8 94       	cli
    6232:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    6234:	89 85       	ldd	r24, Y+9	; 0x09
    6236:	88 2f       	mov	r24, r24
    6238:	90 e0       	ldi	r25, 0x00	; 0
    623a:	2d 81       	ldd	r18, Y+5	; 0x05
    623c:	3e 81       	ldd	r19, Y+6	; 0x06
    623e:	88 0f       	add	r24, r24
    6240:	99 1f       	adc	r25, r25
    6242:	88 0f       	add	r24, r24
    6244:	99 1f       	adc	r25, r25
    6246:	82 0f       	add	r24, r18
    6248:	93 1f       	adc	r25, r19
    624a:	fc 01       	movw	r30, r24
    624c:	b7 96       	adiw	r30, 0x27	; 39
    624e:	80 81       	ld	r24, Z
    6250:	91 81       	ldd	r25, Z+1	; 0x01
    6252:	a2 81       	ldd	r26, Z+2	; 0x02
    6254:	b3 81       	ldd	r27, Z+3	; 0x03
    6256:	89 83       	std	Y+1, r24	; 0x01
    6258:	9a 83       	std	Y+2, r25	; 0x02
    625a:	ab 83       	std	Y+3, r26	; 0x03
    625c:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    625e:	89 85       	ldd	r24, Y+9	; 0x09
    6260:	08 2f       	mov	r16, r24
    6262:	10 e0       	ldi	r17, 0x00	; 0
    6264:	89 85       	ldd	r24, Y+9	; 0x09
    6266:	88 2f       	mov	r24, r24
    6268:	90 e0       	ldi	r25, 0x00	; 0
    626a:	2d 81       	ldd	r18, Y+5	; 0x05
    626c:	3e 81       	ldd	r19, Y+6	; 0x06
    626e:	88 0f       	add	r24, r24
    6270:	99 1f       	adc	r25, r25
    6272:	88 0f       	add	r24, r24
    6274:	99 1f       	adc	r25, r25
    6276:	82 0f       	add	r24, r18
    6278:	93 1f       	adc	r25, r19
    627a:	fc 01       	movw	r30, r24
    627c:	b7 96       	adiw	r30, 0x27	; 39
    627e:	20 81       	ld	r18, Z
    6280:	31 81       	ldd	r19, Z+1	; 0x01
    6282:	42 81       	ldd	r20, Z+2	; 0x02
    6284:	53 81       	ldd	r21, Z+3	; 0x03
    6286:	8a 85       	ldd	r24, Y+10	; 0x0a
    6288:	9b 85       	ldd	r25, Y+11	; 0x0b
    628a:	ac 85       	ldd	r26, Y+12	; 0x0c
    628c:	bd 85       	ldd	r27, Y+13	; 0x0d
    628e:	80 95       	com	r24
    6290:	90 95       	com	r25
    6292:	a0 95       	com	r26
    6294:	b0 95       	com	r27
    6296:	ba 01       	movw	r22, r20
    6298:	a9 01       	movw	r20, r18
    629a:	48 23       	and	r20, r24
    629c:	59 23       	and	r21, r25
    629e:	6a 23       	and	r22, r26
    62a0:	7b 23       	and	r23, r27
    62a2:	2d 81       	ldd	r18, Y+5	; 0x05
    62a4:	3e 81       	ldd	r19, Y+6	; 0x06
    62a6:	c8 01       	movw	r24, r16
    62a8:	88 0f       	add	r24, r24
    62aa:	99 1f       	adc	r25, r25
    62ac:	88 0f       	add	r24, r24
    62ae:	99 1f       	adc	r25, r25
    62b0:	82 0f       	add	r24, r18
    62b2:	93 1f       	adc	r25, r19
    62b4:	fc 01       	movw	r30, r24
    62b6:	b7 96       	adiw	r30, 0x27	; 39
    62b8:	40 83       	st	Z, r20
    62ba:	51 83       	std	Z+1, r21	; 0x01
    62bc:	62 83       	std	Z+2, r22	; 0x02
    62be:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    62c0:	0f 90       	pop	r0
    62c2:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    62c4:	89 81       	ldd	r24, Y+1	; 0x01
    62c6:	9a 81       	ldd	r25, Y+2	; 0x02
    62c8:	ab 81       	ldd	r26, Y+3	; 0x03
    62ca:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    62cc:	bc 01       	movw	r22, r24
    62ce:	cd 01       	movw	r24, r26
    62d0:	2f 96       	adiw	r28, 0x0f	; 15
    62d2:	0f b6       	in	r0, 0x3f	; 63
    62d4:	f8 94       	cli
    62d6:	de bf       	out	0x3e, r29	; 62
    62d8:	0f be       	out	0x3f, r0	; 63
    62da:	cd bf       	out	0x3d, r28	; 61
    62dc:	cf 91       	pop	r28
    62de:	df 91       	pop	r29
    62e0:	1f 91       	pop	r17
    62e2:	0f 91       	pop	r16
    62e4:	08 95       	ret

000062e6 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    62e6:	df 93       	push	r29
    62e8:	cf 93       	push	r28
    62ea:	cd b7       	in	r28, 0x3d	; 61
    62ec:	de b7       	in	r29, 0x3e	; 62
    62ee:	27 97       	sbiw	r28, 0x07	; 7
    62f0:	0f b6       	in	r0, 0x3f	; 63
    62f2:	f8 94       	cli
    62f4:	de bf       	out	0x3e, r29	; 62
    62f6:	0f be       	out	0x3f, r0	; 63
    62f8:	cd bf       	out	0x3d, r28	; 61
    62fa:	9e 83       	std	Y+6, r25	; 0x06
    62fc:	8d 83       	std	Y+5, r24	; 0x05
    62fe:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    6300:	80 91 d0 06 	lds	r24, 0x06D0
    6304:	90 91 d1 06 	lds	r25, 0x06D1
    6308:	9a 83       	std	Y+2, r25	; 0x02
    630a:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    630c:	80 91 cc 06 	lds	r24, 0x06CC
    6310:	90 91 cd 06 	lds	r25, 0x06CD
    6314:	02 96       	adiw	r24, 0x02	; 2
    6316:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the kernel
             * will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    631a:	29 81       	ldd	r18, Y+1	; 0x01
    631c:	3a 81       	ldd	r19, Y+2	; 0x02
    631e:	8d 81       	ldd	r24, Y+5	; 0x05
    6320:	9e 81       	ldd	r25, Y+6	; 0x06
    6322:	82 0f       	add	r24, r18
    6324:	93 1f       	adc	r25, r19
    6326:	9c 83       	std	Y+4, r25	; 0x04
    6328:	8b 83       	std	Y+3, r24	; 0x03

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    632a:	e0 91 cc 06 	lds	r30, 0x06CC
    632e:	f0 91 cd 06 	lds	r31, 0x06CD
    6332:	8b 81       	ldd	r24, Y+3	; 0x03
    6334:	9c 81       	ldd	r25, Y+4	; 0x04
    6336:	93 83       	std	Z+3, r25	; 0x03
    6338:	82 83       	std	Z+2, r24	; 0x02

            if( xTimeToWake < xConstTickCount )
    633a:	2b 81       	ldd	r18, Y+3	; 0x03
    633c:	3c 81       	ldd	r19, Y+4	; 0x04
    633e:	89 81       	ldd	r24, Y+1	; 0x01
    6340:	9a 81       	ldd	r25, Y+2	; 0x02
    6342:	28 17       	cp	r18, r24
    6344:	39 07       	cpc	r19, r25
    6346:	70 f4       	brcc	.+28     	; 0x6364 <prvAddCurrentTaskToDelayedList+0x7e>
            {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6348:	80 91 1e 07 	lds	r24, 0x071E
    634c:	90 91 1f 07 	lds	r25, 0x071F
    6350:	20 91 cc 06 	lds	r18, 0x06CC
    6354:	30 91 cd 06 	lds	r19, 0x06CD
    6358:	2e 5f       	subi	r18, 0xFE	; 254
    635a:	3f 4f       	sbci	r19, 0xFF	; 255
    635c:	b9 01       	movw	r22, r18
    635e:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <vListInsert>
    6362:	1e c0       	rjmp	.+60     	; 0x63a0 <prvAddCurrentTaskToDelayedList+0xba>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    6364:	40 91 1c 07 	lds	r20, 0x071C
    6368:	50 91 1d 07 	lds	r21, 0x071D
    636c:	80 91 cc 06 	lds	r24, 0x06CC
    6370:	90 91 cd 06 	lds	r25, 0x06CD
    6374:	9c 01       	movw	r18, r24
    6376:	2e 5f       	subi	r18, 0xFE	; 254
    6378:	3f 4f       	sbci	r19, 0xFF	; 255
    637a:	ca 01       	movw	r24, r20
    637c:	b9 01       	movw	r22, r18
    637e:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <vListInsert>

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    6382:	20 91 d9 06 	lds	r18, 0x06D9
    6386:	30 91 da 06 	lds	r19, 0x06DA
    638a:	8b 81       	ldd	r24, Y+3	; 0x03
    638c:	9c 81       	ldd	r25, Y+4	; 0x04
    638e:	82 17       	cp	r24, r18
    6390:	93 07       	cpc	r25, r19
    6392:	30 f4       	brcc	.+12     	; 0x63a0 <prvAddCurrentTaskToDelayedList+0xba>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    6394:	8b 81       	ldd	r24, Y+3	; 0x03
    6396:	9c 81       	ldd	r25, Y+4	; 0x04
    6398:	90 93 da 06 	sts	0x06DA, r25
    639c:	80 93 d9 06 	sts	0x06D9, r24

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    63a0:	27 96       	adiw	r28, 0x07	; 7
    63a2:	0f b6       	in	r0, 0x3f	; 63
    63a4:	f8 94       	cli
    63a6:	de bf       	out	0x3e, r29	; 62
    63a8:	0f be       	out	0x3f, r0	; 63
    63aa:	cd bf       	out	0x3d, r28	; 61
    63ac:	cf 91       	pop	r28
    63ae:	df 91       	pop	r29
    63b0:	08 95       	ret

000063b2 <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
    63b2:	ef 92       	push	r14
    63b4:	ff 92       	push	r15
    63b6:	0f 93       	push	r16
    63b8:	df 93       	push	r29
    63ba:	cf 93       	push	r28
    63bc:	0f 92       	push	r0
    63be:	cd b7       	in	r28, 0x3d	; 61
    63c0:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn = pdFAIL;
    63c2:	19 82       	std	Y+1, r1	; 0x01

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
    63c4:	0e 94 98 36 	call	0x6d30	; 0x6d30 <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
    63c8:	80 91 32 07 	lds	r24, 0x0732
    63cc:	90 91 33 07 	lds	r25, 0x0733
    63d0:	00 97       	sbiw	r24, 0x00	; 0
    63d2:	81 f0       	breq	.+32     	; 0x63f4 <xTimerCreateTimerTask+0x42>
                        xReturn = pdPASS;
                    }
                }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
    63d4:	8a e2       	ldi	r24, 0x2A	; 42
    63d6:	94 e3       	ldi	r25, 0x34	; 52
    63d8:	2c e8       	ldi	r18, 0x8C	; 140
    63da:	30 e0       	ldi	r19, 0x00	; 0
    63dc:	e4 e3       	ldi	r30, 0x34	; 52
    63de:	f7 e0       	ldi	r31, 0x07	; 7
    63e0:	b9 01       	movw	r22, r18
    63e2:	45 e5       	ldi	r20, 0x55	; 85
    63e4:	50 e0       	ldi	r21, 0x00	; 0
    63e6:	20 e0       	ldi	r18, 0x00	; 0
    63e8:	30 e0       	ldi	r19, 0x00	; 0
    63ea:	03 e0       	ldi	r16, 0x03	; 3
    63ec:	7f 01       	movw	r14, r30
    63ee:	0e 94 6d 18 	call	0x30da	; 0x30da <xTaskCreate>
    63f2:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
        return xReturn;
    63f4:	89 81       	ldd	r24, Y+1	; 0x01
    }
    63f6:	0f 90       	pop	r0
    63f8:	cf 91       	pop	r28
    63fa:	df 91       	pop	r29
    63fc:	0f 91       	pop	r16
    63fe:	ff 90       	pop	r15
    6400:	ef 90       	pop	r14
    6402:	08 95       	ret

00006404 <xTimerCreate>:
        TimerHandle_t xTimerCreate( const char * const pcTimerName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                    const TickType_t xTimerPeriodInTicks,
                                    const UBaseType_t uxAutoReload,
                                    void * const pvTimerID,
                                    TimerCallbackFunction_t pxCallbackFunction )
        {
    6404:	ef 92       	push	r14
    6406:	ff 92       	push	r15
    6408:	0f 93       	push	r16
    640a:	1f 93       	push	r17
    640c:	df 93       	push	r29
    640e:	cf 93       	push	r28
    6410:	cd b7       	in	r28, 0x3d	; 61
    6412:	de b7       	in	r29, 0x3e	; 62
    6414:	2b 97       	sbiw	r28, 0x0b	; 11
    6416:	0f b6       	in	r0, 0x3f	; 63
    6418:	f8 94       	cli
    641a:	de bf       	out	0x3e, r29	; 62
    641c:	0f be       	out	0x3f, r0	; 63
    641e:	cd bf       	out	0x3d, r28	; 61
    6420:	9c 83       	std	Y+4, r25	; 0x04
    6422:	8b 83       	std	Y+3, r24	; 0x03
    6424:	7e 83       	std	Y+6, r23	; 0x06
    6426:	6d 83       	std	Y+5, r22	; 0x05
    6428:	4f 83       	std	Y+7, r20	; 0x07
    642a:	39 87       	std	Y+9, r19	; 0x09
    642c:	28 87       	std	Y+8, r18	; 0x08
    642e:	1b 87       	std	Y+11, r17	; 0x0b
    6430:	0a 87       	std	Y+10, r16	; 0x0a
            Timer_t * pxNewTimer;

            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
    6432:	84 e1       	ldi	r24, 0x14	; 20
    6434:	90 e0       	ldi	r25, 0x00	; 0
    6436:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    643a:	9a 83       	std	Y+2, r25	; 0x02
    643c:	89 83       	std	Y+1, r24	; 0x01

            if( pxNewTimer != NULL )
    643e:	89 81       	ldd	r24, Y+1	; 0x01
    6440:	9a 81       	ldd	r25, Y+2	; 0x02
    6442:	00 97       	sbiw	r24, 0x00	; 0
    6444:	99 f0       	breq	.+38     	; 0x646c <xTimerCreate+0x68>
            {
                /* Status is thus far zero as the timer is not created statically
                 * and has not been started.  The auto-reload bit may get set in
                 * prvInitialiseNewTimer. */
                pxNewTimer->ucStatus = 0x00;
    6446:	e9 81       	ldd	r30, Y+1	; 0x01
    6448:	fa 81       	ldd	r31, Y+2	; 0x02
    644a:	13 8a       	std	Z+19, r1	; 0x13
                prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
    644c:	8b 81       	ldd	r24, Y+3	; 0x03
    644e:	9c 81       	ldd	r25, Y+4	; 0x04
    6450:	2d 81       	ldd	r18, Y+5	; 0x05
    6452:	3e 81       	ldd	r19, Y+6	; 0x06
    6454:	e8 85       	ldd	r30, Y+8	; 0x08
    6456:	f9 85       	ldd	r31, Y+9	; 0x09
    6458:	aa 85       	ldd	r26, Y+10	; 0x0a
    645a:	bb 85       	ldd	r27, Y+11	; 0x0b
    645c:	e9 80       	ldd	r14, Y+1	; 0x01
    645e:	fa 80       	ldd	r15, Y+2	; 0x02
    6460:	b9 01       	movw	r22, r18
    6462:	4f 81       	ldd	r20, Y+7	; 0x07
    6464:	9f 01       	movw	r18, r30
    6466:	8d 01       	movw	r16, r26
    6468:	0e 94 45 32 	call	0x648a	; 0x648a <prvInitialiseNewTimer>
            }

            return pxNewTimer;
    646c:	89 81       	ldd	r24, Y+1	; 0x01
    646e:	9a 81       	ldd	r25, Y+2	; 0x02
        }
    6470:	2b 96       	adiw	r28, 0x0b	; 11
    6472:	0f b6       	in	r0, 0x3f	; 63
    6474:	f8 94       	cli
    6476:	de bf       	out	0x3e, r29	; 62
    6478:	0f be       	out	0x3f, r0	; 63
    647a:	cd bf       	out	0x3d, r28	; 61
    647c:	cf 91       	pop	r28
    647e:	df 91       	pop	r29
    6480:	1f 91       	pop	r17
    6482:	0f 91       	pop	r16
    6484:	ff 90       	pop	r15
    6486:	ef 90       	pop	r14
    6488:	08 95       	ret

0000648a <prvInitialiseNewTimer>:
                                       const TickType_t xTimerPeriodInTicks,
                                       const UBaseType_t uxAutoReload,
                                       void * const pvTimerID,
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer )
    {
    648a:	ef 92       	push	r14
    648c:	ff 92       	push	r15
    648e:	0f 93       	push	r16
    6490:	1f 93       	push	r17
    6492:	df 93       	push	r29
    6494:	cf 93       	push	r28
    6496:	cd b7       	in	r28, 0x3d	; 61
    6498:	de b7       	in	r29, 0x3e	; 62
    649a:	2b 97       	sbiw	r28, 0x0b	; 11
    649c:	0f b6       	in	r0, 0x3f	; 63
    649e:	f8 94       	cli
    64a0:	de bf       	out	0x3e, r29	; 62
    64a2:	0f be       	out	0x3f, r0	; 63
    64a4:	cd bf       	out	0x3d, r28	; 61
    64a6:	9a 83       	std	Y+2, r25	; 0x02
    64a8:	89 83       	std	Y+1, r24	; 0x01
    64aa:	7c 83       	std	Y+4, r23	; 0x04
    64ac:	6b 83       	std	Y+3, r22	; 0x03
    64ae:	4d 83       	std	Y+5, r20	; 0x05
    64b0:	3f 83       	std	Y+7, r19	; 0x07
    64b2:	2e 83       	std	Y+6, r18	; 0x06
    64b4:	19 87       	std	Y+9, r17	; 0x09
    64b6:	08 87       	std	Y+8, r16	; 0x08
    64b8:	fb 86       	std	Y+11, r15	; 0x0b
    64ba:	ea 86       	std	Y+10, r14	; 0x0a
        /* 0 is not a valid value for xTimerPeriodInTicks. */
        configASSERT( ( xTimerPeriodInTicks > 0 ) );

        /* Ensure the infrastructure used by the timer service task has been
         * created/initialised. */
        prvCheckForValidListAndQueue();
    64bc:	0e 94 98 36 	call	0x6d30	; 0x6d30 <prvCheckForValidListAndQueue>

        /* Initialise the timer structure members using the function
         * parameters. */
        pxNewTimer->pcTimerName = pcTimerName;
    64c0:	ea 85       	ldd	r30, Y+10	; 0x0a
    64c2:	fb 85       	ldd	r31, Y+11	; 0x0b
    64c4:	89 81       	ldd	r24, Y+1	; 0x01
    64c6:	9a 81       	ldd	r25, Y+2	; 0x02
    64c8:	91 83       	std	Z+1, r25	; 0x01
    64ca:	80 83       	st	Z, r24
        pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    64cc:	ea 85       	ldd	r30, Y+10	; 0x0a
    64ce:	fb 85       	ldd	r31, Y+11	; 0x0b
    64d0:	8b 81       	ldd	r24, Y+3	; 0x03
    64d2:	9c 81       	ldd	r25, Y+4	; 0x04
    64d4:	95 87       	std	Z+13, r25	; 0x0d
    64d6:	84 87       	std	Z+12, r24	; 0x0c
        pxNewTimer->pvTimerID = pvTimerID;
    64d8:	ea 85       	ldd	r30, Y+10	; 0x0a
    64da:	fb 85       	ldd	r31, Y+11	; 0x0b
    64dc:	8e 81       	ldd	r24, Y+6	; 0x06
    64de:	9f 81       	ldd	r25, Y+7	; 0x07
    64e0:	97 87       	std	Z+15, r25	; 0x0f
    64e2:	86 87       	std	Z+14, r24	; 0x0e
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    64e4:	ea 85       	ldd	r30, Y+10	; 0x0a
    64e6:	fb 85       	ldd	r31, Y+11	; 0x0b
    64e8:	88 85       	ldd	r24, Y+8	; 0x08
    64ea:	99 85       	ldd	r25, Y+9	; 0x09
    64ec:	91 8b       	std	Z+17, r25	; 0x11
    64ee:	80 8b       	std	Z+16, r24	; 0x10
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    64f0:	8a 85       	ldd	r24, Y+10	; 0x0a
    64f2:	9b 85       	ldd	r25, Y+11	; 0x0b
    64f4:	02 96       	adiw	r24, 0x02	; 2
    64f6:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <vListInitialiseItem>

        if( uxAutoReload != pdFALSE )
    64fa:	8d 81       	ldd	r24, Y+5	; 0x05
    64fc:	88 23       	and	r24, r24
    64fe:	39 f0       	breq	.+14     	; 0x650e <prvInitialiseNewTimer+0x84>
        {
            pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    6500:	ea 85       	ldd	r30, Y+10	; 0x0a
    6502:	fb 85       	ldd	r31, Y+11	; 0x0b
    6504:	83 89       	ldd	r24, Z+19	; 0x13
    6506:	84 60       	ori	r24, 0x04	; 4
    6508:	ea 85       	ldd	r30, Y+10	; 0x0a
    650a:	fb 85       	ldd	r31, Y+11	; 0x0b
    650c:	83 8b       	std	Z+19, r24	; 0x13
        }

        traceTIMER_CREATE( pxNewTimer );
    }
    650e:	2b 96       	adiw	r28, 0x0b	; 11
    6510:	0f b6       	in	r0, 0x3f	; 63
    6512:	f8 94       	cli
    6514:	de bf       	out	0x3e, r29	; 62
    6516:	0f be       	out	0x3f, r0	; 63
    6518:	cd bf       	out	0x3d, r28	; 61
    651a:	cf 91       	pop	r28
    651c:	df 91       	pop	r29
    651e:	1f 91       	pop	r17
    6520:	0f 91       	pop	r16
    6522:	ff 90       	pop	r15
    6524:	ef 90       	pop	r14
    6526:	08 95       	ret

00006528 <xTimerGenericCommand>:
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
    6528:	0f 93       	push	r16
    652a:	1f 93       	push	r17
    652c:	df 93       	push	r29
    652e:	cf 93       	push	r28
    6530:	cd b7       	in	r28, 0x3d	; 61
    6532:	de b7       	in	r29, 0x3e	; 62
    6534:	2f 97       	sbiw	r28, 0x0f	; 15
    6536:	0f b6       	in	r0, 0x3f	; 63
    6538:	f8 94       	cli
    653a:	de bf       	out	0x3e, r29	; 62
    653c:	0f be       	out	0x3f, r0	; 63
    653e:	cd bf       	out	0x3d, r28	; 61
    6540:	98 87       	std	Y+8, r25	; 0x08
    6542:	8f 83       	std	Y+7, r24	; 0x07
    6544:	69 87       	std	Y+9, r22	; 0x09
    6546:	5b 87       	std	Y+11, r21	; 0x0b
    6548:	4a 87       	std	Y+10, r20	; 0x0a
    654a:	3d 87       	std	Y+13, r19	; 0x0d
    654c:	2c 87       	std	Y+12, r18	; 0x0c
    654e:	1f 87       	std	Y+15, r17	; 0x0f
    6550:	0e 87       	std	Y+14, r16	; 0x0e
        BaseType_t xReturn = pdFAIL;
    6552:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTimer );

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
    6554:	80 91 32 07 	lds	r24, 0x0732
    6558:	90 91 33 07 	lds	r25, 0x0733
    655c:	00 97       	sbiw	r24, 0x00	; 0
    655e:	e9 f1       	breq	.+122    	; 0x65da <xTimerGenericCommand+0xb2>
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
    6560:	89 85       	ldd	r24, Y+9	; 0x09
    6562:	8a 83       	std	Y+2, r24	; 0x02
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    6564:	8a 85       	ldd	r24, Y+10	; 0x0a
    6566:	9b 85       	ldd	r25, Y+11	; 0x0b
    6568:	9c 83       	std	Y+4, r25	; 0x04
    656a:	8b 83       	std	Y+3, r24	; 0x03
            xMessage.u.xTimerParameters.pxTimer = xTimer;
    656c:	8f 81       	ldd	r24, Y+7	; 0x07
    656e:	98 85       	ldd	r25, Y+8	; 0x08
    6570:	9e 83       	std	Y+6, r25	; 0x06
    6572:	8d 83       	std	Y+5, r24	; 0x05

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    6574:	89 85       	ldd	r24, Y+9	; 0x09
    6576:	86 30       	cpi	r24, 0x06	; 6
    6578:	14 f5       	brge	.+68     	; 0x65be <xTimerGenericCommand+0x96>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    657a:	0e 94 50 27 	call	0x4ea0	; 0x4ea0 <xTaskGetSchedulerState>
    657e:	82 30       	cpi	r24, 0x02	; 2
    6580:	79 f4       	brne	.+30     	; 0x65a0 <xTimerGenericCommand+0x78>
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    6582:	80 91 32 07 	lds	r24, 0x0732
    6586:	90 91 33 07 	lds	r25, 0x0733
    658a:	9e 01       	movw	r18, r28
    658c:	2e 5f       	subi	r18, 0xFE	; 254
    658e:	3f 4f       	sbci	r19, 0xFF	; 255
    6590:	4e 85       	ldd	r20, Y+14	; 0x0e
    6592:	5f 85       	ldd	r21, Y+15	; 0x0f
    6594:	b9 01       	movw	r22, r18
    6596:	20 e0       	ldi	r18, 0x00	; 0
    6598:	0e 94 40 10 	call	0x2080	; 0x2080 <xQueueGenericSend>
    659c:	89 83       	std	Y+1, r24	; 0x01
    659e:	1d c0       	rjmp	.+58     	; 0x65da <xTimerGenericCommand+0xb2>
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    65a0:	80 91 32 07 	lds	r24, 0x0732
    65a4:	90 91 33 07 	lds	r25, 0x0733
    65a8:	9e 01       	movw	r18, r28
    65aa:	2e 5f       	subi	r18, 0xFE	; 254
    65ac:	3f 4f       	sbci	r19, 0xFF	; 255
    65ae:	b9 01       	movw	r22, r18
    65b0:	40 e0       	ldi	r20, 0x00	; 0
    65b2:	50 e0       	ldi	r21, 0x00	; 0
    65b4:	20 e0       	ldi	r18, 0x00	; 0
    65b6:	0e 94 40 10 	call	0x2080	; 0x2080 <xQueueGenericSend>
    65ba:	89 83       	std	Y+1, r24	; 0x01
    65bc:	0e c0       	rjmp	.+28     	; 0x65da <xTimerGenericCommand+0xb2>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    65be:	80 91 32 07 	lds	r24, 0x0732
    65c2:	90 91 33 07 	lds	r25, 0x0733
    65c6:	9e 01       	movw	r18, r28
    65c8:	2e 5f       	subi	r18, 0xFE	; 254
    65ca:	3f 4f       	sbci	r19, 0xFF	; 255
    65cc:	4c 85       	ldd	r20, Y+12	; 0x0c
    65ce:	5d 85       	ldd	r21, Y+13	; 0x0d
    65d0:	b9 01       	movw	r22, r18
    65d2:	20 e0       	ldi	r18, 0x00	; 0
    65d4:	0e 94 ec 10 	call	0x21d8	; 0x21d8 <xQueueGenericSendFromISR>
    65d8:	89 83       	std	Y+1, r24	; 0x01
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    65da:	89 81       	ldd	r24, Y+1	; 0x01
    }
    65dc:	2f 96       	adiw	r28, 0x0f	; 15
    65de:	0f b6       	in	r0, 0x3f	; 63
    65e0:	f8 94       	cli
    65e2:	de bf       	out	0x3e, r29	; 62
    65e4:	0f be       	out	0x3f, r0	; 63
    65e6:	cd bf       	out	0x3d, r28	; 61
    65e8:	cf 91       	pop	r28
    65ea:	df 91       	pop	r29
    65ec:	1f 91       	pop	r17
    65ee:	0f 91       	pop	r16
    65f0:	08 95       	ret

000065f2 <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
    {
    65f2:	df 93       	push	r29
    65f4:	cf 93       	push	r28
    65f6:	cd b7       	in	r28, 0x3d	; 61
    65f8:	de b7       	in	r29, 0x3e	; 62
        /* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
         * started, then xTimerTaskHandle will be NULL. */
        configASSERT( ( xTimerTaskHandle != NULL ) );
        return xTimerTaskHandle;
    65fa:	80 91 34 07 	lds	r24, 0x0734
    65fe:	90 91 35 07 	lds	r25, 0x0735
    }
    6602:	cf 91       	pop	r28
    6604:	df 91       	pop	r29
    6606:	08 95       	ret

00006608 <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
    {
    6608:	df 93       	push	r29
    660a:	cf 93       	push	r28
    660c:	00 d0       	rcall	.+0      	; 0x660e <xTimerGetPeriod+0x6>
    660e:	00 d0       	rcall	.+0      	; 0x6610 <xTimerGetPeriod+0x8>
    6610:	cd b7       	in	r28, 0x3d	; 61
    6612:	de b7       	in	r29, 0x3e	; 62
    6614:	9c 83       	std	Y+4, r25	; 0x04
    6616:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    6618:	8b 81       	ldd	r24, Y+3	; 0x03
    661a:	9c 81       	ldd	r25, Y+4	; 0x04
    661c:	9a 83       	std	Y+2, r25	; 0x02
    661e:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->xTimerPeriodInTicks;
    6620:	e9 81       	ldd	r30, Y+1	; 0x01
    6622:	fa 81       	ldd	r31, Y+2	; 0x02
    6624:	84 85       	ldd	r24, Z+12	; 0x0c
    6626:	95 85       	ldd	r25, Z+13	; 0x0d
    }
    6628:	0f 90       	pop	r0
    662a:	0f 90       	pop	r0
    662c:	0f 90       	pop	r0
    662e:	0f 90       	pop	r0
    6630:	cf 91       	pop	r28
    6632:	df 91       	pop	r29
    6634:	08 95       	ret

00006636 <vTimerSetReloadMode>:
/*-----------------------------------------------------------*/

    void vTimerSetReloadMode( TimerHandle_t xTimer,
                              const UBaseType_t uxAutoReload )
    {
    6636:	df 93       	push	r29
    6638:	cf 93       	push	r28
    663a:	00 d0       	rcall	.+0      	; 0x663c <vTimerSetReloadMode+0x6>
    663c:	00 d0       	rcall	.+0      	; 0x663e <vTimerSetReloadMode+0x8>
    663e:	0f 92       	push	r0
    6640:	cd b7       	in	r28, 0x3d	; 61
    6642:	de b7       	in	r29, 0x3e	; 62
    6644:	9c 83       	std	Y+4, r25	; 0x04
    6646:	8b 83       	std	Y+3, r24	; 0x03
    6648:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * pxTimer = xTimer;
    664a:	8b 81       	ldd	r24, Y+3	; 0x03
    664c:	9c 81       	ldd	r25, Y+4	; 0x04
    664e:	9a 83       	std	Y+2, r25	; 0x02
    6650:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    6652:	0f b6       	in	r0, 0x3f	; 63
    6654:	f8 94       	cli
    6656:	0f 92       	push	r0
        {
            if( uxAutoReload != pdFALSE )
    6658:	8d 81       	ldd	r24, Y+5	; 0x05
    665a:	88 23       	and	r24, r24
    665c:	41 f0       	breq	.+16     	; 0x666e <vTimerSetReloadMode+0x38>
            {
                pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    665e:	e9 81       	ldd	r30, Y+1	; 0x01
    6660:	fa 81       	ldd	r31, Y+2	; 0x02
    6662:	83 89       	ldd	r24, Z+19	; 0x13
    6664:	84 60       	ori	r24, 0x04	; 4
    6666:	e9 81       	ldd	r30, Y+1	; 0x01
    6668:	fa 81       	ldd	r31, Y+2	; 0x02
    666a:	83 8b       	std	Z+19, r24	; 0x13
    666c:	07 c0       	rjmp	.+14     	; 0x667c <vTimerSetReloadMode+0x46>
            }
            else
            {
                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_AUTORELOAD );
    666e:	e9 81       	ldd	r30, Y+1	; 0x01
    6670:	fa 81       	ldd	r31, Y+2	; 0x02
    6672:	83 89       	ldd	r24, Z+19	; 0x13
    6674:	8b 7f       	andi	r24, 0xFB	; 251
    6676:	e9 81       	ldd	r30, Y+1	; 0x01
    6678:	fa 81       	ldd	r31, Y+2	; 0x02
    667a:	83 8b       	std	Z+19, r24	; 0x13
            }
        }
        taskEXIT_CRITICAL();
    667c:	0f 90       	pop	r0
    667e:	0f be       	out	0x3f, r0	; 63
    }
    6680:	0f 90       	pop	r0
    6682:	0f 90       	pop	r0
    6684:	0f 90       	pop	r0
    6686:	0f 90       	pop	r0
    6688:	0f 90       	pop	r0
    668a:	cf 91       	pop	r28
    668c:	df 91       	pop	r29
    668e:	08 95       	ret

00006690 <uxTimerGetReloadMode>:
/*-----------------------------------------------------------*/

    UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
    {
    6690:	df 93       	push	r29
    6692:	cf 93       	push	r28
    6694:	00 d0       	rcall	.+0      	; 0x6696 <uxTimerGetReloadMode+0x6>
    6696:	00 d0       	rcall	.+0      	; 0x6698 <uxTimerGetReloadMode+0x8>
    6698:	0f 92       	push	r0
    669a:	cd b7       	in	r28, 0x3d	; 61
    669c:	de b7       	in	r29, 0x3e	; 62
    669e:	9d 83       	std	Y+5, r25	; 0x05
    66a0:	8c 83       	std	Y+4, r24	; 0x04
        Timer_t * pxTimer = xTimer;
    66a2:	8c 81       	ldd	r24, Y+4	; 0x04
    66a4:	9d 81       	ldd	r25, Y+5	; 0x05
    66a6:	9b 83       	std	Y+3, r25	; 0x03
    66a8:	8a 83       	std	Y+2, r24	; 0x02
        UBaseType_t uxReturn;

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    66aa:	0f b6       	in	r0, 0x3f	; 63
    66ac:	f8 94       	cli
    66ae:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
    66b0:	ea 81       	ldd	r30, Y+2	; 0x02
    66b2:	fb 81       	ldd	r31, Y+3	; 0x03
    66b4:	83 89       	ldd	r24, Z+19	; 0x13
    66b6:	88 2f       	mov	r24, r24
    66b8:	90 e0       	ldi	r25, 0x00	; 0
    66ba:	84 70       	andi	r24, 0x04	; 4
    66bc:	90 70       	andi	r25, 0x00	; 0
    66be:	00 97       	sbiw	r24, 0x00	; 0
    66c0:	11 f4       	brne	.+4      	; 0x66c6 <uxTimerGetReloadMode+0x36>
            {
                /* Not an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdFALSE;
    66c2:	19 82       	std	Y+1, r1	; 0x01
    66c4:	02 c0       	rjmp	.+4      	; 0x66ca <uxTimerGetReloadMode+0x3a>
            }
            else
            {
                /* Is an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdTRUE;
    66c6:	81 e0       	ldi	r24, 0x01	; 1
    66c8:	89 83       	std	Y+1, r24	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    66ca:	0f 90       	pop	r0
    66cc:	0f be       	out	0x3f, r0	; 63

        return uxReturn;
    66ce:	89 81       	ldd	r24, Y+1	; 0x01
    }
    66d0:	0f 90       	pop	r0
    66d2:	0f 90       	pop	r0
    66d4:	0f 90       	pop	r0
    66d6:	0f 90       	pop	r0
    66d8:	0f 90       	pop	r0
    66da:	cf 91       	pop	r28
    66dc:	df 91       	pop	r29
    66de:	08 95       	ret

000066e0 <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
    {
    66e0:	df 93       	push	r29
    66e2:	cf 93       	push	r28
    66e4:	00 d0       	rcall	.+0      	; 0x66e6 <xTimerGetExpiryTime+0x6>
    66e6:	00 d0       	rcall	.+0      	; 0x66e8 <xTimerGetExpiryTime+0x8>
    66e8:	00 d0       	rcall	.+0      	; 0x66ea <xTimerGetExpiryTime+0xa>
    66ea:	cd b7       	in	r28, 0x3d	; 61
    66ec:	de b7       	in	r29, 0x3e	; 62
    66ee:	9e 83       	std	Y+6, r25	; 0x06
    66f0:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * pxTimer = xTimer;
    66f2:	8d 81       	ldd	r24, Y+5	; 0x05
    66f4:	9e 81       	ldd	r25, Y+6	; 0x06
    66f6:	9c 83       	std	Y+4, r25	; 0x04
    66f8:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xReturn;

        configASSERT( xTimer );
        xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
    66fa:	eb 81       	ldd	r30, Y+3	; 0x03
    66fc:	fc 81       	ldd	r31, Y+4	; 0x04
    66fe:	82 81       	ldd	r24, Z+2	; 0x02
    6700:	93 81       	ldd	r25, Z+3	; 0x03
    6702:	9a 83       	std	Y+2, r25	; 0x02
    6704:	89 83       	std	Y+1, r24	; 0x01
        return xReturn;
    6706:	89 81       	ldd	r24, Y+1	; 0x01
    6708:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    670a:	26 96       	adiw	r28, 0x06	; 6
    670c:	0f b6       	in	r0, 0x3f	; 63
    670e:	f8 94       	cli
    6710:	de bf       	out	0x3e, r29	; 62
    6712:	0f be       	out	0x3f, r0	; 63
    6714:	cd bf       	out	0x3d, r28	; 61
    6716:	cf 91       	pop	r28
    6718:	df 91       	pop	r29
    671a:	08 95       	ret

0000671c <pcTimerGetName>:
/*-----------------------------------------------------------*/

    const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
    671c:	df 93       	push	r29
    671e:	cf 93       	push	r28
    6720:	00 d0       	rcall	.+0      	; 0x6722 <pcTimerGetName+0x6>
    6722:	00 d0       	rcall	.+0      	; 0x6724 <pcTimerGetName+0x8>
    6724:	cd b7       	in	r28, 0x3d	; 61
    6726:	de b7       	in	r29, 0x3e	; 62
    6728:	9c 83       	std	Y+4, r25	; 0x04
    672a:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    672c:	8b 81       	ldd	r24, Y+3	; 0x03
    672e:	9c 81       	ldd	r25, Y+4	; 0x04
    6730:	9a 83       	std	Y+2, r25	; 0x02
    6732:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->pcTimerName;
    6734:	e9 81       	ldd	r30, Y+1	; 0x01
    6736:	fa 81       	ldd	r31, Y+2	; 0x02
    6738:	80 81       	ld	r24, Z
    673a:	91 81       	ldd	r25, Z+1	; 0x01
    }
    673c:	0f 90       	pop	r0
    673e:	0f 90       	pop	r0
    6740:	0f 90       	pop	r0
    6742:	0f 90       	pop	r0
    6744:	cf 91       	pop	r28
    6746:	df 91       	pop	r29
    6748:	08 95       	ret

0000674a <prvReloadTimer>:
/*-----------------------------------------------------------*/

    static void prvReloadTimer( Timer_t * const pxTimer,
                                TickType_t xExpiredTime,
                                const TickType_t xTimeNow )
    {
    674a:	df 93       	push	r29
    674c:	cf 93       	push	r28
    674e:	00 d0       	rcall	.+0      	; 0x6750 <prvReloadTimer+0x6>
    6750:	00 d0       	rcall	.+0      	; 0x6752 <prvReloadTimer+0x8>
    6752:	00 d0       	rcall	.+0      	; 0x6754 <prvReloadTimer+0xa>
    6754:	cd b7       	in	r28, 0x3d	; 61
    6756:	de b7       	in	r29, 0x3e	; 62
    6758:	9a 83       	std	Y+2, r25	; 0x02
    675a:	89 83       	std	Y+1, r24	; 0x01
    675c:	7c 83       	std	Y+4, r23	; 0x04
    675e:	6b 83       	std	Y+3, r22	; 0x03
    6760:	5e 83       	std	Y+6, r21	; 0x06
    6762:	4d 83       	std	Y+5, r20	; 0x05
    6764:	12 c0       	rjmp	.+36     	; 0x678a <prvReloadTimer+0x40>
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
        {
            /* Advance the expiry time. */
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
    6766:	e9 81       	ldd	r30, Y+1	; 0x01
    6768:	fa 81       	ldd	r31, Y+2	; 0x02
    676a:	24 85       	ldd	r18, Z+12	; 0x0c
    676c:	35 85       	ldd	r19, Z+13	; 0x0d
    676e:	8b 81       	ldd	r24, Y+3	; 0x03
    6770:	9c 81       	ldd	r25, Y+4	; 0x04
    6772:	82 0f       	add	r24, r18
    6774:	93 1f       	adc	r25, r19
    6776:	9c 83       	std	Y+4, r25	; 0x04
    6778:	8b 83       	std	Y+3, r24	; 0x03

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    677a:	e9 81       	ldd	r30, Y+1	; 0x01
    677c:	fa 81       	ldd	r31, Y+2	; 0x02
    677e:	00 88       	ldd	r0, Z+16	; 0x10
    6780:	f1 89       	ldd	r31, Z+17	; 0x11
    6782:	e0 2d       	mov	r30, r0
    6784:	89 81       	ldd	r24, Y+1	; 0x01
    6786:	9a 81       	ldd	r25, Y+2	; 0x02
    6788:	09 95       	icall
                                const TickType_t xTimeNow )
    {
        /* Insert the timer into the appropriate list for the next expiry time.
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
    678a:	e9 81       	ldd	r30, Y+1	; 0x01
    678c:	fa 81       	ldd	r31, Y+2	; 0x02
    678e:	24 85       	ldd	r18, Z+12	; 0x0c
    6790:	35 85       	ldd	r19, Z+13	; 0x0d
    6792:	8b 81       	ldd	r24, Y+3	; 0x03
    6794:	9c 81       	ldd	r25, Y+4	; 0x04
    6796:	a9 01       	movw	r20, r18
    6798:	48 0f       	add	r20, r24
    679a:	59 1f       	adc	r21, r25
    679c:	89 81       	ldd	r24, Y+1	; 0x01
    679e:	9a 81       	ldd	r25, Y+2	; 0x02
    67a0:	2d 81       	ldd	r18, Y+5	; 0x05
    67a2:	3e 81       	ldd	r19, Y+6	; 0x06
    67a4:	eb 81       	ldd	r30, Y+3	; 0x03
    67a6:	fc 81       	ldd	r31, Y+4	; 0x04
    67a8:	ba 01       	movw	r22, r20
    67aa:	a9 01       	movw	r20, r18
    67ac:	9f 01       	movw	r18, r30
    67ae:	0e 94 fb 34 	call	0x69f6	; 0x69f6 <prvInsertTimerInActiveList>
    67b2:	88 23       	and	r24, r24
    67b4:	c1 f6       	brne	.-80     	; 0x6766 <prvReloadTimer+0x1c>

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
        }
    }
    67b6:	26 96       	adiw	r28, 0x06	; 6
    67b8:	0f b6       	in	r0, 0x3f	; 63
    67ba:	f8 94       	cli
    67bc:	de bf       	out	0x3e, r29	; 62
    67be:	0f be       	out	0x3f, r0	; 63
    67c0:	cd bf       	out	0x3d, r28	; 61
    67c2:	cf 91       	pop	r28
    67c4:	df 91       	pop	r29
    67c6:	08 95       	ret

000067c8 <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
    67c8:	df 93       	push	r29
    67ca:	cf 93       	push	r28
    67cc:	00 d0       	rcall	.+0      	; 0x67ce <prvProcessExpiredTimer+0x6>
    67ce:	00 d0       	rcall	.+0      	; 0x67d0 <prvProcessExpiredTimer+0x8>
    67d0:	00 d0       	rcall	.+0      	; 0x67d2 <prvProcessExpiredTimer+0xa>
    67d2:	cd b7       	in	r28, 0x3d	; 61
    67d4:	de b7       	in	r29, 0x3e	; 62
    67d6:	9c 83       	std	Y+4, r25	; 0x04
    67d8:	8b 83       	std	Y+3, r24	; 0x03
    67da:	7e 83       	std	Y+6, r23	; 0x06
    67dc:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    67de:	e0 91 4a 07 	lds	r30, 0x074A
    67e2:	f0 91 4b 07 	lds	r31, 0x074B
    67e6:	05 80       	ldd	r0, Z+5	; 0x05
    67e8:	f6 81       	ldd	r31, Z+6	; 0x06
    67ea:	e0 2d       	mov	r30, r0
    67ec:	86 81       	ldd	r24, Z+6	; 0x06
    67ee:	97 81       	ldd	r25, Z+7	; 0x07
    67f0:	9a 83       	std	Y+2, r25	; 0x02
    67f2:	89 83       	std	Y+1, r24	; 0x01

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    67f4:	89 81       	ldd	r24, Y+1	; 0x01
    67f6:	9a 81       	ldd	r25, Y+2	; 0x02
    67f8:	02 96       	adiw	r24, 0x02	; 2
    67fa:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <uxListRemove>

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    67fe:	e9 81       	ldd	r30, Y+1	; 0x01
    6800:	fa 81       	ldd	r31, Y+2	; 0x02
    6802:	83 89       	ldd	r24, Z+19	; 0x13
    6804:	88 2f       	mov	r24, r24
    6806:	90 e0       	ldi	r25, 0x00	; 0
    6808:	84 70       	andi	r24, 0x04	; 4
    680a:	90 70       	andi	r25, 0x00	; 0
    680c:	00 97       	sbiw	r24, 0x00	; 0
    680e:	51 f0       	breq	.+20     	; 0x6824 <prvProcessExpiredTimer+0x5c>
        {
            prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
    6810:	89 81       	ldd	r24, Y+1	; 0x01
    6812:	9a 81       	ldd	r25, Y+2	; 0x02
    6814:	2b 81       	ldd	r18, Y+3	; 0x03
    6816:	3c 81       	ldd	r19, Y+4	; 0x04
    6818:	4d 81       	ldd	r20, Y+5	; 0x05
    681a:	5e 81       	ldd	r21, Y+6	; 0x06
    681c:	b9 01       	movw	r22, r18
    681e:	0e 94 a5 33 	call	0x674a	; 0x674a <prvReloadTimer>
    6822:	07 c0       	rjmp	.+14     	; 0x6832 <prvProcessExpiredTimer+0x6a>
        }
        else
        {
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    6824:	e9 81       	ldd	r30, Y+1	; 0x01
    6826:	fa 81       	ldd	r31, Y+2	; 0x02
    6828:	83 89       	ldd	r24, Z+19	; 0x13
    682a:	8e 7f       	andi	r24, 0xFE	; 254
    682c:	e9 81       	ldd	r30, Y+1	; 0x01
    682e:	fa 81       	ldd	r31, Y+2	; 0x02
    6830:	83 8b       	std	Z+19, r24	; 0x13
        }

        /* Call the timer callback. */
        traceTIMER_EXPIRED( pxTimer );
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    6832:	e9 81       	ldd	r30, Y+1	; 0x01
    6834:	fa 81       	ldd	r31, Y+2	; 0x02
    6836:	00 88       	ldd	r0, Z+16	; 0x10
    6838:	f1 89       	ldd	r31, Z+17	; 0x11
    683a:	e0 2d       	mov	r30, r0
    683c:	89 81       	ldd	r24, Y+1	; 0x01
    683e:	9a 81       	ldd	r25, Y+2	; 0x02
    6840:	09 95       	icall
    }
    6842:	26 96       	adiw	r28, 0x06	; 6
    6844:	0f b6       	in	r0, 0x3f	; 63
    6846:	f8 94       	cli
    6848:	de bf       	out	0x3e, r29	; 62
    684a:	0f be       	out	0x3f, r0	; 63
    684c:	cd bf       	out	0x3d, r28	; 61
    684e:	cf 91       	pop	r28
    6850:	df 91       	pop	r29
    6852:	08 95       	ret

00006854 <prvTimerTask>:
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
    6854:	df 93       	push	r29
    6856:	cf 93       	push	r28
    6858:	00 d0       	rcall	.+0      	; 0x685a <prvTimerTask+0x6>
    685a:	00 d0       	rcall	.+0      	; 0x685c <prvTimerTask+0x8>
    685c:	0f 92       	push	r0
    685e:	cd b7       	in	r28, 0x3d	; 61
    6860:	de b7       	in	r29, 0x3e	; 62
    6862:	9d 83       	std	Y+5, r25	; 0x05
    6864:	8c 83       	std	Y+4, r24	; 0x04

        for( ; ; )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    6866:	ce 01       	movw	r24, r28
    6868:	03 96       	adiw	r24, 0x03	; 3
    686a:	0e 94 99 34 	call	0x6932	; 0x6932 <prvGetNextExpireTime>
    686e:	9a 83       	std	Y+2, r25	; 0x02
    6870:	89 83       	std	Y+1, r24	; 0x01

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    6872:	2b 81       	ldd	r18, Y+3	; 0x03
    6874:	89 81       	ldd	r24, Y+1	; 0x01
    6876:	9a 81       	ldd	r25, Y+2	; 0x02
    6878:	62 2f       	mov	r22, r18
    687a:	0e 94 42 34 	call	0x6884	; 0x6884 <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
    687e:	0e 94 63 35 	call	0x6ac6	; 0x6ac6 <prvProcessReceivedCommands>
    6882:	f1 cf       	rjmp	.-30     	; 0x6866 <prvTimerTask+0x12>

00006884 <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
    6884:	df 93       	push	r29
    6886:	cf 93       	push	r28
    6888:	00 d0       	rcall	.+0      	; 0x688a <prvProcessTimerOrBlockTask+0x6>
    688a:	00 d0       	rcall	.+0      	; 0x688c <prvProcessTimerOrBlockTask+0x8>
    688c:	00 d0       	rcall	.+0      	; 0x688e <prvProcessTimerOrBlockTask+0xa>
    688e:	cd b7       	in	r28, 0x3d	; 61
    6890:	de b7       	in	r29, 0x3e	; 62
    6892:	9d 83       	std	Y+5, r25	; 0x05
    6894:	8c 83       	std	Y+4, r24	; 0x04
    6896:	6e 83       	std	Y+6, r22	; 0x06
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
    6898:	0e 94 30 1c 	call	0x3860	; 0x3860 <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    689c:	ce 01       	movw	r24, r28
    689e:	03 96       	adiw	r24, 0x03	; 3
    68a0:	0e 94 cd 34 	call	0x699a	; 0x699a <prvSampleTimeNow>
    68a4:	9a 83       	std	Y+2, r25	; 0x02
    68a6:	89 83       	std	Y+1, r24	; 0x01

            if( xTimerListsWereSwitched == pdFALSE )
    68a8:	8b 81       	ldd	r24, Y+3	; 0x03
    68aa:	88 23       	and	r24, r24
    68ac:	b9 f5       	brne	.+110    	; 0x691c <prvProcessTimerOrBlockTask+0x98>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    68ae:	8e 81       	ldd	r24, Y+6	; 0x06
    68b0:	88 23       	and	r24, r24
    68b2:	89 f4       	brne	.+34     	; 0x68d6 <prvProcessTimerOrBlockTask+0x52>
    68b4:	2c 81       	ldd	r18, Y+4	; 0x04
    68b6:	3d 81       	ldd	r19, Y+5	; 0x05
    68b8:	89 81       	ldd	r24, Y+1	; 0x01
    68ba:	9a 81       	ldd	r25, Y+2	; 0x02
    68bc:	82 17       	cp	r24, r18
    68be:	93 07       	cpc	r25, r19
    68c0:	50 f0       	brcs	.+20     	; 0x68d6 <prvProcessTimerOrBlockTask+0x52>
                {
                    ( void ) xTaskResumeAll();
    68c2:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    68c6:	8c 81       	ldd	r24, Y+4	; 0x04
    68c8:	9d 81       	ldd	r25, Y+5	; 0x05
    68ca:	29 81       	ldd	r18, Y+1	; 0x01
    68cc:	3a 81       	ldd	r19, Y+2	; 0x02
    68ce:	b9 01       	movw	r22, r18
    68d0:	0e 94 e4 33 	call	0x67c8	; 0x67c8 <prvProcessExpiredTimer>
    68d4:	25 c0       	rjmp	.+74     	; 0x6920 <prvProcessTimerOrBlockTask+0x9c>
                     * time has not been reached yet.  This task should therefore
                     * block to wait for the next expire time or a command to be
                     * received - whichever comes first.  The following line cannot
                     * be reached unless xNextExpireTime > xTimeNow, except in the
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
    68d6:	8e 81       	ldd	r24, Y+6	; 0x06
    68d8:	88 23       	and	r24, r24
    68da:	51 f0       	breq	.+20     	; 0x68f0 <prvProcessTimerOrBlockTask+0x6c>
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    68dc:	e0 91 4c 07 	lds	r30, 0x074C
    68e0:	f0 91 4d 07 	lds	r31, 0x074D
    68e4:	80 81       	ld	r24, Z
    68e6:	1e 82       	std	Y+6, r1	; 0x06
    68e8:	88 23       	and	r24, r24
    68ea:	11 f4       	brne	.+4      	; 0x68f0 <prvProcessTimerOrBlockTask+0x6c>
    68ec:	81 e0       	ldi	r24, 0x01	; 1
    68ee:	8e 83       	std	Y+6, r24	; 0x06
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    68f0:	40 91 32 07 	lds	r20, 0x0732
    68f4:	50 91 33 07 	lds	r21, 0x0733
    68f8:	2c 81       	ldd	r18, Y+4	; 0x04
    68fa:	3d 81       	ldd	r19, Y+5	; 0x05
    68fc:	89 81       	ldd	r24, Y+1	; 0x01
    68fe:	9a 81       	ldd	r25, Y+2	; 0x02
    6900:	28 1b       	sub	r18, r24
    6902:	39 0b       	sbc	r19, r25
    6904:	ca 01       	movw	r24, r20
    6906:	b9 01       	movw	r22, r18
    6908:	4e 81       	ldd	r20, Y+6	; 0x06
    690a:	0e 94 2a 18 	call	0x3054	; 0x3054 <vQueueWaitForMessageRestricted>

                    if( xTaskResumeAll() == pdFALSE )
    690e:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>
    6912:	88 23       	and	r24, r24
    6914:	29 f4       	brne	.+10     	; 0x6920 <prvProcessTimerOrBlockTask+0x9c>
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
    6916:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    691a:	02 c0       	rjmp	.+4      	; 0x6920 <prvProcessTimerOrBlockTask+0x9c>
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
    691c:	0e 94 3c 1c 	call	0x3878	; 0x3878 <xTaskResumeAll>
            }
        }
    }
    6920:	26 96       	adiw	r28, 0x06	; 6
    6922:	0f b6       	in	r0, 0x3f	; 63
    6924:	f8 94       	cli
    6926:	de bf       	out	0x3e, r29	; 62
    6928:	0f be       	out	0x3f, r0	; 63
    692a:	cd bf       	out	0x3d, r28	; 61
    692c:	cf 91       	pop	r28
    692e:	df 91       	pop	r29
    6930:	08 95       	ret

00006932 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
    6932:	df 93       	push	r29
    6934:	cf 93       	push	r28
    6936:	00 d0       	rcall	.+0      	; 0x6938 <prvGetNextExpireTime+0x6>
    6938:	00 d0       	rcall	.+0      	; 0x693a <prvGetNextExpireTime+0x8>
    693a:	0f 92       	push	r0
    693c:	cd b7       	in	r28, 0x3d	; 61
    693e:	de b7       	in	r29, 0x3e	; 62
    6940:	9c 83       	std	Y+4, r25	; 0x04
    6942:	8b 83       	std	Y+3, r24	; 0x03
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    6944:	e0 91 4a 07 	lds	r30, 0x074A
    6948:	f0 91 4b 07 	lds	r31, 0x074B
    694c:	80 81       	ld	r24, Z
    694e:	1d 82       	std	Y+5, r1	; 0x05
    6950:	88 23       	and	r24, r24
    6952:	11 f4       	brne	.+4      	; 0x6958 <prvGetNextExpireTime+0x26>
    6954:	81 e0       	ldi	r24, 0x01	; 1
    6956:	8d 83       	std	Y+5, r24	; 0x05
    6958:	eb 81       	ldd	r30, Y+3	; 0x03
    695a:	fc 81       	ldd	r31, Y+4	; 0x04
    695c:	8d 81       	ldd	r24, Y+5	; 0x05
    695e:	80 83       	st	Z, r24

        if( *pxListWasEmpty == pdFALSE )
    6960:	eb 81       	ldd	r30, Y+3	; 0x03
    6962:	fc 81       	ldd	r31, Y+4	; 0x04
    6964:	80 81       	ld	r24, Z
    6966:	88 23       	and	r24, r24
    6968:	61 f4       	brne	.+24     	; 0x6982 <prvGetNextExpireTime+0x50>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    696a:	e0 91 4a 07 	lds	r30, 0x074A
    696e:	f0 91 4b 07 	lds	r31, 0x074B
    6972:	05 80       	ldd	r0, Z+5	; 0x05
    6974:	f6 81       	ldd	r31, Z+6	; 0x06
    6976:	e0 2d       	mov	r30, r0
    6978:	80 81       	ld	r24, Z
    697a:	91 81       	ldd	r25, Z+1	; 0x01
    697c:	9a 83       	std	Y+2, r25	; 0x02
    697e:	89 83       	std	Y+1, r24	; 0x01
    6980:	02 c0       	rjmp	.+4      	; 0x6986 <prvGetNextExpireTime+0x54>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
    6982:	1a 82       	std	Y+2, r1	; 0x02
    6984:	19 82       	std	Y+1, r1	; 0x01
        }

        return xNextExpireTime;
    6986:	89 81       	ldd	r24, Y+1	; 0x01
    6988:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    698a:	0f 90       	pop	r0
    698c:	0f 90       	pop	r0
    698e:	0f 90       	pop	r0
    6990:	0f 90       	pop	r0
    6992:	0f 90       	pop	r0
    6994:	cf 91       	pop	r28
    6996:	df 91       	pop	r29
    6998:	08 95       	ret

0000699a <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
    699a:	df 93       	push	r29
    699c:	cf 93       	push	r28
    699e:	00 d0       	rcall	.+0      	; 0x69a0 <prvSampleTimeNow+0x6>
    69a0:	00 d0       	rcall	.+0      	; 0x69a2 <prvSampleTimeNow+0x8>
    69a2:	cd b7       	in	r28, 0x3d	; 61
    69a4:	de b7       	in	r29, 0x3e	; 62
    69a6:	9c 83       	std	Y+4, r25	; 0x04
    69a8:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
    69aa:	0e 94 8c 1d 	call	0x3b18	; 0x3b18 <xTaskGetTickCount>
    69ae:	9a 83       	std	Y+2, r25	; 0x02
    69b0:	89 83       	std	Y+1, r24	; 0x01

        if( xTimeNow < xLastTime )
    69b2:	20 91 36 07 	lds	r18, 0x0736
    69b6:	30 91 37 07 	lds	r19, 0x0737
    69ba:	89 81       	ldd	r24, Y+1	; 0x01
    69bc:	9a 81       	ldd	r25, Y+2	; 0x02
    69be:	82 17       	cp	r24, r18
    69c0:	93 07       	cpc	r25, r19
    69c2:	38 f4       	brcc	.+14     	; 0x69d2 <prvSampleTimeNow+0x38>
        {
            prvSwitchTimerLists();
    69c4:	0e 94 5e 36 	call	0x6cbc	; 0x6cbc <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
    69c8:	eb 81       	ldd	r30, Y+3	; 0x03
    69ca:	fc 81       	ldd	r31, Y+4	; 0x04
    69cc:	81 e0       	ldi	r24, 0x01	; 1
    69ce:	80 83       	st	Z, r24
    69d0:	03 c0       	rjmp	.+6      	; 0x69d8 <prvSampleTimeNow+0x3e>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
    69d2:	eb 81       	ldd	r30, Y+3	; 0x03
    69d4:	fc 81       	ldd	r31, Y+4	; 0x04
    69d6:	10 82       	st	Z, r1
        }

        xLastTime = xTimeNow;
    69d8:	89 81       	ldd	r24, Y+1	; 0x01
    69da:	9a 81       	ldd	r25, Y+2	; 0x02
    69dc:	90 93 37 07 	sts	0x0737, r25
    69e0:	80 93 36 07 	sts	0x0736, r24

        return xTimeNow;
    69e4:	89 81       	ldd	r24, Y+1	; 0x01
    69e6:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    69e8:	0f 90       	pop	r0
    69ea:	0f 90       	pop	r0
    69ec:	0f 90       	pop	r0
    69ee:	0f 90       	pop	r0
    69f0:	cf 91       	pop	r28
    69f2:	df 91       	pop	r29
    69f4:	08 95       	ret

000069f6 <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
    69f6:	df 93       	push	r29
    69f8:	cf 93       	push	r28
    69fa:	cd b7       	in	r28, 0x3d	; 61
    69fc:	de b7       	in	r29, 0x3e	; 62
    69fe:	29 97       	sbiw	r28, 0x09	; 9
    6a00:	0f b6       	in	r0, 0x3f	; 63
    6a02:	f8 94       	cli
    6a04:	de bf       	out	0x3e, r29	; 62
    6a06:	0f be       	out	0x3f, r0	; 63
    6a08:	cd bf       	out	0x3d, r28	; 61
    6a0a:	9b 83       	std	Y+3, r25	; 0x03
    6a0c:	8a 83       	std	Y+2, r24	; 0x02
    6a0e:	7d 83       	std	Y+5, r23	; 0x05
    6a10:	6c 83       	std	Y+4, r22	; 0x04
    6a12:	5f 83       	std	Y+7, r21	; 0x07
    6a14:	4e 83       	std	Y+6, r20	; 0x06
    6a16:	39 87       	std	Y+9, r19	; 0x09
    6a18:	28 87       	std	Y+8, r18	; 0x08
        BaseType_t xProcessTimerNow = pdFALSE;
    6a1a:	19 82       	std	Y+1, r1	; 0x01

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    6a1c:	ea 81       	ldd	r30, Y+2	; 0x02
    6a1e:	fb 81       	ldd	r31, Y+3	; 0x03
    6a20:	8c 81       	ldd	r24, Y+4	; 0x04
    6a22:	9d 81       	ldd	r25, Y+5	; 0x05
    6a24:	93 83       	std	Z+3, r25	; 0x03
    6a26:	82 83       	std	Z+2, r24	; 0x02
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    6a28:	ea 81       	ldd	r30, Y+2	; 0x02
    6a2a:	fb 81       	ldd	r31, Y+3	; 0x03
    6a2c:	8a 81       	ldd	r24, Y+2	; 0x02
    6a2e:	9b 81       	ldd	r25, Y+3	; 0x03
    6a30:	91 87       	std	Z+9, r25	; 0x09
    6a32:	80 87       	std	Z+8, r24	; 0x08

        if( xNextExpiryTime <= xTimeNow )
    6a34:	2c 81       	ldd	r18, Y+4	; 0x04
    6a36:	3d 81       	ldd	r19, Y+5	; 0x05
    6a38:	8e 81       	ldd	r24, Y+6	; 0x06
    6a3a:	9f 81       	ldd	r25, Y+7	; 0x07
    6a3c:	82 17       	cp	r24, r18
    6a3e:	93 07       	cpc	r25, r19
    6a40:	e0 f0       	brcs	.+56     	; 0x6a7a <prvInsertTimerInActiveList+0x84>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6a42:	2e 81       	ldd	r18, Y+6	; 0x06
    6a44:	3f 81       	ldd	r19, Y+7	; 0x07
    6a46:	88 85       	ldd	r24, Y+8	; 0x08
    6a48:	99 85       	ldd	r25, Y+9	; 0x09
    6a4a:	28 1b       	sub	r18, r24
    6a4c:	39 0b       	sbc	r19, r25
    6a4e:	ea 81       	ldd	r30, Y+2	; 0x02
    6a50:	fb 81       	ldd	r31, Y+3	; 0x03
    6a52:	84 85       	ldd	r24, Z+12	; 0x0c
    6a54:	95 85       	ldd	r25, Z+13	; 0x0d
    6a56:	28 17       	cp	r18, r24
    6a58:	39 07       	cpc	r19, r25
    6a5a:	18 f0       	brcs	.+6      	; 0x6a62 <prvInsertTimerInActiveList+0x6c>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
    6a5c:	81 e0       	ldi	r24, 0x01	; 1
    6a5e:	89 83       	std	Y+1, r24	; 0x01
    6a60:	28 c0       	rjmp	.+80     	; 0x6ab2 <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    6a62:	80 91 4c 07 	lds	r24, 0x074C
    6a66:	90 91 4d 07 	lds	r25, 0x074D
    6a6a:	2a 81       	ldd	r18, Y+2	; 0x02
    6a6c:	3b 81       	ldd	r19, Y+3	; 0x03
    6a6e:	2e 5f       	subi	r18, 0xFE	; 254
    6a70:	3f 4f       	sbci	r19, 0xFF	; 255
    6a72:	b9 01       	movw	r22, r18
    6a74:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <vListInsert>
    6a78:	1c c0       	rjmp	.+56     	; 0x6ab2 <prvInsertTimerInActiveList+0xbc>
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    6a7a:	2e 81       	ldd	r18, Y+6	; 0x06
    6a7c:	3f 81       	ldd	r19, Y+7	; 0x07
    6a7e:	88 85       	ldd	r24, Y+8	; 0x08
    6a80:	99 85       	ldd	r25, Y+9	; 0x09
    6a82:	28 17       	cp	r18, r24
    6a84:	39 07       	cpc	r19, r25
    6a86:	50 f4       	brcc	.+20     	; 0x6a9c <prvInsertTimerInActiveList+0xa6>
    6a88:	2c 81       	ldd	r18, Y+4	; 0x04
    6a8a:	3d 81       	ldd	r19, Y+5	; 0x05
    6a8c:	88 85       	ldd	r24, Y+8	; 0x08
    6a8e:	99 85       	ldd	r25, Y+9	; 0x09
    6a90:	28 17       	cp	r18, r24
    6a92:	39 07       	cpc	r19, r25
    6a94:	18 f0       	brcs	.+6      	; 0x6a9c <prvInsertTimerInActiveList+0xa6>
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
    6a96:	81 e0       	ldi	r24, 0x01	; 1
    6a98:	89 83       	std	Y+1, r24	; 0x01
    6a9a:	0b c0       	rjmp	.+22     	; 0x6ab2 <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    6a9c:	80 91 4a 07 	lds	r24, 0x074A
    6aa0:	90 91 4b 07 	lds	r25, 0x074B
    6aa4:	2a 81       	ldd	r18, Y+2	; 0x02
    6aa6:	3b 81       	ldd	r19, Y+3	; 0x03
    6aa8:	2e 5f       	subi	r18, 0xFE	; 254
    6aaa:	3f 4f       	sbci	r19, 0xFF	; 255
    6aac:	b9 01       	movw	r22, r18
    6aae:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <vListInsert>
            }
        }

        return xProcessTimerNow;
    6ab2:	89 81       	ldd	r24, Y+1	; 0x01
    }
    6ab4:	29 96       	adiw	r28, 0x09	; 9
    6ab6:	0f b6       	in	r0, 0x3f	; 63
    6ab8:	f8 94       	cli
    6aba:	de bf       	out	0x3e, r29	; 62
    6abc:	0f be       	out	0x3f, r0	; 63
    6abe:	cd bf       	out	0x3d, r28	; 61
    6ac0:	cf 91       	pop	r28
    6ac2:	df 91       	pop	r29
    6ac4:	08 95       	ret

00006ac6 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
    6ac6:	df 93       	push	r29
    6ac8:	cf 93       	push	r28
    6aca:	cd b7       	in	r28, 0x3d	; 61
    6acc:	de b7       	in	r29, 0x3e	; 62
    6ace:	2c 97       	sbiw	r28, 0x0c	; 12
    6ad0:	0f b6       	in	r0, 0x3f	; 63
    6ad2:	f8 94       	cli
    6ad4:	de bf       	out	0x3e, r29	; 62
    6ad6:	0f be       	out	0x3f, r0	; 63
    6ad8:	cd bf       	out	0x3d, r28	; 61
    6ada:	d8 c0       	rjmp	.+432    	; 0x6c8c <prvProcessReceivedCommands+0x1c6>
                }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    6adc:	8d 81       	ldd	r24, Y+5	; 0x05
    6ade:	88 23       	and	r24, r24
    6ae0:	0c f4       	brge	.+2      	; 0x6ae4 <prvProcessReceivedCommands+0x1e>
    6ae2:	d4 c0       	rjmp	.+424    	; 0x6c8c <prvProcessReceivedCommands+0x1c6>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
    6ae4:	88 85       	ldd	r24, Y+8	; 0x08
    6ae6:	99 85       	ldd	r25, Y+9	; 0x09
    6ae8:	9c 83       	std	Y+4, r25	; 0x04
    6aea:	8b 83       	std	Y+3, r24	; 0x03

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    6aec:	eb 81       	ldd	r30, Y+3	; 0x03
    6aee:	fc 81       	ldd	r31, Y+4	; 0x04
    6af0:	82 85       	ldd	r24, Z+10	; 0x0a
    6af2:	93 85       	ldd	r25, Z+11	; 0x0b
    6af4:	00 97       	sbiw	r24, 0x00	; 0
    6af6:	29 f0       	breq	.+10     	; 0x6b02 <prvProcessReceivedCommands+0x3c>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    6af8:	8b 81       	ldd	r24, Y+3	; 0x03
    6afa:	9c 81       	ldd	r25, Y+4	; 0x04
    6afc:	02 96       	adiw	r24, 0x02	; 2
    6afe:	0e 94 96 0e 	call	0x1d2c	; 0x1d2c <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    6b02:	ce 01       	movw	r24, r28
    6b04:	0a 96       	adiw	r24, 0x0a	; 10
    6b06:	0e 94 cd 34 	call	0x699a	; 0x699a <prvSampleTimeNow>
    6b0a:	9a 83       	std	Y+2, r25	; 0x02
    6b0c:	89 83       	std	Y+1, r24	; 0x01

                switch( xMessage.xMessageID )
    6b0e:	8d 81       	ldd	r24, Y+5	; 0x05
    6b10:	28 2f       	mov	r18, r24
    6b12:	33 27       	eor	r19, r19
    6b14:	27 fd       	sbrc	r18, 7
    6b16:	30 95       	com	r19
    6b18:	3c 87       	std	Y+12, r19	; 0x0c
    6b1a:	2b 87       	std	Y+11, r18	; 0x0b
    6b1c:	8b 85       	ldd	r24, Y+11	; 0x0b
    6b1e:	9c 85       	ldd	r25, Y+12	; 0x0c
    6b20:	85 30       	cpi	r24, 0x05	; 5
    6b22:	91 05       	cpc	r25, r1
    6b24:	09 f4       	brne	.+2      	; 0x6b28 <prvProcessReceivedCommands+0x62>
    6b26:	9d c0       	rjmp	.+314    	; 0x6c62 <prvProcessReceivedCommands+0x19c>
    6b28:	2b 85       	ldd	r18, Y+11	; 0x0b
    6b2a:	3c 85       	ldd	r19, Y+12	; 0x0c
    6b2c:	26 30       	cpi	r18, 0x06	; 6
    6b2e:	31 05       	cpc	r19, r1
    6b30:	9c f4       	brge	.+38     	; 0x6b58 <prvProcessReceivedCommands+0x92>
    6b32:	8b 85       	ldd	r24, Y+11	; 0x0b
    6b34:	9c 85       	ldd	r25, Y+12	; 0x0c
    6b36:	83 30       	cpi	r24, 0x03	; 3
    6b38:	91 05       	cpc	r25, r1
    6b3a:	09 f4       	brne	.+2      	; 0x6b3e <prvProcessReceivedCommands+0x78>
    6b3c:	68 c0       	rjmp	.+208    	; 0x6c0e <prvProcessReceivedCommands+0x148>
    6b3e:	2b 85       	ldd	r18, Y+11	; 0x0b
    6b40:	3c 85       	ldd	r19, Y+12	; 0x0c
    6b42:	24 30       	cpi	r18, 0x04	; 4
    6b44:	31 05       	cpc	r19, r1
    6b46:	0c f0       	brlt	.+2      	; 0x6b4a <prvProcessReceivedCommands+0x84>
    6b48:	6a c0       	rjmp	.+212    	; 0x6c1e <prvProcessReceivedCommands+0x158>
    6b4a:	8b 85       	ldd	r24, Y+11	; 0x0b
    6b4c:	9c 85       	ldd	r25, Y+12	; 0x0c
    6b4e:	81 30       	cpi	r24, 0x01	; 1
    6b50:	91 05       	cpc	r25, r1
    6b52:	0c f4       	brge	.+2      	; 0x6b56 <prvProcessReceivedCommands+0x90>
    6b54:	9b c0       	rjmp	.+310    	; 0x6c8c <prvProcessReceivedCommands+0x1c6>
    6b56:	12 c0       	rjmp	.+36     	; 0x6b7c <prvProcessReceivedCommands+0xb6>
    6b58:	2b 85       	ldd	r18, Y+11	; 0x0b
    6b5a:	3c 85       	ldd	r19, Y+12	; 0x0c
    6b5c:	28 30       	cpi	r18, 0x08	; 8
    6b5e:	31 05       	cpc	r19, r1
    6b60:	09 f4       	brne	.+2      	; 0x6b64 <prvProcessReceivedCommands+0x9e>
    6b62:	55 c0       	rjmp	.+170    	; 0x6c0e <prvProcessReceivedCommands+0x148>
    6b64:	8b 85       	ldd	r24, Y+11	; 0x0b
    6b66:	9c 85       	ldd	r25, Y+12	; 0x0c
    6b68:	88 30       	cpi	r24, 0x08	; 8
    6b6a:	91 05       	cpc	r25, r1
    6b6c:	3c f0       	brlt	.+14     	; 0x6b7c <prvProcessReceivedCommands+0xb6>
    6b6e:	2b 85       	ldd	r18, Y+11	; 0x0b
    6b70:	3c 85       	ldd	r19, Y+12	; 0x0c
    6b72:	29 30       	cpi	r18, 0x09	; 9
    6b74:	31 05       	cpc	r19, r1
    6b76:	09 f4       	brne	.+2      	; 0x6b7a <prvProcessReceivedCommands+0xb4>
    6b78:	52 c0       	rjmp	.+164    	; 0x6c1e <prvProcessReceivedCommands+0x158>
    6b7a:	88 c0       	rjmp	.+272    	; 0x6c8c <prvProcessReceivedCommands+0x1c6>
                    case tmrCOMMAND_START:
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    6b7c:	eb 81       	ldd	r30, Y+3	; 0x03
    6b7e:	fc 81       	ldd	r31, Y+4	; 0x04
    6b80:	83 89       	ldd	r24, Z+19	; 0x13
    6b82:	81 60       	ori	r24, 0x01	; 1
    6b84:	eb 81       	ldd	r30, Y+3	; 0x03
    6b86:	fc 81       	ldd	r31, Y+4	; 0x04
    6b88:	83 8b       	std	Z+19, r24	; 0x13

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    6b8a:	2e 81       	ldd	r18, Y+6	; 0x06
    6b8c:	3f 81       	ldd	r19, Y+7	; 0x07
    6b8e:	eb 81       	ldd	r30, Y+3	; 0x03
    6b90:	fc 81       	ldd	r31, Y+4	; 0x04
    6b92:	84 85       	ldd	r24, Z+12	; 0x0c
    6b94:	95 85       	ldd	r25, Z+13	; 0x0d
    6b96:	a9 01       	movw	r20, r18
    6b98:	48 0f       	add	r20, r24
    6b9a:	59 1f       	adc	r21, r25
    6b9c:	ee 81       	ldd	r30, Y+6	; 0x06
    6b9e:	ff 81       	ldd	r31, Y+7	; 0x07
    6ba0:	8b 81       	ldd	r24, Y+3	; 0x03
    6ba2:	9c 81       	ldd	r25, Y+4	; 0x04
    6ba4:	29 81       	ldd	r18, Y+1	; 0x01
    6ba6:	3a 81       	ldd	r19, Y+2	; 0x02
    6ba8:	ba 01       	movw	r22, r20
    6baa:	a9 01       	movw	r20, r18
    6bac:	9f 01       	movw	r18, r30
    6bae:	0e 94 fb 34 	call	0x69f6	; 0x69f6 <prvInsertTimerInActiveList>
    6bb2:	88 23       	and	r24, r24
    6bb4:	09 f4       	brne	.+2      	; 0x6bb8 <prvProcessReceivedCommands+0xf2>
    6bb6:	6a c0       	rjmp	.+212    	; 0x6c8c <prvProcessReceivedCommands+0x1c6>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    6bb8:	eb 81       	ldd	r30, Y+3	; 0x03
    6bba:	fc 81       	ldd	r31, Y+4	; 0x04
    6bbc:	83 89       	ldd	r24, Z+19	; 0x13
    6bbe:	88 2f       	mov	r24, r24
    6bc0:	90 e0       	ldi	r25, 0x00	; 0
    6bc2:	84 70       	andi	r24, 0x04	; 4
    6bc4:	90 70       	andi	r25, 0x00	; 0
    6bc6:	00 97       	sbiw	r24, 0x00	; 0
    6bc8:	91 f0       	breq	.+36     	; 0x6bee <prvProcessReceivedCommands+0x128>
                            {
                                prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow );
    6bca:	2e 81       	ldd	r18, Y+6	; 0x06
    6bcc:	3f 81       	ldd	r19, Y+7	; 0x07
    6bce:	eb 81       	ldd	r30, Y+3	; 0x03
    6bd0:	fc 81       	ldd	r31, Y+4	; 0x04
    6bd2:	84 85       	ldd	r24, Z+12	; 0x0c
    6bd4:	95 85       	ldd	r25, Z+13	; 0x0d
    6bd6:	a9 01       	movw	r20, r18
    6bd8:	48 0f       	add	r20, r24
    6bda:	59 1f       	adc	r21, r25
    6bdc:	8b 81       	ldd	r24, Y+3	; 0x03
    6bde:	9c 81       	ldd	r25, Y+4	; 0x04
    6be0:	29 81       	ldd	r18, Y+1	; 0x01
    6be2:	3a 81       	ldd	r19, Y+2	; 0x02
    6be4:	ba 01       	movw	r22, r20
    6be6:	a9 01       	movw	r20, r18
    6be8:	0e 94 a5 33 	call	0x674a	; 0x674a <prvReloadTimer>
    6bec:	07 c0       	rjmp	.+14     	; 0x6bfc <prvProcessReceivedCommands+0x136>
                            }
                            else
                            {
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    6bee:	eb 81       	ldd	r30, Y+3	; 0x03
    6bf0:	fc 81       	ldd	r31, Y+4	; 0x04
    6bf2:	83 89       	ldd	r24, Z+19	; 0x13
    6bf4:	8e 7f       	andi	r24, 0xFE	; 254
    6bf6:	eb 81       	ldd	r30, Y+3	; 0x03
    6bf8:	fc 81       	ldd	r31, Y+4	; 0x04
    6bfa:	83 8b       	std	Z+19, r24	; 0x13
                            }

                            /* Call the timer callback. */
                            traceTIMER_EXPIRED( pxTimer );
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    6bfc:	eb 81       	ldd	r30, Y+3	; 0x03
    6bfe:	fc 81       	ldd	r31, Y+4	; 0x04
    6c00:	00 88       	ldd	r0, Z+16	; 0x10
    6c02:	f1 89       	ldd	r31, Z+17	; 0x11
    6c04:	e0 2d       	mov	r30, r0
    6c06:	8b 81       	ldd	r24, Y+3	; 0x03
    6c08:	9c 81       	ldd	r25, Y+4	; 0x04
    6c0a:	09 95       	icall
    6c0c:	3f c0       	rjmp	.+126    	; 0x6c8c <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    6c0e:	eb 81       	ldd	r30, Y+3	; 0x03
    6c10:	fc 81       	ldd	r31, Y+4	; 0x04
    6c12:	83 89       	ldd	r24, Z+19	; 0x13
    6c14:	8e 7f       	andi	r24, 0xFE	; 254
    6c16:	eb 81       	ldd	r30, Y+3	; 0x03
    6c18:	fc 81       	ldd	r31, Y+4	; 0x04
    6c1a:	83 8b       	std	Z+19, r24	; 0x13
    6c1c:	37 c0       	rjmp	.+110    	; 0x6c8c <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    6c1e:	eb 81       	ldd	r30, Y+3	; 0x03
    6c20:	fc 81       	ldd	r31, Y+4	; 0x04
    6c22:	83 89       	ldd	r24, Z+19	; 0x13
    6c24:	81 60       	ori	r24, 0x01	; 1
    6c26:	eb 81       	ldd	r30, Y+3	; 0x03
    6c28:	fc 81       	ldd	r31, Y+4	; 0x04
    6c2a:	83 8b       	std	Z+19, r24	; 0x13
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    6c2c:	8e 81       	ldd	r24, Y+6	; 0x06
    6c2e:	9f 81       	ldd	r25, Y+7	; 0x07
    6c30:	eb 81       	ldd	r30, Y+3	; 0x03
    6c32:	fc 81       	ldd	r31, Y+4	; 0x04
    6c34:	95 87       	std	Z+13, r25	; 0x0d
    6c36:	84 87       	std	Z+12, r24	; 0x0c
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    6c38:	eb 81       	ldd	r30, Y+3	; 0x03
    6c3a:	fc 81       	ldd	r31, Y+4	; 0x04
    6c3c:	24 85       	ldd	r18, Z+12	; 0x0c
    6c3e:	35 85       	ldd	r19, Z+13	; 0x0d
    6c40:	89 81       	ldd	r24, Y+1	; 0x01
    6c42:	9a 81       	ldd	r25, Y+2	; 0x02
    6c44:	a9 01       	movw	r20, r18
    6c46:	48 0f       	add	r20, r24
    6c48:	59 1f       	adc	r21, r25
    6c4a:	8b 81       	ldd	r24, Y+3	; 0x03
    6c4c:	9c 81       	ldd	r25, Y+4	; 0x04
    6c4e:	29 81       	ldd	r18, Y+1	; 0x01
    6c50:	3a 81       	ldd	r19, Y+2	; 0x02
    6c52:	e9 81       	ldd	r30, Y+1	; 0x01
    6c54:	fa 81       	ldd	r31, Y+2	; 0x02
    6c56:	ba 01       	movw	r22, r20
    6c58:	a9 01       	movw	r20, r18
    6c5a:	9f 01       	movw	r18, r30
    6c5c:	0e 94 fb 34 	call	0x69f6	; 0x69f6 <prvInsertTimerInActiveList>
    6c60:	15 c0       	rjmp	.+42     	; 0x6c8c <prvProcessReceivedCommands+0x1c6>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                            {
                                /* The timer has already been removed from the active list,
                                 * just free up the memory if the memory was dynamically
                                 * allocated. */
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    6c62:	eb 81       	ldd	r30, Y+3	; 0x03
    6c64:	fc 81       	ldd	r31, Y+4	; 0x04
    6c66:	83 89       	ldd	r24, Z+19	; 0x13
    6c68:	88 2f       	mov	r24, r24
    6c6a:	90 e0       	ldi	r25, 0x00	; 0
    6c6c:	82 70       	andi	r24, 0x02	; 2
    6c6e:	90 70       	andi	r25, 0x00	; 0
    6c70:	00 97       	sbiw	r24, 0x00	; 0
    6c72:	29 f4       	brne	.+10     	; 0x6c7e <prvProcessReceivedCommands+0x1b8>
                                {
                                    vPortFree( pxTimer );
    6c74:	8b 81       	ldd	r24, Y+3	; 0x03
    6c76:	9c 81       	ldd	r25, Y+4	; 0x04
    6c78:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
    6c7c:	07 c0       	rjmp	.+14     	; 0x6c8c <prvProcessReceivedCommands+0x1c6>
                                }
                                else
                                {
                                    pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    6c7e:	eb 81       	ldd	r30, Y+3	; 0x03
    6c80:	fc 81       	ldd	r31, Y+4	; 0x04
    6c82:	83 89       	ldd	r24, Z+19	; 0x13
    6c84:	8e 7f       	andi	r24, 0xFE	; 254
    6c86:	eb 81       	ldd	r30, Y+3	; 0x03
    6c88:	fc 81       	ldd	r31, Y+4	; 0x04
    6c8a:	83 8b       	std	Z+19, r24	; 0x13
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    6c8c:	80 91 32 07 	lds	r24, 0x0732
    6c90:	90 91 33 07 	lds	r25, 0x0733
    6c94:	9e 01       	movw	r18, r28
    6c96:	2b 5f       	subi	r18, 0xFB	; 251
    6c98:	3f 4f       	sbci	r19, 0xFF	; 255
    6c9a:	b9 01       	movw	r22, r18
    6c9c:	40 e0       	ldi	r20, 0x00	; 0
    6c9e:	50 e0       	ldi	r21, 0x00	; 0
    6ca0:	0e 94 99 11 	call	0x2332	; 0x2332 <xQueueReceive>
    6ca4:	88 23       	and	r24, r24
    6ca6:	09 f0       	breq	.+2      	; 0x6caa <prvProcessReceivedCommands+0x1e4>
    6ca8:	19 cf       	rjmp	.-462    	; 0x6adc <prvProcessReceivedCommands+0x16>
                        /* Don't expect to get here. */
                        break;
                }
            }
        }
    }
    6caa:	2c 96       	adiw	r28, 0x0c	; 12
    6cac:	0f b6       	in	r0, 0x3f	; 63
    6cae:	f8 94       	cli
    6cb0:	de bf       	out	0x3e, r29	; 62
    6cb2:	0f be       	out	0x3f, r0	; 63
    6cb4:	cd bf       	out	0x3d, r28	; 61
    6cb6:	cf 91       	pop	r28
    6cb8:	df 91       	pop	r29
    6cba:	08 95       	ret

00006cbc <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
    6cbc:	df 93       	push	r29
    6cbe:	cf 93       	push	r28
    6cc0:	00 d0       	rcall	.+0      	; 0x6cc2 <prvSwitchTimerLists+0x6>
    6cc2:	00 d0       	rcall	.+0      	; 0x6cc4 <prvSwitchTimerLists+0x8>
    6cc4:	cd b7       	in	r28, 0x3d	; 61
    6cc6:	de b7       	in	r29, 0x3e	; 62
    6cc8:	11 c0       	rjmp	.+34     	; 0x6cec <prvSwitchTimerLists+0x30>
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    6cca:	e0 91 4a 07 	lds	r30, 0x074A
    6cce:	f0 91 4b 07 	lds	r31, 0x074B
    6cd2:	05 80       	ldd	r0, Z+5	; 0x05
    6cd4:	f6 81       	ldd	r31, Z+6	; 0x06
    6cd6:	e0 2d       	mov	r30, r0
    6cd8:	80 81       	ld	r24, Z
    6cda:	91 81       	ldd	r25, Z+1	; 0x01
    6cdc:	9c 83       	std	Y+4, r25	; 0x04
    6cde:	8b 83       	std	Y+3, r24	; 0x03

            /* Process the expired timer.  For auto-reload timers, be careful to
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
    6ce0:	8b 81       	ldd	r24, Y+3	; 0x03
    6ce2:	9c 81       	ldd	r25, Y+4	; 0x04
    6ce4:	6f ef       	ldi	r22, 0xFF	; 255
    6ce6:	7f ef       	ldi	r23, 0xFF	; 255
    6ce8:	0e 94 e4 33 	call	0x67c8	; 0x67c8 <prvProcessExpiredTimer>

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    6cec:	e0 91 4a 07 	lds	r30, 0x074A
    6cf0:	f0 91 4b 07 	lds	r31, 0x074B
    6cf4:	80 81       	ld	r24, Z
    6cf6:	88 23       	and	r24, r24
    6cf8:	41 f7       	brne	.-48     	; 0x6cca <prvSwitchTimerLists+0xe>
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
        }

        pxTemp = pxCurrentTimerList;
    6cfa:	80 91 4a 07 	lds	r24, 0x074A
    6cfe:	90 91 4b 07 	lds	r25, 0x074B
    6d02:	9a 83       	std	Y+2, r25	; 0x02
    6d04:	89 83       	std	Y+1, r24	; 0x01
        pxCurrentTimerList = pxOverflowTimerList;
    6d06:	80 91 4c 07 	lds	r24, 0x074C
    6d0a:	90 91 4d 07 	lds	r25, 0x074D
    6d0e:	90 93 4b 07 	sts	0x074B, r25
    6d12:	80 93 4a 07 	sts	0x074A, r24
        pxOverflowTimerList = pxTemp;
    6d16:	89 81       	ldd	r24, Y+1	; 0x01
    6d18:	9a 81       	ldd	r25, Y+2	; 0x02
    6d1a:	90 93 4d 07 	sts	0x074D, r25
    6d1e:	80 93 4c 07 	sts	0x074C, r24
    }
    6d22:	0f 90       	pop	r0
    6d24:	0f 90       	pop	r0
    6d26:	0f 90       	pop	r0
    6d28:	0f 90       	pop	r0
    6d2a:	cf 91       	pop	r28
    6d2c:	df 91       	pop	r29
    6d2e:	08 95       	ret

00006d30 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
    6d30:	df 93       	push	r29
    6d32:	cf 93       	push	r28
    6d34:	cd b7       	in	r28, 0x3d	; 61
    6d36:	de b7       	in	r29, 0x3e	; 62
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
    6d38:	0f b6       	in	r0, 0x3f	; 63
    6d3a:	f8 94       	cli
    6d3c:	0f 92       	push	r0
        {
            if( xTimerQueue == NULL )
    6d3e:	80 91 32 07 	lds	r24, 0x0732
    6d42:	90 91 33 07 	lds	r25, 0x0733
    6d46:	00 97       	sbiw	r24, 0x00	; 0
    6d48:	e9 f4       	brne	.+58     	; 0x6d84 <prvCheckForValidListAndQueue+0x54>
            {
                vListInitialise( &xActiveTimerList1 );
    6d4a:	88 e3       	ldi	r24, 0x38	; 56
    6d4c:	97 e0       	ldi	r25, 0x07	; 7
    6d4e:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
    6d52:	81 e4       	ldi	r24, 0x41	; 65
    6d54:	97 e0       	ldi	r25, 0x07	; 7
    6d56:	0e 94 ac 0d 	call	0x1b58	; 0x1b58 <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
    6d5a:	88 e3       	ldi	r24, 0x38	; 56
    6d5c:	97 e0       	ldi	r25, 0x07	; 7
    6d5e:	90 93 4b 07 	sts	0x074B, r25
    6d62:	80 93 4a 07 	sts	0x074A, r24
                pxOverflowTimerList = &xActiveTimerList2;
    6d66:	81 e4       	ldi	r24, 0x41	; 65
    6d68:	97 e0       	ldi	r25, 0x07	; 7
    6d6a:	90 93 4d 07 	sts	0x074D, r25
    6d6e:	80 93 4c 07 	sts	0x074C, r24

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    6d72:	8a e0       	ldi	r24, 0x0A	; 10
    6d74:	65 e0       	ldi	r22, 0x05	; 5
    6d76:	40 e0       	ldi	r20, 0x00	; 0
    6d78:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <xQueueGenericCreate>
    6d7c:	90 93 33 07 	sts	0x0733, r25
    6d80:	80 93 32 07 	sts	0x0732, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    6d84:	0f 90       	pop	r0
    6d86:	0f be       	out	0x3f, r0	; 63
    }
    6d88:	cf 91       	pop	r28
    6d8a:	df 91       	pop	r29
    6d8c:	08 95       	ret

00006d8e <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
    {
    6d8e:	df 93       	push	r29
    6d90:	cf 93       	push	r28
    6d92:	00 d0       	rcall	.+0      	; 0x6d94 <xTimerIsTimerActive+0x6>
    6d94:	00 d0       	rcall	.+0      	; 0x6d96 <xTimerIsTimerActive+0x8>
    6d96:	0f 92       	push	r0
    6d98:	cd b7       	in	r28, 0x3d	; 61
    6d9a:	de b7       	in	r29, 0x3e	; 62
    6d9c:	9d 83       	std	Y+5, r25	; 0x05
    6d9e:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;
        Timer_t * pxTimer = xTimer;
    6da0:	8c 81       	ldd	r24, Y+4	; 0x04
    6da2:	9d 81       	ldd	r25, Y+5	; 0x05
    6da4:	9a 83       	std	Y+2, r25	; 0x02
    6da6:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        /* Is the timer in the list of active timers? */
        taskENTER_CRITICAL();
    6da8:	0f b6       	in	r0, 0x3f	; 63
    6daa:	f8 94       	cli
    6dac:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
    6dae:	e9 81       	ldd	r30, Y+1	; 0x01
    6db0:	fa 81       	ldd	r31, Y+2	; 0x02
    6db2:	83 89       	ldd	r24, Z+19	; 0x13
    6db4:	88 2f       	mov	r24, r24
    6db6:	90 e0       	ldi	r25, 0x00	; 0
    6db8:	81 70       	andi	r24, 0x01	; 1
    6dba:	90 70       	andi	r25, 0x00	; 0
    6dbc:	00 97       	sbiw	r24, 0x00	; 0
    6dbe:	11 f4       	brne	.+4      	; 0x6dc4 <xTimerIsTimerActive+0x36>
            {
                xReturn = pdFALSE;
    6dc0:	1b 82       	std	Y+3, r1	; 0x03
    6dc2:	02 c0       	rjmp	.+4      	; 0x6dc8 <xTimerIsTimerActive+0x3a>
            }
            else
            {
                xReturn = pdTRUE;
    6dc4:	81 e0       	ldi	r24, 0x01	; 1
    6dc6:	8b 83       	std	Y+3, r24	; 0x03
            }
        }
        taskEXIT_CRITICAL();
    6dc8:	0f 90       	pop	r0
    6dca:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    6dcc:	8b 81       	ldd	r24, Y+3	; 0x03
    } /*lint !e818 Can't be pointer to const due to the typedef. */
    6dce:	0f 90       	pop	r0
    6dd0:	0f 90       	pop	r0
    6dd2:	0f 90       	pop	r0
    6dd4:	0f 90       	pop	r0
    6dd6:	0f 90       	pop	r0
    6dd8:	cf 91       	pop	r28
    6dda:	df 91       	pop	r29
    6ddc:	08 95       	ret

00006dde <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

    void * pvTimerGetTimerID( const TimerHandle_t xTimer )
    {
    6dde:	df 93       	push	r29
    6de0:	cf 93       	push	r28
    6de2:	00 d0       	rcall	.+0      	; 0x6de4 <pvTimerGetTimerID+0x6>
    6de4:	00 d0       	rcall	.+0      	; 0x6de6 <pvTimerGetTimerID+0x8>
    6de6:	00 d0       	rcall	.+0      	; 0x6de8 <pvTimerGetTimerID+0xa>
    6de8:	cd b7       	in	r28, 0x3d	; 61
    6dea:	de b7       	in	r29, 0x3e	; 62
    6dec:	9e 83       	std	Y+6, r25	; 0x06
    6dee:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * const pxTimer = xTimer;
    6df0:	8d 81       	ldd	r24, Y+5	; 0x05
    6df2:	9e 81       	ldd	r25, Y+6	; 0x06
    6df4:	9c 83       	std	Y+4, r25	; 0x04
    6df6:	8b 83       	std	Y+3, r24	; 0x03
        void * pvReturn;

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    6df8:	0f b6       	in	r0, 0x3f	; 63
    6dfa:	f8 94       	cli
    6dfc:	0f 92       	push	r0
        {
            pvReturn = pxTimer->pvTimerID;
    6dfe:	eb 81       	ldd	r30, Y+3	; 0x03
    6e00:	fc 81       	ldd	r31, Y+4	; 0x04
    6e02:	86 85       	ldd	r24, Z+14	; 0x0e
    6e04:	97 85       	ldd	r25, Z+15	; 0x0f
    6e06:	9a 83       	std	Y+2, r25	; 0x02
    6e08:	89 83       	std	Y+1, r24	; 0x01
        }
        taskEXIT_CRITICAL();
    6e0a:	0f 90       	pop	r0
    6e0c:	0f be       	out	0x3f, r0	; 63

        return pvReturn;
    6e0e:	89 81       	ldd	r24, Y+1	; 0x01
    6e10:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    6e12:	26 96       	adiw	r28, 0x06	; 6
    6e14:	0f b6       	in	r0, 0x3f	; 63
    6e16:	f8 94       	cli
    6e18:	de bf       	out	0x3e, r29	; 62
    6e1a:	0f be       	out	0x3f, r0	; 63
    6e1c:	cd bf       	out	0x3d, r28	; 61
    6e1e:	cf 91       	pop	r28
    6e20:	df 91       	pop	r29
    6e22:	08 95       	ret

00006e24 <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

    void vTimerSetTimerID( TimerHandle_t xTimer,
                           void * pvNewID )
    {
    6e24:	df 93       	push	r29
    6e26:	cf 93       	push	r28
    6e28:	00 d0       	rcall	.+0      	; 0x6e2a <vTimerSetTimerID+0x6>
    6e2a:	00 d0       	rcall	.+0      	; 0x6e2c <vTimerSetTimerID+0x8>
    6e2c:	00 d0       	rcall	.+0      	; 0x6e2e <vTimerSetTimerID+0xa>
    6e2e:	cd b7       	in	r28, 0x3d	; 61
    6e30:	de b7       	in	r29, 0x3e	; 62
    6e32:	9c 83       	std	Y+4, r25	; 0x04
    6e34:	8b 83       	std	Y+3, r24	; 0x03
    6e36:	7e 83       	std	Y+6, r23	; 0x06
    6e38:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = xTimer;
    6e3a:	8b 81       	ldd	r24, Y+3	; 0x03
    6e3c:	9c 81       	ldd	r25, Y+4	; 0x04
    6e3e:	9a 83       	std	Y+2, r25	; 0x02
    6e40:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    6e42:	0f b6       	in	r0, 0x3f	; 63
    6e44:	f8 94       	cli
    6e46:	0f 92       	push	r0
        {
            pxTimer->pvTimerID = pvNewID;
    6e48:	e9 81       	ldd	r30, Y+1	; 0x01
    6e4a:	fa 81       	ldd	r31, Y+2	; 0x02
    6e4c:	8d 81       	ldd	r24, Y+5	; 0x05
    6e4e:	9e 81       	ldd	r25, Y+6	; 0x06
    6e50:	97 87       	std	Z+15, r25	; 0x0f
    6e52:	86 87       	std	Z+14, r24	; 0x0e
        }
        taskEXIT_CRITICAL();
    6e54:	0f 90       	pop	r0
    6e56:	0f be       	out	0x3f, r0	; 63
    }
    6e58:	26 96       	adiw	r28, 0x06	; 6
    6e5a:	0f b6       	in	r0, 0x3f	; 63
    6e5c:	f8 94       	cli
    6e5e:	de bf       	out	0x3e, r29	; 62
    6e60:	0f be       	out	0x3f, r0	; 63
    6e62:	cd bf       	out	0x3d, r28	; 61
    6e64:	cf 91       	pop	r28
    6e66:	df 91       	pop	r29
    6e68:	08 95       	ret

00006e6a <uxTimerGetTimerNumber>:
/*-----------------------------------------------------------*/

    #if ( configUSE_TRACE_FACILITY == 1 )

        UBaseType_t uxTimerGetTimerNumber( TimerHandle_t xTimer )
        {
    6e6a:	df 93       	push	r29
    6e6c:	cf 93       	push	r28
    6e6e:	00 d0       	rcall	.+0      	; 0x6e70 <uxTimerGetTimerNumber+0x6>
    6e70:	cd b7       	in	r28, 0x3d	; 61
    6e72:	de b7       	in	r29, 0x3e	; 62
    6e74:	9a 83       	std	Y+2, r25	; 0x02
    6e76:	89 83       	std	Y+1, r24	; 0x01
            return ( ( Timer_t * ) xTimer )->uxTimerNumber;
    6e78:	e9 81       	ldd	r30, Y+1	; 0x01
    6e7a:	fa 81       	ldd	r31, Y+2	; 0x02
    6e7c:	82 89       	ldd	r24, Z+18	; 0x12
        }
    6e7e:	0f 90       	pop	r0
    6e80:	0f 90       	pop	r0
    6e82:	cf 91       	pop	r28
    6e84:	df 91       	pop	r29
    6e86:	08 95       	ret

00006e88 <vTimerSetTimerNumber>:

    #if ( configUSE_TRACE_FACILITY == 1 )

        void vTimerSetTimerNumber( TimerHandle_t xTimer,
                                   UBaseType_t uxTimerNumber )
        {
    6e88:	df 93       	push	r29
    6e8a:	cf 93       	push	r28
    6e8c:	00 d0       	rcall	.+0      	; 0x6e8e <vTimerSetTimerNumber+0x6>
    6e8e:	0f 92       	push	r0
    6e90:	cd b7       	in	r28, 0x3d	; 61
    6e92:	de b7       	in	r29, 0x3e	; 62
    6e94:	9a 83       	std	Y+2, r25	; 0x02
    6e96:	89 83       	std	Y+1, r24	; 0x01
    6e98:	6b 83       	std	Y+3, r22	; 0x03
            ( ( Timer_t * ) xTimer )->uxTimerNumber = uxTimerNumber;
    6e9a:	e9 81       	ldd	r30, Y+1	; 0x01
    6e9c:	fa 81       	ldd	r31, Y+2	; 0x02
    6e9e:	8b 81       	ldd	r24, Y+3	; 0x03
    6ea0:	82 8b       	std	Z+18, r24	; 0x12
        }
    6ea2:	0f 90       	pop	r0
    6ea4:	0f 90       	pop	r0
    6ea6:	0f 90       	pop	r0
    6ea8:	cf 91       	pop	r28
    6eaa:	df 91       	pop	r29
    6eac:	08 95       	ret

00006eae <UART_init>:
#include "LED.h"
#define F_CPU 8000000UL
#define BAUD_PRESCALE (((F_CPU / (USART_BAUDRATE * 16UL))) - 1)

void UART_init(long USART_BAUDRATE)
{
    6eae:	0f 93       	push	r16
    6eb0:	1f 93       	push	r17
    6eb2:	df 93       	push	r29
    6eb4:	cf 93       	push	r28
    6eb6:	00 d0       	rcall	.+0      	; 0x6eb8 <UART_init+0xa>
    6eb8:	00 d0       	rcall	.+0      	; 0x6eba <UART_init+0xc>
    6eba:	cd b7       	in	r28, 0x3d	; 61
    6ebc:	de b7       	in	r29, 0x3e	; 62
    6ebe:	69 83       	std	Y+1, r22	; 0x01
    6ec0:	7a 83       	std	Y+2, r23	; 0x02
    6ec2:	8b 83       	std	Y+3, r24	; 0x03
    6ec4:	9c 83       	std	Y+4, r25	; 0x04
	UCSRB |= (1 << RXEN) | (1 << TXEN);/* Turn on transmission and reception */
    6ec6:	aa e2       	ldi	r26, 0x2A	; 42
    6ec8:	b0 e0       	ldi	r27, 0x00	; 0
    6eca:	ea e2       	ldi	r30, 0x2A	; 42
    6ecc:	f0 e0       	ldi	r31, 0x00	; 0
    6ece:	80 81       	ld	r24, Z
    6ed0:	88 61       	ori	r24, 0x18	; 24
    6ed2:	8c 93       	st	X, r24
	UCSRC |= (1 << URSEL) | (1 << UCSZ0) | (1 << UCSZ1);/* Use 8-bit character sizes */
    6ed4:	a0 e4       	ldi	r26, 0x40	; 64
    6ed6:	b0 e0       	ldi	r27, 0x00	; 0
    6ed8:	e0 e4       	ldi	r30, 0x40	; 64
    6eda:	f0 e0       	ldi	r31, 0x00	; 0
    6edc:	80 81       	ld	r24, Z
    6ede:	86 68       	ori	r24, 0x86	; 134
    6ee0:	8c 93       	st	X, r24
	UBRRL = BAUD_PRESCALE;		/* Load lower 8-bits of the baud rate value */
    6ee2:	09 e2       	ldi	r16, 0x29	; 41
    6ee4:	10 e0       	ldi	r17, 0x00	; 0
    6ee6:	89 81       	ldd	r24, Y+1	; 0x01
    6ee8:	9a 81       	ldd	r25, Y+2	; 0x02
    6eea:	ab 81       	ldd	r26, Y+3	; 0x03
    6eec:	bc 81       	ldd	r27, Y+4	; 0x04
    6eee:	88 0f       	add	r24, r24
    6ef0:	99 1f       	adc	r25, r25
    6ef2:	aa 1f       	adc	r26, r26
    6ef4:	bb 1f       	adc	r27, r27
    6ef6:	88 0f       	add	r24, r24
    6ef8:	99 1f       	adc	r25, r25
    6efa:	aa 1f       	adc	r26, r26
    6efc:	bb 1f       	adc	r27, r27
    6efe:	88 0f       	add	r24, r24
    6f00:	99 1f       	adc	r25, r25
    6f02:	aa 1f       	adc	r26, r26
    6f04:	bb 1f       	adc	r27, r27
    6f06:	88 0f       	add	r24, r24
    6f08:	99 1f       	adc	r25, r25
    6f0a:	aa 1f       	adc	r26, r26
    6f0c:	bb 1f       	adc	r27, r27
    6f0e:	9c 01       	movw	r18, r24
    6f10:	ad 01       	movw	r20, r26
    6f12:	80 e0       	ldi	r24, 0x00	; 0
    6f14:	92 e1       	ldi	r25, 0x12	; 18
    6f16:	aa e7       	ldi	r26, 0x7A	; 122
    6f18:	b0 e0       	ldi	r27, 0x00	; 0
    6f1a:	bc 01       	movw	r22, r24
    6f1c:	cd 01       	movw	r24, r26
    6f1e:	0e 94 86 39 	call	0x730c	; 0x730c <__udivmodsi4>
    6f22:	da 01       	movw	r26, r20
    6f24:	c9 01       	movw	r24, r18
    6f26:	81 50       	subi	r24, 0x01	; 1
    6f28:	f8 01       	movw	r30, r16
    6f2a:	80 83       	st	Z, r24
	UBRRH = (BAUD_PRESCALE >> 8);	/* Load upper 8-bits*/
    6f2c:	00 e4       	ldi	r16, 0x40	; 64
    6f2e:	10 e0       	ldi	r17, 0x00	; 0
    6f30:	89 81       	ldd	r24, Y+1	; 0x01
    6f32:	9a 81       	ldd	r25, Y+2	; 0x02
    6f34:	ab 81       	ldd	r26, Y+3	; 0x03
    6f36:	bc 81       	ldd	r27, Y+4	; 0x04
    6f38:	88 0f       	add	r24, r24
    6f3a:	99 1f       	adc	r25, r25
    6f3c:	aa 1f       	adc	r26, r26
    6f3e:	bb 1f       	adc	r27, r27
    6f40:	88 0f       	add	r24, r24
    6f42:	99 1f       	adc	r25, r25
    6f44:	aa 1f       	adc	r26, r26
    6f46:	bb 1f       	adc	r27, r27
    6f48:	88 0f       	add	r24, r24
    6f4a:	99 1f       	adc	r25, r25
    6f4c:	aa 1f       	adc	r26, r26
    6f4e:	bb 1f       	adc	r27, r27
    6f50:	88 0f       	add	r24, r24
    6f52:	99 1f       	adc	r25, r25
    6f54:	aa 1f       	adc	r26, r26
    6f56:	bb 1f       	adc	r27, r27
    6f58:	9c 01       	movw	r18, r24
    6f5a:	ad 01       	movw	r20, r26
    6f5c:	80 e0       	ldi	r24, 0x00	; 0
    6f5e:	92 e1       	ldi	r25, 0x12	; 18
    6f60:	aa e7       	ldi	r26, 0x7A	; 122
    6f62:	b0 e0       	ldi	r27, 0x00	; 0
    6f64:	bc 01       	movw	r22, r24
    6f66:	cd 01       	movw	r24, r26
    6f68:	0e 94 86 39 	call	0x730c	; 0x730c <__udivmodsi4>
    6f6c:	da 01       	movw	r26, r20
    6f6e:	c9 01       	movw	r24, r18
    6f70:	01 97       	sbiw	r24, 0x01	; 1
    6f72:	a1 09       	sbc	r26, r1
    6f74:	b1 09       	sbc	r27, r1
    6f76:	89 2f       	mov	r24, r25
    6f78:	9a 2f       	mov	r25, r26
    6f7a:	ab 2f       	mov	r26, r27
    6f7c:	bb 27       	eor	r27, r27
    6f7e:	f8 01       	movw	r30, r16
    6f80:	80 83       	st	Z, r24
}
    6f82:	0f 90       	pop	r0
    6f84:	0f 90       	pop	r0
    6f86:	0f 90       	pop	r0
    6f88:	0f 90       	pop	r0
    6f8a:	cf 91       	pop	r28
    6f8c:	df 91       	pop	r29
    6f8e:	1f 91       	pop	r17
    6f90:	0f 91       	pop	r16
    6f92:	08 95       	ret

00006f94 <UART_RxChar>:
unsigned char UART_RxChar()
{
    6f94:	df 93       	push	r29
    6f96:	cf 93       	push	r28
    6f98:	cd b7       	in	r28, 0x3d	; 61
    6f9a:	de b7       	in	r29, 0x3e	; 62
	while ((UCSRA & (1 << RXC)) == 0);/* Wait till data is received */
    6f9c:	eb e2       	ldi	r30, 0x2B	; 43
    6f9e:	f0 e0       	ldi	r31, 0x00	; 0
    6fa0:	80 81       	ld	r24, Z
    6fa2:	88 23       	and	r24, r24
    6fa4:	dc f7       	brge	.-10     	; 0x6f9c <UART_RxChar+0x8>
	return(UDR);			/* Return the byte*/
    6fa6:	ec e2       	ldi	r30, 0x2C	; 44
    6fa8:	f0 e0       	ldi	r31, 0x00	; 0
    6faa:	80 81       	ld	r24, Z
}
    6fac:	cf 91       	pop	r28
    6fae:	df 91       	pop	r29
    6fb0:	08 95       	ret

00006fb2 <UART_TxChar>:

void UART_TxChar(char ch)
{
    6fb2:	df 93       	push	r29
    6fb4:	cf 93       	push	r28
    6fb6:	0f 92       	push	r0
    6fb8:	cd b7       	in	r28, 0x3d	; 61
    6fba:	de b7       	in	r29, 0x3e	; 62
    6fbc:	89 83       	std	Y+1, r24	; 0x01
	while (! (UCSRA & (1<<UDRE)));	/* Wait for empty transmit buffer*/
    6fbe:	eb e2       	ldi	r30, 0x2B	; 43
    6fc0:	f0 e0       	ldi	r31, 0x00	; 0
    6fc2:	80 81       	ld	r24, Z
    6fc4:	88 2f       	mov	r24, r24
    6fc6:	90 e0       	ldi	r25, 0x00	; 0
    6fc8:	80 72       	andi	r24, 0x20	; 32
    6fca:	90 70       	andi	r25, 0x00	; 0
    6fcc:	00 97       	sbiw	r24, 0x00	; 0
    6fce:	b9 f3       	breq	.-18     	; 0x6fbe <UART_TxChar+0xc>
	UDR = ch ;
    6fd0:	ec e2       	ldi	r30, 0x2C	; 44
    6fd2:	f0 e0       	ldi	r31, 0x00	; 0
    6fd4:	89 81       	ldd	r24, Y+1	; 0x01
    6fd6:	80 83       	st	Z, r24
}
    6fd8:	0f 90       	pop	r0
    6fda:	cf 91       	pop	r28
    6fdc:	df 91       	pop	r29
    6fde:	08 95       	ret

00006fe0 <UART_SendString>:

void UART_SendString(char *str)
{
    6fe0:	df 93       	push	r29
    6fe2:	cf 93       	push	r28
    6fe4:	00 d0       	rcall	.+0      	; 0x6fe6 <UART_SendString+0x6>
    6fe6:	0f 92       	push	r0
    6fe8:	cd b7       	in	r28, 0x3d	; 61
    6fea:	de b7       	in	r29, 0x3e	; 62
    6fec:	9b 83       	std	Y+3, r25	; 0x03
    6fee:	8a 83       	std	Y+2, r24	; 0x02
	unsigned char j=0;
    6ff0:	19 82       	std	Y+1, r1	; 0x01
    6ff2:	0e c0       	rjmp	.+28     	; 0x7010 <UART_SendString+0x30>

	while (str[j]!=0)		/* Send string till null */
	{
		UART_TxChar(str[j]);
    6ff4:	89 81       	ldd	r24, Y+1	; 0x01
    6ff6:	28 2f       	mov	r18, r24
    6ff8:	30 e0       	ldi	r19, 0x00	; 0
    6ffa:	8a 81       	ldd	r24, Y+2	; 0x02
    6ffc:	9b 81       	ldd	r25, Y+3	; 0x03
    6ffe:	fc 01       	movw	r30, r24
    7000:	e2 0f       	add	r30, r18
    7002:	f3 1f       	adc	r31, r19
    7004:	80 81       	ld	r24, Z
    7006:	0e 94 d9 37 	call	0x6fb2	; 0x6fb2 <UART_TxChar>
		j++;
    700a:	89 81       	ldd	r24, Y+1	; 0x01
    700c:	8f 5f       	subi	r24, 0xFF	; 255
    700e:	89 83       	std	Y+1, r24	; 0x01

void UART_SendString(char *str)
{
	unsigned char j=0;

	while (str[j]!=0)		/* Send string till null */
    7010:	89 81       	ldd	r24, Y+1	; 0x01
    7012:	28 2f       	mov	r18, r24
    7014:	30 e0       	ldi	r19, 0x00	; 0
    7016:	8a 81       	ldd	r24, Y+2	; 0x02
    7018:	9b 81       	ldd	r25, Y+3	; 0x03
    701a:	fc 01       	movw	r30, r24
    701c:	e2 0f       	add	r30, r18
    701e:	f3 1f       	adc	r31, r19
    7020:	80 81       	ld	r24, Z
    7022:	88 23       	and	r24, r24
    7024:	39 f7       	brne	.-50     	; 0x6ff4 <UART_SendString+0x14>
	{
		UART_TxChar(str[j]);
		j++;
	}
}
    7026:	0f 90       	pop	r0
    7028:	0f 90       	pop	r0
    702a:	0f 90       	pop	r0
    702c:	cf 91       	pop	r28
    702e:	df 91       	pop	r29
    7030:	08 95       	ret

00007032 <main>:
void toggle_led_mode(void);
void config_tim_1();
TaskHandle_t task2ptr;

int main(void)
{
    7032:	ef 92       	push	r14
    7034:	ff 92       	push	r15
    7036:	0f 93       	push	r16
    7038:	1f 93       	push	r17
    703a:	df 93       	push	r29
    703c:	cf 93       	push	r28
    703e:	cd b7       	in	r28, 0x3d	; 61
    7040:	de b7       	in	r29, 0x3e	; 62


	PWM_INIT();
    7042:	0e 94 76 06 	call	0xcec	; 0xcec <PWM_INIT>
	config_tim_1();
    7046:	0e 94 54 39 	call	0x72a8	; 0x72a8 <config_tim_1>
	xButtonTimer = xTimerCreate
    704a:	ea e8       	ldi	r30, 0x8A	; 138
    704c:	f8 e3       	ldi	r31, 0x38	; 56
    704e:	84 e9       	ldi	r24, 0x94	; 148
    7050:	90 e0       	ldi	r25, 0x00	; 0
    7052:	65 e0       	ldi	r22, 0x05	; 5
    7054:	70 e0       	ldi	r23, 0x00	; 0
    7056:	41 e0       	ldi	r20, 0x01	; 1
    7058:	20 e0       	ldi	r18, 0x00	; 0
    705a:	30 e0       	ldi	r19, 0x00	; 0
    705c:	8f 01       	movw	r16, r30
    705e:	0e 94 02 32 	call	0x6404	; 0x6404 <xTimerCreate>
    7062:	90 93 4f 07 	sts	0x074F, r25
    7066:	80 93 4e 07 	sts	0x074E, r24
	                     ( void * ) 0,
	                     /* Each timer calls the same callback when
	                     it expires. */
						 get_readings
	                   );
	xLedBlinkingTimer = xTimerCreate
    706a:	e7 e7       	ldi	r30, 0x77	; 119
    706c:	f8 e3       	ldi	r31, 0x38	; 56
    706e:	81 ea       	ldi	r24, 0xA1	; 161
    7070:	90 e0       	ldi	r25, 0x00	; 0
    7072:	64 ef       	ldi	r22, 0xF4	; 244
    7074:	71 e0       	ldi	r23, 0x01	; 1
    7076:	41 e0       	ldi	r20, 0x01	; 1
    7078:	20 e0       	ldi	r18, 0x00	; 0
    707a:	30 e0       	ldi	r19, 0x00	; 0
    707c:	8f 01       	movw	r16, r30
    707e:	0e 94 02 32 	call	0x6404	; 0x6404 <xTimerCreate>
    7082:	90 93 51 07 	sts	0x0751, r25
    7086:	80 93 50 07 	sts	0x0750, r24
		                     ( void * ) 0,
		                     /* Each timer calls the same callback when
		                     it expires. */
							 toggle_led_mode
		                   );
	xTaskCreate(vState_machine,"first",configMINIMAL_STACK_SIZE,NULL,1,&task1ptr);
    708a:	81 e2       	ldi	r24, 0x21	; 33
    708c:	99 e3       	ldi	r25, 0x39	; 57
    708e:	2b ea       	ldi	r18, 0xAB	; 171
    7090:	30 e0       	ldi	r19, 0x00	; 0
    7092:	ee e6       	ldi	r30, 0x6E	; 110
    7094:	f7 e0       	ldi	r31, 0x07	; 7
    7096:	b9 01       	movw	r22, r18
    7098:	45 e5       	ldi	r20, 0x55	; 85
    709a:	50 e0       	ldi	r21, 0x00	; 0
    709c:	20 e0       	ldi	r18, 0x00	; 0
    709e:	30 e0       	ldi	r19, 0x00	; 0
    70a0:	01 e0       	ldi	r16, 0x01	; 1
    70a2:	7f 01       	movw	r14, r30
    70a4:	0e 94 6d 18 	call	0x30da	; 0x30da <xTaskCreate>
	xTimerStart(xButtonTimer, 10 );
    70a8:	00 91 4e 07 	lds	r16, 0x074E
    70ac:	10 91 4f 07 	lds	r17, 0x074F
    70b0:	0e 94 8c 1d 	call	0x3b18	; 0x3b18 <xTaskGetTickCount>
    70b4:	9c 01       	movw	r18, r24
    70b6:	c8 01       	movw	r24, r16
    70b8:	61 e0       	ldi	r22, 0x01	; 1
    70ba:	a9 01       	movw	r20, r18
    70bc:	20 e0       	ldi	r18, 0x00	; 0
    70be:	30 e0       	ldi	r19, 0x00	; 0
    70c0:	0a e0       	ldi	r16, 0x0A	; 10
    70c2:	10 e0       	ldi	r17, 0x00	; 0
    70c4:	0e 94 94 32 	call	0x6528	; 0x6528 <xTimerGenericCommand>
	xTimerStart(xLedBlinkingTimer, 10 );
    70c8:	00 91 50 07 	lds	r16, 0x0750
    70cc:	10 91 51 07 	lds	r17, 0x0751
    70d0:	0e 94 8c 1d 	call	0x3b18	; 0x3b18 <xTaskGetTickCount>
    70d4:	9c 01       	movw	r18, r24
    70d6:	c8 01       	movw	r24, r16
    70d8:	61 e0       	ldi	r22, 0x01	; 1
    70da:	a9 01       	movw	r20, r18
    70dc:	20 e0       	ldi	r18, 0x00	; 0
    70de:	30 e0       	ldi	r19, 0x00	; 0
    70e0:	0a e0       	ldi	r16, 0x0A	; 10
    70e2:	10 e0       	ldi	r17, 0x00	; 0
    70e4:	0e 94 94 32 	call	0x6528	; 0x6528 <xTimerGenericCommand>
	vTaskStartScheduler();
    70e8:	0e 94 e9 1b 	call	0x37d2	; 0x37d2 <vTaskStartScheduler>
    70ec:	ff cf       	rjmp	.-2      	; 0x70ec <main+0xba>

000070ee <toggle_led_mode>:


	}
}

void toggle_led_mode(void){
    70ee:	df 93       	push	r29
    70f0:	cf 93       	push	r28
    70f2:	0f 92       	push	r0
    70f4:	cd b7       	in	r28, 0x3d	; 61
    70f6:	de b7       	in	r29, 0x3e	; 62
		led_mode = !led_mode;
    70f8:	80 91 52 07 	lds	r24, 0x0752
    70fc:	19 82       	std	Y+1, r1	; 0x01
    70fe:	88 23       	and	r24, r24
    7100:	11 f4       	brne	.+4      	; 0x7106 <toggle_led_mode+0x18>
    7102:	81 e0       	ldi	r24, 0x01	; 1
    7104:	89 83       	std	Y+1, r24	; 0x01
    7106:	89 81       	ldd	r24, Y+1	; 0x01
    7108:	80 93 52 07 	sts	0x0752, r24
}
    710c:	0f 90       	pop	r0
    710e:	cf 91       	pop	r28
    7110:	df 91       	pop	r29
    7112:	08 95       	ret

00007114 <get_readings>:
void get_readings(void)
{
    7114:	df 93       	push	r29
    7116:	cf 93       	push	r28
    7118:	00 d0       	rcall	.+0      	; 0x711a <get_readings+0x6>
    711a:	0f 92       	push	r0
    711c:	cd b7       	in	r28, 0x3d	; 61
    711e:	de b7       	in	r29, 0x3e	; 62

		ignition_button = READ_IGNITON();
    7120:	0e 94 cf 06 	call	0xd9e	; 0xd9e <READ_IGNITON>
    7124:	80 93 55 07 	sts	0x0755, r24
		uint8_t hazard_data = READ_HAZARD_Button();
    7128:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <READ_HAZARD_Button>
    712c:	8b 83       	std	Y+3, r24	; 0x03
		uint8_t right_data = READ_RIGHT_Button();
    712e:	0e 94 f7 06 	call	0xdee	; 0xdee <READ_RIGHT_Button>
    7132:	8a 83       	std	Y+2, r24	; 0x02
		uint8_t left_data = READ_LEFT_Button();
    7134:	0e 94 0b 07 	call	0xe16	; 0xe16 <READ_LEFT_Button>
    7138:	89 83       	std	Y+1, r24	; 0x01
		if(!ignition_button){
    713a:	80 91 55 07 	lds	r24, 0x0755
    713e:	88 23       	and	r24, r24
    7140:	09 f0       	breq	.+2      	; 0x7144 <get_readings+0x30>
    7142:	75 c0       	rjmp	.+234    	; 0x722e <get_readings+0x11a>
			if(hazard_data){
    7144:	8b 81       	ldd	r24, Y+3	; 0x03
    7146:	88 23       	and	r24, r24
    7148:	41 f0       	breq	.+16     	; 0x715a <get_readings+0x46>
				/*hazard btton pressed state*/
					Hazzred_button = 1;
    714a:	81 e0       	ldi	r24, 0x01	; 1
    714c:	80 93 70 07 	sts	0x0770, r24
					L_button = 0;
    7150:	10 92 6d 07 	sts	0x076D, r1
					R_button = 0;
    7154:	10 92 56 07 	sts	0x0756, r1
    7158:	6e c0       	rjmp	.+220    	; 0x7236 <get_readings+0x122>
			}
			else if(right_data){
    715a:	8a 81       	ldd	r24, Y+2	; 0x02
    715c:	88 23       	and	r24, r24
    715e:	39 f1       	breq	.+78     	; 0x71ae <get_readings+0x9a>
				/*Right button pressed state*/
				right_button_pressed_counter++;
    7160:	80 91 73 07 	lds	r24, 0x0773
    7164:	90 91 74 07 	lds	r25, 0x0774
    7168:	01 96       	adiw	r24, 0x01	; 1
    716a:	90 93 74 07 	sts	0x0774, r25
    716e:	80 93 73 07 	sts	0x0773, r24
				hazzred_button_pressed_counter=0;
    7172:	10 92 54 07 	sts	0x0754, r1
    7176:	10 92 53 07 	sts	0x0753, r1
				left_button_pressed_counter=0;
    717a:	10 92 72 07 	sts	0x0772, r1
    717e:	10 92 71 07 	sts	0x0771, r1
				if(!(right_button_pressed_counter%10)){
    7182:	80 91 73 07 	lds	r24, 0x0773
    7186:	90 91 74 07 	lds	r25, 0x0774
    718a:	2a e0       	ldi	r18, 0x0A	; 10
    718c:	30 e0       	ldi	r19, 0x00	; 0
    718e:	b9 01       	movw	r22, r18
    7190:	0e 94 73 39 	call	0x72e6	; 0x72e6 <__divmodhi4>
    7194:	00 97       	sbiw	r24, 0x00	; 0
    7196:	09 f0       	breq	.+2      	; 0x719a <get_readings+0x86>
    7198:	4e c0       	rjmp	.+156    	; 0x7236 <get_readings+0x122>
					R_button = 1;
    719a:	81 e0       	ldi	r24, 0x01	; 1
    719c:	80 93 56 07 	sts	0x0756, r24
					Hazzred_button = 0;
    71a0:	10 92 70 07 	sts	0x0770, r1
					L_button = 0;
    71a4:	10 92 6d 07 	sts	0x076D, r1
					Stop_Blinking_Left();
    71a8:	0e 94 4c 07 	call	0xe98	; 0xe98 <Stop_Blinking_Left>
    71ac:	44 c0       	rjmp	.+136    	; 0x7236 <get_readings+0x122>
				}
			}
			else if(left_data){
    71ae:	89 81       	ldd	r24, Y+1	; 0x01
    71b0:	88 23       	and	r24, r24
    71b2:	31 f1       	breq	.+76     	; 0x7200 <get_readings+0xec>
				/*Left Button pressed state*/
				left_button_pressed_counter++;
    71b4:	80 91 71 07 	lds	r24, 0x0771
    71b8:	90 91 72 07 	lds	r25, 0x0772
    71bc:	01 96       	adiw	r24, 0x01	; 1
    71be:	90 93 72 07 	sts	0x0772, r25
    71c2:	80 93 71 07 	sts	0x0771, r24
				hazzred_button_pressed_counter=0;
    71c6:	10 92 54 07 	sts	0x0754, r1
    71ca:	10 92 53 07 	sts	0x0753, r1
				right_button_pressed_counter=0;
    71ce:	10 92 74 07 	sts	0x0774, r1
    71d2:	10 92 73 07 	sts	0x0773, r1
				if(!(left_button_pressed_counter%10)){
    71d6:	80 91 71 07 	lds	r24, 0x0771
    71da:	90 91 72 07 	lds	r25, 0x0772
    71de:	2a e0       	ldi	r18, 0x0A	; 10
    71e0:	30 e0       	ldi	r19, 0x00	; 0
    71e2:	b9 01       	movw	r22, r18
    71e4:	0e 94 73 39 	call	0x72e6	; 0x72e6 <__divmodhi4>
    71e8:	00 97       	sbiw	r24, 0x00	; 0
    71ea:	29 f5       	brne	.+74     	; 0x7236 <get_readings+0x122>
					L_button = 1;
    71ec:	81 e0       	ldi	r24, 0x01	; 1
    71ee:	80 93 6d 07 	sts	0x076D, r24
					R_button = 0;
    71f2:	10 92 56 07 	sts	0x0756, r1
					Hazzred_button = 0;
    71f6:	10 92 70 07 	sts	0x0770, r1
					Stop_Blinking_Right();
    71fa:	0e 94 43 07 	call	0xe86	; 0xe86 <Stop_Blinking_Right>
    71fe:	1b c0       	rjmp	.+54     	; 0x7236 <get_readings+0x122>
				}
			}
			else{
				/*neutral state no button pressed*/
				Stop_Blinking_Right();
    7200:	0e 94 43 07 	call	0xe86	; 0xe86 <Stop_Blinking_Right>
				Stop_Blinking_Left();
    7204:	0e 94 4c 07 	call	0xe98	; 0xe98 <Stop_Blinking_Left>
				hazzred_button_pressed_counter=0;
    7208:	10 92 54 07 	sts	0x0754, r1
    720c:	10 92 53 07 	sts	0x0753, r1
				right_button_pressed_counter=0;
    7210:	10 92 74 07 	sts	0x0774, r1
    7214:	10 92 73 07 	sts	0x0773, r1
				left_button_pressed_counter=0;
    7218:	10 92 72 07 	sts	0x0772, r1
    721c:	10 92 71 07 	sts	0x0771, r1
				L_button = 0;
    7220:	10 92 6d 07 	sts	0x076D, r1
				R_button = 0;
    7224:	10 92 56 07 	sts	0x0756, r1
				Hazzred_button = 0;
    7228:	10 92 70 07 	sts	0x0770, r1
    722c:	04 c0       	rjmp	.+8      	; 0x7236 <get_readings+0x122>

			}
		}else{
			/*Ignition is off*/
			Stop_Blinking_Right();
    722e:	0e 94 43 07 	call	0xe86	; 0xe86 <Stop_Blinking_Right>
			Stop_Blinking_Left();
    7232:	0e 94 4c 07 	call	0xe98	; 0xe98 <Stop_Blinking_Left>
		}


}
    7236:	0f 90       	pop	r0
    7238:	0f 90       	pop	r0
    723a:	0f 90       	pop	r0
    723c:	cf 91       	pop	r28
    723e:	df 91       	pop	r29
    7240:	08 95       	ret

00007242 <vState_machine>:


void vState_machine(void)
{
    7242:	df 93       	push	r29
    7244:	cf 93       	push	r28
    7246:	cd b7       	in	r28, 0x3d	; 61
    7248:	de b7       	in	r29, 0x3e	; 62
	while(1)
	{
		if(Hazzred_button){
    724a:	80 91 70 07 	lds	r24, 0x0770
    724e:	88 23       	and	r24, r24
    7250:	41 f0       	breq	.+16     	; 0x7262 <vState_machine+0x20>
			vBlink_Right(led_mode);
    7252:	80 91 52 07 	lds	r24, 0x0752
    7256:	0e 94 1f 07 	call	0xe3e	; 0xe3e <vBlink_Right>
			Blink_LEFT(led_mode);
    725a:	80 91 52 07 	lds	r24, 0x0752
    725e:	0e 94 31 07 	call	0xe62	; 0xe62 <Blink_LEFT>
		}
		if(!ignition_button){
    7262:	80 91 55 07 	lds	r24, 0x0755
    7266:	88 23       	and	r24, r24
    7268:	81 f7       	brne	.-32     	; 0x724a <vState_machine+0x8>
			if(Hazzred_button){
    726a:	80 91 70 07 	lds	r24, 0x0770
    726e:	88 23       	and	r24, r24
    7270:	49 f0       	breq	.+18     	; 0x7284 <vState_machine+0x42>
				vBlink_Right(led_mode);
    7272:	80 91 52 07 	lds	r24, 0x0752
    7276:	0e 94 1f 07 	call	0xe3e	; 0xe3e <vBlink_Right>
				Blink_LEFT(led_mode);
    727a:	80 91 52 07 	lds	r24, 0x0752
    727e:	0e 94 31 07 	call	0xe62	; 0xe62 <Blink_LEFT>
    7282:	e3 cf       	rjmp	.-58     	; 0x724a <vState_machine+0x8>
			}
			else if(R_button ){
    7284:	80 91 56 07 	lds	r24, 0x0756
    7288:	88 23       	and	r24, r24
    728a:	29 f0       	breq	.+10     	; 0x7296 <vState_machine+0x54>
				vBlink_Right(led_mode);
    728c:	80 91 52 07 	lds	r24, 0x0752
    7290:	0e 94 1f 07 	call	0xe3e	; 0xe3e <vBlink_Right>
    7294:	da cf       	rjmp	.-76     	; 0x724a <vState_machine+0x8>
			}
			else if(L_button ){
    7296:	80 91 6d 07 	lds	r24, 0x076D
    729a:	88 23       	and	r24, r24
    729c:	b1 f2       	breq	.-84     	; 0x724a <vState_machine+0x8>
				Blink_LEFT(led_mode);
    729e:	80 91 52 07 	lds	r24, 0x0752
    72a2:	0e 94 31 07 	call	0xe62	; 0xe62 <Blink_LEFT>
    72a6:	d1 cf       	rjmp	.-94     	; 0x724a <vState_machine+0x8>

000072a8 <config_tim_1>:
		UART_SendString(runtime_Status);

	}


void config_tim_1(){
    72a8:	df 93       	push	r29
    72aa:	cf 93       	push	r28
    72ac:	cd b7       	in	r28, 0x3d	; 61
    72ae:	de b7       	in	r29, 0x3e	; 62
	TCCR0 = 0x01;
    72b0:	e3 e5       	ldi	r30, 0x53	; 83
    72b2:	f0 e0       	ldi	r31, 0x00	; 0
    72b4:	81 e0       	ldi	r24, 0x01	; 1
    72b6:	80 83       	st	Z, r24
}
    72b8:	cf 91       	pop	r28
    72ba:	df 91       	pop	r29
    72bc:	08 95       	ret

000072be <__udivmodhi4>:
    72be:	aa 1b       	sub	r26, r26
    72c0:	bb 1b       	sub	r27, r27
    72c2:	51 e1       	ldi	r21, 0x11	; 17
    72c4:	07 c0       	rjmp	.+14     	; 0x72d4 <__udivmodhi4_ep>

000072c6 <__udivmodhi4_loop>:
    72c6:	aa 1f       	adc	r26, r26
    72c8:	bb 1f       	adc	r27, r27
    72ca:	a6 17       	cp	r26, r22
    72cc:	b7 07       	cpc	r27, r23
    72ce:	10 f0       	brcs	.+4      	; 0x72d4 <__udivmodhi4_ep>
    72d0:	a6 1b       	sub	r26, r22
    72d2:	b7 0b       	sbc	r27, r23

000072d4 <__udivmodhi4_ep>:
    72d4:	88 1f       	adc	r24, r24
    72d6:	99 1f       	adc	r25, r25
    72d8:	5a 95       	dec	r21
    72da:	a9 f7       	brne	.-22     	; 0x72c6 <__udivmodhi4_loop>
    72dc:	80 95       	com	r24
    72de:	90 95       	com	r25
    72e0:	bc 01       	movw	r22, r24
    72e2:	cd 01       	movw	r24, r26
    72e4:	08 95       	ret

000072e6 <__divmodhi4>:
    72e6:	97 fb       	bst	r25, 7
    72e8:	09 2e       	mov	r0, r25
    72ea:	07 26       	eor	r0, r23
    72ec:	0a d0       	rcall	.+20     	; 0x7302 <__divmodhi4_neg1>
    72ee:	77 fd       	sbrc	r23, 7
    72f0:	04 d0       	rcall	.+8      	; 0x72fa <__divmodhi4_neg2>
    72f2:	e5 df       	rcall	.-54     	; 0x72be <__udivmodhi4>
    72f4:	06 d0       	rcall	.+12     	; 0x7302 <__divmodhi4_neg1>
    72f6:	00 20       	and	r0, r0
    72f8:	1a f4       	brpl	.+6      	; 0x7300 <__divmodhi4_exit>

000072fa <__divmodhi4_neg2>:
    72fa:	70 95       	com	r23
    72fc:	61 95       	neg	r22
    72fe:	7f 4f       	sbci	r23, 0xFF	; 255

00007300 <__divmodhi4_exit>:
    7300:	08 95       	ret

00007302 <__divmodhi4_neg1>:
    7302:	f6 f7       	brtc	.-4      	; 0x7300 <__divmodhi4_exit>
    7304:	90 95       	com	r25
    7306:	81 95       	neg	r24
    7308:	9f 4f       	sbci	r25, 0xFF	; 255
    730a:	08 95       	ret

0000730c <__udivmodsi4>:
    730c:	a1 e2       	ldi	r26, 0x21	; 33
    730e:	1a 2e       	mov	r1, r26
    7310:	aa 1b       	sub	r26, r26
    7312:	bb 1b       	sub	r27, r27
    7314:	fd 01       	movw	r30, r26
    7316:	0d c0       	rjmp	.+26     	; 0x7332 <__udivmodsi4_ep>

00007318 <__udivmodsi4_loop>:
    7318:	aa 1f       	adc	r26, r26
    731a:	bb 1f       	adc	r27, r27
    731c:	ee 1f       	adc	r30, r30
    731e:	ff 1f       	adc	r31, r31
    7320:	a2 17       	cp	r26, r18
    7322:	b3 07       	cpc	r27, r19
    7324:	e4 07       	cpc	r30, r20
    7326:	f5 07       	cpc	r31, r21
    7328:	20 f0       	brcs	.+8      	; 0x7332 <__udivmodsi4_ep>
    732a:	a2 1b       	sub	r26, r18
    732c:	b3 0b       	sbc	r27, r19
    732e:	e4 0b       	sbc	r30, r20
    7330:	f5 0b       	sbc	r31, r21

00007332 <__udivmodsi4_ep>:
    7332:	66 1f       	adc	r22, r22
    7334:	77 1f       	adc	r23, r23
    7336:	88 1f       	adc	r24, r24
    7338:	99 1f       	adc	r25, r25
    733a:	1a 94       	dec	r1
    733c:	69 f7       	brne	.-38     	; 0x7318 <__udivmodsi4_loop>
    733e:	60 95       	com	r22
    7340:	70 95       	com	r23
    7342:	80 95       	com	r24
    7344:	90 95       	com	r25
    7346:	9b 01       	movw	r18, r22
    7348:	ac 01       	movw	r20, r24
    734a:	bd 01       	movw	r22, r26
    734c:	cf 01       	movw	r24, r30
    734e:	08 95       	ret

00007350 <memcpy>:
    7350:	fb 01       	movw	r30, r22
    7352:	dc 01       	movw	r26, r24
    7354:	02 c0       	rjmp	.+4      	; 0x735a <memcpy+0xa>
    7356:	01 90       	ld	r0, Z+
    7358:	0d 92       	st	X+, r0
    735a:	41 50       	subi	r20, 0x01	; 1
    735c:	50 40       	sbci	r21, 0x00	; 0
    735e:	d8 f7       	brcc	.-10     	; 0x7356 <memcpy+0x6>
    7360:	08 95       	ret

00007362 <memset>:
    7362:	dc 01       	movw	r26, r24
    7364:	01 c0       	rjmp	.+2      	; 0x7368 <memset+0x6>
    7366:	6d 93       	st	X+, r22
    7368:	41 50       	subi	r20, 0x01	; 1
    736a:	50 40       	sbci	r21, 0x00	; 0
    736c:	e0 f7       	brcc	.-8      	; 0x7366 <memset+0x4>
    736e:	08 95       	ret

00007370 <strcpy>:
    7370:	fb 01       	movw	r30, r22
    7372:	dc 01       	movw	r26, r24
    7374:	01 90       	ld	r0, Z+
    7376:	0d 92       	st	X+, r0
    7378:	00 20       	and	r0, r0
    737a:	e1 f7       	brne	.-8      	; 0x7374 <strcpy+0x4>
    737c:	08 95       	ret

0000737e <strlen>:
    737e:	fc 01       	movw	r30, r24
    7380:	01 90       	ld	r0, Z+
    7382:	00 20       	and	r0, r0
    7384:	e9 f7       	brne	.-6      	; 0x7380 <strlen+0x2>
    7386:	80 95       	com	r24
    7388:	90 95       	com	r25
    738a:	8e 0f       	add	r24, r30
    738c:	9f 1f       	adc	r25, r31
    738e:	08 95       	ret

00007390 <sprintf>:
    7390:	ae e0       	ldi	r26, 0x0E	; 14
    7392:	b0 e0       	ldi	r27, 0x00	; 0
    7394:	ee ec       	ldi	r30, 0xCE	; 206
    7396:	f9 e3       	ldi	r31, 0x39	; 57
    7398:	0c 94 77 3c 	jmp	0x78ee	; 0x78ee <__prologue_saves__+0x1c>
    739c:	0d 89       	ldd	r16, Y+21	; 0x15
    739e:	1e 89       	ldd	r17, Y+22	; 0x16
    73a0:	86 e0       	ldi	r24, 0x06	; 6
    73a2:	8c 83       	std	Y+4, r24	; 0x04
    73a4:	1a 83       	std	Y+2, r17	; 0x02
    73a6:	09 83       	std	Y+1, r16	; 0x01
    73a8:	8f ef       	ldi	r24, 0xFF	; 255
    73aa:	9f e7       	ldi	r25, 0x7F	; 127
    73ac:	9e 83       	std	Y+6, r25	; 0x06
    73ae:	8d 83       	std	Y+5, r24	; 0x05
    73b0:	9e 01       	movw	r18, r28
    73b2:	27 5e       	subi	r18, 0xE7	; 231
    73b4:	3f 4f       	sbci	r19, 0xFF	; 255
    73b6:	ce 01       	movw	r24, r28
    73b8:	01 96       	adiw	r24, 0x01	; 1
    73ba:	6f 89       	ldd	r22, Y+23	; 0x17
    73bc:	78 8d       	ldd	r23, Y+24	; 0x18
    73be:	a9 01       	movw	r20, r18
    73c0:	0e 94 ec 39 	call	0x73d8	; 0x73d8 <vfprintf>
    73c4:	2f 81       	ldd	r18, Y+7	; 0x07
    73c6:	38 85       	ldd	r19, Y+8	; 0x08
    73c8:	02 0f       	add	r16, r18
    73ca:	13 1f       	adc	r17, r19
    73cc:	f8 01       	movw	r30, r16
    73ce:	10 82       	st	Z, r1
    73d0:	2e 96       	adiw	r28, 0x0e	; 14
    73d2:	e4 e0       	ldi	r30, 0x04	; 4
    73d4:	0c 94 93 3c 	jmp	0x7926	; 0x7926 <__epilogue_restores__+0x1c>

000073d8 <vfprintf>:
    73d8:	ab e0       	ldi	r26, 0x0B	; 11
    73da:	b0 e0       	ldi	r27, 0x00	; 0
    73dc:	e2 ef       	ldi	r30, 0xF2	; 242
    73de:	f9 e3       	ldi	r31, 0x39	; 57
    73e0:	0c 94 69 3c 	jmp	0x78d2	; 0x78d2 <__prologue_saves__>
    73e4:	3c 01       	movw	r6, r24
    73e6:	2b 01       	movw	r4, r22
    73e8:	5a 01       	movw	r10, r20
    73ea:	fc 01       	movw	r30, r24
    73ec:	17 82       	std	Z+7, r1	; 0x07
    73ee:	16 82       	std	Z+6, r1	; 0x06
    73f0:	83 81       	ldd	r24, Z+3	; 0x03
    73f2:	81 fd       	sbrc	r24, 1
    73f4:	03 c0       	rjmp	.+6      	; 0x73fc <vfprintf+0x24>
    73f6:	6f ef       	ldi	r22, 0xFF	; 255
    73f8:	7f ef       	ldi	r23, 0xFF	; 255
    73fa:	c6 c1       	rjmp	.+908    	; 0x7788 <vfprintf+0x3b0>
    73fc:	9a e0       	ldi	r25, 0x0A	; 10
    73fe:	89 2e       	mov	r8, r25
    7400:	1e 01       	movw	r2, r28
    7402:	08 94       	sec
    7404:	21 1c       	adc	r2, r1
    7406:	31 1c       	adc	r3, r1
    7408:	f3 01       	movw	r30, r6
    740a:	23 81       	ldd	r18, Z+3	; 0x03
    740c:	f2 01       	movw	r30, r4
    740e:	23 fd       	sbrc	r18, 3
    7410:	85 91       	lpm	r24, Z+
    7412:	23 ff       	sbrs	r18, 3
    7414:	81 91       	ld	r24, Z+
    7416:	2f 01       	movw	r4, r30
    7418:	88 23       	and	r24, r24
    741a:	09 f4       	brne	.+2      	; 0x741e <vfprintf+0x46>
    741c:	b2 c1       	rjmp	.+868    	; 0x7782 <vfprintf+0x3aa>
    741e:	85 32       	cpi	r24, 0x25	; 37
    7420:	39 f4       	brne	.+14     	; 0x7430 <vfprintf+0x58>
    7422:	23 fd       	sbrc	r18, 3
    7424:	85 91       	lpm	r24, Z+
    7426:	23 ff       	sbrs	r18, 3
    7428:	81 91       	ld	r24, Z+
    742a:	2f 01       	movw	r4, r30
    742c:	85 32       	cpi	r24, 0x25	; 37
    742e:	29 f4       	brne	.+10     	; 0x743a <vfprintf+0x62>
    7430:	90 e0       	ldi	r25, 0x00	; 0
    7432:	b3 01       	movw	r22, r6
    7434:	0e 94 df 3b 	call	0x77be	; 0x77be <fputc>
    7438:	e7 cf       	rjmp	.-50     	; 0x7408 <vfprintf+0x30>
    743a:	98 2f       	mov	r25, r24
    743c:	ff 24       	eor	r15, r15
    743e:	ee 24       	eor	r14, r14
    7440:	99 24       	eor	r9, r9
    7442:	ff e1       	ldi	r31, 0x1F	; 31
    7444:	ff 15       	cp	r31, r15
    7446:	d0 f0       	brcs	.+52     	; 0x747c <vfprintf+0xa4>
    7448:	9b 32       	cpi	r25, 0x2B	; 43
    744a:	69 f0       	breq	.+26     	; 0x7466 <vfprintf+0x8e>
    744c:	9c 32       	cpi	r25, 0x2C	; 44
    744e:	28 f4       	brcc	.+10     	; 0x745a <vfprintf+0x82>
    7450:	90 32       	cpi	r25, 0x20	; 32
    7452:	59 f0       	breq	.+22     	; 0x746a <vfprintf+0x92>
    7454:	93 32       	cpi	r25, 0x23	; 35
    7456:	91 f4       	brne	.+36     	; 0x747c <vfprintf+0xa4>
    7458:	0e c0       	rjmp	.+28     	; 0x7476 <vfprintf+0x9e>
    745a:	9d 32       	cpi	r25, 0x2D	; 45
    745c:	49 f0       	breq	.+18     	; 0x7470 <vfprintf+0x98>
    745e:	90 33       	cpi	r25, 0x30	; 48
    7460:	69 f4       	brne	.+26     	; 0x747c <vfprintf+0xa4>
    7462:	41 e0       	ldi	r20, 0x01	; 1
    7464:	24 c0       	rjmp	.+72     	; 0x74ae <vfprintf+0xd6>
    7466:	52 e0       	ldi	r21, 0x02	; 2
    7468:	f5 2a       	or	r15, r21
    746a:	84 e0       	ldi	r24, 0x04	; 4
    746c:	f8 2a       	or	r15, r24
    746e:	28 c0       	rjmp	.+80     	; 0x74c0 <vfprintf+0xe8>
    7470:	98 e0       	ldi	r25, 0x08	; 8
    7472:	f9 2a       	or	r15, r25
    7474:	25 c0       	rjmp	.+74     	; 0x74c0 <vfprintf+0xe8>
    7476:	e0 e1       	ldi	r30, 0x10	; 16
    7478:	fe 2a       	or	r15, r30
    747a:	22 c0       	rjmp	.+68     	; 0x74c0 <vfprintf+0xe8>
    747c:	f7 fc       	sbrc	r15, 7
    747e:	29 c0       	rjmp	.+82     	; 0x74d2 <vfprintf+0xfa>
    7480:	89 2f       	mov	r24, r25
    7482:	80 53       	subi	r24, 0x30	; 48
    7484:	8a 30       	cpi	r24, 0x0A	; 10
    7486:	70 f4       	brcc	.+28     	; 0x74a4 <vfprintf+0xcc>
    7488:	f6 fe       	sbrs	r15, 6
    748a:	05 c0       	rjmp	.+10     	; 0x7496 <vfprintf+0xbe>
    748c:	98 9c       	mul	r9, r8
    748e:	90 2c       	mov	r9, r0
    7490:	11 24       	eor	r1, r1
    7492:	98 0e       	add	r9, r24
    7494:	15 c0       	rjmp	.+42     	; 0x74c0 <vfprintf+0xe8>
    7496:	e8 9c       	mul	r14, r8
    7498:	e0 2c       	mov	r14, r0
    749a:	11 24       	eor	r1, r1
    749c:	e8 0e       	add	r14, r24
    749e:	f0 e2       	ldi	r31, 0x20	; 32
    74a0:	ff 2a       	or	r15, r31
    74a2:	0e c0       	rjmp	.+28     	; 0x74c0 <vfprintf+0xe8>
    74a4:	9e 32       	cpi	r25, 0x2E	; 46
    74a6:	29 f4       	brne	.+10     	; 0x74b2 <vfprintf+0xda>
    74a8:	f6 fc       	sbrc	r15, 6
    74aa:	6b c1       	rjmp	.+726    	; 0x7782 <vfprintf+0x3aa>
    74ac:	40 e4       	ldi	r20, 0x40	; 64
    74ae:	f4 2a       	or	r15, r20
    74b0:	07 c0       	rjmp	.+14     	; 0x74c0 <vfprintf+0xe8>
    74b2:	9c 36       	cpi	r25, 0x6C	; 108
    74b4:	19 f4       	brne	.+6      	; 0x74bc <vfprintf+0xe4>
    74b6:	50 e8       	ldi	r21, 0x80	; 128
    74b8:	f5 2a       	or	r15, r21
    74ba:	02 c0       	rjmp	.+4      	; 0x74c0 <vfprintf+0xe8>
    74bc:	98 36       	cpi	r25, 0x68	; 104
    74be:	49 f4       	brne	.+18     	; 0x74d2 <vfprintf+0xfa>
    74c0:	f2 01       	movw	r30, r4
    74c2:	23 fd       	sbrc	r18, 3
    74c4:	95 91       	lpm	r25, Z+
    74c6:	23 ff       	sbrs	r18, 3
    74c8:	91 91       	ld	r25, Z+
    74ca:	2f 01       	movw	r4, r30
    74cc:	99 23       	and	r25, r25
    74ce:	09 f0       	breq	.+2      	; 0x74d2 <vfprintf+0xfa>
    74d0:	b8 cf       	rjmp	.-144    	; 0x7442 <vfprintf+0x6a>
    74d2:	89 2f       	mov	r24, r25
    74d4:	85 54       	subi	r24, 0x45	; 69
    74d6:	83 30       	cpi	r24, 0x03	; 3
    74d8:	18 f0       	brcs	.+6      	; 0x74e0 <vfprintf+0x108>
    74da:	80 52       	subi	r24, 0x20	; 32
    74dc:	83 30       	cpi	r24, 0x03	; 3
    74de:	38 f4       	brcc	.+14     	; 0x74ee <vfprintf+0x116>
    74e0:	44 e0       	ldi	r20, 0x04	; 4
    74e2:	50 e0       	ldi	r21, 0x00	; 0
    74e4:	a4 0e       	add	r10, r20
    74e6:	b5 1e       	adc	r11, r21
    74e8:	5f e3       	ldi	r21, 0x3F	; 63
    74ea:	59 83       	std	Y+1, r21	; 0x01
    74ec:	0f c0       	rjmp	.+30     	; 0x750c <vfprintf+0x134>
    74ee:	93 36       	cpi	r25, 0x63	; 99
    74f0:	31 f0       	breq	.+12     	; 0x74fe <vfprintf+0x126>
    74f2:	93 37       	cpi	r25, 0x73	; 115
    74f4:	79 f0       	breq	.+30     	; 0x7514 <vfprintf+0x13c>
    74f6:	93 35       	cpi	r25, 0x53	; 83
    74f8:	09 f0       	breq	.+2      	; 0x74fc <vfprintf+0x124>
    74fa:	56 c0       	rjmp	.+172    	; 0x75a8 <vfprintf+0x1d0>
    74fc:	20 c0       	rjmp	.+64     	; 0x753e <vfprintf+0x166>
    74fe:	f5 01       	movw	r30, r10
    7500:	80 81       	ld	r24, Z
    7502:	89 83       	std	Y+1, r24	; 0x01
    7504:	42 e0       	ldi	r20, 0x02	; 2
    7506:	50 e0       	ldi	r21, 0x00	; 0
    7508:	a4 0e       	add	r10, r20
    750a:	b5 1e       	adc	r11, r21
    750c:	61 01       	movw	r12, r2
    750e:	01 e0       	ldi	r16, 0x01	; 1
    7510:	10 e0       	ldi	r17, 0x00	; 0
    7512:	12 c0       	rjmp	.+36     	; 0x7538 <vfprintf+0x160>
    7514:	f5 01       	movw	r30, r10
    7516:	c0 80       	ld	r12, Z
    7518:	d1 80       	ldd	r13, Z+1	; 0x01
    751a:	f6 fc       	sbrc	r15, 6
    751c:	03 c0       	rjmp	.+6      	; 0x7524 <vfprintf+0x14c>
    751e:	6f ef       	ldi	r22, 0xFF	; 255
    7520:	7f ef       	ldi	r23, 0xFF	; 255
    7522:	02 c0       	rjmp	.+4      	; 0x7528 <vfprintf+0x150>
    7524:	69 2d       	mov	r22, r9
    7526:	70 e0       	ldi	r23, 0x00	; 0
    7528:	42 e0       	ldi	r20, 0x02	; 2
    752a:	50 e0       	ldi	r21, 0x00	; 0
    752c:	a4 0e       	add	r10, r20
    752e:	b5 1e       	adc	r11, r21
    7530:	c6 01       	movw	r24, r12
    7532:	0e 94 d4 3b 	call	0x77a8	; 0x77a8 <strnlen>
    7536:	8c 01       	movw	r16, r24
    7538:	5f e7       	ldi	r21, 0x7F	; 127
    753a:	f5 22       	and	r15, r21
    753c:	14 c0       	rjmp	.+40     	; 0x7566 <vfprintf+0x18e>
    753e:	f5 01       	movw	r30, r10
    7540:	c0 80       	ld	r12, Z
    7542:	d1 80       	ldd	r13, Z+1	; 0x01
    7544:	f6 fc       	sbrc	r15, 6
    7546:	03 c0       	rjmp	.+6      	; 0x754e <vfprintf+0x176>
    7548:	6f ef       	ldi	r22, 0xFF	; 255
    754a:	7f ef       	ldi	r23, 0xFF	; 255
    754c:	02 c0       	rjmp	.+4      	; 0x7552 <vfprintf+0x17a>
    754e:	69 2d       	mov	r22, r9
    7550:	70 e0       	ldi	r23, 0x00	; 0
    7552:	42 e0       	ldi	r20, 0x02	; 2
    7554:	50 e0       	ldi	r21, 0x00	; 0
    7556:	a4 0e       	add	r10, r20
    7558:	b5 1e       	adc	r11, r21
    755a:	c6 01       	movw	r24, r12
    755c:	0e 94 c9 3b 	call	0x7792	; 0x7792 <strnlen_P>
    7560:	8c 01       	movw	r16, r24
    7562:	50 e8       	ldi	r21, 0x80	; 128
    7564:	f5 2a       	or	r15, r21
    7566:	f3 fe       	sbrs	r15, 3
    7568:	07 c0       	rjmp	.+14     	; 0x7578 <vfprintf+0x1a0>
    756a:	1a c0       	rjmp	.+52     	; 0x75a0 <vfprintf+0x1c8>
    756c:	80 e2       	ldi	r24, 0x20	; 32
    756e:	90 e0       	ldi	r25, 0x00	; 0
    7570:	b3 01       	movw	r22, r6
    7572:	0e 94 df 3b 	call	0x77be	; 0x77be <fputc>
    7576:	ea 94       	dec	r14
    7578:	8e 2d       	mov	r24, r14
    757a:	90 e0       	ldi	r25, 0x00	; 0
    757c:	08 17       	cp	r16, r24
    757e:	19 07       	cpc	r17, r25
    7580:	a8 f3       	brcs	.-22     	; 0x756c <vfprintf+0x194>
    7582:	0e c0       	rjmp	.+28     	; 0x75a0 <vfprintf+0x1c8>
    7584:	f6 01       	movw	r30, r12
    7586:	f7 fc       	sbrc	r15, 7
    7588:	85 91       	lpm	r24, Z+
    758a:	f7 fe       	sbrs	r15, 7
    758c:	81 91       	ld	r24, Z+
    758e:	6f 01       	movw	r12, r30
    7590:	90 e0       	ldi	r25, 0x00	; 0
    7592:	b3 01       	movw	r22, r6
    7594:	0e 94 df 3b 	call	0x77be	; 0x77be <fputc>
    7598:	e1 10       	cpse	r14, r1
    759a:	ea 94       	dec	r14
    759c:	01 50       	subi	r16, 0x01	; 1
    759e:	10 40       	sbci	r17, 0x00	; 0
    75a0:	01 15       	cp	r16, r1
    75a2:	11 05       	cpc	r17, r1
    75a4:	79 f7       	brne	.-34     	; 0x7584 <vfprintf+0x1ac>
    75a6:	ea c0       	rjmp	.+468    	; 0x777c <vfprintf+0x3a4>
    75a8:	94 36       	cpi	r25, 0x64	; 100
    75aa:	11 f0       	breq	.+4      	; 0x75b0 <vfprintf+0x1d8>
    75ac:	99 36       	cpi	r25, 0x69	; 105
    75ae:	69 f5       	brne	.+90     	; 0x760a <vfprintf+0x232>
    75b0:	f7 fe       	sbrs	r15, 7
    75b2:	08 c0       	rjmp	.+16     	; 0x75c4 <vfprintf+0x1ec>
    75b4:	f5 01       	movw	r30, r10
    75b6:	20 81       	ld	r18, Z
    75b8:	31 81       	ldd	r19, Z+1	; 0x01
    75ba:	42 81       	ldd	r20, Z+2	; 0x02
    75bc:	53 81       	ldd	r21, Z+3	; 0x03
    75be:	84 e0       	ldi	r24, 0x04	; 4
    75c0:	90 e0       	ldi	r25, 0x00	; 0
    75c2:	0a c0       	rjmp	.+20     	; 0x75d8 <vfprintf+0x200>
    75c4:	f5 01       	movw	r30, r10
    75c6:	80 81       	ld	r24, Z
    75c8:	91 81       	ldd	r25, Z+1	; 0x01
    75ca:	9c 01       	movw	r18, r24
    75cc:	44 27       	eor	r20, r20
    75ce:	37 fd       	sbrc	r19, 7
    75d0:	40 95       	com	r20
    75d2:	54 2f       	mov	r21, r20
    75d4:	82 e0       	ldi	r24, 0x02	; 2
    75d6:	90 e0       	ldi	r25, 0x00	; 0
    75d8:	a8 0e       	add	r10, r24
    75da:	b9 1e       	adc	r11, r25
    75dc:	9f e6       	ldi	r25, 0x6F	; 111
    75de:	f9 22       	and	r15, r25
    75e0:	57 ff       	sbrs	r21, 7
    75e2:	09 c0       	rjmp	.+18     	; 0x75f6 <vfprintf+0x21e>
    75e4:	50 95       	com	r21
    75e6:	40 95       	com	r20
    75e8:	30 95       	com	r19
    75ea:	21 95       	neg	r18
    75ec:	3f 4f       	sbci	r19, 0xFF	; 255
    75ee:	4f 4f       	sbci	r20, 0xFF	; 255
    75f0:	5f 4f       	sbci	r21, 0xFF	; 255
    75f2:	e0 e8       	ldi	r30, 0x80	; 128
    75f4:	fe 2a       	or	r15, r30
    75f6:	ca 01       	movw	r24, r20
    75f8:	b9 01       	movw	r22, r18
    75fa:	a1 01       	movw	r20, r2
    75fc:	2a e0       	ldi	r18, 0x0A	; 10
    75fe:	30 e0       	ldi	r19, 0x00	; 0
    7600:	0e 94 0b 3c 	call	0x7816	; 0x7816 <__ultoa_invert>
    7604:	d8 2e       	mov	r13, r24
    7606:	d2 18       	sub	r13, r2
    7608:	40 c0       	rjmp	.+128    	; 0x768a <vfprintf+0x2b2>
    760a:	95 37       	cpi	r25, 0x75	; 117
    760c:	29 f4       	brne	.+10     	; 0x7618 <vfprintf+0x240>
    760e:	1f 2d       	mov	r17, r15
    7610:	1f 7e       	andi	r17, 0xEF	; 239
    7612:	2a e0       	ldi	r18, 0x0A	; 10
    7614:	30 e0       	ldi	r19, 0x00	; 0
    7616:	1d c0       	rjmp	.+58     	; 0x7652 <vfprintf+0x27a>
    7618:	1f 2d       	mov	r17, r15
    761a:	19 7f       	andi	r17, 0xF9	; 249
    761c:	9f 36       	cpi	r25, 0x6F	; 111
    761e:	61 f0       	breq	.+24     	; 0x7638 <vfprintf+0x260>
    7620:	90 37       	cpi	r25, 0x70	; 112
    7622:	20 f4       	brcc	.+8      	; 0x762c <vfprintf+0x254>
    7624:	98 35       	cpi	r25, 0x58	; 88
    7626:	09 f0       	breq	.+2      	; 0x762a <vfprintf+0x252>
    7628:	ac c0       	rjmp	.+344    	; 0x7782 <vfprintf+0x3aa>
    762a:	0f c0       	rjmp	.+30     	; 0x764a <vfprintf+0x272>
    762c:	90 37       	cpi	r25, 0x70	; 112
    762e:	39 f0       	breq	.+14     	; 0x763e <vfprintf+0x266>
    7630:	98 37       	cpi	r25, 0x78	; 120
    7632:	09 f0       	breq	.+2      	; 0x7636 <vfprintf+0x25e>
    7634:	a6 c0       	rjmp	.+332    	; 0x7782 <vfprintf+0x3aa>
    7636:	04 c0       	rjmp	.+8      	; 0x7640 <vfprintf+0x268>
    7638:	28 e0       	ldi	r18, 0x08	; 8
    763a:	30 e0       	ldi	r19, 0x00	; 0
    763c:	0a c0       	rjmp	.+20     	; 0x7652 <vfprintf+0x27a>
    763e:	10 61       	ori	r17, 0x10	; 16
    7640:	14 fd       	sbrc	r17, 4
    7642:	14 60       	ori	r17, 0x04	; 4
    7644:	20 e1       	ldi	r18, 0x10	; 16
    7646:	30 e0       	ldi	r19, 0x00	; 0
    7648:	04 c0       	rjmp	.+8      	; 0x7652 <vfprintf+0x27a>
    764a:	14 fd       	sbrc	r17, 4
    764c:	16 60       	ori	r17, 0x06	; 6
    764e:	20 e1       	ldi	r18, 0x10	; 16
    7650:	32 e0       	ldi	r19, 0x02	; 2
    7652:	17 ff       	sbrs	r17, 7
    7654:	08 c0       	rjmp	.+16     	; 0x7666 <vfprintf+0x28e>
    7656:	f5 01       	movw	r30, r10
    7658:	60 81       	ld	r22, Z
    765a:	71 81       	ldd	r23, Z+1	; 0x01
    765c:	82 81       	ldd	r24, Z+2	; 0x02
    765e:	93 81       	ldd	r25, Z+3	; 0x03
    7660:	44 e0       	ldi	r20, 0x04	; 4
    7662:	50 e0       	ldi	r21, 0x00	; 0
    7664:	08 c0       	rjmp	.+16     	; 0x7676 <vfprintf+0x29e>
    7666:	f5 01       	movw	r30, r10
    7668:	80 81       	ld	r24, Z
    766a:	91 81       	ldd	r25, Z+1	; 0x01
    766c:	bc 01       	movw	r22, r24
    766e:	80 e0       	ldi	r24, 0x00	; 0
    7670:	90 e0       	ldi	r25, 0x00	; 0
    7672:	42 e0       	ldi	r20, 0x02	; 2
    7674:	50 e0       	ldi	r21, 0x00	; 0
    7676:	a4 0e       	add	r10, r20
    7678:	b5 1e       	adc	r11, r21
    767a:	a1 01       	movw	r20, r2
    767c:	0e 94 0b 3c 	call	0x7816	; 0x7816 <__ultoa_invert>
    7680:	d8 2e       	mov	r13, r24
    7682:	d2 18       	sub	r13, r2
    7684:	8f e7       	ldi	r24, 0x7F	; 127
    7686:	f8 2e       	mov	r15, r24
    7688:	f1 22       	and	r15, r17
    768a:	f6 fe       	sbrs	r15, 6
    768c:	0b c0       	rjmp	.+22     	; 0x76a4 <vfprintf+0x2cc>
    768e:	5e ef       	ldi	r21, 0xFE	; 254
    7690:	f5 22       	and	r15, r21
    7692:	d9 14       	cp	r13, r9
    7694:	38 f4       	brcc	.+14     	; 0x76a4 <vfprintf+0x2cc>
    7696:	f4 fe       	sbrs	r15, 4
    7698:	07 c0       	rjmp	.+14     	; 0x76a8 <vfprintf+0x2d0>
    769a:	f2 fc       	sbrc	r15, 2
    769c:	05 c0       	rjmp	.+10     	; 0x76a8 <vfprintf+0x2d0>
    769e:	8f ee       	ldi	r24, 0xEF	; 239
    76a0:	f8 22       	and	r15, r24
    76a2:	02 c0       	rjmp	.+4      	; 0x76a8 <vfprintf+0x2d0>
    76a4:	1d 2d       	mov	r17, r13
    76a6:	01 c0       	rjmp	.+2      	; 0x76aa <vfprintf+0x2d2>
    76a8:	19 2d       	mov	r17, r9
    76aa:	f4 fe       	sbrs	r15, 4
    76ac:	0d c0       	rjmp	.+26     	; 0x76c8 <vfprintf+0x2f0>
    76ae:	fe 01       	movw	r30, r28
    76b0:	ed 0d       	add	r30, r13
    76b2:	f1 1d       	adc	r31, r1
    76b4:	80 81       	ld	r24, Z
    76b6:	80 33       	cpi	r24, 0x30	; 48
    76b8:	19 f4       	brne	.+6      	; 0x76c0 <vfprintf+0x2e8>
    76ba:	99 ee       	ldi	r25, 0xE9	; 233
    76bc:	f9 22       	and	r15, r25
    76be:	08 c0       	rjmp	.+16     	; 0x76d0 <vfprintf+0x2f8>
    76c0:	1f 5f       	subi	r17, 0xFF	; 255
    76c2:	f2 fe       	sbrs	r15, 2
    76c4:	05 c0       	rjmp	.+10     	; 0x76d0 <vfprintf+0x2f8>
    76c6:	03 c0       	rjmp	.+6      	; 0x76ce <vfprintf+0x2f6>
    76c8:	8f 2d       	mov	r24, r15
    76ca:	86 78       	andi	r24, 0x86	; 134
    76cc:	09 f0       	breq	.+2      	; 0x76d0 <vfprintf+0x2f8>
    76ce:	1f 5f       	subi	r17, 0xFF	; 255
    76d0:	0f 2d       	mov	r16, r15
    76d2:	f3 fc       	sbrc	r15, 3
    76d4:	14 c0       	rjmp	.+40     	; 0x76fe <vfprintf+0x326>
    76d6:	f0 fe       	sbrs	r15, 0
    76d8:	0f c0       	rjmp	.+30     	; 0x76f8 <vfprintf+0x320>
    76da:	1e 15       	cp	r17, r14
    76dc:	10 f0       	brcs	.+4      	; 0x76e2 <vfprintf+0x30a>
    76de:	9d 2c       	mov	r9, r13
    76e0:	0b c0       	rjmp	.+22     	; 0x76f8 <vfprintf+0x320>
    76e2:	9d 2c       	mov	r9, r13
    76e4:	9e 0c       	add	r9, r14
    76e6:	91 1a       	sub	r9, r17
    76e8:	1e 2d       	mov	r17, r14
    76ea:	06 c0       	rjmp	.+12     	; 0x76f8 <vfprintf+0x320>
    76ec:	80 e2       	ldi	r24, 0x20	; 32
    76ee:	90 e0       	ldi	r25, 0x00	; 0
    76f0:	b3 01       	movw	r22, r6
    76f2:	0e 94 df 3b 	call	0x77be	; 0x77be <fputc>
    76f6:	1f 5f       	subi	r17, 0xFF	; 255
    76f8:	1e 15       	cp	r17, r14
    76fa:	c0 f3       	brcs	.-16     	; 0x76ec <vfprintf+0x314>
    76fc:	04 c0       	rjmp	.+8      	; 0x7706 <vfprintf+0x32e>
    76fe:	1e 15       	cp	r17, r14
    7700:	10 f4       	brcc	.+4      	; 0x7706 <vfprintf+0x32e>
    7702:	e1 1a       	sub	r14, r17
    7704:	01 c0       	rjmp	.+2      	; 0x7708 <vfprintf+0x330>
    7706:	ee 24       	eor	r14, r14
    7708:	04 ff       	sbrs	r16, 4
    770a:	0f c0       	rjmp	.+30     	; 0x772a <vfprintf+0x352>
    770c:	80 e3       	ldi	r24, 0x30	; 48
    770e:	90 e0       	ldi	r25, 0x00	; 0
    7710:	b3 01       	movw	r22, r6
    7712:	0e 94 df 3b 	call	0x77be	; 0x77be <fputc>
    7716:	02 ff       	sbrs	r16, 2
    7718:	1d c0       	rjmp	.+58     	; 0x7754 <vfprintf+0x37c>
    771a:	01 fd       	sbrc	r16, 1
    771c:	03 c0       	rjmp	.+6      	; 0x7724 <vfprintf+0x34c>
    771e:	88 e7       	ldi	r24, 0x78	; 120
    7720:	90 e0       	ldi	r25, 0x00	; 0
    7722:	0e c0       	rjmp	.+28     	; 0x7740 <vfprintf+0x368>
    7724:	88 e5       	ldi	r24, 0x58	; 88
    7726:	90 e0       	ldi	r25, 0x00	; 0
    7728:	0b c0       	rjmp	.+22     	; 0x7740 <vfprintf+0x368>
    772a:	80 2f       	mov	r24, r16
    772c:	86 78       	andi	r24, 0x86	; 134
    772e:	91 f0       	breq	.+36     	; 0x7754 <vfprintf+0x37c>
    7730:	01 ff       	sbrs	r16, 1
    7732:	02 c0       	rjmp	.+4      	; 0x7738 <vfprintf+0x360>
    7734:	8b e2       	ldi	r24, 0x2B	; 43
    7736:	01 c0       	rjmp	.+2      	; 0x773a <vfprintf+0x362>
    7738:	80 e2       	ldi	r24, 0x20	; 32
    773a:	f7 fc       	sbrc	r15, 7
    773c:	8d e2       	ldi	r24, 0x2D	; 45
    773e:	90 e0       	ldi	r25, 0x00	; 0
    7740:	b3 01       	movw	r22, r6
    7742:	0e 94 df 3b 	call	0x77be	; 0x77be <fputc>
    7746:	06 c0       	rjmp	.+12     	; 0x7754 <vfprintf+0x37c>
    7748:	80 e3       	ldi	r24, 0x30	; 48
    774a:	90 e0       	ldi	r25, 0x00	; 0
    774c:	b3 01       	movw	r22, r6
    774e:	0e 94 df 3b 	call	0x77be	; 0x77be <fputc>
    7752:	9a 94       	dec	r9
    7754:	d9 14       	cp	r13, r9
    7756:	c0 f3       	brcs	.-16     	; 0x7748 <vfprintf+0x370>
    7758:	da 94       	dec	r13
    775a:	f1 01       	movw	r30, r2
    775c:	ed 0d       	add	r30, r13
    775e:	f1 1d       	adc	r31, r1
    7760:	80 81       	ld	r24, Z
    7762:	90 e0       	ldi	r25, 0x00	; 0
    7764:	b3 01       	movw	r22, r6
    7766:	0e 94 df 3b 	call	0x77be	; 0x77be <fputc>
    776a:	dd 20       	and	r13, r13
    776c:	a9 f7       	brne	.-22     	; 0x7758 <vfprintf+0x380>
    776e:	06 c0       	rjmp	.+12     	; 0x777c <vfprintf+0x3a4>
    7770:	80 e2       	ldi	r24, 0x20	; 32
    7772:	90 e0       	ldi	r25, 0x00	; 0
    7774:	b3 01       	movw	r22, r6
    7776:	0e 94 df 3b 	call	0x77be	; 0x77be <fputc>
    777a:	ea 94       	dec	r14
    777c:	ee 20       	and	r14, r14
    777e:	c1 f7       	brne	.-16     	; 0x7770 <vfprintf+0x398>
    7780:	43 ce       	rjmp	.-890    	; 0x7408 <vfprintf+0x30>
    7782:	f3 01       	movw	r30, r6
    7784:	66 81       	ldd	r22, Z+6	; 0x06
    7786:	77 81       	ldd	r23, Z+7	; 0x07
    7788:	cb 01       	movw	r24, r22
    778a:	2b 96       	adiw	r28, 0x0b	; 11
    778c:	e2 e1       	ldi	r30, 0x12	; 18
    778e:	0c 94 85 3c 	jmp	0x790a	; 0x790a <__epilogue_restores__>

00007792 <strnlen_P>:
    7792:	fc 01       	movw	r30, r24
    7794:	05 90       	lpm	r0, Z+
    7796:	61 50       	subi	r22, 0x01	; 1
    7798:	70 40       	sbci	r23, 0x00	; 0
    779a:	01 10       	cpse	r0, r1
    779c:	d8 f7       	brcc	.-10     	; 0x7794 <strnlen_P+0x2>
    779e:	80 95       	com	r24
    77a0:	90 95       	com	r25
    77a2:	8e 0f       	add	r24, r30
    77a4:	9f 1f       	adc	r25, r31
    77a6:	08 95       	ret

000077a8 <strnlen>:
    77a8:	fc 01       	movw	r30, r24
    77aa:	61 50       	subi	r22, 0x01	; 1
    77ac:	70 40       	sbci	r23, 0x00	; 0
    77ae:	01 90       	ld	r0, Z+
    77b0:	01 10       	cpse	r0, r1
    77b2:	d8 f7       	brcc	.-10     	; 0x77aa <strnlen+0x2>
    77b4:	80 95       	com	r24
    77b6:	90 95       	com	r25
    77b8:	8e 0f       	add	r24, r30
    77ba:	9f 1f       	adc	r25, r31
    77bc:	08 95       	ret

000077be <fputc>:
    77be:	0f 93       	push	r16
    77c0:	1f 93       	push	r17
    77c2:	cf 93       	push	r28
    77c4:	df 93       	push	r29
    77c6:	8c 01       	movw	r16, r24
    77c8:	eb 01       	movw	r28, r22
    77ca:	8b 81       	ldd	r24, Y+3	; 0x03
    77cc:	81 ff       	sbrs	r24, 1
    77ce:	1b c0       	rjmp	.+54     	; 0x7806 <fputc+0x48>
    77d0:	82 ff       	sbrs	r24, 2
    77d2:	0d c0       	rjmp	.+26     	; 0x77ee <fputc+0x30>
    77d4:	2e 81       	ldd	r18, Y+6	; 0x06
    77d6:	3f 81       	ldd	r19, Y+7	; 0x07
    77d8:	8c 81       	ldd	r24, Y+4	; 0x04
    77da:	9d 81       	ldd	r25, Y+5	; 0x05
    77dc:	28 17       	cp	r18, r24
    77de:	39 07       	cpc	r19, r25
    77e0:	64 f4       	brge	.+24     	; 0x77fa <fputc+0x3c>
    77e2:	e8 81       	ld	r30, Y
    77e4:	f9 81       	ldd	r31, Y+1	; 0x01
    77e6:	01 93       	st	Z+, r16
    77e8:	f9 83       	std	Y+1, r31	; 0x01
    77ea:	e8 83       	st	Y, r30
    77ec:	06 c0       	rjmp	.+12     	; 0x77fa <fputc+0x3c>
    77ee:	e8 85       	ldd	r30, Y+8	; 0x08
    77f0:	f9 85       	ldd	r31, Y+9	; 0x09
    77f2:	80 2f       	mov	r24, r16
    77f4:	09 95       	icall
    77f6:	89 2b       	or	r24, r25
    77f8:	31 f4       	brne	.+12     	; 0x7806 <fputc+0x48>
    77fa:	8e 81       	ldd	r24, Y+6	; 0x06
    77fc:	9f 81       	ldd	r25, Y+7	; 0x07
    77fe:	01 96       	adiw	r24, 0x01	; 1
    7800:	9f 83       	std	Y+7, r25	; 0x07
    7802:	8e 83       	std	Y+6, r24	; 0x06
    7804:	02 c0       	rjmp	.+4      	; 0x780a <fputc+0x4c>
    7806:	0f ef       	ldi	r16, 0xFF	; 255
    7808:	1f ef       	ldi	r17, 0xFF	; 255
    780a:	c8 01       	movw	r24, r16
    780c:	df 91       	pop	r29
    780e:	cf 91       	pop	r28
    7810:	1f 91       	pop	r17
    7812:	0f 91       	pop	r16
    7814:	08 95       	ret

00007816 <__ultoa_invert>:
    7816:	fa 01       	movw	r30, r20
    7818:	aa 27       	eor	r26, r26
    781a:	28 30       	cpi	r18, 0x08	; 8
    781c:	51 f1       	breq	.+84     	; 0x7872 <__ultoa_invert+0x5c>
    781e:	20 31       	cpi	r18, 0x10	; 16
    7820:	81 f1       	breq	.+96     	; 0x7882 <__ultoa_invert+0x6c>
    7822:	e8 94       	clt
    7824:	6f 93       	push	r22
    7826:	6e 7f       	andi	r22, 0xFE	; 254
    7828:	6e 5f       	subi	r22, 0xFE	; 254
    782a:	7f 4f       	sbci	r23, 0xFF	; 255
    782c:	8f 4f       	sbci	r24, 0xFF	; 255
    782e:	9f 4f       	sbci	r25, 0xFF	; 255
    7830:	af 4f       	sbci	r26, 0xFF	; 255
    7832:	b1 e0       	ldi	r27, 0x01	; 1
    7834:	3e d0       	rcall	.+124    	; 0x78b2 <__ultoa_invert+0x9c>
    7836:	b4 e0       	ldi	r27, 0x04	; 4
    7838:	3c d0       	rcall	.+120    	; 0x78b2 <__ultoa_invert+0x9c>
    783a:	67 0f       	add	r22, r23
    783c:	78 1f       	adc	r23, r24
    783e:	89 1f       	adc	r24, r25
    7840:	9a 1f       	adc	r25, r26
    7842:	a1 1d       	adc	r26, r1
    7844:	68 0f       	add	r22, r24
    7846:	79 1f       	adc	r23, r25
    7848:	8a 1f       	adc	r24, r26
    784a:	91 1d       	adc	r25, r1
    784c:	a1 1d       	adc	r26, r1
    784e:	6a 0f       	add	r22, r26
    7850:	71 1d       	adc	r23, r1
    7852:	81 1d       	adc	r24, r1
    7854:	91 1d       	adc	r25, r1
    7856:	a1 1d       	adc	r26, r1
    7858:	20 d0       	rcall	.+64     	; 0x789a <__ultoa_invert+0x84>
    785a:	09 f4       	brne	.+2      	; 0x785e <__ultoa_invert+0x48>
    785c:	68 94       	set
    785e:	3f 91       	pop	r19
    7860:	2a e0       	ldi	r18, 0x0A	; 10
    7862:	26 9f       	mul	r18, r22
    7864:	11 24       	eor	r1, r1
    7866:	30 19       	sub	r19, r0
    7868:	30 5d       	subi	r19, 0xD0	; 208
    786a:	31 93       	st	Z+, r19
    786c:	de f6       	brtc	.-74     	; 0x7824 <__ultoa_invert+0xe>
    786e:	cf 01       	movw	r24, r30
    7870:	08 95       	ret
    7872:	46 2f       	mov	r20, r22
    7874:	47 70       	andi	r20, 0x07	; 7
    7876:	40 5d       	subi	r20, 0xD0	; 208
    7878:	41 93       	st	Z+, r20
    787a:	b3 e0       	ldi	r27, 0x03	; 3
    787c:	0f d0       	rcall	.+30     	; 0x789c <__ultoa_invert+0x86>
    787e:	c9 f7       	brne	.-14     	; 0x7872 <__ultoa_invert+0x5c>
    7880:	f6 cf       	rjmp	.-20     	; 0x786e <__ultoa_invert+0x58>
    7882:	46 2f       	mov	r20, r22
    7884:	4f 70       	andi	r20, 0x0F	; 15
    7886:	40 5d       	subi	r20, 0xD0	; 208
    7888:	4a 33       	cpi	r20, 0x3A	; 58
    788a:	18 f0       	brcs	.+6      	; 0x7892 <__ultoa_invert+0x7c>
    788c:	49 5d       	subi	r20, 0xD9	; 217
    788e:	31 fd       	sbrc	r19, 1
    7890:	40 52       	subi	r20, 0x20	; 32
    7892:	41 93       	st	Z+, r20
    7894:	02 d0       	rcall	.+4      	; 0x789a <__ultoa_invert+0x84>
    7896:	a9 f7       	brne	.-22     	; 0x7882 <__ultoa_invert+0x6c>
    7898:	ea cf       	rjmp	.-44     	; 0x786e <__ultoa_invert+0x58>
    789a:	b4 e0       	ldi	r27, 0x04	; 4
    789c:	a6 95       	lsr	r26
    789e:	97 95       	ror	r25
    78a0:	87 95       	ror	r24
    78a2:	77 95       	ror	r23
    78a4:	67 95       	ror	r22
    78a6:	ba 95       	dec	r27
    78a8:	c9 f7       	brne	.-14     	; 0x789c <__ultoa_invert+0x86>
    78aa:	00 97       	sbiw	r24, 0x00	; 0
    78ac:	61 05       	cpc	r22, r1
    78ae:	71 05       	cpc	r23, r1
    78b0:	08 95       	ret
    78b2:	9b 01       	movw	r18, r22
    78b4:	ac 01       	movw	r20, r24
    78b6:	0a 2e       	mov	r0, r26
    78b8:	06 94       	lsr	r0
    78ba:	57 95       	ror	r21
    78bc:	47 95       	ror	r20
    78be:	37 95       	ror	r19
    78c0:	27 95       	ror	r18
    78c2:	ba 95       	dec	r27
    78c4:	c9 f7       	brne	.-14     	; 0x78b8 <__ultoa_invert+0xa2>
    78c6:	62 0f       	add	r22, r18
    78c8:	73 1f       	adc	r23, r19
    78ca:	84 1f       	adc	r24, r20
    78cc:	95 1f       	adc	r25, r21
    78ce:	a0 1d       	adc	r26, r0
    78d0:	08 95       	ret

000078d2 <__prologue_saves__>:
    78d2:	2f 92       	push	r2
    78d4:	3f 92       	push	r3
    78d6:	4f 92       	push	r4
    78d8:	5f 92       	push	r5
    78da:	6f 92       	push	r6
    78dc:	7f 92       	push	r7
    78de:	8f 92       	push	r8
    78e0:	9f 92       	push	r9
    78e2:	af 92       	push	r10
    78e4:	bf 92       	push	r11
    78e6:	cf 92       	push	r12
    78e8:	df 92       	push	r13
    78ea:	ef 92       	push	r14
    78ec:	ff 92       	push	r15
    78ee:	0f 93       	push	r16
    78f0:	1f 93       	push	r17
    78f2:	cf 93       	push	r28
    78f4:	df 93       	push	r29
    78f6:	cd b7       	in	r28, 0x3d	; 61
    78f8:	de b7       	in	r29, 0x3e	; 62
    78fa:	ca 1b       	sub	r28, r26
    78fc:	db 0b       	sbc	r29, r27
    78fe:	0f b6       	in	r0, 0x3f	; 63
    7900:	f8 94       	cli
    7902:	de bf       	out	0x3e, r29	; 62
    7904:	0f be       	out	0x3f, r0	; 63
    7906:	cd bf       	out	0x3d, r28	; 61
    7908:	09 94       	ijmp

0000790a <__epilogue_restores__>:
    790a:	2a 88       	ldd	r2, Y+18	; 0x12
    790c:	39 88       	ldd	r3, Y+17	; 0x11
    790e:	48 88       	ldd	r4, Y+16	; 0x10
    7910:	5f 84       	ldd	r5, Y+15	; 0x0f
    7912:	6e 84       	ldd	r6, Y+14	; 0x0e
    7914:	7d 84       	ldd	r7, Y+13	; 0x0d
    7916:	8c 84       	ldd	r8, Y+12	; 0x0c
    7918:	9b 84       	ldd	r9, Y+11	; 0x0b
    791a:	aa 84       	ldd	r10, Y+10	; 0x0a
    791c:	b9 84       	ldd	r11, Y+9	; 0x09
    791e:	c8 84       	ldd	r12, Y+8	; 0x08
    7920:	df 80       	ldd	r13, Y+7	; 0x07
    7922:	ee 80       	ldd	r14, Y+6	; 0x06
    7924:	fd 80       	ldd	r15, Y+5	; 0x05
    7926:	0c 81       	ldd	r16, Y+4	; 0x04
    7928:	1b 81       	ldd	r17, Y+3	; 0x03
    792a:	aa 81       	ldd	r26, Y+2	; 0x02
    792c:	b9 81       	ldd	r27, Y+1	; 0x01
    792e:	ce 0f       	add	r28, r30
    7930:	d1 1d       	adc	r29, r1
    7932:	0f b6       	in	r0, 0x3f	; 63
    7934:	f8 94       	cli
    7936:	de bf       	out	0x3e, r29	; 62
    7938:	0f be       	out	0x3f, r0	; 63
    793a:	cd bf       	out	0x3d, r28	; 61
    793c:	ed 01       	movw	r28, r26
    793e:	08 95       	ret

00007940 <_exit>:
    7940:	f8 94       	cli

00007942 <__stop_program>:
    7942:	ff cf       	rjmp	.-2      	; 0x7942 <__stop_program>
