
RTOS_2023.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000656e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000002c  00800060  0000656e  00006602  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000006a7  0080008c  0080008c  0000662e  2**0
                  ALLOC
  3 .stab         0000942c  00000000  00000000  00006630  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000057ff  00000000  00000000  0000fa5c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 9a 03 	jmp	0x734	; 0x734 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee e6       	ldi	r30, 0x6E	; 110
      68:	f5 e6       	ldi	r31, 0x65	; 101
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 38       	cpi	r26, 0x8C	; 140
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	ac e8       	ldi	r26, 0x8C	; 140
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 33       	cpi	r26, 0x33	; 51
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 51 31 	call	0x62a2	; 0x62a2 <main>
      8a:	0c 94 b5 32 	jmp	0x656a	; 0x656a <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <pvPortMalloc+0x6>
      98:	00 d0       	rcall	.+0      	; 0x9a <pvPortMalloc+0x8>
      9a:	cd b7       	in	r28, 0x3d	; 61
      9c:	de b7       	in	r29, 0x3e	; 62
      9e:	9c 83       	std	Y+4, r25	; 0x04
      a0:	8b 83       	std	Y+3, r24	; 0x03
    void * pvReturn = NULL;
      a2:	1a 82       	std	Y+2, r1	; 0x02
      a4:	19 82       	std	Y+1, r1	; 0x01
                }
            }
        }
    #endif

    vTaskSuspendAll();
      a6:	0e 94 56 1b 	call	0x36ac	; 0x36ac <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
      aa:	80 91 8e 00 	lds	r24, 0x008E
      ae:	90 91 8f 00 	lds	r25, 0x008F
      b2:	00 97       	sbiw	r24, 0x00	; 0
      b4:	31 f4       	brne	.+12     	; 0xc2 <pvPortMalloc+0x30>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
      b6:	80 e9       	ldi	r24, 0x90	; 144
      b8:	90 e0       	ldi	r25, 0x00	; 0
      ba:	90 93 8f 00 	sts	0x008F, r25
      be:	80 93 8e 00 	sts	0x008E, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
      c2:	8b 81       	ldd	r24, Y+3	; 0x03
      c4:	9c 81       	ldd	r25, Y+4	; 0x04
      c6:	00 97       	sbiw	r24, 0x00	; 0
      c8:	99 f1       	breq	.+102    	; 0x130 <pvPortMalloc+0x9e>
      ca:	80 91 8c 00 	lds	r24, 0x008C
      ce:	90 91 8d 00 	lds	r25, 0x008D
      d2:	2b 81       	ldd	r18, Y+3	; 0x03
      d4:	3c 81       	ldd	r19, Y+4	; 0x04
      d6:	82 0f       	add	r24, r18
      d8:	93 1f       	adc	r25, r19
      da:	25 e0       	ldi	r18, 0x05	; 5
      dc:	8b 3d       	cpi	r24, 0xDB	; 219
      de:	92 07       	cpc	r25, r18
      e0:	38 f5       	brcc	.+78     	; 0x130 <pvPortMalloc+0x9e>
      e2:	20 91 8c 00 	lds	r18, 0x008C
      e6:	30 91 8d 00 	lds	r19, 0x008D
      ea:	8b 81       	ldd	r24, Y+3	; 0x03
      ec:	9c 81       	ldd	r25, Y+4	; 0x04
      ee:	28 0f       	add	r18, r24
      f0:	39 1f       	adc	r19, r25
      f2:	80 91 8c 00 	lds	r24, 0x008C
      f6:	90 91 8d 00 	lds	r25, 0x008D
      fa:	82 17       	cp	r24, r18
      fc:	93 07       	cpc	r25, r19
      fe:	c0 f4       	brcc	.+48     	; 0x130 <pvPortMalloc+0x9e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
     100:	20 91 8e 00 	lds	r18, 0x008E
     104:	30 91 8f 00 	lds	r19, 0x008F
     108:	80 91 8c 00 	lds	r24, 0x008C
     10c:	90 91 8d 00 	lds	r25, 0x008D
     110:	82 0f       	add	r24, r18
     112:	93 1f       	adc	r25, r19
     114:	9a 83       	std	Y+2, r25	; 0x02
     116:	89 83       	std	Y+1, r24	; 0x01
            xNextFreeByte += xWantedSize;
     118:	20 91 8c 00 	lds	r18, 0x008C
     11c:	30 91 8d 00 	lds	r19, 0x008D
     120:	8b 81       	ldd	r24, Y+3	; 0x03
     122:	9c 81       	ldd	r25, Y+4	; 0x04
     124:	82 0f       	add	r24, r18
     126:	93 1f       	adc	r25, r19
     128:	90 93 8d 00 	sts	0x008D, r25
     12c:	80 93 8c 00 	sts	0x008C, r24
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
     130:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
     134:	89 81       	ldd	r24, Y+1	; 0x01
     136:	9a 81       	ldd	r25, Y+2	; 0x02
}
     138:	0f 90       	pop	r0
     13a:	0f 90       	pop	r0
     13c:	0f 90       	pop	r0
     13e:	0f 90       	pop	r0
     140:	cf 91       	pop	r28
     142:	df 91       	pop	r29
     144:	08 95       	ret

00000146 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
     146:	df 93       	push	r29
     148:	cf 93       	push	r28
     14a:	00 d0       	rcall	.+0      	; 0x14c <vPortFree+0x6>
     14c:	cd b7       	in	r28, 0x3d	; 61
     14e:	de b7       	in	r29, 0x3e	; 62
     150:	9a 83       	std	Y+2, r25	; 0x02
     152:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
     154:	0f 90       	pop	r0
     156:	0f 90       	pop	r0
     158:	cf 91       	pop	r28
     15a:	df 91       	pop	r29
     15c:	08 95       	ret

0000015e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     15e:	df 93       	push	r29
     160:	cf 93       	push	r28
     162:	cd b7       	in	r28, 0x3d	; 61
     164:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
     166:	10 92 8d 00 	sts	0x008D, r1
     16a:	10 92 8c 00 	sts	0x008C, r1
}
     16e:	cf 91       	pop	r28
     170:	df 91       	pop	r29
     172:	08 95       	ret

00000174 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     174:	df 93       	push	r29
     176:	cf 93       	push	r28
     178:	cd b7       	in	r28, 0x3d	; 61
     17a:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     17c:	20 91 8c 00 	lds	r18, 0x008C
     180:	30 91 8d 00 	lds	r19, 0x008D
     184:	8b ed       	ldi	r24, 0xDB	; 219
     186:	95 e0       	ldi	r25, 0x05	; 5
     188:	82 1b       	sub	r24, r18
     18a:	93 0b       	sbc	r25, r19
}
     18c:	cf 91       	pop	r28
     18e:	df 91       	pop	r29
     190:	08 95       	ret

00000192 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     192:	df 93       	push	r29
     194:	cf 93       	push	r28
     196:	cd b7       	in	r28, 0x3d	; 61
     198:	de b7       	in	r29, 0x3e	; 62
     19a:	28 97       	sbiw	r28, 0x08	; 8
     19c:	0f b6       	in	r0, 0x3f	; 63
     19e:	f8 94       	cli
     1a0:	de bf       	out	0x3e, r29	; 62
     1a2:	0f be       	out	0x3f, r0	; 63
     1a4:	cd bf       	out	0x3d, r28	; 61
     1a6:	9c 83       	std	Y+4, r25	; 0x04
     1a8:	8b 83       	std	Y+3, r24	; 0x03
     1aa:	7e 83       	std	Y+6, r23	; 0x06
     1ac:	6d 83       	std	Y+5, r22	; 0x05
     1ae:	58 87       	std	Y+8, r21	; 0x08
     1b0:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     1b2:	eb 81       	ldd	r30, Y+3	; 0x03
     1b4:	fc 81       	ldd	r31, Y+4	; 0x04
     1b6:	81 e1       	ldi	r24, 0x11	; 17
     1b8:	80 83       	st	Z, r24
	pxTopOfStack--;
     1ba:	8b 81       	ldd	r24, Y+3	; 0x03
     1bc:	9c 81       	ldd	r25, Y+4	; 0x04
     1be:	01 97       	sbiw	r24, 0x01	; 1
     1c0:	9c 83       	std	Y+4, r25	; 0x04
     1c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     1c4:	eb 81       	ldd	r30, Y+3	; 0x03
     1c6:	fc 81       	ldd	r31, Y+4	; 0x04
     1c8:	82 e2       	ldi	r24, 0x22	; 34
     1ca:	80 83       	st	Z, r24
	pxTopOfStack--;
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	01 97       	sbiw	r24, 0x01	; 1
     1d2:	9c 83       	std	Y+4, r25	; 0x04
     1d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     1d6:	eb 81       	ldd	r30, Y+3	; 0x03
     1d8:	fc 81       	ldd	r31, Y+4	; 0x04
     1da:	83 e3       	ldi	r24, 0x33	; 51
     1dc:	80 83       	st	Z, r24
	pxTopOfStack--;
     1de:	8b 81       	ldd	r24, Y+3	; 0x03
     1e0:	9c 81       	ldd	r25, Y+4	; 0x04
     1e2:	01 97       	sbiw	r24, 0x01	; 1
     1e4:	9c 83       	std	Y+4, r25	; 0x04
     1e6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     1e8:	8d 81       	ldd	r24, Y+5	; 0x05
     1ea:	9e 81       	ldd	r25, Y+6	; 0x06
     1ec:	9a 83       	std	Y+2, r25	; 0x02
     1ee:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     1f0:	89 81       	ldd	r24, Y+1	; 0x01
     1f2:	eb 81       	ldd	r30, Y+3	; 0x03
     1f4:	fc 81       	ldd	r31, Y+4	; 0x04
     1f6:	80 83       	st	Z, r24
	pxTopOfStack--;
     1f8:	8b 81       	ldd	r24, Y+3	; 0x03
     1fa:	9c 81       	ldd	r25, Y+4	; 0x04
     1fc:	01 97       	sbiw	r24, 0x01	; 1
     1fe:	9c 83       	std	Y+4, r25	; 0x04
     200:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     202:	89 81       	ldd	r24, Y+1	; 0x01
     204:	9a 81       	ldd	r25, Y+2	; 0x02
     206:	89 2f       	mov	r24, r25
     208:	99 27       	eor	r25, r25
     20a:	9a 83       	std	Y+2, r25	; 0x02
     20c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     20e:	89 81       	ldd	r24, Y+1	; 0x01
     210:	eb 81       	ldd	r30, Y+3	; 0x03
     212:	fc 81       	ldd	r31, Y+4	; 0x04
     214:	80 83       	st	Z, r24
	pxTopOfStack--;
     216:	8b 81       	ldd	r24, Y+3	; 0x03
     218:	9c 81       	ldd	r25, Y+4	; 0x04
     21a:	01 97       	sbiw	r24, 0x01	; 1
     21c:	9c 83       	std	Y+4, r25	; 0x04
     21e:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     220:	eb 81       	ldd	r30, Y+3	; 0x03
     222:	fc 81       	ldd	r31, Y+4	; 0x04
     224:	10 82       	st	Z, r1
	pxTopOfStack--;
     226:	8b 81       	ldd	r24, Y+3	; 0x03
     228:	9c 81       	ldd	r25, Y+4	; 0x04
     22a:	01 97       	sbiw	r24, 0x01	; 1
     22c:	9c 83       	std	Y+4, r25	; 0x04
     22e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     230:	eb 81       	ldd	r30, Y+3	; 0x03
     232:	fc 81       	ldd	r31, Y+4	; 0x04
     234:	80 e8       	ldi	r24, 0x80	; 128
     236:	80 83       	st	Z, r24
	pxTopOfStack--;
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	01 97       	sbiw	r24, 0x01	; 1
     23e:	9c 83       	std	Y+4, r25	; 0x04
     240:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     242:	eb 81       	ldd	r30, Y+3	; 0x03
     244:	fc 81       	ldd	r31, Y+4	; 0x04
     246:	10 82       	st	Z, r1
	pxTopOfStack--;
     248:	8b 81       	ldd	r24, Y+3	; 0x03
     24a:	9c 81       	ldd	r25, Y+4	; 0x04
     24c:	01 97       	sbiw	r24, 0x01	; 1
     24e:	9c 83       	std	Y+4, r25	; 0x04
     250:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     252:	eb 81       	ldd	r30, Y+3	; 0x03
     254:	fc 81       	ldd	r31, Y+4	; 0x04
     256:	82 e0       	ldi	r24, 0x02	; 2
     258:	80 83       	st	Z, r24
	pxTopOfStack--;
     25a:	8b 81       	ldd	r24, Y+3	; 0x03
     25c:	9c 81       	ldd	r25, Y+4	; 0x04
     25e:	01 97       	sbiw	r24, 0x01	; 1
     260:	9c 83       	std	Y+4, r25	; 0x04
     262:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     264:	eb 81       	ldd	r30, Y+3	; 0x03
     266:	fc 81       	ldd	r31, Y+4	; 0x04
     268:	83 e0       	ldi	r24, 0x03	; 3
     26a:	80 83       	st	Z, r24
	pxTopOfStack--;
     26c:	8b 81       	ldd	r24, Y+3	; 0x03
     26e:	9c 81       	ldd	r25, Y+4	; 0x04
     270:	01 97       	sbiw	r24, 0x01	; 1
     272:	9c 83       	std	Y+4, r25	; 0x04
     274:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     276:	eb 81       	ldd	r30, Y+3	; 0x03
     278:	fc 81       	ldd	r31, Y+4	; 0x04
     27a:	84 e0       	ldi	r24, 0x04	; 4
     27c:	80 83       	st	Z, r24
	pxTopOfStack--;
     27e:	8b 81       	ldd	r24, Y+3	; 0x03
     280:	9c 81       	ldd	r25, Y+4	; 0x04
     282:	01 97       	sbiw	r24, 0x01	; 1
     284:	9c 83       	std	Y+4, r25	; 0x04
     286:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     288:	eb 81       	ldd	r30, Y+3	; 0x03
     28a:	fc 81       	ldd	r31, Y+4	; 0x04
     28c:	85 e0       	ldi	r24, 0x05	; 5
     28e:	80 83       	st	Z, r24
	pxTopOfStack--;
     290:	8b 81       	ldd	r24, Y+3	; 0x03
     292:	9c 81       	ldd	r25, Y+4	; 0x04
     294:	01 97       	sbiw	r24, 0x01	; 1
     296:	9c 83       	std	Y+4, r25	; 0x04
     298:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     29a:	eb 81       	ldd	r30, Y+3	; 0x03
     29c:	fc 81       	ldd	r31, Y+4	; 0x04
     29e:	86 e0       	ldi	r24, 0x06	; 6
     2a0:	80 83       	st	Z, r24
	pxTopOfStack--;
     2a2:	8b 81       	ldd	r24, Y+3	; 0x03
     2a4:	9c 81       	ldd	r25, Y+4	; 0x04
     2a6:	01 97       	sbiw	r24, 0x01	; 1
     2a8:	9c 83       	std	Y+4, r25	; 0x04
     2aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     2ac:	eb 81       	ldd	r30, Y+3	; 0x03
     2ae:	fc 81       	ldd	r31, Y+4	; 0x04
     2b0:	87 e0       	ldi	r24, 0x07	; 7
     2b2:	80 83       	st	Z, r24
	pxTopOfStack--;
     2b4:	8b 81       	ldd	r24, Y+3	; 0x03
     2b6:	9c 81       	ldd	r25, Y+4	; 0x04
     2b8:	01 97       	sbiw	r24, 0x01	; 1
     2ba:	9c 83       	std	Y+4, r25	; 0x04
     2bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     2be:	eb 81       	ldd	r30, Y+3	; 0x03
     2c0:	fc 81       	ldd	r31, Y+4	; 0x04
     2c2:	88 e0       	ldi	r24, 0x08	; 8
     2c4:	80 83       	st	Z, r24
	pxTopOfStack--;
     2c6:	8b 81       	ldd	r24, Y+3	; 0x03
     2c8:	9c 81       	ldd	r25, Y+4	; 0x04
     2ca:	01 97       	sbiw	r24, 0x01	; 1
     2cc:	9c 83       	std	Y+4, r25	; 0x04
     2ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     2d0:	eb 81       	ldd	r30, Y+3	; 0x03
     2d2:	fc 81       	ldd	r31, Y+4	; 0x04
     2d4:	89 e0       	ldi	r24, 0x09	; 9
     2d6:	80 83       	st	Z, r24
	pxTopOfStack--;
     2d8:	8b 81       	ldd	r24, Y+3	; 0x03
     2da:	9c 81       	ldd	r25, Y+4	; 0x04
     2dc:	01 97       	sbiw	r24, 0x01	; 1
     2de:	9c 83       	std	Y+4, r25	; 0x04
     2e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     2e2:	eb 81       	ldd	r30, Y+3	; 0x03
     2e4:	fc 81       	ldd	r31, Y+4	; 0x04
     2e6:	80 e1       	ldi	r24, 0x10	; 16
     2e8:	80 83       	st	Z, r24
	pxTopOfStack--;
     2ea:	8b 81       	ldd	r24, Y+3	; 0x03
     2ec:	9c 81       	ldd	r25, Y+4	; 0x04
     2ee:	01 97       	sbiw	r24, 0x01	; 1
     2f0:	9c 83       	std	Y+4, r25	; 0x04
     2f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     2f4:	eb 81       	ldd	r30, Y+3	; 0x03
     2f6:	fc 81       	ldd	r31, Y+4	; 0x04
     2f8:	81 e1       	ldi	r24, 0x11	; 17
     2fa:	80 83       	st	Z, r24
	pxTopOfStack--;
     2fc:	8b 81       	ldd	r24, Y+3	; 0x03
     2fe:	9c 81       	ldd	r25, Y+4	; 0x04
     300:	01 97       	sbiw	r24, 0x01	; 1
     302:	9c 83       	std	Y+4, r25	; 0x04
     304:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     306:	eb 81       	ldd	r30, Y+3	; 0x03
     308:	fc 81       	ldd	r31, Y+4	; 0x04
     30a:	82 e1       	ldi	r24, 0x12	; 18
     30c:	80 83       	st	Z, r24
	pxTopOfStack--;
     30e:	8b 81       	ldd	r24, Y+3	; 0x03
     310:	9c 81       	ldd	r25, Y+4	; 0x04
     312:	01 97       	sbiw	r24, 0x01	; 1
     314:	9c 83       	std	Y+4, r25	; 0x04
     316:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     318:	eb 81       	ldd	r30, Y+3	; 0x03
     31a:	fc 81       	ldd	r31, Y+4	; 0x04
     31c:	83 e1       	ldi	r24, 0x13	; 19
     31e:	80 83       	st	Z, r24
	pxTopOfStack--;
     320:	8b 81       	ldd	r24, Y+3	; 0x03
     322:	9c 81       	ldd	r25, Y+4	; 0x04
     324:	01 97       	sbiw	r24, 0x01	; 1
     326:	9c 83       	std	Y+4, r25	; 0x04
     328:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     32a:	eb 81       	ldd	r30, Y+3	; 0x03
     32c:	fc 81       	ldd	r31, Y+4	; 0x04
     32e:	84 e1       	ldi	r24, 0x14	; 20
     330:	80 83       	st	Z, r24
	pxTopOfStack--;
     332:	8b 81       	ldd	r24, Y+3	; 0x03
     334:	9c 81       	ldd	r25, Y+4	; 0x04
     336:	01 97       	sbiw	r24, 0x01	; 1
     338:	9c 83       	std	Y+4, r25	; 0x04
     33a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     33c:	eb 81       	ldd	r30, Y+3	; 0x03
     33e:	fc 81       	ldd	r31, Y+4	; 0x04
     340:	85 e1       	ldi	r24, 0x15	; 21
     342:	80 83       	st	Z, r24
	pxTopOfStack--;
     344:	8b 81       	ldd	r24, Y+3	; 0x03
     346:	9c 81       	ldd	r25, Y+4	; 0x04
     348:	01 97       	sbiw	r24, 0x01	; 1
     34a:	9c 83       	std	Y+4, r25	; 0x04
     34c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     34e:	eb 81       	ldd	r30, Y+3	; 0x03
     350:	fc 81       	ldd	r31, Y+4	; 0x04
     352:	86 e1       	ldi	r24, 0x16	; 22
     354:	80 83       	st	Z, r24
	pxTopOfStack--;
     356:	8b 81       	ldd	r24, Y+3	; 0x03
     358:	9c 81       	ldd	r25, Y+4	; 0x04
     35a:	01 97       	sbiw	r24, 0x01	; 1
     35c:	9c 83       	std	Y+4, r25	; 0x04
     35e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     360:	eb 81       	ldd	r30, Y+3	; 0x03
     362:	fc 81       	ldd	r31, Y+4	; 0x04
     364:	87 e1       	ldi	r24, 0x17	; 23
     366:	80 83       	st	Z, r24
	pxTopOfStack--;
     368:	8b 81       	ldd	r24, Y+3	; 0x03
     36a:	9c 81       	ldd	r25, Y+4	; 0x04
     36c:	01 97       	sbiw	r24, 0x01	; 1
     36e:	9c 83       	std	Y+4, r25	; 0x04
     370:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     372:	eb 81       	ldd	r30, Y+3	; 0x03
     374:	fc 81       	ldd	r31, Y+4	; 0x04
     376:	88 e1       	ldi	r24, 0x18	; 24
     378:	80 83       	st	Z, r24
	pxTopOfStack--;
     37a:	8b 81       	ldd	r24, Y+3	; 0x03
     37c:	9c 81       	ldd	r25, Y+4	; 0x04
     37e:	01 97       	sbiw	r24, 0x01	; 1
     380:	9c 83       	std	Y+4, r25	; 0x04
     382:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     384:	eb 81       	ldd	r30, Y+3	; 0x03
     386:	fc 81       	ldd	r31, Y+4	; 0x04
     388:	89 e1       	ldi	r24, 0x19	; 25
     38a:	80 83       	st	Z, r24
	pxTopOfStack--;
     38c:	8b 81       	ldd	r24, Y+3	; 0x03
     38e:	9c 81       	ldd	r25, Y+4	; 0x04
     390:	01 97       	sbiw	r24, 0x01	; 1
     392:	9c 83       	std	Y+4, r25	; 0x04
     394:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     396:	eb 81       	ldd	r30, Y+3	; 0x03
     398:	fc 81       	ldd	r31, Y+4	; 0x04
     39a:	80 e2       	ldi	r24, 0x20	; 32
     39c:	80 83       	st	Z, r24
	pxTopOfStack--;
     39e:	8b 81       	ldd	r24, Y+3	; 0x03
     3a0:	9c 81       	ldd	r25, Y+4	; 0x04
     3a2:	01 97       	sbiw	r24, 0x01	; 1
     3a4:	9c 83       	std	Y+4, r25	; 0x04
     3a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     3a8:	eb 81       	ldd	r30, Y+3	; 0x03
     3aa:	fc 81       	ldd	r31, Y+4	; 0x04
     3ac:	81 e2       	ldi	r24, 0x21	; 33
     3ae:	80 83       	st	Z, r24
	pxTopOfStack--;
     3b0:	8b 81       	ldd	r24, Y+3	; 0x03
     3b2:	9c 81       	ldd	r25, Y+4	; 0x04
     3b4:	01 97       	sbiw	r24, 0x01	; 1
     3b6:	9c 83       	std	Y+4, r25	; 0x04
     3b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     3ba:	eb 81       	ldd	r30, Y+3	; 0x03
     3bc:	fc 81       	ldd	r31, Y+4	; 0x04
     3be:	82 e2       	ldi	r24, 0x22	; 34
     3c0:	80 83       	st	Z, r24
	pxTopOfStack--;
     3c2:	8b 81       	ldd	r24, Y+3	; 0x03
     3c4:	9c 81       	ldd	r25, Y+4	; 0x04
     3c6:	01 97       	sbiw	r24, 0x01	; 1
     3c8:	9c 83       	std	Y+4, r25	; 0x04
     3ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     3cc:	eb 81       	ldd	r30, Y+3	; 0x03
     3ce:	fc 81       	ldd	r31, Y+4	; 0x04
     3d0:	83 e2       	ldi	r24, 0x23	; 35
     3d2:	80 83       	st	Z, r24
	pxTopOfStack--;
     3d4:	8b 81       	ldd	r24, Y+3	; 0x03
     3d6:	9c 81       	ldd	r25, Y+4	; 0x04
     3d8:	01 97       	sbiw	r24, 0x01	; 1
     3da:	9c 83       	std	Y+4, r25	; 0x04
     3dc:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     3de:	8f 81       	ldd	r24, Y+7	; 0x07
     3e0:	98 85       	ldd	r25, Y+8	; 0x08
     3e2:	9a 83       	std	Y+2, r25	; 0x02
     3e4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     3e6:	89 81       	ldd	r24, Y+1	; 0x01
     3e8:	eb 81       	ldd	r30, Y+3	; 0x03
     3ea:	fc 81       	ldd	r31, Y+4	; 0x04
     3ec:	80 83       	st	Z, r24
	pxTopOfStack--;
     3ee:	8b 81       	ldd	r24, Y+3	; 0x03
     3f0:	9c 81       	ldd	r25, Y+4	; 0x04
     3f2:	01 97       	sbiw	r24, 0x01	; 1
     3f4:	9c 83       	std	Y+4, r25	; 0x04
     3f6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     3f8:	89 81       	ldd	r24, Y+1	; 0x01
     3fa:	9a 81       	ldd	r25, Y+2	; 0x02
     3fc:	89 2f       	mov	r24, r25
     3fe:	99 27       	eor	r25, r25
     400:	9a 83       	std	Y+2, r25	; 0x02
     402:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     404:	89 81       	ldd	r24, Y+1	; 0x01
     406:	eb 81       	ldd	r30, Y+3	; 0x03
     408:	fc 81       	ldd	r31, Y+4	; 0x04
     40a:	80 83       	st	Z, r24
	pxTopOfStack--;
     40c:	8b 81       	ldd	r24, Y+3	; 0x03
     40e:	9c 81       	ldd	r25, Y+4	; 0x04
     410:	01 97       	sbiw	r24, 0x01	; 1
     412:	9c 83       	std	Y+4, r25	; 0x04
     414:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     416:	eb 81       	ldd	r30, Y+3	; 0x03
     418:	fc 81       	ldd	r31, Y+4	; 0x04
     41a:	86 e2       	ldi	r24, 0x26	; 38
     41c:	80 83       	st	Z, r24
	pxTopOfStack--;
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	9c 81       	ldd	r25, Y+4	; 0x04
     422:	01 97       	sbiw	r24, 0x01	; 1
     424:	9c 83       	std	Y+4, r25	; 0x04
     426:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     428:	eb 81       	ldd	r30, Y+3	; 0x03
     42a:	fc 81       	ldd	r31, Y+4	; 0x04
     42c:	87 e2       	ldi	r24, 0x27	; 39
     42e:	80 83       	st	Z, r24
	pxTopOfStack--;
     430:	8b 81       	ldd	r24, Y+3	; 0x03
     432:	9c 81       	ldd	r25, Y+4	; 0x04
     434:	01 97       	sbiw	r24, 0x01	; 1
     436:	9c 83       	std	Y+4, r25	; 0x04
     438:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     43a:	eb 81       	ldd	r30, Y+3	; 0x03
     43c:	fc 81       	ldd	r31, Y+4	; 0x04
     43e:	88 e2       	ldi	r24, 0x28	; 40
     440:	80 83       	st	Z, r24
	pxTopOfStack--;
     442:	8b 81       	ldd	r24, Y+3	; 0x03
     444:	9c 81       	ldd	r25, Y+4	; 0x04
     446:	01 97       	sbiw	r24, 0x01	; 1
     448:	9c 83       	std	Y+4, r25	; 0x04
     44a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     44c:	eb 81       	ldd	r30, Y+3	; 0x03
     44e:	fc 81       	ldd	r31, Y+4	; 0x04
     450:	89 e2       	ldi	r24, 0x29	; 41
     452:	80 83       	st	Z, r24
	pxTopOfStack--;
     454:	8b 81       	ldd	r24, Y+3	; 0x03
     456:	9c 81       	ldd	r25, Y+4	; 0x04
     458:	01 97       	sbiw	r24, 0x01	; 1
     45a:	9c 83       	std	Y+4, r25	; 0x04
     45c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     45e:	eb 81       	ldd	r30, Y+3	; 0x03
     460:	fc 81       	ldd	r31, Y+4	; 0x04
     462:	80 e3       	ldi	r24, 0x30	; 48
     464:	80 83       	st	Z, r24
	pxTopOfStack--;
     466:	8b 81       	ldd	r24, Y+3	; 0x03
     468:	9c 81       	ldd	r25, Y+4	; 0x04
     46a:	01 97       	sbiw	r24, 0x01	; 1
     46c:	9c 83       	std	Y+4, r25	; 0x04
     46e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     470:	eb 81       	ldd	r30, Y+3	; 0x03
     472:	fc 81       	ldd	r31, Y+4	; 0x04
     474:	81 e3       	ldi	r24, 0x31	; 49
     476:	80 83       	st	Z, r24
	pxTopOfStack--;
     478:	8b 81       	ldd	r24, Y+3	; 0x03
     47a:	9c 81       	ldd	r25, Y+4	; 0x04
     47c:	01 97       	sbiw	r24, 0x01	; 1
     47e:	9c 83       	std	Y+4, r25	; 0x04
     480:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     482:	8b 81       	ldd	r24, Y+3	; 0x03
     484:	9c 81       	ldd	r25, Y+4	; 0x04
}
     486:	28 96       	adiw	r28, 0x08	; 8
     488:	0f b6       	in	r0, 0x3f	; 63
     48a:	f8 94       	cli
     48c:	de bf       	out	0x3e, r29	; 62
     48e:	0f be       	out	0x3f, r0	; 63
     490:	cd bf       	out	0x3d, r28	; 61
     492:	cf 91       	pop	r28
     494:	df 91       	pop	r29
     496:	08 95       	ret

00000498 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     498:	df 93       	push	r29
     49a:	cf 93       	push	r28
     49c:	cd b7       	in	r28, 0x3d	; 61
     49e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     4a0:	0e 94 3e 03 	call	0x67c	; 0x67c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     4a4:	a0 91 a6 06 	lds	r26, 0x06A6
     4a8:	b0 91 a7 06 	lds	r27, 0x06A7
     4ac:	cd 91       	ld	r28, X+
     4ae:	cd bf       	out	0x3d, r28	; 61
     4b0:	dd 91       	ld	r29, X+
     4b2:	de bf       	out	0x3e, r29	; 62
     4b4:	ff 91       	pop	r31
     4b6:	ef 91       	pop	r30
     4b8:	df 91       	pop	r29
     4ba:	cf 91       	pop	r28
     4bc:	bf 91       	pop	r27
     4be:	af 91       	pop	r26
     4c0:	9f 91       	pop	r25
     4c2:	8f 91       	pop	r24
     4c4:	7f 91       	pop	r23
     4c6:	6f 91       	pop	r22
     4c8:	5f 91       	pop	r21
     4ca:	4f 91       	pop	r20
     4cc:	3f 91       	pop	r19
     4ce:	2f 91       	pop	r18
     4d0:	1f 91       	pop	r17
     4d2:	0f 91       	pop	r16
     4d4:	ff 90       	pop	r15
     4d6:	ef 90       	pop	r14
     4d8:	df 90       	pop	r13
     4da:	cf 90       	pop	r12
     4dc:	bf 90       	pop	r11
     4de:	af 90       	pop	r10
     4e0:	9f 90       	pop	r9
     4e2:	8f 90       	pop	r8
     4e4:	7f 90       	pop	r7
     4e6:	6f 90       	pop	r6
     4e8:	5f 90       	pop	r5
     4ea:	4f 90       	pop	r4
     4ec:	3f 90       	pop	r3
     4ee:	2f 90       	pop	r2
     4f0:	1f 90       	pop	r1
     4f2:	0f 90       	pop	r0
     4f4:	0f be       	out	0x3f, r0	; 63
     4f6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     4f8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     4fa:	81 e0       	ldi	r24, 0x01	; 1
}
     4fc:	cf 91       	pop	r28
     4fe:	df 91       	pop	r29
     500:	08 95       	ret

00000502 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     502:	df 93       	push	r29
     504:	cf 93       	push	r28
     506:	cd b7       	in	r28, 0x3d	; 61
     508:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     50a:	cf 91       	pop	r28
     50c:	df 91       	pop	r29
     50e:	08 95       	ret

00000510 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     510:	0f 92       	push	r0
     512:	0f b6       	in	r0, 0x3f	; 63
     514:	f8 94       	cli
     516:	0f 92       	push	r0
     518:	1f 92       	push	r1
     51a:	11 24       	eor	r1, r1
     51c:	2f 92       	push	r2
     51e:	3f 92       	push	r3
     520:	4f 92       	push	r4
     522:	5f 92       	push	r5
     524:	6f 92       	push	r6
     526:	7f 92       	push	r7
     528:	8f 92       	push	r8
     52a:	9f 92       	push	r9
     52c:	af 92       	push	r10
     52e:	bf 92       	push	r11
     530:	cf 92       	push	r12
     532:	df 92       	push	r13
     534:	ef 92       	push	r14
     536:	ff 92       	push	r15
     538:	0f 93       	push	r16
     53a:	1f 93       	push	r17
     53c:	2f 93       	push	r18
     53e:	3f 93       	push	r19
     540:	4f 93       	push	r20
     542:	5f 93       	push	r21
     544:	6f 93       	push	r22
     546:	7f 93       	push	r23
     548:	8f 93       	push	r24
     54a:	9f 93       	push	r25
     54c:	af 93       	push	r26
     54e:	bf 93       	push	r27
     550:	cf 93       	push	r28
     552:	df 93       	push	r29
     554:	ef 93       	push	r30
     556:	ff 93       	push	r31
     558:	a0 91 a6 06 	lds	r26, 0x06A6
     55c:	b0 91 a7 06 	lds	r27, 0x06A7
     560:	0d b6       	in	r0, 0x3d	; 61
     562:	0d 92       	st	X+, r0
     564:	0e b6       	in	r0, 0x3e	; 62
     566:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     568:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     56c:	a0 91 a6 06 	lds	r26, 0x06A6
     570:	b0 91 a7 06 	lds	r27, 0x06A7
     574:	cd 91       	ld	r28, X+
     576:	cd bf       	out	0x3d, r28	; 61
     578:	dd 91       	ld	r29, X+
     57a:	de bf       	out	0x3e, r29	; 62
     57c:	ff 91       	pop	r31
     57e:	ef 91       	pop	r30
     580:	df 91       	pop	r29
     582:	cf 91       	pop	r28
     584:	bf 91       	pop	r27
     586:	af 91       	pop	r26
     588:	9f 91       	pop	r25
     58a:	8f 91       	pop	r24
     58c:	7f 91       	pop	r23
     58e:	6f 91       	pop	r22
     590:	5f 91       	pop	r21
     592:	4f 91       	pop	r20
     594:	3f 91       	pop	r19
     596:	2f 91       	pop	r18
     598:	1f 91       	pop	r17
     59a:	0f 91       	pop	r16
     59c:	ff 90       	pop	r15
     59e:	ef 90       	pop	r14
     5a0:	df 90       	pop	r13
     5a2:	cf 90       	pop	r12
     5a4:	bf 90       	pop	r11
     5a6:	af 90       	pop	r10
     5a8:	9f 90       	pop	r9
     5aa:	8f 90       	pop	r8
     5ac:	7f 90       	pop	r7
     5ae:	6f 90       	pop	r6
     5b0:	5f 90       	pop	r5
     5b2:	4f 90       	pop	r4
     5b4:	3f 90       	pop	r3
     5b6:	2f 90       	pop	r2
     5b8:	1f 90       	pop	r1
     5ba:	0f 90       	pop	r0
     5bc:	0f be       	out	0x3f, r0	; 63
     5be:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5c0:	08 95       	ret

000005c2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     5c2:	0f 92       	push	r0
     5c4:	0f b6       	in	r0, 0x3f	; 63
     5c6:	f8 94       	cli
     5c8:	0f 92       	push	r0
     5ca:	1f 92       	push	r1
     5cc:	11 24       	eor	r1, r1
     5ce:	2f 92       	push	r2
     5d0:	3f 92       	push	r3
     5d2:	4f 92       	push	r4
     5d4:	5f 92       	push	r5
     5d6:	6f 92       	push	r6
     5d8:	7f 92       	push	r7
     5da:	8f 92       	push	r8
     5dc:	9f 92       	push	r9
     5de:	af 92       	push	r10
     5e0:	bf 92       	push	r11
     5e2:	cf 92       	push	r12
     5e4:	df 92       	push	r13
     5e6:	ef 92       	push	r14
     5e8:	ff 92       	push	r15
     5ea:	0f 93       	push	r16
     5ec:	1f 93       	push	r17
     5ee:	2f 93       	push	r18
     5f0:	3f 93       	push	r19
     5f2:	4f 93       	push	r20
     5f4:	5f 93       	push	r21
     5f6:	6f 93       	push	r22
     5f8:	7f 93       	push	r23
     5fa:	8f 93       	push	r24
     5fc:	9f 93       	push	r25
     5fe:	af 93       	push	r26
     600:	bf 93       	push	r27
     602:	cf 93       	push	r28
     604:	df 93       	push	r29
     606:	ef 93       	push	r30
     608:	ff 93       	push	r31
     60a:	a0 91 a6 06 	lds	r26, 0x06A6
     60e:	b0 91 a7 06 	lds	r27, 0x06A7
     612:	0d b6       	in	r0, 0x3d	; 61
     614:	0d 92       	st	X+, r0
     616:	0e b6       	in	r0, 0x3e	; 62
     618:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     61a:	0e 94 2f 1d 	call	0x3a5e	; 0x3a5e <xTaskIncrementTick>
     61e:	88 23       	and	r24, r24
     620:	11 f0       	breq	.+4      	; 0x626 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     622:	0e 94 c6 1e 	call	0x3d8c	; 0x3d8c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     626:	a0 91 a6 06 	lds	r26, 0x06A6
     62a:	b0 91 a7 06 	lds	r27, 0x06A7
     62e:	cd 91       	ld	r28, X+
     630:	cd bf       	out	0x3d, r28	; 61
     632:	dd 91       	ld	r29, X+
     634:	de bf       	out	0x3e, r29	; 62
     636:	ff 91       	pop	r31
     638:	ef 91       	pop	r30
     63a:	df 91       	pop	r29
     63c:	cf 91       	pop	r28
     63e:	bf 91       	pop	r27
     640:	af 91       	pop	r26
     642:	9f 91       	pop	r25
     644:	8f 91       	pop	r24
     646:	7f 91       	pop	r23
     648:	6f 91       	pop	r22
     64a:	5f 91       	pop	r21
     64c:	4f 91       	pop	r20
     64e:	3f 91       	pop	r19
     650:	2f 91       	pop	r18
     652:	1f 91       	pop	r17
     654:	0f 91       	pop	r16
     656:	ff 90       	pop	r15
     658:	ef 90       	pop	r14
     65a:	df 90       	pop	r13
     65c:	cf 90       	pop	r12
     65e:	bf 90       	pop	r11
     660:	af 90       	pop	r10
     662:	9f 90       	pop	r9
     664:	8f 90       	pop	r8
     666:	7f 90       	pop	r7
     668:	6f 90       	pop	r6
     66a:	5f 90       	pop	r5
     66c:	4f 90       	pop	r4
     66e:	3f 90       	pop	r3
     670:	2f 90       	pop	r2
     672:	1f 90       	pop	r1
     674:	0f 90       	pop	r0
     676:	0f be       	out	0x3f, r0	; 63
     678:	0f 90       	pop	r0

	asm volatile ( "ret" );
     67a:	08 95       	ret

0000067c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     67c:	df 93       	push	r29
     67e:	cf 93       	push	r28
     680:	00 d0       	rcall	.+0      	; 0x682 <prvSetupTimerInterrupt+0x6>
     682:	00 d0       	rcall	.+0      	; 0x684 <prvSetupTimerInterrupt+0x8>
     684:	00 d0       	rcall	.+0      	; 0x686 <prvSetupTimerInterrupt+0xa>
     686:	cd b7       	in	r28, 0x3d	; 61
     688:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     68a:	80 e4       	ldi	r24, 0x40	; 64
     68c:	9f e1       	ldi	r25, 0x1F	; 31
     68e:	a0 e0       	ldi	r26, 0x00	; 0
     690:	b0 e0       	ldi	r27, 0x00	; 0
     692:	8b 83       	std	Y+3, r24	; 0x03
     694:	9c 83       	std	Y+4, r25	; 0x04
     696:	ad 83       	std	Y+5, r26	; 0x05
     698:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     69a:	8b 81       	ldd	r24, Y+3	; 0x03
     69c:	9c 81       	ldd	r25, Y+4	; 0x04
     69e:	ad 81       	ldd	r26, Y+5	; 0x05
     6a0:	be 81       	ldd	r27, Y+6	; 0x06
     6a2:	68 94       	set
     6a4:	15 f8       	bld	r1, 5
     6a6:	b6 95       	lsr	r27
     6a8:	a7 95       	ror	r26
     6aa:	97 95       	ror	r25
     6ac:	87 95       	ror	r24
     6ae:	16 94       	lsr	r1
     6b0:	d1 f7       	brne	.-12     	; 0x6a6 <prvSetupTimerInterrupt+0x2a>
     6b2:	8b 83       	std	Y+3, r24	; 0x03
     6b4:	9c 83       	std	Y+4, r25	; 0x04
     6b6:	ad 83       	std	Y+5, r26	; 0x05
     6b8:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     6ba:	8b 81       	ldd	r24, Y+3	; 0x03
     6bc:	9c 81       	ldd	r25, Y+4	; 0x04
     6be:	ad 81       	ldd	r26, Y+5	; 0x05
     6c0:	be 81       	ldd	r27, Y+6	; 0x06
     6c2:	01 97       	sbiw	r24, 0x01	; 1
     6c4:	a1 09       	sbc	r26, r1
     6c6:	b1 09       	sbc	r27, r1
     6c8:	8b 83       	std	Y+3, r24	; 0x03
     6ca:	9c 83       	std	Y+4, r25	; 0x04
     6cc:	ad 83       	std	Y+5, r26	; 0x05
     6ce:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     6d0:	8b 81       	ldd	r24, Y+3	; 0x03
     6d2:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     6d4:	8b 81       	ldd	r24, Y+3	; 0x03
     6d6:	9c 81       	ldd	r25, Y+4	; 0x04
     6d8:	ad 81       	ldd	r26, Y+5	; 0x05
     6da:	be 81       	ldd	r27, Y+6	; 0x06
     6dc:	89 2f       	mov	r24, r25
     6de:	9a 2f       	mov	r25, r26
     6e0:	ab 2f       	mov	r26, r27
     6e2:	bb 27       	eor	r27, r27
     6e4:	8b 83       	std	Y+3, r24	; 0x03
     6e6:	9c 83       	std	Y+4, r25	; 0x04
     6e8:	ad 83       	std	Y+5, r26	; 0x05
     6ea:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     6ec:	8b 81       	ldd	r24, Y+3	; 0x03
     6ee:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     6f0:	eb e4       	ldi	r30, 0x4B	; 75
     6f2:	f0 e0       	ldi	r31, 0x00	; 0
     6f4:	8a 81       	ldd	r24, Y+2	; 0x02
     6f6:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     6f8:	ea e4       	ldi	r30, 0x4A	; 74
     6fa:	f0 e0       	ldi	r31, 0x00	; 0
     6fc:	89 81       	ldd	r24, Y+1	; 0x01
     6fe:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     700:	8b e0       	ldi	r24, 0x0B	; 11
     702:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     704:	ee e4       	ldi	r30, 0x4E	; 78
     706:	f0 e0       	ldi	r31, 0x00	; 0
     708:	89 81       	ldd	r24, Y+1	; 0x01
     70a:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     70c:	e9 e5       	ldi	r30, 0x59	; 89
     70e:	f0 e0       	ldi	r31, 0x00	; 0
     710:	80 81       	ld	r24, Z
     712:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     714:	89 81       	ldd	r24, Y+1	; 0x01
     716:	80 61       	ori	r24, 0x10	; 16
     718:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
     71a:	e9 e5       	ldi	r30, 0x59	; 89
     71c:	f0 e0       	ldi	r31, 0x00	; 0
     71e:	89 81       	ldd	r24, Y+1	; 0x01
     720:	80 83       	st	Z, r24
}
     722:	26 96       	adiw	r28, 0x06	; 6
     724:	0f b6       	in	r0, 0x3f	; 63
     726:	f8 94       	cli
     728:	de bf       	out	0x3e, r29	; 62
     72a:	0f be       	out	0x3f, r0	; 63
     72c:	cd bf       	out	0x3d, r28	; 61
     72e:	cf 91       	pop	r28
     730:	df 91       	pop	r29
     732:	08 95       	ret

00000734 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     734:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vPortYieldFromTick>
		asm volatile ( "reti" );
     738:	18 95       	reti

0000073a <DIO_SetPinDir>:


#include "DIO.h"

void DIO_SetPinDir(uint8_t port ,uint8_t pin, uint8_t dir)
{
     73a:	df 93       	push	r29
     73c:	cf 93       	push	r28
     73e:	cd b7       	in	r28, 0x3d	; 61
     740:	de b7       	in	r29, 0x3e	; 62
     742:	2d 97       	sbiw	r28, 0x0d	; 13
     744:	0f b6       	in	r0, 0x3f	; 63
     746:	f8 94       	cli
     748:	de bf       	out	0x3e, r29	; 62
     74a:	0f be       	out	0x3f, r0	; 63
     74c:	cd bf       	out	0x3d, r28	; 61
     74e:	89 83       	std	Y+1, r24	; 0x01
     750:	6a 83       	std	Y+2, r22	; 0x02
     752:	4b 83       	std	Y+3, r20	; 0x03
	switch (port)
     754:	89 81       	ldd	r24, Y+1	; 0x01
     756:	28 2f       	mov	r18, r24
     758:	30 e0       	ldi	r19, 0x00	; 0
     75a:	3d 87       	std	Y+13, r19	; 0x0d
     75c:	2c 87       	std	Y+12, r18	; 0x0c
     75e:	8c 85       	ldd	r24, Y+12	; 0x0c
     760:	9d 85       	ldd	r25, Y+13	; 0x0d
     762:	81 30       	cpi	r24, 0x01	; 1
     764:	91 05       	cpc	r25, r1
     766:	09 f4       	brne	.+2      	; 0x76a <DIO_SetPinDir+0x30>
     768:	44 c0       	rjmp	.+136    	; 0x7f2 <DIO_SetPinDir+0xb8>
     76a:	2c 85       	ldd	r18, Y+12	; 0x0c
     76c:	3d 85       	ldd	r19, Y+13	; 0x0d
     76e:	22 30       	cpi	r18, 0x02	; 2
     770:	31 05       	cpc	r19, r1
     772:	2c f4       	brge	.+10     	; 0x77e <DIO_SetPinDir+0x44>
     774:	8c 85       	ldd	r24, Y+12	; 0x0c
     776:	9d 85       	ldd	r25, Y+13	; 0x0d
     778:	00 97       	sbiw	r24, 0x00	; 0
     77a:	71 f0       	breq	.+28     	; 0x798 <DIO_SetPinDir+0x5e>
     77c:	c2 c0       	rjmp	.+388    	; 0x902 <__stack+0xa3>
     77e:	2c 85       	ldd	r18, Y+12	; 0x0c
     780:	3d 85       	ldd	r19, Y+13	; 0x0d
     782:	22 30       	cpi	r18, 0x02	; 2
     784:	31 05       	cpc	r19, r1
     786:	09 f4       	brne	.+2      	; 0x78a <DIO_SetPinDir+0x50>
     788:	62 c0       	rjmp	.+196    	; 0x84e <DIO_SetPinDir+0x114>
     78a:	8c 85       	ldd	r24, Y+12	; 0x0c
     78c:	9d 85       	ldd	r25, Y+13	; 0x0d
     78e:	83 30       	cpi	r24, 0x03	; 3
     790:	91 05       	cpc	r25, r1
     792:	09 f4       	brne	.+2      	; 0x796 <DIO_SetPinDir+0x5c>
     794:	89 c0       	rjmp	.+274    	; 0x8a8 <__stack+0x49>
     796:	b5 c0       	rjmp	.+362    	; 0x902 <__stack+0xa3>
	{
		case DIO_PORTA:
		(dir == OUTPUT)? (SET_BIT(DDRA,pin)):(CLR_BIT(DDRA,pin));
     798:	8b 81       	ldd	r24, Y+3	; 0x03
     79a:	83 30       	cpi	r24, 0x03	; 3
     79c:	a9 f4       	brne	.+42     	; 0x7c8 <DIO_SetPinDir+0x8e>
     79e:	aa e3       	ldi	r26, 0x3A	; 58
     7a0:	b0 e0       	ldi	r27, 0x00	; 0
     7a2:	ea e3       	ldi	r30, 0x3A	; 58
     7a4:	f0 e0       	ldi	r31, 0x00	; 0
     7a6:	80 81       	ld	r24, Z
     7a8:	48 2f       	mov	r20, r24
     7aa:	8a 81       	ldd	r24, Y+2	; 0x02
     7ac:	28 2f       	mov	r18, r24
     7ae:	30 e0       	ldi	r19, 0x00	; 0
     7b0:	81 e0       	ldi	r24, 0x01	; 1
     7b2:	90 e0       	ldi	r25, 0x00	; 0
     7b4:	02 2e       	mov	r0, r18
     7b6:	02 c0       	rjmp	.+4      	; 0x7bc <DIO_SetPinDir+0x82>
     7b8:	88 0f       	add	r24, r24
     7ba:	99 1f       	adc	r25, r25
     7bc:	0a 94       	dec	r0
     7be:	e2 f7       	brpl	.-8      	; 0x7b8 <DIO_SetPinDir+0x7e>
     7c0:	84 2b       	or	r24, r20
     7c2:	8c 93       	st	X, r24
     7c4:	9c 91       	ld	r25, X
     7c6:	9d c0       	rjmp	.+314    	; 0x902 <__stack+0xa3>
     7c8:	aa e3       	ldi	r26, 0x3A	; 58
     7ca:	b0 e0       	ldi	r27, 0x00	; 0
     7cc:	ea e3       	ldi	r30, 0x3A	; 58
     7ce:	f0 e0       	ldi	r31, 0x00	; 0
     7d0:	80 81       	ld	r24, Z
     7d2:	48 2f       	mov	r20, r24
     7d4:	8a 81       	ldd	r24, Y+2	; 0x02
     7d6:	28 2f       	mov	r18, r24
     7d8:	30 e0       	ldi	r19, 0x00	; 0
     7da:	81 e0       	ldi	r24, 0x01	; 1
     7dc:	90 e0       	ldi	r25, 0x00	; 0
     7de:	02 c0       	rjmp	.+4      	; 0x7e4 <DIO_SetPinDir+0xaa>
     7e0:	88 0f       	add	r24, r24
     7e2:	99 1f       	adc	r25, r25
     7e4:	2a 95       	dec	r18
     7e6:	e2 f7       	brpl	.-8      	; 0x7e0 <DIO_SetPinDir+0xa6>
     7e8:	80 95       	com	r24
     7ea:	84 23       	and	r24, r20
     7ec:	8c 93       	st	X, r24
     7ee:	2c 91       	ld	r18, X
     7f0:	88 c0       	rjmp	.+272    	; 0x902 <__stack+0xa3>
		break;

		case DIO_PORTB:
		(dir == OUTPUT)? (SET_BIT(DDRB,pin)):(CLR_BIT(DDRB,pin));
     7f2:	8b 81       	ldd	r24, Y+3	; 0x03
     7f4:	83 30       	cpi	r24, 0x03	; 3
     7f6:	a9 f4       	brne	.+42     	; 0x822 <DIO_SetPinDir+0xe8>
     7f8:	a7 e3       	ldi	r26, 0x37	; 55
     7fa:	b0 e0       	ldi	r27, 0x00	; 0
     7fc:	e7 e3       	ldi	r30, 0x37	; 55
     7fe:	f0 e0       	ldi	r31, 0x00	; 0
     800:	80 81       	ld	r24, Z
     802:	48 2f       	mov	r20, r24
     804:	8a 81       	ldd	r24, Y+2	; 0x02
     806:	28 2f       	mov	r18, r24
     808:	30 e0       	ldi	r19, 0x00	; 0
     80a:	81 e0       	ldi	r24, 0x01	; 1
     80c:	90 e0       	ldi	r25, 0x00	; 0
     80e:	02 2e       	mov	r0, r18
     810:	02 c0       	rjmp	.+4      	; 0x816 <DIO_SetPinDir+0xdc>
     812:	88 0f       	add	r24, r24
     814:	99 1f       	adc	r25, r25
     816:	0a 94       	dec	r0
     818:	e2 f7       	brpl	.-8      	; 0x812 <DIO_SetPinDir+0xd8>
     81a:	84 2b       	or	r24, r20
     81c:	8c 93       	st	X, r24
     81e:	3c 91       	ld	r19, X
     820:	70 c0       	rjmp	.+224    	; 0x902 <__stack+0xa3>
     822:	a7 e3       	ldi	r26, 0x37	; 55
     824:	b0 e0       	ldi	r27, 0x00	; 0
     826:	e7 e3       	ldi	r30, 0x37	; 55
     828:	f0 e0       	ldi	r31, 0x00	; 0
     82a:	80 81       	ld	r24, Z
     82c:	48 2f       	mov	r20, r24
     82e:	8a 81       	ldd	r24, Y+2	; 0x02
     830:	28 2f       	mov	r18, r24
     832:	30 e0       	ldi	r19, 0x00	; 0
     834:	81 e0       	ldi	r24, 0x01	; 1
     836:	90 e0       	ldi	r25, 0x00	; 0
     838:	02 2e       	mov	r0, r18
     83a:	02 c0       	rjmp	.+4      	; 0x840 <DIO_SetPinDir+0x106>
     83c:	88 0f       	add	r24, r24
     83e:	99 1f       	adc	r25, r25
     840:	0a 94       	dec	r0
     842:	e2 f7       	brpl	.-8      	; 0x83c <DIO_SetPinDir+0x102>
     844:	80 95       	com	r24
     846:	84 23       	and	r24, r20
     848:	8c 93       	st	X, r24
     84a:	8c 91       	ld	r24, X
     84c:	5a c0       	rjmp	.+180    	; 0x902 <__stack+0xa3>
		break;

		case DIO_PORTC:
		(dir == OUTPUT)? (SET_BIT(DDRC,pin)):(CLR_BIT(DDRC,pin));
     84e:	8b 81       	ldd	r24, Y+3	; 0x03
     850:	83 30       	cpi	r24, 0x03	; 3
     852:	a9 f4       	brne	.+42     	; 0x87e <__stack+0x1f>
     854:	a4 e3       	ldi	r26, 0x34	; 52
     856:	b0 e0       	ldi	r27, 0x00	; 0
     858:	e4 e3       	ldi	r30, 0x34	; 52
     85a:	f0 e0       	ldi	r31, 0x00	; 0
     85c:	80 81       	ld	r24, Z
     85e:	48 2f       	mov	r20, r24
     860:	8a 81       	ldd	r24, Y+2	; 0x02
     862:	28 2f       	mov	r18, r24
     864:	30 e0       	ldi	r19, 0x00	; 0
     866:	81 e0       	ldi	r24, 0x01	; 1
     868:	90 e0       	ldi	r25, 0x00	; 0
     86a:	02 2e       	mov	r0, r18
     86c:	02 c0       	rjmp	.+4      	; 0x872 <__stack+0x13>
     86e:	88 0f       	add	r24, r24
     870:	99 1f       	adc	r25, r25
     872:	0a 94       	dec	r0
     874:	e2 f7       	brpl	.-8      	; 0x86e <__stack+0xf>
     876:	84 2b       	or	r24, r20
     878:	8c 93       	st	X, r24
     87a:	9c 91       	ld	r25, X
     87c:	42 c0       	rjmp	.+132    	; 0x902 <__stack+0xa3>
     87e:	a4 e3       	ldi	r26, 0x34	; 52
     880:	b0 e0       	ldi	r27, 0x00	; 0
     882:	e4 e3       	ldi	r30, 0x34	; 52
     884:	f0 e0       	ldi	r31, 0x00	; 0
     886:	80 81       	ld	r24, Z
     888:	48 2f       	mov	r20, r24
     88a:	8a 81       	ldd	r24, Y+2	; 0x02
     88c:	28 2f       	mov	r18, r24
     88e:	30 e0       	ldi	r19, 0x00	; 0
     890:	81 e0       	ldi	r24, 0x01	; 1
     892:	90 e0       	ldi	r25, 0x00	; 0
     894:	02 c0       	rjmp	.+4      	; 0x89a <__stack+0x3b>
     896:	88 0f       	add	r24, r24
     898:	99 1f       	adc	r25, r25
     89a:	2a 95       	dec	r18
     89c:	e2 f7       	brpl	.-8      	; 0x896 <__stack+0x37>
     89e:	80 95       	com	r24
     8a0:	84 23       	and	r24, r20
     8a2:	8c 93       	st	X, r24
     8a4:	2c 91       	ld	r18, X
     8a6:	2d c0       	rjmp	.+90     	; 0x902 <__stack+0xa3>
		break;

		case DIO_PORTD:
		(dir == OUTPUT)? (SET_BIT(DDRD,pin)):(CLR_BIT(DDRD,pin));
     8a8:	8b 81       	ldd	r24, Y+3	; 0x03
     8aa:	83 30       	cpi	r24, 0x03	; 3
     8ac:	a9 f4       	brne	.+42     	; 0x8d8 <__stack+0x79>
     8ae:	a1 e3       	ldi	r26, 0x31	; 49
     8b0:	b0 e0       	ldi	r27, 0x00	; 0
     8b2:	e1 e3       	ldi	r30, 0x31	; 49
     8b4:	f0 e0       	ldi	r31, 0x00	; 0
     8b6:	80 81       	ld	r24, Z
     8b8:	48 2f       	mov	r20, r24
     8ba:	8a 81       	ldd	r24, Y+2	; 0x02
     8bc:	28 2f       	mov	r18, r24
     8be:	30 e0       	ldi	r19, 0x00	; 0
     8c0:	81 e0       	ldi	r24, 0x01	; 1
     8c2:	90 e0       	ldi	r25, 0x00	; 0
     8c4:	02 2e       	mov	r0, r18
     8c6:	02 c0       	rjmp	.+4      	; 0x8cc <__stack+0x6d>
     8c8:	88 0f       	add	r24, r24
     8ca:	99 1f       	adc	r25, r25
     8cc:	0a 94       	dec	r0
     8ce:	e2 f7       	brpl	.-8      	; 0x8c8 <__stack+0x69>
     8d0:	84 2b       	or	r24, r20
     8d2:	8c 93       	st	X, r24
     8d4:	3c 91       	ld	r19, X
     8d6:	15 c0       	rjmp	.+42     	; 0x902 <__stack+0xa3>
     8d8:	a1 e3       	ldi	r26, 0x31	; 49
     8da:	b0 e0       	ldi	r27, 0x00	; 0
     8dc:	e1 e3       	ldi	r30, 0x31	; 49
     8de:	f0 e0       	ldi	r31, 0x00	; 0
     8e0:	80 81       	ld	r24, Z
     8e2:	48 2f       	mov	r20, r24
     8e4:	8a 81       	ldd	r24, Y+2	; 0x02
     8e6:	28 2f       	mov	r18, r24
     8e8:	30 e0       	ldi	r19, 0x00	; 0
     8ea:	81 e0       	ldi	r24, 0x01	; 1
     8ec:	90 e0       	ldi	r25, 0x00	; 0
     8ee:	02 2e       	mov	r0, r18
     8f0:	02 c0       	rjmp	.+4      	; 0x8f6 <__stack+0x97>
     8f2:	88 0f       	add	r24, r24
     8f4:	99 1f       	adc	r25, r25
     8f6:	0a 94       	dec	r0
     8f8:	e2 f7       	brpl	.-8      	; 0x8f2 <__stack+0x93>
     8fa:	80 95       	com	r24
     8fc:	84 23       	and	r24, r20
     8fe:	8c 93       	st	X, r24
     900:	8c 91       	ld	r24, X
		break;
	}
}
     902:	2d 96       	adiw	r28, 0x0d	; 13
     904:	0f b6       	in	r0, 0x3f	; 63
     906:	f8 94       	cli
     908:	de bf       	out	0x3e, r29	; 62
     90a:	0f be       	out	0x3f, r0	; 63
     90c:	cd bf       	out	0x3d, r28	; 61
     90e:	cf 91       	pop	r28
     910:	df 91       	pop	r29
     912:	08 95       	ret

00000914 <DIO_SetPinVal>:


void DIO_SetPinVal(uint8_t port ,uint8_t pin , uint8_t val)
{
     914:	df 93       	push	r29
     916:	cf 93       	push	r28
     918:	cd b7       	in	r28, 0x3d	; 61
     91a:	de b7       	in	r29, 0x3e	; 62
     91c:	2d 97       	sbiw	r28, 0x0d	; 13
     91e:	0f b6       	in	r0, 0x3f	; 63
     920:	f8 94       	cli
     922:	de bf       	out	0x3e, r29	; 62
     924:	0f be       	out	0x3f, r0	; 63
     926:	cd bf       	out	0x3d, r28	; 61
     928:	89 83       	std	Y+1, r24	; 0x01
     92a:	6a 83       	std	Y+2, r22	; 0x02
     92c:	4b 83       	std	Y+3, r20	; 0x03
	switch (port)
     92e:	89 81       	ldd	r24, Y+1	; 0x01
     930:	28 2f       	mov	r18, r24
     932:	30 e0       	ldi	r19, 0x00	; 0
     934:	3d 87       	std	Y+13, r19	; 0x0d
     936:	2c 87       	std	Y+12, r18	; 0x0c
     938:	8c 85       	ldd	r24, Y+12	; 0x0c
     93a:	9d 85       	ldd	r25, Y+13	; 0x0d
     93c:	81 30       	cpi	r24, 0x01	; 1
     93e:	91 05       	cpc	r25, r1
     940:	09 f4       	brne	.+2      	; 0x944 <DIO_SetPinVal+0x30>
     942:	44 c0       	rjmp	.+136    	; 0x9cc <DIO_SetPinVal+0xb8>
     944:	2c 85       	ldd	r18, Y+12	; 0x0c
     946:	3d 85       	ldd	r19, Y+13	; 0x0d
     948:	22 30       	cpi	r18, 0x02	; 2
     94a:	31 05       	cpc	r19, r1
     94c:	2c f4       	brge	.+10     	; 0x958 <DIO_SetPinVal+0x44>
     94e:	8c 85       	ldd	r24, Y+12	; 0x0c
     950:	9d 85       	ldd	r25, Y+13	; 0x0d
     952:	00 97       	sbiw	r24, 0x00	; 0
     954:	71 f0       	breq	.+28     	; 0x972 <DIO_SetPinVal+0x5e>
     956:	c2 c0       	rjmp	.+388    	; 0xadc <DIO_SetPinVal+0x1c8>
     958:	2c 85       	ldd	r18, Y+12	; 0x0c
     95a:	3d 85       	ldd	r19, Y+13	; 0x0d
     95c:	22 30       	cpi	r18, 0x02	; 2
     95e:	31 05       	cpc	r19, r1
     960:	09 f4       	brne	.+2      	; 0x964 <DIO_SetPinVal+0x50>
     962:	62 c0       	rjmp	.+196    	; 0xa28 <DIO_SetPinVal+0x114>
     964:	8c 85       	ldd	r24, Y+12	; 0x0c
     966:	9d 85       	ldd	r25, Y+13	; 0x0d
     968:	83 30       	cpi	r24, 0x03	; 3
     96a:	91 05       	cpc	r25, r1
     96c:	09 f4       	brne	.+2      	; 0x970 <DIO_SetPinVal+0x5c>
     96e:	89 c0       	rjmp	.+274    	; 0xa82 <DIO_SetPinVal+0x16e>
     970:	b5 c0       	rjmp	.+362    	; 0xadc <DIO_SetPinVal+0x1c8>
	{
		case DIO_PORTA:
		(val == HIGH)? (SET_BIT(PORTA,pin)):(CLR_BIT(PORTA,pin));
     972:	8b 81       	ldd	r24, Y+3	; 0x03
     974:	81 30       	cpi	r24, 0x01	; 1
     976:	a9 f4       	brne	.+42     	; 0x9a2 <DIO_SetPinVal+0x8e>
     978:	ab e3       	ldi	r26, 0x3B	; 59
     97a:	b0 e0       	ldi	r27, 0x00	; 0
     97c:	eb e3       	ldi	r30, 0x3B	; 59
     97e:	f0 e0       	ldi	r31, 0x00	; 0
     980:	80 81       	ld	r24, Z
     982:	48 2f       	mov	r20, r24
     984:	8a 81       	ldd	r24, Y+2	; 0x02
     986:	28 2f       	mov	r18, r24
     988:	30 e0       	ldi	r19, 0x00	; 0
     98a:	81 e0       	ldi	r24, 0x01	; 1
     98c:	90 e0       	ldi	r25, 0x00	; 0
     98e:	02 2e       	mov	r0, r18
     990:	02 c0       	rjmp	.+4      	; 0x996 <DIO_SetPinVal+0x82>
     992:	88 0f       	add	r24, r24
     994:	99 1f       	adc	r25, r25
     996:	0a 94       	dec	r0
     998:	e2 f7       	brpl	.-8      	; 0x992 <DIO_SetPinVal+0x7e>
     99a:	84 2b       	or	r24, r20
     99c:	8c 93       	st	X, r24
     99e:	9c 91       	ld	r25, X
     9a0:	9d c0       	rjmp	.+314    	; 0xadc <DIO_SetPinVal+0x1c8>
     9a2:	ab e3       	ldi	r26, 0x3B	; 59
     9a4:	b0 e0       	ldi	r27, 0x00	; 0
     9a6:	eb e3       	ldi	r30, 0x3B	; 59
     9a8:	f0 e0       	ldi	r31, 0x00	; 0
     9aa:	80 81       	ld	r24, Z
     9ac:	48 2f       	mov	r20, r24
     9ae:	8a 81       	ldd	r24, Y+2	; 0x02
     9b0:	28 2f       	mov	r18, r24
     9b2:	30 e0       	ldi	r19, 0x00	; 0
     9b4:	81 e0       	ldi	r24, 0x01	; 1
     9b6:	90 e0       	ldi	r25, 0x00	; 0
     9b8:	02 c0       	rjmp	.+4      	; 0x9be <DIO_SetPinVal+0xaa>
     9ba:	88 0f       	add	r24, r24
     9bc:	99 1f       	adc	r25, r25
     9be:	2a 95       	dec	r18
     9c0:	e2 f7       	brpl	.-8      	; 0x9ba <DIO_SetPinVal+0xa6>
     9c2:	80 95       	com	r24
     9c4:	84 23       	and	r24, r20
     9c6:	8c 93       	st	X, r24
     9c8:	2c 91       	ld	r18, X
     9ca:	88 c0       	rjmp	.+272    	; 0xadc <DIO_SetPinVal+0x1c8>
		break;

		case DIO_PORTB:
		(val == HIGH)? (SET_BIT(PORTB,pin)):(CLR_BIT(PORTB,pin));
     9cc:	8b 81       	ldd	r24, Y+3	; 0x03
     9ce:	81 30       	cpi	r24, 0x01	; 1
     9d0:	a9 f4       	brne	.+42     	; 0x9fc <DIO_SetPinVal+0xe8>
     9d2:	a8 e3       	ldi	r26, 0x38	; 56
     9d4:	b0 e0       	ldi	r27, 0x00	; 0
     9d6:	e8 e3       	ldi	r30, 0x38	; 56
     9d8:	f0 e0       	ldi	r31, 0x00	; 0
     9da:	80 81       	ld	r24, Z
     9dc:	48 2f       	mov	r20, r24
     9de:	8a 81       	ldd	r24, Y+2	; 0x02
     9e0:	28 2f       	mov	r18, r24
     9e2:	30 e0       	ldi	r19, 0x00	; 0
     9e4:	81 e0       	ldi	r24, 0x01	; 1
     9e6:	90 e0       	ldi	r25, 0x00	; 0
     9e8:	02 2e       	mov	r0, r18
     9ea:	02 c0       	rjmp	.+4      	; 0x9f0 <DIO_SetPinVal+0xdc>
     9ec:	88 0f       	add	r24, r24
     9ee:	99 1f       	adc	r25, r25
     9f0:	0a 94       	dec	r0
     9f2:	e2 f7       	brpl	.-8      	; 0x9ec <DIO_SetPinVal+0xd8>
     9f4:	84 2b       	or	r24, r20
     9f6:	8c 93       	st	X, r24
     9f8:	3c 91       	ld	r19, X
     9fa:	70 c0       	rjmp	.+224    	; 0xadc <DIO_SetPinVal+0x1c8>
     9fc:	a8 e3       	ldi	r26, 0x38	; 56
     9fe:	b0 e0       	ldi	r27, 0x00	; 0
     a00:	e8 e3       	ldi	r30, 0x38	; 56
     a02:	f0 e0       	ldi	r31, 0x00	; 0
     a04:	80 81       	ld	r24, Z
     a06:	48 2f       	mov	r20, r24
     a08:	8a 81       	ldd	r24, Y+2	; 0x02
     a0a:	28 2f       	mov	r18, r24
     a0c:	30 e0       	ldi	r19, 0x00	; 0
     a0e:	81 e0       	ldi	r24, 0x01	; 1
     a10:	90 e0       	ldi	r25, 0x00	; 0
     a12:	02 2e       	mov	r0, r18
     a14:	02 c0       	rjmp	.+4      	; 0xa1a <DIO_SetPinVal+0x106>
     a16:	88 0f       	add	r24, r24
     a18:	99 1f       	adc	r25, r25
     a1a:	0a 94       	dec	r0
     a1c:	e2 f7       	brpl	.-8      	; 0xa16 <DIO_SetPinVal+0x102>
     a1e:	80 95       	com	r24
     a20:	84 23       	and	r24, r20
     a22:	8c 93       	st	X, r24
     a24:	8c 91       	ld	r24, X
     a26:	5a c0       	rjmp	.+180    	; 0xadc <DIO_SetPinVal+0x1c8>
		break;

		case DIO_PORTC:
		(val == HIGH)? (SET_BIT(PORTC,pin)):(CLR_BIT(PORTC,pin));
     a28:	8b 81       	ldd	r24, Y+3	; 0x03
     a2a:	81 30       	cpi	r24, 0x01	; 1
     a2c:	a9 f4       	brne	.+42     	; 0xa58 <DIO_SetPinVal+0x144>
     a2e:	a5 e3       	ldi	r26, 0x35	; 53
     a30:	b0 e0       	ldi	r27, 0x00	; 0
     a32:	e5 e3       	ldi	r30, 0x35	; 53
     a34:	f0 e0       	ldi	r31, 0x00	; 0
     a36:	80 81       	ld	r24, Z
     a38:	48 2f       	mov	r20, r24
     a3a:	8a 81       	ldd	r24, Y+2	; 0x02
     a3c:	28 2f       	mov	r18, r24
     a3e:	30 e0       	ldi	r19, 0x00	; 0
     a40:	81 e0       	ldi	r24, 0x01	; 1
     a42:	90 e0       	ldi	r25, 0x00	; 0
     a44:	02 2e       	mov	r0, r18
     a46:	02 c0       	rjmp	.+4      	; 0xa4c <DIO_SetPinVal+0x138>
     a48:	88 0f       	add	r24, r24
     a4a:	99 1f       	adc	r25, r25
     a4c:	0a 94       	dec	r0
     a4e:	e2 f7       	brpl	.-8      	; 0xa48 <DIO_SetPinVal+0x134>
     a50:	84 2b       	or	r24, r20
     a52:	8c 93       	st	X, r24
     a54:	9c 91       	ld	r25, X
     a56:	42 c0       	rjmp	.+132    	; 0xadc <DIO_SetPinVal+0x1c8>
     a58:	a5 e3       	ldi	r26, 0x35	; 53
     a5a:	b0 e0       	ldi	r27, 0x00	; 0
     a5c:	e5 e3       	ldi	r30, 0x35	; 53
     a5e:	f0 e0       	ldi	r31, 0x00	; 0
     a60:	80 81       	ld	r24, Z
     a62:	48 2f       	mov	r20, r24
     a64:	8a 81       	ldd	r24, Y+2	; 0x02
     a66:	28 2f       	mov	r18, r24
     a68:	30 e0       	ldi	r19, 0x00	; 0
     a6a:	81 e0       	ldi	r24, 0x01	; 1
     a6c:	90 e0       	ldi	r25, 0x00	; 0
     a6e:	02 c0       	rjmp	.+4      	; 0xa74 <DIO_SetPinVal+0x160>
     a70:	88 0f       	add	r24, r24
     a72:	99 1f       	adc	r25, r25
     a74:	2a 95       	dec	r18
     a76:	e2 f7       	brpl	.-8      	; 0xa70 <DIO_SetPinVal+0x15c>
     a78:	80 95       	com	r24
     a7a:	84 23       	and	r24, r20
     a7c:	8c 93       	st	X, r24
     a7e:	2c 91       	ld	r18, X
     a80:	2d c0       	rjmp	.+90     	; 0xadc <DIO_SetPinVal+0x1c8>
		break;

		case DIO_PORTD:
		(val == HIGH)? (SET_BIT(PORTD,pin)):(CLR_BIT(PORTD,pin));
     a82:	8b 81       	ldd	r24, Y+3	; 0x03
     a84:	81 30       	cpi	r24, 0x01	; 1
     a86:	a9 f4       	brne	.+42     	; 0xab2 <DIO_SetPinVal+0x19e>
     a88:	a2 e3       	ldi	r26, 0x32	; 50
     a8a:	b0 e0       	ldi	r27, 0x00	; 0
     a8c:	e2 e3       	ldi	r30, 0x32	; 50
     a8e:	f0 e0       	ldi	r31, 0x00	; 0
     a90:	80 81       	ld	r24, Z
     a92:	48 2f       	mov	r20, r24
     a94:	8a 81       	ldd	r24, Y+2	; 0x02
     a96:	28 2f       	mov	r18, r24
     a98:	30 e0       	ldi	r19, 0x00	; 0
     a9a:	81 e0       	ldi	r24, 0x01	; 1
     a9c:	90 e0       	ldi	r25, 0x00	; 0
     a9e:	02 2e       	mov	r0, r18
     aa0:	02 c0       	rjmp	.+4      	; 0xaa6 <DIO_SetPinVal+0x192>
     aa2:	88 0f       	add	r24, r24
     aa4:	99 1f       	adc	r25, r25
     aa6:	0a 94       	dec	r0
     aa8:	e2 f7       	brpl	.-8      	; 0xaa2 <DIO_SetPinVal+0x18e>
     aaa:	84 2b       	or	r24, r20
     aac:	8c 93       	st	X, r24
     aae:	3c 91       	ld	r19, X
     ab0:	15 c0       	rjmp	.+42     	; 0xadc <DIO_SetPinVal+0x1c8>
     ab2:	a2 e3       	ldi	r26, 0x32	; 50
     ab4:	b0 e0       	ldi	r27, 0x00	; 0
     ab6:	e2 e3       	ldi	r30, 0x32	; 50
     ab8:	f0 e0       	ldi	r31, 0x00	; 0
     aba:	80 81       	ld	r24, Z
     abc:	48 2f       	mov	r20, r24
     abe:	8a 81       	ldd	r24, Y+2	; 0x02
     ac0:	28 2f       	mov	r18, r24
     ac2:	30 e0       	ldi	r19, 0x00	; 0
     ac4:	81 e0       	ldi	r24, 0x01	; 1
     ac6:	90 e0       	ldi	r25, 0x00	; 0
     ac8:	02 2e       	mov	r0, r18
     aca:	02 c0       	rjmp	.+4      	; 0xad0 <DIO_SetPinVal+0x1bc>
     acc:	88 0f       	add	r24, r24
     ace:	99 1f       	adc	r25, r25
     ad0:	0a 94       	dec	r0
     ad2:	e2 f7       	brpl	.-8      	; 0xacc <DIO_SetPinVal+0x1b8>
     ad4:	80 95       	com	r24
     ad6:	84 23       	and	r24, r20
     ad8:	8c 93       	st	X, r24
     ada:	8c 91       	ld	r24, X
		break;
	}
}
     adc:	2d 96       	adiw	r28, 0x0d	; 13
     ade:	0f b6       	in	r0, 0x3f	; 63
     ae0:	f8 94       	cli
     ae2:	de bf       	out	0x3e, r29	; 62
     ae4:	0f be       	out	0x3f, r0	; 63
     ae6:	cd bf       	out	0x3d, r28	; 61
     ae8:	cf 91       	pop	r28
     aea:	df 91       	pop	r29
     aec:	08 95       	ret

00000aee <DIO_GetPinVal>:


uint8_t  DIO_GetPinVal(uint8_t port ,uint8_t pin)
{
     aee:	df 93       	push	r29
     af0:	cf 93       	push	r28
     af2:	00 d0       	rcall	.+0      	; 0xaf4 <DIO_GetPinVal+0x6>
     af4:	00 d0       	rcall	.+0      	; 0xaf6 <DIO_GetPinVal+0x8>
     af6:	00 d0       	rcall	.+0      	; 0xaf8 <DIO_GetPinVal+0xa>
     af8:	cd b7       	in	r28, 0x3d	; 61
     afa:	de b7       	in	r29, 0x3e	; 62
     afc:	89 83       	std	Y+1, r24	; 0x01
     afe:	6a 83       	std	Y+2, r22	; 0x02
	switch(port)
     b00:	89 81       	ldd	r24, Y+1	; 0x01
     b02:	28 2f       	mov	r18, r24
     b04:	30 e0       	ldi	r19, 0x00	; 0
     b06:	3d 83       	std	Y+5, r19	; 0x05
     b08:	2c 83       	std	Y+4, r18	; 0x04
     b0a:	4c 81       	ldd	r20, Y+4	; 0x04
     b0c:	5d 81       	ldd	r21, Y+5	; 0x05
     b0e:	41 30       	cpi	r20, 0x01	; 1
     b10:	51 05       	cpc	r21, r1
     b12:	49 f1       	breq	.+82     	; 0xb66 <DIO_GetPinVal+0x78>
     b14:	8c 81       	ldd	r24, Y+4	; 0x04
     b16:	9d 81       	ldd	r25, Y+5	; 0x05
     b18:	82 30       	cpi	r24, 0x02	; 2
     b1a:	91 05       	cpc	r25, r1
     b1c:	34 f4       	brge	.+12     	; 0xb2a <DIO_GetPinVal+0x3c>
     b1e:	2c 81       	ldd	r18, Y+4	; 0x04
     b20:	3d 81       	ldd	r19, Y+5	; 0x05
     b22:	21 15       	cp	r18, r1
     b24:	31 05       	cpc	r19, r1
     b26:	61 f0       	breq	.+24     	; 0xb40 <DIO_GetPinVal+0x52>
     b28:	57 c0       	rjmp	.+174    	; 0xbd8 <DIO_GetPinVal+0xea>
     b2a:	4c 81       	ldd	r20, Y+4	; 0x04
     b2c:	5d 81       	ldd	r21, Y+5	; 0x05
     b2e:	42 30       	cpi	r20, 0x02	; 2
     b30:	51 05       	cpc	r21, r1
     b32:	61 f1       	breq	.+88     	; 0xb8c <DIO_GetPinVal+0x9e>
     b34:	8c 81       	ldd	r24, Y+4	; 0x04
     b36:	9d 81       	ldd	r25, Y+5	; 0x05
     b38:	83 30       	cpi	r24, 0x03	; 3
     b3a:	91 05       	cpc	r25, r1
     b3c:	d1 f1       	breq	.+116    	; 0xbb2 <DIO_GetPinVal+0xc4>
     b3e:	4c c0       	rjmp	.+152    	; 0xbd8 <DIO_GetPinVal+0xea>
	{
		case  DIO_PORTA :
			return GET_BIT(PINA,pin);
     b40:	e9 e3       	ldi	r30, 0x39	; 57
     b42:	f0 e0       	ldi	r31, 0x00	; 0
     b44:	80 81       	ld	r24, Z
     b46:	28 2f       	mov	r18, r24
     b48:	30 e0       	ldi	r19, 0x00	; 0
     b4a:	8a 81       	ldd	r24, Y+2	; 0x02
     b4c:	88 2f       	mov	r24, r24
     b4e:	90 e0       	ldi	r25, 0x00	; 0
     b50:	a9 01       	movw	r20, r18
     b52:	02 c0       	rjmp	.+4      	; 0xb58 <DIO_GetPinVal+0x6a>
     b54:	55 95       	asr	r21
     b56:	47 95       	ror	r20
     b58:	8a 95       	dec	r24
     b5a:	e2 f7       	brpl	.-8      	; 0xb54 <DIO_GetPinVal+0x66>
     b5c:	ca 01       	movw	r24, r20
     b5e:	58 2f       	mov	r21, r24
     b60:	51 70       	andi	r21, 0x01	; 1
     b62:	5b 83       	std	Y+3, r21	; 0x03
     b64:	3a c0       	rjmp	.+116    	; 0xbda <DIO_GetPinVal+0xec>
			break;
		case  DIO_PORTB :
			return GET_BIT(PINB,pin);
     b66:	e6 e3       	ldi	r30, 0x36	; 54
     b68:	f0 e0       	ldi	r31, 0x00	; 0
     b6a:	80 81       	ld	r24, Z
     b6c:	28 2f       	mov	r18, r24
     b6e:	30 e0       	ldi	r19, 0x00	; 0
     b70:	8a 81       	ldd	r24, Y+2	; 0x02
     b72:	88 2f       	mov	r24, r24
     b74:	90 e0       	ldi	r25, 0x00	; 0
     b76:	a9 01       	movw	r20, r18
     b78:	02 c0       	rjmp	.+4      	; 0xb7e <DIO_GetPinVal+0x90>
     b7a:	55 95       	asr	r21
     b7c:	47 95       	ror	r20
     b7e:	8a 95       	dec	r24
     b80:	e2 f7       	brpl	.-8      	; 0xb7a <DIO_GetPinVal+0x8c>
     b82:	ca 01       	movw	r24, r20
     b84:	58 2f       	mov	r21, r24
     b86:	51 70       	andi	r21, 0x01	; 1
     b88:	5b 83       	std	Y+3, r21	; 0x03
     b8a:	27 c0       	rjmp	.+78     	; 0xbda <DIO_GetPinVal+0xec>
			break;
		case  DIO_PORTC :
			return GET_BIT(PINC,pin);
     b8c:	e3 e3       	ldi	r30, 0x33	; 51
     b8e:	f0 e0       	ldi	r31, 0x00	; 0
     b90:	80 81       	ld	r24, Z
     b92:	28 2f       	mov	r18, r24
     b94:	30 e0       	ldi	r19, 0x00	; 0
     b96:	8a 81       	ldd	r24, Y+2	; 0x02
     b98:	88 2f       	mov	r24, r24
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	a9 01       	movw	r20, r18
     b9e:	02 c0       	rjmp	.+4      	; 0xba4 <DIO_GetPinVal+0xb6>
     ba0:	55 95       	asr	r21
     ba2:	47 95       	ror	r20
     ba4:	8a 95       	dec	r24
     ba6:	e2 f7       	brpl	.-8      	; 0xba0 <DIO_GetPinVal+0xb2>
     ba8:	ca 01       	movw	r24, r20
     baa:	58 2f       	mov	r21, r24
     bac:	51 70       	andi	r21, 0x01	; 1
     bae:	5b 83       	std	Y+3, r21	; 0x03
     bb0:	14 c0       	rjmp	.+40     	; 0xbda <DIO_GetPinVal+0xec>
			break;
		case  DIO_PORTD :
			return GET_BIT(PIND,pin);
     bb2:	e0 e3       	ldi	r30, 0x30	; 48
     bb4:	f0 e0       	ldi	r31, 0x00	; 0
     bb6:	80 81       	ld	r24, Z
     bb8:	28 2f       	mov	r18, r24
     bba:	30 e0       	ldi	r19, 0x00	; 0
     bbc:	8a 81       	ldd	r24, Y+2	; 0x02
     bbe:	88 2f       	mov	r24, r24
     bc0:	90 e0       	ldi	r25, 0x00	; 0
     bc2:	a9 01       	movw	r20, r18
     bc4:	02 c0       	rjmp	.+4      	; 0xbca <DIO_GetPinVal+0xdc>
     bc6:	55 95       	asr	r21
     bc8:	47 95       	ror	r20
     bca:	8a 95       	dec	r24
     bcc:	e2 f7       	brpl	.-8      	; 0xbc6 <DIO_GetPinVal+0xd8>
     bce:	ca 01       	movw	r24, r20
     bd0:	58 2f       	mov	r21, r24
     bd2:	51 70       	andi	r21, 0x01	; 1
     bd4:	5b 83       	std	Y+3, r21	; 0x03
     bd6:	01 c0       	rjmp	.+2      	; 0xbda <DIO_GetPinVal+0xec>
     bd8:	02 c0       	rjmp	.+4      	; 0xbde <DIO_GetPinVal+0xf0>
			break;
	}
}
     bda:	8b 81       	ldd	r24, Y+3	; 0x03
     bdc:	8e 83       	std	Y+6, r24	; 0x06
     bde:	8e 81       	ldd	r24, Y+6	; 0x06
     be0:	26 96       	adiw	r28, 0x06	; 6
     be2:	0f b6       	in	r0, 0x3f	; 63
     be4:	f8 94       	cli
     be6:	de bf       	out	0x3e, r29	; 62
     be8:	0f be       	out	0x3f, r0	; 63
     bea:	cd bf       	out	0x3d, r28	; 61
     bec:	cf 91       	pop	r28
     bee:	df 91       	pop	r29
     bf0:	08 95       	ret

00000bf2 <DIO_TogPinVal>:


void  DIO_TogPinVal(uint8_t port ,uint8_t pin)
{
     bf2:	df 93       	push	r29
     bf4:	cf 93       	push	r28
     bf6:	00 d0       	rcall	.+0      	; 0xbf8 <DIO_TogPinVal+0x6>
     bf8:	00 d0       	rcall	.+0      	; 0xbfa <DIO_TogPinVal+0x8>
     bfa:	cd b7       	in	r28, 0x3d	; 61
     bfc:	de b7       	in	r29, 0x3e	; 62
     bfe:	89 83       	std	Y+1, r24	; 0x01
     c00:	6a 83       	std	Y+2, r22	; 0x02
	switch(port)
     c02:	89 81       	ldd	r24, Y+1	; 0x01
     c04:	28 2f       	mov	r18, r24
     c06:	30 e0       	ldi	r19, 0x00	; 0
     c08:	3c 83       	std	Y+4, r19	; 0x04
     c0a:	2b 83       	std	Y+3, r18	; 0x03
     c0c:	8b 81       	ldd	r24, Y+3	; 0x03
     c0e:	9c 81       	ldd	r25, Y+4	; 0x04
     c10:	81 30       	cpi	r24, 0x01	; 1
     c12:	91 05       	cpc	r25, r1
     c14:	49 f1       	breq	.+82     	; 0xc68 <DIO_TogPinVal+0x76>
     c16:	2b 81       	ldd	r18, Y+3	; 0x03
     c18:	3c 81       	ldd	r19, Y+4	; 0x04
     c1a:	22 30       	cpi	r18, 0x02	; 2
     c1c:	31 05       	cpc	r19, r1
     c1e:	2c f4       	brge	.+10     	; 0xc2a <DIO_TogPinVal+0x38>
     c20:	8b 81       	ldd	r24, Y+3	; 0x03
     c22:	9c 81       	ldd	r25, Y+4	; 0x04
     c24:	00 97       	sbiw	r24, 0x00	; 0
     c26:	61 f0       	breq	.+24     	; 0xc40 <DIO_TogPinVal+0x4e>
     c28:	5a c0       	rjmp	.+180    	; 0xcde <DIO_TogPinVal+0xec>
     c2a:	2b 81       	ldd	r18, Y+3	; 0x03
     c2c:	3c 81       	ldd	r19, Y+4	; 0x04
     c2e:	22 30       	cpi	r18, 0x02	; 2
     c30:	31 05       	cpc	r19, r1
     c32:	71 f1       	breq	.+92     	; 0xc90 <DIO_TogPinVal+0x9e>
     c34:	8b 81       	ldd	r24, Y+3	; 0x03
     c36:	9c 81       	ldd	r25, Y+4	; 0x04
     c38:	83 30       	cpi	r24, 0x03	; 3
     c3a:	91 05       	cpc	r25, r1
     c3c:	e9 f1       	breq	.+122    	; 0xcb8 <DIO_TogPinVal+0xc6>
     c3e:	4f c0       	rjmp	.+158    	; 0xcde <DIO_TogPinVal+0xec>
	{
		case  DIO_PORTA :	TOG_BIT(PORTA,pin);
     c40:	ab e3       	ldi	r26, 0x3B	; 59
     c42:	b0 e0       	ldi	r27, 0x00	; 0
     c44:	eb e3       	ldi	r30, 0x3B	; 59
     c46:	f0 e0       	ldi	r31, 0x00	; 0
     c48:	80 81       	ld	r24, Z
     c4a:	48 2f       	mov	r20, r24
     c4c:	8a 81       	ldd	r24, Y+2	; 0x02
     c4e:	28 2f       	mov	r18, r24
     c50:	30 e0       	ldi	r19, 0x00	; 0
     c52:	81 e0       	ldi	r24, 0x01	; 1
     c54:	90 e0       	ldi	r25, 0x00	; 0
     c56:	02 2e       	mov	r0, r18
     c58:	02 c0       	rjmp	.+4      	; 0xc5e <DIO_TogPinVal+0x6c>
     c5a:	88 0f       	add	r24, r24
     c5c:	99 1f       	adc	r25, r25
     c5e:	0a 94       	dec	r0
     c60:	e2 f7       	brpl	.-8      	; 0xc5a <DIO_TogPinVal+0x68>
     c62:	84 27       	eor	r24, r20
     c64:	8c 93       	st	X, r24
     c66:	3b c0       	rjmp	.+118    	; 0xcde <DIO_TogPinVal+0xec>
		break;
		case  DIO_PORTB :   TOG_BIT(PORTB,pin);
     c68:	a8 e3       	ldi	r26, 0x38	; 56
     c6a:	b0 e0       	ldi	r27, 0x00	; 0
     c6c:	e8 e3       	ldi	r30, 0x38	; 56
     c6e:	f0 e0       	ldi	r31, 0x00	; 0
     c70:	80 81       	ld	r24, Z
     c72:	48 2f       	mov	r20, r24
     c74:	8a 81       	ldd	r24, Y+2	; 0x02
     c76:	28 2f       	mov	r18, r24
     c78:	30 e0       	ldi	r19, 0x00	; 0
     c7a:	81 e0       	ldi	r24, 0x01	; 1
     c7c:	90 e0       	ldi	r25, 0x00	; 0
     c7e:	02 2e       	mov	r0, r18
     c80:	02 c0       	rjmp	.+4      	; 0xc86 <DIO_TogPinVal+0x94>
     c82:	88 0f       	add	r24, r24
     c84:	99 1f       	adc	r25, r25
     c86:	0a 94       	dec	r0
     c88:	e2 f7       	brpl	.-8      	; 0xc82 <DIO_TogPinVal+0x90>
     c8a:	84 27       	eor	r24, r20
     c8c:	8c 93       	st	X, r24
     c8e:	27 c0       	rjmp	.+78     	; 0xcde <DIO_TogPinVal+0xec>
		break;
		case  DIO_PORTC :   TOG_BIT(PORTC,pin);
     c90:	a5 e3       	ldi	r26, 0x35	; 53
     c92:	b0 e0       	ldi	r27, 0x00	; 0
     c94:	e5 e3       	ldi	r30, 0x35	; 53
     c96:	f0 e0       	ldi	r31, 0x00	; 0
     c98:	80 81       	ld	r24, Z
     c9a:	48 2f       	mov	r20, r24
     c9c:	8a 81       	ldd	r24, Y+2	; 0x02
     c9e:	28 2f       	mov	r18, r24
     ca0:	30 e0       	ldi	r19, 0x00	; 0
     ca2:	81 e0       	ldi	r24, 0x01	; 1
     ca4:	90 e0       	ldi	r25, 0x00	; 0
     ca6:	02 2e       	mov	r0, r18
     ca8:	02 c0       	rjmp	.+4      	; 0xcae <DIO_TogPinVal+0xbc>
     caa:	88 0f       	add	r24, r24
     cac:	99 1f       	adc	r25, r25
     cae:	0a 94       	dec	r0
     cb0:	e2 f7       	brpl	.-8      	; 0xcaa <DIO_TogPinVal+0xb8>
     cb2:	84 27       	eor	r24, r20
     cb4:	8c 93       	st	X, r24
     cb6:	13 c0       	rjmp	.+38     	; 0xcde <DIO_TogPinVal+0xec>
		break;
		case  DIO_PORTD :   TOG_BIT(PORTD,pin);
     cb8:	a2 e3       	ldi	r26, 0x32	; 50
     cba:	b0 e0       	ldi	r27, 0x00	; 0
     cbc:	e2 e3       	ldi	r30, 0x32	; 50
     cbe:	f0 e0       	ldi	r31, 0x00	; 0
     cc0:	80 81       	ld	r24, Z
     cc2:	48 2f       	mov	r20, r24
     cc4:	8a 81       	ldd	r24, Y+2	; 0x02
     cc6:	28 2f       	mov	r18, r24
     cc8:	30 e0       	ldi	r19, 0x00	; 0
     cca:	81 e0       	ldi	r24, 0x01	; 1
     ccc:	90 e0       	ldi	r25, 0x00	; 0
     cce:	02 2e       	mov	r0, r18
     cd0:	02 c0       	rjmp	.+4      	; 0xcd6 <DIO_TogPinVal+0xe4>
     cd2:	88 0f       	add	r24, r24
     cd4:	99 1f       	adc	r25, r25
     cd6:	0a 94       	dec	r0
     cd8:	e2 f7       	brpl	.-8      	; 0xcd2 <DIO_TogPinVal+0xe0>
     cda:	84 27       	eor	r24, r20
     cdc:	8c 93       	st	X, r24
		break;
	}
}
     cde:	0f 90       	pop	r0
     ce0:	0f 90       	pop	r0
     ce2:	0f 90       	pop	r0
     ce4:	0f 90       	pop	r0
     ce6:	cf 91       	pop	r28
     ce8:	df 91       	pop	r29
     cea:	08 95       	ret

00000cec <PWM_INIT>:
 *  Created on: Feb 11, 2023
 *      Author: wario
 */

#include"PWM.h"
void PWM_INIT(void){
     cec:	df 93       	push	r29
     cee:	cf 93       	push	r28
     cf0:	cd b7       	in	r28, 0x3d	; 61
     cf2:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTB ,Pin3, OUTPUT);
     cf4:	81 e0       	ldi	r24, 0x01	; 1
     cf6:	63 e0       	ldi	r22, 0x03	; 3
     cf8:	43 e0       	ldi	r20, 0x03	; 3
     cfa:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	DIO_SetPinDir(DIO_PORTD ,Pin7, OUTPUT);
     cfe:	83 e0       	ldi	r24, 0x03	; 3
     d00:	67 e0       	ldi	r22, 0x07	; 7
     d02:	43 e0       	ldi	r20, 0x03	; 3
     d04:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
}
     d08:	cf 91       	pop	r28
     d0a:	df 91       	pop	r29
     d0c:	08 95       	ret

00000d0e <Start_PWM1>:
void Start_PWM1(void){
     d0e:	df 93       	push	r29
     d10:	cf 93       	push	r28
     d12:	cd b7       	in	r28, 0x3d	; 61
     d14:	de b7       	in	r29, 0x3e	; 62
	TCCR0 = (1<<WGM00) | (1<<WGM01) | (1<<COM01) | (1<<CS00);
     d16:	e3 e5       	ldi	r30, 0x53	; 83
     d18:	f0 e0       	ldi	r31, 0x00	; 0
     d1a:	89 e6       	ldi	r24, 0x69	; 105
     d1c:	80 83       	st	Z, r24
	OCR0 = 204;
     d1e:	ec e5       	ldi	r30, 0x5C	; 92
     d20:	f0 e0       	ldi	r31, 0x00	; 0
     d22:	8c ec       	ldi	r24, 0xCC	; 204
     d24:	80 83       	st	Z, r24
}
     d26:	cf 91       	pop	r28
     d28:	df 91       	pop	r29
     d2a:	08 95       	ret

00000d2c <Start_PWM2>:
void Start_PWM2(void){
     d2c:	df 93       	push	r29
     d2e:	cf 93       	push	r28
     d30:	cd b7       	in	r28, 0x3d	; 61
     d32:	de b7       	in	r29, 0x3e	; 62
	TCCR2 = (1<<WGM20) | (1<<WGM21) | (1<<COM21) | (1<<CS20);
     d34:	e5 e4       	ldi	r30, 0x45	; 69
     d36:	f0 e0       	ldi	r31, 0x00	; 0
     d38:	89 e6       	ldi	r24, 0x69	; 105
     d3a:	80 83       	st	Z, r24
	OCR2 = 204;
     d3c:	e3 e4       	ldi	r30, 0x43	; 67
     d3e:	f0 e0       	ldi	r31, 0x00	; 0
     d40:	8c ec       	ldi	r24, 0xCC	; 204
     d42:	80 83       	st	Z, r24
}
     d44:	cf 91       	pop	r28
     d46:	df 91       	pop	r29
     d48:	08 95       	ret

00000d4a <Stop_PWM1>:
void Stop_PWM1(void){
     d4a:	df 93       	push	r29
     d4c:	cf 93       	push	r28
     d4e:	cd b7       	in	r28, 0x3d	; 61
     d50:	de b7       	in	r29, 0x3e	; 62
	TCCR0 &=~ (1<<COM01);
     d52:	a3 e5       	ldi	r26, 0x53	; 83
     d54:	b0 e0       	ldi	r27, 0x00	; 0
     d56:	e3 e5       	ldi	r30, 0x53	; 83
     d58:	f0 e0       	ldi	r31, 0x00	; 0
     d5a:	80 81       	ld	r24, Z
     d5c:	8f 7d       	andi	r24, 0xDF	; 223
     d5e:	8c 93       	st	X, r24
	TCCR0 &=~ (1<<CS00);
     d60:	a3 e5       	ldi	r26, 0x53	; 83
     d62:	b0 e0       	ldi	r27, 0x00	; 0
     d64:	e3 e5       	ldi	r30, 0x53	; 83
     d66:	f0 e0       	ldi	r31, 0x00	; 0
     d68:	80 81       	ld	r24, Z
     d6a:	8e 7f       	andi	r24, 0xFE	; 254
     d6c:	8c 93       	st	X, r24
}
     d6e:	cf 91       	pop	r28
     d70:	df 91       	pop	r29
     d72:	08 95       	ret

00000d74 <Stop_PWM2>:
void Stop_PWM2(void){
     d74:	df 93       	push	r29
     d76:	cf 93       	push	r28
     d78:	cd b7       	in	r28, 0x3d	; 61
     d7a:	de b7       	in	r29, 0x3e	; 62
	TCCR2 &=~ (1<<COM21);
     d7c:	a5 e4       	ldi	r26, 0x45	; 69
     d7e:	b0 e0       	ldi	r27, 0x00	; 0
     d80:	e5 e4       	ldi	r30, 0x45	; 69
     d82:	f0 e0       	ldi	r31, 0x00	; 0
     d84:	80 81       	ld	r24, Z
     d86:	8f 7d       	andi	r24, 0xDF	; 223
     d88:	8c 93       	st	X, r24
	TCCR2 &=~ (1<<CS20);
     d8a:	a5 e4       	ldi	r26, 0x45	; 69
     d8c:	b0 e0       	ldi	r27, 0x00	; 0
     d8e:	e5 e4       	ldi	r30, 0x45	; 69
     d90:	f0 e0       	ldi	r31, 0x00	; 0
     d92:	80 81       	ld	r24, Z
     d94:	8e 7f       	andi	r24, 0xFE	; 254
     d96:	8c 93       	st	X, r24
}
     d98:	cf 91       	pop	r28
     d9a:	df 91       	pop	r29
     d9c:	08 95       	ret

00000d9e <READ_IGNITON>:
 *
 *  Created on: Feb 11, 2023
 *      Author: wario
 */
#include "Btn_Handler.h"
uint8_t READ_IGNITON(void){
     d9e:	df 93       	push	r29
     da0:	cf 93       	push	r28
     da2:	0f 92       	push	r0
     da4:	cd b7       	in	r28, 0x3d	; 61
     da6:	de b7       	in	r29, 0x3e	; 62

	DIO_SetPinDir(DIO_PORTA ,Pin0, INPUT);
     da8:	80 e0       	ldi	r24, 0x00	; 0
     daa:	60 e0       	ldi	r22, 0x00	; 0
     dac:	42 e0       	ldi	r20, 0x02	; 2
     dae:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	uint8_t IGNITION_data = DIO_GetPinVal(DIO_PORTA ,Pin0) ;
     db2:	80 e0       	ldi	r24, 0x00	; 0
     db4:	60 e0       	ldi	r22, 0x00	; 0
     db6:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_GetPinVal>
     dba:	89 83       	std	Y+1, r24	; 0x01
	return IGNITION_data;
     dbc:	89 81       	ldd	r24, Y+1	; 0x01
}
     dbe:	0f 90       	pop	r0
     dc0:	cf 91       	pop	r28
     dc2:	df 91       	pop	r29
     dc4:	08 95       	ret

00000dc6 <READ_HAZARD_Button>:
uint8_t READ_HAZARD_Button(void){
     dc6:	df 93       	push	r29
     dc8:	cf 93       	push	r28
     dca:	0f 92       	push	r0
     dcc:	cd b7       	in	r28, 0x3d	; 61
     dce:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTA ,Pin1, INPUT);
     dd0:	80 e0       	ldi	r24, 0x00	; 0
     dd2:	61 e0       	ldi	r22, 0x01	; 1
     dd4:	42 e0       	ldi	r20, 0x02	; 2
     dd6:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	uint8_t HAZARD_data = DIO_GetPinVal(DIO_PORTA ,Pin1) ;
     dda:	80 e0       	ldi	r24, 0x00	; 0
     ddc:	61 e0       	ldi	r22, 0x01	; 1
     dde:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_GetPinVal>
     de2:	89 83       	std	Y+1, r24	; 0x01
	 return pressed ;
	 }else{
	 return unpressed;
	 }
	 */
	return HAZARD_data;
     de4:	89 81       	ldd	r24, Y+1	; 0x01
}
     de6:	0f 90       	pop	r0
     de8:	cf 91       	pop	r28
     dea:	df 91       	pop	r29
     dec:	08 95       	ret

00000dee <READ_RIGHT_Button>:
uint8_t READ_RIGHT_Button(void){
     dee:	df 93       	push	r29
     df0:	cf 93       	push	r28
     df2:	0f 92       	push	r0
     df4:	cd b7       	in	r28, 0x3d	; 61
     df6:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTA ,Pin2, INPUT);
     df8:	80 e0       	ldi	r24, 0x00	; 0
     dfa:	62 e0       	ldi	r22, 0x02	; 2
     dfc:	42 e0       	ldi	r20, 0x02	; 2
     dfe:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	uint8_t right_data  = DIO_GetPinVal(DIO_PORTA ,Pin2) ;
     e02:	80 e0       	ldi	r24, 0x00	; 0
     e04:	62 e0       	ldi	r22, 0x02	; 2
     e06:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_GetPinVal>
     e0a:	89 83       	std	Y+1, r24	; 0x01
	return right_data ;
     e0c:	89 81       	ldd	r24, Y+1	; 0x01
}
     e0e:	0f 90       	pop	r0
     e10:	cf 91       	pop	r28
     e12:	df 91       	pop	r29
     e14:	08 95       	ret

00000e16 <READ_LEFT_Button>:
uint8_t READ_LEFT_Button(void){
     e16:	df 93       	push	r29
     e18:	cf 93       	push	r28
     e1a:	0f 92       	push	r0
     e1c:	cd b7       	in	r28, 0x3d	; 61
     e1e:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTA ,Pin3, INPUT);
     e20:	80 e0       	ldi	r24, 0x00	; 0
     e22:	63 e0       	ldi	r22, 0x03	; 3
     e24:	42 e0       	ldi	r20, 0x02	; 2
     e26:	0e 94 9d 03 	call	0x73a	; 0x73a <DIO_SetPinDir>
	uint8_t right_data  = DIO_GetPinVal(DIO_PORTA ,Pin3) ;
     e2a:	80 e0       	ldi	r24, 0x00	; 0
     e2c:	63 e0       	ldi	r22, 0x03	; 3
     e2e:	0e 94 77 05 	call	0xaee	; 0xaee <DIO_GetPinVal>
     e32:	89 83       	std	Y+1, r24	; 0x01
	return right_data;
     e34:	89 81       	ldd	r24, Y+1	; 0x01

}
     e36:	0f 90       	pop	r0
     e38:	cf 91       	pop	r28
     e3a:	df 91       	pop	r29
     e3c:	08 95       	ret

00000e3e <vBlink_Right>:
 */

#include"LED.h"
#include"PWM.h"

void vBlink_Right(char led_mode ){
     e3e:	df 93       	push	r29
     e40:	cf 93       	push	r28
     e42:	0f 92       	push	r0
     e44:	cd b7       	in	r28, 0x3d	; 61
     e46:	de b7       	in	r29, 0x3e	; 62
     e48:	89 83       	std	Y+1, r24	; 0x01
		if(led_mode){
     e4a:	89 81       	ldd	r24, Y+1	; 0x01
     e4c:	88 23       	and	r24, r24
     e4e:	19 f0       	breq	.+6      	; 0xe56 <vBlink_Right+0x18>
			Start_PWM1();
     e50:	0e 94 87 06 	call	0xd0e	; 0xd0e <Start_PWM1>
     e54:	02 c0       	rjmp	.+4      	; 0xe5a <vBlink_Right+0x1c>
		}else{
			Stop_PWM1();
     e56:	0e 94 a5 06 	call	0xd4a	; 0xd4a <Stop_PWM1>
	}
}
     e5a:	0f 90       	pop	r0
     e5c:	cf 91       	pop	r28
     e5e:	df 91       	pop	r29
     e60:	08 95       	ret

00000e62 <Blink_LEFT>:

void Blink_LEFT(char led_mode){
     e62:	df 93       	push	r29
     e64:	cf 93       	push	r28
     e66:	0f 92       	push	r0
     e68:	cd b7       	in	r28, 0x3d	; 61
     e6a:	de b7       	in	r29, 0x3e	; 62
     e6c:	89 83       	std	Y+1, r24	; 0x01
		if(led_mode){
     e6e:	89 81       	ldd	r24, Y+1	; 0x01
     e70:	88 23       	and	r24, r24
     e72:	19 f0       	breq	.+6      	; 0xe7a <Blink_LEFT+0x18>
			Start_PWM2();
     e74:	0e 94 96 06 	call	0xd2c	; 0xd2c <Start_PWM2>
     e78:	02 c0       	rjmp	.+4      	; 0xe7e <Blink_LEFT+0x1c>
		}else{
			Stop_PWM2();
     e7a:	0e 94 ba 06 	call	0xd74	; 0xd74 <Stop_PWM2>
		}
}
     e7e:	0f 90       	pop	r0
     e80:	cf 91       	pop	r28
     e82:	df 91       	pop	r29
     e84:	08 95       	ret

00000e86 <Stop_Blinking_Right>:
void Stop_Blinking_Right(void){
     e86:	df 93       	push	r29
     e88:	cf 93       	push	r28
     e8a:	cd b7       	in	r28, 0x3d	; 61
     e8c:	de b7       	in	r29, 0x3e	; 62
	Stop_PWM1();
     e8e:	0e 94 a5 06 	call	0xd4a	; 0xd4a <Stop_PWM1>
}
     e92:	cf 91       	pop	r28
     e94:	df 91       	pop	r29
     e96:	08 95       	ret

00000e98 <Stop_Blinking_Left>:
void Stop_Blinking_Left(void){
     e98:	df 93       	push	r29
     e9a:	cf 93       	push	r28
     e9c:	cd b7       	in	r28, 0x3d	; 61
     e9e:	de b7       	in	r29, 0x3e	; 62
	Stop_PWM2();
     ea0:	0e 94 ba 06 	call	0xd74	; 0xd74 <Stop_PWM2>
}
     ea4:	cf 91       	pop	r28
     ea6:	df 91       	pop	r29
     ea8:	08 95       	ret

00000eaa <xCoRoutineCreate>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode,
                                 UBaseType_t uxPriority,
                                 UBaseType_t uxIndex )
    {
     eaa:	df 93       	push	r29
     eac:	cf 93       	push	r28
     eae:	cd b7       	in	r28, 0x3d	; 61
     eb0:	de b7       	in	r29, 0x3e	; 62
     eb2:	27 97       	sbiw	r28, 0x07	; 7
     eb4:	0f b6       	in	r0, 0x3f	; 63
     eb6:	f8 94       	cli
     eb8:	de bf       	out	0x3e, r29	; 62
     eba:	0f be       	out	0x3f, r0	; 63
     ebc:	cd bf       	out	0x3d, r28	; 61
     ebe:	9d 83       	std	Y+5, r25	; 0x05
     ec0:	8c 83       	std	Y+4, r24	; 0x04
     ec2:	6e 83       	std	Y+6, r22	; 0x06
     ec4:	4f 83       	std	Y+7, r20	; 0x07
        BaseType_t xReturn;
        CRCB_t * pxCoRoutine;

        /* Allocate the memory that will store the co-routine control block. */
        pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     ec6:	8a e1       	ldi	r24, 0x1A	; 26
     ec8:	90 e0       	ldi	r25, 0x00	; 0
     eca:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     ece:	9a 83       	std	Y+2, r25	; 0x02
     ed0:	89 83       	std	Y+1, r24	; 0x01

        if( pxCoRoutine )
     ed2:	89 81       	ldd	r24, Y+1	; 0x01
     ed4:	9a 81       	ldd	r25, Y+2	; 0x02
     ed6:	00 97       	sbiw	r24, 0x00	; 0
     ed8:	09 f4       	brne	.+2      	; 0xedc <xCoRoutineCreate+0x32>
     eda:	6f c0       	rjmp	.+222    	; 0xfba <xCoRoutineCreate+0x110>
        {
            /* If pxCurrentCoRoutine is NULL then this is the first co-routine to
            * be created and the co-routine data structures need initialising. */
            if( pxCurrentCoRoutine == NULL )
     edc:	80 91 70 06 	lds	r24, 0x0670
     ee0:	90 91 71 06 	lds	r25, 0x0671
     ee4:	00 97       	sbiw	r24, 0x00	; 0
     ee6:	41 f4       	brne	.+16     	; 0xef8 <xCoRoutineCreate+0x4e>
            {
                pxCurrentCoRoutine = pxCoRoutine;
     ee8:	89 81       	ldd	r24, Y+1	; 0x01
     eea:	9a 81       	ldd	r25, Y+2	; 0x02
     eec:	90 93 71 06 	sts	0x0671, r25
     ef0:	80 93 70 06 	sts	0x0670, r24
                prvInitialiseCoRoutineLists();
     ef4:	0e 94 c3 09 	call	0x1386	; 0x1386 <prvInitialiseCoRoutineLists>
            }

            /* Check the priority is within limits. */
            if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     ef8:	8e 81       	ldd	r24, Y+6	; 0x06
     efa:	82 30       	cpi	r24, 0x02	; 2
     efc:	10 f0       	brcs	.+4      	; 0xf02 <xCoRoutineCreate+0x58>
            {
                uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     efe:	81 e0       	ldi	r24, 0x01	; 1
     f00:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Fill out the co-routine control block from the function parameters. */
            pxCoRoutine->uxState = corINITIAL_STATE;
     f02:	e9 81       	ldd	r30, Y+1	; 0x01
     f04:	fa 81       	ldd	r31, Y+2	; 0x02
     f06:	11 8e       	std	Z+25, r1	; 0x19
     f08:	10 8e       	std	Z+24, r1	; 0x18
            pxCoRoutine->uxPriority = uxPriority;
     f0a:	e9 81       	ldd	r30, Y+1	; 0x01
     f0c:	fa 81       	ldd	r31, Y+2	; 0x02
     f0e:	8e 81       	ldd	r24, Y+6	; 0x06
     f10:	86 8b       	std	Z+22, r24	; 0x16
            pxCoRoutine->uxIndex = uxIndex;
     f12:	e9 81       	ldd	r30, Y+1	; 0x01
     f14:	fa 81       	ldd	r31, Y+2	; 0x02
     f16:	8f 81       	ldd	r24, Y+7	; 0x07
     f18:	87 8b       	std	Z+23, r24	; 0x17
            pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     f1a:	e9 81       	ldd	r30, Y+1	; 0x01
     f1c:	fa 81       	ldd	r31, Y+2	; 0x02
     f1e:	8c 81       	ldd	r24, Y+4	; 0x04
     f20:	9d 81       	ldd	r25, Y+5	; 0x05
     f22:	91 83       	std	Z+1, r25	; 0x01
     f24:	80 83       	st	Z, r24

            /* Initialise all the other co-routine control block parameters. */
            vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     f26:	89 81       	ldd	r24, Y+1	; 0x01
     f28:	9a 81       	ldd	r25, Y+2	; 0x02
     f2a:	02 96       	adiw	r24, 0x02	; 2
     f2c:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <vListInitialiseItem>
            vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     f30:	89 81       	ldd	r24, Y+1	; 0x01
     f32:	9a 81       	ldd	r25, Y+2	; 0x02
     f34:	0c 96       	adiw	r24, 0x0c	; 12
     f36:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <vListInitialiseItem>

            /* Set the co-routine control block as a link back from the ListItem_t.
             * This is so we can get back to the containing CRCB from a generic item
             * in a list. */
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     f3a:	e9 81       	ldd	r30, Y+1	; 0x01
     f3c:	fa 81       	ldd	r31, Y+2	; 0x02
     f3e:	89 81       	ldd	r24, Y+1	; 0x01
     f40:	9a 81       	ldd	r25, Y+2	; 0x02
     f42:	91 87       	std	Z+9, r25	; 0x09
     f44:	80 87       	std	Z+8, r24	; 0x08
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     f46:	e9 81       	ldd	r30, Y+1	; 0x01
     f48:	fa 81       	ldd	r31, Y+2	; 0x02
     f4a:	89 81       	ldd	r24, Y+1	; 0x01
     f4c:	9a 81       	ldd	r25, Y+2	; 0x02
     f4e:	93 8b       	std	Z+19, r25	; 0x13
     f50:	82 8b       	std	Z+18, r24	; 0x12

            /* Event lists are always in priority order. */
            listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     f52:	8e 81       	ldd	r24, Y+6	; 0x06
     f54:	28 2f       	mov	r18, r24
     f56:	30 e0       	ldi	r19, 0x00	; 0
     f58:	82 e0       	ldi	r24, 0x02	; 2
     f5a:	90 e0       	ldi	r25, 0x00	; 0
     f5c:	82 1b       	sub	r24, r18
     f5e:	93 0b       	sbc	r25, r19
     f60:	e9 81       	ldd	r30, Y+1	; 0x01
     f62:	fa 81       	ldd	r31, Y+2	; 0x02
     f64:	95 87       	std	Z+13, r25	; 0x0d
     f66:	84 87       	std	Z+12, r24	; 0x0c

            /* Now the co-routine has been initialised it can be added to the ready
             * list at the correct priority. */
            prvAddCoRoutineToReadyQueue( pxCoRoutine );
     f68:	e9 81       	ldd	r30, Y+1	; 0x01
     f6a:	fa 81       	ldd	r31, Y+2	; 0x02
     f6c:	96 89       	ldd	r25, Z+22	; 0x16
     f6e:	80 91 72 06 	lds	r24, 0x0672
     f72:	89 17       	cp	r24, r25
     f74:	28 f4       	brcc	.+10     	; 0xf80 <xCoRoutineCreate+0xd6>
     f76:	e9 81       	ldd	r30, Y+1	; 0x01
     f78:	fa 81       	ldd	r31, Y+2	; 0x02
     f7a:	86 89       	ldd	r24, Z+22	; 0x16
     f7c:	80 93 72 06 	sts	0x0672, r24
     f80:	e9 81       	ldd	r30, Y+1	; 0x01
     f82:	fa 81       	ldd	r31, Y+2	; 0x02
     f84:	86 89       	ldd	r24, Z+22	; 0x16
     f86:	28 2f       	mov	r18, r24
     f88:	30 e0       	ldi	r19, 0x00	; 0
     f8a:	c9 01       	movw	r24, r18
     f8c:	88 0f       	add	r24, r24
     f8e:	99 1f       	adc	r25, r25
     f90:	88 0f       	add	r24, r24
     f92:	99 1f       	adc	r25, r25
     f94:	88 0f       	add	r24, r24
     f96:	99 1f       	adc	r25, r25
     f98:	82 0f       	add	r24, r18
     f9a:	93 1f       	adc	r25, r19
     f9c:	ac 01       	movw	r20, r24
     f9e:	47 58       	subi	r20, 0x87	; 135
     fa0:	59 4f       	sbci	r21, 0xF9	; 249
     fa2:	89 81       	ldd	r24, Y+1	; 0x01
     fa4:	9a 81       	ldd	r25, Y+2	; 0x02
     fa6:	9c 01       	movw	r18, r24
     fa8:	2e 5f       	subi	r18, 0xFE	; 254
     faa:	3f 4f       	sbci	r19, 0xFF	; 255
     fac:	ca 01       	movw	r24, r20
     fae:	b9 01       	movw	r22, r18
     fb0:	0e 94 b3 0d 	call	0x1b66	; 0x1b66 <vListInsertEnd>

            xReturn = pdPASS;
     fb4:	81 e0       	ldi	r24, 0x01	; 1
     fb6:	8b 83       	std	Y+3, r24	; 0x03
     fb8:	02 c0       	rjmp	.+4      	; 0xfbe <xCoRoutineCreate+0x114>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     fba:	8f ef       	ldi	r24, 0xFF	; 255
     fbc:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
     fbe:	8b 81       	ldd	r24, Y+3	; 0x03
    }
     fc0:	27 96       	adiw	r28, 0x07	; 7
     fc2:	0f b6       	in	r0, 0x3f	; 63
     fc4:	f8 94       	cli
     fc6:	de bf       	out	0x3e, r29	; 62
     fc8:	0f be       	out	0x3f, r0	; 63
     fca:	cd bf       	out	0x3d, r28	; 61
     fcc:	cf 91       	pop	r28
     fce:	df 91       	pop	r29
     fd0:	08 95       	ret

00000fd2 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

    void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay,
                                     List_t * pxEventList )
    {
     fd2:	df 93       	push	r29
     fd4:	cf 93       	push	r28
     fd6:	00 d0       	rcall	.+0      	; 0xfd8 <vCoRoutineAddToDelayedList+0x6>
     fd8:	00 d0       	rcall	.+0      	; 0xfda <vCoRoutineAddToDelayedList+0x8>
     fda:	00 d0       	rcall	.+0      	; 0xfdc <vCoRoutineAddToDelayedList+0xa>
     fdc:	cd b7       	in	r28, 0x3d	; 61
     fde:	de b7       	in	r29, 0x3e	; 62
     fe0:	9c 83       	std	Y+4, r25	; 0x04
     fe2:	8b 83       	std	Y+3, r24	; 0x03
     fe4:	7e 83       	std	Y+6, r23	; 0x06
     fe6:	6d 83       	std	Y+5, r22	; 0x05
        TickType_t xTimeToWake;

        /* Calculate the time to wake - this may overflow but this is
         * not a problem. */
        xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     fe8:	20 91 73 06 	lds	r18, 0x0673
     fec:	30 91 74 06 	lds	r19, 0x0674
     ff0:	8b 81       	ldd	r24, Y+3	; 0x03
     ff2:	9c 81       	ldd	r25, Y+4	; 0x04
     ff4:	82 0f       	add	r24, r18
     ff6:	93 1f       	adc	r25, r19
     ff8:	9a 83       	std	Y+2, r25	; 0x02
     ffa:	89 83       	std	Y+1, r24	; 0x01

        /* We must remove ourselves from the ready list before adding
         * ourselves to the blocked list as the same list item is used for
         * both lists. */
        ( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     ffc:	80 91 70 06 	lds	r24, 0x0670
    1000:	90 91 71 06 	lds	r25, 0x0671
    1004:	02 96       	adiw	r24, 0x02	; 2
    1006:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <uxListRemove>

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    100a:	e0 91 70 06 	lds	r30, 0x0670
    100e:	f0 91 71 06 	lds	r31, 0x0671
    1012:	89 81       	ldd	r24, Y+1	; 0x01
    1014:	9a 81       	ldd	r25, Y+2	; 0x02
    1016:	93 83       	std	Z+3, r25	; 0x03
    1018:	82 83       	std	Z+2, r24	; 0x02

        if( xTimeToWake < xCoRoutineTickCount )
    101a:	20 91 73 06 	lds	r18, 0x0673
    101e:	30 91 74 06 	lds	r19, 0x0674
    1022:	89 81       	ldd	r24, Y+1	; 0x01
    1024:	9a 81       	ldd	r25, Y+2	; 0x02
    1026:	82 17       	cp	r24, r18
    1028:	93 07       	cpc	r25, r19
    102a:	70 f4       	brcc	.+28     	; 0x1048 <vCoRoutineAddToDelayedList+0x76>
        {
            /* Wake time has overflowed.  Place this item in the
             * overflow list. */
            vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    102c:	80 91 6e 06 	lds	r24, 0x066E
    1030:	90 91 6f 06 	lds	r25, 0x066F
    1034:	20 91 70 06 	lds	r18, 0x0670
    1038:	30 91 71 06 	lds	r19, 0x0671
    103c:	2e 5f       	subi	r18, 0xFE	; 254
    103e:	3f 4f       	sbci	r19, 0xFF	; 255
    1040:	b9 01       	movw	r22, r18
    1042:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <vListInsert>
    1046:	0d c0       	rjmp	.+26     	; 0x1062 <vCoRoutineAddToDelayedList+0x90>
        }
        else
        {
            /* The wake time has not overflowed, so we can use the
             * current block list. */
            vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1048:	80 91 6c 06 	lds	r24, 0x066C
    104c:	90 91 6d 06 	lds	r25, 0x066D
    1050:	20 91 70 06 	lds	r18, 0x0670
    1054:	30 91 71 06 	lds	r19, 0x0671
    1058:	2e 5f       	subi	r18, 0xFE	; 254
    105a:	3f 4f       	sbci	r19, 0xFF	; 255
    105c:	b9 01       	movw	r22, r18
    105e:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <vListInsert>
        }

        if( pxEventList )
    1062:	8d 81       	ldd	r24, Y+5	; 0x05
    1064:	9e 81       	ldd	r25, Y+6	; 0x06
    1066:	00 97       	sbiw	r24, 0x00	; 0
    1068:	61 f0       	breq	.+24     	; 0x1082 <vCoRoutineAddToDelayedList+0xb0>
        {
            /* Also add the co-routine to an event list.  If this is done then the
             * function must be called with interrupts disabled. */
            vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    106a:	80 91 70 06 	lds	r24, 0x0670
    106e:	90 91 71 06 	lds	r25, 0x0671
    1072:	9c 01       	movw	r18, r24
    1074:	24 5f       	subi	r18, 0xF4	; 244
    1076:	3f 4f       	sbci	r19, 0xFF	; 255
    1078:	8d 81       	ldd	r24, Y+5	; 0x05
    107a:	9e 81       	ldd	r25, Y+6	; 0x06
    107c:	b9 01       	movw	r22, r18
    107e:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <vListInsert>
        }
    }
    1082:	26 96       	adiw	r28, 0x06	; 6
    1084:	0f b6       	in	r0, 0x3f	; 63
    1086:	f8 94       	cli
    1088:	de bf       	out	0x3e, r29	; 62
    108a:	0f be       	out	0x3f, r0	; 63
    108c:	cd bf       	out	0x3d, r28	; 61
    108e:	cf 91       	pop	r28
    1090:	df 91       	pop	r29
    1092:	08 95       	ret

00001094 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

    static void prvCheckPendingReadyList( void )
    {
    1094:	df 93       	push	r29
    1096:	cf 93       	push	r28
    1098:	00 d0       	rcall	.+0      	; 0x109a <prvCheckPendingReadyList+0x6>
    109a:	cd b7       	in	r28, 0x3d	; 61
    109c:	de b7       	in	r29, 0x3e	; 62
    109e:	3a c0       	rjmp	.+116    	; 0x1114 <prvCheckPendingReadyList+0x80>
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
        {
            CRCB_t * pxUnblockedCRCB;

            /* The pending ready list can be accessed by an ISR. */
            portDISABLE_INTERRUPTS();
    10a0:	f8 94       	cli
            {
                pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyCoRoutineList ) );
    10a2:	e0 91 a2 06 	lds	r30, 0x06A2
    10a6:	f0 91 a3 06 	lds	r31, 0x06A3
    10aa:	86 81       	ldd	r24, Z+6	; 0x06
    10ac:	97 81       	ldd	r25, Z+7	; 0x07
    10ae:	9a 83       	std	Y+2, r25	; 0x02
    10b0:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    10b2:	89 81       	ldd	r24, Y+1	; 0x01
    10b4:	9a 81       	ldd	r25, Y+2	; 0x02
    10b6:	0c 96       	adiw	r24, 0x0c	; 12
    10b8:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <uxListRemove>
            }
            portENABLE_INTERRUPTS();
    10bc:	78 94       	sei

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    10be:	89 81       	ldd	r24, Y+1	; 0x01
    10c0:	9a 81       	ldd	r25, Y+2	; 0x02
    10c2:	02 96       	adiw	r24, 0x02	; 2
    10c4:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <uxListRemove>
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    10c8:	e9 81       	ldd	r30, Y+1	; 0x01
    10ca:	fa 81       	ldd	r31, Y+2	; 0x02
    10cc:	96 89       	ldd	r25, Z+22	; 0x16
    10ce:	80 91 72 06 	lds	r24, 0x0672
    10d2:	89 17       	cp	r24, r25
    10d4:	28 f4       	brcc	.+10     	; 0x10e0 <prvCheckPendingReadyList+0x4c>
    10d6:	e9 81       	ldd	r30, Y+1	; 0x01
    10d8:	fa 81       	ldd	r31, Y+2	; 0x02
    10da:	86 89       	ldd	r24, Z+22	; 0x16
    10dc:	80 93 72 06 	sts	0x0672, r24
    10e0:	e9 81       	ldd	r30, Y+1	; 0x01
    10e2:	fa 81       	ldd	r31, Y+2	; 0x02
    10e4:	86 89       	ldd	r24, Z+22	; 0x16
    10e6:	28 2f       	mov	r18, r24
    10e8:	30 e0       	ldi	r19, 0x00	; 0
    10ea:	c9 01       	movw	r24, r18
    10ec:	88 0f       	add	r24, r24
    10ee:	99 1f       	adc	r25, r25
    10f0:	88 0f       	add	r24, r24
    10f2:	99 1f       	adc	r25, r25
    10f4:	88 0f       	add	r24, r24
    10f6:	99 1f       	adc	r25, r25
    10f8:	82 0f       	add	r24, r18
    10fa:	93 1f       	adc	r25, r19
    10fc:	ac 01       	movw	r20, r24
    10fe:	47 58       	subi	r20, 0x87	; 135
    1100:	59 4f       	sbci	r21, 0xF9	; 249
    1102:	89 81       	ldd	r24, Y+1	; 0x01
    1104:	9a 81       	ldd	r25, Y+2	; 0x02
    1106:	9c 01       	movw	r18, r24
    1108:	2e 5f       	subi	r18, 0xFE	; 254
    110a:	3f 4f       	sbci	r19, 0xFF	; 255
    110c:	ca 01       	movw	r24, r20
    110e:	b9 01       	movw	r22, r18
    1110:	0e 94 b3 0d 	call	0x1b66	; 0x1b66 <vListInsertEnd>
    static void prvCheckPendingReadyList( void )
    {
        /* Are there any co-routines waiting to get moved to the ready list?  These
         * are co-routines that have been readied by an ISR.  The ISR cannot access
         * the ready lists itself. */
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1114:	80 91 9d 06 	lds	r24, 0x069D
    1118:	88 23       	and	r24, r24
    111a:	09 f0       	breq	.+2      	; 0x111e <prvCheckPendingReadyList+0x8a>
    111c:	c1 cf       	rjmp	.-126    	; 0x10a0 <prvCheckPendingReadyList+0xc>
            portENABLE_INTERRUPTS();

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
        }
    }
    111e:	0f 90       	pop	r0
    1120:	0f 90       	pop	r0
    1122:	cf 91       	pop	r28
    1124:	df 91       	pop	r29
    1126:	08 95       	ret

00001128 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

    static void prvCheckDelayedList( void )
    {
    1128:	df 93       	push	r29
    112a:	cf 93       	push	r28
    112c:	00 d0       	rcall	.+0      	; 0x112e <prvCheckDelayedList+0x6>
    112e:	00 d0       	rcall	.+0      	; 0x1130 <prvCheckDelayedList+0x8>
    1130:	cd b7       	in	r28, 0x3d	; 61
    1132:	de b7       	in	r29, 0x3e	; 62
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1134:	0e 94 b2 1c 	call	0x3964	; 0x3964 <xTaskGetTickCount>
    1138:	20 91 75 06 	lds	r18, 0x0675
    113c:	30 91 76 06 	lds	r19, 0x0676
    1140:	82 1b       	sub	r24, r18
    1142:	93 0b       	sbc	r25, r19
    1144:	90 93 78 06 	sts	0x0678, r25
    1148:	80 93 77 06 	sts	0x0677, r24
    114c:	85 c0       	rjmp	.+266    	; 0x1258 <prvCheckDelayedList+0x130>

        while( xPassedTicks )
        {
            xCoRoutineTickCount++;
    114e:	80 91 73 06 	lds	r24, 0x0673
    1152:	90 91 74 06 	lds	r25, 0x0674
    1156:	01 96       	adiw	r24, 0x01	; 1
    1158:	90 93 74 06 	sts	0x0674, r25
    115c:	80 93 73 06 	sts	0x0673, r24
            xPassedTicks--;
    1160:	80 91 77 06 	lds	r24, 0x0677
    1164:	90 91 78 06 	lds	r25, 0x0678
    1168:	01 97       	sbiw	r24, 0x01	; 1
    116a:	90 93 78 06 	sts	0x0678, r25
    116e:	80 93 77 06 	sts	0x0677, r24

            /* If the tick count has overflowed we need to swap the ready lists. */
            if( xCoRoutineTickCount == 0 )
    1172:	80 91 73 06 	lds	r24, 0x0673
    1176:	90 91 74 06 	lds	r25, 0x0674
    117a:	00 97       	sbiw	r24, 0x00	; 0
    117c:	09 f0       	breq	.+2      	; 0x1180 <prvCheckDelayedList+0x58>
    117e:	64 c0       	rjmp	.+200    	; 0x1248 <prvCheckDelayedList+0x120>
            {
                List_t * pxTemp;

                /* Tick count has overflowed so we need to swap the delay lists.  If there are
                 * any items in pxDelayedCoRoutineList here then there is an error! */
                pxTemp = pxDelayedCoRoutineList;
    1180:	80 91 6c 06 	lds	r24, 0x066C
    1184:	90 91 6d 06 	lds	r25, 0x066D
    1188:	9a 83       	std	Y+2, r25	; 0x02
    118a:	89 83       	std	Y+1, r24	; 0x01
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    118c:	80 91 6e 06 	lds	r24, 0x066E
    1190:	90 91 6f 06 	lds	r25, 0x066F
    1194:	90 93 6d 06 	sts	0x066D, r25
    1198:	80 93 6c 06 	sts	0x066C, r24
                pxOverflowDelayedCoRoutineList = pxTemp;
    119c:	89 81       	ldd	r24, Y+1	; 0x01
    119e:	9a 81       	ldd	r25, Y+2	; 0x02
    11a0:	90 93 6f 06 	sts	0x066F, r25
    11a4:	80 93 6e 06 	sts	0x066E, r24
    11a8:	4f c0       	rjmp	.+158    	; 0x1248 <prvCheckDelayedList+0x120>
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
            {
                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    11aa:	e0 91 6c 06 	lds	r30, 0x066C
    11ae:	f0 91 6d 06 	lds	r31, 0x066D
    11b2:	05 80       	ldd	r0, Z+5	; 0x05
    11b4:	f6 81       	ldd	r31, Z+6	; 0x06
    11b6:	e0 2d       	mov	r30, r0
    11b8:	86 81       	ldd	r24, Z+6	; 0x06
    11ba:	97 81       	ldd	r25, Z+7	; 0x07
    11bc:	9c 83       	std	Y+4, r25	; 0x04
    11be:	8b 83       	std	Y+3, r24	; 0x03

                if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    11c0:	eb 81       	ldd	r30, Y+3	; 0x03
    11c2:	fc 81       	ldd	r31, Y+4	; 0x04
    11c4:	22 81       	ldd	r18, Z+2	; 0x02
    11c6:	33 81       	ldd	r19, Z+3	; 0x03
    11c8:	80 91 73 06 	lds	r24, 0x0673
    11cc:	90 91 74 06 	lds	r25, 0x0674
    11d0:	82 17       	cp	r24, r18
    11d2:	93 07       	cpc	r25, r19
    11d4:	08 f4       	brcc	.+2      	; 0x11d8 <prvCheckDelayedList+0xb0>
    11d6:	40 c0       	rjmp	.+128    	; 0x1258 <prvCheckDelayedList+0x130>
                {
                    /* Timeout not yet expired. */
                    break;
                }

                portDISABLE_INTERRUPTS();
    11d8:	f8 94       	cli
                    /* The event could have occurred just before this critical
                     *  section.  If this is the case then the generic list item will
                     *  have been moved to the pending ready list and the following
                     *  line is still valid.  Also the pvContainer parameter will have
                     *  been set to NULL so the following lines are also valid. */
                    ( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
    11da:	8b 81       	ldd	r24, Y+3	; 0x03
    11dc:	9c 81       	ldd	r25, Y+4	; 0x04
    11de:	02 96       	adiw	r24, 0x02	; 2
    11e0:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <uxListRemove>

                    /* Is the co-routine waiting on an event also? */
                    if( pxCRCB->xEventListItem.pxContainer )
    11e4:	eb 81       	ldd	r30, Y+3	; 0x03
    11e6:	fc 81       	ldd	r31, Y+4	; 0x04
    11e8:	84 89       	ldd	r24, Z+20	; 0x14
    11ea:	95 89       	ldd	r25, Z+21	; 0x15
    11ec:	00 97       	sbiw	r24, 0x00	; 0
    11ee:	29 f0       	breq	.+10     	; 0x11fa <prvCheckDelayedList+0xd2>
                    {
                        ( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
    11f0:	8b 81       	ldd	r24, Y+3	; 0x03
    11f2:	9c 81       	ldd	r25, Y+4	; 0x04
    11f4:	0c 96       	adiw	r24, 0x0c	; 12
    11f6:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <uxListRemove>
                    }
                }
                portENABLE_INTERRUPTS();
    11fa:	78 94       	sei

                prvAddCoRoutineToReadyQueue( pxCRCB );
    11fc:	eb 81       	ldd	r30, Y+3	; 0x03
    11fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1200:	96 89       	ldd	r25, Z+22	; 0x16
    1202:	80 91 72 06 	lds	r24, 0x0672
    1206:	89 17       	cp	r24, r25
    1208:	28 f4       	brcc	.+10     	; 0x1214 <prvCheckDelayedList+0xec>
    120a:	eb 81       	ldd	r30, Y+3	; 0x03
    120c:	fc 81       	ldd	r31, Y+4	; 0x04
    120e:	86 89       	ldd	r24, Z+22	; 0x16
    1210:	80 93 72 06 	sts	0x0672, r24
    1214:	eb 81       	ldd	r30, Y+3	; 0x03
    1216:	fc 81       	ldd	r31, Y+4	; 0x04
    1218:	86 89       	ldd	r24, Z+22	; 0x16
    121a:	28 2f       	mov	r18, r24
    121c:	30 e0       	ldi	r19, 0x00	; 0
    121e:	c9 01       	movw	r24, r18
    1220:	88 0f       	add	r24, r24
    1222:	99 1f       	adc	r25, r25
    1224:	88 0f       	add	r24, r24
    1226:	99 1f       	adc	r25, r25
    1228:	88 0f       	add	r24, r24
    122a:	99 1f       	adc	r25, r25
    122c:	82 0f       	add	r24, r18
    122e:	93 1f       	adc	r25, r19
    1230:	ac 01       	movw	r20, r24
    1232:	47 58       	subi	r20, 0x87	; 135
    1234:	59 4f       	sbci	r21, 0xF9	; 249
    1236:	8b 81       	ldd	r24, Y+3	; 0x03
    1238:	9c 81       	ldd	r25, Y+4	; 0x04
    123a:	9c 01       	movw	r18, r24
    123c:	2e 5f       	subi	r18, 0xFE	; 254
    123e:	3f 4f       	sbci	r19, 0xFF	; 255
    1240:	ca 01       	movw	r24, r20
    1242:	b9 01       	movw	r22, r18
    1244:	0e 94 b3 0d 	call	0x1b66	; 0x1b66 <vListInsertEnd>
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
                pxOverflowDelayedCoRoutineList = pxTemp;
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1248:	e0 91 6c 06 	lds	r30, 0x066C
    124c:	f0 91 6d 06 	lds	r31, 0x066D
    1250:	80 81       	ld	r24, Z
    1252:	88 23       	and	r24, r24
    1254:	09 f0       	breq	.+2      	; 0x1258 <prvCheckDelayedList+0x130>
    1256:	a9 cf       	rjmp	.-174    	; 0x11aa <prvCheckDelayedList+0x82>
    {
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;

        while( xPassedTicks )
    1258:	80 91 77 06 	lds	r24, 0x0677
    125c:	90 91 78 06 	lds	r25, 0x0678
    1260:	00 97       	sbiw	r24, 0x00	; 0
    1262:	09 f0       	breq	.+2      	; 0x1266 <prvCheckDelayedList+0x13e>
    1264:	74 cf       	rjmp	.-280    	; 0x114e <prvCheckDelayedList+0x26>

                prvAddCoRoutineToReadyQueue( pxCRCB );
            }
        }

        xLastTickCount = xCoRoutineTickCount;
    1266:	80 91 73 06 	lds	r24, 0x0673
    126a:	90 91 74 06 	lds	r25, 0x0674
    126e:	90 93 76 06 	sts	0x0676, r25
    1272:	80 93 75 06 	sts	0x0675, r24
    }
    1276:	0f 90       	pop	r0
    1278:	0f 90       	pop	r0
    127a:	0f 90       	pop	r0
    127c:	0f 90       	pop	r0
    127e:	cf 91       	pop	r28
    1280:	df 91       	pop	r29
    1282:	08 95       	ret

00001284 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

    void vCoRoutineSchedule( void )
    {
    1284:	df 93       	push	r29
    1286:	cf 93       	push	r28
    1288:	00 d0       	rcall	.+0      	; 0x128a <vCoRoutineSchedule+0x6>
    128a:	cd b7       	in	r28, 0x3d	; 61
    128c:	de b7       	in	r29, 0x3e	; 62
        /* Only run a co-routine after prvInitialiseCoRoutineLists() has been
         * called.  prvInitialiseCoRoutineLists() is called automatically when a
         * co-routine is created. */
        if( pxDelayedCoRoutineList != NULL )
    128e:	80 91 6c 06 	lds	r24, 0x066C
    1292:	90 91 6d 06 	lds	r25, 0x066D
    1296:	00 97       	sbiw	r24, 0x00	; 0
    1298:	09 f4       	brne	.+2      	; 0x129c <vCoRoutineSchedule+0x18>
    129a:	70 c0       	rjmp	.+224    	; 0x137c <vCoRoutineSchedule+0xf8>
        {
            /* See if any co-routines readied by events need moving to the ready lists. */
            prvCheckPendingReadyList();
    129c:	0e 94 4a 08 	call	0x1094	; 0x1094 <prvCheckPendingReadyList>

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();
    12a0:	0e 94 94 08 	call	0x1128	; 0x1128 <prvCheckDelayedList>
    12a4:	0a c0       	rjmp	.+20     	; 0x12ba <vCoRoutineSchedule+0x36>

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
            {
                if( uxTopCoRoutineReadyPriority == 0 )
    12a6:	80 91 72 06 	lds	r24, 0x0672
    12aa:	88 23       	and	r24, r24
    12ac:	09 f4       	brne	.+2      	; 0x12b0 <vCoRoutineSchedule+0x2c>
    12ae:	66 c0       	rjmp	.+204    	; 0x137c <vCoRoutineSchedule+0xf8>
                {
                    /* No more co-routines to check. */
                    return;
                }

                --uxTopCoRoutineReadyPriority;
    12b0:	80 91 72 06 	lds	r24, 0x0672
    12b4:	81 50       	subi	r24, 0x01	; 1
    12b6:	80 93 72 06 	sts	0x0672, r24

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    12ba:	80 91 72 06 	lds	r24, 0x0672
    12be:	28 2f       	mov	r18, r24
    12c0:	30 e0       	ldi	r19, 0x00	; 0
    12c2:	c9 01       	movw	r24, r18
    12c4:	88 0f       	add	r24, r24
    12c6:	99 1f       	adc	r25, r25
    12c8:	88 0f       	add	r24, r24
    12ca:	99 1f       	adc	r25, r25
    12cc:	88 0f       	add	r24, r24
    12ce:	99 1f       	adc	r25, r25
    12d0:	82 0f       	add	r24, r18
    12d2:	93 1f       	adc	r25, r19
    12d4:	fc 01       	movw	r30, r24
    12d6:	e7 58       	subi	r30, 0x87	; 135
    12d8:	f9 4f       	sbci	r31, 0xF9	; 249
    12da:	80 81       	ld	r24, Z
    12dc:	88 23       	and	r24, r24
    12de:	19 f3       	breq	.-58     	; 0x12a6 <vCoRoutineSchedule+0x22>
                --uxTopCoRoutineReadyPriority;
            }

            /* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
             * of the same priority get an equal share of the processor time. */
            listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    12e0:	80 91 72 06 	lds	r24, 0x0672
    12e4:	28 2f       	mov	r18, r24
    12e6:	30 e0       	ldi	r19, 0x00	; 0
    12e8:	c9 01       	movw	r24, r18
    12ea:	88 0f       	add	r24, r24
    12ec:	99 1f       	adc	r25, r25
    12ee:	88 0f       	add	r24, r24
    12f0:	99 1f       	adc	r25, r25
    12f2:	88 0f       	add	r24, r24
    12f4:	99 1f       	adc	r25, r25
    12f6:	82 0f       	add	r24, r18
    12f8:	93 1f       	adc	r25, r19
    12fa:	87 58       	subi	r24, 0x87	; 135
    12fc:	99 4f       	sbci	r25, 0xF9	; 249
    12fe:	9a 83       	std	Y+2, r25	; 0x02
    1300:	89 83       	std	Y+1, r24	; 0x01
    1302:	e9 81       	ldd	r30, Y+1	; 0x01
    1304:	fa 81       	ldd	r31, Y+2	; 0x02
    1306:	01 80       	ldd	r0, Z+1	; 0x01
    1308:	f2 81       	ldd	r31, Z+2	; 0x02
    130a:	e0 2d       	mov	r30, r0
    130c:	82 81       	ldd	r24, Z+2	; 0x02
    130e:	93 81       	ldd	r25, Z+3	; 0x03
    1310:	e9 81       	ldd	r30, Y+1	; 0x01
    1312:	fa 81       	ldd	r31, Y+2	; 0x02
    1314:	92 83       	std	Z+2, r25	; 0x02
    1316:	81 83       	std	Z+1, r24	; 0x01
    1318:	e9 81       	ldd	r30, Y+1	; 0x01
    131a:	fa 81       	ldd	r31, Y+2	; 0x02
    131c:	21 81       	ldd	r18, Z+1	; 0x01
    131e:	32 81       	ldd	r19, Z+2	; 0x02
    1320:	89 81       	ldd	r24, Y+1	; 0x01
    1322:	9a 81       	ldd	r25, Y+2	; 0x02
    1324:	03 96       	adiw	r24, 0x03	; 3
    1326:	28 17       	cp	r18, r24
    1328:	39 07       	cpc	r19, r25
    132a:	59 f4       	brne	.+22     	; 0x1342 <vCoRoutineSchedule+0xbe>
    132c:	e9 81       	ldd	r30, Y+1	; 0x01
    132e:	fa 81       	ldd	r31, Y+2	; 0x02
    1330:	01 80       	ldd	r0, Z+1	; 0x01
    1332:	f2 81       	ldd	r31, Z+2	; 0x02
    1334:	e0 2d       	mov	r30, r0
    1336:	82 81       	ldd	r24, Z+2	; 0x02
    1338:	93 81       	ldd	r25, Z+3	; 0x03
    133a:	e9 81       	ldd	r30, Y+1	; 0x01
    133c:	fa 81       	ldd	r31, Y+2	; 0x02
    133e:	92 83       	std	Z+2, r25	; 0x02
    1340:	81 83       	std	Z+1, r24	; 0x01
    1342:	e9 81       	ldd	r30, Y+1	; 0x01
    1344:	fa 81       	ldd	r31, Y+2	; 0x02
    1346:	01 80       	ldd	r0, Z+1	; 0x01
    1348:	f2 81       	ldd	r31, Z+2	; 0x02
    134a:	e0 2d       	mov	r30, r0
    134c:	86 81       	ldd	r24, Z+6	; 0x06
    134e:	97 81       	ldd	r25, Z+7	; 0x07
    1350:	90 93 71 06 	sts	0x0671, r25
    1354:	80 93 70 06 	sts	0x0670, r24

            /* Call the co-routine. */
            ( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1358:	e0 91 70 06 	lds	r30, 0x0670
    135c:	f0 91 71 06 	lds	r31, 0x0671
    1360:	40 81       	ld	r20, Z
    1362:	51 81       	ldd	r21, Z+1	; 0x01
    1364:	80 91 70 06 	lds	r24, 0x0670
    1368:	90 91 71 06 	lds	r25, 0x0671
    136c:	e0 91 70 06 	lds	r30, 0x0670
    1370:	f0 91 71 06 	lds	r31, 0x0671
    1374:	27 89       	ldd	r18, Z+23	; 0x17
    1376:	62 2f       	mov	r22, r18
    1378:	fa 01       	movw	r30, r20
    137a:	09 95       	icall
        }
    }
    137c:	0f 90       	pop	r0
    137e:	0f 90       	pop	r0
    1380:	cf 91       	pop	r28
    1382:	df 91       	pop	r29
    1384:	08 95       	ret

00001386 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

    static void prvInitialiseCoRoutineLists( void )
    {
    1386:	df 93       	push	r29
    1388:	cf 93       	push	r28
    138a:	0f 92       	push	r0
    138c:	cd b7       	in	r28, 0x3d	; 61
    138e:	de b7       	in	r29, 0x3e	; 62
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1390:	19 82       	std	Y+1, r1	; 0x01
    1392:	13 c0       	rjmp	.+38     	; 0x13ba <prvInitialiseCoRoutineLists+0x34>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1394:	89 81       	ldd	r24, Y+1	; 0x01
    1396:	28 2f       	mov	r18, r24
    1398:	30 e0       	ldi	r19, 0x00	; 0
    139a:	c9 01       	movw	r24, r18
    139c:	88 0f       	add	r24, r24
    139e:	99 1f       	adc	r25, r25
    13a0:	88 0f       	add	r24, r24
    13a2:	99 1f       	adc	r25, r25
    13a4:	88 0f       	add	r24, r24
    13a6:	99 1f       	adc	r25, r25
    13a8:	82 0f       	add	r24, r18
    13aa:	93 1f       	adc	r25, r19
    13ac:	87 58       	subi	r24, 0x87	; 135
    13ae:	99 4f       	sbci	r25, 0xF9	; 249
    13b0:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <vListInitialise>

    static void prvInitialiseCoRoutineLists( void )
    {
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    13b4:	89 81       	ldd	r24, Y+1	; 0x01
    13b6:	8f 5f       	subi	r24, 0xFF	; 255
    13b8:	89 83       	std	Y+1, r24	; 0x01
    13ba:	89 81       	ldd	r24, Y+1	; 0x01
    13bc:	82 30       	cpi	r24, 0x02	; 2
    13be:	50 f3       	brcs	.-44     	; 0x1394 <prvInitialiseCoRoutineLists+0xe>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
        }

        vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
    13c0:	8b e8       	ldi	r24, 0x8B	; 139
    13c2:	96 e0       	ldi	r25, 0x06	; 6
    13c4:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <vListInitialise>
        vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
    13c8:	84 e9       	ldi	r24, 0x94	; 148
    13ca:	96 e0       	ldi	r25, 0x06	; 6
    13cc:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <vListInitialise>
        vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
    13d0:	8d e9       	ldi	r24, 0x9D	; 157
    13d2:	96 e0       	ldi	r25, 0x06	; 6
    13d4:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <vListInitialise>

        /* Start with pxDelayedCoRoutineList using list1 and the
         * pxOverflowDelayedCoRoutineList using list2. */
        pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    13d8:	8b e8       	ldi	r24, 0x8B	; 139
    13da:	96 e0       	ldi	r25, 0x06	; 6
    13dc:	90 93 6d 06 	sts	0x066D, r25
    13e0:	80 93 6c 06 	sts	0x066C, r24
        pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    13e4:	84 e9       	ldi	r24, 0x94	; 148
    13e6:	96 e0       	ldi	r25, 0x06	; 6
    13e8:	90 93 6f 06 	sts	0x066F, r25
    13ec:	80 93 6e 06 	sts	0x066E, r24
    }
    13f0:	0f 90       	pop	r0
    13f2:	cf 91       	pop	r28
    13f4:	df 91       	pop	r29
    13f6:	08 95       	ret

000013f8 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineRemoveFromEventList( const List_t * pxEventList )
    {
    13f8:	df 93       	push	r29
    13fa:	cf 93       	push	r28
    13fc:	00 d0       	rcall	.+0      	; 0x13fe <xCoRoutineRemoveFromEventList+0x6>
    13fe:	00 d0       	rcall	.+0      	; 0x1400 <xCoRoutineRemoveFromEventList+0x8>
    1400:	0f 92       	push	r0
    1402:	cd b7       	in	r28, 0x3d	; 61
    1404:	de b7       	in	r29, 0x3e	; 62
    1406:	9d 83       	std	Y+5, r25	; 0x05
    1408:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;

        /* This function is called from within an interrupt.  It can only access
         * event lists and the pending ready list.  This function assumes that a
         * check has already been made to ensure pxEventList is not empty. */
        pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    140a:	ec 81       	ldd	r30, Y+4	; 0x04
    140c:	fd 81       	ldd	r31, Y+5	; 0x05
    140e:	05 80       	ldd	r0, Z+5	; 0x05
    1410:	f6 81       	ldd	r31, Z+6	; 0x06
    1412:	e0 2d       	mov	r30, r0
    1414:	86 81       	ldd	r24, Z+6	; 0x06
    1416:	97 81       	ldd	r25, Z+7	; 0x07
    1418:	9b 83       	std	Y+3, r25	; 0x03
    141a:	8a 83       	std	Y+2, r24	; 0x02
        ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    141c:	8a 81       	ldd	r24, Y+2	; 0x02
    141e:	9b 81       	ldd	r25, Y+3	; 0x03
    1420:	0c 96       	adiw	r24, 0x0c	; 12
    1422:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <uxListRemove>
        vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1426:	8a 81       	ldd	r24, Y+2	; 0x02
    1428:	9b 81       	ldd	r25, Y+3	; 0x03
    142a:	9c 01       	movw	r18, r24
    142c:	24 5f       	subi	r18, 0xF4	; 244
    142e:	3f 4f       	sbci	r19, 0xFF	; 255
    1430:	8d e9       	ldi	r24, 0x9D	; 157
    1432:	96 e0       	ldi	r25, 0x06	; 6
    1434:	b9 01       	movw	r22, r18
    1436:	0e 94 b3 0d 	call	0x1b66	; 0x1b66 <vListInsertEnd>

        if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    143a:	ea 81       	ldd	r30, Y+2	; 0x02
    143c:	fb 81       	ldd	r31, Y+3	; 0x03
    143e:	96 89       	ldd	r25, Z+22	; 0x16
    1440:	e0 91 70 06 	lds	r30, 0x0670
    1444:	f0 91 71 06 	lds	r31, 0x0671
    1448:	86 89       	ldd	r24, Z+22	; 0x16
    144a:	98 17       	cp	r25, r24
    144c:	18 f0       	brcs	.+6      	; 0x1454 <xCoRoutineRemoveFromEventList+0x5c>
        {
            xReturn = pdTRUE;
    144e:	81 e0       	ldi	r24, 0x01	; 1
    1450:	89 83       	std	Y+1, r24	; 0x01
    1452:	01 c0       	rjmp	.+2      	; 0x1456 <xCoRoutineRemoveFromEventList+0x5e>
        }
        else
        {
            xReturn = pdFALSE;
    1454:	19 82       	std	Y+1, r1	; 0x01
        }

        return xReturn;
    1456:	89 81       	ldd	r24, Y+1	; 0x01
    }
    1458:	0f 90       	pop	r0
    145a:	0f 90       	pop	r0
    145c:	0f 90       	pop	r0
    145e:	0f 90       	pop	r0
    1460:	0f 90       	pop	r0
    1462:	cf 91       	pop	r28
    1464:	df 91       	pop	r29
    1466:	08 95       	ret

00001468 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    1468:	df 93       	push	r29
    146a:	cf 93       	push	r28
    146c:	00 d0       	rcall	.+0      	; 0x146e <xEventGroupCreate+0x6>
    146e:	cd b7       	in	r28, 0x3d	; 61
    1470:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    1472:	8b e0       	ldi	r24, 0x0B	; 11
    1474:	90 e0       	ldi	r25, 0x00	; 0
    1476:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    147a:	9a 83       	std	Y+2, r25	; 0x02
    147c:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
    147e:	89 81       	ldd	r24, Y+1	; 0x01
    1480:	9a 81       	ldd	r25, Y+2	; 0x02
    1482:	00 97       	sbiw	r24, 0x00	; 0
    1484:	49 f0       	breq	.+18     	; 0x1498 <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
    1486:	e9 81       	ldd	r30, Y+1	; 0x01
    1488:	fa 81       	ldd	r31, Y+2	; 0x02
    148a:	11 82       	std	Z+1, r1	; 0x01
    148c:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    148e:	89 81       	ldd	r24, Y+1	; 0x01
    1490:	9a 81       	ldd	r25, Y+2	; 0x02
    1492:	02 96       	adiw	r24, 0x02	; 2
    1494:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    1498:	89 81       	ldd	r24, Y+1	; 0x01
    149a:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    149c:	0f 90       	pop	r0
    149e:	0f 90       	pop	r0
    14a0:	cf 91       	pop	r28
    14a2:	df 91       	pop	r29
    14a4:	08 95       	ret

000014a6 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    14a6:	df 93       	push	r29
    14a8:	cf 93       	push	r28
    14aa:	cd b7       	in	r28, 0x3d	; 61
    14ac:	de b7       	in	r29, 0x3e	; 62
    14ae:	60 97       	sbiw	r28, 0x10	; 16
    14b0:	0f b6       	in	r0, 0x3f	; 63
    14b2:	f8 94       	cli
    14b4:	de bf       	out	0x3e, r29	; 62
    14b6:	0f be       	out	0x3f, r0	; 63
    14b8:	cd bf       	out	0x3d, r28	; 61
    14ba:	9a 87       	std	Y+10, r25	; 0x0a
    14bc:	89 87       	std	Y+9, r24	; 0x09
    14be:	7c 87       	std	Y+12, r23	; 0x0c
    14c0:	6b 87       	std	Y+11, r22	; 0x0b
    14c2:	5e 87       	std	Y+14, r21	; 0x0e
    14c4:	4d 87       	std	Y+13, r20	; 0x0d
    14c6:	38 8b       	std	Y+16, r19	; 0x10
    14c8:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
    14ca:	89 85       	ldd	r24, Y+9	; 0x09
    14cc:	9a 85       	ldd	r25, Y+10	; 0x0a
    14ce:	9c 83       	std	Y+4, r25	; 0x04
    14d0:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    14d2:	19 82       	std	Y+1, r1	; 0x01
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    14d4:	0e 94 56 1b 	call	0x36ac	; 0x36ac <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    14d8:	eb 81       	ldd	r30, Y+3	; 0x03
    14da:	fc 81       	ldd	r31, Y+4	; 0x04
    14dc:	80 81       	ld	r24, Z
    14de:	91 81       	ldd	r25, Z+1	; 0x01
    14e0:	98 87       	std	Y+8, r25	; 0x08
    14e2:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    14e4:	89 85       	ldd	r24, Y+9	; 0x09
    14e6:	9a 85       	ldd	r25, Y+10	; 0x0a
    14e8:	2b 85       	ldd	r18, Y+11	; 0x0b
    14ea:	3c 85       	ldd	r19, Y+12	; 0x0c
    14ec:	b9 01       	movw	r22, r18
    14ee:	0e 94 2a 0c 	call	0x1854	; 0x1854 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    14f2:	2f 81       	ldd	r18, Y+7	; 0x07
    14f4:	38 85       	ldd	r19, Y+8	; 0x08
    14f6:	8b 85       	ldd	r24, Y+11	; 0x0b
    14f8:	9c 85       	ldd	r25, Y+12	; 0x0c
    14fa:	28 2b       	or	r18, r24
    14fc:	39 2b       	or	r19, r25
    14fe:	8d 85       	ldd	r24, Y+13	; 0x0d
    1500:	9e 85       	ldd	r25, Y+14	; 0x0e
    1502:	28 23       	and	r18, r24
    1504:	39 23       	and	r19, r25
    1506:	8d 85       	ldd	r24, Y+13	; 0x0d
    1508:	9e 85       	ldd	r25, Y+14	; 0x0e
    150a:	28 17       	cp	r18, r24
    150c:	39 07       	cpc	r19, r25
    150e:	c9 f4       	brne	.+50     	; 0x1542 <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
    1510:	2f 81       	ldd	r18, Y+7	; 0x07
    1512:	38 85       	ldd	r19, Y+8	; 0x08
    1514:	8b 85       	ldd	r24, Y+11	; 0x0b
    1516:	9c 85       	ldd	r25, Y+12	; 0x0c
    1518:	82 2b       	or	r24, r18
    151a:	93 2b       	or	r25, r19
    151c:	9e 83       	std	Y+6, r25	; 0x06
    151e:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1520:	eb 81       	ldd	r30, Y+3	; 0x03
    1522:	fc 81       	ldd	r31, Y+4	; 0x04
    1524:	20 81       	ld	r18, Z
    1526:	31 81       	ldd	r19, Z+1	; 0x01
    1528:	8d 85       	ldd	r24, Y+13	; 0x0d
    152a:	9e 85       	ldd	r25, Y+14	; 0x0e
    152c:	80 95       	com	r24
    152e:	90 95       	com	r25
    1530:	82 23       	and	r24, r18
    1532:	93 23       	and	r25, r19
    1534:	eb 81       	ldd	r30, Y+3	; 0x03
    1536:	fc 81       	ldd	r31, Y+4	; 0x04
    1538:	91 83       	std	Z+1, r25	; 0x01
    153a:	80 83       	st	Z, r24

            xTicksToWait = 0;
    153c:	18 8a       	std	Y+16, r1	; 0x10
    153e:	1f 86       	std	Y+15, r1	; 0x0f
    1540:	1e c0       	rjmp	.+60     	; 0x157e <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    1542:	8f 85       	ldd	r24, Y+15	; 0x0f
    1544:	98 89       	ldd	r25, Y+16	; 0x10
    1546:	00 97       	sbiw	r24, 0x00	; 0
    1548:	91 f0       	breq	.+36     	; 0x156e <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    154a:	8b 81       	ldd	r24, Y+3	; 0x03
    154c:	9c 81       	ldd	r25, Y+4	; 0x04
    154e:	bc 01       	movw	r22, r24
    1550:	6e 5f       	subi	r22, 0xFE	; 254
    1552:	7f 4f       	sbci	r23, 0xFF	; 255
    1554:	8d 85       	ldd	r24, Y+13	; 0x0d
    1556:	9e 85       	ldd	r25, Y+14	; 0x0e
    1558:	9c 01       	movw	r18, r24
    155a:	35 60       	ori	r19, 0x05	; 5
    155c:	4f 85       	ldd	r20, Y+15	; 0x0f
    155e:	58 89       	ldd	r21, Y+16	; 0x10
    1560:	cb 01       	movw	r24, r22
    1562:	b9 01       	movw	r22, r18
    1564:	0e 94 55 1f 	call	0x3eaa	; 0x3eaa <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
    1568:	1e 82       	std	Y+6, r1	; 0x06
    156a:	1d 82       	std	Y+5, r1	; 0x05
    156c:	08 c0       	rjmp	.+16     	; 0x157e <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    156e:	eb 81       	ldd	r30, Y+3	; 0x03
    1570:	fc 81       	ldd	r31, Y+4	; 0x04
    1572:	80 81       	ld	r24, Z
    1574:	91 81       	ldd	r25, Z+1	; 0x01
    1576:	9e 83       	std	Y+6, r25	; 0x06
    1578:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
    157a:	81 e0       	ldi	r24, 0x01	; 1
    157c:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    157e:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>
    1582:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
    1584:	8f 85       	ldd	r24, Y+15	; 0x0f
    1586:	98 89       	ldd	r25, Y+16	; 0x10
    1588:	00 97       	sbiw	r24, 0x00	; 0
    158a:	09 f4       	brne	.+2      	; 0x158e <xEventGroupSync+0xe8>
    158c:	3a c0       	rjmp	.+116    	; 0x1602 <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
    158e:	8a 81       	ldd	r24, Y+2	; 0x02
    1590:	88 23       	and	r24, r24
    1592:	11 f4       	brne	.+4      	; 0x1598 <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
    1594:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    1598:	0e 94 e3 23 	call	0x47c6	; 0x47c6 <uxTaskResetEventItemValue>
    159c:	9e 83       	std	Y+6, r25	; 0x06
    159e:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    15a0:	8d 81       	ldd	r24, Y+5	; 0x05
    15a2:	9e 81       	ldd	r25, Y+6	; 0x06
    15a4:	80 70       	andi	r24, 0x00	; 0
    15a6:	92 70       	andi	r25, 0x02	; 2
    15a8:	00 97       	sbiw	r24, 0x00	; 0
    15aa:	31 f5       	brne	.+76     	; 0x15f8 <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    15ac:	0f b6       	in	r0, 0x3f	; 63
    15ae:	f8 94       	cli
    15b0:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    15b2:	eb 81       	ldd	r30, Y+3	; 0x03
    15b4:	fc 81       	ldd	r31, Y+4	; 0x04
    15b6:	80 81       	ld	r24, Z
    15b8:	91 81       	ldd	r25, Z+1	; 0x01
    15ba:	9e 83       	std	Y+6, r25	; 0x06
    15bc:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    15be:	2d 81       	ldd	r18, Y+5	; 0x05
    15c0:	3e 81       	ldd	r19, Y+6	; 0x06
    15c2:	8d 85       	ldd	r24, Y+13	; 0x0d
    15c4:	9e 85       	ldd	r25, Y+14	; 0x0e
    15c6:	28 23       	and	r18, r24
    15c8:	39 23       	and	r19, r25
    15ca:	8d 85       	ldd	r24, Y+13	; 0x0d
    15cc:	9e 85       	ldd	r25, Y+14	; 0x0e
    15ce:	28 17       	cp	r18, r24
    15d0:	39 07       	cpc	r19, r25
    15d2:	71 f4       	brne	.+28     	; 0x15f0 <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    15d4:	eb 81       	ldd	r30, Y+3	; 0x03
    15d6:	fc 81       	ldd	r31, Y+4	; 0x04
    15d8:	20 81       	ld	r18, Z
    15da:	31 81       	ldd	r19, Z+1	; 0x01
    15dc:	8d 85       	ldd	r24, Y+13	; 0x0d
    15de:	9e 85       	ldd	r25, Y+14	; 0x0e
    15e0:	80 95       	com	r24
    15e2:	90 95       	com	r25
    15e4:	82 23       	and	r24, r18
    15e6:	93 23       	and	r25, r19
    15e8:	eb 81       	ldd	r30, Y+3	; 0x03
    15ea:	fc 81       	ldd	r31, Y+4	; 0x04
    15ec:	91 83       	std	Z+1, r25	; 0x01
    15ee:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    15f0:	0f 90       	pop	r0
    15f2:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
    15f4:	81 e0       	ldi	r24, 0x01	; 1
    15f6:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    15f8:	8d 81       	ldd	r24, Y+5	; 0x05
    15fa:	9e 81       	ldd	r25, Y+6	; 0x06
    15fc:	90 70       	andi	r25, 0x00	; 0
    15fe:	9e 83       	std	Y+6, r25	; 0x06
    1600:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    1602:	8d 81       	ldd	r24, Y+5	; 0x05
    1604:	9e 81       	ldd	r25, Y+6	; 0x06
}
    1606:	60 96       	adiw	r28, 0x10	; 16
    1608:	0f b6       	in	r0, 0x3f	; 63
    160a:	f8 94       	cli
    160c:	de bf       	out	0x3e, r29	; 62
    160e:	0f be       	out	0x3f, r0	; 63
    1610:	cd bf       	out	0x3d, r28	; 61
    1612:	cf 91       	pop	r28
    1614:	df 91       	pop	r29
    1616:	08 95       	ret

00001618 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    1618:	0f 93       	push	r16
    161a:	1f 93       	push	r17
    161c:	df 93       	push	r29
    161e:	cf 93       	push	r28
    1620:	cd b7       	in	r28, 0x3d	; 61
    1622:	de b7       	in	r29, 0x3e	; 62
    1624:	63 97       	sbiw	r28, 0x13	; 19
    1626:	0f b6       	in	r0, 0x3f	; 63
    1628:	f8 94       	cli
    162a:	de bf       	out	0x3e, r29	; 62
    162c:	0f be       	out	0x3f, r0	; 63
    162e:	cd bf       	out	0x3d, r28	; 61
    1630:	9d 87       	std	Y+13, r25	; 0x0d
    1632:	8c 87       	std	Y+12, r24	; 0x0c
    1634:	7f 87       	std	Y+15, r23	; 0x0f
    1636:	6e 87       	std	Y+14, r22	; 0x0e
    1638:	48 8b       	std	Y+16, r20	; 0x10
    163a:	29 8b       	std	Y+17, r18	; 0x11
    163c:	1b 8b       	std	Y+19, r17	; 0x13
    163e:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
    1640:	8c 85       	ldd	r24, Y+12	; 0x0c
    1642:	9d 85       	ldd	r25, Y+13	; 0x0d
    1644:	9b 87       	std	Y+11, r25	; 0x0b
    1646:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
    1648:	1f 82       	std	Y+7, r1	; 0x07
    164a:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
    164c:	1b 82       	std	Y+3, r1	; 0x03
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
    164e:	0e 94 56 1b 	call	0x36ac	; 0x36ac <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1652:	ea 85       	ldd	r30, Y+10	; 0x0a
    1654:	fb 85       	ldd	r31, Y+11	; 0x0b
    1656:	80 81       	ld	r24, Z
    1658:	91 81       	ldd	r25, Z+1	; 0x01
    165a:	9a 83       	std	Y+2, r25	; 0x02
    165c:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    165e:	89 81       	ldd	r24, Y+1	; 0x01
    1660:	9a 81       	ldd	r25, Y+2	; 0x02
    1662:	2e 85       	ldd	r18, Y+14	; 0x0e
    1664:	3f 85       	ldd	r19, Y+15	; 0x0f
    1666:	b9 01       	movw	r22, r18
    1668:	49 89       	ldd	r20, Y+17	; 0x11
    166a:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <prvTestWaitCondition>
    166e:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
    1670:	8d 81       	ldd	r24, Y+5	; 0x05
    1672:	88 23       	and	r24, r24
    1674:	c1 f0       	breq	.+48     	; 0x16a6 <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
    1676:	89 81       	ldd	r24, Y+1	; 0x01
    1678:	9a 81       	ldd	r25, Y+2	; 0x02
    167a:	99 87       	std	Y+9, r25	; 0x09
    167c:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
    167e:	1b 8a       	std	Y+19, r1	; 0x13
    1680:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    1682:	88 89       	ldd	r24, Y+16	; 0x10
    1684:	88 23       	and	r24, r24
    1686:	e9 f1       	breq	.+122    	; 0x1702 <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1688:	ea 85       	ldd	r30, Y+10	; 0x0a
    168a:	fb 85       	ldd	r31, Y+11	; 0x0b
    168c:	20 81       	ld	r18, Z
    168e:	31 81       	ldd	r19, Z+1	; 0x01
    1690:	8e 85       	ldd	r24, Y+14	; 0x0e
    1692:	9f 85       	ldd	r25, Y+15	; 0x0f
    1694:	80 95       	com	r24
    1696:	90 95       	com	r25
    1698:	82 23       	and	r24, r18
    169a:	93 23       	and	r25, r19
    169c:	ea 85       	ldd	r30, Y+10	; 0x0a
    169e:	fb 85       	ldd	r31, Y+11	; 0x0b
    16a0:	91 83       	std	Z+1, r25	; 0x01
    16a2:	80 83       	st	Z, r24
    16a4:	2e c0       	rjmp	.+92     	; 0x1702 <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    16a6:	8a 89       	ldd	r24, Y+18	; 0x12
    16a8:	9b 89       	ldd	r25, Y+19	; 0x13
    16aa:	00 97       	sbiw	r24, 0x00	; 0
    16ac:	39 f4       	brne	.+14     	; 0x16bc <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
    16ae:	89 81       	ldd	r24, Y+1	; 0x01
    16b0:	9a 81       	ldd	r25, Y+2	; 0x02
    16b2:	99 87       	std	Y+9, r25	; 0x09
    16b4:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
    16b6:	81 e0       	ldi	r24, 0x01	; 1
    16b8:	8b 83       	std	Y+3, r24	; 0x03
    16ba:	23 c0       	rjmp	.+70     	; 0x1702 <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    16bc:	88 89       	ldd	r24, Y+16	; 0x10
    16be:	88 23       	and	r24, r24
    16c0:	29 f0       	breq	.+10     	; 0x16cc <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
    16c2:	8e 81       	ldd	r24, Y+6	; 0x06
    16c4:	9f 81       	ldd	r25, Y+7	; 0x07
    16c6:	91 60       	ori	r25, 0x01	; 1
    16c8:	9f 83       	std	Y+7, r25	; 0x07
    16ca:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    16cc:	89 89       	ldd	r24, Y+17	; 0x11
    16ce:	88 23       	and	r24, r24
    16d0:	29 f0       	breq	.+10     	; 0x16dc <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    16d2:	8e 81       	ldd	r24, Y+6	; 0x06
    16d4:	9f 81       	ldd	r25, Y+7	; 0x07
    16d6:	94 60       	ori	r25, 0x04	; 4
    16d8:	9f 83       	std	Y+7, r25	; 0x07
    16da:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    16dc:	8a 85       	ldd	r24, Y+10	; 0x0a
    16de:	9b 85       	ldd	r25, Y+11	; 0x0b
    16e0:	bc 01       	movw	r22, r24
    16e2:	6e 5f       	subi	r22, 0xFE	; 254
    16e4:	7f 4f       	sbci	r23, 0xFF	; 255
    16e6:	2e 85       	ldd	r18, Y+14	; 0x0e
    16e8:	3f 85       	ldd	r19, Y+15	; 0x0f
    16ea:	8e 81       	ldd	r24, Y+6	; 0x06
    16ec:	9f 81       	ldd	r25, Y+7	; 0x07
    16ee:	28 2b       	or	r18, r24
    16f0:	39 2b       	or	r19, r25
    16f2:	4a 89       	ldd	r20, Y+18	; 0x12
    16f4:	5b 89       	ldd	r21, Y+19	; 0x13
    16f6:	cb 01       	movw	r24, r22
    16f8:	b9 01       	movw	r22, r18
    16fa:	0e 94 55 1f 	call	0x3eaa	; 0x3eaa <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
    16fe:	19 86       	std	Y+9, r1	; 0x09
    1700:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    1702:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>
    1706:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
    1708:	8a 89       	ldd	r24, Y+18	; 0x12
    170a:	9b 89       	ldd	r25, Y+19	; 0x13
    170c:	00 97       	sbiw	r24, 0x00	; 0
    170e:	09 f4       	brne	.+2      	; 0x1712 <xEventGroupWaitBits+0xfa>
    1710:	3c c0       	rjmp	.+120    	; 0x178a <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
    1712:	8c 81       	ldd	r24, Y+4	; 0x04
    1714:	88 23       	and	r24, r24
    1716:	11 f4       	brne	.+4      	; 0x171c <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
    1718:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    171c:	0e 94 e3 23 	call	0x47c6	; 0x47c6 <uxTaskResetEventItemValue>
    1720:	99 87       	std	Y+9, r25	; 0x09
    1722:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    1724:	88 85       	ldd	r24, Y+8	; 0x08
    1726:	99 85       	ldd	r25, Y+9	; 0x09
    1728:	80 70       	andi	r24, 0x00	; 0
    172a:	92 70       	andi	r25, 0x02	; 2
    172c:	00 97       	sbiw	r24, 0x00	; 0
    172e:	41 f5       	brne	.+80     	; 0x1780 <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
    1730:	0f b6       	in	r0, 0x3f	; 63
    1732:	f8 94       	cli
    1734:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1736:	ea 85       	ldd	r30, Y+10	; 0x0a
    1738:	fb 85       	ldd	r31, Y+11	; 0x0b
    173a:	80 81       	ld	r24, Z
    173c:	91 81       	ldd	r25, Z+1	; 0x01
    173e:	99 87       	std	Y+9, r25	; 0x09
    1740:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    1742:	88 85       	ldd	r24, Y+8	; 0x08
    1744:	99 85       	ldd	r25, Y+9	; 0x09
    1746:	2e 85       	ldd	r18, Y+14	; 0x0e
    1748:	3f 85       	ldd	r19, Y+15	; 0x0f
    174a:	b9 01       	movw	r22, r18
    174c:	49 89       	ldd	r20, Y+17	; 0x11
    174e:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <prvTestWaitCondition>
    1752:	88 23       	and	r24, r24
    1754:	89 f0       	breq	.+34     	; 0x1778 <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
    1756:	88 89       	ldd	r24, Y+16	; 0x10
    1758:	88 23       	and	r24, r24
    175a:	71 f0       	breq	.+28     	; 0x1778 <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    175c:	ea 85       	ldd	r30, Y+10	; 0x0a
    175e:	fb 85       	ldd	r31, Y+11	; 0x0b
    1760:	20 81       	ld	r18, Z
    1762:	31 81       	ldd	r19, Z+1	; 0x01
    1764:	8e 85       	ldd	r24, Y+14	; 0x0e
    1766:	9f 85       	ldd	r25, Y+15	; 0x0f
    1768:	80 95       	com	r24
    176a:	90 95       	com	r25
    176c:	82 23       	and	r24, r18
    176e:	93 23       	and	r25, r19
    1770:	ea 85       	ldd	r30, Y+10	; 0x0a
    1772:	fb 85       	ldd	r31, Y+11	; 0x0b
    1774:	91 83       	std	Z+1, r25	; 0x01
    1776:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    1778:	81 e0       	ldi	r24, 0x01	; 1
    177a:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    177c:	0f 90       	pop	r0
    177e:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1780:	88 85       	ldd	r24, Y+8	; 0x08
    1782:	99 85       	ldd	r25, Y+9	; 0x09
    1784:	90 70       	andi	r25, 0x00	; 0
    1786:	99 87       	std	Y+9, r25	; 0x09
    1788:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    178a:	88 85       	ldd	r24, Y+8	; 0x08
    178c:	99 85       	ldd	r25, Y+9	; 0x09
}
    178e:	63 96       	adiw	r28, 0x13	; 19
    1790:	0f b6       	in	r0, 0x3f	; 63
    1792:	f8 94       	cli
    1794:	de bf       	out	0x3e, r29	; 62
    1796:	0f be       	out	0x3f, r0	; 63
    1798:	cd bf       	out	0x3d, r28	; 61
    179a:	cf 91       	pop	r28
    179c:	df 91       	pop	r29
    179e:	1f 91       	pop	r17
    17a0:	0f 91       	pop	r16
    17a2:	08 95       	ret

000017a4 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    17a4:	df 93       	push	r29
    17a6:	cf 93       	push	r28
    17a8:	cd b7       	in	r28, 0x3d	; 61
    17aa:	de b7       	in	r29, 0x3e	; 62
    17ac:	28 97       	sbiw	r28, 0x08	; 8
    17ae:	0f b6       	in	r0, 0x3f	; 63
    17b0:	f8 94       	cli
    17b2:	de bf       	out	0x3e, r29	; 62
    17b4:	0f be       	out	0x3f, r0	; 63
    17b6:	cd bf       	out	0x3d, r28	; 61
    17b8:	9e 83       	std	Y+6, r25	; 0x06
    17ba:	8d 83       	std	Y+5, r24	; 0x05
    17bc:	78 87       	std	Y+8, r23	; 0x08
    17be:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    17c0:	8d 81       	ldd	r24, Y+5	; 0x05
    17c2:	9e 81       	ldd	r25, Y+6	; 0x06
    17c4:	9c 83       	std	Y+4, r25	; 0x04
    17c6:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    17c8:	0f b6       	in	r0, 0x3f	; 63
    17ca:	f8 94       	cli
    17cc:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    17ce:	eb 81       	ldd	r30, Y+3	; 0x03
    17d0:	fc 81       	ldd	r31, Y+4	; 0x04
    17d2:	80 81       	ld	r24, Z
    17d4:	91 81       	ldd	r25, Z+1	; 0x01
    17d6:	9a 83       	std	Y+2, r25	; 0x02
    17d8:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    17da:	eb 81       	ldd	r30, Y+3	; 0x03
    17dc:	fc 81       	ldd	r31, Y+4	; 0x04
    17de:	20 81       	ld	r18, Z
    17e0:	31 81       	ldd	r19, Z+1	; 0x01
    17e2:	8f 81       	ldd	r24, Y+7	; 0x07
    17e4:	98 85       	ldd	r25, Y+8	; 0x08
    17e6:	80 95       	com	r24
    17e8:	90 95       	com	r25
    17ea:	82 23       	and	r24, r18
    17ec:	93 23       	and	r25, r19
    17ee:	eb 81       	ldd	r30, Y+3	; 0x03
    17f0:	fc 81       	ldd	r31, Y+4	; 0x04
    17f2:	91 83       	std	Z+1, r25	; 0x01
    17f4:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    17f6:	0f 90       	pop	r0
    17f8:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    17fa:	89 81       	ldd	r24, Y+1	; 0x01
    17fc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    17fe:	28 96       	adiw	r28, 0x08	; 8
    1800:	0f b6       	in	r0, 0x3f	; 63
    1802:	f8 94       	cli
    1804:	de bf       	out	0x3e, r29	; 62
    1806:	0f be       	out	0x3f, r0	; 63
    1808:	cd bf       	out	0x3d, r28	; 61
    180a:	cf 91       	pop	r28
    180c:	df 91       	pop	r29
    180e:	08 95       	ret

00001810 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    1810:	df 93       	push	r29
    1812:	cf 93       	push	r28
    1814:	cd b7       	in	r28, 0x3d	; 61
    1816:	de b7       	in	r29, 0x3e	; 62
    1818:	27 97       	sbiw	r28, 0x07	; 7
    181a:	0f b6       	in	r0, 0x3f	; 63
    181c:	f8 94       	cli
    181e:	de bf       	out	0x3e, r29	; 62
    1820:	0f be       	out	0x3f, r0	; 63
    1822:	cd bf       	out	0x3d, r28	; 61
    1824:	9f 83       	std	Y+7, r25	; 0x07
    1826:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    1828:	8e 81       	ldd	r24, Y+6	; 0x06
    182a:	9f 81       	ldd	r25, Y+7	; 0x07
    182c:	9c 83       	std	Y+4, r25	; 0x04
    182e:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1830:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    1832:	eb 81       	ldd	r30, Y+3	; 0x03
    1834:	fc 81       	ldd	r31, Y+4	; 0x04
    1836:	80 81       	ld	r24, Z
    1838:	91 81       	ldd	r25, Z+1	; 0x01
    183a:	9a 83       	std	Y+2, r25	; 0x02
    183c:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    183e:	89 81       	ldd	r24, Y+1	; 0x01
    1840:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    1842:	27 96       	adiw	r28, 0x07	; 7
    1844:	0f b6       	in	r0, 0x3f	; 63
    1846:	f8 94       	cli
    1848:	de bf       	out	0x3e, r29	; 62
    184a:	0f be       	out	0x3f, r0	; 63
    184c:	cd bf       	out	0x3d, r28	; 61
    184e:	cf 91       	pop	r28
    1850:	df 91       	pop	r29
    1852:	08 95       	ret

00001854 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    1854:	df 93       	push	r29
    1856:	cf 93       	push	r28
    1858:	cd b7       	in	r28, 0x3d	; 61
    185a:	de b7       	in	r29, 0x3e	; 62
    185c:	65 97       	sbiw	r28, 0x15	; 21
    185e:	0f b6       	in	r0, 0x3f	; 63
    1860:	f8 94       	cli
    1862:	de bf       	out	0x3e, r29	; 62
    1864:	0f be       	out	0x3f, r0	; 63
    1866:	cd bf       	out	0x3d, r28	; 61
    1868:	9b 8b       	std	Y+19, r25	; 0x13
    186a:	8a 8b       	std	Y+18, r24	; 0x12
    186c:	7d 8b       	std	Y+21, r23	; 0x15
    186e:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    1870:	19 86       	std	Y+9, r1	; 0x09
    1872:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    1874:	8a 89       	ldd	r24, Y+18	; 0x12
    1876:	9b 89       	ldd	r25, Y+19	; 0x13
    1878:	9b 83       	std	Y+3, r25	; 0x03
    187a:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    187c:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    187e:	8a 81       	ldd	r24, Y+2	; 0x02
    1880:	9b 81       	ldd	r25, Y+3	; 0x03
    1882:	02 96       	adiw	r24, 0x02	; 2
    1884:	9b 87       	std	Y+11, r25	; 0x0b
    1886:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1888:	8a 85       	ldd	r24, Y+10	; 0x0a
    188a:	9b 85       	ldd	r25, Y+11	; 0x0b
    188c:	03 96       	adiw	r24, 0x03	; 3
    188e:	9d 87       	std	Y+13, r25	; 0x0d
    1890:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    1892:	0e 94 56 1b 	call	0x36ac	; 0x36ac <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    1896:	ea 85       	ldd	r30, Y+10	; 0x0a
    1898:	fb 85       	ldd	r31, Y+11	; 0x0b
    189a:	85 81       	ldd	r24, Z+5	; 0x05
    189c:	96 81       	ldd	r25, Z+6	; 0x06
    189e:	99 8b       	std	Y+17, r25	; 0x11
    18a0:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    18a2:	ea 81       	ldd	r30, Y+2	; 0x02
    18a4:	fb 81       	ldd	r31, Y+3	; 0x03
    18a6:	20 81       	ld	r18, Z
    18a8:	31 81       	ldd	r19, Z+1	; 0x01
    18aa:	8c 89       	ldd	r24, Y+20	; 0x14
    18ac:	9d 89       	ldd	r25, Y+21	; 0x15
    18ae:	82 2b       	or	r24, r18
    18b0:	93 2b       	or	r25, r19
    18b2:	ea 81       	ldd	r30, Y+2	; 0x02
    18b4:	fb 81       	ldd	r31, Y+3	; 0x03
    18b6:	91 83       	std	Z+1, r25	; 0x01
    18b8:	80 83       	st	Z, r24
    18ba:	59 c0       	rjmp	.+178    	; 0x196e <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    18bc:	e8 89       	ldd	r30, Y+16	; 0x10
    18be:	f9 89       	ldd	r31, Y+17	; 0x11
    18c0:	82 81       	ldd	r24, Z+2	; 0x02
    18c2:	93 81       	ldd	r25, Z+3	; 0x03
    18c4:	9f 87       	std	Y+15, r25	; 0x0f
    18c6:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    18c8:	e8 89       	ldd	r30, Y+16	; 0x10
    18ca:	f9 89       	ldd	r31, Y+17	; 0x11
    18cc:	80 81       	ld	r24, Z
    18ce:	91 81       	ldd	r25, Z+1	; 0x01
    18d0:	9f 83       	std	Y+7, r25	; 0x07
    18d2:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    18d4:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    18d6:	8e 81       	ldd	r24, Y+6	; 0x06
    18d8:	9f 81       	ldd	r25, Y+7	; 0x07
    18da:	80 70       	andi	r24, 0x00	; 0
    18dc:	9d 83       	std	Y+5, r25	; 0x05
    18de:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    18e0:	8e 81       	ldd	r24, Y+6	; 0x06
    18e2:	9f 81       	ldd	r25, Y+7	; 0x07
    18e4:	90 70       	andi	r25, 0x00	; 0
    18e6:	9f 83       	std	Y+7, r25	; 0x07
    18e8:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    18ea:	8c 81       	ldd	r24, Y+4	; 0x04
    18ec:	9d 81       	ldd	r25, Y+5	; 0x05
    18ee:	80 70       	andi	r24, 0x00	; 0
    18f0:	94 70       	andi	r25, 0x04	; 4
    18f2:	00 97       	sbiw	r24, 0x00	; 0
    18f4:	69 f4       	brne	.+26     	; 0x1910 <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    18f6:	ea 81       	ldd	r30, Y+2	; 0x02
    18f8:	fb 81       	ldd	r31, Y+3	; 0x03
    18fa:	20 81       	ld	r18, Z
    18fc:	31 81       	ldd	r19, Z+1	; 0x01
    18fe:	8e 81       	ldd	r24, Y+6	; 0x06
    1900:	9f 81       	ldd	r25, Y+7	; 0x07
    1902:	82 23       	and	r24, r18
    1904:	93 23       	and	r25, r19
    1906:	00 97       	sbiw	r24, 0x00	; 0
    1908:	91 f0       	breq	.+36     	; 0x192e <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    190a:	81 e0       	ldi	r24, 0x01	; 1
    190c:	89 83       	std	Y+1, r24	; 0x01
    190e:	0f c0       	rjmp	.+30     	; 0x192e <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    1910:	ea 81       	ldd	r30, Y+2	; 0x02
    1912:	fb 81       	ldd	r31, Y+3	; 0x03
    1914:	20 81       	ld	r18, Z
    1916:	31 81       	ldd	r19, Z+1	; 0x01
    1918:	8e 81       	ldd	r24, Y+6	; 0x06
    191a:	9f 81       	ldd	r25, Y+7	; 0x07
    191c:	28 23       	and	r18, r24
    191e:	39 23       	and	r19, r25
    1920:	8e 81       	ldd	r24, Y+6	; 0x06
    1922:	9f 81       	ldd	r25, Y+7	; 0x07
    1924:	28 17       	cp	r18, r24
    1926:	39 07       	cpc	r19, r25
    1928:	11 f4       	brne	.+4      	; 0x192e <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    192a:	81 e0       	ldi	r24, 0x01	; 1
    192c:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    192e:	89 81       	ldd	r24, Y+1	; 0x01
    1930:	88 23       	and	r24, r24
    1932:	c9 f0       	breq	.+50     	; 0x1966 <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    1934:	8c 81       	ldd	r24, Y+4	; 0x04
    1936:	9d 81       	ldd	r25, Y+5	; 0x05
    1938:	80 70       	andi	r24, 0x00	; 0
    193a:	91 70       	andi	r25, 0x01	; 1
    193c:	00 97       	sbiw	r24, 0x00	; 0
    193e:	41 f0       	breq	.+16     	; 0x1950 <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    1940:	88 85       	ldd	r24, Y+8	; 0x08
    1942:	99 85       	ldd	r25, Y+9	; 0x09
    1944:	2e 81       	ldd	r18, Y+6	; 0x06
    1946:	3f 81       	ldd	r19, Y+7	; 0x07
    1948:	82 2b       	or	r24, r18
    194a:	93 2b       	or	r25, r19
    194c:	99 87       	std	Y+9, r25	; 0x09
    194e:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    1950:	ea 81       	ldd	r30, Y+2	; 0x02
    1952:	fb 81       	ldd	r31, Y+3	; 0x03
    1954:	80 81       	ld	r24, Z
    1956:	91 81       	ldd	r25, Z+1	; 0x01
    1958:	9c 01       	movw	r18, r24
    195a:	32 60       	ori	r19, 0x02	; 2
    195c:	88 89       	ldd	r24, Y+16	; 0x10
    195e:	99 89       	ldd	r25, Y+17	; 0x11
    1960:	b9 01       	movw	r22, r18
    1962:	0e 94 60 21 	call	0x42c0	; 0x42c0 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    1966:	8e 85       	ldd	r24, Y+14	; 0x0e
    1968:	9f 85       	ldd	r25, Y+15	; 0x0f
    196a:	99 8b       	std	Y+17, r25	; 0x11
    196c:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    196e:	28 89       	ldd	r18, Y+16	; 0x10
    1970:	39 89       	ldd	r19, Y+17	; 0x11
    1972:	8c 85       	ldd	r24, Y+12	; 0x0c
    1974:	9d 85       	ldd	r25, Y+13	; 0x0d
    1976:	28 17       	cp	r18, r24
    1978:	39 07       	cpc	r19, r25
    197a:	09 f0       	breq	.+2      	; 0x197e <xEventGroupSetBits+0x12a>
    197c:	9f cf       	rjmp	.-194    	; 0x18bc <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    197e:	ea 81       	ldd	r30, Y+2	; 0x02
    1980:	fb 81       	ldd	r31, Y+3	; 0x03
    1982:	20 81       	ld	r18, Z
    1984:	31 81       	ldd	r19, Z+1	; 0x01
    1986:	88 85       	ldd	r24, Y+8	; 0x08
    1988:	99 85       	ldd	r25, Y+9	; 0x09
    198a:	80 95       	com	r24
    198c:	90 95       	com	r25
    198e:	82 23       	and	r24, r18
    1990:	93 23       	and	r25, r19
    1992:	ea 81       	ldd	r30, Y+2	; 0x02
    1994:	fb 81       	ldd	r31, Y+3	; 0x03
    1996:	91 83       	std	Z+1, r25	; 0x01
    1998:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    199a:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    199e:	ea 81       	ldd	r30, Y+2	; 0x02
    19a0:	fb 81       	ldd	r31, Y+3	; 0x03
    19a2:	80 81       	ld	r24, Z
    19a4:	91 81       	ldd	r25, Z+1	; 0x01
}
    19a6:	65 96       	adiw	r28, 0x15	; 21
    19a8:	0f b6       	in	r0, 0x3f	; 63
    19aa:	f8 94       	cli
    19ac:	de bf       	out	0x3e, r29	; 62
    19ae:	0f be       	out	0x3f, r0	; 63
    19b0:	cd bf       	out	0x3d, r28	; 61
    19b2:	cf 91       	pop	r28
    19b4:	df 91       	pop	r29
    19b6:	08 95       	ret

000019b8 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    19b8:	df 93       	push	r29
    19ba:	cf 93       	push	r28
    19bc:	00 d0       	rcall	.+0      	; 0x19be <vEventGroupDelete+0x6>
    19be:	00 d0       	rcall	.+0      	; 0x19c0 <vEventGroupDelete+0x8>
    19c0:	00 d0       	rcall	.+0      	; 0x19c2 <vEventGroupDelete+0xa>
    19c2:	cd b7       	in	r28, 0x3d	; 61
    19c4:	de b7       	in	r29, 0x3e	; 62
    19c6:	9e 83       	std	Y+6, r25	; 0x06
    19c8:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    19ca:	8d 81       	ldd	r24, Y+5	; 0x05
    19cc:	9e 81       	ldd	r25, Y+6	; 0x06
    19ce:	9c 83       	std	Y+4, r25	; 0x04
    19d0:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    19d2:	8b 81       	ldd	r24, Y+3	; 0x03
    19d4:	9c 81       	ldd	r25, Y+4	; 0x04
    19d6:	02 96       	adiw	r24, 0x02	; 2
    19d8:	9a 83       	std	Y+2, r25	; 0x02
    19da:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    19dc:	0e 94 56 1b 	call	0x36ac	; 0x36ac <vTaskSuspendAll>
    19e0:	08 c0       	rjmp	.+16     	; 0x19f2 <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    19e2:	e9 81       	ldd	r30, Y+1	; 0x01
    19e4:	fa 81       	ldd	r31, Y+2	; 0x02
    19e6:	85 81       	ldd	r24, Z+5	; 0x05
    19e8:	96 81       	ldd	r25, Z+6	; 0x06
    19ea:	60 e0       	ldi	r22, 0x00	; 0
    19ec:	72 e0       	ldi	r23, 0x02	; 2
    19ee:	0e 94 60 21 	call	0x42c0	; 0x42c0 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    19f2:	e9 81       	ldd	r30, Y+1	; 0x01
    19f4:	fa 81       	ldd	r31, Y+2	; 0x02
    19f6:	80 81       	ld	r24, Z
    19f8:	88 23       	and	r24, r24
    19fa:	99 f7       	brne	.-26     	; 0x19e2 <vEventGroupDelete+0x2a>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
    19fc:	8b 81       	ldd	r24, Y+3	; 0x03
    19fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1a00:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
    1a04:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>
}
    1a08:	26 96       	adiw	r28, 0x06	; 6
    1a0a:	0f b6       	in	r0, 0x3f	; 63
    1a0c:	f8 94       	cli
    1a0e:	de bf       	out	0x3e, r29	; 62
    1a10:	0f be       	out	0x3f, r0	; 63
    1a12:	cd bf       	out	0x3d, r28	; 61
    1a14:	cf 91       	pop	r28
    1a16:	df 91       	pop	r29
    1a18:	08 95       	ret

00001a1a <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    1a1a:	df 93       	push	r29
    1a1c:	cf 93       	push	r28
    1a1e:	00 d0       	rcall	.+0      	; 0x1a20 <vEventGroupSetBitsCallback+0x6>
    1a20:	00 d0       	rcall	.+0      	; 0x1a22 <vEventGroupSetBitsCallback+0x8>
    1a22:	00 d0       	rcall	.+0      	; 0x1a24 <vEventGroupSetBitsCallback+0xa>
    1a24:	cd b7       	in	r28, 0x3d	; 61
    1a26:	de b7       	in	r29, 0x3e	; 62
    1a28:	9a 83       	std	Y+2, r25	; 0x02
    1a2a:	89 83       	std	Y+1, r24	; 0x01
    1a2c:	4b 83       	std	Y+3, r20	; 0x03
    1a2e:	5c 83       	std	Y+4, r21	; 0x04
    1a30:	6d 83       	std	Y+5, r22	; 0x05
    1a32:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1a34:	89 81       	ldd	r24, Y+1	; 0x01
    1a36:	9a 81       	ldd	r25, Y+2	; 0x02
    1a38:	2b 81       	ldd	r18, Y+3	; 0x03
    1a3a:	3c 81       	ldd	r19, Y+4	; 0x04
    1a3c:	b9 01       	movw	r22, r18
    1a3e:	0e 94 2a 0c 	call	0x1854	; 0x1854 <xEventGroupSetBits>
}
    1a42:	26 96       	adiw	r28, 0x06	; 6
    1a44:	0f b6       	in	r0, 0x3f	; 63
    1a46:	f8 94       	cli
    1a48:	de bf       	out	0x3e, r29	; 62
    1a4a:	0f be       	out	0x3f, r0	; 63
    1a4c:	cd bf       	out	0x3d, r28	; 61
    1a4e:	cf 91       	pop	r28
    1a50:	df 91       	pop	r29
    1a52:	08 95       	ret

00001a54 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    1a54:	df 93       	push	r29
    1a56:	cf 93       	push	r28
    1a58:	00 d0       	rcall	.+0      	; 0x1a5a <vEventGroupClearBitsCallback+0x6>
    1a5a:	00 d0       	rcall	.+0      	; 0x1a5c <vEventGroupClearBitsCallback+0x8>
    1a5c:	00 d0       	rcall	.+0      	; 0x1a5e <vEventGroupClearBitsCallback+0xa>
    1a5e:	cd b7       	in	r28, 0x3d	; 61
    1a60:	de b7       	in	r29, 0x3e	; 62
    1a62:	9a 83       	std	Y+2, r25	; 0x02
    1a64:	89 83       	std	Y+1, r24	; 0x01
    1a66:	4b 83       	std	Y+3, r20	; 0x03
    1a68:	5c 83       	std	Y+4, r21	; 0x04
    1a6a:	6d 83       	std	Y+5, r22	; 0x05
    1a6c:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1a6e:	89 81       	ldd	r24, Y+1	; 0x01
    1a70:	9a 81       	ldd	r25, Y+2	; 0x02
    1a72:	2b 81       	ldd	r18, Y+3	; 0x03
    1a74:	3c 81       	ldd	r19, Y+4	; 0x04
    1a76:	b9 01       	movw	r22, r18
    1a78:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <xEventGroupClearBits>
}
    1a7c:	26 96       	adiw	r28, 0x06	; 6
    1a7e:	0f b6       	in	r0, 0x3f	; 63
    1a80:	f8 94       	cli
    1a82:	de bf       	out	0x3e, r29	; 62
    1a84:	0f be       	out	0x3f, r0	; 63
    1a86:	cd bf       	out	0x3d, r28	; 61
    1a88:	cf 91       	pop	r28
    1a8a:	df 91       	pop	r29
    1a8c:	08 95       	ret

00001a8e <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    1a8e:	df 93       	push	r29
    1a90:	cf 93       	push	r28
    1a92:	00 d0       	rcall	.+0      	; 0x1a94 <prvTestWaitCondition+0x6>
    1a94:	00 d0       	rcall	.+0      	; 0x1a96 <prvTestWaitCondition+0x8>
    1a96:	00 d0       	rcall	.+0      	; 0x1a98 <prvTestWaitCondition+0xa>
    1a98:	cd b7       	in	r28, 0x3d	; 61
    1a9a:	de b7       	in	r29, 0x3e	; 62
    1a9c:	9b 83       	std	Y+3, r25	; 0x03
    1a9e:	8a 83       	std	Y+2, r24	; 0x02
    1aa0:	7d 83       	std	Y+5, r23	; 0x05
    1aa2:	6c 83       	std	Y+4, r22	; 0x04
    1aa4:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    1aa6:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    1aa8:	8e 81       	ldd	r24, Y+6	; 0x06
    1aaa:	88 23       	and	r24, r24
    1aac:	59 f4       	brne	.+22     	; 0x1ac4 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1aae:	8a 81       	ldd	r24, Y+2	; 0x02
    1ab0:	9b 81       	ldd	r25, Y+3	; 0x03
    1ab2:	2c 81       	ldd	r18, Y+4	; 0x04
    1ab4:	3d 81       	ldd	r19, Y+5	; 0x05
    1ab6:	82 23       	and	r24, r18
    1ab8:	93 23       	and	r25, r19
    1aba:	00 97       	sbiw	r24, 0x00	; 0
    1abc:	81 f0       	breq	.+32     	; 0x1ade <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    1abe:	81 e0       	ldi	r24, 0x01	; 1
    1ac0:	89 83       	std	Y+1, r24	; 0x01
    1ac2:	0d c0       	rjmp	.+26     	; 0x1ade <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1ac4:	2a 81       	ldd	r18, Y+2	; 0x02
    1ac6:	3b 81       	ldd	r19, Y+3	; 0x03
    1ac8:	8c 81       	ldd	r24, Y+4	; 0x04
    1aca:	9d 81       	ldd	r25, Y+5	; 0x05
    1acc:	28 23       	and	r18, r24
    1ace:	39 23       	and	r19, r25
    1ad0:	8c 81       	ldd	r24, Y+4	; 0x04
    1ad2:	9d 81       	ldd	r25, Y+5	; 0x05
    1ad4:	28 17       	cp	r18, r24
    1ad6:	39 07       	cpc	r19, r25
    1ad8:	11 f4       	brne	.+4      	; 0x1ade <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    1ada:	81 e0       	ldi	r24, 0x01	; 1
    1adc:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    1ade:	89 81       	ldd	r24, Y+1	; 0x01
}
    1ae0:	26 96       	adiw	r28, 0x06	; 6
    1ae2:	0f b6       	in	r0, 0x3f	; 63
    1ae4:	f8 94       	cli
    1ae6:	de bf       	out	0x3e, r29	; 62
    1ae8:	0f be       	out	0x3f, r0	; 63
    1aea:	cd bf       	out	0x3d, r28	; 61
    1aec:	cf 91       	pop	r28
    1aee:	df 91       	pop	r29
    1af0:	08 95       	ret

00001af2 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1af2:	df 93       	push	r29
    1af4:	cf 93       	push	r28
    1af6:	00 d0       	rcall	.+0      	; 0x1af8 <vListInitialise+0x6>
    1af8:	cd b7       	in	r28, 0x3d	; 61
    1afa:	de b7       	in	r29, 0x3e	; 62
    1afc:	9a 83       	std	Y+2, r25	; 0x02
    1afe:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b00:	89 81       	ldd	r24, Y+1	; 0x01
    1b02:	9a 81       	ldd	r25, Y+2	; 0x02
    1b04:	03 96       	adiw	r24, 0x03	; 3
    1b06:	e9 81       	ldd	r30, Y+1	; 0x01
    1b08:	fa 81       	ldd	r31, Y+2	; 0x02
    1b0a:	92 83       	std	Z+2, r25	; 0x02
    1b0c:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    1b0e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b10:	fa 81       	ldd	r31, Y+2	; 0x02
    1b12:	8f ef       	ldi	r24, 0xFF	; 255
    1b14:	9f ef       	ldi	r25, 0xFF	; 255
    1b16:	94 83       	std	Z+4, r25	; 0x04
    1b18:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b1a:	89 81       	ldd	r24, Y+1	; 0x01
    1b1c:	9a 81       	ldd	r25, Y+2	; 0x02
    1b1e:	03 96       	adiw	r24, 0x03	; 3
    1b20:	e9 81       	ldd	r30, Y+1	; 0x01
    1b22:	fa 81       	ldd	r31, Y+2	; 0x02
    1b24:	96 83       	std	Z+6, r25	; 0x06
    1b26:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b28:	89 81       	ldd	r24, Y+1	; 0x01
    1b2a:	9a 81       	ldd	r25, Y+2	; 0x02
    1b2c:	03 96       	adiw	r24, 0x03	; 3
    1b2e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b30:	fa 81       	ldd	r31, Y+2	; 0x02
    1b32:	90 87       	std	Z+8, r25	; 0x08
    1b34:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1b36:	e9 81       	ldd	r30, Y+1	; 0x01
    1b38:	fa 81       	ldd	r31, Y+2	; 0x02
    1b3a:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    1b3c:	0f 90       	pop	r0
    1b3e:	0f 90       	pop	r0
    1b40:	cf 91       	pop	r28
    1b42:	df 91       	pop	r29
    1b44:	08 95       	ret

00001b46 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1b46:	df 93       	push	r29
    1b48:	cf 93       	push	r28
    1b4a:	00 d0       	rcall	.+0      	; 0x1b4c <vListInitialiseItem+0x6>
    1b4c:	cd b7       	in	r28, 0x3d	; 61
    1b4e:	de b7       	in	r29, 0x3e	; 62
    1b50:	9a 83       	std	Y+2, r25	; 0x02
    1b52:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    1b54:	e9 81       	ldd	r30, Y+1	; 0x01
    1b56:	fa 81       	ldd	r31, Y+2	; 0x02
    1b58:	11 86       	std	Z+9, r1	; 0x09
    1b5a:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    1b5c:	0f 90       	pop	r0
    1b5e:	0f 90       	pop	r0
    1b60:	cf 91       	pop	r28
    1b62:	df 91       	pop	r29
    1b64:	08 95       	ret

00001b66 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    1b66:	df 93       	push	r29
    1b68:	cf 93       	push	r28
    1b6a:	00 d0       	rcall	.+0      	; 0x1b6c <vListInsertEnd+0x6>
    1b6c:	00 d0       	rcall	.+0      	; 0x1b6e <vListInsertEnd+0x8>
    1b6e:	00 d0       	rcall	.+0      	; 0x1b70 <vListInsertEnd+0xa>
    1b70:	cd b7       	in	r28, 0x3d	; 61
    1b72:	de b7       	in	r29, 0x3e	; 62
    1b74:	9c 83       	std	Y+4, r25	; 0x04
    1b76:	8b 83       	std	Y+3, r24	; 0x03
    1b78:	7e 83       	std	Y+6, r23	; 0x06
    1b7a:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    1b7c:	eb 81       	ldd	r30, Y+3	; 0x03
    1b7e:	fc 81       	ldd	r31, Y+4	; 0x04
    1b80:	81 81       	ldd	r24, Z+1	; 0x01
    1b82:	92 81       	ldd	r25, Z+2	; 0x02
    1b84:	9a 83       	std	Y+2, r25	; 0x02
    1b86:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    1b88:	ed 81       	ldd	r30, Y+5	; 0x05
    1b8a:	fe 81       	ldd	r31, Y+6	; 0x06
    1b8c:	89 81       	ldd	r24, Y+1	; 0x01
    1b8e:	9a 81       	ldd	r25, Y+2	; 0x02
    1b90:	93 83       	std	Z+3, r25	; 0x03
    1b92:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1b94:	e9 81       	ldd	r30, Y+1	; 0x01
    1b96:	fa 81       	ldd	r31, Y+2	; 0x02
    1b98:	84 81       	ldd	r24, Z+4	; 0x04
    1b9a:	95 81       	ldd	r25, Z+5	; 0x05
    1b9c:	ed 81       	ldd	r30, Y+5	; 0x05
    1b9e:	fe 81       	ldd	r31, Y+6	; 0x06
    1ba0:	95 83       	std	Z+5, r25	; 0x05
    1ba2:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1ba4:	e9 81       	ldd	r30, Y+1	; 0x01
    1ba6:	fa 81       	ldd	r31, Y+2	; 0x02
    1ba8:	04 80       	ldd	r0, Z+4	; 0x04
    1baa:	f5 81       	ldd	r31, Z+5	; 0x05
    1bac:	e0 2d       	mov	r30, r0
    1bae:	8d 81       	ldd	r24, Y+5	; 0x05
    1bb0:	9e 81       	ldd	r25, Y+6	; 0x06
    1bb2:	93 83       	std	Z+3, r25	; 0x03
    1bb4:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    1bb6:	e9 81       	ldd	r30, Y+1	; 0x01
    1bb8:	fa 81       	ldd	r31, Y+2	; 0x02
    1bba:	8d 81       	ldd	r24, Y+5	; 0x05
    1bbc:	9e 81       	ldd	r25, Y+6	; 0x06
    1bbe:	95 83       	std	Z+5, r25	; 0x05
    1bc0:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    1bc2:	ed 81       	ldd	r30, Y+5	; 0x05
    1bc4:	fe 81       	ldd	r31, Y+6	; 0x06
    1bc6:	8b 81       	ldd	r24, Y+3	; 0x03
    1bc8:	9c 81       	ldd	r25, Y+4	; 0x04
    1bca:	91 87       	std	Z+9, r25	; 0x09
    1bcc:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1bce:	eb 81       	ldd	r30, Y+3	; 0x03
    1bd0:	fc 81       	ldd	r31, Y+4	; 0x04
    1bd2:	80 81       	ld	r24, Z
    1bd4:	8f 5f       	subi	r24, 0xFF	; 255
    1bd6:	eb 81       	ldd	r30, Y+3	; 0x03
    1bd8:	fc 81       	ldd	r31, Y+4	; 0x04
    1bda:	80 83       	st	Z, r24
}
    1bdc:	26 96       	adiw	r28, 0x06	; 6
    1bde:	0f b6       	in	r0, 0x3f	; 63
    1be0:	f8 94       	cli
    1be2:	de bf       	out	0x3e, r29	; 62
    1be4:	0f be       	out	0x3f, r0	; 63
    1be6:	cd bf       	out	0x3d, r28	; 61
    1be8:	cf 91       	pop	r28
    1bea:	df 91       	pop	r29
    1bec:	08 95       	ret

00001bee <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    1bee:	df 93       	push	r29
    1bf0:	cf 93       	push	r28
    1bf2:	cd b7       	in	r28, 0x3d	; 61
    1bf4:	de b7       	in	r29, 0x3e	; 62
    1bf6:	28 97       	sbiw	r28, 0x08	; 8
    1bf8:	0f b6       	in	r0, 0x3f	; 63
    1bfa:	f8 94       	cli
    1bfc:	de bf       	out	0x3e, r29	; 62
    1bfe:	0f be       	out	0x3f, r0	; 63
    1c00:	cd bf       	out	0x3d, r28	; 61
    1c02:	9e 83       	std	Y+6, r25	; 0x06
    1c04:	8d 83       	std	Y+5, r24	; 0x05
    1c06:	78 87       	std	Y+8, r23	; 0x08
    1c08:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1c0a:	ef 81       	ldd	r30, Y+7	; 0x07
    1c0c:	f8 85       	ldd	r31, Y+8	; 0x08
    1c0e:	80 81       	ld	r24, Z
    1c10:	91 81       	ldd	r25, Z+1	; 0x01
    1c12:	9a 83       	std	Y+2, r25	; 0x02
    1c14:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1c16:	89 81       	ldd	r24, Y+1	; 0x01
    1c18:	9a 81       	ldd	r25, Y+2	; 0x02
    1c1a:	2f ef       	ldi	r18, 0xFF	; 255
    1c1c:	8f 3f       	cpi	r24, 0xFF	; 255
    1c1e:	92 07       	cpc	r25, r18
    1c20:	39 f4       	brne	.+14     	; 0x1c30 <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    1c22:	ed 81       	ldd	r30, Y+5	; 0x05
    1c24:	fe 81       	ldd	r31, Y+6	; 0x06
    1c26:	87 81       	ldd	r24, Z+7	; 0x07
    1c28:	90 85       	ldd	r25, Z+8	; 0x08
    1c2a:	9c 83       	std	Y+4, r25	; 0x04
    1c2c:	8b 83       	std	Y+3, r24	; 0x03
    1c2e:	18 c0       	rjmp	.+48     	; 0x1c60 <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1c30:	8d 81       	ldd	r24, Y+5	; 0x05
    1c32:	9e 81       	ldd	r25, Y+6	; 0x06
    1c34:	03 96       	adiw	r24, 0x03	; 3
    1c36:	9c 83       	std	Y+4, r25	; 0x04
    1c38:	8b 83       	std	Y+3, r24	; 0x03
    1c3a:	06 c0       	rjmp	.+12     	; 0x1c48 <vListInsert+0x5a>
    1c3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1c40:	82 81       	ldd	r24, Z+2	; 0x02
    1c42:	93 81       	ldd	r25, Z+3	; 0x03
    1c44:	9c 83       	std	Y+4, r25	; 0x04
    1c46:	8b 83       	std	Y+3, r24	; 0x03
    1c48:	eb 81       	ldd	r30, Y+3	; 0x03
    1c4a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c4c:	02 80       	ldd	r0, Z+2	; 0x02
    1c4e:	f3 81       	ldd	r31, Z+3	; 0x03
    1c50:	e0 2d       	mov	r30, r0
    1c52:	20 81       	ld	r18, Z
    1c54:	31 81       	ldd	r19, Z+1	; 0x01
    1c56:	89 81       	ldd	r24, Y+1	; 0x01
    1c58:	9a 81       	ldd	r25, Y+2	; 0x02
    1c5a:	82 17       	cp	r24, r18
    1c5c:	93 07       	cpc	r25, r19
    1c5e:	70 f7       	brcc	.-36     	; 0x1c3c <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1c60:	eb 81       	ldd	r30, Y+3	; 0x03
    1c62:	fc 81       	ldd	r31, Y+4	; 0x04
    1c64:	82 81       	ldd	r24, Z+2	; 0x02
    1c66:	93 81       	ldd	r25, Z+3	; 0x03
    1c68:	ef 81       	ldd	r30, Y+7	; 0x07
    1c6a:	f8 85       	ldd	r31, Y+8	; 0x08
    1c6c:	93 83       	std	Z+3, r25	; 0x03
    1c6e:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1c70:	ef 81       	ldd	r30, Y+7	; 0x07
    1c72:	f8 85       	ldd	r31, Y+8	; 0x08
    1c74:	02 80       	ldd	r0, Z+2	; 0x02
    1c76:	f3 81       	ldd	r31, Z+3	; 0x03
    1c78:	e0 2d       	mov	r30, r0
    1c7a:	8f 81       	ldd	r24, Y+7	; 0x07
    1c7c:	98 85       	ldd	r25, Y+8	; 0x08
    1c7e:	95 83       	std	Z+5, r25	; 0x05
    1c80:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1c82:	ef 81       	ldd	r30, Y+7	; 0x07
    1c84:	f8 85       	ldd	r31, Y+8	; 0x08
    1c86:	8b 81       	ldd	r24, Y+3	; 0x03
    1c88:	9c 81       	ldd	r25, Y+4	; 0x04
    1c8a:	95 83       	std	Z+5, r25	; 0x05
    1c8c:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    1c8e:	eb 81       	ldd	r30, Y+3	; 0x03
    1c90:	fc 81       	ldd	r31, Y+4	; 0x04
    1c92:	8f 81       	ldd	r24, Y+7	; 0x07
    1c94:	98 85       	ldd	r25, Y+8	; 0x08
    1c96:	93 83       	std	Z+3, r25	; 0x03
    1c98:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    1c9a:	ef 81       	ldd	r30, Y+7	; 0x07
    1c9c:	f8 85       	ldd	r31, Y+8	; 0x08
    1c9e:	8d 81       	ldd	r24, Y+5	; 0x05
    1ca0:	9e 81       	ldd	r25, Y+6	; 0x06
    1ca2:	91 87       	std	Z+9, r25	; 0x09
    1ca4:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1ca6:	ed 81       	ldd	r30, Y+5	; 0x05
    1ca8:	fe 81       	ldd	r31, Y+6	; 0x06
    1caa:	80 81       	ld	r24, Z
    1cac:	8f 5f       	subi	r24, 0xFF	; 255
    1cae:	ed 81       	ldd	r30, Y+5	; 0x05
    1cb0:	fe 81       	ldd	r31, Y+6	; 0x06
    1cb2:	80 83       	st	Z, r24
}
    1cb4:	28 96       	adiw	r28, 0x08	; 8
    1cb6:	0f b6       	in	r0, 0x3f	; 63
    1cb8:	f8 94       	cli
    1cba:	de bf       	out	0x3e, r29	; 62
    1cbc:	0f be       	out	0x3f, r0	; 63
    1cbe:	cd bf       	out	0x3d, r28	; 61
    1cc0:	cf 91       	pop	r28
    1cc2:	df 91       	pop	r29
    1cc4:	08 95       	ret

00001cc6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1cc6:	df 93       	push	r29
    1cc8:	cf 93       	push	r28
    1cca:	00 d0       	rcall	.+0      	; 0x1ccc <uxListRemove+0x6>
    1ccc:	00 d0       	rcall	.+0      	; 0x1cce <uxListRemove+0x8>
    1cce:	cd b7       	in	r28, 0x3d	; 61
    1cd0:	de b7       	in	r29, 0x3e	; 62
    1cd2:	9c 83       	std	Y+4, r25	; 0x04
    1cd4:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    1cd6:	eb 81       	ldd	r30, Y+3	; 0x03
    1cd8:	fc 81       	ldd	r31, Y+4	; 0x04
    1cda:	80 85       	ldd	r24, Z+8	; 0x08
    1cdc:	91 85       	ldd	r25, Z+9	; 0x09
    1cde:	9a 83       	std	Y+2, r25	; 0x02
    1ce0:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1ce2:	eb 81       	ldd	r30, Y+3	; 0x03
    1ce4:	fc 81       	ldd	r31, Y+4	; 0x04
    1ce6:	a2 81       	ldd	r26, Z+2	; 0x02
    1ce8:	b3 81       	ldd	r27, Z+3	; 0x03
    1cea:	eb 81       	ldd	r30, Y+3	; 0x03
    1cec:	fc 81       	ldd	r31, Y+4	; 0x04
    1cee:	84 81       	ldd	r24, Z+4	; 0x04
    1cf0:	95 81       	ldd	r25, Z+5	; 0x05
    1cf2:	15 96       	adiw	r26, 0x05	; 5
    1cf4:	9c 93       	st	X, r25
    1cf6:	8e 93       	st	-X, r24
    1cf8:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1cfa:	eb 81       	ldd	r30, Y+3	; 0x03
    1cfc:	fc 81       	ldd	r31, Y+4	; 0x04
    1cfe:	a4 81       	ldd	r26, Z+4	; 0x04
    1d00:	b5 81       	ldd	r27, Z+5	; 0x05
    1d02:	eb 81       	ldd	r30, Y+3	; 0x03
    1d04:	fc 81       	ldd	r31, Y+4	; 0x04
    1d06:	82 81       	ldd	r24, Z+2	; 0x02
    1d08:	93 81       	ldd	r25, Z+3	; 0x03
    1d0a:	13 96       	adiw	r26, 0x03	; 3
    1d0c:	9c 93       	st	X, r25
    1d0e:	8e 93       	st	-X, r24
    1d10:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    1d12:	e9 81       	ldd	r30, Y+1	; 0x01
    1d14:	fa 81       	ldd	r31, Y+2	; 0x02
    1d16:	21 81       	ldd	r18, Z+1	; 0x01
    1d18:	32 81       	ldd	r19, Z+2	; 0x02
    1d1a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d1c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d1e:	28 17       	cp	r18, r24
    1d20:	39 07       	cpc	r19, r25
    1d22:	41 f4       	brne	.+16     	; 0x1d34 <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    1d24:	eb 81       	ldd	r30, Y+3	; 0x03
    1d26:	fc 81       	ldd	r31, Y+4	; 0x04
    1d28:	84 81       	ldd	r24, Z+4	; 0x04
    1d2a:	95 81       	ldd	r25, Z+5	; 0x05
    1d2c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d2e:	fa 81       	ldd	r31, Y+2	; 0x02
    1d30:	92 83       	std	Z+2, r25	; 0x02
    1d32:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    1d34:	eb 81       	ldd	r30, Y+3	; 0x03
    1d36:	fc 81       	ldd	r31, Y+4	; 0x04
    1d38:	11 86       	std	Z+9, r1	; 0x09
    1d3a:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    1d3c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d3e:	fa 81       	ldd	r31, Y+2	; 0x02
    1d40:	80 81       	ld	r24, Z
    1d42:	81 50       	subi	r24, 0x01	; 1
    1d44:	e9 81       	ldd	r30, Y+1	; 0x01
    1d46:	fa 81       	ldd	r31, Y+2	; 0x02
    1d48:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    1d4a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d4c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d4e:	80 81       	ld	r24, Z
}
    1d50:	0f 90       	pop	r0
    1d52:	0f 90       	pop	r0
    1d54:	0f 90       	pop	r0
    1d56:	0f 90       	pop	r0
    1d58:	cf 91       	pop	r28
    1d5a:	df 91       	pop	r29
    1d5c:	08 95       	ret

00001d5e <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    1d5e:	df 93       	push	r29
    1d60:	cf 93       	push	r28
    1d62:	00 d0       	rcall	.+0      	; 0x1d64 <xQueueGenericReset+0x6>
    1d64:	00 d0       	rcall	.+0      	; 0x1d66 <xQueueGenericReset+0x8>
    1d66:	00 d0       	rcall	.+0      	; 0x1d68 <xQueueGenericReset+0xa>
    1d68:	cd b7       	in	r28, 0x3d	; 61
    1d6a:	de b7       	in	r29, 0x3e	; 62
    1d6c:	9d 83       	std	Y+5, r25	; 0x05
    1d6e:	8c 83       	std	Y+4, r24	; 0x04
    1d70:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    1d72:	81 e0       	ldi	r24, 0x01	; 1
    1d74:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    1d76:	8c 81       	ldd	r24, Y+4	; 0x04
    1d78:	9d 81       	ldd	r25, Y+5	; 0x05
    1d7a:	9a 83       	std	Y+2, r25	; 0x02
    1d7c:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    1d7e:	89 81       	ldd	r24, Y+1	; 0x01
    1d80:	9a 81       	ldd	r25, Y+2	; 0x02
    1d82:	00 97       	sbiw	r24, 0x00	; 0
    1d84:	09 f4       	brne	.+2      	; 0x1d88 <xQueueGenericReset+0x2a>
    1d86:	8b c0       	rjmp	.+278    	; 0x1e9e <xQueueGenericReset+0x140>
    1d88:	e9 81       	ldd	r30, Y+1	; 0x01
    1d8a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d8c:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d8e:	88 23       	and	r24, r24
    1d90:	09 f4       	brne	.+2      	; 0x1d94 <xQueueGenericReset+0x36>
    1d92:	85 c0       	rjmp	.+266    	; 0x1e9e <xQueueGenericReset+0x140>
    1d94:	e9 81       	ldd	r30, Y+1	; 0x01
    1d96:	fa 81       	ldd	r31, Y+2	; 0x02
    1d98:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d9a:	28 2f       	mov	r18, r24
    1d9c:	30 e0       	ldi	r19, 0x00	; 0
    1d9e:	8f ef       	ldi	r24, 0xFF	; 255
    1da0:	9f e7       	ldi	r25, 0x7F	; 127
    1da2:	b9 01       	movw	r22, r18
    1da4:	0e 94 7e 32 	call	0x64fc	; 0x64fc <__udivmodhi4>
    1da8:	cb 01       	movw	r24, r22
    1daa:	9c 01       	movw	r18, r24
    1dac:	e9 81       	ldd	r30, Y+1	; 0x01
    1dae:	fa 81       	ldd	r31, Y+2	; 0x02
    1db0:	84 8d       	ldd	r24, Z+28	; 0x1c
    1db2:	88 2f       	mov	r24, r24
    1db4:	90 e0       	ldi	r25, 0x00	; 0
    1db6:	28 17       	cp	r18, r24
    1db8:	39 07       	cpc	r19, r25
    1dba:	08 f4       	brcc	.+2      	; 0x1dbe <xQueueGenericReset+0x60>
    1dbc:	70 c0       	rjmp	.+224    	; 0x1e9e <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    1dbe:	0f b6       	in	r0, 0x3f	; 63
    1dc0:	f8 94       	cli
    1dc2:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1dc4:	e9 81       	ldd	r30, Y+1	; 0x01
    1dc6:	fa 81       	ldd	r31, Y+2	; 0x02
    1dc8:	40 81       	ld	r20, Z
    1dca:	51 81       	ldd	r21, Z+1	; 0x01
    1dcc:	e9 81       	ldd	r30, Y+1	; 0x01
    1dce:	fa 81       	ldd	r31, Y+2	; 0x02
    1dd0:	83 8d       	ldd	r24, Z+27	; 0x1b
    1dd2:	28 2f       	mov	r18, r24
    1dd4:	30 e0       	ldi	r19, 0x00	; 0
    1dd6:	e9 81       	ldd	r30, Y+1	; 0x01
    1dd8:	fa 81       	ldd	r31, Y+2	; 0x02
    1dda:	84 8d       	ldd	r24, Z+28	; 0x1c
    1ddc:	88 2f       	mov	r24, r24
    1dde:	90 e0       	ldi	r25, 0x00	; 0
    1de0:	bc 01       	movw	r22, r24
    1de2:	26 9f       	mul	r18, r22
    1de4:	c0 01       	movw	r24, r0
    1de6:	27 9f       	mul	r18, r23
    1de8:	90 0d       	add	r25, r0
    1dea:	36 9f       	mul	r19, r22
    1dec:	90 0d       	add	r25, r0
    1dee:	11 24       	eor	r1, r1
    1df0:	84 0f       	add	r24, r20
    1df2:	95 1f       	adc	r25, r21
    1df4:	e9 81       	ldd	r30, Y+1	; 0x01
    1df6:	fa 81       	ldd	r31, Y+2	; 0x02
    1df8:	95 83       	std	Z+5, r25	; 0x05
    1dfa:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1dfc:	e9 81       	ldd	r30, Y+1	; 0x01
    1dfe:	fa 81       	ldd	r31, Y+2	; 0x02
    1e00:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    1e02:	e9 81       	ldd	r30, Y+1	; 0x01
    1e04:	fa 81       	ldd	r31, Y+2	; 0x02
    1e06:	80 81       	ld	r24, Z
    1e08:	91 81       	ldd	r25, Z+1	; 0x01
    1e0a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e0c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e0e:	93 83       	std	Z+3, r25	; 0x03
    1e10:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1e12:	e9 81       	ldd	r30, Y+1	; 0x01
    1e14:	fa 81       	ldd	r31, Y+2	; 0x02
    1e16:	40 81       	ld	r20, Z
    1e18:	51 81       	ldd	r21, Z+1	; 0x01
    1e1a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e1c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e1e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e20:	88 2f       	mov	r24, r24
    1e22:	90 e0       	ldi	r25, 0x00	; 0
    1e24:	9c 01       	movw	r18, r24
    1e26:	21 50       	subi	r18, 0x01	; 1
    1e28:	30 40       	sbci	r19, 0x00	; 0
    1e2a:	e9 81       	ldd	r30, Y+1	; 0x01
    1e2c:	fa 81       	ldd	r31, Y+2	; 0x02
    1e2e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e30:	88 2f       	mov	r24, r24
    1e32:	90 e0       	ldi	r25, 0x00	; 0
    1e34:	bc 01       	movw	r22, r24
    1e36:	26 9f       	mul	r18, r22
    1e38:	c0 01       	movw	r24, r0
    1e3a:	27 9f       	mul	r18, r23
    1e3c:	90 0d       	add	r25, r0
    1e3e:	36 9f       	mul	r19, r22
    1e40:	90 0d       	add	r25, r0
    1e42:	11 24       	eor	r1, r1
    1e44:	84 0f       	add	r24, r20
    1e46:	95 1f       	adc	r25, r21
    1e48:	e9 81       	ldd	r30, Y+1	; 0x01
    1e4a:	fa 81       	ldd	r31, Y+2	; 0x02
    1e4c:	97 83       	std	Z+7, r25	; 0x07
    1e4e:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    1e50:	e9 81       	ldd	r30, Y+1	; 0x01
    1e52:	fa 81       	ldd	r31, Y+2	; 0x02
    1e54:	8f ef       	ldi	r24, 0xFF	; 255
    1e56:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    1e58:	e9 81       	ldd	r30, Y+1	; 0x01
    1e5a:	fa 81       	ldd	r31, Y+2	; 0x02
    1e5c:	8f ef       	ldi	r24, 0xFF	; 255
    1e5e:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    1e60:	8e 81       	ldd	r24, Y+6	; 0x06
    1e62:	88 23       	and	r24, r24
    1e64:	79 f4       	brne	.+30     	; 0x1e84 <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e66:	e9 81       	ldd	r30, Y+1	; 0x01
    1e68:	fa 81       	ldd	r31, Y+2	; 0x02
    1e6a:	80 85       	ldd	r24, Z+8	; 0x08
    1e6c:	88 23       	and	r24, r24
    1e6e:	a1 f0       	breq	.+40     	; 0x1e98 <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e70:	89 81       	ldd	r24, Y+1	; 0x01
    1e72:	9a 81       	ldd	r25, Y+2	; 0x02
    1e74:	08 96       	adiw	r24, 0x08	; 8
    1e76:	0e 94 1c 20 	call	0x4038	; 0x4038 <xTaskRemoveFromEventList>
    1e7a:	88 23       	and	r24, r24
    1e7c:	69 f0       	breq	.+26     	; 0x1e98 <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1e7e:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    1e82:	0a c0       	rjmp	.+20     	; 0x1e98 <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1e84:	89 81       	ldd	r24, Y+1	; 0x01
    1e86:	9a 81       	ldd	r25, Y+2	; 0x02
    1e88:	08 96       	adiw	r24, 0x08	; 8
    1e8a:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1e8e:	89 81       	ldd	r24, Y+1	; 0x01
    1e90:	9a 81       	ldd	r25, Y+2	; 0x02
    1e92:	41 96       	adiw	r24, 0x11	; 17
    1e94:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    1e98:	0f 90       	pop	r0
    1e9a:	0f be       	out	0x3f, r0	; 63
    1e9c:	01 c0       	rjmp	.+2      	; 0x1ea0 <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    1e9e:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    1ea0:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1ea2:	26 96       	adiw	r28, 0x06	; 6
    1ea4:	0f b6       	in	r0, 0x3f	; 63
    1ea6:	f8 94       	cli
    1ea8:	de bf       	out	0x3e, r29	; 62
    1eaa:	0f be       	out	0x3f, r0	; 63
    1eac:	cd bf       	out	0x3d, r28	; 61
    1eae:	cf 91       	pop	r28
    1eb0:	df 91       	pop	r29
    1eb2:	08 95       	ret

00001eb4 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    1eb4:	0f 93       	push	r16
    1eb6:	1f 93       	push	r17
    1eb8:	df 93       	push	r29
    1eba:	cf 93       	push	r28
    1ebc:	cd b7       	in	r28, 0x3d	; 61
    1ebe:	de b7       	in	r29, 0x3e	; 62
    1ec0:	29 97       	sbiw	r28, 0x09	; 9
    1ec2:	0f b6       	in	r0, 0x3f	; 63
    1ec4:	f8 94       	cli
    1ec6:	de bf       	out	0x3e, r29	; 62
    1ec8:	0f be       	out	0x3f, r0	; 63
    1eca:	cd bf       	out	0x3d, r28	; 61
    1ecc:	8f 83       	std	Y+7, r24	; 0x07
    1ece:	68 87       	std	Y+8, r22	; 0x08
    1ed0:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    1ed2:	1e 82       	std	Y+6, r1	; 0x06
    1ed4:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    1ed6:	8f 81       	ldd	r24, Y+7	; 0x07
    1ed8:	88 23       	and	r24, r24
    1eda:	09 f4       	brne	.+2      	; 0x1ede <xQueueGenericCreate+0x2a>
    1edc:	52 c0       	rjmp	.+164    	; 0x1f82 <xQueueGenericCreate+0xce>
    1ede:	8f 81       	ldd	r24, Y+7	; 0x07
    1ee0:	28 2f       	mov	r18, r24
    1ee2:	30 e0       	ldi	r19, 0x00	; 0
    1ee4:	8f ef       	ldi	r24, 0xFF	; 255
    1ee6:	9f e7       	ldi	r25, 0x7F	; 127
    1ee8:	b9 01       	movw	r22, r18
    1eea:	0e 94 7e 32 	call	0x64fc	; 0x64fc <__udivmodhi4>
    1eee:	cb 01       	movw	r24, r22
    1ef0:	9c 01       	movw	r18, r24
    1ef2:	88 85       	ldd	r24, Y+8	; 0x08
    1ef4:	88 2f       	mov	r24, r24
    1ef6:	90 e0       	ldi	r25, 0x00	; 0
    1ef8:	28 17       	cp	r18, r24
    1efa:	39 07       	cpc	r19, r25
    1efc:	08 f4       	brcc	.+2      	; 0x1f00 <xQueueGenericCreate+0x4c>
    1efe:	41 c0       	rjmp	.+130    	; 0x1f82 <xQueueGenericCreate+0xce>
    1f00:	8f 81       	ldd	r24, Y+7	; 0x07
    1f02:	28 2f       	mov	r18, r24
    1f04:	30 e0       	ldi	r19, 0x00	; 0
    1f06:	88 85       	ldd	r24, Y+8	; 0x08
    1f08:	88 2f       	mov	r24, r24
    1f0a:	90 e0       	ldi	r25, 0x00	; 0
    1f0c:	ac 01       	movw	r20, r24
    1f0e:	24 9f       	mul	r18, r20
    1f10:	c0 01       	movw	r24, r0
    1f12:	25 9f       	mul	r18, r21
    1f14:	90 0d       	add	r25, r0
    1f16:	34 9f       	mul	r19, r20
    1f18:	90 0d       	add	r25, r0
    1f1a:	11 24       	eor	r1, r1
    1f1c:	5f e7       	ldi	r21, 0x7F	; 127
    1f1e:	81 3e       	cpi	r24, 0xE1	; 225
    1f20:	95 07       	cpc	r25, r21
    1f22:	78 f5       	brcc	.+94     	; 0x1f82 <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1f24:	8f 81       	ldd	r24, Y+7	; 0x07
    1f26:	28 2f       	mov	r18, r24
    1f28:	30 e0       	ldi	r19, 0x00	; 0
    1f2a:	88 85       	ldd	r24, Y+8	; 0x08
    1f2c:	88 2f       	mov	r24, r24
    1f2e:	90 e0       	ldi	r25, 0x00	; 0
    1f30:	ac 01       	movw	r20, r24
    1f32:	24 9f       	mul	r18, r20
    1f34:	c0 01       	movw	r24, r0
    1f36:	25 9f       	mul	r18, r21
    1f38:	90 0d       	add	r25, r0
    1f3a:	34 9f       	mul	r19, r20
    1f3c:	90 0d       	add	r25, r0
    1f3e:	11 24       	eor	r1, r1
    1f40:	9c 83       	std	Y+4, r25	; 0x04
    1f42:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1f44:	8b 81       	ldd	r24, Y+3	; 0x03
    1f46:	9c 81       	ldd	r25, Y+4	; 0x04
    1f48:	4f 96       	adiw	r24, 0x1f	; 31
    1f4a:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    1f4e:	9e 83       	std	Y+6, r25	; 0x06
    1f50:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    1f52:	8d 81       	ldd	r24, Y+5	; 0x05
    1f54:	9e 81       	ldd	r25, Y+6	; 0x06
    1f56:	00 97       	sbiw	r24, 0x00	; 0
    1f58:	a1 f0       	breq	.+40     	; 0x1f82 <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1f5a:	8d 81       	ldd	r24, Y+5	; 0x05
    1f5c:	9e 81       	ldd	r25, Y+6	; 0x06
    1f5e:	9a 83       	std	Y+2, r25	; 0x02
    1f60:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1f62:	89 81       	ldd	r24, Y+1	; 0x01
    1f64:	9a 81       	ldd	r25, Y+2	; 0x02
    1f66:	4f 96       	adiw	r24, 0x1f	; 31
    1f68:	9a 83       	std	Y+2, r25	; 0x02
    1f6a:	89 83       	std	Y+1, r24	; 0x01
                         * deleted. */
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
                    }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1f6c:	29 81       	ldd	r18, Y+1	; 0x01
    1f6e:	3a 81       	ldd	r19, Y+2	; 0x02
    1f70:	ed 81       	ldd	r30, Y+5	; 0x05
    1f72:	fe 81       	ldd	r31, Y+6	; 0x06
    1f74:	8f 81       	ldd	r24, Y+7	; 0x07
    1f76:	68 85       	ldd	r22, Y+8	; 0x08
    1f78:	a9 01       	movw	r20, r18
    1f7a:	29 85       	ldd	r18, Y+9	; 0x09
    1f7c:	8f 01       	movw	r16, r30
    1f7e:	0e 94 ce 0f 	call	0x1f9c	; 0x1f9c <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    1f82:	8d 81       	ldd	r24, Y+5	; 0x05
    1f84:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    1f86:	29 96       	adiw	r28, 0x09	; 9
    1f88:	0f b6       	in	r0, 0x3f	; 63
    1f8a:	f8 94       	cli
    1f8c:	de bf       	out	0x3e, r29	; 62
    1f8e:	0f be       	out	0x3f, r0	; 63
    1f90:	cd bf       	out	0x3d, r28	; 61
    1f92:	cf 91       	pop	r28
    1f94:	df 91       	pop	r29
    1f96:	1f 91       	pop	r17
    1f98:	0f 91       	pop	r16
    1f9a:	08 95       	ret

00001f9c <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    1f9c:	0f 93       	push	r16
    1f9e:	1f 93       	push	r17
    1fa0:	df 93       	push	r29
    1fa2:	cf 93       	push	r28
    1fa4:	cd b7       	in	r28, 0x3d	; 61
    1fa6:	de b7       	in	r29, 0x3e	; 62
    1fa8:	27 97       	sbiw	r28, 0x07	; 7
    1faa:	0f b6       	in	r0, 0x3f	; 63
    1fac:	f8 94       	cli
    1fae:	de bf       	out	0x3e, r29	; 62
    1fb0:	0f be       	out	0x3f, r0	; 63
    1fb2:	cd bf       	out	0x3d, r28	; 61
    1fb4:	89 83       	std	Y+1, r24	; 0x01
    1fb6:	6a 83       	std	Y+2, r22	; 0x02
    1fb8:	5c 83       	std	Y+4, r21	; 0x04
    1fba:	4b 83       	std	Y+3, r20	; 0x03
    1fbc:	2d 83       	std	Y+5, r18	; 0x05
    1fbe:	1f 83       	std	Y+7, r17	; 0x07
    1fc0:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    1fc2:	8a 81       	ldd	r24, Y+2	; 0x02
    1fc4:	88 23       	and	r24, r24
    1fc6:	39 f4       	brne	.+14     	; 0x1fd6 <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1fc8:	8e 81       	ldd	r24, Y+6	; 0x06
    1fca:	9f 81       	ldd	r25, Y+7	; 0x07
    1fcc:	ee 81       	ldd	r30, Y+6	; 0x06
    1fce:	ff 81       	ldd	r31, Y+7	; 0x07
    1fd0:	91 83       	std	Z+1, r25	; 0x01
    1fd2:	80 83       	st	Z, r24
    1fd4:	06 c0       	rjmp	.+12     	; 0x1fe2 <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1fd6:	8b 81       	ldd	r24, Y+3	; 0x03
    1fd8:	9c 81       	ldd	r25, Y+4	; 0x04
    1fda:	ee 81       	ldd	r30, Y+6	; 0x06
    1fdc:	ff 81       	ldd	r31, Y+7	; 0x07
    1fde:	91 83       	std	Z+1, r25	; 0x01
    1fe0:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    1fe2:	ee 81       	ldd	r30, Y+6	; 0x06
    1fe4:	ff 81       	ldd	r31, Y+7	; 0x07
    1fe6:	89 81       	ldd	r24, Y+1	; 0x01
    1fe8:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    1fea:	ee 81       	ldd	r30, Y+6	; 0x06
    1fec:	ff 81       	ldd	r31, Y+7	; 0x07
    1fee:	8a 81       	ldd	r24, Y+2	; 0x02
    1ff0:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1ff2:	8e 81       	ldd	r24, Y+6	; 0x06
    1ff4:	9f 81       	ldd	r25, Y+7	; 0x07
    1ff6:	61 e0       	ldi	r22, 0x01	; 1
    1ff8:	0e 94 af 0e 	call	0x1d5e	; 0x1d5e <xQueueGenericReset>
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    1ffc:	27 96       	adiw	r28, 0x07	; 7
    1ffe:	0f b6       	in	r0, 0x3f	; 63
    2000:	f8 94       	cli
    2002:	de bf       	out	0x3e, r29	; 62
    2004:	0f be       	out	0x3f, r0	; 63
    2006:	cd bf       	out	0x3d, r28	; 61
    2008:	cf 91       	pop	r28
    200a:	df 91       	pop	r29
    200c:	1f 91       	pop	r17
    200e:	0f 91       	pop	r16
    2010:	08 95       	ret

00002012 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    2012:	df 93       	push	r29
    2014:	cf 93       	push	r28
    2016:	cd b7       	in	r28, 0x3d	; 61
    2018:	de b7       	in	r29, 0x3e	; 62
    201a:	2f 97       	sbiw	r28, 0x0f	; 15
    201c:	0f b6       	in	r0, 0x3f	; 63
    201e:	f8 94       	cli
    2020:	de bf       	out	0x3e, r29	; 62
    2022:	0f be       	out	0x3f, r0	; 63
    2024:	cd bf       	out	0x3d, r28	; 61
    2026:	99 87       	std	Y+9, r25	; 0x09
    2028:	88 87       	std	Y+8, r24	; 0x08
    202a:	7b 87       	std	Y+11, r23	; 0x0b
    202c:	6a 87       	std	Y+10, r22	; 0x0a
    202e:	5d 87       	std	Y+13, r21	; 0x0d
    2030:	4c 87       	std	Y+12, r20	; 0x0c
    2032:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    2034:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2036:	88 85       	ldd	r24, Y+8	; 0x08
    2038:	99 85       	ldd	r25, Y+9	; 0x09
    203a:	9a 83       	std	Y+2, r25	; 0x02
    203c:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    203e:	0f b6       	in	r0, 0x3f	; 63
    2040:	f8 94       	cli
    2042:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2044:	e9 81       	ldd	r30, Y+1	; 0x01
    2046:	fa 81       	ldd	r31, Y+2	; 0x02
    2048:	92 8d       	ldd	r25, Z+26	; 0x1a
    204a:	e9 81       	ldd	r30, Y+1	; 0x01
    204c:	fa 81       	ldd	r31, Y+2	; 0x02
    204e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2050:	98 17       	cp	r25, r24
    2052:	18 f0       	brcs	.+6      	; 0x205a <xQueueGenericSend+0x48>
    2054:	8e 85       	ldd	r24, Y+14	; 0x0e
    2056:	82 30       	cpi	r24, 0x02	; 2
    2058:	11 f5       	brne	.+68     	; 0x209e <xQueueGenericSend+0x8c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    205a:	89 81       	ldd	r24, Y+1	; 0x01
    205c:	9a 81       	ldd	r25, Y+2	; 0x02
    205e:	2a 85       	ldd	r18, Y+10	; 0x0a
    2060:	3b 85       	ldd	r19, Y+11	; 0x0b
    2062:	b9 01       	movw	r22, r18
    2064:	4e 85       	ldd	r20, Y+14	; 0x0e
    2066:	0e 94 5f 14 	call	0x28be	; 0x28be <prvCopyDataToQueue>
    206a:	8b 83       	std	Y+3, r24	; 0x03

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    206c:	e9 81       	ldd	r30, Y+1	; 0x01
    206e:	fa 81       	ldd	r31, Y+2	; 0x02
    2070:	81 89       	ldd	r24, Z+17	; 0x11
    2072:	88 23       	and	r24, r24
    2074:	51 f0       	breq	.+20     	; 0x208a <xQueueGenericSend+0x78>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2076:	89 81       	ldd	r24, Y+1	; 0x01
    2078:	9a 81       	ldd	r25, Y+2	; 0x02
    207a:	41 96       	adiw	r24, 0x11	; 17
    207c:	0e 94 1c 20 	call	0x4038	; 0x4038 <xTaskRemoveFromEventList>
    2080:	88 23       	and	r24, r24
    2082:	41 f0       	breq	.+16     	; 0x2094 <xQueueGenericSend+0x82>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    2084:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    2088:	05 c0       	rjmp	.+10     	; 0x2094 <xQueueGenericSend+0x82>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    208a:	8b 81       	ldd	r24, Y+3	; 0x03
    208c:	88 23       	and	r24, r24
    208e:	11 f0       	breq	.+4      	; 0x2094 <xQueueGenericSend+0x82>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    2090:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    2094:	0f 90       	pop	r0
    2096:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    2098:	81 e0       	ldi	r24, 0x01	; 1
    209a:	8f 87       	std	Y+15, r24	; 0x0f
    209c:	5c c0       	rjmp	.+184    	; 0x2156 <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    209e:	8c 85       	ldd	r24, Y+12	; 0x0c
    20a0:	9d 85       	ldd	r25, Y+13	; 0x0d
    20a2:	00 97       	sbiw	r24, 0x00	; 0
    20a4:	21 f4       	brne	.+8      	; 0x20ae <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    20a6:	0f 90       	pop	r0
    20a8:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    20aa:	1f 86       	std	Y+15, r1	; 0x0f
    20ac:	54 c0       	rjmp	.+168    	; 0x2156 <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    20ae:	8c 81       	ldd	r24, Y+4	; 0x04
    20b0:	88 23       	and	r24, r24
    20b2:	31 f4       	brne	.+12     	; 0x20c0 <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    20b4:	ce 01       	movw	r24, r28
    20b6:	05 96       	adiw	r24, 0x05	; 5
    20b8:	0e 94 8c 22 	call	0x4518	; 0x4518 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    20bc:	81 e0       	ldi	r24, 0x01	; 1
    20be:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    20c0:	0f 90       	pop	r0
    20c2:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    20c4:	0e 94 56 1b 	call	0x36ac	; 0x36ac <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    20c8:	0f b6       	in	r0, 0x3f	; 63
    20ca:	f8 94       	cli
    20cc:	0f 92       	push	r0
    20ce:	e9 81       	ldd	r30, Y+1	; 0x01
    20d0:	fa 81       	ldd	r31, Y+2	; 0x02
    20d2:	85 8d       	ldd	r24, Z+29	; 0x1d
    20d4:	8f 3f       	cpi	r24, 0xFF	; 255
    20d6:	19 f4       	brne	.+6      	; 0x20de <xQueueGenericSend+0xcc>
    20d8:	e9 81       	ldd	r30, Y+1	; 0x01
    20da:	fa 81       	ldd	r31, Y+2	; 0x02
    20dc:	15 8e       	std	Z+29, r1	; 0x1d
    20de:	e9 81       	ldd	r30, Y+1	; 0x01
    20e0:	fa 81       	ldd	r31, Y+2	; 0x02
    20e2:	86 8d       	ldd	r24, Z+30	; 0x1e
    20e4:	8f 3f       	cpi	r24, 0xFF	; 255
    20e6:	19 f4       	brne	.+6      	; 0x20ee <xQueueGenericSend+0xdc>
    20e8:	e9 81       	ldd	r30, Y+1	; 0x01
    20ea:	fa 81       	ldd	r31, Y+2	; 0x02
    20ec:	16 8e       	std	Z+30, r1	; 0x1e
    20ee:	0f 90       	pop	r0
    20f0:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    20f2:	ce 01       	movw	r24, r28
    20f4:	05 96       	adiw	r24, 0x05	; 5
    20f6:	9e 01       	movw	r18, r28
    20f8:	24 5f       	subi	r18, 0xF4	; 244
    20fa:	3f 4f       	sbci	r19, 0xFF	; 255
    20fc:	b9 01       	movw	r22, r18
    20fe:	0e 94 a5 22 	call	0x454a	; 0x454a <xTaskCheckForTimeOut>
    2102:	88 23       	and	r24, r24
    2104:	09 f5       	brne	.+66     	; 0x2148 <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2106:	89 81       	ldd	r24, Y+1	; 0x01
    2108:	9a 81       	ldd	r25, Y+2	; 0x02
    210a:	0e 94 db 15 	call	0x2bb6	; 0x2bb6 <prvIsQueueFull>
    210e:	88 23       	and	r24, r24
    2110:	a1 f0       	breq	.+40     	; 0x213a <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2112:	89 81       	ldd	r24, Y+1	; 0x01
    2114:	9a 81       	ldd	r25, Y+2	; 0x02
    2116:	08 96       	adiw	r24, 0x08	; 8
    2118:	2c 85       	ldd	r18, Y+12	; 0x0c
    211a:	3d 85       	ldd	r19, Y+13	; 0x0d
    211c:	b9 01       	movw	r22, r18
    211e:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    2122:	89 81       	ldd	r24, Y+1	; 0x01
    2124:	9a 81       	ldd	r25, Y+2	; 0x02
    2126:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    212a:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>
    212e:	88 23       	and	r24, r24
    2130:	09 f0       	breq	.+2      	; 0x2134 <xQueueGenericSend+0x122>
    2132:	85 cf       	rjmp	.-246    	; 0x203e <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    2134:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    2138:	82 cf       	rjmp	.-252    	; 0x203e <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    213a:	89 81       	ldd	r24, Y+1	; 0x01
    213c:	9a 81       	ldd	r25, Y+2	; 0x02
    213e:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2142:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>
    2146:	7b cf       	rjmp	.-266    	; 0x203e <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    2148:	89 81       	ldd	r24, Y+1	; 0x01
    214a:	9a 81       	ldd	r25, Y+2	; 0x02
    214c:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2150:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    2154:	1f 86       	std	Y+15, r1	; 0x0f
    2156:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    2158:	2f 96       	adiw	r28, 0x0f	; 15
    215a:	0f b6       	in	r0, 0x3f	; 63
    215c:	f8 94       	cli
    215e:	de bf       	out	0x3e, r29	; 62
    2160:	0f be       	out	0x3f, r0	; 63
    2162:	cd bf       	out	0x3d, r28	; 61
    2164:	cf 91       	pop	r28
    2166:	df 91       	pop	r29
    2168:	08 95       	ret

0000216a <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    216a:	df 93       	push	r29
    216c:	cf 93       	push	r28
    216e:	cd b7       	in	r28, 0x3d	; 61
    2170:	de b7       	in	r29, 0x3e	; 62
    2172:	2d 97       	sbiw	r28, 0x0d	; 13
    2174:	0f b6       	in	r0, 0x3f	; 63
    2176:	f8 94       	cli
    2178:	de bf       	out	0x3e, r29	; 62
    217a:	0f be       	out	0x3f, r0	; 63
    217c:	cd bf       	out	0x3d, r28	; 61
    217e:	98 87       	std	Y+8, r25	; 0x08
    2180:	8f 83       	std	Y+7, r24	; 0x07
    2182:	7a 87       	std	Y+10, r23	; 0x0a
    2184:	69 87       	std	Y+9, r22	; 0x09
    2186:	5c 87       	std	Y+12, r21	; 0x0c
    2188:	4b 87       	std	Y+11, r20	; 0x0b
    218a:	2d 87       	std	Y+13, r18	; 0x0d
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    218c:	8f 81       	ldd	r24, Y+7	; 0x07
    218e:	98 85       	ldd	r25, Y+8	; 0x08
    2190:	9c 83       	std	Y+4, r25	; 0x04
    2192:	8b 83       	std	Y+3, r24	; 0x03
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2194:	1d 82       	std	Y+5, r1	; 0x05
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2196:	eb 81       	ldd	r30, Y+3	; 0x03
    2198:	fc 81       	ldd	r31, Y+4	; 0x04
    219a:	92 8d       	ldd	r25, Z+26	; 0x1a
    219c:	eb 81       	ldd	r30, Y+3	; 0x03
    219e:	fc 81       	ldd	r31, Y+4	; 0x04
    21a0:	83 8d       	ldd	r24, Z+27	; 0x1b
    21a2:	98 17       	cp	r25, r24
    21a4:	18 f0       	brcs	.+6      	; 0x21ac <xQueueGenericSendFromISR+0x42>
    21a6:	8d 85       	ldd	r24, Y+13	; 0x0d
    21a8:	82 30       	cpi	r24, 0x02	; 2
    21aa:	81 f5       	brne	.+96     	; 0x220c <xQueueGenericSendFromISR+0xa2>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    21ac:	eb 81       	ldd	r30, Y+3	; 0x03
    21ae:	fc 81       	ldd	r31, Y+4	; 0x04
    21b0:	86 8d       	ldd	r24, Z+30	; 0x1e
    21b2:	8a 83       	std	Y+2, r24	; 0x02
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    21b4:	eb 81       	ldd	r30, Y+3	; 0x03
    21b6:	fc 81       	ldd	r31, Y+4	; 0x04
    21b8:	82 8d       	ldd	r24, Z+26	; 0x1a
    21ba:	89 83       	std	Y+1, r24	; 0x01
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    21bc:	8b 81       	ldd	r24, Y+3	; 0x03
    21be:	9c 81       	ldd	r25, Y+4	; 0x04
    21c0:	29 85       	ldd	r18, Y+9	; 0x09
    21c2:	3a 85       	ldd	r19, Y+10	; 0x0a
    21c4:	b9 01       	movw	r22, r18
    21c6:	4d 85       	ldd	r20, Y+13	; 0x0d
    21c8:	0e 94 5f 14 	call	0x28be	; 0x28be <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    21cc:	8a 81       	ldd	r24, Y+2	; 0x02
    21ce:	8f 3f       	cpi	r24, 0xFF	; 255
    21d0:	a9 f4       	brne	.+42     	; 0x21fc <xQueueGenericSendFromISR+0x92>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    21d2:	eb 81       	ldd	r30, Y+3	; 0x03
    21d4:	fc 81       	ldd	r31, Y+4	; 0x04
    21d6:	81 89       	ldd	r24, Z+17	; 0x11
    21d8:	88 23       	and	r24, r24
    21da:	a9 f0       	breq	.+42     	; 0x2206 <xQueueGenericSendFromISR+0x9c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    21dc:	8b 81       	ldd	r24, Y+3	; 0x03
    21de:	9c 81       	ldd	r25, Y+4	; 0x04
    21e0:	41 96       	adiw	r24, 0x11	; 17
    21e2:	0e 94 1c 20 	call	0x4038	; 0x4038 <xTaskRemoveFromEventList>
    21e6:	88 23       	and	r24, r24
    21e8:	71 f0       	breq	.+28     	; 0x2206 <xQueueGenericSendFromISR+0x9c>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    21ea:	8b 85       	ldd	r24, Y+11	; 0x0b
    21ec:	9c 85       	ldd	r25, Y+12	; 0x0c
    21ee:	00 97       	sbiw	r24, 0x00	; 0
    21f0:	51 f0       	breq	.+20     	; 0x2206 <xQueueGenericSendFromISR+0x9c>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    21f2:	eb 85       	ldd	r30, Y+11	; 0x0b
    21f4:	fc 85       	ldd	r31, Y+12	; 0x0c
    21f6:	81 e0       	ldi	r24, 0x01	; 1
    21f8:	80 83       	st	Z, r24
    21fa:	05 c0       	rjmp	.+10     	; 0x2206 <xQueueGenericSendFromISR+0x9c>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    21fc:	8a 81       	ldd	r24, Y+2	; 0x02
    21fe:	8f 5f       	subi	r24, 0xFF	; 255
    2200:	eb 81       	ldd	r30, Y+3	; 0x03
    2202:	fc 81       	ldd	r31, Y+4	; 0x04
    2204:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    2206:	81 e0       	ldi	r24, 0x01	; 1
    2208:	8e 83       	std	Y+6, r24	; 0x06
    220a:	01 c0       	rjmp	.+2      	; 0x220e <xQueueGenericSendFromISR+0xa4>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    220c:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    220e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2210:	2d 96       	adiw	r28, 0x0d	; 13
    2212:	0f b6       	in	r0, 0x3f	; 63
    2214:	f8 94       	cli
    2216:	de bf       	out	0x3e, r29	; 62
    2218:	0f be       	out	0x3f, r0	; 63
    221a:	cd bf       	out	0x3d, r28	; 61
    221c:	cf 91       	pop	r28
    221e:	df 91       	pop	r29
    2220:	08 95       	ret

00002222 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    2222:	df 93       	push	r29
    2224:	cf 93       	push	r28
    2226:	cd b7       	in	r28, 0x3d	; 61
    2228:	de b7       	in	r29, 0x3e	; 62
    222a:	2a 97       	sbiw	r28, 0x0a	; 10
    222c:	0f b6       	in	r0, 0x3f	; 63
    222e:	f8 94       	cli
    2230:	de bf       	out	0x3e, r29	; 62
    2232:	0f be       	out	0x3f, r0	; 63
    2234:	cd bf       	out	0x3d, r28	; 61
    2236:	98 87       	std	Y+8, r25	; 0x08
    2238:	8f 83       	std	Y+7, r24	; 0x07
    223a:	7a 87       	std	Y+10, r23	; 0x0a
    223c:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    223e:	8f 81       	ldd	r24, Y+7	; 0x07
    2240:	98 85       	ldd	r25, Y+8	; 0x08
    2242:	9c 83       	std	Y+4, r25	; 0x04
    2244:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2246:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2248:	eb 81       	ldd	r30, Y+3	; 0x03
    224a:	fc 81       	ldd	r31, Y+4	; 0x04
    224c:	82 8d       	ldd	r24, Z+26	; 0x1a
    224e:	8a 83       	std	Y+2, r24	; 0x02

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    2250:	eb 81       	ldd	r30, Y+3	; 0x03
    2252:	fc 81       	ldd	r31, Y+4	; 0x04
    2254:	93 8d       	ldd	r25, Z+27	; 0x1b
    2256:	8a 81       	ldd	r24, Y+2	; 0x02
    2258:	89 17       	cp	r24, r25
    225a:	48 f5       	brcc	.+82     	; 0x22ae <xQueueGiveFromISR+0x8c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    225c:	eb 81       	ldd	r30, Y+3	; 0x03
    225e:	fc 81       	ldd	r31, Y+4	; 0x04
    2260:	86 8d       	ldd	r24, Z+30	; 0x1e
    2262:	89 83       	std	Y+1, r24	; 0x01
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2264:	8a 81       	ldd	r24, Y+2	; 0x02
    2266:	8f 5f       	subi	r24, 0xFF	; 255
    2268:	eb 81       	ldd	r30, Y+3	; 0x03
    226a:	fc 81       	ldd	r31, Y+4	; 0x04
    226c:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    226e:	89 81       	ldd	r24, Y+1	; 0x01
    2270:	8f 3f       	cpi	r24, 0xFF	; 255
    2272:	a9 f4       	brne	.+42     	; 0x229e <xQueueGiveFromISR+0x7c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2274:	eb 81       	ldd	r30, Y+3	; 0x03
    2276:	fc 81       	ldd	r31, Y+4	; 0x04
    2278:	81 89       	ldd	r24, Z+17	; 0x11
    227a:	88 23       	and	r24, r24
    227c:	a9 f0       	breq	.+42     	; 0x22a8 <xQueueGiveFromISR+0x86>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    227e:	8b 81       	ldd	r24, Y+3	; 0x03
    2280:	9c 81       	ldd	r25, Y+4	; 0x04
    2282:	41 96       	adiw	r24, 0x11	; 17
    2284:	0e 94 1c 20 	call	0x4038	; 0x4038 <xTaskRemoveFromEventList>
    2288:	88 23       	and	r24, r24
    228a:	71 f0       	breq	.+28     	; 0x22a8 <xQueueGiveFromISR+0x86>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    228c:	89 85       	ldd	r24, Y+9	; 0x09
    228e:	9a 85       	ldd	r25, Y+10	; 0x0a
    2290:	00 97       	sbiw	r24, 0x00	; 0
    2292:	51 f0       	breq	.+20     	; 0x22a8 <xQueueGiveFromISR+0x86>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    2294:	e9 85       	ldd	r30, Y+9	; 0x09
    2296:	fa 85       	ldd	r31, Y+10	; 0x0a
    2298:	81 e0       	ldi	r24, 0x01	; 1
    229a:	80 83       	st	Z, r24
    229c:	05 c0       	rjmp	.+10     	; 0x22a8 <xQueueGiveFromISR+0x86>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    229e:	89 81       	ldd	r24, Y+1	; 0x01
    22a0:	8f 5f       	subi	r24, 0xFF	; 255
    22a2:	eb 81       	ldd	r30, Y+3	; 0x03
    22a4:	fc 81       	ldd	r31, Y+4	; 0x04
    22a6:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    22a8:	81 e0       	ldi	r24, 0x01	; 1
    22aa:	8e 83       	std	Y+6, r24	; 0x06
    22ac:	01 c0       	rjmp	.+2      	; 0x22b0 <xQueueGiveFromISR+0x8e>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    22ae:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    22b0:	8e 81       	ldd	r24, Y+6	; 0x06
}
    22b2:	2a 96       	adiw	r28, 0x0a	; 10
    22b4:	0f b6       	in	r0, 0x3f	; 63
    22b6:	f8 94       	cli
    22b8:	de bf       	out	0x3e, r29	; 62
    22ba:	0f be       	out	0x3f, r0	; 63
    22bc:	cd bf       	out	0x3d, r28	; 61
    22be:	cf 91       	pop	r28
    22c0:	df 91       	pop	r29
    22c2:	08 95       	ret

000022c4 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    22c4:	df 93       	push	r29
    22c6:	cf 93       	push	r28
    22c8:	cd b7       	in	r28, 0x3d	; 61
    22ca:	de b7       	in	r29, 0x3e	; 62
    22cc:	2e 97       	sbiw	r28, 0x0e	; 14
    22ce:	0f b6       	in	r0, 0x3f	; 63
    22d0:	f8 94       	cli
    22d2:	de bf       	out	0x3e, r29	; 62
    22d4:	0f be       	out	0x3f, r0	; 63
    22d6:	cd bf       	out	0x3d, r28	; 61
    22d8:	99 87       	std	Y+9, r25	; 0x09
    22da:	88 87       	std	Y+8, r24	; 0x08
    22dc:	7b 87       	std	Y+11, r23	; 0x0b
    22de:	6a 87       	std	Y+10, r22	; 0x0a
    22e0:	5d 87       	std	Y+13, r21	; 0x0d
    22e2:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    22e4:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    22e6:	88 85       	ldd	r24, Y+8	; 0x08
    22e8:	99 85       	ldd	r25, Y+9	; 0x09
    22ea:	9b 83       	std	Y+3, r25	; 0x03
    22ec:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    22ee:	0f b6       	in	r0, 0x3f	; 63
    22f0:	f8 94       	cli
    22f2:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    22f4:	ea 81       	ldd	r30, Y+2	; 0x02
    22f6:	fb 81       	ldd	r31, Y+3	; 0x03
    22f8:	82 8d       	ldd	r24, Z+26	; 0x1a
    22fa:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    22fc:	89 81       	ldd	r24, Y+1	; 0x01
    22fe:	88 23       	and	r24, r24
    2300:	f9 f0       	breq	.+62     	; 0x2340 <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2302:	8a 81       	ldd	r24, Y+2	; 0x02
    2304:	9b 81       	ldd	r25, Y+3	; 0x03
    2306:	2a 85       	ldd	r18, Y+10	; 0x0a
    2308:	3b 85       	ldd	r19, Y+11	; 0x0b
    230a:	b9 01       	movw	r22, r18
    230c:	0e 94 05 15 	call	0x2a0a	; 0x2a0a <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2310:	89 81       	ldd	r24, Y+1	; 0x01
    2312:	81 50       	subi	r24, 0x01	; 1
    2314:	ea 81       	ldd	r30, Y+2	; 0x02
    2316:	fb 81       	ldd	r31, Y+3	; 0x03
    2318:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    231a:	ea 81       	ldd	r30, Y+2	; 0x02
    231c:	fb 81       	ldd	r31, Y+3	; 0x03
    231e:	80 85       	ldd	r24, Z+8	; 0x08
    2320:	88 23       	and	r24, r24
    2322:	49 f0       	breq	.+18     	; 0x2336 <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2324:	8a 81       	ldd	r24, Y+2	; 0x02
    2326:	9b 81       	ldd	r25, Y+3	; 0x03
    2328:	08 96       	adiw	r24, 0x08	; 8
    232a:	0e 94 1c 20 	call	0x4038	; 0x4038 <xTaskRemoveFromEventList>
    232e:	88 23       	and	r24, r24
    2330:	11 f0       	breq	.+4      	; 0x2336 <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2332:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    2336:	0f 90       	pop	r0
    2338:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    233a:	81 e0       	ldi	r24, 0x01	; 1
    233c:	8e 87       	std	Y+14, r24	; 0x0e
    233e:	63 c0       	rjmp	.+198    	; 0x2406 <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2340:	8c 85       	ldd	r24, Y+12	; 0x0c
    2342:	9d 85       	ldd	r25, Y+13	; 0x0d
    2344:	00 97       	sbiw	r24, 0x00	; 0
    2346:	21 f4       	brne	.+8      	; 0x2350 <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2348:	0f 90       	pop	r0
    234a:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    234c:	1e 86       	std	Y+14, r1	; 0x0e
    234e:	5b c0       	rjmp	.+182    	; 0x2406 <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    2350:	8c 81       	ldd	r24, Y+4	; 0x04
    2352:	88 23       	and	r24, r24
    2354:	31 f4       	brne	.+12     	; 0x2362 <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2356:	ce 01       	movw	r24, r28
    2358:	05 96       	adiw	r24, 0x05	; 5
    235a:	0e 94 8c 22 	call	0x4518	; 0x4518 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    235e:	81 e0       	ldi	r24, 0x01	; 1
    2360:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2362:	0f 90       	pop	r0
    2364:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2366:	0e 94 56 1b 	call	0x36ac	; 0x36ac <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    236a:	0f b6       	in	r0, 0x3f	; 63
    236c:	f8 94       	cli
    236e:	0f 92       	push	r0
    2370:	ea 81       	ldd	r30, Y+2	; 0x02
    2372:	fb 81       	ldd	r31, Y+3	; 0x03
    2374:	85 8d       	ldd	r24, Z+29	; 0x1d
    2376:	8f 3f       	cpi	r24, 0xFF	; 255
    2378:	19 f4       	brne	.+6      	; 0x2380 <xQueueReceive+0xbc>
    237a:	ea 81       	ldd	r30, Y+2	; 0x02
    237c:	fb 81       	ldd	r31, Y+3	; 0x03
    237e:	15 8e       	std	Z+29, r1	; 0x1d
    2380:	ea 81       	ldd	r30, Y+2	; 0x02
    2382:	fb 81       	ldd	r31, Y+3	; 0x03
    2384:	86 8d       	ldd	r24, Z+30	; 0x1e
    2386:	8f 3f       	cpi	r24, 0xFF	; 255
    2388:	19 f4       	brne	.+6      	; 0x2390 <xQueueReceive+0xcc>
    238a:	ea 81       	ldd	r30, Y+2	; 0x02
    238c:	fb 81       	ldd	r31, Y+3	; 0x03
    238e:	16 8e       	std	Z+30, r1	; 0x1e
    2390:	0f 90       	pop	r0
    2392:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2394:	ce 01       	movw	r24, r28
    2396:	05 96       	adiw	r24, 0x05	; 5
    2398:	9e 01       	movw	r18, r28
    239a:	24 5f       	subi	r18, 0xF4	; 244
    239c:	3f 4f       	sbci	r19, 0xFF	; 255
    239e:	b9 01       	movw	r22, r18
    23a0:	0e 94 a5 22 	call	0x454a	; 0x454a <xTaskCheckForTimeOut>
    23a4:	88 23       	and	r24, r24
    23a6:	09 f5       	brne	.+66     	; 0x23ea <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    23a8:	8a 81       	ldd	r24, Y+2	; 0x02
    23aa:	9b 81       	ldd	r25, Y+3	; 0x03
    23ac:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <prvIsQueueEmpty>
    23b0:	88 23       	and	r24, r24
    23b2:	a1 f0       	breq	.+40     	; 0x23dc <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    23b4:	8a 81       	ldd	r24, Y+2	; 0x02
    23b6:	9b 81       	ldd	r25, Y+3	; 0x03
    23b8:	41 96       	adiw	r24, 0x11	; 17
    23ba:	2c 85       	ldd	r18, Y+12	; 0x0c
    23bc:	3d 85       	ldd	r19, Y+13	; 0x0d
    23be:	b9 01       	movw	r22, r18
    23c0:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    23c4:	8a 81       	ldd	r24, Y+2	; 0x02
    23c6:	9b 81       	ldd	r25, Y+3	; 0x03
    23c8:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    23cc:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>
    23d0:	88 23       	and	r24, r24
    23d2:	09 f0       	breq	.+2      	; 0x23d6 <xQueueReceive+0x112>
    23d4:	8c cf       	rjmp	.-232    	; 0x22ee <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    23d6:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    23da:	89 cf       	rjmp	.-238    	; 0x22ee <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    23dc:	8a 81       	ldd	r24, Y+2	; 0x02
    23de:	9b 81       	ldd	r25, Y+3	; 0x03
    23e0:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    23e4:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>
    23e8:	82 cf       	rjmp	.-252    	; 0x22ee <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    23ea:	8a 81       	ldd	r24, Y+2	; 0x02
    23ec:	9b 81       	ldd	r25, Y+3	; 0x03
    23ee:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    23f2:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    23f6:	8a 81       	ldd	r24, Y+2	; 0x02
    23f8:	9b 81       	ldd	r25, Y+3	; 0x03
    23fa:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <prvIsQueueEmpty>
    23fe:	88 23       	and	r24, r24
    2400:	09 f4       	brne	.+2      	; 0x2404 <xQueueReceive+0x140>
    2402:	75 cf       	rjmp	.-278    	; 0x22ee <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2404:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    2406:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    2408:	2e 96       	adiw	r28, 0x0e	; 14
    240a:	0f b6       	in	r0, 0x3f	; 63
    240c:	f8 94       	cli
    240e:	de bf       	out	0x3e, r29	; 62
    2410:	0f be       	out	0x3f, r0	; 63
    2412:	cd bf       	out	0x3d, r28	; 61
    2414:	cf 91       	pop	r28
    2416:	df 91       	pop	r29
    2418:	08 95       	ret

0000241a <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    241a:	df 93       	push	r29
    241c:	cf 93       	push	r28
    241e:	cd b7       	in	r28, 0x3d	; 61
    2420:	de b7       	in	r29, 0x3e	; 62
    2422:	2c 97       	sbiw	r28, 0x0c	; 12
    2424:	0f b6       	in	r0, 0x3f	; 63
    2426:	f8 94       	cli
    2428:	de bf       	out	0x3e, r29	; 62
    242a:	0f be       	out	0x3f, r0	; 63
    242c:	cd bf       	out	0x3d, r28	; 61
    242e:	99 87       	std	Y+9, r25	; 0x09
    2430:	88 87       	std	Y+8, r24	; 0x08
    2432:	7b 87       	std	Y+11, r23	; 0x0b
    2434:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    2436:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    2438:	88 85       	ldd	r24, Y+8	; 0x08
    243a:	99 85       	ldd	r25, Y+9	; 0x09
    243c:	9b 83       	std	Y+3, r25	; 0x03
    243e:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2440:	0f b6       	in	r0, 0x3f	; 63
    2442:	f8 94       	cli
    2444:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2446:	ea 81       	ldd	r30, Y+2	; 0x02
    2448:	fb 81       	ldd	r31, Y+3	; 0x03
    244a:	82 8d       	ldd	r24, Z+26	; 0x1a
    244c:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    244e:	89 81       	ldd	r24, Y+1	; 0x01
    2450:	88 23       	and	r24, r24
    2452:	c1 f0       	breq	.+48     	; 0x2484 <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2454:	89 81       	ldd	r24, Y+1	; 0x01
    2456:	81 50       	subi	r24, 0x01	; 1
    2458:	ea 81       	ldd	r30, Y+2	; 0x02
    245a:	fb 81       	ldd	r31, Y+3	; 0x03
    245c:	82 8f       	std	Z+26, r24	; 0x1a
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    245e:	ea 81       	ldd	r30, Y+2	; 0x02
    2460:	fb 81       	ldd	r31, Y+3	; 0x03
    2462:	80 85       	ldd	r24, Z+8	; 0x08
    2464:	88 23       	and	r24, r24
    2466:	49 f0       	breq	.+18     	; 0x247a <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2468:	8a 81       	ldd	r24, Y+2	; 0x02
    246a:	9b 81       	ldd	r25, Y+3	; 0x03
    246c:	08 96       	adiw	r24, 0x08	; 8
    246e:	0e 94 1c 20 	call	0x4038	; 0x4038 <xTaskRemoveFromEventList>
    2472:	88 23       	and	r24, r24
    2474:	11 f0       	breq	.+4      	; 0x247a <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2476:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    247a:	0f 90       	pop	r0
    247c:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    247e:	81 e0       	ldi	r24, 0x01	; 1
    2480:	8c 87       	std	Y+12, r24	; 0x0c
    2482:	63 c0       	rjmp	.+198    	; 0x254a <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2484:	8a 85       	ldd	r24, Y+10	; 0x0a
    2486:	9b 85       	ldd	r25, Y+11	; 0x0b
    2488:	00 97       	sbiw	r24, 0x00	; 0
    248a:	21 f4       	brne	.+8      	; 0x2494 <xQueueSemaphoreTake+0x7a>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    248c:	0f 90       	pop	r0
    248e:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    2490:	1c 86       	std	Y+12, r1	; 0x0c
    2492:	5b c0       	rjmp	.+182    	; 0x254a <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    2494:	8c 81       	ldd	r24, Y+4	; 0x04
    2496:	88 23       	and	r24, r24
    2498:	31 f4       	brne	.+12     	; 0x24a6 <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    249a:	ce 01       	movw	r24, r28
    249c:	05 96       	adiw	r24, 0x05	; 5
    249e:	0e 94 8c 22 	call	0x4518	; 0x4518 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    24a2:	81 e0       	ldi	r24, 0x01	; 1
    24a4:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    24a6:	0f 90       	pop	r0
    24a8:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    24aa:	0e 94 56 1b 	call	0x36ac	; 0x36ac <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    24ae:	0f b6       	in	r0, 0x3f	; 63
    24b0:	f8 94       	cli
    24b2:	0f 92       	push	r0
    24b4:	ea 81       	ldd	r30, Y+2	; 0x02
    24b6:	fb 81       	ldd	r31, Y+3	; 0x03
    24b8:	85 8d       	ldd	r24, Z+29	; 0x1d
    24ba:	8f 3f       	cpi	r24, 0xFF	; 255
    24bc:	19 f4       	brne	.+6      	; 0x24c4 <xQueueSemaphoreTake+0xaa>
    24be:	ea 81       	ldd	r30, Y+2	; 0x02
    24c0:	fb 81       	ldd	r31, Y+3	; 0x03
    24c2:	15 8e       	std	Z+29, r1	; 0x1d
    24c4:	ea 81       	ldd	r30, Y+2	; 0x02
    24c6:	fb 81       	ldd	r31, Y+3	; 0x03
    24c8:	86 8d       	ldd	r24, Z+30	; 0x1e
    24ca:	8f 3f       	cpi	r24, 0xFF	; 255
    24cc:	19 f4       	brne	.+6      	; 0x24d4 <xQueueSemaphoreTake+0xba>
    24ce:	ea 81       	ldd	r30, Y+2	; 0x02
    24d0:	fb 81       	ldd	r31, Y+3	; 0x03
    24d2:	16 8e       	std	Z+30, r1	; 0x1e
    24d4:	0f 90       	pop	r0
    24d6:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    24d8:	ce 01       	movw	r24, r28
    24da:	05 96       	adiw	r24, 0x05	; 5
    24dc:	9e 01       	movw	r18, r28
    24de:	26 5f       	subi	r18, 0xF6	; 246
    24e0:	3f 4f       	sbci	r19, 0xFF	; 255
    24e2:	b9 01       	movw	r22, r18
    24e4:	0e 94 a5 22 	call	0x454a	; 0x454a <xTaskCheckForTimeOut>
    24e8:	88 23       	and	r24, r24
    24ea:	09 f5       	brne	.+66     	; 0x252e <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    24ec:	8a 81       	ldd	r24, Y+2	; 0x02
    24ee:	9b 81       	ldd	r25, Y+3	; 0x03
    24f0:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <prvIsQueueEmpty>
    24f4:	88 23       	and	r24, r24
    24f6:	a1 f0       	breq	.+40     	; 0x2520 <xQueueSemaphoreTake+0x106>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    24f8:	8a 81       	ldd	r24, Y+2	; 0x02
    24fa:	9b 81       	ldd	r25, Y+3	; 0x03
    24fc:	41 96       	adiw	r24, 0x11	; 17
    24fe:	2a 85       	ldd	r18, Y+10	; 0x0a
    2500:	3b 85       	ldd	r19, Y+11	; 0x0b
    2502:	b9 01       	movw	r22, r18
    2504:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    2508:	8a 81       	ldd	r24, Y+2	; 0x02
    250a:	9b 81       	ldd	r25, Y+3	; 0x03
    250c:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2510:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>
    2514:	88 23       	and	r24, r24
    2516:	09 f0       	breq	.+2      	; 0x251a <xQueueSemaphoreTake+0x100>
    2518:	93 cf       	rjmp	.-218    	; 0x2440 <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    251a:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    251e:	90 cf       	rjmp	.-224    	; 0x2440 <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    2520:	8a 81       	ldd	r24, Y+2	; 0x02
    2522:	9b 81       	ldd	r25, Y+3	; 0x03
    2524:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2528:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>
    252c:	89 cf       	rjmp	.-238    	; 0x2440 <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    252e:	8a 81       	ldd	r24, Y+2	; 0x02
    2530:	9b 81       	ldd	r25, Y+3	; 0x03
    2532:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2536:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    253a:	8a 81       	ldd	r24, Y+2	; 0x02
    253c:	9b 81       	ldd	r25, Y+3	; 0x03
    253e:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <prvIsQueueEmpty>
    2542:	88 23       	and	r24, r24
    2544:	09 f4       	brne	.+2      	; 0x2548 <xQueueSemaphoreTake+0x12e>
    2546:	7c cf       	rjmp	.-264    	; 0x2440 <xQueueSemaphoreTake+0x26>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    2548:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    254a:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    254c:	2c 96       	adiw	r28, 0x0c	; 12
    254e:	0f b6       	in	r0, 0x3f	; 63
    2550:	f8 94       	cli
    2552:	de bf       	out	0x3e, r29	; 62
    2554:	0f be       	out	0x3f, r0	; 63
    2556:	cd bf       	out	0x3d, r28	; 61
    2558:	cf 91       	pop	r28
    255a:	df 91       	pop	r29
    255c:	08 95       	ret

0000255e <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    255e:	df 93       	push	r29
    2560:	cf 93       	push	r28
    2562:	cd b7       	in	r28, 0x3d	; 61
    2564:	de b7       	in	r29, 0x3e	; 62
    2566:	60 97       	sbiw	r28, 0x10	; 16
    2568:	0f b6       	in	r0, 0x3f	; 63
    256a:	f8 94       	cli
    256c:	de bf       	out	0x3e, r29	; 62
    256e:	0f be       	out	0x3f, r0	; 63
    2570:	cd bf       	out	0x3d, r28	; 61
    2572:	9b 87       	std	Y+11, r25	; 0x0b
    2574:	8a 87       	std	Y+10, r24	; 0x0a
    2576:	7d 87       	std	Y+13, r23	; 0x0d
    2578:	6c 87       	std	Y+12, r22	; 0x0c
    257a:	5f 87       	std	Y+15, r21	; 0x0f
    257c:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    257e:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    2580:	8a 85       	ldd	r24, Y+10	; 0x0a
    2582:	9b 85       	ldd	r25, Y+11	; 0x0b
    2584:	9b 83       	std	Y+3, r25	; 0x03
    2586:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2588:	0f b6       	in	r0, 0x3f	; 63
    258a:	f8 94       	cli
    258c:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    258e:	ea 81       	ldd	r30, Y+2	; 0x02
    2590:	fb 81       	ldd	r31, Y+3	; 0x03
    2592:	82 8d       	ldd	r24, Z+26	; 0x1a
    2594:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2596:	89 81       	ldd	r24, Y+1	; 0x01
    2598:	88 23       	and	r24, r24
    259a:	31 f1       	breq	.+76     	; 0x25e8 <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    259c:	ea 81       	ldd	r30, Y+2	; 0x02
    259e:	fb 81       	ldd	r31, Y+3	; 0x03
    25a0:	86 81       	ldd	r24, Z+6	; 0x06
    25a2:	97 81       	ldd	r25, Z+7	; 0x07
    25a4:	9d 83       	std	Y+5, r25	; 0x05
    25a6:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    25a8:	8a 81       	ldd	r24, Y+2	; 0x02
    25aa:	9b 81       	ldd	r25, Y+3	; 0x03
    25ac:	2c 85       	ldd	r18, Y+12	; 0x0c
    25ae:	3d 85       	ldd	r19, Y+13	; 0x0d
    25b0:	b9 01       	movw	r22, r18
    25b2:	0e 94 05 15 	call	0x2a0a	; 0x2a0a <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    25b6:	ea 81       	ldd	r30, Y+2	; 0x02
    25b8:	fb 81       	ldd	r31, Y+3	; 0x03
    25ba:	8c 81       	ldd	r24, Y+4	; 0x04
    25bc:	9d 81       	ldd	r25, Y+5	; 0x05
    25be:	97 83       	std	Z+7, r25	; 0x07
    25c0:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    25c2:	ea 81       	ldd	r30, Y+2	; 0x02
    25c4:	fb 81       	ldd	r31, Y+3	; 0x03
    25c6:	81 89       	ldd	r24, Z+17	; 0x11
    25c8:	88 23       	and	r24, r24
    25ca:	49 f0       	breq	.+18     	; 0x25de <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    25cc:	8a 81       	ldd	r24, Y+2	; 0x02
    25ce:	9b 81       	ldd	r25, Y+3	; 0x03
    25d0:	41 96       	adiw	r24, 0x11	; 17
    25d2:	0e 94 1c 20 	call	0x4038	; 0x4038 <xTaskRemoveFromEventList>
    25d6:	88 23       	and	r24, r24
    25d8:	11 f0       	breq	.+4      	; 0x25de <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    25da:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    25de:	0f 90       	pop	r0
    25e0:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    25e2:	81 e0       	ldi	r24, 0x01	; 1
    25e4:	88 8b       	std	Y+16, r24	; 0x10
    25e6:	63 c0       	rjmp	.+198    	; 0x26ae <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    25e8:	8e 85       	ldd	r24, Y+14	; 0x0e
    25ea:	9f 85       	ldd	r25, Y+15	; 0x0f
    25ec:	00 97       	sbiw	r24, 0x00	; 0
    25ee:	21 f4       	brne	.+8      	; 0x25f8 <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    25f0:	0f 90       	pop	r0
    25f2:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    25f4:	18 8a       	std	Y+16, r1	; 0x10
    25f6:	5b c0       	rjmp	.+182    	; 0x26ae <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    25f8:	8e 81       	ldd	r24, Y+6	; 0x06
    25fa:	88 23       	and	r24, r24
    25fc:	31 f4       	brne	.+12     	; 0x260a <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    25fe:	ce 01       	movw	r24, r28
    2600:	07 96       	adiw	r24, 0x07	; 7
    2602:	0e 94 8c 22 	call	0x4518	; 0x4518 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    2606:	81 e0       	ldi	r24, 0x01	; 1
    2608:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    260a:	0f 90       	pop	r0
    260c:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    260e:	0e 94 56 1b 	call	0x36ac	; 0x36ac <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2612:	0f b6       	in	r0, 0x3f	; 63
    2614:	f8 94       	cli
    2616:	0f 92       	push	r0
    2618:	ea 81       	ldd	r30, Y+2	; 0x02
    261a:	fb 81       	ldd	r31, Y+3	; 0x03
    261c:	85 8d       	ldd	r24, Z+29	; 0x1d
    261e:	8f 3f       	cpi	r24, 0xFF	; 255
    2620:	19 f4       	brne	.+6      	; 0x2628 <xQueuePeek+0xca>
    2622:	ea 81       	ldd	r30, Y+2	; 0x02
    2624:	fb 81       	ldd	r31, Y+3	; 0x03
    2626:	15 8e       	std	Z+29, r1	; 0x1d
    2628:	ea 81       	ldd	r30, Y+2	; 0x02
    262a:	fb 81       	ldd	r31, Y+3	; 0x03
    262c:	86 8d       	ldd	r24, Z+30	; 0x1e
    262e:	8f 3f       	cpi	r24, 0xFF	; 255
    2630:	19 f4       	brne	.+6      	; 0x2638 <xQueuePeek+0xda>
    2632:	ea 81       	ldd	r30, Y+2	; 0x02
    2634:	fb 81       	ldd	r31, Y+3	; 0x03
    2636:	16 8e       	std	Z+30, r1	; 0x1e
    2638:	0f 90       	pop	r0
    263a:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    263c:	ce 01       	movw	r24, r28
    263e:	07 96       	adiw	r24, 0x07	; 7
    2640:	9e 01       	movw	r18, r28
    2642:	22 5f       	subi	r18, 0xF2	; 242
    2644:	3f 4f       	sbci	r19, 0xFF	; 255
    2646:	b9 01       	movw	r22, r18
    2648:	0e 94 a5 22 	call	0x454a	; 0x454a <xTaskCheckForTimeOut>
    264c:	88 23       	and	r24, r24
    264e:	09 f5       	brne	.+66     	; 0x2692 <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2650:	8a 81       	ldd	r24, Y+2	; 0x02
    2652:	9b 81       	ldd	r25, Y+3	; 0x03
    2654:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <prvIsQueueEmpty>
    2658:	88 23       	and	r24, r24
    265a:	a1 f0       	breq	.+40     	; 0x2684 <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    265c:	8a 81       	ldd	r24, Y+2	; 0x02
    265e:	9b 81       	ldd	r25, Y+3	; 0x03
    2660:	41 96       	adiw	r24, 0x11	; 17
    2662:	2e 85       	ldd	r18, Y+14	; 0x0e
    2664:	3f 85       	ldd	r19, Y+15	; 0x0f
    2666:	b9 01       	movw	r22, r18
    2668:	0e 94 33 1f 	call	0x3e66	; 0x3e66 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    266c:	8a 81       	ldd	r24, Y+2	; 0x02
    266e:	9b 81       	ldd	r25, Y+3	; 0x03
    2670:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2674:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>
    2678:	88 23       	and	r24, r24
    267a:	09 f0       	breq	.+2      	; 0x267e <xQueuePeek+0x120>
    267c:	85 cf       	rjmp	.-246    	; 0x2588 <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    267e:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    2682:	82 cf       	rjmp	.-252    	; 0x2588 <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    2684:	8a 81       	ldd	r24, Y+2	; 0x02
    2686:	9b 81       	ldd	r25, Y+3	; 0x03
    2688:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    268c:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>
    2690:	7b cf       	rjmp	.-266    	; 0x2588 <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    2692:	8a 81       	ldd	r24, Y+2	; 0x02
    2694:	9b 81       	ldd	r25, Y+3	; 0x03
    2696:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    269a:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    269e:	8a 81       	ldd	r24, Y+2	; 0x02
    26a0:	9b 81       	ldd	r25, Y+3	; 0x03
    26a2:	0e 94 9f 15 	call	0x2b3e	; 0x2b3e <prvIsQueueEmpty>
    26a6:	88 23       	and	r24, r24
    26a8:	09 f4       	brne	.+2      	; 0x26ac <xQueuePeek+0x14e>
    26aa:	6e cf       	rjmp	.-292    	; 0x2588 <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    26ac:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    26ae:	88 89       	ldd	r24, Y+16	; 0x10
}
    26b0:	60 96       	adiw	r28, 0x10	; 16
    26b2:	0f b6       	in	r0, 0x3f	; 63
    26b4:	f8 94       	cli
    26b6:	de bf       	out	0x3e, r29	; 62
    26b8:	0f be       	out	0x3f, r0	; 63
    26ba:	cd bf       	out	0x3d, r28	; 61
    26bc:	cf 91       	pop	r28
    26be:	df 91       	pop	r29
    26c0:	08 95       	ret

000026c2 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    26c2:	df 93       	push	r29
    26c4:	cf 93       	push	r28
    26c6:	cd b7       	in	r28, 0x3d	; 61
    26c8:	de b7       	in	r29, 0x3e	; 62
    26ca:	2c 97       	sbiw	r28, 0x0c	; 12
    26cc:	0f b6       	in	r0, 0x3f	; 63
    26ce:	f8 94       	cli
    26d0:	de bf       	out	0x3e, r29	; 62
    26d2:	0f be       	out	0x3f, r0	; 63
    26d4:	cd bf       	out	0x3d, r28	; 61
    26d6:	98 87       	std	Y+8, r25	; 0x08
    26d8:	8f 83       	std	Y+7, r24	; 0x07
    26da:	7a 87       	std	Y+10, r23	; 0x0a
    26dc:	69 87       	std	Y+9, r22	; 0x09
    26de:	5c 87       	std	Y+12, r21	; 0x0c
    26e0:	4b 87       	std	Y+11, r20	; 0x0b
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    26e2:	8f 81       	ldd	r24, Y+7	; 0x07
    26e4:	98 85       	ldd	r25, Y+8	; 0x08
    26e6:	9c 83       	std	Y+4, r25	; 0x04
    26e8:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    26ea:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    26ec:	eb 81       	ldd	r30, Y+3	; 0x03
    26ee:	fc 81       	ldd	r31, Y+4	; 0x04
    26f0:	82 8d       	ldd	r24, Z+26	; 0x1a
    26f2:	8a 83       	std	Y+2, r24	; 0x02

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    26f4:	8a 81       	ldd	r24, Y+2	; 0x02
    26f6:	88 23       	and	r24, r24
    26f8:	81 f1       	breq	.+96     	; 0x275a <xQueueReceiveFromISR+0x98>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    26fa:	eb 81       	ldd	r30, Y+3	; 0x03
    26fc:	fc 81       	ldd	r31, Y+4	; 0x04
    26fe:	85 8d       	ldd	r24, Z+29	; 0x1d
    2700:	89 83       	std	Y+1, r24	; 0x01

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2702:	8b 81       	ldd	r24, Y+3	; 0x03
    2704:	9c 81       	ldd	r25, Y+4	; 0x04
    2706:	29 85       	ldd	r18, Y+9	; 0x09
    2708:	3a 85       	ldd	r19, Y+10	; 0x0a
    270a:	b9 01       	movw	r22, r18
    270c:	0e 94 05 15 	call	0x2a0a	; 0x2a0a <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    2710:	8a 81       	ldd	r24, Y+2	; 0x02
    2712:	81 50       	subi	r24, 0x01	; 1
    2714:	eb 81       	ldd	r30, Y+3	; 0x03
    2716:	fc 81       	ldd	r31, Y+4	; 0x04
    2718:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    271a:	89 81       	ldd	r24, Y+1	; 0x01
    271c:	8f 3f       	cpi	r24, 0xFF	; 255
    271e:	a9 f4       	brne	.+42     	; 0x274a <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2720:	eb 81       	ldd	r30, Y+3	; 0x03
    2722:	fc 81       	ldd	r31, Y+4	; 0x04
    2724:	80 85       	ldd	r24, Z+8	; 0x08
    2726:	88 23       	and	r24, r24
    2728:	a9 f0       	breq	.+42     	; 0x2754 <xQueueReceiveFromISR+0x92>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    272a:	8b 81       	ldd	r24, Y+3	; 0x03
    272c:	9c 81       	ldd	r25, Y+4	; 0x04
    272e:	08 96       	adiw	r24, 0x08	; 8
    2730:	0e 94 1c 20 	call	0x4038	; 0x4038 <xTaskRemoveFromEventList>
    2734:	88 23       	and	r24, r24
    2736:	71 f0       	breq	.+28     	; 0x2754 <xQueueReceiveFromISR+0x92>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    2738:	8b 85       	ldd	r24, Y+11	; 0x0b
    273a:	9c 85       	ldd	r25, Y+12	; 0x0c
    273c:	00 97       	sbiw	r24, 0x00	; 0
    273e:	51 f0       	breq	.+20     	; 0x2754 <xQueueReceiveFromISR+0x92>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    2740:	eb 85       	ldd	r30, Y+11	; 0x0b
    2742:	fc 85       	ldd	r31, Y+12	; 0x0c
    2744:	81 e0       	ldi	r24, 0x01	; 1
    2746:	80 83       	st	Z, r24
    2748:	05 c0       	rjmp	.+10     	; 0x2754 <xQueueReceiveFromISR+0x92>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    274a:	89 81       	ldd	r24, Y+1	; 0x01
    274c:	8f 5f       	subi	r24, 0xFF	; 255
    274e:	eb 81       	ldd	r30, Y+3	; 0x03
    2750:	fc 81       	ldd	r31, Y+4	; 0x04
    2752:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    2754:	81 e0       	ldi	r24, 0x01	; 1
    2756:	8e 83       	std	Y+6, r24	; 0x06
    2758:	01 c0       	rjmp	.+2      	; 0x275c <xQueueReceiveFromISR+0x9a>
        }
        else
        {
            xReturn = pdFAIL;
    275a:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    275c:	8e 81       	ldd	r24, Y+6	; 0x06
}
    275e:	2c 96       	adiw	r28, 0x0c	; 12
    2760:	0f b6       	in	r0, 0x3f	; 63
    2762:	f8 94       	cli
    2764:	de bf       	out	0x3e, r29	; 62
    2766:	0f be       	out	0x3f, r0	; 63
    2768:	cd bf       	out	0x3d, r28	; 61
    276a:	cf 91       	pop	r28
    276c:	df 91       	pop	r29
    276e:	08 95       	ret

00002770 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    2770:	df 93       	push	r29
    2772:	cf 93       	push	r28
    2774:	cd b7       	in	r28, 0x3d	; 61
    2776:	de b7       	in	r29, 0x3e	; 62
    2778:	2a 97       	sbiw	r28, 0x0a	; 10
    277a:	0f b6       	in	r0, 0x3f	; 63
    277c:	f8 94       	cli
    277e:	de bf       	out	0x3e, r29	; 62
    2780:	0f be       	out	0x3f, r0	; 63
    2782:	cd bf       	out	0x3d, r28	; 61
    2784:	98 87       	std	Y+8, r25	; 0x08
    2786:	8f 83       	std	Y+7, r24	; 0x07
    2788:	7a 87       	std	Y+10, r23	; 0x0a
    278a:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    278c:	8f 81       	ldd	r24, Y+7	; 0x07
    278e:	98 85       	ldd	r25, Y+8	; 0x08
    2790:	9a 83       	std	Y+2, r25	; 0x02
    2792:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2794:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2796:	e9 81       	ldd	r30, Y+1	; 0x01
    2798:	fa 81       	ldd	r31, Y+2	; 0x02
    279a:	82 8d       	ldd	r24, Z+26	; 0x1a
    279c:	88 23       	and	r24, r24
    279e:	b1 f0       	breq	.+44     	; 0x27cc <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    27a0:	e9 81       	ldd	r30, Y+1	; 0x01
    27a2:	fa 81       	ldd	r31, Y+2	; 0x02
    27a4:	86 81       	ldd	r24, Z+6	; 0x06
    27a6:	97 81       	ldd	r25, Z+7	; 0x07
    27a8:	9c 83       	std	Y+4, r25	; 0x04
    27aa:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    27ac:	89 81       	ldd	r24, Y+1	; 0x01
    27ae:	9a 81       	ldd	r25, Y+2	; 0x02
    27b0:	29 85       	ldd	r18, Y+9	; 0x09
    27b2:	3a 85       	ldd	r19, Y+10	; 0x0a
    27b4:	b9 01       	movw	r22, r18
    27b6:	0e 94 05 15 	call	0x2a0a	; 0x2a0a <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    27ba:	e9 81       	ldd	r30, Y+1	; 0x01
    27bc:	fa 81       	ldd	r31, Y+2	; 0x02
    27be:	8b 81       	ldd	r24, Y+3	; 0x03
    27c0:	9c 81       	ldd	r25, Y+4	; 0x04
    27c2:	97 83       	std	Z+7, r25	; 0x07
    27c4:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    27c6:	81 e0       	ldi	r24, 0x01	; 1
    27c8:	8e 83       	std	Y+6, r24	; 0x06
    27ca:	01 c0       	rjmp	.+2      	; 0x27ce <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    27cc:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    27ce:	8e 81       	ldd	r24, Y+6	; 0x06
}
    27d0:	2a 96       	adiw	r28, 0x0a	; 10
    27d2:	0f b6       	in	r0, 0x3f	; 63
    27d4:	f8 94       	cli
    27d6:	de bf       	out	0x3e, r29	; 62
    27d8:	0f be       	out	0x3f, r0	; 63
    27da:	cd bf       	out	0x3d, r28	; 61
    27dc:	cf 91       	pop	r28
    27de:	df 91       	pop	r29
    27e0:	08 95       	ret

000027e2 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    27e2:	df 93       	push	r29
    27e4:	cf 93       	push	r28
    27e6:	00 d0       	rcall	.+0      	; 0x27e8 <uxQueueMessagesWaiting+0x6>
    27e8:	0f 92       	push	r0
    27ea:	cd b7       	in	r28, 0x3d	; 61
    27ec:	de b7       	in	r29, 0x3e	; 62
    27ee:	9b 83       	std	Y+3, r25	; 0x03
    27f0:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    27f2:	0f b6       	in	r0, 0x3f	; 63
    27f4:	f8 94       	cli
    27f6:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    27f8:	ea 81       	ldd	r30, Y+2	; 0x02
    27fa:	fb 81       	ldd	r31, Y+3	; 0x03
    27fc:	82 8d       	ldd	r24, Z+26	; 0x1a
    27fe:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    2800:	0f 90       	pop	r0
    2802:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2804:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2806:	0f 90       	pop	r0
    2808:	0f 90       	pop	r0
    280a:	0f 90       	pop	r0
    280c:	cf 91       	pop	r28
    280e:	df 91       	pop	r29
    2810:	08 95       	ret

00002812 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2812:	df 93       	push	r29
    2814:	cf 93       	push	r28
    2816:	00 d0       	rcall	.+0      	; 0x2818 <uxQueueSpacesAvailable+0x6>
    2818:	00 d0       	rcall	.+0      	; 0x281a <uxQueueSpacesAvailable+0x8>
    281a:	0f 92       	push	r0
    281c:	cd b7       	in	r28, 0x3d	; 61
    281e:	de b7       	in	r29, 0x3e	; 62
    2820:	9d 83       	std	Y+5, r25	; 0x05
    2822:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    2824:	8c 81       	ldd	r24, Y+4	; 0x04
    2826:	9d 81       	ldd	r25, Y+5	; 0x05
    2828:	9a 83       	std	Y+2, r25	; 0x02
    282a:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    282c:	0f b6       	in	r0, 0x3f	; 63
    282e:	f8 94       	cli
    2830:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2832:	e9 81       	ldd	r30, Y+1	; 0x01
    2834:	fa 81       	ldd	r31, Y+2	; 0x02
    2836:	93 8d       	ldd	r25, Z+27	; 0x1b
    2838:	e9 81       	ldd	r30, Y+1	; 0x01
    283a:	fa 81       	ldd	r31, Y+2	; 0x02
    283c:	82 8d       	ldd	r24, Z+26	; 0x1a
    283e:	29 2f       	mov	r18, r25
    2840:	28 1b       	sub	r18, r24
    2842:	82 2f       	mov	r24, r18
    2844:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    2846:	0f 90       	pop	r0
    2848:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    284a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    284c:	0f 90       	pop	r0
    284e:	0f 90       	pop	r0
    2850:	0f 90       	pop	r0
    2852:	0f 90       	pop	r0
    2854:	0f 90       	pop	r0
    2856:	cf 91       	pop	r28
    2858:	df 91       	pop	r29
    285a:	08 95       	ret

0000285c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    285c:	df 93       	push	r29
    285e:	cf 93       	push	r28
    2860:	00 d0       	rcall	.+0      	; 0x2862 <uxQueueMessagesWaitingFromISR+0x6>
    2862:	00 d0       	rcall	.+0      	; 0x2864 <uxQueueMessagesWaitingFromISR+0x8>
    2864:	0f 92       	push	r0
    2866:	cd b7       	in	r28, 0x3d	; 61
    2868:	de b7       	in	r29, 0x3e	; 62
    286a:	9d 83       	std	Y+5, r25	; 0x05
    286c:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    286e:	8c 81       	ldd	r24, Y+4	; 0x04
    2870:	9d 81       	ldd	r25, Y+5	; 0x05
    2872:	9a 83       	std	Y+2, r25	; 0x02
    2874:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    2876:	e9 81       	ldd	r30, Y+1	; 0x01
    2878:	fa 81       	ldd	r31, Y+2	; 0x02
    287a:	82 8d       	ldd	r24, Z+26	; 0x1a
    287c:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    287e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2880:	0f 90       	pop	r0
    2882:	0f 90       	pop	r0
    2884:	0f 90       	pop	r0
    2886:	0f 90       	pop	r0
    2888:	0f 90       	pop	r0
    288a:	cf 91       	pop	r28
    288c:	df 91       	pop	r29
    288e:	08 95       	ret

00002890 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2890:	df 93       	push	r29
    2892:	cf 93       	push	r28
    2894:	00 d0       	rcall	.+0      	; 0x2896 <vQueueDelete+0x6>
    2896:	00 d0       	rcall	.+0      	; 0x2898 <vQueueDelete+0x8>
    2898:	cd b7       	in	r28, 0x3d	; 61
    289a:	de b7       	in	r29, 0x3e	; 62
    289c:	9c 83       	std	Y+4, r25	; 0x04
    289e:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    28a0:	8b 81       	ldd	r24, Y+3	; 0x03
    28a2:	9c 81       	ldd	r25, Y+4	; 0x04
    28a4:	9a 83       	std	Y+2, r25	; 0x02
    28a6:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    28a8:	89 81       	ldd	r24, Y+1	; 0x01
    28aa:	9a 81       	ldd	r25, Y+2	; 0x02
    28ac:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    28b0:	0f 90       	pop	r0
    28b2:	0f 90       	pop	r0
    28b4:	0f 90       	pop	r0
    28b6:	0f 90       	pop	r0
    28b8:	cf 91       	pop	r28
    28ba:	df 91       	pop	r29
    28bc:	08 95       	ret

000028be <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    28be:	df 93       	push	r29
    28c0:	cf 93       	push	r28
    28c2:	cd b7       	in	r28, 0x3d	; 61
    28c4:	de b7       	in	r29, 0x3e	; 62
    28c6:	27 97       	sbiw	r28, 0x07	; 7
    28c8:	0f b6       	in	r0, 0x3f	; 63
    28ca:	f8 94       	cli
    28cc:	de bf       	out	0x3e, r29	; 62
    28ce:	0f be       	out	0x3f, r0	; 63
    28d0:	cd bf       	out	0x3d, r28	; 61
    28d2:	9c 83       	std	Y+4, r25	; 0x04
    28d4:	8b 83       	std	Y+3, r24	; 0x03
    28d6:	7e 83       	std	Y+6, r23	; 0x06
    28d8:	6d 83       	std	Y+5, r22	; 0x05
    28da:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    28dc:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    28de:	eb 81       	ldd	r30, Y+3	; 0x03
    28e0:	fc 81       	ldd	r31, Y+4	; 0x04
    28e2:	82 8d       	ldd	r24, Z+26	; 0x1a
    28e4:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    28e6:	eb 81       	ldd	r30, Y+3	; 0x03
    28e8:	fc 81       	ldd	r31, Y+4	; 0x04
    28ea:	84 8d       	ldd	r24, Z+28	; 0x1c
    28ec:	88 23       	and	r24, r24
    28ee:	09 f4       	brne	.+2      	; 0x28f2 <prvCopyDataToQueue+0x34>
    28f0:	7d c0       	rjmp	.+250    	; 0x29ec <prvCopyDataToQueue+0x12e>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    28f2:	8f 81       	ldd	r24, Y+7	; 0x07
    28f4:	88 23       	and	r24, r24
    28f6:	99 f5       	brne	.+102    	; 0x295e <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    28f8:	eb 81       	ldd	r30, Y+3	; 0x03
    28fa:	fc 81       	ldd	r31, Y+4	; 0x04
    28fc:	62 81       	ldd	r22, Z+2	; 0x02
    28fe:	73 81       	ldd	r23, Z+3	; 0x03
    2900:	eb 81       	ldd	r30, Y+3	; 0x03
    2902:	fc 81       	ldd	r31, Y+4	; 0x04
    2904:	84 8d       	ldd	r24, Z+28	; 0x1c
    2906:	48 2f       	mov	r20, r24
    2908:	50 e0       	ldi	r21, 0x00	; 0
    290a:	2d 81       	ldd	r18, Y+5	; 0x05
    290c:	3e 81       	ldd	r19, Y+6	; 0x06
    290e:	cb 01       	movw	r24, r22
    2910:	b9 01       	movw	r22, r18
    2912:	0e 94 a5 32 	call	0x654a	; 0x654a <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2916:	eb 81       	ldd	r30, Y+3	; 0x03
    2918:	fc 81       	ldd	r31, Y+4	; 0x04
    291a:	22 81       	ldd	r18, Z+2	; 0x02
    291c:	33 81       	ldd	r19, Z+3	; 0x03
    291e:	eb 81       	ldd	r30, Y+3	; 0x03
    2920:	fc 81       	ldd	r31, Y+4	; 0x04
    2922:	84 8d       	ldd	r24, Z+28	; 0x1c
    2924:	88 2f       	mov	r24, r24
    2926:	90 e0       	ldi	r25, 0x00	; 0
    2928:	82 0f       	add	r24, r18
    292a:	93 1f       	adc	r25, r19
    292c:	eb 81       	ldd	r30, Y+3	; 0x03
    292e:	fc 81       	ldd	r31, Y+4	; 0x04
    2930:	93 83       	std	Z+3, r25	; 0x03
    2932:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2934:	eb 81       	ldd	r30, Y+3	; 0x03
    2936:	fc 81       	ldd	r31, Y+4	; 0x04
    2938:	22 81       	ldd	r18, Z+2	; 0x02
    293a:	33 81       	ldd	r19, Z+3	; 0x03
    293c:	eb 81       	ldd	r30, Y+3	; 0x03
    293e:	fc 81       	ldd	r31, Y+4	; 0x04
    2940:	84 81       	ldd	r24, Z+4	; 0x04
    2942:	95 81       	ldd	r25, Z+5	; 0x05
    2944:	28 17       	cp	r18, r24
    2946:	39 07       	cpc	r19, r25
    2948:	08 f4       	brcc	.+2      	; 0x294c <prvCopyDataToQueue+0x8e>
    294a:	50 c0       	rjmp	.+160    	; 0x29ec <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    294c:	eb 81       	ldd	r30, Y+3	; 0x03
    294e:	fc 81       	ldd	r31, Y+4	; 0x04
    2950:	80 81       	ld	r24, Z
    2952:	91 81       	ldd	r25, Z+1	; 0x01
    2954:	eb 81       	ldd	r30, Y+3	; 0x03
    2956:	fc 81       	ldd	r31, Y+4	; 0x04
    2958:	93 83       	std	Z+3, r25	; 0x03
    295a:	82 83       	std	Z+2, r24	; 0x02
    295c:	47 c0       	rjmp	.+142    	; 0x29ec <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    295e:	eb 81       	ldd	r30, Y+3	; 0x03
    2960:	fc 81       	ldd	r31, Y+4	; 0x04
    2962:	66 81       	ldd	r22, Z+6	; 0x06
    2964:	77 81       	ldd	r23, Z+7	; 0x07
    2966:	eb 81       	ldd	r30, Y+3	; 0x03
    2968:	fc 81       	ldd	r31, Y+4	; 0x04
    296a:	84 8d       	ldd	r24, Z+28	; 0x1c
    296c:	48 2f       	mov	r20, r24
    296e:	50 e0       	ldi	r21, 0x00	; 0
    2970:	2d 81       	ldd	r18, Y+5	; 0x05
    2972:	3e 81       	ldd	r19, Y+6	; 0x06
    2974:	cb 01       	movw	r24, r22
    2976:	b9 01       	movw	r22, r18
    2978:	0e 94 a5 32 	call	0x654a	; 0x654a <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    297c:	eb 81       	ldd	r30, Y+3	; 0x03
    297e:	fc 81       	ldd	r31, Y+4	; 0x04
    2980:	26 81       	ldd	r18, Z+6	; 0x06
    2982:	37 81       	ldd	r19, Z+7	; 0x07
    2984:	eb 81       	ldd	r30, Y+3	; 0x03
    2986:	fc 81       	ldd	r31, Y+4	; 0x04
    2988:	84 8d       	ldd	r24, Z+28	; 0x1c
    298a:	88 2f       	mov	r24, r24
    298c:	90 e0       	ldi	r25, 0x00	; 0
    298e:	90 95       	com	r25
    2990:	81 95       	neg	r24
    2992:	9f 4f       	sbci	r25, 0xFF	; 255
    2994:	82 0f       	add	r24, r18
    2996:	93 1f       	adc	r25, r19
    2998:	eb 81       	ldd	r30, Y+3	; 0x03
    299a:	fc 81       	ldd	r31, Y+4	; 0x04
    299c:	97 83       	std	Z+7, r25	; 0x07
    299e:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    29a0:	eb 81       	ldd	r30, Y+3	; 0x03
    29a2:	fc 81       	ldd	r31, Y+4	; 0x04
    29a4:	26 81       	ldd	r18, Z+6	; 0x06
    29a6:	37 81       	ldd	r19, Z+7	; 0x07
    29a8:	eb 81       	ldd	r30, Y+3	; 0x03
    29aa:	fc 81       	ldd	r31, Y+4	; 0x04
    29ac:	80 81       	ld	r24, Z
    29ae:	91 81       	ldd	r25, Z+1	; 0x01
    29b0:	28 17       	cp	r18, r24
    29b2:	39 07       	cpc	r19, r25
    29b4:	90 f4       	brcc	.+36     	; 0x29da <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    29b6:	eb 81       	ldd	r30, Y+3	; 0x03
    29b8:	fc 81       	ldd	r31, Y+4	; 0x04
    29ba:	24 81       	ldd	r18, Z+4	; 0x04
    29bc:	35 81       	ldd	r19, Z+5	; 0x05
    29be:	eb 81       	ldd	r30, Y+3	; 0x03
    29c0:	fc 81       	ldd	r31, Y+4	; 0x04
    29c2:	84 8d       	ldd	r24, Z+28	; 0x1c
    29c4:	88 2f       	mov	r24, r24
    29c6:	90 e0       	ldi	r25, 0x00	; 0
    29c8:	90 95       	com	r25
    29ca:	81 95       	neg	r24
    29cc:	9f 4f       	sbci	r25, 0xFF	; 255
    29ce:	82 0f       	add	r24, r18
    29d0:	93 1f       	adc	r25, r19
    29d2:	eb 81       	ldd	r30, Y+3	; 0x03
    29d4:	fc 81       	ldd	r31, Y+4	; 0x04
    29d6:	97 83       	std	Z+7, r25	; 0x07
    29d8:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    29da:	8f 81       	ldd	r24, Y+7	; 0x07
    29dc:	82 30       	cpi	r24, 0x02	; 2
    29de:	31 f4       	brne	.+12     	; 0x29ec <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    29e0:	89 81       	ldd	r24, Y+1	; 0x01
    29e2:	88 23       	and	r24, r24
    29e4:	19 f0       	breq	.+6      	; 0x29ec <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    29e6:	89 81       	ldd	r24, Y+1	; 0x01
    29e8:	81 50       	subi	r24, 0x01	; 1
    29ea:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    29ec:	89 81       	ldd	r24, Y+1	; 0x01
    29ee:	8f 5f       	subi	r24, 0xFF	; 255
    29f0:	eb 81       	ldd	r30, Y+3	; 0x03
    29f2:	fc 81       	ldd	r31, Y+4	; 0x04
    29f4:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    29f6:	8a 81       	ldd	r24, Y+2	; 0x02
}
    29f8:	27 96       	adiw	r28, 0x07	; 7
    29fa:	0f b6       	in	r0, 0x3f	; 63
    29fc:	f8 94       	cli
    29fe:	de bf       	out	0x3e, r29	; 62
    2a00:	0f be       	out	0x3f, r0	; 63
    2a02:	cd bf       	out	0x3d, r28	; 61
    2a04:	cf 91       	pop	r28
    2a06:	df 91       	pop	r29
    2a08:	08 95       	ret

00002a0a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    2a0a:	df 93       	push	r29
    2a0c:	cf 93       	push	r28
    2a0e:	00 d0       	rcall	.+0      	; 0x2a10 <prvCopyDataFromQueue+0x6>
    2a10:	00 d0       	rcall	.+0      	; 0x2a12 <prvCopyDataFromQueue+0x8>
    2a12:	cd b7       	in	r28, 0x3d	; 61
    2a14:	de b7       	in	r29, 0x3e	; 62
    2a16:	9a 83       	std	Y+2, r25	; 0x02
    2a18:	89 83       	std	Y+1, r24	; 0x01
    2a1a:	7c 83       	std	Y+4, r23	; 0x04
    2a1c:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2a1e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a20:	fa 81       	ldd	r31, Y+2	; 0x02
    2a22:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a24:	88 23       	and	r24, r24
    2a26:	89 f1       	breq	.+98     	; 0x2a8a <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2a28:	e9 81       	ldd	r30, Y+1	; 0x01
    2a2a:	fa 81       	ldd	r31, Y+2	; 0x02
    2a2c:	26 81       	ldd	r18, Z+6	; 0x06
    2a2e:	37 81       	ldd	r19, Z+7	; 0x07
    2a30:	e9 81       	ldd	r30, Y+1	; 0x01
    2a32:	fa 81       	ldd	r31, Y+2	; 0x02
    2a34:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a36:	88 2f       	mov	r24, r24
    2a38:	90 e0       	ldi	r25, 0x00	; 0
    2a3a:	82 0f       	add	r24, r18
    2a3c:	93 1f       	adc	r25, r19
    2a3e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a40:	fa 81       	ldd	r31, Y+2	; 0x02
    2a42:	97 83       	std	Z+7, r25	; 0x07
    2a44:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2a46:	e9 81       	ldd	r30, Y+1	; 0x01
    2a48:	fa 81       	ldd	r31, Y+2	; 0x02
    2a4a:	26 81       	ldd	r18, Z+6	; 0x06
    2a4c:	37 81       	ldd	r19, Z+7	; 0x07
    2a4e:	e9 81       	ldd	r30, Y+1	; 0x01
    2a50:	fa 81       	ldd	r31, Y+2	; 0x02
    2a52:	84 81       	ldd	r24, Z+4	; 0x04
    2a54:	95 81       	ldd	r25, Z+5	; 0x05
    2a56:	28 17       	cp	r18, r24
    2a58:	39 07       	cpc	r19, r25
    2a5a:	40 f0       	brcs	.+16     	; 0x2a6c <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2a5c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a5e:	fa 81       	ldd	r31, Y+2	; 0x02
    2a60:	80 81       	ld	r24, Z
    2a62:	91 81       	ldd	r25, Z+1	; 0x01
    2a64:	e9 81       	ldd	r30, Y+1	; 0x01
    2a66:	fa 81       	ldd	r31, Y+2	; 0x02
    2a68:	97 83       	std	Z+7, r25	; 0x07
    2a6a:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2a6c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a6e:	fa 81       	ldd	r31, Y+2	; 0x02
    2a70:	46 81       	ldd	r20, Z+6	; 0x06
    2a72:	57 81       	ldd	r21, Z+7	; 0x07
    2a74:	e9 81       	ldd	r30, Y+1	; 0x01
    2a76:	fa 81       	ldd	r31, Y+2	; 0x02
    2a78:	84 8d       	ldd	r24, Z+28	; 0x1c
    2a7a:	28 2f       	mov	r18, r24
    2a7c:	30 e0       	ldi	r19, 0x00	; 0
    2a7e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a80:	9c 81       	ldd	r25, Y+4	; 0x04
    2a82:	ba 01       	movw	r22, r20
    2a84:	a9 01       	movw	r20, r18
    2a86:	0e 94 a5 32 	call	0x654a	; 0x654a <memcpy>
    }
}
    2a8a:	0f 90       	pop	r0
    2a8c:	0f 90       	pop	r0
    2a8e:	0f 90       	pop	r0
    2a90:	0f 90       	pop	r0
    2a92:	cf 91       	pop	r28
    2a94:	df 91       	pop	r29
    2a96:	08 95       	ret

00002a98 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2a98:	df 93       	push	r29
    2a9a:	cf 93       	push	r28
    2a9c:	00 d0       	rcall	.+0      	; 0x2a9e <prvUnlockQueue+0x6>
    2a9e:	00 d0       	rcall	.+0      	; 0x2aa0 <prvUnlockQueue+0x8>
    2aa0:	cd b7       	in	r28, 0x3d	; 61
    2aa2:	de b7       	in	r29, 0x3e	; 62
    2aa4:	9c 83       	std	Y+4, r25	; 0x04
    2aa6:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    2aa8:	0f b6       	in	r0, 0x3f	; 63
    2aaa:	f8 94       	cli
    2aac:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    2aae:	eb 81       	ldd	r30, Y+3	; 0x03
    2ab0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ab2:	86 8d       	ldd	r24, Z+30	; 0x1e
    2ab4:	8a 83       	std	Y+2, r24	; 0x02
    2ab6:	11 c0       	rjmp	.+34     	; 0x2ada <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2ab8:	eb 81       	ldd	r30, Y+3	; 0x03
    2aba:	fc 81       	ldd	r31, Y+4	; 0x04
    2abc:	81 89       	ldd	r24, Z+17	; 0x11
    2abe:	88 23       	and	r24, r24
    2ac0:	79 f0       	breq	.+30     	; 0x2ae0 <prvUnlockQueue+0x48>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2ac2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ac4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ac6:	41 96       	adiw	r24, 0x11	; 17
    2ac8:	0e 94 1c 20 	call	0x4038	; 0x4038 <xTaskRemoveFromEventList>
    2acc:	88 23       	and	r24, r24
    2ace:	11 f0       	breq	.+4      	; 0x2ad4 <prvUnlockQueue+0x3c>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    2ad0:	0e 94 0c 23 	call	0x4618	; 0x4618 <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    2ad4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ad6:	81 50       	subi	r24, 0x01	; 1
    2ad8:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    2ada:	8a 81       	ldd	r24, Y+2	; 0x02
    2adc:	18 16       	cp	r1, r24
    2ade:	64 f3       	brlt	.-40     	; 0x2ab8 <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    2ae0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ae2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ae4:	8f ef       	ldi	r24, 0xFF	; 255
    2ae6:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    2ae8:	0f 90       	pop	r0
    2aea:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    2aec:	0f b6       	in	r0, 0x3f	; 63
    2aee:	f8 94       	cli
    2af0:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    2af2:	eb 81       	ldd	r30, Y+3	; 0x03
    2af4:	fc 81       	ldd	r31, Y+4	; 0x04
    2af6:	85 8d       	ldd	r24, Z+29	; 0x1d
    2af8:	89 83       	std	Y+1, r24	; 0x01
    2afa:	11 c0       	rjmp	.+34     	; 0x2b1e <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2afc:	eb 81       	ldd	r30, Y+3	; 0x03
    2afe:	fc 81       	ldd	r31, Y+4	; 0x04
    2b00:	80 85       	ldd	r24, Z+8	; 0x08
    2b02:	88 23       	and	r24, r24
    2b04:	79 f0       	breq	.+30     	; 0x2b24 <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2b06:	8b 81       	ldd	r24, Y+3	; 0x03
    2b08:	9c 81       	ldd	r25, Y+4	; 0x04
    2b0a:	08 96       	adiw	r24, 0x08	; 8
    2b0c:	0e 94 1c 20 	call	0x4038	; 0x4038 <xTaskRemoveFromEventList>
    2b10:	88 23       	and	r24, r24
    2b12:	11 f0       	breq	.+4      	; 0x2b18 <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    2b14:	0e 94 0c 23 	call	0x4618	; 0x4618 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    2b18:	89 81       	ldd	r24, Y+1	; 0x01
    2b1a:	81 50       	subi	r24, 0x01	; 1
    2b1c:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    2b1e:	89 81       	ldd	r24, Y+1	; 0x01
    2b20:	18 16       	cp	r1, r24
    2b22:	64 f3       	brlt	.-40     	; 0x2afc <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    2b24:	eb 81       	ldd	r30, Y+3	; 0x03
    2b26:	fc 81       	ldd	r31, Y+4	; 0x04
    2b28:	8f ef       	ldi	r24, 0xFF	; 255
    2b2a:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    2b2c:	0f 90       	pop	r0
    2b2e:	0f be       	out	0x3f, r0	; 63
}
    2b30:	0f 90       	pop	r0
    2b32:	0f 90       	pop	r0
    2b34:	0f 90       	pop	r0
    2b36:	0f 90       	pop	r0
    2b38:	cf 91       	pop	r28
    2b3a:	df 91       	pop	r29
    2b3c:	08 95       	ret

00002b3e <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    2b3e:	df 93       	push	r29
    2b40:	cf 93       	push	r28
    2b42:	00 d0       	rcall	.+0      	; 0x2b44 <prvIsQueueEmpty+0x6>
    2b44:	0f 92       	push	r0
    2b46:	cd b7       	in	r28, 0x3d	; 61
    2b48:	de b7       	in	r29, 0x3e	; 62
    2b4a:	9b 83       	std	Y+3, r25	; 0x03
    2b4c:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2b4e:	0f b6       	in	r0, 0x3f	; 63
    2b50:	f8 94       	cli
    2b52:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2b54:	ea 81       	ldd	r30, Y+2	; 0x02
    2b56:	fb 81       	ldd	r31, Y+3	; 0x03
    2b58:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b5a:	88 23       	and	r24, r24
    2b5c:	19 f4       	brne	.+6      	; 0x2b64 <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    2b5e:	81 e0       	ldi	r24, 0x01	; 1
    2b60:	89 83       	std	Y+1, r24	; 0x01
    2b62:	01 c0       	rjmp	.+2      	; 0x2b66 <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    2b64:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    2b66:	0f 90       	pop	r0
    2b68:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    2b6a:	89 81       	ldd	r24, Y+1	; 0x01
}
    2b6c:	0f 90       	pop	r0
    2b6e:	0f 90       	pop	r0
    2b70:	0f 90       	pop	r0
    2b72:	cf 91       	pop	r28
    2b74:	df 91       	pop	r29
    2b76:	08 95       	ret

00002b78 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2b78:	df 93       	push	r29
    2b7a:	cf 93       	push	r28
    2b7c:	00 d0       	rcall	.+0      	; 0x2b7e <xQueueIsQueueEmptyFromISR+0x6>
    2b7e:	00 d0       	rcall	.+0      	; 0x2b80 <xQueueIsQueueEmptyFromISR+0x8>
    2b80:	0f 92       	push	r0
    2b82:	cd b7       	in	r28, 0x3d	; 61
    2b84:	de b7       	in	r29, 0x3e	; 62
    2b86:	9d 83       	std	Y+5, r25	; 0x05
    2b88:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    2b8a:	8c 81       	ldd	r24, Y+4	; 0x04
    2b8c:	9d 81       	ldd	r25, Y+5	; 0x05
    2b8e:	9a 83       	std	Y+2, r25	; 0x02
    2b90:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2b92:	e9 81       	ldd	r30, Y+1	; 0x01
    2b94:	fa 81       	ldd	r31, Y+2	; 0x02
    2b96:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b98:	88 23       	and	r24, r24
    2b9a:	19 f4       	brne	.+6      	; 0x2ba2 <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    2b9c:	81 e0       	ldi	r24, 0x01	; 1
    2b9e:	8b 83       	std	Y+3, r24	; 0x03
    2ba0:	01 c0       	rjmp	.+2      	; 0x2ba4 <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    2ba2:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    2ba4:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2ba6:	0f 90       	pop	r0
    2ba8:	0f 90       	pop	r0
    2baa:	0f 90       	pop	r0
    2bac:	0f 90       	pop	r0
    2bae:	0f 90       	pop	r0
    2bb0:	cf 91       	pop	r28
    2bb2:	df 91       	pop	r29
    2bb4:	08 95       	ret

00002bb6 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    2bb6:	df 93       	push	r29
    2bb8:	cf 93       	push	r28
    2bba:	00 d0       	rcall	.+0      	; 0x2bbc <prvIsQueueFull+0x6>
    2bbc:	0f 92       	push	r0
    2bbe:	cd b7       	in	r28, 0x3d	; 61
    2bc0:	de b7       	in	r29, 0x3e	; 62
    2bc2:	9b 83       	std	Y+3, r25	; 0x03
    2bc4:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2bc6:	0f b6       	in	r0, 0x3f	; 63
    2bc8:	f8 94       	cli
    2bca:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2bcc:	ea 81       	ldd	r30, Y+2	; 0x02
    2bce:	fb 81       	ldd	r31, Y+3	; 0x03
    2bd0:	92 8d       	ldd	r25, Z+26	; 0x1a
    2bd2:	ea 81       	ldd	r30, Y+2	; 0x02
    2bd4:	fb 81       	ldd	r31, Y+3	; 0x03
    2bd6:	83 8d       	ldd	r24, Z+27	; 0x1b
    2bd8:	98 17       	cp	r25, r24
    2bda:	19 f4       	brne	.+6      	; 0x2be2 <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    2bdc:	81 e0       	ldi	r24, 0x01	; 1
    2bde:	89 83       	std	Y+1, r24	; 0x01
    2be0:	01 c0       	rjmp	.+2      	; 0x2be4 <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    2be2:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    2be4:	0f 90       	pop	r0
    2be6:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    2be8:	89 81       	ldd	r24, Y+1	; 0x01
}
    2bea:	0f 90       	pop	r0
    2bec:	0f 90       	pop	r0
    2bee:	0f 90       	pop	r0
    2bf0:	cf 91       	pop	r28
    2bf2:	df 91       	pop	r29
    2bf4:	08 95       	ret

00002bf6 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2bf6:	df 93       	push	r29
    2bf8:	cf 93       	push	r28
    2bfa:	00 d0       	rcall	.+0      	; 0x2bfc <xQueueIsQueueFullFromISR+0x6>
    2bfc:	00 d0       	rcall	.+0      	; 0x2bfe <xQueueIsQueueFullFromISR+0x8>
    2bfe:	0f 92       	push	r0
    2c00:	cd b7       	in	r28, 0x3d	; 61
    2c02:	de b7       	in	r29, 0x3e	; 62
    2c04:	9d 83       	std	Y+5, r25	; 0x05
    2c06:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    2c08:	8c 81       	ldd	r24, Y+4	; 0x04
    2c0a:	9d 81       	ldd	r25, Y+5	; 0x05
    2c0c:	9a 83       	std	Y+2, r25	; 0x02
    2c0e:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2c10:	e9 81       	ldd	r30, Y+1	; 0x01
    2c12:	fa 81       	ldd	r31, Y+2	; 0x02
    2c14:	92 8d       	ldd	r25, Z+26	; 0x1a
    2c16:	e9 81       	ldd	r30, Y+1	; 0x01
    2c18:	fa 81       	ldd	r31, Y+2	; 0x02
    2c1a:	83 8d       	ldd	r24, Z+27	; 0x1b
    2c1c:	98 17       	cp	r25, r24
    2c1e:	19 f4       	brne	.+6      	; 0x2c26 <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    2c20:	81 e0       	ldi	r24, 0x01	; 1
    2c22:	8b 83       	std	Y+3, r24	; 0x03
    2c24:	01 c0       	rjmp	.+2      	; 0x2c28 <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    2c26:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    2c28:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2c2a:	0f 90       	pop	r0
    2c2c:	0f 90       	pop	r0
    2c2e:	0f 90       	pop	r0
    2c30:	0f 90       	pop	r0
    2c32:	0f 90       	pop	r0
    2c34:	cf 91       	pop	r28
    2c36:	df 91       	pop	r29
    2c38:	08 95       	ret

00002c3a <xQueueCRSend>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSend( QueueHandle_t xQueue,
                             const void * pvItemToQueue,
                             TickType_t xTicksToWait )
    {
    2c3a:	df 93       	push	r29
    2c3c:	cf 93       	push	r28
    2c3e:	cd b7       	in	r28, 0x3d	; 61
    2c40:	de b7       	in	r29, 0x3e	; 62
    2c42:	2a 97       	sbiw	r28, 0x0a	; 10
    2c44:	0f b6       	in	r0, 0x3f	; 63
    2c46:	f8 94       	cli
    2c48:	de bf       	out	0x3e, r29	; 62
    2c4a:	0f be       	out	0x3f, r0	; 63
    2c4c:	cd bf       	out	0x3d, r28	; 61
    2c4e:	9d 83       	std	Y+5, r25	; 0x05
    2c50:	8c 83       	std	Y+4, r24	; 0x04
    2c52:	7f 83       	std	Y+7, r23	; 0x07
    2c54:	6e 83       	std	Y+6, r22	; 0x06
    2c56:	59 87       	std	Y+9, r21	; 0x09
    2c58:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    2c5a:	8c 81       	ldd	r24, Y+4	; 0x04
    2c5c:	9d 81       	ldd	r25, Y+5	; 0x05
    2c5e:	9a 83       	std	Y+2, r25	; 0x02
    2c60:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    2c62:	f8 94       	cli
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2c64:	89 81       	ldd	r24, Y+1	; 0x01
    2c66:	9a 81       	ldd	r25, Y+2	; 0x02
    2c68:	0e 94 db 15 	call	0x2bb6	; 0x2bb6 <prvIsQueueFull>
    2c6c:	88 23       	and	r24, r24
    2c6e:	a9 f0       	breq	.+42     	; 0x2c9a <xQueueCRSend+0x60>
            {
                /* The queue is full - do we want to block or just leave without
                 * posting? */
                if( xTicksToWait > ( TickType_t ) 0 )
    2c70:	88 85       	ldd	r24, Y+8	; 0x08
    2c72:	99 85       	ldd	r25, Y+9	; 0x09
    2c74:	00 97       	sbiw	r24, 0x00	; 0
    2c76:	71 f0       	breq	.+28     	; 0x2c94 <xQueueCRSend+0x5a>
                {
                    /* As this is called from a coroutine we cannot block directly, but
                     * return indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    2c78:	89 81       	ldd	r24, Y+1	; 0x01
    2c7a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c7c:	9c 01       	movw	r18, r24
    2c7e:	28 5f       	subi	r18, 0xF8	; 248
    2c80:	3f 4f       	sbci	r19, 0xFF	; 255
    2c82:	88 85       	ldd	r24, Y+8	; 0x08
    2c84:	99 85       	ldd	r25, Y+9	; 0x09
    2c86:	b9 01       	movw	r22, r18
    2c88:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    2c8c:	78 94       	sei
                    return errQUEUE_BLOCKED;
    2c8e:	8c ef       	ldi	r24, 0xFC	; 252
    2c90:	8a 87       	std	Y+10, r24	; 0x0a
    2c92:	2a c0       	rjmp	.+84     	; 0x2ce8 <xQueueCRSend+0xae>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    2c94:	78 94       	sei
                    return errQUEUE_FULL;
    2c96:	1a 86       	std	Y+10, r1	; 0x0a
    2c98:	27 c0       	rjmp	.+78     	; 0x2ce8 <xQueueCRSend+0xae>
                }
            }
        }
        portENABLE_INTERRUPTS();
    2c9a:	78 94       	sei

        portDISABLE_INTERRUPTS();
    2c9c:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2c9e:	e9 81       	ldd	r30, Y+1	; 0x01
    2ca0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ca2:	92 8d       	ldd	r25, Z+26	; 0x1a
    2ca4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ca6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ca8:	83 8d       	ldd	r24, Z+27	; 0x1b
    2caa:	98 17       	cp	r25, r24
    2cac:	c8 f4       	brcc	.+50     	; 0x2ce0 <xQueueCRSend+0xa6>
            {
                /* There is room in the queue, copy the data into the queue. */
                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    2cae:	89 81       	ldd	r24, Y+1	; 0x01
    2cb0:	9a 81       	ldd	r25, Y+2	; 0x02
    2cb2:	2e 81       	ldd	r18, Y+6	; 0x06
    2cb4:	3f 81       	ldd	r19, Y+7	; 0x07
    2cb6:	b9 01       	movw	r22, r18
    2cb8:	40 e0       	ldi	r20, 0x00	; 0
    2cba:	0e 94 5f 14 	call	0x28be	; 0x28be <prvCopyDataToQueue>
                xReturn = pdPASS;
    2cbe:	81 e0       	ldi	r24, 0x01	; 1
    2cc0:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for data to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2cc2:	e9 81       	ldd	r30, Y+1	; 0x01
    2cc4:	fa 81       	ldd	r31, Y+2	; 0x02
    2cc6:	81 89       	ldd	r24, Z+17	; 0x11
    2cc8:	88 23       	and	r24, r24
    2cca:	59 f0       	breq	.+22     	; 0x2ce2 <xQueueCRSend+0xa8>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2ccc:	89 81       	ldd	r24, Y+1	; 0x01
    2cce:	9a 81       	ldd	r25, Y+2	; 0x02
    2cd0:	41 96       	adiw	r24, 0x11	; 17
    2cd2:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <xCoRoutineRemoveFromEventList>
    2cd6:	88 23       	and	r24, r24
    2cd8:	21 f0       	breq	.+8      	; 0x2ce2 <xQueueCRSend+0xa8>
                    {
                        /* The co-routine waiting has a higher priority so record
                         * that a yield might be appropriate. */
                        xReturn = errQUEUE_YIELD;
    2cda:	8b ef       	ldi	r24, 0xFB	; 251
    2cdc:	8b 83       	std	Y+3, r24	; 0x03
    2cde:	01 c0       	rjmp	.+2      	; 0x2ce2 <xQueueCRSend+0xa8>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = errQUEUE_FULL;
    2ce0:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    2ce2:	78 94       	sei

        return xReturn;
    2ce4:	8b 81       	ldd	r24, Y+3	; 0x03
    2ce6:	8a 87       	std	Y+10, r24	; 0x0a
    2ce8:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    2cea:	2a 96       	adiw	r28, 0x0a	; 10
    2cec:	0f b6       	in	r0, 0x3f	; 63
    2cee:	f8 94       	cli
    2cf0:	de bf       	out	0x3e, r29	; 62
    2cf2:	0f be       	out	0x3f, r0	; 63
    2cf4:	cd bf       	out	0x3d, r28	; 61
    2cf6:	cf 91       	pop	r28
    2cf8:	df 91       	pop	r29
    2cfa:	08 95       	ret

00002cfc <xQueueCRReceive>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
                                void * pvBuffer,
                                TickType_t xTicksToWait )
    {
    2cfc:	df 93       	push	r29
    2cfe:	cf 93       	push	r28
    2d00:	cd b7       	in	r28, 0x3d	; 61
    2d02:	de b7       	in	r29, 0x3e	; 62
    2d04:	2a 97       	sbiw	r28, 0x0a	; 10
    2d06:	0f b6       	in	r0, 0x3f	; 63
    2d08:	f8 94       	cli
    2d0a:	de bf       	out	0x3e, r29	; 62
    2d0c:	0f be       	out	0x3f, r0	; 63
    2d0e:	cd bf       	out	0x3d, r28	; 61
    2d10:	9d 83       	std	Y+5, r25	; 0x05
    2d12:	8c 83       	std	Y+4, r24	; 0x04
    2d14:	7f 83       	std	Y+7, r23	; 0x07
    2d16:	6e 83       	std	Y+6, r22	; 0x06
    2d18:	59 87       	std	Y+9, r21	; 0x09
    2d1a:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    2d1c:	8c 81       	ldd	r24, Y+4	; 0x04
    2d1e:	9d 81       	ldd	r25, Y+5	; 0x05
    2d20:	9a 83       	std	Y+2, r25	; 0x02
    2d22:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already empty we may have to block.  A critical section
         * is required to prevent an interrupt adding something to the queue
         * between the check to see if the queue is empty and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    2d24:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2d26:	e9 81       	ldd	r30, Y+1	; 0x01
    2d28:	fa 81       	ldd	r31, Y+2	; 0x02
    2d2a:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d2c:	88 23       	and	r24, r24
    2d2e:	a9 f4       	brne	.+42     	; 0x2d5a <xQueueCRReceive+0x5e>
            {
                /* There are no messages in the queue, do we want to block or just
                 * leave with nothing? */
                if( xTicksToWait > ( TickType_t ) 0 )
    2d30:	88 85       	ldd	r24, Y+8	; 0x08
    2d32:	99 85       	ldd	r25, Y+9	; 0x09
    2d34:	00 97       	sbiw	r24, 0x00	; 0
    2d36:	71 f0       	breq	.+28     	; 0x2d54 <xQueueCRReceive+0x58>
                {
                    /* As this is a co-routine we cannot block directly, but return
                     * indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    2d38:	89 81       	ldd	r24, Y+1	; 0x01
    2d3a:	9a 81       	ldd	r25, Y+2	; 0x02
    2d3c:	9c 01       	movw	r18, r24
    2d3e:	2f 5e       	subi	r18, 0xEF	; 239
    2d40:	3f 4f       	sbci	r19, 0xFF	; 255
    2d42:	88 85       	ldd	r24, Y+8	; 0x08
    2d44:	99 85       	ldd	r25, Y+9	; 0x09
    2d46:	b9 01       	movw	r22, r18
    2d48:	0e 94 e9 07 	call	0xfd2	; 0xfd2 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    2d4c:	78 94       	sei
                    return errQUEUE_BLOCKED;
    2d4e:	8c ef       	ldi	r24, 0xFC	; 252
    2d50:	8a 87       	std	Y+10, r24	; 0x0a
    2d52:	58 c0       	rjmp	.+176    	; 0x2e04 <xQueueCRReceive+0x108>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    2d54:	78 94       	sei
                    return errQUEUE_FULL;
    2d56:	1a 86       	std	Y+10, r1	; 0x0a
    2d58:	55 c0       	rjmp	.+170    	; 0x2e04 <xQueueCRReceive+0x108>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portENABLE_INTERRUPTS();
    2d5a:	78 94       	sei

        portDISABLE_INTERRUPTS();
    2d5c:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2d5e:	e9 81       	ldd	r30, Y+1	; 0x01
    2d60:	fa 81       	ldd	r31, Y+2	; 0x02
    2d62:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d64:	88 23       	and	r24, r24
    2d66:	09 f4       	brne	.+2      	; 0x2d6a <xQueueCRReceive+0x6e>
    2d68:	49 c0       	rjmp	.+146    	; 0x2dfc <xQueueCRReceive+0x100>
            {
                /* Data is available from the queue. */
                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    2d6a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d6c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d6e:	26 81       	ldd	r18, Z+6	; 0x06
    2d70:	37 81       	ldd	r19, Z+7	; 0x07
    2d72:	e9 81       	ldd	r30, Y+1	; 0x01
    2d74:	fa 81       	ldd	r31, Y+2	; 0x02
    2d76:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d78:	88 2f       	mov	r24, r24
    2d7a:	90 e0       	ldi	r25, 0x00	; 0
    2d7c:	82 0f       	add	r24, r18
    2d7e:	93 1f       	adc	r25, r19
    2d80:	e9 81       	ldd	r30, Y+1	; 0x01
    2d82:	fa 81       	ldd	r31, Y+2	; 0x02
    2d84:	97 83       	std	Z+7, r25	; 0x07
    2d86:	86 83       	std	Z+6, r24	; 0x06

                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    2d88:	e9 81       	ldd	r30, Y+1	; 0x01
    2d8a:	fa 81       	ldd	r31, Y+2	; 0x02
    2d8c:	26 81       	ldd	r18, Z+6	; 0x06
    2d8e:	37 81       	ldd	r19, Z+7	; 0x07
    2d90:	e9 81       	ldd	r30, Y+1	; 0x01
    2d92:	fa 81       	ldd	r31, Y+2	; 0x02
    2d94:	84 81       	ldd	r24, Z+4	; 0x04
    2d96:	95 81       	ldd	r25, Z+5	; 0x05
    2d98:	28 17       	cp	r18, r24
    2d9a:	39 07       	cpc	r19, r25
    2d9c:	40 f0       	brcs	.+16     	; 0x2dae <xQueueCRReceive+0xb2>
                {
                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2d9e:	e9 81       	ldd	r30, Y+1	; 0x01
    2da0:	fa 81       	ldd	r31, Y+2	; 0x02
    2da2:	80 81       	ld	r24, Z
    2da4:	91 81       	ldd	r25, Z+1	; 0x01
    2da6:	e9 81       	ldd	r30, Y+1	; 0x01
    2da8:	fa 81       	ldd	r31, Y+2	; 0x02
    2daa:	97 83       	std	Z+7, r25	; 0x07
    2dac:	86 83       	std	Z+6, r24	; 0x06
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --( pxQueue->uxMessagesWaiting );
    2dae:	e9 81       	ldd	r30, Y+1	; 0x01
    2db0:	fa 81       	ldd	r31, Y+2	; 0x02
    2db2:	82 8d       	ldd	r24, Z+26	; 0x1a
    2db4:	81 50       	subi	r24, 0x01	; 1
    2db6:	e9 81       	ldd	r30, Y+1	; 0x01
    2db8:	fa 81       	ldd	r31, Y+2	; 0x02
    2dba:	82 8f       	std	Z+26, r24	; 0x1a
                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2dbc:	e9 81       	ldd	r30, Y+1	; 0x01
    2dbe:	fa 81       	ldd	r31, Y+2	; 0x02
    2dc0:	46 81       	ldd	r20, Z+6	; 0x06
    2dc2:	57 81       	ldd	r21, Z+7	; 0x07
    2dc4:	e9 81       	ldd	r30, Y+1	; 0x01
    2dc6:	fa 81       	ldd	r31, Y+2	; 0x02
    2dc8:	84 8d       	ldd	r24, Z+28	; 0x1c
    2dca:	28 2f       	mov	r18, r24
    2dcc:	30 e0       	ldi	r19, 0x00	; 0
    2dce:	8e 81       	ldd	r24, Y+6	; 0x06
    2dd0:	9f 81       	ldd	r25, Y+7	; 0x07
    2dd2:	ba 01       	movw	r22, r20
    2dd4:	a9 01       	movw	r20, r18
    2dd6:	0e 94 a5 32 	call	0x654a	; 0x654a <memcpy>

                xReturn = pdPASS;
    2dda:	81 e0       	ldi	r24, 0x01	; 1
    2ddc:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for space to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2dde:	e9 81       	ldd	r30, Y+1	; 0x01
    2de0:	fa 81       	ldd	r31, Y+2	; 0x02
    2de2:	80 85       	ldd	r24, Z+8	; 0x08
    2de4:	88 23       	and	r24, r24
    2de6:	59 f0       	breq	.+22     	; 0x2dfe <xQueueCRReceive+0x102>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2de8:	89 81       	ldd	r24, Y+1	; 0x01
    2dea:	9a 81       	ldd	r25, Y+2	; 0x02
    2dec:	08 96       	adiw	r24, 0x08	; 8
    2dee:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <xCoRoutineRemoveFromEventList>
    2df2:	88 23       	and	r24, r24
    2df4:	21 f0       	breq	.+8      	; 0x2dfe <xQueueCRReceive+0x102>
                    {
                        xReturn = errQUEUE_YIELD;
    2df6:	8b ef       	ldi	r24, 0xFB	; 251
    2df8:	8b 83       	std	Y+3, r24	; 0x03
    2dfa:	01 c0       	rjmp	.+2      	; 0x2dfe <xQueueCRReceive+0x102>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = pdFAIL;
    2dfc:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    2dfe:	78 94       	sei

        return xReturn;
    2e00:	8b 81       	ldd	r24, Y+3	; 0x03
    2e02:	8a 87       	std	Y+10, r24	; 0x0a
    2e04:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    2e06:	2a 96       	adiw	r28, 0x0a	; 10
    2e08:	0f b6       	in	r0, 0x3f	; 63
    2e0a:	f8 94       	cli
    2e0c:	de bf       	out	0x3e, r29	; 62
    2e0e:	0f be       	out	0x3f, r0	; 63
    2e10:	cd bf       	out	0x3d, r28	; 61
    2e12:	cf 91       	pop	r28
    2e14:	df 91       	pop	r29
    2e16:	08 95       	ret

00002e18 <xQueueCRSendFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
                                    const void * pvItemToQueue,
                                    BaseType_t xCoRoutinePreviouslyWoken )
    {
    2e18:	df 93       	push	r29
    2e1a:	cf 93       	push	r28
    2e1c:	cd b7       	in	r28, 0x3d	; 61
    2e1e:	de b7       	in	r29, 0x3e	; 62
    2e20:	28 97       	sbiw	r28, 0x08	; 8
    2e22:	0f b6       	in	r0, 0x3f	; 63
    2e24:	f8 94       	cli
    2e26:	de bf       	out	0x3e, r29	; 62
    2e28:	0f be       	out	0x3f, r0	; 63
    2e2a:	cd bf       	out	0x3d, r28	; 61
    2e2c:	9c 83       	std	Y+4, r25	; 0x04
    2e2e:	8b 83       	std	Y+3, r24	; 0x03
    2e30:	7e 83       	std	Y+6, r23	; 0x06
    2e32:	6d 83       	std	Y+5, r22	; 0x05
    2e34:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    2e36:	8b 81       	ldd	r24, Y+3	; 0x03
    2e38:	9c 81       	ldd	r25, Y+4	; 0x04
    2e3a:	9a 83       	std	Y+2, r25	; 0x02
    2e3c:	89 83       	std	Y+1, r24	; 0x01

        /* Cannot block within an ISR so if there is no space on the queue then
         * exit without doing anything. */
        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2e3e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e40:	fa 81       	ldd	r31, Y+2	; 0x02
    2e42:	92 8d       	ldd	r25, Z+26	; 0x1a
    2e44:	e9 81       	ldd	r30, Y+1	; 0x01
    2e46:	fa 81       	ldd	r31, Y+2	; 0x02
    2e48:	83 8d       	ldd	r24, Z+27	; 0x1b
    2e4a:	98 17       	cp	r25, r24
    2e4c:	d0 f4       	brcc	.+52     	; 0x2e82 <xQueueCRSendFromISR+0x6a>
        {
            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    2e4e:	89 81       	ldd	r24, Y+1	; 0x01
    2e50:	9a 81       	ldd	r25, Y+2	; 0x02
    2e52:	2d 81       	ldd	r18, Y+5	; 0x05
    2e54:	3e 81       	ldd	r19, Y+6	; 0x06
    2e56:	b9 01       	movw	r22, r18
    2e58:	40 e0       	ldi	r20, 0x00	; 0
    2e5a:	0e 94 5f 14 	call	0x28be	; 0x28be <prvCopyDataToQueue>

            /* We only want to wake one co-routine per ISR, so check that a
             * co-routine has not already been woken. */
            if( xCoRoutinePreviouslyWoken == pdFALSE )
    2e5e:	8f 81       	ldd	r24, Y+7	; 0x07
    2e60:	88 23       	and	r24, r24
    2e62:	79 f4       	brne	.+30     	; 0x2e82 <xQueueCRSendFromISR+0x6a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2e64:	e9 81       	ldd	r30, Y+1	; 0x01
    2e66:	fa 81       	ldd	r31, Y+2	; 0x02
    2e68:	81 89       	ldd	r24, Z+17	; 0x11
    2e6a:	88 23       	and	r24, r24
    2e6c:	51 f0       	breq	.+20     	; 0x2e82 <xQueueCRSendFromISR+0x6a>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2e6e:	89 81       	ldd	r24, Y+1	; 0x01
    2e70:	9a 81       	ldd	r25, Y+2	; 0x02
    2e72:	41 96       	adiw	r24, 0x11	; 17
    2e74:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <xCoRoutineRemoveFromEventList>
    2e78:	88 23       	and	r24, r24
    2e7a:	19 f0       	breq	.+6      	; 0x2e82 <xQueueCRSendFromISR+0x6a>
                    {
                        return pdTRUE;
    2e7c:	81 e0       	ldi	r24, 0x01	; 1
    2e7e:	88 87       	std	Y+8, r24	; 0x08
    2e80:	02 c0       	rjmp	.+4      	; 0x2e86 <xQueueCRSendFromISR+0x6e>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xCoRoutinePreviouslyWoken;
    2e82:	8f 81       	ldd	r24, Y+7	; 0x07
    2e84:	88 87       	std	Y+8, r24	; 0x08
    2e86:	88 85       	ldd	r24, Y+8	; 0x08
    }
    2e88:	28 96       	adiw	r28, 0x08	; 8
    2e8a:	0f b6       	in	r0, 0x3f	; 63
    2e8c:	f8 94       	cli
    2e8e:	de bf       	out	0x3e, r29	; 62
    2e90:	0f be       	out	0x3f, r0	; 63
    2e92:	cd bf       	out	0x3d, r28	; 61
    2e94:	cf 91       	pop	r28
    2e96:	df 91       	pop	r29
    2e98:	08 95       	ret

00002e9a <xQueueCRReceiveFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
                                       void * pvBuffer,
                                       BaseType_t * pxCoRoutineWoken )
    {
    2e9a:	df 93       	push	r29
    2e9c:	cf 93       	push	r28
    2e9e:	cd b7       	in	r28, 0x3d	; 61
    2ea0:	de b7       	in	r29, 0x3e	; 62
    2ea2:	29 97       	sbiw	r28, 0x09	; 9
    2ea4:	0f b6       	in	r0, 0x3f	; 63
    2ea6:	f8 94       	cli
    2ea8:	de bf       	out	0x3e, r29	; 62
    2eaa:	0f be       	out	0x3f, r0	; 63
    2eac:	cd bf       	out	0x3d, r28	; 61
    2eae:	9d 83       	std	Y+5, r25	; 0x05
    2eb0:	8c 83       	std	Y+4, r24	; 0x04
    2eb2:	7f 83       	std	Y+7, r23	; 0x07
    2eb4:	6e 83       	std	Y+6, r22	; 0x06
    2eb6:	59 87       	std	Y+9, r21	; 0x09
    2eb8:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    2eba:	8c 81       	ldd	r24, Y+4	; 0x04
    2ebc:	9d 81       	ldd	r25, Y+5	; 0x05
    2ebe:	9a 83       	std	Y+2, r25	; 0x02
    2ec0:	89 83       	std	Y+1, r24	; 0x01

        /* We cannot block from an ISR, so check there is data available. If
         * not then just leave without doing anything. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2ec2:	e9 81       	ldd	r30, Y+1	; 0x01
    2ec4:	fa 81       	ldd	r31, Y+2	; 0x02
    2ec6:	82 8d       	ldd	r24, Z+26	; 0x1a
    2ec8:	88 23       	and	r24, r24
    2eca:	09 f4       	brne	.+2      	; 0x2ece <xQueueCRReceiveFromISR+0x34>
    2ecc:	50 c0       	rjmp	.+160    	; 0x2f6e <xQueueCRReceiveFromISR+0xd4>
        {
            /* Copy the data from the queue. */
            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    2ece:	e9 81       	ldd	r30, Y+1	; 0x01
    2ed0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ed2:	26 81       	ldd	r18, Z+6	; 0x06
    2ed4:	37 81       	ldd	r19, Z+7	; 0x07
    2ed6:	e9 81       	ldd	r30, Y+1	; 0x01
    2ed8:	fa 81       	ldd	r31, Y+2	; 0x02
    2eda:	84 8d       	ldd	r24, Z+28	; 0x1c
    2edc:	88 2f       	mov	r24, r24
    2ede:	90 e0       	ldi	r25, 0x00	; 0
    2ee0:	82 0f       	add	r24, r18
    2ee2:	93 1f       	adc	r25, r19
    2ee4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ee6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ee8:	97 83       	std	Z+7, r25	; 0x07
    2eea:	86 83       	std	Z+6, r24	; 0x06

            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    2eec:	e9 81       	ldd	r30, Y+1	; 0x01
    2eee:	fa 81       	ldd	r31, Y+2	; 0x02
    2ef0:	26 81       	ldd	r18, Z+6	; 0x06
    2ef2:	37 81       	ldd	r19, Z+7	; 0x07
    2ef4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ef6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ef8:	84 81       	ldd	r24, Z+4	; 0x04
    2efa:	95 81       	ldd	r25, Z+5	; 0x05
    2efc:	28 17       	cp	r18, r24
    2efe:	39 07       	cpc	r19, r25
    2f00:	40 f0       	brcs	.+16     	; 0x2f12 <xQueueCRReceiveFromISR+0x78>
            {
                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2f02:	e9 81       	ldd	r30, Y+1	; 0x01
    2f04:	fa 81       	ldd	r31, Y+2	; 0x02
    2f06:	80 81       	ld	r24, Z
    2f08:	91 81       	ldd	r25, Z+1	; 0x01
    2f0a:	e9 81       	ldd	r30, Y+1	; 0x01
    2f0c:	fa 81       	ldd	r31, Y+2	; 0x02
    2f0e:	97 83       	std	Z+7, r25	; 0x07
    2f10:	86 83       	std	Z+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            --( pxQueue->uxMessagesWaiting );
    2f12:	e9 81       	ldd	r30, Y+1	; 0x01
    2f14:	fa 81       	ldd	r31, Y+2	; 0x02
    2f16:	82 8d       	ldd	r24, Z+26	; 0x1a
    2f18:	81 50       	subi	r24, 0x01	; 1
    2f1a:	e9 81       	ldd	r30, Y+1	; 0x01
    2f1c:	fa 81       	ldd	r31, Y+2	; 0x02
    2f1e:	82 8f       	std	Z+26, r24	; 0x1a
            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2f20:	e9 81       	ldd	r30, Y+1	; 0x01
    2f22:	fa 81       	ldd	r31, Y+2	; 0x02
    2f24:	46 81       	ldd	r20, Z+6	; 0x06
    2f26:	57 81       	ldd	r21, Z+7	; 0x07
    2f28:	e9 81       	ldd	r30, Y+1	; 0x01
    2f2a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f2c:	84 8d       	ldd	r24, Z+28	; 0x1c
    2f2e:	28 2f       	mov	r18, r24
    2f30:	30 e0       	ldi	r19, 0x00	; 0
    2f32:	8e 81       	ldd	r24, Y+6	; 0x06
    2f34:	9f 81       	ldd	r25, Y+7	; 0x07
    2f36:	ba 01       	movw	r22, r20
    2f38:	a9 01       	movw	r20, r18
    2f3a:	0e 94 a5 32 	call	0x654a	; 0x654a <memcpy>

            if( ( *pxCoRoutineWoken ) == pdFALSE )
    2f3e:	e8 85       	ldd	r30, Y+8	; 0x08
    2f40:	f9 85       	ldd	r31, Y+9	; 0x09
    2f42:	80 81       	ld	r24, Z
    2f44:	88 23       	and	r24, r24
    2f46:	81 f4       	brne	.+32     	; 0x2f68 <xQueueCRReceiveFromISR+0xce>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2f48:	e9 81       	ldd	r30, Y+1	; 0x01
    2f4a:	fa 81       	ldd	r31, Y+2	; 0x02
    2f4c:	80 85       	ldd	r24, Z+8	; 0x08
    2f4e:	88 23       	and	r24, r24
    2f50:	59 f0       	breq	.+22     	; 0x2f68 <xQueueCRReceiveFromISR+0xce>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2f52:	89 81       	ldd	r24, Y+1	; 0x01
    2f54:	9a 81       	ldd	r25, Y+2	; 0x02
    2f56:	08 96       	adiw	r24, 0x08	; 8
    2f58:	0e 94 fc 09 	call	0x13f8	; 0x13f8 <xCoRoutineRemoveFromEventList>
    2f5c:	88 23       	and	r24, r24
    2f5e:	21 f0       	breq	.+8      	; 0x2f68 <xQueueCRReceiveFromISR+0xce>
                    {
                        *pxCoRoutineWoken = pdTRUE;
    2f60:	e8 85       	ldd	r30, Y+8	; 0x08
    2f62:	f9 85       	ldd	r31, Y+9	; 0x09
    2f64:	81 e0       	ldi	r24, 0x01	; 1
    2f66:	80 83       	st	Z, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
    2f68:	81 e0       	ldi	r24, 0x01	; 1
    2f6a:	8b 83       	std	Y+3, r24	; 0x03
    2f6c:	01 c0       	rjmp	.+2      	; 0x2f70 <xQueueCRReceiveFromISR+0xd6>
        }
        else
        {
            xReturn = pdFAIL;
    2f6e:	1b 82       	std	Y+3, r1	; 0x03
        }

        return xReturn;
    2f70:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    2f72:	29 96       	adiw	r28, 0x09	; 9
    2f74:	0f b6       	in	r0, 0x3f	; 63
    2f76:	f8 94       	cli
    2f78:	de bf       	out	0x3e, r29	; 62
    2f7a:	0f be       	out	0x3f, r0	; 63
    2f7c:	cd bf       	out	0x3d, r28	; 61
    2f7e:	cf 91       	pop	r28
    2f80:	df 91       	pop	r29
    2f82:	08 95       	ret

00002f84 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
    2f84:	df 93       	push	r29
    2f86:	cf 93       	push	r28
    2f88:	cd b7       	in	r28, 0x3d	; 61
    2f8a:	de b7       	in	r29, 0x3e	; 62
    2f8c:	27 97       	sbiw	r28, 0x07	; 7
    2f8e:	0f b6       	in	r0, 0x3f	; 63
    2f90:	f8 94       	cli
    2f92:	de bf       	out	0x3e, r29	; 62
    2f94:	0f be       	out	0x3f, r0	; 63
    2f96:	cd bf       	out	0x3d, r28	; 61
    2f98:	9c 83       	std	Y+4, r25	; 0x04
    2f9a:	8b 83       	std	Y+3, r24	; 0x03
    2f9c:	7e 83       	std	Y+6, r23	; 0x06
    2f9e:	6d 83       	std	Y+5, r22	; 0x05
    2fa0:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    2fa2:	8b 81       	ldd	r24, Y+3	; 0x03
    2fa4:	9c 81       	ldd	r25, Y+4	; 0x04
    2fa6:	9a 83       	std	Y+2, r25	; 0x02
    2fa8:	89 83       	std	Y+1, r24	; 0x01
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    2faa:	0f b6       	in	r0, 0x3f	; 63
    2fac:	f8 94       	cli
    2fae:	0f 92       	push	r0
    2fb0:	e9 81       	ldd	r30, Y+1	; 0x01
    2fb2:	fa 81       	ldd	r31, Y+2	; 0x02
    2fb4:	85 8d       	ldd	r24, Z+29	; 0x1d
    2fb6:	8f 3f       	cpi	r24, 0xFF	; 255
    2fb8:	19 f4       	brne	.+6      	; 0x2fc0 <vQueueWaitForMessageRestricted+0x3c>
    2fba:	e9 81       	ldd	r30, Y+1	; 0x01
    2fbc:	fa 81       	ldd	r31, Y+2	; 0x02
    2fbe:	15 8e       	std	Z+29, r1	; 0x1d
    2fc0:	e9 81       	ldd	r30, Y+1	; 0x01
    2fc2:	fa 81       	ldd	r31, Y+2	; 0x02
    2fc4:	86 8d       	ldd	r24, Z+30	; 0x1e
    2fc6:	8f 3f       	cpi	r24, 0xFF	; 255
    2fc8:	19 f4       	brne	.+6      	; 0x2fd0 <vQueueWaitForMessageRestricted+0x4c>
    2fca:	e9 81       	ldd	r30, Y+1	; 0x01
    2fcc:	fa 81       	ldd	r31, Y+2	; 0x02
    2fce:	16 8e       	std	Z+30, r1	; 0x1e
    2fd0:	0f 90       	pop	r0
    2fd2:	0f be       	out	0x3f, r0	; 63

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    2fd4:	e9 81       	ldd	r30, Y+1	; 0x01
    2fd6:	fa 81       	ldd	r31, Y+2	; 0x02
    2fd8:	82 8d       	ldd	r24, Z+26	; 0x1a
    2fda:	88 23       	and	r24, r24
    2fdc:	49 f4       	brne	.+18     	; 0x2ff0 <vQueueWaitForMessageRestricted+0x6c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    2fde:	89 81       	ldd	r24, Y+1	; 0x01
    2fe0:	9a 81       	ldd	r25, Y+2	; 0x02
    2fe2:	41 96       	adiw	r24, 0x11	; 17
    2fe4:	2d 81       	ldd	r18, Y+5	; 0x05
    2fe6:	3e 81       	ldd	r19, Y+6	; 0x06
    2fe8:	b9 01       	movw	r22, r18
    2fea:	4f 81       	ldd	r20, Y+7	; 0x07
    2fec:	0e 94 ba 1f 	call	0x3f74	; 0x3f74 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
    2ff0:	89 81       	ldd	r24, Y+1	; 0x01
    2ff2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ff4:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <prvUnlockQueue>
    }
    2ff8:	27 96       	adiw	r28, 0x07	; 7
    2ffa:	0f b6       	in	r0, 0x3f	; 63
    2ffc:	f8 94       	cli
    2ffe:	de bf       	out	0x3e, r29	; 62
    3000:	0f be       	out	0x3f, r0	; 63
    3002:	cd bf       	out	0x3d, r28	; 61
    3004:	cf 91       	pop	r28
    3006:	df 91       	pop	r29
    3008:	08 95       	ret

0000300a <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    300a:	8f 92       	push	r8
    300c:	9f 92       	push	r9
    300e:	af 92       	push	r10
    3010:	bf 92       	push	r11
    3012:	cf 92       	push	r12
    3014:	df 92       	push	r13
    3016:	ef 92       	push	r14
    3018:	ff 92       	push	r15
    301a:	0f 93       	push	r16
    301c:	1f 93       	push	r17
    301e:	df 93       	push	r29
    3020:	cf 93       	push	r28
    3022:	cd b7       	in	r28, 0x3d	; 61
    3024:	de b7       	in	r29, 0x3e	; 62
    3026:	60 97       	sbiw	r28, 0x10	; 16
    3028:	0f b6       	in	r0, 0x3f	; 63
    302a:	f8 94       	cli
    302c:	de bf       	out	0x3e, r29	; 62
    302e:	0f be       	out	0x3f, r0	; 63
    3030:	cd bf       	out	0x3d, r28	; 61
    3032:	9f 83       	std	Y+7, r25	; 0x07
    3034:	8e 83       	std	Y+6, r24	; 0x06
    3036:	79 87       	std	Y+9, r23	; 0x09
    3038:	68 87       	std	Y+8, r22	; 0x08
    303a:	5b 87       	std	Y+11, r21	; 0x0b
    303c:	4a 87       	std	Y+10, r20	; 0x0a
    303e:	3d 87       	std	Y+13, r19	; 0x0d
    3040:	2c 87       	std	Y+12, r18	; 0x0c
    3042:	0e 87       	std	Y+14, r16	; 0x0e
    3044:	f8 8a       	std	Y+16, r15	; 0x10
    3046:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    3048:	8a 85       	ldd	r24, Y+10	; 0x0a
    304a:	9b 85       	ldd	r25, Y+11	; 0x0b
    304c:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    3050:	9a 83       	std	Y+2, r25	; 0x02
    3052:	89 83       	std	Y+1, r24	; 0x01

                if( pxStack != NULL )
    3054:	89 81       	ldd	r24, Y+1	; 0x01
    3056:	9a 81       	ldd	r25, Y+2	; 0x02
    3058:	00 97       	sbiw	r24, 0x00	; 0
    305a:	b1 f0       	breq	.+44     	; 0x3088 <xTaskCreate+0x7e>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    305c:	86 e2       	ldi	r24, 0x26	; 38
    305e:	90 e0       	ldi	r25, 0x00	; 0
    3060:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    3064:	9d 83       	std	Y+5, r25	; 0x05
    3066:	8c 83       	std	Y+4, r24	; 0x04

                    if( pxNewTCB != NULL )
    3068:	8c 81       	ldd	r24, Y+4	; 0x04
    306a:	9d 81       	ldd	r25, Y+5	; 0x05
    306c:	00 97       	sbiw	r24, 0x00	; 0
    306e:	39 f0       	breq	.+14     	; 0x307e <xTaskCreate+0x74>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    3070:	ec 81       	ldd	r30, Y+4	; 0x04
    3072:	fd 81       	ldd	r31, Y+5	; 0x05
    3074:	89 81       	ldd	r24, Y+1	; 0x01
    3076:	9a 81       	ldd	r25, Y+2	; 0x02
    3078:	90 8f       	std	Z+24, r25	; 0x18
    307a:	87 8b       	std	Z+23, r24	; 0x17
    307c:	07 c0       	rjmp	.+14     	; 0x308c <xTaskCreate+0x82>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFreeStack( pxStack );
    307e:	89 81       	ldd	r24, Y+1	; 0x01
    3080:	9a 81       	ldd	r25, Y+2	; 0x02
    3082:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
    3086:	02 c0       	rjmp	.+4      	; 0x308c <xTaskCreate+0x82>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
    3088:	1d 82       	std	Y+5, r1	; 0x05
    308a:	1c 82       	std	Y+4, r1	; 0x04
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    308c:	8c 81       	ldd	r24, Y+4	; 0x04
    308e:	9d 81       	ldd	r25, Y+5	; 0x05
    3090:	00 97       	sbiw	r24, 0x00	; 0
    3092:	e9 f0       	breq	.+58     	; 0x30ce <xTaskCreate+0xc4>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    3094:	8a 85       	ldd	r24, Y+10	; 0x0a
    3096:	9b 85       	ldd	r25, Y+11	; 0x0b
    3098:	9c 01       	movw	r18, r24
    309a:	40 e0       	ldi	r20, 0x00	; 0
    309c:	50 e0       	ldi	r21, 0x00	; 0
    309e:	8e 81       	ldd	r24, Y+6	; 0x06
    30a0:	9f 81       	ldd	r25, Y+7	; 0x07
    30a2:	68 85       	ldd	r22, Y+8	; 0x08
    30a4:	79 85       	ldd	r23, Y+9	; 0x09
    30a6:	ec 85       	ldd	r30, Y+12	; 0x0c
    30a8:	fd 85       	ldd	r31, Y+13	; 0x0d
    30aa:	af 85       	ldd	r26, Y+15	; 0x0f
    30ac:	b8 89       	ldd	r27, Y+16	; 0x10
    30ae:	ac 80       	ldd	r10, Y+4	; 0x04
    30b0:	bd 80       	ldd	r11, Y+5	; 0x05
    30b2:	8f 01       	movw	r16, r30
    30b4:	ee 84       	ldd	r14, Y+14	; 0x0e
    30b6:	6d 01       	movw	r12, r26
    30b8:	88 24       	eor	r8, r8
    30ba:	99 24       	eor	r9, r9
    30bc:	0e 94 7d 18 	call	0x30fa	; 0x30fa <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    30c0:	8c 81       	ldd	r24, Y+4	; 0x04
    30c2:	9d 81       	ldd	r25, Y+5	; 0x05
    30c4:	0e 94 42 19 	call	0x3284	; 0x3284 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    30c8:	81 e0       	ldi	r24, 0x01	; 1
    30ca:	8b 83       	std	Y+3, r24	; 0x03
    30cc:	02 c0       	rjmp	.+4      	; 0x30d2 <xTaskCreate+0xc8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    30ce:	8f ef       	ldi	r24, 0xFF	; 255
    30d0:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    30d2:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    30d4:	60 96       	adiw	r28, 0x10	; 16
    30d6:	0f b6       	in	r0, 0x3f	; 63
    30d8:	f8 94       	cli
    30da:	de bf       	out	0x3e, r29	; 62
    30dc:	0f be       	out	0x3f, r0	; 63
    30de:	cd bf       	out	0x3d, r28	; 61
    30e0:	cf 91       	pop	r28
    30e2:	df 91       	pop	r29
    30e4:	1f 91       	pop	r17
    30e6:	0f 91       	pop	r16
    30e8:	ff 90       	pop	r15
    30ea:	ef 90       	pop	r14
    30ec:	df 90       	pop	r13
    30ee:	cf 90       	pop	r12
    30f0:	bf 90       	pop	r11
    30f2:	af 90       	pop	r10
    30f4:	9f 90       	pop	r9
    30f6:	8f 90       	pop	r8
    30f8:	08 95       	ret

000030fa <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    30fa:	8f 92       	push	r8
    30fc:	9f 92       	push	r9
    30fe:	af 92       	push	r10
    3100:	bf 92       	push	r11
    3102:	cf 92       	push	r12
    3104:	df 92       	push	r13
    3106:	ef 92       	push	r14
    3108:	0f 93       	push	r16
    310a:	1f 93       	push	r17
    310c:	df 93       	push	r29
    310e:	cf 93       	push	r28
    3110:	cd b7       	in	r28, 0x3d	; 61
    3112:	de b7       	in	r29, 0x3e	; 62
    3114:	64 97       	sbiw	r28, 0x14	; 20
    3116:	0f b6       	in	r0, 0x3f	; 63
    3118:	f8 94       	cli
    311a:	de bf       	out	0x3e, r29	; 62
    311c:	0f be       	out	0x3f, r0	; 63
    311e:	cd bf       	out	0x3d, r28	; 61
    3120:	9d 83       	std	Y+5, r25	; 0x05
    3122:	8c 83       	std	Y+4, r24	; 0x04
    3124:	7f 83       	std	Y+7, r23	; 0x07
    3126:	6e 83       	std	Y+6, r22	; 0x06
    3128:	28 87       	std	Y+8, r18	; 0x08
    312a:	39 87       	std	Y+9, r19	; 0x09
    312c:	4a 87       	std	Y+10, r20	; 0x0a
    312e:	5b 87       	std	Y+11, r21	; 0x0b
    3130:	1d 87       	std	Y+13, r17	; 0x0d
    3132:	0c 87       	std	Y+12, r16	; 0x0c
    3134:	ee 86       	std	Y+14, r14	; 0x0e
    3136:	d8 8a       	std	Y+16, r13	; 0x10
    3138:	cf 86       	std	Y+15, r12	; 0x0f
    313a:	ba 8a       	std	Y+18, r11	; 0x12
    313c:	a9 8a       	std	Y+17, r10	; 0x11
    313e:	9c 8a       	std	Y+20, r9	; 0x14
    3140:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    3142:	e9 89       	ldd	r30, Y+17	; 0x11
    3144:	fa 89       	ldd	r31, Y+18	; 0x12
    3146:	27 89       	ldd	r18, Z+23	; 0x17
    3148:	30 8d       	ldd	r19, Z+24	; 0x18
    314a:	88 85       	ldd	r24, Y+8	; 0x08
    314c:	99 85       	ldd	r25, Y+9	; 0x09
    314e:	01 97       	sbiw	r24, 0x01	; 1
    3150:	82 0f       	add	r24, r18
    3152:	93 1f       	adc	r25, r19
    3154:	9b 83       	std	Y+3, r25	; 0x03
    3156:	8a 83       	std	Y+2, r24	; 0x02
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    3158:	8e 81       	ldd	r24, Y+6	; 0x06
    315a:	9f 81       	ldd	r25, Y+7	; 0x07
    315c:	00 97       	sbiw	r24, 0x00	; 0
    315e:	51 f1       	breq	.+84     	; 0x31b4 <prvInitialiseNewTask+0xba>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    3160:	19 82       	std	Y+1, r1	; 0x01
    3162:	21 c0       	rjmp	.+66     	; 0x31a6 <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3164:	89 81       	ldd	r24, Y+1	; 0x01
    3166:	48 2f       	mov	r20, r24
    3168:	50 e0       	ldi	r21, 0x00	; 0
    316a:	89 81       	ldd	r24, Y+1	; 0x01
    316c:	28 2f       	mov	r18, r24
    316e:	30 e0       	ldi	r19, 0x00	; 0
    3170:	8e 81       	ldd	r24, Y+6	; 0x06
    3172:	9f 81       	ldd	r25, Y+7	; 0x07
    3174:	fc 01       	movw	r30, r24
    3176:	e2 0f       	add	r30, r18
    3178:	f3 1f       	adc	r31, r19
    317a:	20 81       	ld	r18, Z
    317c:	89 89       	ldd	r24, Y+17	; 0x11
    317e:	9a 89       	ldd	r25, Y+18	; 0x12
    3180:	84 0f       	add	r24, r20
    3182:	95 1f       	adc	r25, r21
    3184:	fc 01       	movw	r30, r24
    3186:	79 96       	adiw	r30, 0x19	; 25
    3188:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    318a:	89 81       	ldd	r24, Y+1	; 0x01
    318c:	28 2f       	mov	r18, r24
    318e:	30 e0       	ldi	r19, 0x00	; 0
    3190:	8e 81       	ldd	r24, Y+6	; 0x06
    3192:	9f 81       	ldd	r25, Y+7	; 0x07
    3194:	fc 01       	movw	r30, r24
    3196:	e2 0f       	add	r30, r18
    3198:	f3 1f       	adc	r31, r19
    319a:	80 81       	ld	r24, Z
    319c:	88 23       	and	r24, r24
    319e:	31 f0       	breq	.+12     	; 0x31ac <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    31a0:	89 81       	ldd	r24, Y+1	; 0x01
    31a2:	8f 5f       	subi	r24, 0xFF	; 255
    31a4:	89 83       	std	Y+1, r24	; 0x01
    31a6:	89 81       	ldd	r24, Y+1	; 0x01
    31a8:	88 30       	cpi	r24, 0x08	; 8
    31aa:	e0 f2       	brcs	.-72     	; 0x3164 <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    31ac:	e9 89       	ldd	r30, Y+17	; 0x11
    31ae:	fa 89       	ldd	r31, Y+18	; 0x12
    31b0:	10 a2       	std	Z+32, r1	; 0x20
    31b2:	03 c0       	rjmp	.+6      	; 0x31ba <prvInitialiseNewTask+0xc0>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    31b4:	e9 89       	ldd	r30, Y+17	; 0x11
    31b6:	fa 89       	ldd	r31, Y+18	; 0x12
    31b8:	11 8e       	std	Z+25, r1	; 0x19
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    31ba:	8e 85       	ldd	r24, Y+14	; 0x0e
    31bc:	84 30       	cpi	r24, 0x04	; 4
    31be:	10 f0       	brcs	.+4      	; 0x31c4 <prvInitialiseNewTask+0xca>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    31c0:	83 e0       	ldi	r24, 0x03	; 3
    31c2:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    31c4:	e9 89       	ldd	r30, Y+17	; 0x11
    31c6:	fa 89       	ldd	r31, Y+18	; 0x12
    31c8:	8e 85       	ldd	r24, Y+14	; 0x0e
    31ca:	86 8b       	std	Z+22, r24	; 0x16
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    31cc:	89 89       	ldd	r24, Y+17	; 0x11
    31ce:	9a 89       	ldd	r25, Y+18	; 0x12
    31d0:	02 96       	adiw	r24, 0x02	; 2
    31d2:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    31d6:	89 89       	ldd	r24, Y+17	; 0x11
    31d8:	9a 89       	ldd	r25, Y+18	; 0x12
    31da:	0c 96       	adiw	r24, 0x0c	; 12
    31dc:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    31e0:	e9 89       	ldd	r30, Y+17	; 0x11
    31e2:	fa 89       	ldd	r31, Y+18	; 0x12
    31e4:	89 89       	ldd	r24, Y+17	; 0x11
    31e6:	9a 89       	ldd	r25, Y+18	; 0x12
    31e8:	91 87       	std	Z+9, r25	; 0x09
    31ea:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    31ec:	8e 85       	ldd	r24, Y+14	; 0x0e
    31ee:	28 2f       	mov	r18, r24
    31f0:	30 e0       	ldi	r19, 0x00	; 0
    31f2:	84 e0       	ldi	r24, 0x04	; 4
    31f4:	90 e0       	ldi	r25, 0x00	; 0
    31f6:	82 1b       	sub	r24, r18
    31f8:	93 0b       	sbc	r25, r19
    31fa:	e9 89       	ldd	r30, Y+17	; 0x11
    31fc:	fa 89       	ldd	r31, Y+18	; 0x12
    31fe:	95 87       	std	Z+13, r25	; 0x0d
    3200:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    3202:	e9 89       	ldd	r30, Y+17	; 0x11
    3204:	fa 89       	ldd	r31, Y+18	; 0x12
    3206:	89 89       	ldd	r24, Y+17	; 0x11
    3208:	9a 89       	ldd	r25, Y+18	; 0x12
    320a:	93 8b       	std	Z+19, r25	; 0x13
    320c:	82 8b       	std	Z+18, r24	; 0x12
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    320e:	89 89       	ldd	r24, Y+17	; 0x11
    3210:	9a 89       	ldd	r25, Y+18	; 0x12
    3212:	81 96       	adiw	r24, 0x21	; 33
    3214:	60 e0       	ldi	r22, 0x00	; 0
    3216:	70 e0       	ldi	r23, 0x00	; 0
    3218:	44 e0       	ldi	r20, 0x04	; 4
    321a:	50 e0       	ldi	r21, 0x00	; 0
    321c:	0e 94 ae 32 	call	0x655c	; 0x655c <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    3220:	89 89       	ldd	r24, Y+17	; 0x11
    3222:	9a 89       	ldd	r25, Y+18	; 0x12
    3224:	85 96       	adiw	r24, 0x25	; 37
    3226:	60 e0       	ldi	r22, 0x00	; 0
    3228:	70 e0       	ldi	r23, 0x00	; 0
    322a:	41 e0       	ldi	r20, 0x01	; 1
    322c:	50 e0       	ldi	r21, 0x00	; 0
    322e:	0e 94 ae 32 	call	0x655c	; 0x655c <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    3232:	8a 81       	ldd	r24, Y+2	; 0x02
    3234:	9b 81       	ldd	r25, Y+3	; 0x03
    3236:	2c 81       	ldd	r18, Y+4	; 0x04
    3238:	3d 81       	ldd	r19, Y+5	; 0x05
    323a:	4c 85       	ldd	r20, Y+12	; 0x0c
    323c:	5d 85       	ldd	r21, Y+13	; 0x0d
    323e:	b9 01       	movw	r22, r18
    3240:	0e 94 c9 00 	call	0x192	; 0x192 <pxPortInitialiseStack>
    3244:	e9 89       	ldd	r30, Y+17	; 0x11
    3246:	fa 89       	ldd	r31, Y+18	; 0x12
    3248:	91 83       	std	Z+1, r25	; 0x01
    324a:	80 83       	st	Z, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    324c:	8f 85       	ldd	r24, Y+15	; 0x0f
    324e:	98 89       	ldd	r25, Y+16	; 0x10
    3250:	00 97       	sbiw	r24, 0x00	; 0
    3252:	31 f0       	breq	.+12     	; 0x3260 <prvInitialiseNewTask+0x166>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    3254:	ef 85       	ldd	r30, Y+15	; 0x0f
    3256:	f8 89       	ldd	r31, Y+16	; 0x10
    3258:	89 89       	ldd	r24, Y+17	; 0x11
    325a:	9a 89       	ldd	r25, Y+18	; 0x12
    325c:	91 83       	std	Z+1, r25	; 0x01
    325e:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    3260:	64 96       	adiw	r28, 0x14	; 20
    3262:	0f b6       	in	r0, 0x3f	; 63
    3264:	f8 94       	cli
    3266:	de bf       	out	0x3e, r29	; 62
    3268:	0f be       	out	0x3f, r0	; 63
    326a:	cd bf       	out	0x3d, r28	; 61
    326c:	cf 91       	pop	r28
    326e:	df 91       	pop	r29
    3270:	1f 91       	pop	r17
    3272:	0f 91       	pop	r16
    3274:	ef 90       	pop	r14
    3276:	df 90       	pop	r13
    3278:	cf 90       	pop	r12
    327a:	bf 90       	pop	r11
    327c:	af 90       	pop	r10
    327e:	9f 90       	pop	r9
    3280:	8f 90       	pop	r8
    3282:	08 95       	ret

00003284 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    3284:	df 93       	push	r29
    3286:	cf 93       	push	r28
    3288:	00 d0       	rcall	.+0      	; 0x328a <prvAddNewTaskToReadyList+0x6>
    328a:	00 d0       	rcall	.+0      	; 0x328c <prvAddNewTaskToReadyList+0x8>
    328c:	cd b7       	in	r28, 0x3d	; 61
    328e:	de b7       	in	r29, 0x3e	; 62
    3290:	9c 83       	std	Y+4, r25	; 0x04
    3292:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    3294:	0f b6       	in	r0, 0x3f	; 63
    3296:	f8 94       	cli
    3298:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    329a:	80 91 a9 06 	lds	r24, 0x06A9
    329e:	8f 5f       	subi	r24, 0xFF	; 255
    32a0:	80 93 a9 06 	sts	0x06A9, r24

        if( pxCurrentTCB == NULL )
    32a4:	80 91 a6 06 	lds	r24, 0x06A6
    32a8:	90 91 a7 06 	lds	r25, 0x06A7
    32ac:	00 97       	sbiw	r24, 0x00	; 0
    32ae:	69 f4       	brne	.+26     	; 0x32ca <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    32b0:	8b 81       	ldd	r24, Y+3	; 0x03
    32b2:	9c 81       	ldd	r25, Y+4	; 0x04
    32b4:	90 93 a7 06 	sts	0x06A7, r25
    32b8:	80 93 a6 06 	sts	0x06A6, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    32bc:	80 91 a9 06 	lds	r24, 0x06A9
    32c0:	81 30       	cpi	r24, 0x01	; 1
    32c2:	b9 f4       	brne	.+46     	; 0x32f2 <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    32c4:	0e 94 26 23 	call	0x464c	; 0x464c <prvInitialiseTaskLists>
    32c8:	14 c0       	rjmp	.+40     	; 0x32f2 <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    32ca:	80 91 ad 06 	lds	r24, 0x06AD
    32ce:	88 23       	and	r24, r24
    32d0:	81 f4       	brne	.+32     	; 0x32f2 <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    32d2:	e0 91 a6 06 	lds	r30, 0x06A6
    32d6:	f0 91 a7 06 	lds	r31, 0x06A7
    32da:	96 89       	ldd	r25, Z+22	; 0x16
    32dc:	eb 81       	ldd	r30, Y+3	; 0x03
    32de:	fc 81       	ldd	r31, Y+4	; 0x04
    32e0:	86 89       	ldd	r24, Z+22	; 0x16
    32e2:	89 17       	cp	r24, r25
    32e4:	30 f0       	brcs	.+12     	; 0x32f2 <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    32e6:	8b 81       	ldd	r24, Y+3	; 0x03
    32e8:	9c 81       	ldd	r25, Y+4	; 0x04
    32ea:	90 93 a7 06 	sts	0x06A7, r25
    32ee:	80 93 a6 06 	sts	0x06A6, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    32f2:	80 91 b2 06 	lds	r24, 0x06B2
    32f6:	8f 5f       	subi	r24, 0xFF	; 255
    32f8:	80 93 b2 06 	sts	0x06B2, r24
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    32fc:	eb 81       	ldd	r30, Y+3	; 0x03
    32fe:	fc 81       	ldd	r31, Y+4	; 0x04
    3300:	96 89       	ldd	r25, Z+22	; 0x16
    3302:	80 91 ac 06 	lds	r24, 0x06AC
    3306:	89 17       	cp	r24, r25
    3308:	28 f4       	brcc	.+10     	; 0x3314 <prvAddNewTaskToReadyList+0x90>
    330a:	eb 81       	ldd	r30, Y+3	; 0x03
    330c:	fc 81       	ldd	r31, Y+4	; 0x04
    330e:	86 89       	ldd	r24, Z+22	; 0x16
    3310:	80 93 ac 06 	sts	0x06AC, r24
    3314:	eb 81       	ldd	r30, Y+3	; 0x03
    3316:	fc 81       	ldd	r31, Y+4	; 0x04
    3318:	86 89       	ldd	r24, Z+22	; 0x16
    331a:	28 2f       	mov	r18, r24
    331c:	30 e0       	ldi	r19, 0x00	; 0
    331e:	c9 01       	movw	r24, r18
    3320:	88 0f       	add	r24, r24
    3322:	99 1f       	adc	r25, r25
    3324:	88 0f       	add	r24, r24
    3326:	99 1f       	adc	r25, r25
    3328:	88 0f       	add	r24, r24
    332a:	99 1f       	adc	r25, r25
    332c:	82 0f       	add	r24, r18
    332e:	93 1f       	adc	r25, r19
    3330:	fc 01       	movw	r30, r24
    3332:	e8 54       	subi	r30, 0x48	; 72
    3334:	f9 4f       	sbci	r31, 0xF9	; 249
    3336:	81 81       	ldd	r24, Z+1	; 0x01
    3338:	92 81       	ldd	r25, Z+2	; 0x02
    333a:	9a 83       	std	Y+2, r25	; 0x02
    333c:	89 83       	std	Y+1, r24	; 0x01
    333e:	eb 81       	ldd	r30, Y+3	; 0x03
    3340:	fc 81       	ldd	r31, Y+4	; 0x04
    3342:	89 81       	ldd	r24, Y+1	; 0x01
    3344:	9a 81       	ldd	r25, Y+2	; 0x02
    3346:	95 83       	std	Z+5, r25	; 0x05
    3348:	84 83       	std	Z+4, r24	; 0x04
    334a:	e9 81       	ldd	r30, Y+1	; 0x01
    334c:	fa 81       	ldd	r31, Y+2	; 0x02
    334e:	84 81       	ldd	r24, Z+4	; 0x04
    3350:	95 81       	ldd	r25, Z+5	; 0x05
    3352:	eb 81       	ldd	r30, Y+3	; 0x03
    3354:	fc 81       	ldd	r31, Y+4	; 0x04
    3356:	97 83       	std	Z+7, r25	; 0x07
    3358:	86 83       	std	Z+6, r24	; 0x06
    335a:	e9 81       	ldd	r30, Y+1	; 0x01
    335c:	fa 81       	ldd	r31, Y+2	; 0x02
    335e:	04 80       	ldd	r0, Z+4	; 0x04
    3360:	f5 81       	ldd	r31, Z+5	; 0x05
    3362:	e0 2d       	mov	r30, r0
    3364:	8b 81       	ldd	r24, Y+3	; 0x03
    3366:	9c 81       	ldd	r25, Y+4	; 0x04
    3368:	02 96       	adiw	r24, 0x02	; 2
    336a:	93 83       	std	Z+3, r25	; 0x03
    336c:	82 83       	std	Z+2, r24	; 0x02
    336e:	8b 81       	ldd	r24, Y+3	; 0x03
    3370:	9c 81       	ldd	r25, Y+4	; 0x04
    3372:	02 96       	adiw	r24, 0x02	; 2
    3374:	e9 81       	ldd	r30, Y+1	; 0x01
    3376:	fa 81       	ldd	r31, Y+2	; 0x02
    3378:	95 83       	std	Z+5, r25	; 0x05
    337a:	84 83       	std	Z+4, r24	; 0x04
    337c:	eb 81       	ldd	r30, Y+3	; 0x03
    337e:	fc 81       	ldd	r31, Y+4	; 0x04
    3380:	86 89       	ldd	r24, Z+22	; 0x16
    3382:	28 2f       	mov	r18, r24
    3384:	30 e0       	ldi	r19, 0x00	; 0
    3386:	c9 01       	movw	r24, r18
    3388:	88 0f       	add	r24, r24
    338a:	99 1f       	adc	r25, r25
    338c:	88 0f       	add	r24, r24
    338e:	99 1f       	adc	r25, r25
    3390:	88 0f       	add	r24, r24
    3392:	99 1f       	adc	r25, r25
    3394:	82 0f       	add	r24, r18
    3396:	93 1f       	adc	r25, r19
    3398:	88 54       	subi	r24, 0x48	; 72
    339a:	99 4f       	sbci	r25, 0xF9	; 249
    339c:	eb 81       	ldd	r30, Y+3	; 0x03
    339e:	fc 81       	ldd	r31, Y+4	; 0x04
    33a0:	93 87       	std	Z+11, r25	; 0x0b
    33a2:	82 87       	std	Z+10, r24	; 0x0a
    33a4:	eb 81       	ldd	r30, Y+3	; 0x03
    33a6:	fc 81       	ldd	r31, Y+4	; 0x04
    33a8:	86 89       	ldd	r24, Z+22	; 0x16
    33aa:	28 2f       	mov	r18, r24
    33ac:	30 e0       	ldi	r19, 0x00	; 0
    33ae:	c9 01       	movw	r24, r18
    33b0:	88 0f       	add	r24, r24
    33b2:	99 1f       	adc	r25, r25
    33b4:	88 0f       	add	r24, r24
    33b6:	99 1f       	adc	r25, r25
    33b8:	88 0f       	add	r24, r24
    33ba:	99 1f       	adc	r25, r25
    33bc:	82 0f       	add	r24, r18
    33be:	93 1f       	adc	r25, r19
    33c0:	fc 01       	movw	r30, r24
    33c2:	e8 54       	subi	r30, 0x48	; 72
    33c4:	f9 4f       	sbci	r31, 0xF9	; 249
    33c6:	80 81       	ld	r24, Z
    33c8:	8f 5f       	subi	r24, 0xFF	; 255
    33ca:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    33cc:	0f 90       	pop	r0
    33ce:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    33d0:	80 91 ad 06 	lds	r24, 0x06AD
    33d4:	88 23       	and	r24, r24
    33d6:	61 f0       	breq	.+24     	; 0x33f0 <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    33d8:	e0 91 a6 06 	lds	r30, 0x06A6
    33dc:	f0 91 a7 06 	lds	r31, 0x06A7
    33e0:	96 89       	ldd	r25, Z+22	; 0x16
    33e2:	eb 81       	ldd	r30, Y+3	; 0x03
    33e4:	fc 81       	ldd	r31, Y+4	; 0x04
    33e6:	86 89       	ldd	r24, Z+22	; 0x16
    33e8:	98 17       	cp	r25, r24
    33ea:	10 f4       	brcc	.+4      	; 0x33f0 <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    33ec:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    33f0:	0f 90       	pop	r0
    33f2:	0f 90       	pop	r0
    33f4:	0f 90       	pop	r0
    33f6:	0f 90       	pop	r0
    33f8:	cf 91       	pop	r28
    33fa:	df 91       	pop	r29
    33fc:	08 95       	ret

000033fe <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    33fe:	df 93       	push	r29
    3400:	cf 93       	push	r28
    3402:	00 d0       	rcall	.+0      	; 0x3404 <vTaskDelete+0x6>
    3404:	00 d0       	rcall	.+0      	; 0x3406 <vTaskDelete+0x8>
    3406:	00 d0       	rcall	.+0      	; 0x3408 <vTaskDelete+0xa>
    3408:	cd b7       	in	r28, 0x3d	; 61
    340a:	de b7       	in	r29, 0x3e	; 62
    340c:	9c 83       	std	Y+4, r25	; 0x04
    340e:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    3410:	0f b6       	in	r0, 0x3f	; 63
    3412:	f8 94       	cli
    3414:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3416:	8b 81       	ldd	r24, Y+3	; 0x03
    3418:	9c 81       	ldd	r25, Y+4	; 0x04
    341a:	00 97       	sbiw	r24, 0x00	; 0
    341c:	39 f4       	brne	.+14     	; 0x342c <vTaskDelete+0x2e>
    341e:	80 91 a6 06 	lds	r24, 0x06A6
    3422:	90 91 a7 06 	lds	r25, 0x06A7
    3426:	9e 83       	std	Y+6, r25	; 0x06
    3428:	8d 83       	std	Y+5, r24	; 0x05
    342a:	04 c0       	rjmp	.+8      	; 0x3434 <vTaskDelete+0x36>
    342c:	8b 81       	ldd	r24, Y+3	; 0x03
    342e:	9c 81       	ldd	r25, Y+4	; 0x04
    3430:	9e 83       	std	Y+6, r25	; 0x06
    3432:	8d 83       	std	Y+5, r24	; 0x05
    3434:	8d 81       	ldd	r24, Y+5	; 0x05
    3436:	9e 81       	ldd	r25, Y+6	; 0x06
    3438:	9a 83       	std	Y+2, r25	; 0x02
    343a:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    343c:	89 81       	ldd	r24, Y+1	; 0x01
    343e:	9a 81       	ldd	r25, Y+2	; 0x02
    3440:	02 96       	adiw	r24, 0x02	; 2
    3442:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3446:	e9 81       	ldd	r30, Y+1	; 0x01
    3448:	fa 81       	ldd	r31, Y+2	; 0x02
    344a:	84 89       	ldd	r24, Z+20	; 0x14
    344c:	95 89       	ldd	r25, Z+21	; 0x15
    344e:	00 97       	sbiw	r24, 0x00	; 0
    3450:	29 f0       	breq	.+10     	; 0x345c <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3452:	89 81       	ldd	r24, Y+1	; 0x01
    3454:	9a 81       	ldd	r25, Y+2	; 0x02
    3456:	0c 96       	adiw	r24, 0x0c	; 12
    3458:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    345c:	80 91 b2 06 	lds	r24, 0x06B2
    3460:	8f 5f       	subi	r24, 0xFF	; 255
    3462:	80 93 b2 06 	sts	0x06B2, r24

            if( pxTCB == pxCurrentTCB )
    3466:	20 91 a6 06 	lds	r18, 0x06A6
    346a:	30 91 a7 06 	lds	r19, 0x06A7
    346e:	89 81       	ldd	r24, Y+1	; 0x01
    3470:	9a 81       	ldd	r25, Y+2	; 0x02
    3472:	82 17       	cp	r24, r18
    3474:	93 07       	cpc	r25, r19
    3476:	81 f4       	brne	.+32     	; 0x3498 <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    3478:	89 81       	ldd	r24, Y+1	; 0x01
    347a:	9a 81       	ldd	r25, Y+2	; 0x02
    347c:	9c 01       	movw	r18, r24
    347e:	2e 5f       	subi	r18, 0xFE	; 254
    3480:	3f 4f       	sbci	r19, 0xFF	; 255
    3482:	8b ef       	ldi	r24, 0xFB	; 251
    3484:	96 e0       	ldi	r25, 0x06	; 6
    3486:	b9 01       	movw	r22, r18
    3488:	0e 94 b3 0d 	call	0x1b66	; 0x1b66 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    348c:	80 91 a8 06 	lds	r24, 0x06A8
    3490:	8f 5f       	subi	r24, 0xFF	; 255
    3492:	80 93 a8 06 	sts	0x06A8, r24
    3496:	07 c0       	rjmp	.+14     	; 0x34a6 <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    3498:	80 91 a9 06 	lds	r24, 0x06A9
    349c:	81 50       	subi	r24, 0x01	; 1
    349e:	80 93 a9 06 	sts	0x06A9, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    34a2:	0e 94 a8 23 	call	0x4750	; 0x4750 <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    34a6:	0f 90       	pop	r0
    34a8:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    34aa:	20 91 a6 06 	lds	r18, 0x06A6
    34ae:	30 91 a7 06 	lds	r19, 0x06A7
    34b2:	89 81       	ldd	r24, Y+1	; 0x01
    34b4:	9a 81       	ldd	r25, Y+2	; 0x02
    34b6:	82 17       	cp	r24, r18
    34b8:	93 07       	cpc	r25, r19
    34ba:	21 f0       	breq	.+8      	; 0x34c4 <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    34bc:	89 81       	ldd	r24, Y+1	; 0x01
    34be:	9a 81       	ldd	r25, Y+2	; 0x02
    34c0:	0e 94 92 23 	call	0x4724	; 0x4724 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    34c4:	80 91 ad 06 	lds	r24, 0x06AD
    34c8:	88 23       	and	r24, r24
    34ca:	59 f0       	breq	.+22     	; 0x34e2 <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    34cc:	20 91 a6 06 	lds	r18, 0x06A6
    34d0:	30 91 a7 06 	lds	r19, 0x06A7
    34d4:	89 81       	ldd	r24, Y+1	; 0x01
    34d6:	9a 81       	ldd	r25, Y+2	; 0x02
    34d8:	82 17       	cp	r24, r18
    34da:	93 07       	cpc	r25, r19
    34dc:	11 f4       	brne	.+4      	; 0x34e2 <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    34de:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    34e2:	26 96       	adiw	r28, 0x06	; 6
    34e4:	0f b6       	in	r0, 0x3f	; 63
    34e6:	f8 94       	cli
    34e8:	de bf       	out	0x3e, r29	; 62
    34ea:	0f be       	out	0x3f, r0	; 63
    34ec:	cd bf       	out	0x3d, r28	; 61
    34ee:	cf 91       	pop	r28
    34f0:	df 91       	pop	r29
    34f2:	08 95       	ret

000034f4 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    34f4:	df 93       	push	r29
    34f6:	cf 93       	push	r28
    34f8:	cd b7       	in	r28, 0x3d	; 61
    34fa:	de b7       	in	r29, 0x3e	; 62
    34fc:	2a 97       	sbiw	r28, 0x0a	; 10
    34fe:	0f b6       	in	r0, 0x3f	; 63
    3500:	f8 94       	cli
    3502:	de bf       	out	0x3e, r29	; 62
    3504:	0f be       	out	0x3f, r0	; 63
    3506:	cd bf       	out	0x3d, r28	; 61
    3508:	98 87       	std	Y+8, r25	; 0x08
    350a:	8f 83       	std	Y+7, r24	; 0x07
    350c:	7a 87       	std	Y+10, r23	; 0x0a
    350e:	69 87       	std	Y+9, r22	; 0x09
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    3510:	1b 82       	std	Y+3, r1	; 0x03

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    3512:	0e 94 56 1b 	call	0x36ac	; 0x36ac <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    3516:	80 91 aa 06 	lds	r24, 0x06AA
    351a:	90 91 ab 06 	lds	r25, 0x06AB
    351e:	9a 83       	std	Y+2, r25	; 0x02
    3520:	89 83       	std	Y+1, r24	; 0x01

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3522:	ef 81       	ldd	r30, Y+7	; 0x07
    3524:	f8 85       	ldd	r31, Y+8	; 0x08
    3526:	20 81       	ld	r18, Z
    3528:	31 81       	ldd	r19, Z+1	; 0x01
    352a:	89 85       	ldd	r24, Y+9	; 0x09
    352c:	9a 85       	ldd	r25, Y+10	; 0x0a
    352e:	82 0f       	add	r24, r18
    3530:	93 1f       	adc	r25, r19
    3532:	9e 83       	std	Y+6, r25	; 0x06
    3534:	8d 83       	std	Y+5, r24	; 0x05

            if( xConstTickCount < *pxPreviousWakeTime )
    3536:	ef 81       	ldd	r30, Y+7	; 0x07
    3538:	f8 85       	ldd	r31, Y+8	; 0x08
    353a:	20 81       	ld	r18, Z
    353c:	31 81       	ldd	r19, Z+1	; 0x01
    353e:	89 81       	ldd	r24, Y+1	; 0x01
    3540:	9a 81       	ldd	r25, Y+2	; 0x02
    3542:	82 17       	cp	r24, r18
    3544:	93 07       	cpc	r25, r19
    3546:	98 f4       	brcc	.+38     	; 0x356e <xTaskDelayUntil+0x7a>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    3548:	ef 81       	ldd	r30, Y+7	; 0x07
    354a:	f8 85       	ldd	r31, Y+8	; 0x08
    354c:	20 81       	ld	r18, Z
    354e:	31 81       	ldd	r19, Z+1	; 0x01
    3550:	8d 81       	ldd	r24, Y+5	; 0x05
    3552:	9e 81       	ldd	r25, Y+6	; 0x06
    3554:	82 17       	cp	r24, r18
    3556:	93 07       	cpc	r25, r19
    3558:	e0 f4       	brcc	.+56     	; 0x3592 <xTaskDelayUntil+0x9e>
    355a:	2d 81       	ldd	r18, Y+5	; 0x05
    355c:	3e 81       	ldd	r19, Y+6	; 0x06
    355e:	89 81       	ldd	r24, Y+1	; 0x01
    3560:	9a 81       	ldd	r25, Y+2	; 0x02
    3562:	82 17       	cp	r24, r18
    3564:	93 07       	cpc	r25, r19
    3566:	a8 f4       	brcc	.+42     	; 0x3592 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    3568:	81 e0       	ldi	r24, 0x01	; 1
    356a:	8b 83       	std	Y+3, r24	; 0x03
    356c:	12 c0       	rjmp	.+36     	; 0x3592 <xTaskDelayUntil+0x9e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    356e:	ef 81       	ldd	r30, Y+7	; 0x07
    3570:	f8 85       	ldd	r31, Y+8	; 0x08
    3572:	20 81       	ld	r18, Z
    3574:	31 81       	ldd	r19, Z+1	; 0x01
    3576:	8d 81       	ldd	r24, Y+5	; 0x05
    3578:	9e 81       	ldd	r25, Y+6	; 0x06
    357a:	82 17       	cp	r24, r18
    357c:	93 07       	cpc	r25, r19
    357e:	38 f0       	brcs	.+14     	; 0x358e <xTaskDelayUntil+0x9a>
    3580:	2d 81       	ldd	r18, Y+5	; 0x05
    3582:	3e 81       	ldd	r19, Y+6	; 0x06
    3584:	89 81       	ldd	r24, Y+1	; 0x01
    3586:	9a 81       	ldd	r25, Y+2	; 0x02
    3588:	82 17       	cp	r24, r18
    358a:	93 07       	cpc	r25, r19
    358c:	10 f4       	brcc	.+4      	; 0x3592 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    358e:	81 e0       	ldi	r24, 0x01	; 1
    3590:	8b 83       	std	Y+3, r24	; 0x03
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    3592:	ef 81       	ldd	r30, Y+7	; 0x07
    3594:	f8 85       	ldd	r31, Y+8	; 0x08
    3596:	8d 81       	ldd	r24, Y+5	; 0x05
    3598:	9e 81       	ldd	r25, Y+6	; 0x06
    359a:	91 83       	std	Z+1, r25	; 0x01
    359c:	80 83       	st	Z, r24

            if( xShouldDelay != pdFALSE )
    359e:	8b 81       	ldd	r24, Y+3	; 0x03
    35a0:	88 23       	and	r24, r24
    35a2:	49 f0       	breq	.+18     	; 0x35b6 <xTaskDelayUntil+0xc2>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    35a4:	8d 81       	ldd	r24, Y+5	; 0x05
    35a6:	9e 81       	ldd	r25, Y+6	; 0x06
    35a8:	29 81       	ldd	r18, Y+1	; 0x01
    35aa:	3a 81       	ldd	r19, Y+2	; 0x02
    35ac:	82 1b       	sub	r24, r18
    35ae:	93 0b       	sbc	r25, r19
    35b0:	60 e0       	ldi	r22, 0x00	; 0
    35b2:	0e 94 8f 2b 	call	0x571e	; 0x571e <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    35b6:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>
    35ba:	8c 83       	std	Y+4, r24	; 0x04

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    35bc:	8c 81       	ldd	r24, Y+4	; 0x04
    35be:	88 23       	and	r24, r24
    35c0:	11 f4       	brne	.+4      	; 0x35c6 <xTaskDelayUntil+0xd2>
        {
            portYIELD_WITHIN_API();
    35c2:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    35c6:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    35c8:	2a 96       	adiw	r28, 0x0a	; 10
    35ca:	0f b6       	in	r0, 0x3f	; 63
    35cc:	f8 94       	cli
    35ce:	de bf       	out	0x3e, r29	; 62
    35d0:	0f be       	out	0x3f, r0	; 63
    35d2:	cd bf       	out	0x3d, r28	; 61
    35d4:	cf 91       	pop	r28
    35d6:	df 91       	pop	r29
    35d8:	08 95       	ret

000035da <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    35da:	df 93       	push	r29
    35dc:	cf 93       	push	r28
    35de:	00 d0       	rcall	.+0      	; 0x35e0 <vTaskDelay+0x6>
    35e0:	0f 92       	push	r0
    35e2:	cd b7       	in	r28, 0x3d	; 61
    35e4:	de b7       	in	r29, 0x3e	; 62
    35e6:	9b 83       	std	Y+3, r25	; 0x03
    35e8:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    35ea:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    35ec:	8a 81       	ldd	r24, Y+2	; 0x02
    35ee:	9b 81       	ldd	r25, Y+3	; 0x03
    35f0:	00 97       	sbiw	r24, 0x00	; 0
    35f2:	51 f0       	breq	.+20     	; 0x3608 <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    35f4:	0e 94 56 1b 	call	0x36ac	; 0x36ac <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    35f8:	8a 81       	ldd	r24, Y+2	; 0x02
    35fa:	9b 81       	ldd	r25, Y+3	; 0x03
    35fc:	60 e0       	ldi	r22, 0x00	; 0
    35fe:	0e 94 8f 2b 	call	0x571e	; 0x571e <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    3602:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>
    3606:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    3608:	89 81       	ldd	r24, Y+1	; 0x01
    360a:	88 23       	and	r24, r24
    360c:	11 f4       	brne	.+4      	; 0x3612 <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    360e:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    3612:	0f 90       	pop	r0
    3614:	0f 90       	pop	r0
    3616:	0f 90       	pop	r0
    3618:	cf 91       	pop	r28
    361a:	df 91       	pop	r29
    361c:	08 95       	ret

0000361e <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    361e:	ef 92       	push	r14
    3620:	ff 92       	push	r15
    3622:	0f 93       	push	r16
    3624:	df 93       	push	r29
    3626:	cf 93       	push	r28
    3628:	00 d0       	rcall	.+0      	; 0x362a <vTaskStartScheduler+0xc>
    362a:	cd b7       	in	r28, 0x3d	; 61
    362c:	de b7       	in	r29, 0x3e	; 62
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    362e:	86 e1       	ldi	r24, 0x16	; 22
    3630:	93 e2       	ldi	r25, 0x23	; 35
    3632:	20 e6       	ldi	r18, 0x60	; 96
    3634:	30 e0       	ldi	r19, 0x00	; 0
    3636:	e5 eb       	ldi	r30, 0xB5	; 181
    3638:	f6 e0       	ldi	r31, 0x06	; 6
    363a:	b9 01       	movw	r22, r18
    363c:	45 e5       	ldi	r20, 0x55	; 85
    363e:	50 e0       	ldi	r21, 0x00	; 0
    3640:	20 e0       	ldi	r18, 0x00	; 0
    3642:	30 e0       	ldi	r19, 0x00	; 0
    3644:	00 e0       	ldi	r16, 0x00	; 0
    3646:	7f 01       	movw	r14, r30
    3648:	0e 94 05 18 	call	0x300a	; 0x300a <xTaskCreate>
    364c:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
        {
            if( xReturn == pdPASS )
    364e:	89 81       	ldd	r24, Y+1	; 0x01
    3650:	81 30       	cpi	r24, 0x01	; 1
    3652:	19 f4       	brne	.+6      	; 0x365a <vTaskStartScheduler+0x3c>
            {
                xReturn = xTimerCreateTimerTask();
    3654:	0e 94 f5 2b 	call	0x57ea	; 0x57ea <xTimerCreateTimerTask>
    3658:	89 83       	std	Y+1, r24	; 0x01
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    365a:	89 81       	ldd	r24, Y+1	; 0x01
    365c:	81 30       	cpi	r24, 0x01	; 1
    365e:	81 f4       	brne	.+32     	; 0x3680 <vTaskStartScheduler+0x62>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    3660:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    3662:	8f ef       	ldi	r24, 0xFF	; 255
    3664:	9f ef       	ldi	r25, 0xFF	; 255
    3666:	90 93 b4 06 	sts	0x06B4, r25
    366a:	80 93 b3 06 	sts	0x06B3, r24
        xSchedulerRunning = pdTRUE;
    366e:	81 e0       	ldi	r24, 0x01	; 1
    3670:	80 93 ad 06 	sts	0x06AD, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    3674:	10 92 ab 06 	sts	0x06AB, r1
    3678:	10 92 aa 06 	sts	0x06AA, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    367c:	0e 94 4c 02 	call	0x498	; 0x498 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    3680:	80 91 8a 00 	lds	r24, 0x008A
}
    3684:	0f 90       	pop	r0
    3686:	0f 90       	pop	r0
    3688:	cf 91       	pop	r28
    368a:	df 91       	pop	r29
    368c:	0f 91       	pop	r16
    368e:	ff 90       	pop	r15
    3690:	ef 90       	pop	r14
    3692:	08 95       	ret

00003694 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3694:	df 93       	push	r29
    3696:	cf 93       	push	r28
    3698:	cd b7       	in	r28, 0x3d	; 61
    369a:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    369c:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    369e:	10 92 ad 06 	sts	0x06AD, r1
    vPortEndScheduler();
    36a2:	0e 94 81 02 	call	0x502	; 0x502 <vPortEndScheduler>
}
    36a6:	cf 91       	pop	r28
    36a8:	df 91       	pop	r29
    36aa:	08 95       	ret

000036ac <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    36ac:	df 93       	push	r29
    36ae:	cf 93       	push	r28
    36b0:	cd b7       	in	r28, 0x3d	; 61
    36b2:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    36b4:	80 91 b7 06 	lds	r24, 0x06B7
    36b8:	8f 5f       	subi	r24, 0xFF	; 255
    36ba:	80 93 b7 06 	sts	0x06B7, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    36be:	cf 91       	pop	r28
    36c0:	df 91       	pop	r29
    36c2:	08 95       	ret

000036c4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    36c4:	df 93       	push	r29
    36c6:	cf 93       	push	r28
    36c8:	cd b7       	in	r28, 0x3d	; 61
    36ca:	de b7       	in	r29, 0x3e	; 62
    36cc:	2b 97       	sbiw	r28, 0x0b	; 11
    36ce:	0f b6       	in	r0, 0x3f	; 63
    36d0:	f8 94       	cli
    36d2:	de bf       	out	0x3e, r29	; 62
    36d4:	0f be       	out	0x3f, r0	; 63
    36d6:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    36d8:	1b 86       	std	Y+11, r1	; 0x0b
    36da:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    36dc:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    36de:	0f b6       	in	r0, 0x3f	; 63
    36e0:	f8 94       	cli
    36e2:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    36e4:	80 91 b7 06 	lds	r24, 0x06B7
    36e8:	81 50       	subi	r24, 0x01	; 1
    36ea:	80 93 b7 06 	sts	0x06B7, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    36ee:	80 91 b7 06 	lds	r24, 0x06B7
    36f2:	88 23       	and	r24, r24
    36f4:	09 f0       	breq	.+2      	; 0x36f8 <xTaskResumeAll+0x34>
    36f6:	2a c1       	rjmp	.+596    	; 0x394c <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    36f8:	80 91 a9 06 	lds	r24, 0x06A9
    36fc:	88 23       	and	r24, r24
    36fe:	09 f4       	brne	.+2      	; 0x3702 <xTaskResumeAll+0x3e>
    3700:	25 c1       	rjmp	.+586    	; 0x394c <xTaskResumeAll+0x288>
    3702:	f3 c0       	rjmp	.+486    	; 0x38ea <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3704:	e0 91 f7 06 	lds	r30, 0x06F7
    3708:	f0 91 f8 06 	lds	r31, 0x06F8
    370c:	86 81       	ldd	r24, Z+6	; 0x06
    370e:	97 81       	ldd	r25, Z+7	; 0x07
    3710:	9b 87       	std	Y+11, r25	; 0x0b
    3712:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3714:	ea 85       	ldd	r30, Y+10	; 0x0a
    3716:	fb 85       	ldd	r31, Y+11	; 0x0b
    3718:	84 89       	ldd	r24, Z+20	; 0x14
    371a:	95 89       	ldd	r25, Z+21	; 0x15
    371c:	98 87       	std	Y+8, r25	; 0x08
    371e:	8f 83       	std	Y+7, r24	; 0x07
    3720:	ea 85       	ldd	r30, Y+10	; 0x0a
    3722:	fb 85       	ldd	r31, Y+11	; 0x0b
    3724:	a6 85       	ldd	r26, Z+14	; 0x0e
    3726:	b7 85       	ldd	r27, Z+15	; 0x0f
    3728:	ea 85       	ldd	r30, Y+10	; 0x0a
    372a:	fb 85       	ldd	r31, Y+11	; 0x0b
    372c:	80 89       	ldd	r24, Z+16	; 0x10
    372e:	91 89       	ldd	r25, Z+17	; 0x11
    3730:	15 96       	adiw	r26, 0x05	; 5
    3732:	9c 93       	st	X, r25
    3734:	8e 93       	st	-X, r24
    3736:	14 97       	sbiw	r26, 0x04	; 4
    3738:	ea 85       	ldd	r30, Y+10	; 0x0a
    373a:	fb 85       	ldd	r31, Y+11	; 0x0b
    373c:	a0 89       	ldd	r26, Z+16	; 0x10
    373e:	b1 89       	ldd	r27, Z+17	; 0x11
    3740:	ea 85       	ldd	r30, Y+10	; 0x0a
    3742:	fb 85       	ldd	r31, Y+11	; 0x0b
    3744:	86 85       	ldd	r24, Z+14	; 0x0e
    3746:	97 85       	ldd	r25, Z+15	; 0x0f
    3748:	13 96       	adiw	r26, 0x03	; 3
    374a:	9c 93       	st	X, r25
    374c:	8e 93       	st	-X, r24
    374e:	12 97       	sbiw	r26, 0x02	; 2
    3750:	ef 81       	ldd	r30, Y+7	; 0x07
    3752:	f8 85       	ldd	r31, Y+8	; 0x08
    3754:	21 81       	ldd	r18, Z+1	; 0x01
    3756:	32 81       	ldd	r19, Z+2	; 0x02
    3758:	8a 85       	ldd	r24, Y+10	; 0x0a
    375a:	9b 85       	ldd	r25, Y+11	; 0x0b
    375c:	0c 96       	adiw	r24, 0x0c	; 12
    375e:	28 17       	cp	r18, r24
    3760:	39 07       	cpc	r19, r25
    3762:	41 f4       	brne	.+16     	; 0x3774 <xTaskResumeAll+0xb0>
    3764:	ea 85       	ldd	r30, Y+10	; 0x0a
    3766:	fb 85       	ldd	r31, Y+11	; 0x0b
    3768:	80 89       	ldd	r24, Z+16	; 0x10
    376a:	91 89       	ldd	r25, Z+17	; 0x11
    376c:	ef 81       	ldd	r30, Y+7	; 0x07
    376e:	f8 85       	ldd	r31, Y+8	; 0x08
    3770:	92 83       	std	Z+2, r25	; 0x02
    3772:	81 83       	std	Z+1, r24	; 0x01
    3774:	ea 85       	ldd	r30, Y+10	; 0x0a
    3776:	fb 85       	ldd	r31, Y+11	; 0x0b
    3778:	15 8a       	std	Z+21, r1	; 0x15
    377a:	14 8a       	std	Z+20, r1	; 0x14
    377c:	ef 81       	ldd	r30, Y+7	; 0x07
    377e:	f8 85       	ldd	r31, Y+8	; 0x08
    3780:	80 81       	ld	r24, Z
    3782:	81 50       	subi	r24, 0x01	; 1
    3784:	ef 81       	ldd	r30, Y+7	; 0x07
    3786:	f8 85       	ldd	r31, Y+8	; 0x08
    3788:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    378a:	ea 85       	ldd	r30, Y+10	; 0x0a
    378c:	fb 85       	ldd	r31, Y+11	; 0x0b
    378e:	82 85       	ldd	r24, Z+10	; 0x0a
    3790:	93 85       	ldd	r25, Z+11	; 0x0b
    3792:	9e 83       	std	Y+6, r25	; 0x06
    3794:	8d 83       	std	Y+5, r24	; 0x05
    3796:	ea 85       	ldd	r30, Y+10	; 0x0a
    3798:	fb 85       	ldd	r31, Y+11	; 0x0b
    379a:	a4 81       	ldd	r26, Z+4	; 0x04
    379c:	b5 81       	ldd	r27, Z+5	; 0x05
    379e:	ea 85       	ldd	r30, Y+10	; 0x0a
    37a0:	fb 85       	ldd	r31, Y+11	; 0x0b
    37a2:	86 81       	ldd	r24, Z+6	; 0x06
    37a4:	97 81       	ldd	r25, Z+7	; 0x07
    37a6:	15 96       	adiw	r26, 0x05	; 5
    37a8:	9c 93       	st	X, r25
    37aa:	8e 93       	st	-X, r24
    37ac:	14 97       	sbiw	r26, 0x04	; 4
    37ae:	ea 85       	ldd	r30, Y+10	; 0x0a
    37b0:	fb 85       	ldd	r31, Y+11	; 0x0b
    37b2:	a6 81       	ldd	r26, Z+6	; 0x06
    37b4:	b7 81       	ldd	r27, Z+7	; 0x07
    37b6:	ea 85       	ldd	r30, Y+10	; 0x0a
    37b8:	fb 85       	ldd	r31, Y+11	; 0x0b
    37ba:	84 81       	ldd	r24, Z+4	; 0x04
    37bc:	95 81       	ldd	r25, Z+5	; 0x05
    37be:	13 96       	adiw	r26, 0x03	; 3
    37c0:	9c 93       	st	X, r25
    37c2:	8e 93       	st	-X, r24
    37c4:	12 97       	sbiw	r26, 0x02	; 2
    37c6:	ed 81       	ldd	r30, Y+5	; 0x05
    37c8:	fe 81       	ldd	r31, Y+6	; 0x06
    37ca:	21 81       	ldd	r18, Z+1	; 0x01
    37cc:	32 81       	ldd	r19, Z+2	; 0x02
    37ce:	8a 85       	ldd	r24, Y+10	; 0x0a
    37d0:	9b 85       	ldd	r25, Y+11	; 0x0b
    37d2:	02 96       	adiw	r24, 0x02	; 2
    37d4:	28 17       	cp	r18, r24
    37d6:	39 07       	cpc	r19, r25
    37d8:	41 f4       	brne	.+16     	; 0x37ea <xTaskResumeAll+0x126>
    37da:	ea 85       	ldd	r30, Y+10	; 0x0a
    37dc:	fb 85       	ldd	r31, Y+11	; 0x0b
    37de:	86 81       	ldd	r24, Z+6	; 0x06
    37e0:	97 81       	ldd	r25, Z+7	; 0x07
    37e2:	ed 81       	ldd	r30, Y+5	; 0x05
    37e4:	fe 81       	ldd	r31, Y+6	; 0x06
    37e6:	92 83       	std	Z+2, r25	; 0x02
    37e8:	81 83       	std	Z+1, r24	; 0x01
    37ea:	ea 85       	ldd	r30, Y+10	; 0x0a
    37ec:	fb 85       	ldd	r31, Y+11	; 0x0b
    37ee:	13 86       	std	Z+11, r1	; 0x0b
    37f0:	12 86       	std	Z+10, r1	; 0x0a
    37f2:	ed 81       	ldd	r30, Y+5	; 0x05
    37f4:	fe 81       	ldd	r31, Y+6	; 0x06
    37f6:	80 81       	ld	r24, Z
    37f8:	81 50       	subi	r24, 0x01	; 1
    37fa:	ed 81       	ldd	r30, Y+5	; 0x05
    37fc:	fe 81       	ldd	r31, Y+6	; 0x06
    37fe:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    3800:	ea 85       	ldd	r30, Y+10	; 0x0a
    3802:	fb 85       	ldd	r31, Y+11	; 0x0b
    3804:	96 89       	ldd	r25, Z+22	; 0x16
    3806:	80 91 ac 06 	lds	r24, 0x06AC
    380a:	89 17       	cp	r24, r25
    380c:	28 f4       	brcc	.+10     	; 0x3818 <xTaskResumeAll+0x154>
    380e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3810:	fb 85       	ldd	r31, Y+11	; 0x0b
    3812:	86 89       	ldd	r24, Z+22	; 0x16
    3814:	80 93 ac 06 	sts	0x06AC, r24
    3818:	ea 85       	ldd	r30, Y+10	; 0x0a
    381a:	fb 85       	ldd	r31, Y+11	; 0x0b
    381c:	86 89       	ldd	r24, Z+22	; 0x16
    381e:	28 2f       	mov	r18, r24
    3820:	30 e0       	ldi	r19, 0x00	; 0
    3822:	c9 01       	movw	r24, r18
    3824:	88 0f       	add	r24, r24
    3826:	99 1f       	adc	r25, r25
    3828:	88 0f       	add	r24, r24
    382a:	99 1f       	adc	r25, r25
    382c:	88 0f       	add	r24, r24
    382e:	99 1f       	adc	r25, r25
    3830:	82 0f       	add	r24, r18
    3832:	93 1f       	adc	r25, r19
    3834:	fc 01       	movw	r30, r24
    3836:	e8 54       	subi	r30, 0x48	; 72
    3838:	f9 4f       	sbci	r31, 0xF9	; 249
    383a:	81 81       	ldd	r24, Z+1	; 0x01
    383c:	92 81       	ldd	r25, Z+2	; 0x02
    383e:	9c 83       	std	Y+4, r25	; 0x04
    3840:	8b 83       	std	Y+3, r24	; 0x03
    3842:	ea 85       	ldd	r30, Y+10	; 0x0a
    3844:	fb 85       	ldd	r31, Y+11	; 0x0b
    3846:	8b 81       	ldd	r24, Y+3	; 0x03
    3848:	9c 81       	ldd	r25, Y+4	; 0x04
    384a:	95 83       	std	Z+5, r25	; 0x05
    384c:	84 83       	std	Z+4, r24	; 0x04
    384e:	eb 81       	ldd	r30, Y+3	; 0x03
    3850:	fc 81       	ldd	r31, Y+4	; 0x04
    3852:	84 81       	ldd	r24, Z+4	; 0x04
    3854:	95 81       	ldd	r25, Z+5	; 0x05
    3856:	ea 85       	ldd	r30, Y+10	; 0x0a
    3858:	fb 85       	ldd	r31, Y+11	; 0x0b
    385a:	97 83       	std	Z+7, r25	; 0x07
    385c:	86 83       	std	Z+6, r24	; 0x06
    385e:	eb 81       	ldd	r30, Y+3	; 0x03
    3860:	fc 81       	ldd	r31, Y+4	; 0x04
    3862:	04 80       	ldd	r0, Z+4	; 0x04
    3864:	f5 81       	ldd	r31, Z+5	; 0x05
    3866:	e0 2d       	mov	r30, r0
    3868:	8a 85       	ldd	r24, Y+10	; 0x0a
    386a:	9b 85       	ldd	r25, Y+11	; 0x0b
    386c:	02 96       	adiw	r24, 0x02	; 2
    386e:	93 83       	std	Z+3, r25	; 0x03
    3870:	82 83       	std	Z+2, r24	; 0x02
    3872:	8a 85       	ldd	r24, Y+10	; 0x0a
    3874:	9b 85       	ldd	r25, Y+11	; 0x0b
    3876:	02 96       	adiw	r24, 0x02	; 2
    3878:	eb 81       	ldd	r30, Y+3	; 0x03
    387a:	fc 81       	ldd	r31, Y+4	; 0x04
    387c:	95 83       	std	Z+5, r25	; 0x05
    387e:	84 83       	std	Z+4, r24	; 0x04
    3880:	ea 85       	ldd	r30, Y+10	; 0x0a
    3882:	fb 85       	ldd	r31, Y+11	; 0x0b
    3884:	86 89       	ldd	r24, Z+22	; 0x16
    3886:	28 2f       	mov	r18, r24
    3888:	30 e0       	ldi	r19, 0x00	; 0
    388a:	c9 01       	movw	r24, r18
    388c:	88 0f       	add	r24, r24
    388e:	99 1f       	adc	r25, r25
    3890:	88 0f       	add	r24, r24
    3892:	99 1f       	adc	r25, r25
    3894:	88 0f       	add	r24, r24
    3896:	99 1f       	adc	r25, r25
    3898:	82 0f       	add	r24, r18
    389a:	93 1f       	adc	r25, r19
    389c:	88 54       	subi	r24, 0x48	; 72
    389e:	99 4f       	sbci	r25, 0xF9	; 249
    38a0:	ea 85       	ldd	r30, Y+10	; 0x0a
    38a2:	fb 85       	ldd	r31, Y+11	; 0x0b
    38a4:	93 87       	std	Z+11, r25	; 0x0b
    38a6:	82 87       	std	Z+10, r24	; 0x0a
    38a8:	ea 85       	ldd	r30, Y+10	; 0x0a
    38aa:	fb 85       	ldd	r31, Y+11	; 0x0b
    38ac:	86 89       	ldd	r24, Z+22	; 0x16
    38ae:	28 2f       	mov	r18, r24
    38b0:	30 e0       	ldi	r19, 0x00	; 0
    38b2:	c9 01       	movw	r24, r18
    38b4:	88 0f       	add	r24, r24
    38b6:	99 1f       	adc	r25, r25
    38b8:	88 0f       	add	r24, r24
    38ba:	99 1f       	adc	r25, r25
    38bc:	88 0f       	add	r24, r24
    38be:	99 1f       	adc	r25, r25
    38c0:	82 0f       	add	r24, r18
    38c2:	93 1f       	adc	r25, r19
    38c4:	fc 01       	movw	r30, r24
    38c6:	e8 54       	subi	r30, 0x48	; 72
    38c8:	f9 4f       	sbci	r31, 0xF9	; 249
    38ca:	80 81       	ld	r24, Z
    38cc:	8f 5f       	subi	r24, 0xFF	; 255
    38ce:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    38d0:	ea 85       	ldd	r30, Y+10	; 0x0a
    38d2:	fb 85       	ldd	r31, Y+11	; 0x0b
    38d4:	96 89       	ldd	r25, Z+22	; 0x16
    38d6:	e0 91 a6 06 	lds	r30, 0x06A6
    38da:	f0 91 a7 06 	lds	r31, 0x06A7
    38de:	86 89       	ldd	r24, Z+22	; 0x16
    38e0:	98 17       	cp	r25, r24
    38e2:	18 f0       	brcs	.+6      	; 0x38ea <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    38e4:	81 e0       	ldi	r24, 0x01	; 1
    38e6:	80 93 b0 06 	sts	0x06B0, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    38ea:	80 91 f2 06 	lds	r24, 0x06F2
    38ee:	88 23       	and	r24, r24
    38f0:	09 f0       	breq	.+2      	; 0x38f4 <xTaskResumeAll+0x230>
    38f2:	08 cf       	rjmp	.-496    	; 0x3704 <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    38f4:	8a 85       	ldd	r24, Y+10	; 0x0a
    38f6:	9b 85       	ldd	r25, Y+11	; 0x0b
    38f8:	00 97       	sbiw	r24, 0x00	; 0
    38fa:	11 f0       	breq	.+4      	; 0x3900 <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    38fc:	0e 94 a8 23 	call	0x4750	; 0x4750 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    3900:	80 91 ae 06 	lds	r24, 0x06AE
    3904:	90 91 af 06 	lds	r25, 0x06AF
    3908:	9a 83       	std	Y+2, r25	; 0x02
    390a:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    390c:	89 81       	ldd	r24, Y+1	; 0x01
    390e:	9a 81       	ldd	r25, Y+2	; 0x02
    3910:	00 97       	sbiw	r24, 0x00	; 0
    3912:	a1 f0       	breq	.+40     	; 0x393c <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    3914:	0e 94 2f 1d 	call	0x3a5e	; 0x3a5e <xTaskIncrementTick>
    3918:	88 23       	and	r24, r24
    391a:	19 f0       	breq	.+6      	; 0x3922 <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    391c:	81 e0       	ldi	r24, 0x01	; 1
    391e:	80 93 b0 06 	sts	0x06B0, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    3922:	89 81       	ldd	r24, Y+1	; 0x01
    3924:	9a 81       	ldd	r25, Y+2	; 0x02
    3926:	01 97       	sbiw	r24, 0x01	; 1
    3928:	9a 83       	std	Y+2, r25	; 0x02
    392a:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    392c:	89 81       	ldd	r24, Y+1	; 0x01
    392e:	9a 81       	ldd	r25, Y+2	; 0x02
    3930:	00 97       	sbiw	r24, 0x00	; 0
    3932:	81 f7       	brne	.-32     	; 0x3914 <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    3934:	10 92 af 06 	sts	0x06AF, r1
    3938:	10 92 ae 06 	sts	0x06AE, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    393c:	80 91 b0 06 	lds	r24, 0x06B0
    3940:	88 23       	and	r24, r24
    3942:	21 f0       	breq	.+8      	; 0x394c <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    3944:	81 e0       	ldi	r24, 0x01	; 1
    3946:	89 87       	std	Y+9, r24	; 0x09
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    3948:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    394c:	0f 90       	pop	r0
    394e:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    3950:	89 85       	ldd	r24, Y+9	; 0x09
}
    3952:	2b 96       	adiw	r28, 0x0b	; 11
    3954:	0f b6       	in	r0, 0x3f	; 63
    3956:	f8 94       	cli
    3958:	de bf       	out	0x3e, r29	; 62
    395a:	0f be       	out	0x3f, r0	; 63
    395c:	cd bf       	out	0x3d, r28	; 61
    395e:	cf 91       	pop	r28
    3960:	df 91       	pop	r29
    3962:	08 95       	ret

00003964 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3964:	df 93       	push	r29
    3966:	cf 93       	push	r28
    3968:	00 d0       	rcall	.+0      	; 0x396a <xTaskGetTickCount+0x6>
    396a:	cd b7       	in	r28, 0x3d	; 61
    396c:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    396e:	0f b6       	in	r0, 0x3f	; 63
    3970:	f8 94       	cli
    3972:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    3974:	80 91 aa 06 	lds	r24, 0x06AA
    3978:	90 91 ab 06 	lds	r25, 0x06AB
    397c:	9a 83       	std	Y+2, r25	; 0x02
    397e:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    3980:	0f 90       	pop	r0
    3982:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    3984:	89 81       	ldd	r24, Y+1	; 0x01
    3986:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3988:	0f 90       	pop	r0
    398a:	0f 90       	pop	r0
    398c:	cf 91       	pop	r28
    398e:	df 91       	pop	r29
    3990:	08 95       	ret

00003992 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3992:	df 93       	push	r29
    3994:	cf 93       	push	r28
    3996:	00 d0       	rcall	.+0      	; 0x3998 <xTaskGetTickCountFromISR+0x6>
    3998:	0f 92       	push	r0
    399a:	cd b7       	in	r28, 0x3d	; 61
    399c:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    399e:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    39a0:	80 91 aa 06 	lds	r24, 0x06AA
    39a4:	90 91 ab 06 	lds	r25, 0x06AB
    39a8:	9b 83       	std	Y+3, r25	; 0x03
    39aa:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    39ac:	8a 81       	ldd	r24, Y+2	; 0x02
    39ae:	9b 81       	ldd	r25, Y+3	; 0x03
}
    39b0:	0f 90       	pop	r0
    39b2:	0f 90       	pop	r0
    39b4:	0f 90       	pop	r0
    39b6:	cf 91       	pop	r28
    39b8:	df 91       	pop	r29
    39ba:	08 95       	ret

000039bc <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    39bc:	df 93       	push	r29
    39be:	cf 93       	push	r28
    39c0:	cd b7       	in	r28, 0x3d	; 61
    39c2:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    39c4:	80 91 a9 06 	lds	r24, 0x06A9
}
    39c8:	cf 91       	pop	r28
    39ca:	df 91       	pop	r29
    39cc:	08 95       	ret

000039ce <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    39ce:	df 93       	push	r29
    39d0:	cf 93       	push	r28
    39d2:	00 d0       	rcall	.+0      	; 0x39d4 <pcTaskGetName+0x6>
    39d4:	00 d0       	rcall	.+0      	; 0x39d6 <pcTaskGetName+0x8>
    39d6:	00 d0       	rcall	.+0      	; 0x39d8 <pcTaskGetName+0xa>
    39d8:	cd b7       	in	r28, 0x3d	; 61
    39da:	de b7       	in	r29, 0x3e	; 62
    39dc:	9c 83       	std	Y+4, r25	; 0x04
    39de:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    39e0:	8b 81       	ldd	r24, Y+3	; 0x03
    39e2:	9c 81       	ldd	r25, Y+4	; 0x04
    39e4:	00 97       	sbiw	r24, 0x00	; 0
    39e6:	39 f4       	brne	.+14     	; 0x39f6 <pcTaskGetName+0x28>
    39e8:	80 91 a6 06 	lds	r24, 0x06A6
    39ec:	90 91 a7 06 	lds	r25, 0x06A7
    39f0:	9e 83       	std	Y+6, r25	; 0x06
    39f2:	8d 83       	std	Y+5, r24	; 0x05
    39f4:	04 c0       	rjmp	.+8      	; 0x39fe <pcTaskGetName+0x30>
    39f6:	8b 81       	ldd	r24, Y+3	; 0x03
    39f8:	9c 81       	ldd	r25, Y+4	; 0x04
    39fa:	9e 83       	std	Y+6, r25	; 0x06
    39fc:	8d 83       	std	Y+5, r24	; 0x05
    39fe:	8d 81       	ldd	r24, Y+5	; 0x05
    3a00:	9e 81       	ldd	r25, Y+6	; 0x06
    3a02:	9a 83       	std	Y+2, r25	; 0x02
    3a04:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    3a06:	89 81       	ldd	r24, Y+1	; 0x01
    3a08:	9a 81       	ldd	r25, Y+2	; 0x02
    3a0a:	49 96       	adiw	r24, 0x19	; 25
}
    3a0c:	26 96       	adiw	r28, 0x06	; 6
    3a0e:	0f b6       	in	r0, 0x3f	; 63
    3a10:	f8 94       	cli
    3a12:	de bf       	out	0x3e, r29	; 62
    3a14:	0f be       	out	0x3f, r0	; 63
    3a16:	cd bf       	out	0x3d, r28	; 61
    3a18:	cf 91       	pop	r28
    3a1a:	df 91       	pop	r29
    3a1c:	08 95       	ret

00003a1e <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    3a1e:	df 93       	push	r29
    3a20:	cf 93       	push	r28
    3a22:	00 d0       	rcall	.+0      	; 0x3a24 <xTaskCatchUpTicks+0x6>
    3a24:	0f 92       	push	r0
    3a26:	cd b7       	in	r28, 0x3d	; 61
    3a28:	de b7       	in	r29, 0x3e	; 62
    3a2a:	9b 83       	std	Y+3, r25	; 0x03
    3a2c:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    3a2e:	0e 94 56 1b 	call	0x36ac	; 0x36ac <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
    3a32:	20 91 ae 06 	lds	r18, 0x06AE
    3a36:	30 91 af 06 	lds	r19, 0x06AF
    3a3a:	8a 81       	ldd	r24, Y+2	; 0x02
    3a3c:	9b 81       	ldd	r25, Y+3	; 0x03
    3a3e:	82 0f       	add	r24, r18
    3a40:	93 1f       	adc	r25, r19
    3a42:	90 93 af 06 	sts	0x06AF, r25
    3a46:	80 93 ae 06 	sts	0x06AE, r24
    xYieldOccurred = xTaskResumeAll();
    3a4a:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>
    3a4e:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    3a50:	89 81       	ldd	r24, Y+1	; 0x01
}
    3a52:	0f 90       	pop	r0
    3a54:	0f 90       	pop	r0
    3a56:	0f 90       	pop	r0
    3a58:	cf 91       	pop	r28
    3a5a:	df 91       	pop	r29
    3a5c:	08 95       	ret

00003a5e <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3a5e:	df 93       	push	r29
    3a60:	cf 93       	push	r28
    3a62:	cd b7       	in	r28, 0x3d	; 61
    3a64:	de b7       	in	r29, 0x3e	; 62
    3a66:	2f 97       	sbiw	r28, 0x0f	; 15
    3a68:	0f b6       	in	r0, 0x3f	; 63
    3a6a:	f8 94       	cli
    3a6c:	de bf       	out	0x3e, r29	; 62
    3a6e:	0f be       	out	0x3f, r0	; 63
    3a70:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    3a72:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3a74:	80 91 b7 06 	lds	r24, 0x06B7
    3a78:	88 23       	and	r24, r24
    3a7a:	09 f0       	breq	.+2      	; 0x3a7e <xTaskIncrementTick+0x20>
    3a7c:	74 c1       	rjmp	.+744    	; 0x3d66 <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    3a7e:	80 91 aa 06 	lds	r24, 0x06AA
    3a82:	90 91 ab 06 	lds	r25, 0x06AB
    3a86:	01 96       	adiw	r24, 0x01	; 1
    3a88:	9a 87       	std	Y+10, r25	; 0x0a
    3a8a:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    3a8c:	89 85       	ldd	r24, Y+9	; 0x09
    3a8e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3a90:	90 93 ab 06 	sts	0x06AB, r25
    3a94:	80 93 aa 06 	sts	0x06AA, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    3a98:	89 85       	ldd	r24, Y+9	; 0x09
    3a9a:	9a 85       	ldd	r25, Y+10	; 0x0a
    3a9c:	00 97       	sbiw	r24, 0x00	; 0
    3a9e:	d9 f4       	brne	.+54     	; 0x3ad6 <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    3aa0:	80 91 ee 06 	lds	r24, 0x06EE
    3aa4:	90 91 ef 06 	lds	r25, 0x06EF
    3aa8:	98 87       	std	Y+8, r25	; 0x08
    3aaa:	8f 83       	std	Y+7, r24	; 0x07
    3aac:	80 91 f0 06 	lds	r24, 0x06F0
    3ab0:	90 91 f1 06 	lds	r25, 0x06F1
    3ab4:	90 93 ef 06 	sts	0x06EF, r25
    3ab8:	80 93 ee 06 	sts	0x06EE, r24
    3abc:	8f 81       	ldd	r24, Y+7	; 0x07
    3abe:	98 85       	ldd	r25, Y+8	; 0x08
    3ac0:	90 93 f1 06 	sts	0x06F1, r25
    3ac4:	80 93 f0 06 	sts	0x06F0, r24
    3ac8:	80 91 b1 06 	lds	r24, 0x06B1
    3acc:	8f 5f       	subi	r24, 0xFF	; 255
    3ace:	80 93 b1 06 	sts	0x06B1, r24
    3ad2:	0e 94 a8 23 	call	0x4750	; 0x4750 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    3ad6:	20 91 b3 06 	lds	r18, 0x06B3
    3ada:	30 91 b4 06 	lds	r19, 0x06B4
    3ade:	89 85       	ldd	r24, Y+9	; 0x09
    3ae0:	9a 85       	ldd	r25, Y+10	; 0x0a
    3ae2:	82 17       	cp	r24, r18
    3ae4:	93 07       	cpc	r25, r19
    3ae6:	08 f4       	brcc	.+2      	; 0x3aea <xTaskIncrementTick+0x8c>
    3ae8:	1f c1       	rjmp	.+574    	; 0x3d28 <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3aea:	e0 91 ee 06 	lds	r30, 0x06EE
    3aee:	f0 91 ef 06 	lds	r31, 0x06EF
    3af2:	80 81       	ld	r24, Z
    3af4:	88 23       	and	r24, r24
    3af6:	39 f4       	brne	.+14     	; 0x3b06 <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3af8:	8f ef       	ldi	r24, 0xFF	; 255
    3afa:	9f ef       	ldi	r25, 0xFF	; 255
    3afc:	90 93 b4 06 	sts	0x06B4, r25
    3b00:	80 93 b3 06 	sts	0x06B3, r24
    3b04:	11 c1       	rjmp	.+546    	; 0x3d28 <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3b06:	e0 91 ee 06 	lds	r30, 0x06EE
    3b0a:	f0 91 ef 06 	lds	r31, 0x06EF
    3b0e:	05 80       	ldd	r0, Z+5	; 0x05
    3b10:	f6 81       	ldd	r31, Z+6	; 0x06
    3b12:	e0 2d       	mov	r30, r0
    3b14:	86 81       	ldd	r24, Z+6	; 0x06
    3b16:	97 81       	ldd	r25, Z+7	; 0x07
    3b18:	9f 87       	std	Y+15, r25	; 0x0f
    3b1a:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    3b1c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b1e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b20:	82 81       	ldd	r24, Z+2	; 0x02
    3b22:	93 81       	ldd	r25, Z+3	; 0x03
    3b24:	9d 87       	std	Y+13, r25	; 0x0d
    3b26:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    3b28:	29 85       	ldd	r18, Y+9	; 0x09
    3b2a:	3a 85       	ldd	r19, Y+10	; 0x0a
    3b2c:	8c 85       	ldd	r24, Y+12	; 0x0c
    3b2e:	9d 85       	ldd	r25, Y+13	; 0x0d
    3b30:	28 17       	cp	r18, r24
    3b32:	39 07       	cpc	r19, r25
    3b34:	38 f4       	brcc	.+14     	; 0x3b44 <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    3b36:	8c 85       	ldd	r24, Y+12	; 0x0c
    3b38:	9d 85       	ldd	r25, Y+13	; 0x0d
    3b3a:	90 93 b4 06 	sts	0x06B4, r25
    3b3e:	80 93 b3 06 	sts	0x06B3, r24
    3b42:	f2 c0       	rjmp	.+484    	; 0x3d28 <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3b44:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b46:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b48:	82 85       	ldd	r24, Z+10	; 0x0a
    3b4a:	93 85       	ldd	r25, Z+11	; 0x0b
    3b4c:	9e 83       	std	Y+6, r25	; 0x06
    3b4e:	8d 83       	std	Y+5, r24	; 0x05
    3b50:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b52:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b54:	a4 81       	ldd	r26, Z+4	; 0x04
    3b56:	b5 81       	ldd	r27, Z+5	; 0x05
    3b58:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b5a:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b5c:	86 81       	ldd	r24, Z+6	; 0x06
    3b5e:	97 81       	ldd	r25, Z+7	; 0x07
    3b60:	15 96       	adiw	r26, 0x05	; 5
    3b62:	9c 93       	st	X, r25
    3b64:	8e 93       	st	-X, r24
    3b66:	14 97       	sbiw	r26, 0x04	; 4
    3b68:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b6a:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b6c:	a6 81       	ldd	r26, Z+6	; 0x06
    3b6e:	b7 81       	ldd	r27, Z+7	; 0x07
    3b70:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b72:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b74:	84 81       	ldd	r24, Z+4	; 0x04
    3b76:	95 81       	ldd	r25, Z+5	; 0x05
    3b78:	13 96       	adiw	r26, 0x03	; 3
    3b7a:	9c 93       	st	X, r25
    3b7c:	8e 93       	st	-X, r24
    3b7e:	12 97       	sbiw	r26, 0x02	; 2
    3b80:	ed 81       	ldd	r30, Y+5	; 0x05
    3b82:	fe 81       	ldd	r31, Y+6	; 0x06
    3b84:	21 81       	ldd	r18, Z+1	; 0x01
    3b86:	32 81       	ldd	r19, Z+2	; 0x02
    3b88:	8e 85       	ldd	r24, Y+14	; 0x0e
    3b8a:	9f 85       	ldd	r25, Y+15	; 0x0f
    3b8c:	02 96       	adiw	r24, 0x02	; 2
    3b8e:	28 17       	cp	r18, r24
    3b90:	39 07       	cpc	r19, r25
    3b92:	41 f4       	brne	.+16     	; 0x3ba4 <xTaskIncrementTick+0x146>
    3b94:	ee 85       	ldd	r30, Y+14	; 0x0e
    3b96:	ff 85       	ldd	r31, Y+15	; 0x0f
    3b98:	86 81       	ldd	r24, Z+6	; 0x06
    3b9a:	97 81       	ldd	r25, Z+7	; 0x07
    3b9c:	ed 81       	ldd	r30, Y+5	; 0x05
    3b9e:	fe 81       	ldd	r31, Y+6	; 0x06
    3ba0:	92 83       	std	Z+2, r25	; 0x02
    3ba2:	81 83       	std	Z+1, r24	; 0x01
    3ba4:	ee 85       	ldd	r30, Y+14	; 0x0e
    3ba6:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ba8:	13 86       	std	Z+11, r1	; 0x0b
    3baa:	12 86       	std	Z+10, r1	; 0x0a
    3bac:	ed 81       	ldd	r30, Y+5	; 0x05
    3bae:	fe 81       	ldd	r31, Y+6	; 0x06
    3bb0:	80 81       	ld	r24, Z
    3bb2:	81 50       	subi	r24, 0x01	; 1
    3bb4:	ed 81       	ldd	r30, Y+5	; 0x05
    3bb6:	fe 81       	ldd	r31, Y+6	; 0x06
    3bb8:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3bba:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bbc:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bbe:	84 89       	ldd	r24, Z+20	; 0x14
    3bc0:	95 89       	ldd	r25, Z+21	; 0x15
    3bc2:	00 97       	sbiw	r24, 0x00	; 0
    3bc4:	d9 f1       	breq	.+118    	; 0x3c3c <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3bc6:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bc8:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bca:	84 89       	ldd	r24, Z+20	; 0x14
    3bcc:	95 89       	ldd	r25, Z+21	; 0x15
    3bce:	9c 83       	std	Y+4, r25	; 0x04
    3bd0:	8b 83       	std	Y+3, r24	; 0x03
    3bd2:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bd4:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bd6:	a6 85       	ldd	r26, Z+14	; 0x0e
    3bd8:	b7 85       	ldd	r27, Z+15	; 0x0f
    3bda:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bdc:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bde:	80 89       	ldd	r24, Z+16	; 0x10
    3be0:	91 89       	ldd	r25, Z+17	; 0x11
    3be2:	15 96       	adiw	r26, 0x05	; 5
    3be4:	9c 93       	st	X, r25
    3be6:	8e 93       	st	-X, r24
    3be8:	14 97       	sbiw	r26, 0x04	; 4
    3bea:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bec:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bee:	a0 89       	ldd	r26, Z+16	; 0x10
    3bf0:	b1 89       	ldd	r27, Z+17	; 0x11
    3bf2:	ee 85       	ldd	r30, Y+14	; 0x0e
    3bf4:	ff 85       	ldd	r31, Y+15	; 0x0f
    3bf6:	86 85       	ldd	r24, Z+14	; 0x0e
    3bf8:	97 85       	ldd	r25, Z+15	; 0x0f
    3bfa:	13 96       	adiw	r26, 0x03	; 3
    3bfc:	9c 93       	st	X, r25
    3bfe:	8e 93       	st	-X, r24
    3c00:	12 97       	sbiw	r26, 0x02	; 2
    3c02:	eb 81       	ldd	r30, Y+3	; 0x03
    3c04:	fc 81       	ldd	r31, Y+4	; 0x04
    3c06:	21 81       	ldd	r18, Z+1	; 0x01
    3c08:	32 81       	ldd	r19, Z+2	; 0x02
    3c0a:	8e 85       	ldd	r24, Y+14	; 0x0e
    3c0c:	9f 85       	ldd	r25, Y+15	; 0x0f
    3c0e:	0c 96       	adiw	r24, 0x0c	; 12
    3c10:	28 17       	cp	r18, r24
    3c12:	39 07       	cpc	r19, r25
    3c14:	41 f4       	brne	.+16     	; 0x3c26 <xTaskIncrementTick+0x1c8>
    3c16:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c18:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c1a:	80 89       	ldd	r24, Z+16	; 0x10
    3c1c:	91 89       	ldd	r25, Z+17	; 0x11
    3c1e:	eb 81       	ldd	r30, Y+3	; 0x03
    3c20:	fc 81       	ldd	r31, Y+4	; 0x04
    3c22:	92 83       	std	Z+2, r25	; 0x02
    3c24:	81 83       	std	Z+1, r24	; 0x01
    3c26:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c28:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c2a:	15 8a       	std	Z+21, r1	; 0x15
    3c2c:	14 8a       	std	Z+20, r1	; 0x14
    3c2e:	eb 81       	ldd	r30, Y+3	; 0x03
    3c30:	fc 81       	ldd	r31, Y+4	; 0x04
    3c32:	80 81       	ld	r24, Z
    3c34:	81 50       	subi	r24, 0x01	; 1
    3c36:	eb 81       	ldd	r30, Y+3	; 0x03
    3c38:	fc 81       	ldd	r31, Y+4	; 0x04
    3c3a:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    3c3c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c3e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c40:	96 89       	ldd	r25, Z+22	; 0x16
    3c42:	80 91 ac 06 	lds	r24, 0x06AC
    3c46:	89 17       	cp	r24, r25
    3c48:	28 f4       	brcc	.+10     	; 0x3c54 <xTaskIncrementTick+0x1f6>
    3c4a:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c4c:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c4e:	86 89       	ldd	r24, Z+22	; 0x16
    3c50:	80 93 ac 06 	sts	0x06AC, r24
    3c54:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c56:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c58:	86 89       	ldd	r24, Z+22	; 0x16
    3c5a:	28 2f       	mov	r18, r24
    3c5c:	30 e0       	ldi	r19, 0x00	; 0
    3c5e:	c9 01       	movw	r24, r18
    3c60:	88 0f       	add	r24, r24
    3c62:	99 1f       	adc	r25, r25
    3c64:	88 0f       	add	r24, r24
    3c66:	99 1f       	adc	r25, r25
    3c68:	88 0f       	add	r24, r24
    3c6a:	99 1f       	adc	r25, r25
    3c6c:	82 0f       	add	r24, r18
    3c6e:	93 1f       	adc	r25, r19
    3c70:	fc 01       	movw	r30, r24
    3c72:	e8 54       	subi	r30, 0x48	; 72
    3c74:	f9 4f       	sbci	r31, 0xF9	; 249
    3c76:	81 81       	ldd	r24, Z+1	; 0x01
    3c78:	92 81       	ldd	r25, Z+2	; 0x02
    3c7a:	9a 83       	std	Y+2, r25	; 0x02
    3c7c:	89 83       	std	Y+1, r24	; 0x01
    3c7e:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c80:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c82:	89 81       	ldd	r24, Y+1	; 0x01
    3c84:	9a 81       	ldd	r25, Y+2	; 0x02
    3c86:	95 83       	std	Z+5, r25	; 0x05
    3c88:	84 83       	std	Z+4, r24	; 0x04
    3c8a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c8c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c8e:	84 81       	ldd	r24, Z+4	; 0x04
    3c90:	95 81       	ldd	r25, Z+5	; 0x05
    3c92:	ee 85       	ldd	r30, Y+14	; 0x0e
    3c94:	ff 85       	ldd	r31, Y+15	; 0x0f
    3c96:	97 83       	std	Z+7, r25	; 0x07
    3c98:	86 83       	std	Z+6, r24	; 0x06
    3c9a:	e9 81       	ldd	r30, Y+1	; 0x01
    3c9c:	fa 81       	ldd	r31, Y+2	; 0x02
    3c9e:	04 80       	ldd	r0, Z+4	; 0x04
    3ca0:	f5 81       	ldd	r31, Z+5	; 0x05
    3ca2:	e0 2d       	mov	r30, r0
    3ca4:	8e 85       	ldd	r24, Y+14	; 0x0e
    3ca6:	9f 85       	ldd	r25, Y+15	; 0x0f
    3ca8:	02 96       	adiw	r24, 0x02	; 2
    3caa:	93 83       	std	Z+3, r25	; 0x03
    3cac:	82 83       	std	Z+2, r24	; 0x02
    3cae:	8e 85       	ldd	r24, Y+14	; 0x0e
    3cb0:	9f 85       	ldd	r25, Y+15	; 0x0f
    3cb2:	02 96       	adiw	r24, 0x02	; 2
    3cb4:	e9 81       	ldd	r30, Y+1	; 0x01
    3cb6:	fa 81       	ldd	r31, Y+2	; 0x02
    3cb8:	95 83       	std	Z+5, r25	; 0x05
    3cba:	84 83       	std	Z+4, r24	; 0x04
    3cbc:	ee 85       	ldd	r30, Y+14	; 0x0e
    3cbe:	ff 85       	ldd	r31, Y+15	; 0x0f
    3cc0:	86 89       	ldd	r24, Z+22	; 0x16
    3cc2:	28 2f       	mov	r18, r24
    3cc4:	30 e0       	ldi	r19, 0x00	; 0
    3cc6:	c9 01       	movw	r24, r18
    3cc8:	88 0f       	add	r24, r24
    3cca:	99 1f       	adc	r25, r25
    3ccc:	88 0f       	add	r24, r24
    3cce:	99 1f       	adc	r25, r25
    3cd0:	88 0f       	add	r24, r24
    3cd2:	99 1f       	adc	r25, r25
    3cd4:	82 0f       	add	r24, r18
    3cd6:	93 1f       	adc	r25, r19
    3cd8:	88 54       	subi	r24, 0x48	; 72
    3cda:	99 4f       	sbci	r25, 0xF9	; 249
    3cdc:	ee 85       	ldd	r30, Y+14	; 0x0e
    3cde:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ce0:	93 87       	std	Z+11, r25	; 0x0b
    3ce2:	82 87       	std	Z+10, r24	; 0x0a
    3ce4:	ee 85       	ldd	r30, Y+14	; 0x0e
    3ce6:	ff 85       	ldd	r31, Y+15	; 0x0f
    3ce8:	86 89       	ldd	r24, Z+22	; 0x16
    3cea:	28 2f       	mov	r18, r24
    3cec:	30 e0       	ldi	r19, 0x00	; 0
    3cee:	c9 01       	movw	r24, r18
    3cf0:	88 0f       	add	r24, r24
    3cf2:	99 1f       	adc	r25, r25
    3cf4:	88 0f       	add	r24, r24
    3cf6:	99 1f       	adc	r25, r25
    3cf8:	88 0f       	add	r24, r24
    3cfa:	99 1f       	adc	r25, r25
    3cfc:	82 0f       	add	r24, r18
    3cfe:	93 1f       	adc	r25, r19
    3d00:	fc 01       	movw	r30, r24
    3d02:	e8 54       	subi	r30, 0x48	; 72
    3d04:	f9 4f       	sbci	r31, 0xF9	; 249
    3d06:	80 81       	ld	r24, Z
    3d08:	8f 5f       	subi	r24, 0xFF	; 255
    3d0a:	80 83       	st	Z, r24
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3d0c:	ee 85       	ldd	r30, Y+14	; 0x0e
    3d0e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3d10:	96 89       	ldd	r25, Z+22	; 0x16
    3d12:	e0 91 a6 06 	lds	r30, 0x06A6
    3d16:	f0 91 a7 06 	lds	r31, 0x06A7
    3d1a:	86 89       	ldd	r24, Z+22	; 0x16
    3d1c:	98 17       	cp	r25, r24
    3d1e:	08 f4       	brcc	.+2      	; 0x3d22 <xTaskIncrementTick+0x2c4>
    3d20:	e4 ce       	rjmp	.-568    	; 0x3aea <xTaskIncrementTick+0x8c>
                            {
                                xSwitchRequired = pdTRUE;
    3d22:	81 e0       	ldi	r24, 0x01	; 1
    3d24:	8b 87       	std	Y+11, r24	; 0x0b
    3d26:	e1 ce       	rjmp	.-574    	; 0x3aea <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3d28:	e0 91 a6 06 	lds	r30, 0x06A6
    3d2c:	f0 91 a7 06 	lds	r31, 0x06A7
    3d30:	86 89       	ldd	r24, Z+22	; 0x16
    3d32:	28 2f       	mov	r18, r24
    3d34:	30 e0       	ldi	r19, 0x00	; 0
    3d36:	c9 01       	movw	r24, r18
    3d38:	88 0f       	add	r24, r24
    3d3a:	99 1f       	adc	r25, r25
    3d3c:	88 0f       	add	r24, r24
    3d3e:	99 1f       	adc	r25, r25
    3d40:	88 0f       	add	r24, r24
    3d42:	99 1f       	adc	r25, r25
    3d44:	82 0f       	add	r24, r18
    3d46:	93 1f       	adc	r25, r19
    3d48:	fc 01       	movw	r30, r24
    3d4a:	e8 54       	subi	r30, 0x48	; 72
    3d4c:	f9 4f       	sbci	r31, 0xF9	; 249
    3d4e:	80 81       	ld	r24, Z
    3d50:	82 30       	cpi	r24, 0x02	; 2
    3d52:	10 f0       	brcs	.+4      	; 0x3d58 <xTaskIncrementTick+0x2fa>
                {
                    xSwitchRequired = pdTRUE;
    3d54:	81 e0       	ldi	r24, 0x01	; 1
    3d56:	8b 87       	std	Y+11, r24	; 0x0b
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    3d58:	80 91 b0 06 	lds	r24, 0x06B0
    3d5c:	88 23       	and	r24, r24
    3d5e:	61 f0       	breq	.+24     	; 0x3d78 <xTaskIncrementTick+0x31a>
                {
                    xSwitchRequired = pdTRUE;
    3d60:	81 e0       	ldi	r24, 0x01	; 1
    3d62:	8b 87       	std	Y+11, r24	; 0x0b
    3d64:	09 c0       	rjmp	.+18     	; 0x3d78 <xTaskIncrementTick+0x31a>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    3d66:	80 91 ae 06 	lds	r24, 0x06AE
    3d6a:	90 91 af 06 	lds	r25, 0x06AF
    3d6e:	01 96       	adiw	r24, 0x01	; 1
    3d70:	90 93 af 06 	sts	0x06AF, r25
    3d74:	80 93 ae 06 	sts	0x06AE, r24
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
    3d78:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    3d7a:	2f 96       	adiw	r28, 0x0f	; 15
    3d7c:	0f b6       	in	r0, 0x3f	; 63
    3d7e:	f8 94       	cli
    3d80:	de bf       	out	0x3e, r29	; 62
    3d82:	0f be       	out	0x3f, r0	; 63
    3d84:	cd bf       	out	0x3d, r28	; 61
    3d86:	cf 91       	pop	r28
    3d88:	df 91       	pop	r29
    3d8a:	08 95       	ret

00003d8c <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3d8c:	df 93       	push	r29
    3d8e:	cf 93       	push	r28
    3d90:	00 d0       	rcall	.+0      	; 0x3d92 <vTaskSwitchContext+0x6>
    3d92:	0f 92       	push	r0
    3d94:	cd b7       	in	r28, 0x3d	; 61
    3d96:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3d98:	80 91 b7 06 	lds	r24, 0x06B7
    3d9c:	88 23       	and	r24, r24
    3d9e:	21 f0       	breq	.+8      	; 0x3da8 <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    3da0:	81 e0       	ldi	r24, 0x01	; 1
    3da2:	80 93 b0 06 	sts	0x06B0, r24
    3da6:	59 c0       	rjmp	.+178    	; 0x3e5a <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    3da8:	10 92 b0 06 	sts	0x06B0, r1
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3dac:	80 91 ac 06 	lds	r24, 0x06AC
    3db0:	8b 83       	std	Y+3, r24	; 0x03
    3db2:	03 c0       	rjmp	.+6      	; 0x3dba <vTaskSwitchContext+0x2e>
    3db4:	8b 81       	ldd	r24, Y+3	; 0x03
    3db6:	81 50       	subi	r24, 0x01	; 1
    3db8:	8b 83       	std	Y+3, r24	; 0x03
    3dba:	8b 81       	ldd	r24, Y+3	; 0x03
    3dbc:	28 2f       	mov	r18, r24
    3dbe:	30 e0       	ldi	r19, 0x00	; 0
    3dc0:	c9 01       	movw	r24, r18
    3dc2:	88 0f       	add	r24, r24
    3dc4:	99 1f       	adc	r25, r25
    3dc6:	88 0f       	add	r24, r24
    3dc8:	99 1f       	adc	r25, r25
    3dca:	88 0f       	add	r24, r24
    3dcc:	99 1f       	adc	r25, r25
    3dce:	82 0f       	add	r24, r18
    3dd0:	93 1f       	adc	r25, r19
    3dd2:	fc 01       	movw	r30, r24
    3dd4:	e8 54       	subi	r30, 0x48	; 72
    3dd6:	f9 4f       	sbci	r31, 0xF9	; 249
    3dd8:	80 81       	ld	r24, Z
    3dda:	88 23       	and	r24, r24
    3ddc:	59 f3       	breq	.-42     	; 0x3db4 <vTaskSwitchContext+0x28>
    3dde:	8b 81       	ldd	r24, Y+3	; 0x03
    3de0:	28 2f       	mov	r18, r24
    3de2:	30 e0       	ldi	r19, 0x00	; 0
    3de4:	c9 01       	movw	r24, r18
    3de6:	88 0f       	add	r24, r24
    3de8:	99 1f       	adc	r25, r25
    3dea:	88 0f       	add	r24, r24
    3dec:	99 1f       	adc	r25, r25
    3dee:	88 0f       	add	r24, r24
    3df0:	99 1f       	adc	r25, r25
    3df2:	82 0f       	add	r24, r18
    3df4:	93 1f       	adc	r25, r19
    3df6:	88 54       	subi	r24, 0x48	; 72
    3df8:	99 4f       	sbci	r25, 0xF9	; 249
    3dfa:	9a 83       	std	Y+2, r25	; 0x02
    3dfc:	89 83       	std	Y+1, r24	; 0x01
    3dfe:	e9 81       	ldd	r30, Y+1	; 0x01
    3e00:	fa 81       	ldd	r31, Y+2	; 0x02
    3e02:	01 80       	ldd	r0, Z+1	; 0x01
    3e04:	f2 81       	ldd	r31, Z+2	; 0x02
    3e06:	e0 2d       	mov	r30, r0
    3e08:	82 81       	ldd	r24, Z+2	; 0x02
    3e0a:	93 81       	ldd	r25, Z+3	; 0x03
    3e0c:	e9 81       	ldd	r30, Y+1	; 0x01
    3e0e:	fa 81       	ldd	r31, Y+2	; 0x02
    3e10:	92 83       	std	Z+2, r25	; 0x02
    3e12:	81 83       	std	Z+1, r24	; 0x01
    3e14:	e9 81       	ldd	r30, Y+1	; 0x01
    3e16:	fa 81       	ldd	r31, Y+2	; 0x02
    3e18:	21 81       	ldd	r18, Z+1	; 0x01
    3e1a:	32 81       	ldd	r19, Z+2	; 0x02
    3e1c:	89 81       	ldd	r24, Y+1	; 0x01
    3e1e:	9a 81       	ldd	r25, Y+2	; 0x02
    3e20:	03 96       	adiw	r24, 0x03	; 3
    3e22:	28 17       	cp	r18, r24
    3e24:	39 07       	cpc	r19, r25
    3e26:	59 f4       	brne	.+22     	; 0x3e3e <vTaskSwitchContext+0xb2>
    3e28:	e9 81       	ldd	r30, Y+1	; 0x01
    3e2a:	fa 81       	ldd	r31, Y+2	; 0x02
    3e2c:	01 80       	ldd	r0, Z+1	; 0x01
    3e2e:	f2 81       	ldd	r31, Z+2	; 0x02
    3e30:	e0 2d       	mov	r30, r0
    3e32:	82 81       	ldd	r24, Z+2	; 0x02
    3e34:	93 81       	ldd	r25, Z+3	; 0x03
    3e36:	e9 81       	ldd	r30, Y+1	; 0x01
    3e38:	fa 81       	ldd	r31, Y+2	; 0x02
    3e3a:	92 83       	std	Z+2, r25	; 0x02
    3e3c:	81 83       	std	Z+1, r24	; 0x01
    3e3e:	e9 81       	ldd	r30, Y+1	; 0x01
    3e40:	fa 81       	ldd	r31, Y+2	; 0x02
    3e42:	01 80       	ldd	r0, Z+1	; 0x01
    3e44:	f2 81       	ldd	r31, Z+2	; 0x02
    3e46:	e0 2d       	mov	r30, r0
    3e48:	86 81       	ldd	r24, Z+6	; 0x06
    3e4a:	97 81       	ldd	r25, Z+7	; 0x07
    3e4c:	90 93 a7 06 	sts	0x06A7, r25
    3e50:	80 93 a6 06 	sts	0x06A6, r24
    3e54:	8b 81       	ldd	r24, Y+3	; 0x03
    3e56:	80 93 ac 06 	sts	0x06AC, r24
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    3e5a:	0f 90       	pop	r0
    3e5c:	0f 90       	pop	r0
    3e5e:	0f 90       	pop	r0
    3e60:	cf 91       	pop	r28
    3e62:	df 91       	pop	r29
    3e64:	08 95       	ret

00003e66 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    3e66:	df 93       	push	r29
    3e68:	cf 93       	push	r28
    3e6a:	00 d0       	rcall	.+0      	; 0x3e6c <vTaskPlaceOnEventList+0x6>
    3e6c:	00 d0       	rcall	.+0      	; 0x3e6e <vTaskPlaceOnEventList+0x8>
    3e6e:	cd b7       	in	r28, 0x3d	; 61
    3e70:	de b7       	in	r29, 0x3e	; 62
    3e72:	9a 83       	std	Y+2, r25	; 0x02
    3e74:	89 83       	std	Y+1, r24	; 0x01
    3e76:	7c 83       	std	Y+4, r23	; 0x04
    3e78:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3e7a:	80 91 a6 06 	lds	r24, 0x06A6
    3e7e:	90 91 a7 06 	lds	r25, 0x06A7
    3e82:	9c 01       	movw	r18, r24
    3e84:	24 5f       	subi	r18, 0xF4	; 244
    3e86:	3f 4f       	sbci	r19, 0xFF	; 255
    3e88:	89 81       	ldd	r24, Y+1	; 0x01
    3e8a:	9a 81       	ldd	r25, Y+2	; 0x02
    3e8c:	b9 01       	movw	r22, r18
    3e8e:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3e92:	8b 81       	ldd	r24, Y+3	; 0x03
    3e94:	9c 81       	ldd	r25, Y+4	; 0x04
    3e96:	61 e0       	ldi	r22, 0x01	; 1
    3e98:	0e 94 8f 2b 	call	0x571e	; 0x571e <prvAddCurrentTaskToDelayedList>
}
    3e9c:	0f 90       	pop	r0
    3e9e:	0f 90       	pop	r0
    3ea0:	0f 90       	pop	r0
    3ea2:	0f 90       	pop	r0
    3ea4:	cf 91       	pop	r28
    3ea6:	df 91       	pop	r29
    3ea8:	08 95       	ret

00003eaa <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    3eaa:	df 93       	push	r29
    3eac:	cf 93       	push	r28
    3eae:	cd b7       	in	r28, 0x3d	; 61
    3eb0:	de b7       	in	r29, 0x3e	; 62
    3eb2:	28 97       	sbiw	r28, 0x08	; 8
    3eb4:	0f b6       	in	r0, 0x3f	; 63
    3eb6:	f8 94       	cli
    3eb8:	de bf       	out	0x3e, r29	; 62
    3eba:	0f be       	out	0x3f, r0	; 63
    3ebc:	cd bf       	out	0x3d, r28	; 61
    3ebe:	9c 83       	std	Y+4, r25	; 0x04
    3ec0:	8b 83       	std	Y+3, r24	; 0x03
    3ec2:	7e 83       	std	Y+6, r23	; 0x06
    3ec4:	6d 83       	std	Y+5, r22	; 0x05
    3ec6:	58 87       	std	Y+8, r21	; 0x08
    3ec8:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3eca:	e0 91 a6 06 	lds	r30, 0x06A6
    3ece:	f0 91 a7 06 	lds	r31, 0x06A7
    3ed2:	8d 81       	ldd	r24, Y+5	; 0x05
    3ed4:	9e 81       	ldd	r25, Y+6	; 0x06
    3ed6:	90 68       	ori	r25, 0x80	; 128
    3ed8:	95 87       	std	Z+13, r25	; 0x0d
    3eda:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3edc:	eb 81       	ldd	r30, Y+3	; 0x03
    3ede:	fc 81       	ldd	r31, Y+4	; 0x04
    3ee0:	81 81       	ldd	r24, Z+1	; 0x01
    3ee2:	92 81       	ldd	r25, Z+2	; 0x02
    3ee4:	9a 83       	std	Y+2, r25	; 0x02
    3ee6:	89 83       	std	Y+1, r24	; 0x01
    3ee8:	e0 91 a6 06 	lds	r30, 0x06A6
    3eec:	f0 91 a7 06 	lds	r31, 0x06A7
    3ef0:	89 81       	ldd	r24, Y+1	; 0x01
    3ef2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ef4:	97 87       	std	Z+15, r25	; 0x0f
    3ef6:	86 87       	std	Z+14, r24	; 0x0e
    3ef8:	a0 91 a6 06 	lds	r26, 0x06A6
    3efc:	b0 91 a7 06 	lds	r27, 0x06A7
    3f00:	e9 81       	ldd	r30, Y+1	; 0x01
    3f02:	fa 81       	ldd	r31, Y+2	; 0x02
    3f04:	84 81       	ldd	r24, Z+4	; 0x04
    3f06:	95 81       	ldd	r25, Z+5	; 0x05
    3f08:	51 96       	adiw	r26, 0x11	; 17
    3f0a:	9c 93       	st	X, r25
    3f0c:	8e 93       	st	-X, r24
    3f0e:	50 97       	sbiw	r26, 0x10	; 16
    3f10:	e9 81       	ldd	r30, Y+1	; 0x01
    3f12:	fa 81       	ldd	r31, Y+2	; 0x02
    3f14:	04 80       	ldd	r0, Z+4	; 0x04
    3f16:	f5 81       	ldd	r31, Z+5	; 0x05
    3f18:	e0 2d       	mov	r30, r0
    3f1a:	80 91 a6 06 	lds	r24, 0x06A6
    3f1e:	90 91 a7 06 	lds	r25, 0x06A7
    3f22:	0c 96       	adiw	r24, 0x0c	; 12
    3f24:	93 83       	std	Z+3, r25	; 0x03
    3f26:	82 83       	std	Z+2, r24	; 0x02
    3f28:	80 91 a6 06 	lds	r24, 0x06A6
    3f2c:	90 91 a7 06 	lds	r25, 0x06A7
    3f30:	0c 96       	adiw	r24, 0x0c	; 12
    3f32:	e9 81       	ldd	r30, Y+1	; 0x01
    3f34:	fa 81       	ldd	r31, Y+2	; 0x02
    3f36:	95 83       	std	Z+5, r25	; 0x05
    3f38:	84 83       	std	Z+4, r24	; 0x04
    3f3a:	e0 91 a6 06 	lds	r30, 0x06A6
    3f3e:	f0 91 a7 06 	lds	r31, 0x06A7
    3f42:	8b 81       	ldd	r24, Y+3	; 0x03
    3f44:	9c 81       	ldd	r25, Y+4	; 0x04
    3f46:	95 8b       	std	Z+21, r25	; 0x15
    3f48:	84 8b       	std	Z+20, r24	; 0x14
    3f4a:	eb 81       	ldd	r30, Y+3	; 0x03
    3f4c:	fc 81       	ldd	r31, Y+4	; 0x04
    3f4e:	80 81       	ld	r24, Z
    3f50:	8f 5f       	subi	r24, 0xFF	; 255
    3f52:	eb 81       	ldd	r30, Y+3	; 0x03
    3f54:	fc 81       	ldd	r31, Y+4	; 0x04
    3f56:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3f58:	8f 81       	ldd	r24, Y+7	; 0x07
    3f5a:	98 85       	ldd	r25, Y+8	; 0x08
    3f5c:	61 e0       	ldi	r22, 0x01	; 1
    3f5e:	0e 94 8f 2b 	call	0x571e	; 0x571e <prvAddCurrentTaskToDelayedList>
}
    3f62:	28 96       	adiw	r28, 0x08	; 8
    3f64:	0f b6       	in	r0, 0x3f	; 63
    3f66:	f8 94       	cli
    3f68:	de bf       	out	0x3e, r29	; 62
    3f6a:	0f be       	out	0x3f, r0	; 63
    3f6c:	cd bf       	out	0x3d, r28	; 61
    3f6e:	cf 91       	pop	r28
    3f70:	df 91       	pop	r29
    3f72:	08 95       	ret

00003f74 <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
    3f74:	df 93       	push	r29
    3f76:	cf 93       	push	r28
    3f78:	cd b7       	in	r28, 0x3d	; 61
    3f7a:	de b7       	in	r29, 0x3e	; 62
    3f7c:	27 97       	sbiw	r28, 0x07	; 7
    3f7e:	0f b6       	in	r0, 0x3f	; 63
    3f80:	f8 94       	cli
    3f82:	de bf       	out	0x3e, r29	; 62
    3f84:	0f be       	out	0x3f, r0	; 63
    3f86:	cd bf       	out	0x3d, r28	; 61
    3f88:	9c 83       	std	Y+4, r25	; 0x04
    3f8a:	8b 83       	std	Y+3, r24	; 0x03
    3f8c:	7e 83       	std	Y+6, r23	; 0x06
    3f8e:	6d 83       	std	Y+5, r22	; 0x05
    3f90:	4f 83       	std	Y+7, r20	; 0x07

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3f92:	eb 81       	ldd	r30, Y+3	; 0x03
    3f94:	fc 81       	ldd	r31, Y+4	; 0x04
    3f96:	81 81       	ldd	r24, Z+1	; 0x01
    3f98:	92 81       	ldd	r25, Z+2	; 0x02
    3f9a:	9a 83       	std	Y+2, r25	; 0x02
    3f9c:	89 83       	std	Y+1, r24	; 0x01
    3f9e:	e0 91 a6 06 	lds	r30, 0x06A6
    3fa2:	f0 91 a7 06 	lds	r31, 0x06A7
    3fa6:	89 81       	ldd	r24, Y+1	; 0x01
    3fa8:	9a 81       	ldd	r25, Y+2	; 0x02
    3faa:	97 87       	std	Z+15, r25	; 0x0f
    3fac:	86 87       	std	Z+14, r24	; 0x0e
    3fae:	a0 91 a6 06 	lds	r26, 0x06A6
    3fb2:	b0 91 a7 06 	lds	r27, 0x06A7
    3fb6:	e9 81       	ldd	r30, Y+1	; 0x01
    3fb8:	fa 81       	ldd	r31, Y+2	; 0x02
    3fba:	84 81       	ldd	r24, Z+4	; 0x04
    3fbc:	95 81       	ldd	r25, Z+5	; 0x05
    3fbe:	51 96       	adiw	r26, 0x11	; 17
    3fc0:	9c 93       	st	X, r25
    3fc2:	8e 93       	st	-X, r24
    3fc4:	50 97       	sbiw	r26, 0x10	; 16
    3fc6:	e9 81       	ldd	r30, Y+1	; 0x01
    3fc8:	fa 81       	ldd	r31, Y+2	; 0x02
    3fca:	04 80       	ldd	r0, Z+4	; 0x04
    3fcc:	f5 81       	ldd	r31, Z+5	; 0x05
    3fce:	e0 2d       	mov	r30, r0
    3fd0:	80 91 a6 06 	lds	r24, 0x06A6
    3fd4:	90 91 a7 06 	lds	r25, 0x06A7
    3fd8:	0c 96       	adiw	r24, 0x0c	; 12
    3fda:	93 83       	std	Z+3, r25	; 0x03
    3fdc:	82 83       	std	Z+2, r24	; 0x02
    3fde:	80 91 a6 06 	lds	r24, 0x06A6
    3fe2:	90 91 a7 06 	lds	r25, 0x06A7
    3fe6:	0c 96       	adiw	r24, 0x0c	; 12
    3fe8:	e9 81       	ldd	r30, Y+1	; 0x01
    3fea:	fa 81       	ldd	r31, Y+2	; 0x02
    3fec:	95 83       	std	Z+5, r25	; 0x05
    3fee:	84 83       	std	Z+4, r24	; 0x04
    3ff0:	e0 91 a6 06 	lds	r30, 0x06A6
    3ff4:	f0 91 a7 06 	lds	r31, 0x06A7
    3ff8:	8b 81       	ldd	r24, Y+3	; 0x03
    3ffa:	9c 81       	ldd	r25, Y+4	; 0x04
    3ffc:	95 8b       	std	Z+21, r25	; 0x15
    3ffe:	84 8b       	std	Z+20, r24	; 0x14
    4000:	eb 81       	ldd	r30, Y+3	; 0x03
    4002:	fc 81       	ldd	r31, Y+4	; 0x04
    4004:	80 81       	ld	r24, Z
    4006:	8f 5f       	subi	r24, 0xFF	; 255
    4008:	eb 81       	ldd	r30, Y+3	; 0x03
    400a:	fc 81       	ldd	r31, Y+4	; 0x04
    400c:	80 83       	st	Z, r24

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
    400e:	8f 81       	ldd	r24, Y+7	; 0x07
    4010:	88 23       	and	r24, r24
    4012:	21 f0       	breq	.+8      	; 0x401c <vTaskPlaceOnEventListRestricted+0xa8>
        {
            xTicksToWait = portMAX_DELAY;
    4014:	8f ef       	ldi	r24, 0xFF	; 255
    4016:	9f ef       	ldi	r25, 0xFF	; 255
    4018:	9e 83       	std	Y+6, r25	; 0x06
    401a:	8d 83       	std	Y+5, r24	; 0x05
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    401c:	8d 81       	ldd	r24, Y+5	; 0x05
    401e:	9e 81       	ldd	r25, Y+6	; 0x06
    4020:	6f 81       	ldd	r22, Y+7	; 0x07
    4022:	0e 94 8f 2b 	call	0x571e	; 0x571e <prvAddCurrentTaskToDelayedList>
    }
    4026:	27 96       	adiw	r28, 0x07	; 7
    4028:	0f b6       	in	r0, 0x3f	; 63
    402a:	f8 94       	cli
    402c:	de bf       	out	0x3e, r29	; 62
    402e:	0f be       	out	0x3f, r0	; 63
    4030:	cd bf       	out	0x3d, r28	; 61
    4032:	cf 91       	pop	r28
    4034:	df 91       	pop	r29
    4036:	08 95       	ret

00004038 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4038:	df 93       	push	r29
    403a:	cf 93       	push	r28
    403c:	cd b7       	in	r28, 0x3d	; 61
    403e:	de b7       	in	r29, 0x3e	; 62
    4040:	2d 97       	sbiw	r28, 0x0d	; 13
    4042:	0f b6       	in	r0, 0x3f	; 63
    4044:	f8 94       	cli
    4046:	de bf       	out	0x3e, r29	; 62
    4048:	0f be       	out	0x3f, r0	; 63
    404a:	cd bf       	out	0x3d, r28	; 61
    404c:	9d 87       	std	Y+13, r25	; 0x0d
    404e:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4050:	ec 85       	ldd	r30, Y+12	; 0x0c
    4052:	fd 85       	ldd	r31, Y+13	; 0x0d
    4054:	05 80       	ldd	r0, Z+5	; 0x05
    4056:	f6 81       	ldd	r31, Z+6	; 0x06
    4058:	e0 2d       	mov	r30, r0
    405a:	86 81       	ldd	r24, Z+6	; 0x06
    405c:	97 81       	ldd	r25, Z+7	; 0x07
    405e:	9b 87       	std	Y+11, r25	; 0x0b
    4060:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    4062:	ea 85       	ldd	r30, Y+10	; 0x0a
    4064:	fb 85       	ldd	r31, Y+11	; 0x0b
    4066:	84 89       	ldd	r24, Z+20	; 0x14
    4068:	95 89       	ldd	r25, Z+21	; 0x15
    406a:	98 87       	std	Y+8, r25	; 0x08
    406c:	8f 83       	std	Y+7, r24	; 0x07
    406e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4070:	fb 85       	ldd	r31, Y+11	; 0x0b
    4072:	a6 85       	ldd	r26, Z+14	; 0x0e
    4074:	b7 85       	ldd	r27, Z+15	; 0x0f
    4076:	ea 85       	ldd	r30, Y+10	; 0x0a
    4078:	fb 85       	ldd	r31, Y+11	; 0x0b
    407a:	80 89       	ldd	r24, Z+16	; 0x10
    407c:	91 89       	ldd	r25, Z+17	; 0x11
    407e:	15 96       	adiw	r26, 0x05	; 5
    4080:	9c 93       	st	X, r25
    4082:	8e 93       	st	-X, r24
    4084:	14 97       	sbiw	r26, 0x04	; 4
    4086:	ea 85       	ldd	r30, Y+10	; 0x0a
    4088:	fb 85       	ldd	r31, Y+11	; 0x0b
    408a:	a0 89       	ldd	r26, Z+16	; 0x10
    408c:	b1 89       	ldd	r27, Z+17	; 0x11
    408e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4090:	fb 85       	ldd	r31, Y+11	; 0x0b
    4092:	86 85       	ldd	r24, Z+14	; 0x0e
    4094:	97 85       	ldd	r25, Z+15	; 0x0f
    4096:	13 96       	adiw	r26, 0x03	; 3
    4098:	9c 93       	st	X, r25
    409a:	8e 93       	st	-X, r24
    409c:	12 97       	sbiw	r26, 0x02	; 2
    409e:	ef 81       	ldd	r30, Y+7	; 0x07
    40a0:	f8 85       	ldd	r31, Y+8	; 0x08
    40a2:	21 81       	ldd	r18, Z+1	; 0x01
    40a4:	32 81       	ldd	r19, Z+2	; 0x02
    40a6:	8a 85       	ldd	r24, Y+10	; 0x0a
    40a8:	9b 85       	ldd	r25, Y+11	; 0x0b
    40aa:	0c 96       	adiw	r24, 0x0c	; 12
    40ac:	28 17       	cp	r18, r24
    40ae:	39 07       	cpc	r19, r25
    40b0:	41 f4       	brne	.+16     	; 0x40c2 <xTaskRemoveFromEventList+0x8a>
    40b2:	ea 85       	ldd	r30, Y+10	; 0x0a
    40b4:	fb 85       	ldd	r31, Y+11	; 0x0b
    40b6:	80 89       	ldd	r24, Z+16	; 0x10
    40b8:	91 89       	ldd	r25, Z+17	; 0x11
    40ba:	ef 81       	ldd	r30, Y+7	; 0x07
    40bc:	f8 85       	ldd	r31, Y+8	; 0x08
    40be:	92 83       	std	Z+2, r25	; 0x02
    40c0:	81 83       	std	Z+1, r24	; 0x01
    40c2:	ea 85       	ldd	r30, Y+10	; 0x0a
    40c4:	fb 85       	ldd	r31, Y+11	; 0x0b
    40c6:	15 8a       	std	Z+21, r1	; 0x15
    40c8:	14 8a       	std	Z+20, r1	; 0x14
    40ca:	ef 81       	ldd	r30, Y+7	; 0x07
    40cc:	f8 85       	ldd	r31, Y+8	; 0x08
    40ce:	80 81       	ld	r24, Z
    40d0:	81 50       	subi	r24, 0x01	; 1
    40d2:	ef 81       	ldd	r30, Y+7	; 0x07
    40d4:	f8 85       	ldd	r31, Y+8	; 0x08
    40d6:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    40d8:	80 91 b7 06 	lds	r24, 0x06B7
    40dc:	88 23       	and	r24, r24
    40de:	09 f0       	breq	.+2      	; 0x40e2 <xTaskRemoveFromEventList+0xaa>
    40e0:	a4 c0       	rjmp	.+328    	; 0x422a <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    40e2:	ea 85       	ldd	r30, Y+10	; 0x0a
    40e4:	fb 85       	ldd	r31, Y+11	; 0x0b
    40e6:	82 85       	ldd	r24, Z+10	; 0x0a
    40e8:	93 85       	ldd	r25, Z+11	; 0x0b
    40ea:	9e 83       	std	Y+6, r25	; 0x06
    40ec:	8d 83       	std	Y+5, r24	; 0x05
    40ee:	ea 85       	ldd	r30, Y+10	; 0x0a
    40f0:	fb 85       	ldd	r31, Y+11	; 0x0b
    40f2:	a4 81       	ldd	r26, Z+4	; 0x04
    40f4:	b5 81       	ldd	r27, Z+5	; 0x05
    40f6:	ea 85       	ldd	r30, Y+10	; 0x0a
    40f8:	fb 85       	ldd	r31, Y+11	; 0x0b
    40fa:	86 81       	ldd	r24, Z+6	; 0x06
    40fc:	97 81       	ldd	r25, Z+7	; 0x07
    40fe:	15 96       	adiw	r26, 0x05	; 5
    4100:	9c 93       	st	X, r25
    4102:	8e 93       	st	-X, r24
    4104:	14 97       	sbiw	r26, 0x04	; 4
    4106:	ea 85       	ldd	r30, Y+10	; 0x0a
    4108:	fb 85       	ldd	r31, Y+11	; 0x0b
    410a:	a6 81       	ldd	r26, Z+6	; 0x06
    410c:	b7 81       	ldd	r27, Z+7	; 0x07
    410e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4110:	fb 85       	ldd	r31, Y+11	; 0x0b
    4112:	84 81       	ldd	r24, Z+4	; 0x04
    4114:	95 81       	ldd	r25, Z+5	; 0x05
    4116:	13 96       	adiw	r26, 0x03	; 3
    4118:	9c 93       	st	X, r25
    411a:	8e 93       	st	-X, r24
    411c:	12 97       	sbiw	r26, 0x02	; 2
    411e:	ed 81       	ldd	r30, Y+5	; 0x05
    4120:	fe 81       	ldd	r31, Y+6	; 0x06
    4122:	21 81       	ldd	r18, Z+1	; 0x01
    4124:	32 81       	ldd	r19, Z+2	; 0x02
    4126:	8a 85       	ldd	r24, Y+10	; 0x0a
    4128:	9b 85       	ldd	r25, Y+11	; 0x0b
    412a:	02 96       	adiw	r24, 0x02	; 2
    412c:	28 17       	cp	r18, r24
    412e:	39 07       	cpc	r19, r25
    4130:	41 f4       	brne	.+16     	; 0x4142 <xTaskRemoveFromEventList+0x10a>
    4132:	ea 85       	ldd	r30, Y+10	; 0x0a
    4134:	fb 85       	ldd	r31, Y+11	; 0x0b
    4136:	86 81       	ldd	r24, Z+6	; 0x06
    4138:	97 81       	ldd	r25, Z+7	; 0x07
    413a:	ed 81       	ldd	r30, Y+5	; 0x05
    413c:	fe 81       	ldd	r31, Y+6	; 0x06
    413e:	92 83       	std	Z+2, r25	; 0x02
    4140:	81 83       	std	Z+1, r24	; 0x01
    4142:	ea 85       	ldd	r30, Y+10	; 0x0a
    4144:	fb 85       	ldd	r31, Y+11	; 0x0b
    4146:	13 86       	std	Z+11, r1	; 0x0b
    4148:	12 86       	std	Z+10, r1	; 0x0a
    414a:	ed 81       	ldd	r30, Y+5	; 0x05
    414c:	fe 81       	ldd	r31, Y+6	; 0x06
    414e:	80 81       	ld	r24, Z
    4150:	81 50       	subi	r24, 0x01	; 1
    4152:	ed 81       	ldd	r30, Y+5	; 0x05
    4154:	fe 81       	ldd	r31, Y+6	; 0x06
    4156:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    4158:	ea 85       	ldd	r30, Y+10	; 0x0a
    415a:	fb 85       	ldd	r31, Y+11	; 0x0b
    415c:	96 89       	ldd	r25, Z+22	; 0x16
    415e:	80 91 ac 06 	lds	r24, 0x06AC
    4162:	89 17       	cp	r24, r25
    4164:	28 f4       	brcc	.+10     	; 0x4170 <xTaskRemoveFromEventList+0x138>
    4166:	ea 85       	ldd	r30, Y+10	; 0x0a
    4168:	fb 85       	ldd	r31, Y+11	; 0x0b
    416a:	86 89       	ldd	r24, Z+22	; 0x16
    416c:	80 93 ac 06 	sts	0x06AC, r24
    4170:	ea 85       	ldd	r30, Y+10	; 0x0a
    4172:	fb 85       	ldd	r31, Y+11	; 0x0b
    4174:	86 89       	ldd	r24, Z+22	; 0x16
    4176:	28 2f       	mov	r18, r24
    4178:	30 e0       	ldi	r19, 0x00	; 0
    417a:	c9 01       	movw	r24, r18
    417c:	88 0f       	add	r24, r24
    417e:	99 1f       	adc	r25, r25
    4180:	88 0f       	add	r24, r24
    4182:	99 1f       	adc	r25, r25
    4184:	88 0f       	add	r24, r24
    4186:	99 1f       	adc	r25, r25
    4188:	82 0f       	add	r24, r18
    418a:	93 1f       	adc	r25, r19
    418c:	fc 01       	movw	r30, r24
    418e:	e8 54       	subi	r30, 0x48	; 72
    4190:	f9 4f       	sbci	r31, 0xF9	; 249
    4192:	81 81       	ldd	r24, Z+1	; 0x01
    4194:	92 81       	ldd	r25, Z+2	; 0x02
    4196:	9c 83       	std	Y+4, r25	; 0x04
    4198:	8b 83       	std	Y+3, r24	; 0x03
    419a:	ea 85       	ldd	r30, Y+10	; 0x0a
    419c:	fb 85       	ldd	r31, Y+11	; 0x0b
    419e:	8b 81       	ldd	r24, Y+3	; 0x03
    41a0:	9c 81       	ldd	r25, Y+4	; 0x04
    41a2:	95 83       	std	Z+5, r25	; 0x05
    41a4:	84 83       	std	Z+4, r24	; 0x04
    41a6:	eb 81       	ldd	r30, Y+3	; 0x03
    41a8:	fc 81       	ldd	r31, Y+4	; 0x04
    41aa:	84 81       	ldd	r24, Z+4	; 0x04
    41ac:	95 81       	ldd	r25, Z+5	; 0x05
    41ae:	ea 85       	ldd	r30, Y+10	; 0x0a
    41b0:	fb 85       	ldd	r31, Y+11	; 0x0b
    41b2:	97 83       	std	Z+7, r25	; 0x07
    41b4:	86 83       	std	Z+6, r24	; 0x06
    41b6:	eb 81       	ldd	r30, Y+3	; 0x03
    41b8:	fc 81       	ldd	r31, Y+4	; 0x04
    41ba:	04 80       	ldd	r0, Z+4	; 0x04
    41bc:	f5 81       	ldd	r31, Z+5	; 0x05
    41be:	e0 2d       	mov	r30, r0
    41c0:	8a 85       	ldd	r24, Y+10	; 0x0a
    41c2:	9b 85       	ldd	r25, Y+11	; 0x0b
    41c4:	02 96       	adiw	r24, 0x02	; 2
    41c6:	93 83       	std	Z+3, r25	; 0x03
    41c8:	82 83       	std	Z+2, r24	; 0x02
    41ca:	8a 85       	ldd	r24, Y+10	; 0x0a
    41cc:	9b 85       	ldd	r25, Y+11	; 0x0b
    41ce:	02 96       	adiw	r24, 0x02	; 2
    41d0:	eb 81       	ldd	r30, Y+3	; 0x03
    41d2:	fc 81       	ldd	r31, Y+4	; 0x04
    41d4:	95 83       	std	Z+5, r25	; 0x05
    41d6:	84 83       	std	Z+4, r24	; 0x04
    41d8:	ea 85       	ldd	r30, Y+10	; 0x0a
    41da:	fb 85       	ldd	r31, Y+11	; 0x0b
    41dc:	86 89       	ldd	r24, Z+22	; 0x16
    41de:	28 2f       	mov	r18, r24
    41e0:	30 e0       	ldi	r19, 0x00	; 0
    41e2:	c9 01       	movw	r24, r18
    41e4:	88 0f       	add	r24, r24
    41e6:	99 1f       	adc	r25, r25
    41e8:	88 0f       	add	r24, r24
    41ea:	99 1f       	adc	r25, r25
    41ec:	88 0f       	add	r24, r24
    41ee:	99 1f       	adc	r25, r25
    41f0:	82 0f       	add	r24, r18
    41f2:	93 1f       	adc	r25, r19
    41f4:	88 54       	subi	r24, 0x48	; 72
    41f6:	99 4f       	sbci	r25, 0xF9	; 249
    41f8:	ea 85       	ldd	r30, Y+10	; 0x0a
    41fa:	fb 85       	ldd	r31, Y+11	; 0x0b
    41fc:	93 87       	std	Z+11, r25	; 0x0b
    41fe:	82 87       	std	Z+10, r24	; 0x0a
    4200:	ea 85       	ldd	r30, Y+10	; 0x0a
    4202:	fb 85       	ldd	r31, Y+11	; 0x0b
    4204:	86 89       	ldd	r24, Z+22	; 0x16
    4206:	28 2f       	mov	r18, r24
    4208:	30 e0       	ldi	r19, 0x00	; 0
    420a:	c9 01       	movw	r24, r18
    420c:	88 0f       	add	r24, r24
    420e:	99 1f       	adc	r25, r25
    4210:	88 0f       	add	r24, r24
    4212:	99 1f       	adc	r25, r25
    4214:	88 0f       	add	r24, r24
    4216:	99 1f       	adc	r25, r25
    4218:	82 0f       	add	r24, r18
    421a:	93 1f       	adc	r25, r19
    421c:	fc 01       	movw	r30, r24
    421e:	e8 54       	subi	r30, 0x48	; 72
    4220:	f9 4f       	sbci	r31, 0xF9	; 249
    4222:	80 81       	ld	r24, Z
    4224:	8f 5f       	subi	r24, 0xFF	; 255
    4226:	80 83       	st	Z, r24
    4228:	30 c0       	rjmp	.+96     	; 0x428a <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    422a:	80 91 f3 06 	lds	r24, 0x06F3
    422e:	90 91 f4 06 	lds	r25, 0x06F4
    4232:	9a 83       	std	Y+2, r25	; 0x02
    4234:	89 83       	std	Y+1, r24	; 0x01
    4236:	ea 85       	ldd	r30, Y+10	; 0x0a
    4238:	fb 85       	ldd	r31, Y+11	; 0x0b
    423a:	89 81       	ldd	r24, Y+1	; 0x01
    423c:	9a 81       	ldd	r25, Y+2	; 0x02
    423e:	97 87       	std	Z+15, r25	; 0x0f
    4240:	86 87       	std	Z+14, r24	; 0x0e
    4242:	e9 81       	ldd	r30, Y+1	; 0x01
    4244:	fa 81       	ldd	r31, Y+2	; 0x02
    4246:	84 81       	ldd	r24, Z+4	; 0x04
    4248:	95 81       	ldd	r25, Z+5	; 0x05
    424a:	ea 85       	ldd	r30, Y+10	; 0x0a
    424c:	fb 85       	ldd	r31, Y+11	; 0x0b
    424e:	91 8b       	std	Z+17, r25	; 0x11
    4250:	80 8b       	std	Z+16, r24	; 0x10
    4252:	e9 81       	ldd	r30, Y+1	; 0x01
    4254:	fa 81       	ldd	r31, Y+2	; 0x02
    4256:	04 80       	ldd	r0, Z+4	; 0x04
    4258:	f5 81       	ldd	r31, Z+5	; 0x05
    425a:	e0 2d       	mov	r30, r0
    425c:	8a 85       	ldd	r24, Y+10	; 0x0a
    425e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4260:	0c 96       	adiw	r24, 0x0c	; 12
    4262:	93 83       	std	Z+3, r25	; 0x03
    4264:	82 83       	std	Z+2, r24	; 0x02
    4266:	8a 85       	ldd	r24, Y+10	; 0x0a
    4268:	9b 85       	ldd	r25, Y+11	; 0x0b
    426a:	0c 96       	adiw	r24, 0x0c	; 12
    426c:	e9 81       	ldd	r30, Y+1	; 0x01
    426e:	fa 81       	ldd	r31, Y+2	; 0x02
    4270:	95 83       	std	Z+5, r25	; 0x05
    4272:	84 83       	std	Z+4, r24	; 0x04
    4274:	ea 85       	ldd	r30, Y+10	; 0x0a
    4276:	fb 85       	ldd	r31, Y+11	; 0x0b
    4278:	82 ef       	ldi	r24, 0xF2	; 242
    427a:	96 e0       	ldi	r25, 0x06	; 6
    427c:	95 8b       	std	Z+21, r25	; 0x15
    427e:	84 8b       	std	Z+20, r24	; 0x14
    4280:	80 91 f2 06 	lds	r24, 0x06F2
    4284:	8f 5f       	subi	r24, 0xFF	; 255
    4286:	80 93 f2 06 	sts	0x06F2, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    428a:	ea 85       	ldd	r30, Y+10	; 0x0a
    428c:	fb 85       	ldd	r31, Y+11	; 0x0b
    428e:	96 89       	ldd	r25, Z+22	; 0x16
    4290:	e0 91 a6 06 	lds	r30, 0x06A6
    4294:	f0 91 a7 06 	lds	r31, 0x06A7
    4298:	86 89       	ldd	r24, Z+22	; 0x16
    429a:	89 17       	cp	r24, r25
    429c:	30 f4       	brcc	.+12     	; 0x42aa <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    429e:	81 e0       	ldi	r24, 0x01	; 1
    42a0:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    42a2:	81 e0       	ldi	r24, 0x01	; 1
    42a4:	80 93 b0 06 	sts	0x06B0, r24
    42a8:	01 c0       	rjmp	.+2      	; 0x42ac <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    42aa:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    42ac:	89 85       	ldd	r24, Y+9	; 0x09
}
    42ae:	2d 96       	adiw	r28, 0x0d	; 13
    42b0:	0f b6       	in	r0, 0x3f	; 63
    42b2:	f8 94       	cli
    42b4:	de bf       	out	0x3e, r29	; 62
    42b6:	0f be       	out	0x3f, r0	; 63
    42b8:	cd bf       	out	0x3d, r28	; 61
    42ba:	cf 91       	pop	r28
    42bc:	df 91       	pop	r29
    42be:	08 95       	ret

000042c0 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    42c0:	df 93       	push	r29
    42c2:	cf 93       	push	r28
    42c4:	cd b7       	in	r28, 0x3d	; 61
    42c6:	de b7       	in	r29, 0x3e	; 62
    42c8:	2c 97       	sbiw	r28, 0x0c	; 12
    42ca:	0f b6       	in	r0, 0x3f	; 63
    42cc:	f8 94       	cli
    42ce:	de bf       	out	0x3e, r29	; 62
    42d0:	0f be       	out	0x3f, r0	; 63
    42d2:	cd bf       	out	0x3d, r28	; 61
    42d4:	9a 87       	std	Y+10, r25	; 0x0a
    42d6:	89 87       	std	Y+9, r24	; 0x09
    42d8:	7c 87       	std	Y+12, r23	; 0x0c
    42da:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    42dc:	8b 85       	ldd	r24, Y+11	; 0x0b
    42de:	9c 85       	ldd	r25, Y+12	; 0x0c
    42e0:	90 68       	ori	r25, 0x80	; 128
    42e2:	e9 85       	ldd	r30, Y+9	; 0x09
    42e4:	fa 85       	ldd	r31, Y+10	; 0x0a
    42e6:	91 83       	std	Z+1, r25	; 0x01
    42e8:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    42ea:	e9 85       	ldd	r30, Y+9	; 0x09
    42ec:	fa 85       	ldd	r31, Y+10	; 0x0a
    42ee:	86 81       	ldd	r24, Z+6	; 0x06
    42f0:	97 81       	ldd	r25, Z+7	; 0x07
    42f2:	98 87       	std	Y+8, r25	; 0x08
    42f4:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    42f6:	e9 85       	ldd	r30, Y+9	; 0x09
    42f8:	fa 85       	ldd	r31, Y+10	; 0x0a
    42fa:	80 85       	ldd	r24, Z+8	; 0x08
    42fc:	91 85       	ldd	r25, Z+9	; 0x09
    42fe:	9e 83       	std	Y+6, r25	; 0x06
    4300:	8d 83       	std	Y+5, r24	; 0x05
    4302:	e9 85       	ldd	r30, Y+9	; 0x09
    4304:	fa 85       	ldd	r31, Y+10	; 0x0a
    4306:	a2 81       	ldd	r26, Z+2	; 0x02
    4308:	b3 81       	ldd	r27, Z+3	; 0x03
    430a:	e9 85       	ldd	r30, Y+9	; 0x09
    430c:	fa 85       	ldd	r31, Y+10	; 0x0a
    430e:	84 81       	ldd	r24, Z+4	; 0x04
    4310:	95 81       	ldd	r25, Z+5	; 0x05
    4312:	15 96       	adiw	r26, 0x05	; 5
    4314:	9c 93       	st	X, r25
    4316:	8e 93       	st	-X, r24
    4318:	14 97       	sbiw	r26, 0x04	; 4
    431a:	e9 85       	ldd	r30, Y+9	; 0x09
    431c:	fa 85       	ldd	r31, Y+10	; 0x0a
    431e:	a4 81       	ldd	r26, Z+4	; 0x04
    4320:	b5 81       	ldd	r27, Z+5	; 0x05
    4322:	e9 85       	ldd	r30, Y+9	; 0x09
    4324:	fa 85       	ldd	r31, Y+10	; 0x0a
    4326:	82 81       	ldd	r24, Z+2	; 0x02
    4328:	93 81       	ldd	r25, Z+3	; 0x03
    432a:	13 96       	adiw	r26, 0x03	; 3
    432c:	9c 93       	st	X, r25
    432e:	8e 93       	st	-X, r24
    4330:	12 97       	sbiw	r26, 0x02	; 2
    4332:	ed 81       	ldd	r30, Y+5	; 0x05
    4334:	fe 81       	ldd	r31, Y+6	; 0x06
    4336:	21 81       	ldd	r18, Z+1	; 0x01
    4338:	32 81       	ldd	r19, Z+2	; 0x02
    433a:	89 85       	ldd	r24, Y+9	; 0x09
    433c:	9a 85       	ldd	r25, Y+10	; 0x0a
    433e:	28 17       	cp	r18, r24
    4340:	39 07       	cpc	r19, r25
    4342:	41 f4       	brne	.+16     	; 0x4354 <vTaskRemoveFromUnorderedEventList+0x94>
    4344:	e9 85       	ldd	r30, Y+9	; 0x09
    4346:	fa 85       	ldd	r31, Y+10	; 0x0a
    4348:	84 81       	ldd	r24, Z+4	; 0x04
    434a:	95 81       	ldd	r25, Z+5	; 0x05
    434c:	ed 81       	ldd	r30, Y+5	; 0x05
    434e:	fe 81       	ldd	r31, Y+6	; 0x06
    4350:	92 83       	std	Z+2, r25	; 0x02
    4352:	81 83       	std	Z+1, r24	; 0x01
    4354:	e9 85       	ldd	r30, Y+9	; 0x09
    4356:	fa 85       	ldd	r31, Y+10	; 0x0a
    4358:	11 86       	std	Z+9, r1	; 0x09
    435a:	10 86       	std	Z+8, r1	; 0x08
    435c:	ed 81       	ldd	r30, Y+5	; 0x05
    435e:	fe 81       	ldd	r31, Y+6	; 0x06
    4360:	80 81       	ld	r24, Z
    4362:	81 50       	subi	r24, 0x01	; 1
    4364:	ed 81       	ldd	r30, Y+5	; 0x05
    4366:	fe 81       	ldd	r31, Y+6	; 0x06
    4368:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    436a:	ef 81       	ldd	r30, Y+7	; 0x07
    436c:	f8 85       	ldd	r31, Y+8	; 0x08
    436e:	82 85       	ldd	r24, Z+10	; 0x0a
    4370:	93 85       	ldd	r25, Z+11	; 0x0b
    4372:	9c 83       	std	Y+4, r25	; 0x04
    4374:	8b 83       	std	Y+3, r24	; 0x03
    4376:	ef 81       	ldd	r30, Y+7	; 0x07
    4378:	f8 85       	ldd	r31, Y+8	; 0x08
    437a:	a4 81       	ldd	r26, Z+4	; 0x04
    437c:	b5 81       	ldd	r27, Z+5	; 0x05
    437e:	ef 81       	ldd	r30, Y+7	; 0x07
    4380:	f8 85       	ldd	r31, Y+8	; 0x08
    4382:	86 81       	ldd	r24, Z+6	; 0x06
    4384:	97 81       	ldd	r25, Z+7	; 0x07
    4386:	15 96       	adiw	r26, 0x05	; 5
    4388:	9c 93       	st	X, r25
    438a:	8e 93       	st	-X, r24
    438c:	14 97       	sbiw	r26, 0x04	; 4
    438e:	ef 81       	ldd	r30, Y+7	; 0x07
    4390:	f8 85       	ldd	r31, Y+8	; 0x08
    4392:	a6 81       	ldd	r26, Z+6	; 0x06
    4394:	b7 81       	ldd	r27, Z+7	; 0x07
    4396:	ef 81       	ldd	r30, Y+7	; 0x07
    4398:	f8 85       	ldd	r31, Y+8	; 0x08
    439a:	84 81       	ldd	r24, Z+4	; 0x04
    439c:	95 81       	ldd	r25, Z+5	; 0x05
    439e:	13 96       	adiw	r26, 0x03	; 3
    43a0:	9c 93       	st	X, r25
    43a2:	8e 93       	st	-X, r24
    43a4:	12 97       	sbiw	r26, 0x02	; 2
    43a6:	eb 81       	ldd	r30, Y+3	; 0x03
    43a8:	fc 81       	ldd	r31, Y+4	; 0x04
    43aa:	21 81       	ldd	r18, Z+1	; 0x01
    43ac:	32 81       	ldd	r19, Z+2	; 0x02
    43ae:	8f 81       	ldd	r24, Y+7	; 0x07
    43b0:	98 85       	ldd	r25, Y+8	; 0x08
    43b2:	02 96       	adiw	r24, 0x02	; 2
    43b4:	28 17       	cp	r18, r24
    43b6:	39 07       	cpc	r19, r25
    43b8:	41 f4       	brne	.+16     	; 0x43ca <vTaskRemoveFromUnorderedEventList+0x10a>
    43ba:	ef 81       	ldd	r30, Y+7	; 0x07
    43bc:	f8 85       	ldd	r31, Y+8	; 0x08
    43be:	86 81       	ldd	r24, Z+6	; 0x06
    43c0:	97 81       	ldd	r25, Z+7	; 0x07
    43c2:	eb 81       	ldd	r30, Y+3	; 0x03
    43c4:	fc 81       	ldd	r31, Y+4	; 0x04
    43c6:	92 83       	std	Z+2, r25	; 0x02
    43c8:	81 83       	std	Z+1, r24	; 0x01
    43ca:	ef 81       	ldd	r30, Y+7	; 0x07
    43cc:	f8 85       	ldd	r31, Y+8	; 0x08
    43ce:	13 86       	std	Z+11, r1	; 0x0b
    43d0:	12 86       	std	Z+10, r1	; 0x0a
    43d2:	eb 81       	ldd	r30, Y+3	; 0x03
    43d4:	fc 81       	ldd	r31, Y+4	; 0x04
    43d6:	80 81       	ld	r24, Z
    43d8:	81 50       	subi	r24, 0x01	; 1
    43da:	eb 81       	ldd	r30, Y+3	; 0x03
    43dc:	fc 81       	ldd	r31, Y+4	; 0x04
    43de:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    43e0:	ef 81       	ldd	r30, Y+7	; 0x07
    43e2:	f8 85       	ldd	r31, Y+8	; 0x08
    43e4:	96 89       	ldd	r25, Z+22	; 0x16
    43e6:	80 91 ac 06 	lds	r24, 0x06AC
    43ea:	89 17       	cp	r24, r25
    43ec:	28 f4       	brcc	.+10     	; 0x43f8 <vTaskRemoveFromUnorderedEventList+0x138>
    43ee:	ef 81       	ldd	r30, Y+7	; 0x07
    43f0:	f8 85       	ldd	r31, Y+8	; 0x08
    43f2:	86 89       	ldd	r24, Z+22	; 0x16
    43f4:	80 93 ac 06 	sts	0x06AC, r24
    43f8:	ef 81       	ldd	r30, Y+7	; 0x07
    43fa:	f8 85       	ldd	r31, Y+8	; 0x08
    43fc:	86 89       	ldd	r24, Z+22	; 0x16
    43fe:	28 2f       	mov	r18, r24
    4400:	30 e0       	ldi	r19, 0x00	; 0
    4402:	c9 01       	movw	r24, r18
    4404:	88 0f       	add	r24, r24
    4406:	99 1f       	adc	r25, r25
    4408:	88 0f       	add	r24, r24
    440a:	99 1f       	adc	r25, r25
    440c:	88 0f       	add	r24, r24
    440e:	99 1f       	adc	r25, r25
    4410:	82 0f       	add	r24, r18
    4412:	93 1f       	adc	r25, r19
    4414:	fc 01       	movw	r30, r24
    4416:	e8 54       	subi	r30, 0x48	; 72
    4418:	f9 4f       	sbci	r31, 0xF9	; 249
    441a:	81 81       	ldd	r24, Z+1	; 0x01
    441c:	92 81       	ldd	r25, Z+2	; 0x02
    441e:	9a 83       	std	Y+2, r25	; 0x02
    4420:	89 83       	std	Y+1, r24	; 0x01
    4422:	ef 81       	ldd	r30, Y+7	; 0x07
    4424:	f8 85       	ldd	r31, Y+8	; 0x08
    4426:	89 81       	ldd	r24, Y+1	; 0x01
    4428:	9a 81       	ldd	r25, Y+2	; 0x02
    442a:	95 83       	std	Z+5, r25	; 0x05
    442c:	84 83       	std	Z+4, r24	; 0x04
    442e:	e9 81       	ldd	r30, Y+1	; 0x01
    4430:	fa 81       	ldd	r31, Y+2	; 0x02
    4432:	84 81       	ldd	r24, Z+4	; 0x04
    4434:	95 81       	ldd	r25, Z+5	; 0x05
    4436:	ef 81       	ldd	r30, Y+7	; 0x07
    4438:	f8 85       	ldd	r31, Y+8	; 0x08
    443a:	97 83       	std	Z+7, r25	; 0x07
    443c:	86 83       	std	Z+6, r24	; 0x06
    443e:	e9 81       	ldd	r30, Y+1	; 0x01
    4440:	fa 81       	ldd	r31, Y+2	; 0x02
    4442:	04 80       	ldd	r0, Z+4	; 0x04
    4444:	f5 81       	ldd	r31, Z+5	; 0x05
    4446:	e0 2d       	mov	r30, r0
    4448:	8f 81       	ldd	r24, Y+7	; 0x07
    444a:	98 85       	ldd	r25, Y+8	; 0x08
    444c:	02 96       	adiw	r24, 0x02	; 2
    444e:	93 83       	std	Z+3, r25	; 0x03
    4450:	82 83       	std	Z+2, r24	; 0x02
    4452:	8f 81       	ldd	r24, Y+7	; 0x07
    4454:	98 85       	ldd	r25, Y+8	; 0x08
    4456:	02 96       	adiw	r24, 0x02	; 2
    4458:	e9 81       	ldd	r30, Y+1	; 0x01
    445a:	fa 81       	ldd	r31, Y+2	; 0x02
    445c:	95 83       	std	Z+5, r25	; 0x05
    445e:	84 83       	std	Z+4, r24	; 0x04
    4460:	ef 81       	ldd	r30, Y+7	; 0x07
    4462:	f8 85       	ldd	r31, Y+8	; 0x08
    4464:	86 89       	ldd	r24, Z+22	; 0x16
    4466:	28 2f       	mov	r18, r24
    4468:	30 e0       	ldi	r19, 0x00	; 0
    446a:	c9 01       	movw	r24, r18
    446c:	88 0f       	add	r24, r24
    446e:	99 1f       	adc	r25, r25
    4470:	88 0f       	add	r24, r24
    4472:	99 1f       	adc	r25, r25
    4474:	88 0f       	add	r24, r24
    4476:	99 1f       	adc	r25, r25
    4478:	82 0f       	add	r24, r18
    447a:	93 1f       	adc	r25, r19
    447c:	88 54       	subi	r24, 0x48	; 72
    447e:	99 4f       	sbci	r25, 0xF9	; 249
    4480:	ef 81       	ldd	r30, Y+7	; 0x07
    4482:	f8 85       	ldd	r31, Y+8	; 0x08
    4484:	93 87       	std	Z+11, r25	; 0x0b
    4486:	82 87       	std	Z+10, r24	; 0x0a
    4488:	ef 81       	ldd	r30, Y+7	; 0x07
    448a:	f8 85       	ldd	r31, Y+8	; 0x08
    448c:	86 89       	ldd	r24, Z+22	; 0x16
    448e:	28 2f       	mov	r18, r24
    4490:	30 e0       	ldi	r19, 0x00	; 0
    4492:	c9 01       	movw	r24, r18
    4494:	88 0f       	add	r24, r24
    4496:	99 1f       	adc	r25, r25
    4498:	88 0f       	add	r24, r24
    449a:	99 1f       	adc	r25, r25
    449c:	88 0f       	add	r24, r24
    449e:	99 1f       	adc	r25, r25
    44a0:	82 0f       	add	r24, r18
    44a2:	93 1f       	adc	r25, r19
    44a4:	fc 01       	movw	r30, r24
    44a6:	e8 54       	subi	r30, 0x48	; 72
    44a8:	f9 4f       	sbci	r31, 0xF9	; 249
    44aa:	80 81       	ld	r24, Z
    44ac:	8f 5f       	subi	r24, 0xFF	; 255
    44ae:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    44b0:	ef 81       	ldd	r30, Y+7	; 0x07
    44b2:	f8 85       	ldd	r31, Y+8	; 0x08
    44b4:	96 89       	ldd	r25, Z+22	; 0x16
    44b6:	e0 91 a6 06 	lds	r30, 0x06A6
    44ba:	f0 91 a7 06 	lds	r31, 0x06A7
    44be:	86 89       	ldd	r24, Z+22	; 0x16
    44c0:	89 17       	cp	r24, r25
    44c2:	18 f4       	brcc	.+6      	; 0x44ca <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    44c4:	81 e0       	ldi	r24, 0x01	; 1
    44c6:	80 93 b0 06 	sts	0x06B0, r24
    }
}
    44ca:	2c 96       	adiw	r28, 0x0c	; 12
    44cc:	0f b6       	in	r0, 0x3f	; 63
    44ce:	f8 94       	cli
    44d0:	de bf       	out	0x3e, r29	; 62
    44d2:	0f be       	out	0x3f, r0	; 63
    44d4:	cd bf       	out	0x3d, r28	; 61
    44d6:	cf 91       	pop	r28
    44d8:	df 91       	pop	r29
    44da:	08 95       	ret

000044dc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    44dc:	df 93       	push	r29
    44de:	cf 93       	push	r28
    44e0:	00 d0       	rcall	.+0      	; 0x44e2 <vTaskSetTimeOutState+0x6>
    44e2:	cd b7       	in	r28, 0x3d	; 61
    44e4:	de b7       	in	r29, 0x3e	; 62
    44e6:	9a 83       	std	Y+2, r25	; 0x02
    44e8:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    44ea:	0f b6       	in	r0, 0x3f	; 63
    44ec:	f8 94       	cli
    44ee:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    44f0:	80 91 b1 06 	lds	r24, 0x06B1
    44f4:	e9 81       	ldd	r30, Y+1	; 0x01
    44f6:	fa 81       	ldd	r31, Y+2	; 0x02
    44f8:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    44fa:	80 91 aa 06 	lds	r24, 0x06AA
    44fe:	90 91 ab 06 	lds	r25, 0x06AB
    4502:	e9 81       	ldd	r30, Y+1	; 0x01
    4504:	fa 81       	ldd	r31, Y+2	; 0x02
    4506:	92 83       	std	Z+2, r25	; 0x02
    4508:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    450a:	0f 90       	pop	r0
    450c:	0f be       	out	0x3f, r0	; 63
}
    450e:	0f 90       	pop	r0
    4510:	0f 90       	pop	r0
    4512:	cf 91       	pop	r28
    4514:	df 91       	pop	r29
    4516:	08 95       	ret

00004518 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4518:	df 93       	push	r29
    451a:	cf 93       	push	r28
    451c:	00 d0       	rcall	.+0      	; 0x451e <vTaskInternalSetTimeOutState+0x6>
    451e:	cd b7       	in	r28, 0x3d	; 61
    4520:	de b7       	in	r29, 0x3e	; 62
    4522:	9a 83       	std	Y+2, r25	; 0x02
    4524:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    4526:	80 91 b1 06 	lds	r24, 0x06B1
    452a:	e9 81       	ldd	r30, Y+1	; 0x01
    452c:	fa 81       	ldd	r31, Y+2	; 0x02
    452e:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    4530:	80 91 aa 06 	lds	r24, 0x06AA
    4534:	90 91 ab 06 	lds	r25, 0x06AB
    4538:	e9 81       	ldd	r30, Y+1	; 0x01
    453a:	fa 81       	ldd	r31, Y+2	; 0x02
    453c:	92 83       	std	Z+2, r25	; 0x02
    453e:	81 83       	std	Z+1, r24	; 0x01
}
    4540:	0f 90       	pop	r0
    4542:	0f 90       	pop	r0
    4544:	cf 91       	pop	r28
    4546:	df 91       	pop	r29
    4548:	08 95       	ret

0000454a <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    454a:	df 93       	push	r29
    454c:	cf 93       	push	r28
    454e:	cd b7       	in	r28, 0x3d	; 61
    4550:	de b7       	in	r29, 0x3e	; 62
    4552:	29 97       	sbiw	r28, 0x09	; 9
    4554:	0f b6       	in	r0, 0x3f	; 63
    4556:	f8 94       	cli
    4558:	de bf       	out	0x3e, r29	; 62
    455a:	0f be       	out	0x3f, r0	; 63
    455c:	cd bf       	out	0x3d, r28	; 61
    455e:	9f 83       	std	Y+7, r25	; 0x07
    4560:	8e 83       	std	Y+6, r24	; 0x06
    4562:	79 87       	std	Y+9, r23	; 0x09
    4564:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    4566:	0f b6       	in	r0, 0x3f	; 63
    4568:	f8 94       	cli
    456a:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    456c:	80 91 aa 06 	lds	r24, 0x06AA
    4570:	90 91 ab 06 	lds	r25, 0x06AB
    4574:	9c 83       	std	Y+4, r25	; 0x04
    4576:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4578:	ee 81       	ldd	r30, Y+6	; 0x06
    457a:	ff 81       	ldd	r31, Y+7	; 0x07
    457c:	21 81       	ldd	r18, Z+1	; 0x01
    457e:	32 81       	ldd	r19, Z+2	; 0x02
    4580:	8b 81       	ldd	r24, Y+3	; 0x03
    4582:	9c 81       	ldd	r25, Y+4	; 0x04
    4584:	82 1b       	sub	r24, r18
    4586:	93 0b       	sbc	r25, r19
    4588:	9a 83       	std	Y+2, r25	; 0x02
    458a:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    458c:	ee 81       	ldd	r30, Y+6	; 0x06
    458e:	ff 81       	ldd	r31, Y+7	; 0x07
    4590:	90 81       	ld	r25, Z
    4592:	80 91 b1 06 	lds	r24, 0x06B1
    4596:	98 17       	cp	r25, r24
    4598:	81 f0       	breq	.+32     	; 0x45ba <xTaskCheckForTimeOut+0x70>
    459a:	ee 81       	ldd	r30, Y+6	; 0x06
    459c:	ff 81       	ldd	r31, Y+7	; 0x07
    459e:	21 81       	ldd	r18, Z+1	; 0x01
    45a0:	32 81       	ldd	r19, Z+2	; 0x02
    45a2:	8b 81       	ldd	r24, Y+3	; 0x03
    45a4:	9c 81       	ldd	r25, Y+4	; 0x04
    45a6:	82 17       	cp	r24, r18
    45a8:	93 07       	cpc	r25, r19
    45aa:	38 f0       	brcs	.+14     	; 0x45ba <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    45ac:	81 e0       	ldi	r24, 0x01	; 1
    45ae:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    45b0:	e8 85       	ldd	r30, Y+8	; 0x08
    45b2:	f9 85       	ldd	r31, Y+9	; 0x09
    45b4:	11 82       	std	Z+1, r1	; 0x01
    45b6:	10 82       	st	Z, r1
    45b8:	23 c0       	rjmp	.+70     	; 0x4600 <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    45ba:	e8 85       	ldd	r30, Y+8	; 0x08
    45bc:	f9 85       	ldd	r31, Y+9	; 0x09
    45be:	20 81       	ld	r18, Z
    45c0:	31 81       	ldd	r19, Z+1	; 0x01
    45c2:	89 81       	ldd	r24, Y+1	; 0x01
    45c4:	9a 81       	ldd	r25, Y+2	; 0x02
    45c6:	82 17       	cp	r24, r18
    45c8:	93 07       	cpc	r25, r19
    45ca:	a0 f4       	brcc	.+40     	; 0x45f4 <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    45cc:	e8 85       	ldd	r30, Y+8	; 0x08
    45ce:	f9 85       	ldd	r31, Y+9	; 0x09
    45d0:	20 81       	ld	r18, Z
    45d2:	31 81       	ldd	r19, Z+1	; 0x01
    45d4:	89 81       	ldd	r24, Y+1	; 0x01
    45d6:	9a 81       	ldd	r25, Y+2	; 0x02
    45d8:	a9 01       	movw	r20, r18
    45da:	48 1b       	sub	r20, r24
    45dc:	59 0b       	sbc	r21, r25
    45de:	ca 01       	movw	r24, r20
    45e0:	e8 85       	ldd	r30, Y+8	; 0x08
    45e2:	f9 85       	ldd	r31, Y+9	; 0x09
    45e4:	91 83       	std	Z+1, r25	; 0x01
    45e6:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    45e8:	8e 81       	ldd	r24, Y+6	; 0x06
    45ea:	9f 81       	ldd	r25, Y+7	; 0x07
    45ec:	0e 94 8c 22 	call	0x4518	; 0x4518 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    45f0:	1d 82       	std	Y+5, r1	; 0x05
    45f2:	06 c0       	rjmp	.+12     	; 0x4600 <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    45f4:	e8 85       	ldd	r30, Y+8	; 0x08
    45f6:	f9 85       	ldd	r31, Y+9	; 0x09
    45f8:	11 82       	std	Z+1, r1	; 0x01
    45fa:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    45fc:	81 e0       	ldi	r24, 0x01	; 1
    45fe:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    4600:	0f 90       	pop	r0
    4602:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    4604:	8d 81       	ldd	r24, Y+5	; 0x05
}
    4606:	29 96       	adiw	r28, 0x09	; 9
    4608:	0f b6       	in	r0, 0x3f	; 63
    460a:	f8 94       	cli
    460c:	de bf       	out	0x3e, r29	; 62
    460e:	0f be       	out	0x3f, r0	; 63
    4610:	cd bf       	out	0x3d, r28	; 61
    4612:	cf 91       	pop	r28
    4614:	df 91       	pop	r29
    4616:	08 95       	ret

00004618 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4618:	df 93       	push	r29
    461a:	cf 93       	push	r28
    461c:	cd b7       	in	r28, 0x3d	; 61
    461e:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    4620:	81 e0       	ldi	r24, 0x01	; 1
    4622:	80 93 b0 06 	sts	0x06B0, r24
}
    4626:	cf 91       	pop	r28
    4628:	df 91       	pop	r29
    462a:	08 95       	ret

0000462c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    462c:	df 93       	push	r29
    462e:	cf 93       	push	r28
    4630:	00 d0       	rcall	.+0      	; 0x4632 <prvIdleTask+0x6>
    4632:	cd b7       	in	r28, 0x3d	; 61
    4634:	de b7       	in	r29, 0x3e	; 62
    4636:	9a 83       	std	Y+2, r25	; 0x02
    4638:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    463a:	0e 94 63 23 	call	0x46c6	; 0x46c6 <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    463e:	80 91 b8 06 	lds	r24, 0x06B8
    4642:	82 30       	cpi	r24, 0x02	; 2
    4644:	d0 f3       	brcs	.-12     	; 0x463a <prvIdleTask+0xe>
                {
                    taskYIELD();
    4646:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    464a:	f7 cf       	rjmp	.-18     	; 0x463a <prvIdleTask+0xe>

0000464c <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    464c:	df 93       	push	r29
    464e:	cf 93       	push	r28
    4650:	0f 92       	push	r0
    4652:	cd b7       	in	r28, 0x3d	; 61
    4654:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4656:	19 82       	std	Y+1, r1	; 0x01
    4658:	13 c0       	rjmp	.+38     	; 0x4680 <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    465a:	89 81       	ldd	r24, Y+1	; 0x01
    465c:	28 2f       	mov	r18, r24
    465e:	30 e0       	ldi	r19, 0x00	; 0
    4660:	c9 01       	movw	r24, r18
    4662:	88 0f       	add	r24, r24
    4664:	99 1f       	adc	r25, r25
    4666:	88 0f       	add	r24, r24
    4668:	99 1f       	adc	r25, r25
    466a:	88 0f       	add	r24, r24
    466c:	99 1f       	adc	r25, r25
    466e:	82 0f       	add	r24, r18
    4670:	93 1f       	adc	r25, r19
    4672:	88 54       	subi	r24, 0x48	; 72
    4674:	99 4f       	sbci	r25, 0xF9	; 249
    4676:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    467a:	89 81       	ldd	r24, Y+1	; 0x01
    467c:	8f 5f       	subi	r24, 0xFF	; 255
    467e:	89 83       	std	Y+1, r24	; 0x01
    4680:	89 81       	ldd	r24, Y+1	; 0x01
    4682:	84 30       	cpi	r24, 0x04	; 4
    4684:	50 f3       	brcs	.-44     	; 0x465a <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    4686:	8c ed       	ldi	r24, 0xDC	; 220
    4688:	96 e0       	ldi	r25, 0x06	; 6
    468a:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    468e:	85 ee       	ldi	r24, 0xE5	; 229
    4690:	96 e0       	ldi	r25, 0x06	; 6
    4692:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    4696:	82 ef       	ldi	r24, 0xF2	; 242
    4698:	96 e0       	ldi	r25, 0x06	; 6
    469a:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    469e:	8b ef       	ldi	r24, 0xFB	; 251
    46a0:	96 e0       	ldi	r25, 0x06	; 6
    46a2:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    46a6:	8c ed       	ldi	r24, 0xDC	; 220
    46a8:	96 e0       	ldi	r25, 0x06	; 6
    46aa:	90 93 ef 06 	sts	0x06EF, r25
    46ae:	80 93 ee 06 	sts	0x06EE, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    46b2:	85 ee       	ldi	r24, 0xE5	; 229
    46b4:	96 e0       	ldi	r25, 0x06	; 6
    46b6:	90 93 f1 06 	sts	0x06F1, r25
    46ba:	80 93 f0 06 	sts	0x06F0, r24
}
    46be:	0f 90       	pop	r0
    46c0:	cf 91       	pop	r28
    46c2:	df 91       	pop	r29
    46c4:	08 95       	ret

000046c6 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    46c6:	df 93       	push	r29
    46c8:	cf 93       	push	r28
    46ca:	00 d0       	rcall	.+0      	; 0x46cc <prvCheckTasksWaitingTermination+0x6>
    46cc:	cd b7       	in	r28, 0x3d	; 61
    46ce:	de b7       	in	r29, 0x3e	; 62
    46d0:	20 c0       	rjmp	.+64     	; 0x4712 <prvCheckTasksWaitingTermination+0x4c>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    46d2:	0f b6       	in	r0, 0x3f	; 63
    46d4:	f8 94       	cli
    46d6:	0f 92       	push	r0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    46d8:	e0 91 00 07 	lds	r30, 0x0700
    46dc:	f0 91 01 07 	lds	r31, 0x0701
    46e0:	86 81       	ldd	r24, Z+6	; 0x06
    46e2:	97 81       	ldd	r25, Z+7	; 0x07
    46e4:	9a 83       	std	Y+2, r25	; 0x02
    46e6:	89 83       	std	Y+1, r24	; 0x01
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    46e8:	89 81       	ldd	r24, Y+1	; 0x01
    46ea:	9a 81       	ldd	r25, Y+2	; 0x02
    46ec:	02 96       	adiw	r24, 0x02	; 2
    46ee:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <uxListRemove>
                    --uxCurrentNumberOfTasks;
    46f2:	80 91 a9 06 	lds	r24, 0x06A9
    46f6:	81 50       	subi	r24, 0x01	; 1
    46f8:	80 93 a9 06 	sts	0x06A9, r24
                    --uxDeletedTasksWaitingCleanUp;
    46fc:	80 91 a8 06 	lds	r24, 0x06A8
    4700:	81 50       	subi	r24, 0x01	; 1
    4702:	80 93 a8 06 	sts	0x06A8, r24
                }
                taskEXIT_CRITICAL();
    4706:	0f 90       	pop	r0
    4708:	0f be       	out	0x3f, r0	; 63

                prvDeleteTCB( pxTCB );
    470a:	89 81       	ldd	r24, Y+1	; 0x01
    470c:	9a 81       	ldd	r25, Y+2	; 0x02
    470e:	0e 94 92 23 	call	0x4724	; 0x4724 <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    4712:	80 91 a8 06 	lds	r24, 0x06A8
    4716:	88 23       	and	r24, r24
    4718:	e1 f6       	brne	.-72     	; 0x46d2 <prvCheckTasksWaitingTermination+0xc>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    471a:	0f 90       	pop	r0
    471c:	0f 90       	pop	r0
    471e:	cf 91       	pop	r28
    4720:	df 91       	pop	r29
    4722:	08 95       	ret

00004724 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    4724:	df 93       	push	r29
    4726:	cf 93       	push	r28
    4728:	00 d0       	rcall	.+0      	; 0x472a <prvDeleteTCB+0x6>
    472a:	cd b7       	in	r28, 0x3d	; 61
    472c:	de b7       	in	r29, 0x3e	; 62
    472e:	9a 83       	std	Y+2, r25	; 0x02
    4730:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    4732:	e9 81       	ldd	r30, Y+1	; 0x01
    4734:	fa 81       	ldd	r31, Y+2	; 0x02
    4736:	87 89       	ldd	r24, Z+23	; 0x17
    4738:	90 8d       	ldd	r25, Z+24	; 0x18
    473a:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                vPortFree( pxTCB );
    473e:	89 81       	ldd	r24, Y+1	; 0x01
    4740:	9a 81       	ldd	r25, Y+2	; 0x02
    4742:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    4746:	0f 90       	pop	r0
    4748:	0f 90       	pop	r0
    474a:	cf 91       	pop	r28
    474c:	df 91       	pop	r29
    474e:	08 95       	ret

00004750 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4750:	df 93       	push	r29
    4752:	cf 93       	push	r28
    4754:	cd b7       	in	r28, 0x3d	; 61
    4756:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4758:	e0 91 ee 06 	lds	r30, 0x06EE
    475c:	f0 91 ef 06 	lds	r31, 0x06EF
    4760:	80 81       	ld	r24, Z
    4762:	88 23       	and	r24, r24
    4764:	39 f4       	brne	.+14     	; 0x4774 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    4766:	8f ef       	ldi	r24, 0xFF	; 255
    4768:	9f ef       	ldi	r25, 0xFF	; 255
    476a:	90 93 b4 06 	sts	0x06B4, r25
    476e:	80 93 b3 06 	sts	0x06B3, r24
    4772:	0d c0       	rjmp	.+26     	; 0x478e <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    4774:	e0 91 ee 06 	lds	r30, 0x06EE
    4778:	f0 91 ef 06 	lds	r31, 0x06EF
    477c:	05 80       	ldd	r0, Z+5	; 0x05
    477e:	f6 81       	ldd	r31, Z+6	; 0x06
    4780:	e0 2d       	mov	r30, r0
    4782:	80 81       	ld	r24, Z
    4784:	91 81       	ldd	r25, Z+1	; 0x01
    4786:	90 93 b4 06 	sts	0x06B4, r25
    478a:	80 93 b3 06 	sts	0x06B3, r24
    }
}
    478e:	cf 91       	pop	r28
    4790:	df 91       	pop	r29
    4792:	08 95       	ret

00004794 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
    4794:	df 93       	push	r29
    4796:	cf 93       	push	r28
    4798:	0f 92       	push	r0
    479a:	cd b7       	in	r28, 0x3d	; 61
    479c:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
    479e:	80 91 ad 06 	lds	r24, 0x06AD
    47a2:	88 23       	and	r24, r24
    47a4:	19 f4       	brne	.+6      	; 0x47ac <xTaskGetSchedulerState+0x18>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
    47a6:	81 e0       	ldi	r24, 0x01	; 1
    47a8:	89 83       	std	Y+1, r24	; 0x01
    47aa:	08 c0       	rjmp	.+16     	; 0x47bc <xTaskGetSchedulerState+0x28>
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    47ac:	80 91 b7 06 	lds	r24, 0x06B7
    47b0:	88 23       	and	r24, r24
    47b2:	19 f4       	brne	.+6      	; 0x47ba <xTaskGetSchedulerState+0x26>
            {
                xReturn = taskSCHEDULER_RUNNING;
    47b4:	82 e0       	ldi	r24, 0x02	; 2
    47b6:	89 83       	std	Y+1, r24	; 0x01
    47b8:	01 c0       	rjmp	.+2      	; 0x47bc <xTaskGetSchedulerState+0x28>
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
    47ba:	19 82       	std	Y+1, r1	; 0x01
            }
        }

        return xReturn;
    47bc:	89 81       	ldd	r24, Y+1	; 0x01
    }
    47be:	0f 90       	pop	r0
    47c0:	cf 91       	pop	r28
    47c2:	df 91       	pop	r29
    47c4:	08 95       	ret

000047c6 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    47c6:	df 93       	push	r29
    47c8:	cf 93       	push	r28
    47ca:	00 d0       	rcall	.+0      	; 0x47cc <uxTaskResetEventItemValue+0x6>
    47cc:	cd b7       	in	r28, 0x3d	; 61
    47ce:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    47d0:	e0 91 a6 06 	lds	r30, 0x06A6
    47d4:	f0 91 a7 06 	lds	r31, 0x06A7
    47d8:	84 85       	ldd	r24, Z+12	; 0x0c
    47da:	95 85       	ldd	r25, Z+13	; 0x0d
    47dc:	9a 83       	std	Y+2, r25	; 0x02
    47de:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    47e0:	a0 91 a6 06 	lds	r26, 0x06A6
    47e4:	b0 91 a7 06 	lds	r27, 0x06A7
    47e8:	e0 91 a6 06 	lds	r30, 0x06A6
    47ec:	f0 91 a7 06 	lds	r31, 0x06A7
    47f0:	86 89       	ldd	r24, Z+22	; 0x16
    47f2:	28 2f       	mov	r18, r24
    47f4:	30 e0       	ldi	r19, 0x00	; 0
    47f6:	84 e0       	ldi	r24, 0x04	; 4
    47f8:	90 e0       	ldi	r25, 0x00	; 0
    47fa:	82 1b       	sub	r24, r18
    47fc:	93 0b       	sbc	r25, r19
    47fe:	1d 96       	adiw	r26, 0x0d	; 13
    4800:	9c 93       	st	X, r25
    4802:	8e 93       	st	-X, r24
    4804:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    4806:	89 81       	ldd	r24, Y+1	; 0x01
    4808:	9a 81       	ldd	r25, Y+2	; 0x02
}
    480a:	0f 90       	pop	r0
    480c:	0f 90       	pop	r0
    480e:	cf 91       	pop	r28
    4810:	df 91       	pop	r29
    4812:	08 95       	ret

00004814 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    4814:	df 93       	push	r29
    4816:	cf 93       	push	r28
    4818:	cd b7       	in	r28, 0x3d	; 61
    481a:	de b7       	in	r29, 0x3e	; 62
    481c:	28 97       	sbiw	r28, 0x08	; 8
    481e:	0f b6       	in	r0, 0x3f	; 63
    4820:	f8 94       	cli
    4822:	de bf       	out	0x3e, r29	; 62
    4824:	0f be       	out	0x3f, r0	; 63
    4826:	cd bf       	out	0x3d, r28	; 61
    4828:	8d 83       	std	Y+5, r24	; 0x05
    482a:	6e 83       	std	Y+6, r22	; 0x06
    482c:	58 87       	std	Y+8, r21	; 0x08
    482e:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    4830:	0f b6       	in	r0, 0x3f	; 63
    4832:	f8 94       	cli
    4834:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    4836:	20 91 a6 06 	lds	r18, 0x06A6
    483a:	30 91 a7 06 	lds	r19, 0x06A7
    483e:	8d 81       	ldd	r24, Y+5	; 0x05
    4840:	88 2f       	mov	r24, r24
    4842:	90 e0       	ldi	r25, 0x00	; 0
    4844:	88 0f       	add	r24, r24
    4846:	99 1f       	adc	r25, r25
    4848:	88 0f       	add	r24, r24
    484a:	99 1f       	adc	r25, r25
    484c:	82 0f       	add	r24, r18
    484e:	93 1f       	adc	r25, r19
    4850:	fc 01       	movw	r30, r24
    4852:	b1 96       	adiw	r30, 0x21	; 33
    4854:	80 81       	ld	r24, Z
    4856:	91 81       	ldd	r25, Z+1	; 0x01
    4858:	a2 81       	ldd	r26, Z+2	; 0x02
    485a:	b3 81       	ldd	r27, Z+3	; 0x03
    485c:	00 97       	sbiw	r24, 0x00	; 0
    485e:	a1 05       	cpc	r26, r1
    4860:	b1 05       	cpc	r27, r1
    4862:	c1 f4       	brne	.+48     	; 0x4894 <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4864:	20 91 a6 06 	lds	r18, 0x06A6
    4868:	30 91 a7 06 	lds	r19, 0x06A7
    486c:	8d 81       	ldd	r24, Y+5	; 0x05
    486e:	88 2f       	mov	r24, r24
    4870:	90 e0       	ldi	r25, 0x00	; 0
    4872:	82 0f       	add	r24, r18
    4874:	93 1f       	adc	r25, r19
    4876:	fc 01       	movw	r30, r24
    4878:	b5 96       	adiw	r30, 0x25	; 37
    487a:	81 e0       	ldi	r24, 0x01	; 1
    487c:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    487e:	8f 81       	ldd	r24, Y+7	; 0x07
    4880:	98 85       	ldd	r25, Y+8	; 0x08
    4882:	00 97       	sbiw	r24, 0x00	; 0
    4884:	39 f0       	breq	.+14     	; 0x4894 <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4886:	8f 81       	ldd	r24, Y+7	; 0x07
    4888:	98 85       	ldd	r25, Y+8	; 0x08
    488a:	61 e0       	ldi	r22, 0x01	; 1
    488c:	0e 94 8f 2b 	call	0x571e	; 0x571e <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    4890:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4894:	0f 90       	pop	r0
    4896:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4898:	0f b6       	in	r0, 0x3f	; 63
    489a:	f8 94       	cli
    489c:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    489e:	20 91 a6 06 	lds	r18, 0x06A6
    48a2:	30 91 a7 06 	lds	r19, 0x06A7
    48a6:	8d 81       	ldd	r24, Y+5	; 0x05
    48a8:	88 2f       	mov	r24, r24
    48aa:	90 e0       	ldi	r25, 0x00	; 0
    48ac:	88 0f       	add	r24, r24
    48ae:	99 1f       	adc	r25, r25
    48b0:	88 0f       	add	r24, r24
    48b2:	99 1f       	adc	r25, r25
    48b4:	82 0f       	add	r24, r18
    48b6:	93 1f       	adc	r25, r19
    48b8:	fc 01       	movw	r30, r24
    48ba:	b1 96       	adiw	r30, 0x21	; 33
    48bc:	80 81       	ld	r24, Z
    48be:	91 81       	ldd	r25, Z+1	; 0x01
    48c0:	a2 81       	ldd	r26, Z+2	; 0x02
    48c2:	b3 81       	ldd	r27, Z+3	; 0x03
    48c4:	89 83       	std	Y+1, r24	; 0x01
    48c6:	9a 83       	std	Y+2, r25	; 0x02
    48c8:	ab 83       	std	Y+3, r26	; 0x03
    48ca:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    48cc:	89 81       	ldd	r24, Y+1	; 0x01
    48ce:	9a 81       	ldd	r25, Y+2	; 0x02
    48d0:	ab 81       	ldd	r26, Y+3	; 0x03
    48d2:	bc 81       	ldd	r27, Y+4	; 0x04
    48d4:	00 97       	sbiw	r24, 0x00	; 0
    48d6:	a1 05       	cpc	r26, r1
    48d8:	b1 05       	cpc	r27, r1
    48da:	a9 f1       	breq	.+106    	; 0x4946 <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    48dc:	8e 81       	ldd	r24, Y+6	; 0x06
    48de:	88 23       	and	r24, r24
    48e0:	a1 f0       	breq	.+40     	; 0x490a <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    48e2:	20 91 a6 06 	lds	r18, 0x06A6
    48e6:	30 91 a7 06 	lds	r19, 0x06A7
    48ea:	8d 81       	ldd	r24, Y+5	; 0x05
    48ec:	88 2f       	mov	r24, r24
    48ee:	90 e0       	ldi	r25, 0x00	; 0
    48f0:	88 0f       	add	r24, r24
    48f2:	99 1f       	adc	r25, r25
    48f4:	88 0f       	add	r24, r24
    48f6:	99 1f       	adc	r25, r25
    48f8:	82 0f       	add	r24, r18
    48fa:	93 1f       	adc	r25, r19
    48fc:	fc 01       	movw	r30, r24
    48fe:	b1 96       	adiw	r30, 0x21	; 33
    4900:	10 82       	st	Z, r1
    4902:	11 82       	std	Z+1, r1	; 0x01
    4904:	12 82       	std	Z+2, r1	; 0x02
    4906:	13 82       	std	Z+3, r1	; 0x03
    4908:	1e c0       	rjmp	.+60     	; 0x4946 <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    490a:	e0 91 a6 06 	lds	r30, 0x06A6
    490e:	f0 91 a7 06 	lds	r31, 0x06A7
    4912:	8d 81       	ldd	r24, Y+5	; 0x05
    4914:	68 2f       	mov	r22, r24
    4916:	70 e0       	ldi	r23, 0x00	; 0
    4918:	89 81       	ldd	r24, Y+1	; 0x01
    491a:	9a 81       	ldd	r25, Y+2	; 0x02
    491c:	ab 81       	ldd	r26, Y+3	; 0x03
    491e:	bc 81       	ldd	r27, Y+4	; 0x04
    4920:	9c 01       	movw	r18, r24
    4922:	ad 01       	movw	r20, r26
    4924:	21 50       	subi	r18, 0x01	; 1
    4926:	30 40       	sbci	r19, 0x00	; 0
    4928:	40 40       	sbci	r20, 0x00	; 0
    492a:	50 40       	sbci	r21, 0x00	; 0
    492c:	cb 01       	movw	r24, r22
    492e:	88 0f       	add	r24, r24
    4930:	99 1f       	adc	r25, r25
    4932:	88 0f       	add	r24, r24
    4934:	99 1f       	adc	r25, r25
    4936:	8e 0f       	add	r24, r30
    4938:	9f 1f       	adc	r25, r31
    493a:	fc 01       	movw	r30, r24
    493c:	b1 96       	adiw	r30, 0x21	; 33
    493e:	20 83       	st	Z, r18
    4940:	31 83       	std	Z+1, r19	; 0x01
    4942:	42 83       	std	Z+2, r20	; 0x02
    4944:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    4946:	20 91 a6 06 	lds	r18, 0x06A6
    494a:	30 91 a7 06 	lds	r19, 0x06A7
    494e:	8d 81       	ldd	r24, Y+5	; 0x05
    4950:	88 2f       	mov	r24, r24
    4952:	90 e0       	ldi	r25, 0x00	; 0
    4954:	82 0f       	add	r24, r18
    4956:	93 1f       	adc	r25, r19
    4958:	fc 01       	movw	r30, r24
    495a:	b5 96       	adiw	r30, 0x25	; 37
    495c:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    495e:	0f 90       	pop	r0
    4960:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    4962:	89 81       	ldd	r24, Y+1	; 0x01
    4964:	9a 81       	ldd	r25, Y+2	; 0x02
    4966:	ab 81       	ldd	r26, Y+3	; 0x03
    4968:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    496a:	bc 01       	movw	r22, r24
    496c:	cd 01       	movw	r24, r26
    496e:	28 96       	adiw	r28, 0x08	; 8
    4970:	0f b6       	in	r0, 0x3f	; 63
    4972:	f8 94       	cli
    4974:	de bf       	out	0x3e, r29	; 62
    4976:	0f be       	out	0x3f, r0	; 63
    4978:	cd bf       	out	0x3d, r28	; 61
    497a:	cf 91       	pop	r28
    497c:	df 91       	pop	r29
    497e:	08 95       	ret

00004980 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    4980:	cf 92       	push	r12
    4982:	df 92       	push	r13
    4984:	ef 92       	push	r14
    4986:	ff 92       	push	r15
    4988:	0f 93       	push	r16
    498a:	1f 93       	push	r17
    498c:	df 93       	push	r29
    498e:	cf 93       	push	r28
    4990:	cd b7       	in	r28, 0x3d	; 61
    4992:	de b7       	in	r29, 0x3e	; 62
    4994:	2e 97       	sbiw	r28, 0x0e	; 14
    4996:	0f b6       	in	r0, 0x3f	; 63
    4998:	f8 94       	cli
    499a:	de bf       	out	0x3e, r29	; 62
    499c:	0f be       	out	0x3f, r0	; 63
    499e:	cd bf       	out	0x3d, r28	; 61
    49a0:	8a 83       	std	Y+2, r24	; 0x02
    49a2:	4b 83       	std	Y+3, r20	; 0x03
    49a4:	5c 83       	std	Y+4, r21	; 0x04
    49a6:	6d 83       	std	Y+5, r22	; 0x05
    49a8:	7e 83       	std	Y+6, r23	; 0x06
    49aa:	0f 83       	std	Y+7, r16	; 0x07
    49ac:	18 87       	std	Y+8, r17	; 0x08
    49ae:	29 87       	std	Y+9, r18	; 0x09
    49b0:	3a 87       	std	Y+10, r19	; 0x0a
    49b2:	fc 86       	std	Y+12, r15	; 0x0c
    49b4:	eb 86       	std	Y+11, r14	; 0x0b
    49b6:	de 86       	std	Y+14, r13	; 0x0e
    49b8:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    49ba:	0f b6       	in	r0, 0x3f	; 63
    49bc:	f8 94       	cli
    49be:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    49c0:	20 91 a6 06 	lds	r18, 0x06A6
    49c4:	30 91 a7 06 	lds	r19, 0x06A7
    49c8:	8a 81       	ldd	r24, Y+2	; 0x02
    49ca:	88 2f       	mov	r24, r24
    49cc:	90 e0       	ldi	r25, 0x00	; 0
    49ce:	82 0f       	add	r24, r18
    49d0:	93 1f       	adc	r25, r19
    49d2:	fc 01       	movw	r30, r24
    49d4:	b5 96       	adiw	r30, 0x25	; 37
    49d6:	80 81       	ld	r24, Z
    49d8:	82 30       	cpi	r24, 0x02	; 2
    49da:	09 f4       	brne	.+2      	; 0x49de <xTaskGenericNotifyWait+0x5e>
    49dc:	47 c0       	rjmp	.+142    	; 0x4a6c <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    49de:	60 91 a6 06 	lds	r22, 0x06A6
    49e2:	70 91 a7 06 	lds	r23, 0x06A7
    49e6:	8a 81       	ldd	r24, Y+2	; 0x02
    49e8:	08 2f       	mov	r16, r24
    49ea:	10 e0       	ldi	r17, 0x00	; 0
    49ec:	8a 81       	ldd	r24, Y+2	; 0x02
    49ee:	88 2f       	mov	r24, r24
    49f0:	90 e0       	ldi	r25, 0x00	; 0
    49f2:	88 0f       	add	r24, r24
    49f4:	99 1f       	adc	r25, r25
    49f6:	88 0f       	add	r24, r24
    49f8:	99 1f       	adc	r25, r25
    49fa:	86 0f       	add	r24, r22
    49fc:	97 1f       	adc	r25, r23
    49fe:	fc 01       	movw	r30, r24
    4a00:	b1 96       	adiw	r30, 0x21	; 33
    4a02:	20 81       	ld	r18, Z
    4a04:	31 81       	ldd	r19, Z+1	; 0x01
    4a06:	42 81       	ldd	r20, Z+2	; 0x02
    4a08:	53 81       	ldd	r21, Z+3	; 0x03
    4a0a:	8b 81       	ldd	r24, Y+3	; 0x03
    4a0c:	9c 81       	ldd	r25, Y+4	; 0x04
    4a0e:	ad 81       	ldd	r26, Y+5	; 0x05
    4a10:	be 81       	ldd	r27, Y+6	; 0x06
    4a12:	80 95       	com	r24
    4a14:	90 95       	com	r25
    4a16:	a0 95       	com	r26
    4a18:	b0 95       	com	r27
    4a1a:	28 23       	and	r18, r24
    4a1c:	39 23       	and	r19, r25
    4a1e:	4a 23       	and	r20, r26
    4a20:	5b 23       	and	r21, r27
    4a22:	c8 01       	movw	r24, r16
    4a24:	88 0f       	add	r24, r24
    4a26:	99 1f       	adc	r25, r25
    4a28:	88 0f       	add	r24, r24
    4a2a:	99 1f       	adc	r25, r25
    4a2c:	86 0f       	add	r24, r22
    4a2e:	97 1f       	adc	r25, r23
    4a30:	fc 01       	movw	r30, r24
    4a32:	b1 96       	adiw	r30, 0x21	; 33
    4a34:	20 83       	st	Z, r18
    4a36:	31 83       	std	Z+1, r19	; 0x01
    4a38:	42 83       	std	Z+2, r20	; 0x02
    4a3a:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4a3c:	20 91 a6 06 	lds	r18, 0x06A6
    4a40:	30 91 a7 06 	lds	r19, 0x06A7
    4a44:	8a 81       	ldd	r24, Y+2	; 0x02
    4a46:	88 2f       	mov	r24, r24
    4a48:	90 e0       	ldi	r25, 0x00	; 0
    4a4a:	82 0f       	add	r24, r18
    4a4c:	93 1f       	adc	r25, r19
    4a4e:	fc 01       	movw	r30, r24
    4a50:	b5 96       	adiw	r30, 0x25	; 37
    4a52:	81 e0       	ldi	r24, 0x01	; 1
    4a54:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    4a56:	8d 85       	ldd	r24, Y+13	; 0x0d
    4a58:	9e 85       	ldd	r25, Y+14	; 0x0e
    4a5a:	00 97       	sbiw	r24, 0x00	; 0
    4a5c:	39 f0       	breq	.+14     	; 0x4a6c <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4a5e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4a60:	9e 85       	ldd	r25, Y+14	; 0x0e
    4a62:	61 e0       	ldi	r22, 0x01	; 1
    4a64:	0e 94 8f 2b 	call	0x571e	; 0x571e <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    4a68:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4a6c:	0f 90       	pop	r0
    4a6e:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4a70:	0f b6       	in	r0, 0x3f	; 63
    4a72:	f8 94       	cli
    4a74:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    4a76:	8b 85       	ldd	r24, Y+11	; 0x0b
    4a78:	9c 85       	ldd	r25, Y+12	; 0x0c
    4a7a:	00 97       	sbiw	r24, 0x00	; 0
    4a7c:	c9 f0       	breq	.+50     	; 0x4ab0 <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    4a7e:	20 91 a6 06 	lds	r18, 0x06A6
    4a82:	30 91 a7 06 	lds	r19, 0x06A7
    4a86:	8a 81       	ldd	r24, Y+2	; 0x02
    4a88:	88 2f       	mov	r24, r24
    4a8a:	90 e0       	ldi	r25, 0x00	; 0
    4a8c:	88 0f       	add	r24, r24
    4a8e:	99 1f       	adc	r25, r25
    4a90:	88 0f       	add	r24, r24
    4a92:	99 1f       	adc	r25, r25
    4a94:	82 0f       	add	r24, r18
    4a96:	93 1f       	adc	r25, r19
    4a98:	fc 01       	movw	r30, r24
    4a9a:	b1 96       	adiw	r30, 0x21	; 33
    4a9c:	80 81       	ld	r24, Z
    4a9e:	91 81       	ldd	r25, Z+1	; 0x01
    4aa0:	a2 81       	ldd	r26, Z+2	; 0x02
    4aa2:	b3 81       	ldd	r27, Z+3	; 0x03
    4aa4:	eb 85       	ldd	r30, Y+11	; 0x0b
    4aa6:	fc 85       	ldd	r31, Y+12	; 0x0c
    4aa8:	80 83       	st	Z, r24
    4aaa:	91 83       	std	Z+1, r25	; 0x01
    4aac:	a2 83       	std	Z+2, r26	; 0x02
    4aae:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    4ab0:	20 91 a6 06 	lds	r18, 0x06A6
    4ab4:	30 91 a7 06 	lds	r19, 0x06A7
    4ab8:	8a 81       	ldd	r24, Y+2	; 0x02
    4aba:	88 2f       	mov	r24, r24
    4abc:	90 e0       	ldi	r25, 0x00	; 0
    4abe:	82 0f       	add	r24, r18
    4ac0:	93 1f       	adc	r25, r19
    4ac2:	fc 01       	movw	r30, r24
    4ac4:	b5 96       	adiw	r30, 0x25	; 37
    4ac6:	80 81       	ld	r24, Z
    4ac8:	82 30       	cpi	r24, 0x02	; 2
    4aca:	11 f0       	breq	.+4      	; 0x4ad0 <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    4acc:	19 82       	std	Y+1, r1	; 0x01
    4ace:	31 c0       	rjmp	.+98     	; 0x4b32 <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    4ad0:	60 91 a6 06 	lds	r22, 0x06A6
    4ad4:	70 91 a7 06 	lds	r23, 0x06A7
    4ad8:	8a 81       	ldd	r24, Y+2	; 0x02
    4ada:	08 2f       	mov	r16, r24
    4adc:	10 e0       	ldi	r17, 0x00	; 0
    4ade:	8a 81       	ldd	r24, Y+2	; 0x02
    4ae0:	88 2f       	mov	r24, r24
    4ae2:	90 e0       	ldi	r25, 0x00	; 0
    4ae4:	88 0f       	add	r24, r24
    4ae6:	99 1f       	adc	r25, r25
    4ae8:	88 0f       	add	r24, r24
    4aea:	99 1f       	adc	r25, r25
    4aec:	86 0f       	add	r24, r22
    4aee:	97 1f       	adc	r25, r23
    4af0:	fc 01       	movw	r30, r24
    4af2:	b1 96       	adiw	r30, 0x21	; 33
    4af4:	20 81       	ld	r18, Z
    4af6:	31 81       	ldd	r19, Z+1	; 0x01
    4af8:	42 81       	ldd	r20, Z+2	; 0x02
    4afa:	53 81       	ldd	r21, Z+3	; 0x03
    4afc:	8f 81       	ldd	r24, Y+7	; 0x07
    4afe:	98 85       	ldd	r25, Y+8	; 0x08
    4b00:	a9 85       	ldd	r26, Y+9	; 0x09
    4b02:	ba 85       	ldd	r27, Y+10	; 0x0a
    4b04:	80 95       	com	r24
    4b06:	90 95       	com	r25
    4b08:	a0 95       	com	r26
    4b0a:	b0 95       	com	r27
    4b0c:	28 23       	and	r18, r24
    4b0e:	39 23       	and	r19, r25
    4b10:	4a 23       	and	r20, r26
    4b12:	5b 23       	and	r21, r27
    4b14:	c8 01       	movw	r24, r16
    4b16:	88 0f       	add	r24, r24
    4b18:	99 1f       	adc	r25, r25
    4b1a:	88 0f       	add	r24, r24
    4b1c:	99 1f       	adc	r25, r25
    4b1e:	86 0f       	add	r24, r22
    4b20:	97 1f       	adc	r25, r23
    4b22:	fc 01       	movw	r30, r24
    4b24:	b1 96       	adiw	r30, 0x21	; 33
    4b26:	20 83       	st	Z, r18
    4b28:	31 83       	std	Z+1, r19	; 0x01
    4b2a:	42 83       	std	Z+2, r20	; 0x02
    4b2c:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    4b2e:	81 e0       	ldi	r24, 0x01	; 1
    4b30:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    4b32:	20 91 a6 06 	lds	r18, 0x06A6
    4b36:	30 91 a7 06 	lds	r19, 0x06A7
    4b3a:	8a 81       	ldd	r24, Y+2	; 0x02
    4b3c:	88 2f       	mov	r24, r24
    4b3e:	90 e0       	ldi	r25, 0x00	; 0
    4b40:	82 0f       	add	r24, r18
    4b42:	93 1f       	adc	r25, r19
    4b44:	fc 01       	movw	r30, r24
    4b46:	b5 96       	adiw	r30, 0x25	; 37
    4b48:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    4b4a:	0f 90       	pop	r0
    4b4c:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    4b4e:	89 81       	ldd	r24, Y+1	; 0x01
    }
    4b50:	2e 96       	adiw	r28, 0x0e	; 14
    4b52:	0f b6       	in	r0, 0x3f	; 63
    4b54:	f8 94       	cli
    4b56:	de bf       	out	0x3e, r29	; 62
    4b58:	0f be       	out	0x3f, r0	; 63
    4b5a:	cd bf       	out	0x3d, r28	; 61
    4b5c:	cf 91       	pop	r28
    4b5e:	df 91       	pop	r29
    4b60:	1f 91       	pop	r17
    4b62:	0f 91       	pop	r16
    4b64:	ff 90       	pop	r15
    4b66:	ef 90       	pop	r14
    4b68:	df 90       	pop	r13
    4b6a:	cf 90       	pop	r12
    4b6c:	08 95       	ret

00004b6e <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    4b6e:	ef 92       	push	r14
    4b70:	ff 92       	push	r15
    4b72:	0f 93       	push	r16
    4b74:	1f 93       	push	r17
    4b76:	df 93       	push	r29
    4b78:	cf 93       	push	r28
    4b7a:	cd b7       	in	r28, 0x3d	; 61
    4b7c:	de b7       	in	r29, 0x3e	; 62
    4b7e:	64 97       	sbiw	r28, 0x14	; 20
    4b80:	0f b6       	in	r0, 0x3f	; 63
    4b82:	f8 94       	cli
    4b84:	de bf       	out	0x3e, r29	; 62
    4b86:	0f be       	out	0x3f, r0	; 63
    4b88:	cd bf       	out	0x3d, r28	; 61
    4b8a:	9a 87       	std	Y+10, r25	; 0x0a
    4b8c:	89 87       	std	Y+9, r24	; 0x09
    4b8e:	6b 87       	std	Y+11, r22	; 0x0b
    4b90:	2c 87       	std	Y+12, r18	; 0x0c
    4b92:	3d 87       	std	Y+13, r19	; 0x0d
    4b94:	4e 87       	std	Y+14, r20	; 0x0e
    4b96:	5f 87       	std	Y+15, r21	; 0x0f
    4b98:	08 8b       	std	Y+16, r16	; 0x10
    4b9a:	fa 8a       	std	Y+18, r15	; 0x12
    4b9c:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    4b9e:	81 e0       	ldi	r24, 0x01	; 1
    4ba0:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    4ba2:	89 85       	ldd	r24, Y+9	; 0x09
    4ba4:	9a 85       	ldd	r25, Y+10	; 0x0a
    4ba6:	98 87       	std	Y+8, r25	; 0x08
    4ba8:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    4baa:	0f b6       	in	r0, 0x3f	; 63
    4bac:	f8 94       	cli
    4bae:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    4bb0:	89 89       	ldd	r24, Y+17	; 0x11
    4bb2:	9a 89       	ldd	r25, Y+18	; 0x12
    4bb4:	00 97       	sbiw	r24, 0x00	; 0
    4bb6:	b9 f0       	breq	.+46     	; 0x4be6 <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    4bb8:	8b 85       	ldd	r24, Y+11	; 0x0b
    4bba:	88 2f       	mov	r24, r24
    4bbc:	90 e0       	ldi	r25, 0x00	; 0
    4bbe:	2f 81       	ldd	r18, Y+7	; 0x07
    4bc0:	38 85       	ldd	r19, Y+8	; 0x08
    4bc2:	88 0f       	add	r24, r24
    4bc4:	99 1f       	adc	r25, r25
    4bc6:	88 0f       	add	r24, r24
    4bc8:	99 1f       	adc	r25, r25
    4bca:	82 0f       	add	r24, r18
    4bcc:	93 1f       	adc	r25, r19
    4bce:	fc 01       	movw	r30, r24
    4bd0:	b1 96       	adiw	r30, 0x21	; 33
    4bd2:	80 81       	ld	r24, Z
    4bd4:	91 81       	ldd	r25, Z+1	; 0x01
    4bd6:	a2 81       	ldd	r26, Z+2	; 0x02
    4bd8:	b3 81       	ldd	r27, Z+3	; 0x03
    4bda:	e9 89       	ldd	r30, Y+17	; 0x11
    4bdc:	fa 89       	ldd	r31, Y+18	; 0x12
    4bde:	80 83       	st	Z, r24
    4be0:	91 83       	std	Z+1, r25	; 0x01
    4be2:	a2 83       	std	Z+2, r26	; 0x02
    4be4:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4be6:	8b 85       	ldd	r24, Y+11	; 0x0b
    4be8:	28 2f       	mov	r18, r24
    4bea:	30 e0       	ldi	r19, 0x00	; 0
    4bec:	8f 81       	ldd	r24, Y+7	; 0x07
    4bee:	98 85       	ldd	r25, Y+8	; 0x08
    4bf0:	82 0f       	add	r24, r18
    4bf2:	93 1f       	adc	r25, r19
    4bf4:	fc 01       	movw	r30, r24
    4bf6:	b5 96       	adiw	r30, 0x25	; 37
    4bf8:	80 81       	ld	r24, Z
    4bfa:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    4bfc:	8b 85       	ldd	r24, Y+11	; 0x0b
    4bfe:	28 2f       	mov	r18, r24
    4c00:	30 e0       	ldi	r19, 0x00	; 0
    4c02:	8f 81       	ldd	r24, Y+7	; 0x07
    4c04:	98 85       	ldd	r25, Y+8	; 0x08
    4c06:	82 0f       	add	r24, r18
    4c08:	93 1f       	adc	r25, r19
    4c0a:	fc 01       	movw	r30, r24
    4c0c:	b5 96       	adiw	r30, 0x25	; 37
    4c0e:	82 e0       	ldi	r24, 0x02	; 2
    4c10:	80 83       	st	Z, r24

            switch( eAction )
    4c12:	88 89       	ldd	r24, Y+16	; 0x10
    4c14:	28 2f       	mov	r18, r24
    4c16:	30 e0       	ldi	r19, 0x00	; 0
    4c18:	3c 8b       	std	Y+20, r19	; 0x14
    4c1a:	2b 8b       	std	Y+19, r18	; 0x13
    4c1c:	8b 89       	ldd	r24, Y+19	; 0x13
    4c1e:	9c 89       	ldd	r25, Y+20	; 0x14
    4c20:	82 30       	cpi	r24, 0x02	; 2
    4c22:	91 05       	cpc	r25, r1
    4c24:	09 f4       	brne	.+2      	; 0x4c28 <xTaskGenericNotify+0xba>
    4c26:	46 c0       	rjmp	.+140    	; 0x4cb4 <xTaskGenericNotify+0x146>
    4c28:	2b 89       	ldd	r18, Y+19	; 0x13
    4c2a:	3c 89       	ldd	r19, Y+20	; 0x14
    4c2c:	23 30       	cpi	r18, 0x03	; 3
    4c2e:	31 05       	cpc	r19, r1
    4c30:	34 f4       	brge	.+12     	; 0x4c3e <xTaskGenericNotify+0xd0>
    4c32:	8b 89       	ldd	r24, Y+19	; 0x13
    4c34:	9c 89       	ldd	r25, Y+20	; 0x14
    4c36:	81 30       	cpi	r24, 0x01	; 1
    4c38:	91 05       	cpc	r25, r1
    4c3a:	71 f0       	breq	.+28     	; 0x4c58 <xTaskGenericNotify+0xea>
    4c3c:	93 c0       	rjmp	.+294    	; 0x4d64 <xTaskGenericNotify+0x1f6>
    4c3e:	2b 89       	ldd	r18, Y+19	; 0x13
    4c40:	3c 89       	ldd	r19, Y+20	; 0x14
    4c42:	23 30       	cpi	r18, 0x03	; 3
    4c44:	31 05       	cpc	r19, r1
    4c46:	09 f4       	brne	.+2      	; 0x4c4a <xTaskGenericNotify+0xdc>
    4c48:	5d c0       	rjmp	.+186    	; 0x4d04 <xTaskGenericNotify+0x196>
    4c4a:	8b 89       	ldd	r24, Y+19	; 0x13
    4c4c:	9c 89       	ldd	r25, Y+20	; 0x14
    4c4e:	84 30       	cpi	r24, 0x04	; 4
    4c50:	91 05       	cpc	r25, r1
    4c52:	09 f4       	brne	.+2      	; 0x4c56 <xTaskGenericNotify+0xe8>
    4c54:	6d c0       	rjmp	.+218    	; 0x4d30 <xTaskGenericNotify+0x1c2>
    4c56:	86 c0       	rjmp	.+268    	; 0x4d64 <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    4c58:	8b 85       	ldd	r24, Y+11	; 0x0b
    4c5a:	08 2f       	mov	r16, r24
    4c5c:	10 e0       	ldi	r17, 0x00	; 0
    4c5e:	8b 85       	ldd	r24, Y+11	; 0x0b
    4c60:	88 2f       	mov	r24, r24
    4c62:	90 e0       	ldi	r25, 0x00	; 0
    4c64:	2f 81       	ldd	r18, Y+7	; 0x07
    4c66:	38 85       	ldd	r19, Y+8	; 0x08
    4c68:	88 0f       	add	r24, r24
    4c6a:	99 1f       	adc	r25, r25
    4c6c:	88 0f       	add	r24, r24
    4c6e:	99 1f       	adc	r25, r25
    4c70:	82 0f       	add	r24, r18
    4c72:	93 1f       	adc	r25, r19
    4c74:	fc 01       	movw	r30, r24
    4c76:	b1 96       	adiw	r30, 0x21	; 33
    4c78:	20 81       	ld	r18, Z
    4c7a:	31 81       	ldd	r19, Z+1	; 0x01
    4c7c:	42 81       	ldd	r20, Z+2	; 0x02
    4c7e:	53 81       	ldd	r21, Z+3	; 0x03
    4c80:	8c 85       	ldd	r24, Y+12	; 0x0c
    4c82:	9d 85       	ldd	r25, Y+13	; 0x0d
    4c84:	ae 85       	ldd	r26, Y+14	; 0x0e
    4c86:	bf 85       	ldd	r27, Y+15	; 0x0f
    4c88:	ba 01       	movw	r22, r20
    4c8a:	a9 01       	movw	r20, r18
    4c8c:	48 2b       	or	r20, r24
    4c8e:	59 2b       	or	r21, r25
    4c90:	6a 2b       	or	r22, r26
    4c92:	7b 2b       	or	r23, r27
    4c94:	2f 81       	ldd	r18, Y+7	; 0x07
    4c96:	38 85       	ldd	r19, Y+8	; 0x08
    4c98:	c8 01       	movw	r24, r16
    4c9a:	88 0f       	add	r24, r24
    4c9c:	99 1f       	adc	r25, r25
    4c9e:	88 0f       	add	r24, r24
    4ca0:	99 1f       	adc	r25, r25
    4ca2:	82 0f       	add	r24, r18
    4ca4:	93 1f       	adc	r25, r19
    4ca6:	fc 01       	movw	r30, r24
    4ca8:	b1 96       	adiw	r30, 0x21	; 33
    4caa:	40 83       	st	Z, r20
    4cac:	51 83       	std	Z+1, r21	; 0x01
    4cae:	62 83       	std	Z+2, r22	; 0x02
    4cb0:	73 83       	std	Z+3, r23	; 0x03
    4cb2:	58 c0       	rjmp	.+176    	; 0x4d64 <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    4cb4:	8b 85       	ldd	r24, Y+11	; 0x0b
    4cb6:	08 2f       	mov	r16, r24
    4cb8:	10 e0       	ldi	r17, 0x00	; 0
    4cba:	2f 81       	ldd	r18, Y+7	; 0x07
    4cbc:	38 85       	ldd	r19, Y+8	; 0x08
    4cbe:	c8 01       	movw	r24, r16
    4cc0:	88 0f       	add	r24, r24
    4cc2:	99 1f       	adc	r25, r25
    4cc4:	88 0f       	add	r24, r24
    4cc6:	99 1f       	adc	r25, r25
    4cc8:	82 0f       	add	r24, r18
    4cca:	93 1f       	adc	r25, r19
    4ccc:	fc 01       	movw	r30, r24
    4cce:	b1 96       	adiw	r30, 0x21	; 33
    4cd0:	80 81       	ld	r24, Z
    4cd2:	91 81       	ldd	r25, Z+1	; 0x01
    4cd4:	a2 81       	ldd	r26, Z+2	; 0x02
    4cd6:	b3 81       	ldd	r27, Z+3	; 0x03
    4cd8:	ac 01       	movw	r20, r24
    4cda:	bd 01       	movw	r22, r26
    4cdc:	4f 5f       	subi	r20, 0xFF	; 255
    4cde:	5f 4f       	sbci	r21, 0xFF	; 255
    4ce0:	6f 4f       	sbci	r22, 0xFF	; 255
    4ce2:	7f 4f       	sbci	r23, 0xFF	; 255
    4ce4:	2f 81       	ldd	r18, Y+7	; 0x07
    4ce6:	38 85       	ldd	r19, Y+8	; 0x08
    4ce8:	c8 01       	movw	r24, r16
    4cea:	88 0f       	add	r24, r24
    4cec:	99 1f       	adc	r25, r25
    4cee:	88 0f       	add	r24, r24
    4cf0:	99 1f       	adc	r25, r25
    4cf2:	82 0f       	add	r24, r18
    4cf4:	93 1f       	adc	r25, r19
    4cf6:	fc 01       	movw	r30, r24
    4cf8:	b1 96       	adiw	r30, 0x21	; 33
    4cfa:	40 83       	st	Z, r20
    4cfc:	51 83       	std	Z+1, r21	; 0x01
    4cfe:	62 83       	std	Z+2, r22	; 0x02
    4d00:	73 83       	std	Z+3, r23	; 0x03
    4d02:	30 c0       	rjmp	.+96     	; 0x4d64 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4d04:	8b 85       	ldd	r24, Y+11	; 0x0b
    4d06:	88 2f       	mov	r24, r24
    4d08:	90 e0       	ldi	r25, 0x00	; 0
    4d0a:	2f 81       	ldd	r18, Y+7	; 0x07
    4d0c:	38 85       	ldd	r19, Y+8	; 0x08
    4d0e:	88 0f       	add	r24, r24
    4d10:	99 1f       	adc	r25, r25
    4d12:	88 0f       	add	r24, r24
    4d14:	99 1f       	adc	r25, r25
    4d16:	82 0f       	add	r24, r18
    4d18:	93 1f       	adc	r25, r19
    4d1a:	fc 01       	movw	r30, r24
    4d1c:	b1 96       	adiw	r30, 0x21	; 33
    4d1e:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d20:	9d 85       	ldd	r25, Y+13	; 0x0d
    4d22:	ae 85       	ldd	r26, Y+14	; 0x0e
    4d24:	bf 85       	ldd	r27, Y+15	; 0x0f
    4d26:	80 83       	st	Z, r24
    4d28:	91 83       	std	Z+1, r25	; 0x01
    4d2a:	a2 83       	std	Z+2, r26	; 0x02
    4d2c:	b3 83       	std	Z+3, r27	; 0x03
    4d2e:	1a c0       	rjmp	.+52     	; 0x4d64 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4d30:	8d 81       	ldd	r24, Y+5	; 0x05
    4d32:	82 30       	cpi	r24, 0x02	; 2
    4d34:	b1 f0       	breq	.+44     	; 0x4d62 <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4d36:	8b 85       	ldd	r24, Y+11	; 0x0b
    4d38:	88 2f       	mov	r24, r24
    4d3a:	90 e0       	ldi	r25, 0x00	; 0
    4d3c:	2f 81       	ldd	r18, Y+7	; 0x07
    4d3e:	38 85       	ldd	r19, Y+8	; 0x08
    4d40:	88 0f       	add	r24, r24
    4d42:	99 1f       	adc	r25, r25
    4d44:	88 0f       	add	r24, r24
    4d46:	99 1f       	adc	r25, r25
    4d48:	82 0f       	add	r24, r18
    4d4a:	93 1f       	adc	r25, r19
    4d4c:	fc 01       	movw	r30, r24
    4d4e:	b1 96       	adiw	r30, 0x21	; 33
    4d50:	8c 85       	ldd	r24, Y+12	; 0x0c
    4d52:	9d 85       	ldd	r25, Y+13	; 0x0d
    4d54:	ae 85       	ldd	r26, Y+14	; 0x0e
    4d56:	bf 85       	ldd	r27, Y+15	; 0x0f
    4d58:	80 83       	st	Z, r24
    4d5a:	91 83       	std	Z+1, r25	; 0x01
    4d5c:	a2 83       	std	Z+2, r26	; 0x02
    4d5e:	b3 83       	std	Z+3, r27	; 0x03
    4d60:	01 c0       	rjmp	.+2      	; 0x4d64 <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    4d62:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4d64:	8d 81       	ldd	r24, Y+5	; 0x05
    4d66:	81 30       	cpi	r24, 0x01	; 1
    4d68:	09 f0       	breq	.+2      	; 0x4d6c <xTaskGenericNotify+0x1fe>
    4d6a:	af c0       	rjmp	.+350    	; 0x4eca <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    4d6c:	ef 81       	ldd	r30, Y+7	; 0x07
    4d6e:	f8 85       	ldd	r31, Y+8	; 0x08
    4d70:	82 85       	ldd	r24, Z+10	; 0x0a
    4d72:	93 85       	ldd	r25, Z+11	; 0x0b
    4d74:	9c 83       	std	Y+4, r25	; 0x04
    4d76:	8b 83       	std	Y+3, r24	; 0x03
    4d78:	ef 81       	ldd	r30, Y+7	; 0x07
    4d7a:	f8 85       	ldd	r31, Y+8	; 0x08
    4d7c:	a4 81       	ldd	r26, Z+4	; 0x04
    4d7e:	b5 81       	ldd	r27, Z+5	; 0x05
    4d80:	ef 81       	ldd	r30, Y+7	; 0x07
    4d82:	f8 85       	ldd	r31, Y+8	; 0x08
    4d84:	86 81       	ldd	r24, Z+6	; 0x06
    4d86:	97 81       	ldd	r25, Z+7	; 0x07
    4d88:	15 96       	adiw	r26, 0x05	; 5
    4d8a:	9c 93       	st	X, r25
    4d8c:	8e 93       	st	-X, r24
    4d8e:	14 97       	sbiw	r26, 0x04	; 4
    4d90:	ef 81       	ldd	r30, Y+7	; 0x07
    4d92:	f8 85       	ldd	r31, Y+8	; 0x08
    4d94:	a6 81       	ldd	r26, Z+6	; 0x06
    4d96:	b7 81       	ldd	r27, Z+7	; 0x07
    4d98:	ef 81       	ldd	r30, Y+7	; 0x07
    4d9a:	f8 85       	ldd	r31, Y+8	; 0x08
    4d9c:	84 81       	ldd	r24, Z+4	; 0x04
    4d9e:	95 81       	ldd	r25, Z+5	; 0x05
    4da0:	13 96       	adiw	r26, 0x03	; 3
    4da2:	9c 93       	st	X, r25
    4da4:	8e 93       	st	-X, r24
    4da6:	12 97       	sbiw	r26, 0x02	; 2
    4da8:	eb 81       	ldd	r30, Y+3	; 0x03
    4daa:	fc 81       	ldd	r31, Y+4	; 0x04
    4dac:	21 81       	ldd	r18, Z+1	; 0x01
    4dae:	32 81       	ldd	r19, Z+2	; 0x02
    4db0:	8f 81       	ldd	r24, Y+7	; 0x07
    4db2:	98 85       	ldd	r25, Y+8	; 0x08
    4db4:	02 96       	adiw	r24, 0x02	; 2
    4db6:	28 17       	cp	r18, r24
    4db8:	39 07       	cpc	r19, r25
    4dba:	41 f4       	brne	.+16     	; 0x4dcc <xTaskGenericNotify+0x25e>
    4dbc:	ef 81       	ldd	r30, Y+7	; 0x07
    4dbe:	f8 85       	ldd	r31, Y+8	; 0x08
    4dc0:	86 81       	ldd	r24, Z+6	; 0x06
    4dc2:	97 81       	ldd	r25, Z+7	; 0x07
    4dc4:	eb 81       	ldd	r30, Y+3	; 0x03
    4dc6:	fc 81       	ldd	r31, Y+4	; 0x04
    4dc8:	92 83       	std	Z+2, r25	; 0x02
    4dca:	81 83       	std	Z+1, r24	; 0x01
    4dcc:	ef 81       	ldd	r30, Y+7	; 0x07
    4dce:	f8 85       	ldd	r31, Y+8	; 0x08
    4dd0:	13 86       	std	Z+11, r1	; 0x0b
    4dd2:	12 86       	std	Z+10, r1	; 0x0a
    4dd4:	eb 81       	ldd	r30, Y+3	; 0x03
    4dd6:	fc 81       	ldd	r31, Y+4	; 0x04
    4dd8:	80 81       	ld	r24, Z
    4dda:	81 50       	subi	r24, 0x01	; 1
    4ddc:	eb 81       	ldd	r30, Y+3	; 0x03
    4dde:	fc 81       	ldd	r31, Y+4	; 0x04
    4de0:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    4de2:	ef 81       	ldd	r30, Y+7	; 0x07
    4de4:	f8 85       	ldd	r31, Y+8	; 0x08
    4de6:	96 89       	ldd	r25, Z+22	; 0x16
    4de8:	80 91 ac 06 	lds	r24, 0x06AC
    4dec:	89 17       	cp	r24, r25
    4dee:	28 f4       	brcc	.+10     	; 0x4dfa <xTaskGenericNotify+0x28c>
    4df0:	ef 81       	ldd	r30, Y+7	; 0x07
    4df2:	f8 85       	ldd	r31, Y+8	; 0x08
    4df4:	86 89       	ldd	r24, Z+22	; 0x16
    4df6:	80 93 ac 06 	sts	0x06AC, r24
    4dfa:	ef 81       	ldd	r30, Y+7	; 0x07
    4dfc:	f8 85       	ldd	r31, Y+8	; 0x08
    4dfe:	86 89       	ldd	r24, Z+22	; 0x16
    4e00:	28 2f       	mov	r18, r24
    4e02:	30 e0       	ldi	r19, 0x00	; 0
    4e04:	c9 01       	movw	r24, r18
    4e06:	88 0f       	add	r24, r24
    4e08:	99 1f       	adc	r25, r25
    4e0a:	88 0f       	add	r24, r24
    4e0c:	99 1f       	adc	r25, r25
    4e0e:	88 0f       	add	r24, r24
    4e10:	99 1f       	adc	r25, r25
    4e12:	82 0f       	add	r24, r18
    4e14:	93 1f       	adc	r25, r19
    4e16:	fc 01       	movw	r30, r24
    4e18:	e8 54       	subi	r30, 0x48	; 72
    4e1a:	f9 4f       	sbci	r31, 0xF9	; 249
    4e1c:	81 81       	ldd	r24, Z+1	; 0x01
    4e1e:	92 81       	ldd	r25, Z+2	; 0x02
    4e20:	9a 83       	std	Y+2, r25	; 0x02
    4e22:	89 83       	std	Y+1, r24	; 0x01
    4e24:	ef 81       	ldd	r30, Y+7	; 0x07
    4e26:	f8 85       	ldd	r31, Y+8	; 0x08
    4e28:	89 81       	ldd	r24, Y+1	; 0x01
    4e2a:	9a 81       	ldd	r25, Y+2	; 0x02
    4e2c:	95 83       	std	Z+5, r25	; 0x05
    4e2e:	84 83       	std	Z+4, r24	; 0x04
    4e30:	e9 81       	ldd	r30, Y+1	; 0x01
    4e32:	fa 81       	ldd	r31, Y+2	; 0x02
    4e34:	84 81       	ldd	r24, Z+4	; 0x04
    4e36:	95 81       	ldd	r25, Z+5	; 0x05
    4e38:	ef 81       	ldd	r30, Y+7	; 0x07
    4e3a:	f8 85       	ldd	r31, Y+8	; 0x08
    4e3c:	97 83       	std	Z+7, r25	; 0x07
    4e3e:	86 83       	std	Z+6, r24	; 0x06
    4e40:	e9 81       	ldd	r30, Y+1	; 0x01
    4e42:	fa 81       	ldd	r31, Y+2	; 0x02
    4e44:	04 80       	ldd	r0, Z+4	; 0x04
    4e46:	f5 81       	ldd	r31, Z+5	; 0x05
    4e48:	e0 2d       	mov	r30, r0
    4e4a:	8f 81       	ldd	r24, Y+7	; 0x07
    4e4c:	98 85       	ldd	r25, Y+8	; 0x08
    4e4e:	02 96       	adiw	r24, 0x02	; 2
    4e50:	93 83       	std	Z+3, r25	; 0x03
    4e52:	82 83       	std	Z+2, r24	; 0x02
    4e54:	8f 81       	ldd	r24, Y+7	; 0x07
    4e56:	98 85       	ldd	r25, Y+8	; 0x08
    4e58:	02 96       	adiw	r24, 0x02	; 2
    4e5a:	e9 81       	ldd	r30, Y+1	; 0x01
    4e5c:	fa 81       	ldd	r31, Y+2	; 0x02
    4e5e:	95 83       	std	Z+5, r25	; 0x05
    4e60:	84 83       	std	Z+4, r24	; 0x04
    4e62:	ef 81       	ldd	r30, Y+7	; 0x07
    4e64:	f8 85       	ldd	r31, Y+8	; 0x08
    4e66:	86 89       	ldd	r24, Z+22	; 0x16
    4e68:	28 2f       	mov	r18, r24
    4e6a:	30 e0       	ldi	r19, 0x00	; 0
    4e6c:	c9 01       	movw	r24, r18
    4e6e:	88 0f       	add	r24, r24
    4e70:	99 1f       	adc	r25, r25
    4e72:	88 0f       	add	r24, r24
    4e74:	99 1f       	adc	r25, r25
    4e76:	88 0f       	add	r24, r24
    4e78:	99 1f       	adc	r25, r25
    4e7a:	82 0f       	add	r24, r18
    4e7c:	93 1f       	adc	r25, r19
    4e7e:	88 54       	subi	r24, 0x48	; 72
    4e80:	99 4f       	sbci	r25, 0xF9	; 249
    4e82:	ef 81       	ldd	r30, Y+7	; 0x07
    4e84:	f8 85       	ldd	r31, Y+8	; 0x08
    4e86:	93 87       	std	Z+11, r25	; 0x0b
    4e88:	82 87       	std	Z+10, r24	; 0x0a
    4e8a:	ef 81       	ldd	r30, Y+7	; 0x07
    4e8c:	f8 85       	ldd	r31, Y+8	; 0x08
    4e8e:	86 89       	ldd	r24, Z+22	; 0x16
    4e90:	28 2f       	mov	r18, r24
    4e92:	30 e0       	ldi	r19, 0x00	; 0
    4e94:	c9 01       	movw	r24, r18
    4e96:	88 0f       	add	r24, r24
    4e98:	99 1f       	adc	r25, r25
    4e9a:	88 0f       	add	r24, r24
    4e9c:	99 1f       	adc	r25, r25
    4e9e:	88 0f       	add	r24, r24
    4ea0:	99 1f       	adc	r25, r25
    4ea2:	82 0f       	add	r24, r18
    4ea4:	93 1f       	adc	r25, r19
    4ea6:	fc 01       	movw	r30, r24
    4ea8:	e8 54       	subi	r30, 0x48	; 72
    4eaa:	f9 4f       	sbci	r31, 0xF9	; 249
    4eac:	80 81       	ld	r24, Z
    4eae:	8f 5f       	subi	r24, 0xFF	; 255
    4eb0:	80 83       	st	Z, r24
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4eb2:	ef 81       	ldd	r30, Y+7	; 0x07
    4eb4:	f8 85       	ldd	r31, Y+8	; 0x08
    4eb6:	96 89       	ldd	r25, Z+22	; 0x16
    4eb8:	e0 91 a6 06 	lds	r30, 0x06A6
    4ebc:	f0 91 a7 06 	lds	r31, 0x06A7
    4ec0:	86 89       	ldd	r24, Z+22	; 0x16
    4ec2:	89 17       	cp	r24, r25
    4ec4:	10 f4       	brcc	.+4      	; 0x4eca <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    4ec6:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4eca:	0f 90       	pop	r0
    4ecc:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    4ece:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    4ed0:	64 96       	adiw	r28, 0x14	; 20
    4ed2:	0f b6       	in	r0, 0x3f	; 63
    4ed4:	f8 94       	cli
    4ed6:	de bf       	out	0x3e, r29	; 62
    4ed8:	0f be       	out	0x3f, r0	; 63
    4eda:	cd bf       	out	0x3d, r28	; 61
    4edc:	cf 91       	pop	r28
    4ede:	df 91       	pop	r29
    4ee0:	1f 91       	pop	r17
    4ee2:	0f 91       	pop	r16
    4ee4:	ff 90       	pop	r15
    4ee6:	ef 90       	pop	r14
    4ee8:	08 95       	ret

00004eea <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    4eea:	cf 92       	push	r12
    4eec:	df 92       	push	r13
    4eee:	ef 92       	push	r14
    4ef0:	ff 92       	push	r15
    4ef2:	0f 93       	push	r16
    4ef4:	1f 93       	push	r17
    4ef6:	df 93       	push	r29
    4ef8:	cf 93       	push	r28
    4efa:	cd b7       	in	r28, 0x3d	; 61
    4efc:	de b7       	in	r29, 0x3e	; 62
    4efe:	69 97       	sbiw	r28, 0x19	; 25
    4f00:	0f b6       	in	r0, 0x3f	; 63
    4f02:	f8 94       	cli
    4f04:	de bf       	out	0x3e, r29	; 62
    4f06:	0f be       	out	0x3f, r0	; 63
    4f08:	cd bf       	out	0x3d, r28	; 61
    4f0a:	9d 87       	std	Y+13, r25	; 0x0d
    4f0c:	8c 87       	std	Y+12, r24	; 0x0c
    4f0e:	6e 87       	std	Y+14, r22	; 0x0e
    4f10:	2f 87       	std	Y+15, r18	; 0x0f
    4f12:	38 8b       	std	Y+16, r19	; 0x10
    4f14:	49 8b       	std	Y+17, r20	; 0x11
    4f16:	5a 8b       	std	Y+18, r21	; 0x12
    4f18:	0b 8b       	std	Y+19, r16	; 0x13
    4f1a:	fd 8a       	std	Y+21, r15	; 0x15
    4f1c:	ec 8a       	std	Y+20, r14	; 0x14
    4f1e:	df 8a       	std	Y+23, r13	; 0x17
    4f20:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    4f22:	81 e0       	ldi	r24, 0x01	; 1
    4f24:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    4f26:	8c 85       	ldd	r24, Y+12	; 0x0c
    4f28:	9d 85       	ldd	r25, Y+13	; 0x0d
    4f2a:	9b 87       	std	Y+11, r25	; 0x0b
    4f2c:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4f2e:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    4f30:	8c 89       	ldd	r24, Y+20	; 0x14
    4f32:	9d 89       	ldd	r25, Y+21	; 0x15
    4f34:	00 97       	sbiw	r24, 0x00	; 0
    4f36:	b9 f0       	breq	.+46     	; 0x4f66 <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    4f38:	8e 85       	ldd	r24, Y+14	; 0x0e
    4f3a:	88 2f       	mov	r24, r24
    4f3c:	90 e0       	ldi	r25, 0x00	; 0
    4f3e:	2a 85       	ldd	r18, Y+10	; 0x0a
    4f40:	3b 85       	ldd	r19, Y+11	; 0x0b
    4f42:	88 0f       	add	r24, r24
    4f44:	99 1f       	adc	r25, r25
    4f46:	88 0f       	add	r24, r24
    4f48:	99 1f       	adc	r25, r25
    4f4a:	82 0f       	add	r24, r18
    4f4c:	93 1f       	adc	r25, r19
    4f4e:	fc 01       	movw	r30, r24
    4f50:	b1 96       	adiw	r30, 0x21	; 33
    4f52:	80 81       	ld	r24, Z
    4f54:	91 81       	ldd	r25, Z+1	; 0x01
    4f56:	a2 81       	ldd	r26, Z+2	; 0x02
    4f58:	b3 81       	ldd	r27, Z+3	; 0x03
    4f5a:	ec 89       	ldd	r30, Y+20	; 0x14
    4f5c:	fd 89       	ldd	r31, Y+21	; 0x15
    4f5e:	80 83       	st	Z, r24
    4f60:	91 83       	std	Z+1, r25	; 0x01
    4f62:	a2 83       	std	Z+2, r26	; 0x02
    4f64:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4f66:	8e 85       	ldd	r24, Y+14	; 0x0e
    4f68:	28 2f       	mov	r18, r24
    4f6a:	30 e0       	ldi	r19, 0x00	; 0
    4f6c:	8a 85       	ldd	r24, Y+10	; 0x0a
    4f6e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4f70:	82 0f       	add	r24, r18
    4f72:	93 1f       	adc	r25, r19
    4f74:	fc 01       	movw	r30, r24
    4f76:	b5 96       	adiw	r30, 0x25	; 37
    4f78:	80 81       	ld	r24, Z
    4f7a:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    4f7c:	8e 85       	ldd	r24, Y+14	; 0x0e
    4f7e:	28 2f       	mov	r18, r24
    4f80:	30 e0       	ldi	r19, 0x00	; 0
    4f82:	8a 85       	ldd	r24, Y+10	; 0x0a
    4f84:	9b 85       	ldd	r25, Y+11	; 0x0b
    4f86:	82 0f       	add	r24, r18
    4f88:	93 1f       	adc	r25, r19
    4f8a:	fc 01       	movw	r30, r24
    4f8c:	b5 96       	adiw	r30, 0x25	; 37
    4f8e:	82 e0       	ldi	r24, 0x02	; 2
    4f90:	80 83       	st	Z, r24

            switch( eAction )
    4f92:	8b 89       	ldd	r24, Y+19	; 0x13
    4f94:	28 2f       	mov	r18, r24
    4f96:	30 e0       	ldi	r19, 0x00	; 0
    4f98:	39 8f       	std	Y+25, r19	; 0x19
    4f9a:	28 8f       	std	Y+24, r18	; 0x18
    4f9c:	88 8d       	ldd	r24, Y+24	; 0x18
    4f9e:	99 8d       	ldd	r25, Y+25	; 0x19
    4fa0:	82 30       	cpi	r24, 0x02	; 2
    4fa2:	91 05       	cpc	r25, r1
    4fa4:	09 f4       	brne	.+2      	; 0x4fa8 <xTaskGenericNotifyFromISR+0xbe>
    4fa6:	46 c0       	rjmp	.+140    	; 0x5034 <xTaskGenericNotifyFromISR+0x14a>
    4fa8:	28 8d       	ldd	r18, Y+24	; 0x18
    4faa:	39 8d       	ldd	r19, Y+25	; 0x19
    4fac:	23 30       	cpi	r18, 0x03	; 3
    4fae:	31 05       	cpc	r19, r1
    4fb0:	34 f4       	brge	.+12     	; 0x4fbe <xTaskGenericNotifyFromISR+0xd4>
    4fb2:	88 8d       	ldd	r24, Y+24	; 0x18
    4fb4:	99 8d       	ldd	r25, Y+25	; 0x19
    4fb6:	81 30       	cpi	r24, 0x01	; 1
    4fb8:	91 05       	cpc	r25, r1
    4fba:	71 f0       	breq	.+28     	; 0x4fd8 <xTaskGenericNotifyFromISR+0xee>
    4fbc:	93 c0       	rjmp	.+294    	; 0x50e4 <xTaskGenericNotifyFromISR+0x1fa>
    4fbe:	28 8d       	ldd	r18, Y+24	; 0x18
    4fc0:	39 8d       	ldd	r19, Y+25	; 0x19
    4fc2:	23 30       	cpi	r18, 0x03	; 3
    4fc4:	31 05       	cpc	r19, r1
    4fc6:	09 f4       	brne	.+2      	; 0x4fca <xTaskGenericNotifyFromISR+0xe0>
    4fc8:	5d c0       	rjmp	.+186    	; 0x5084 <xTaskGenericNotifyFromISR+0x19a>
    4fca:	88 8d       	ldd	r24, Y+24	; 0x18
    4fcc:	99 8d       	ldd	r25, Y+25	; 0x19
    4fce:	84 30       	cpi	r24, 0x04	; 4
    4fd0:	91 05       	cpc	r25, r1
    4fd2:	09 f4       	brne	.+2      	; 0x4fd6 <xTaskGenericNotifyFromISR+0xec>
    4fd4:	6d c0       	rjmp	.+218    	; 0x50b0 <xTaskGenericNotifyFromISR+0x1c6>
    4fd6:	86 c0       	rjmp	.+268    	; 0x50e4 <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    4fd8:	8e 85       	ldd	r24, Y+14	; 0x0e
    4fda:	08 2f       	mov	r16, r24
    4fdc:	10 e0       	ldi	r17, 0x00	; 0
    4fde:	8e 85       	ldd	r24, Y+14	; 0x0e
    4fe0:	88 2f       	mov	r24, r24
    4fe2:	90 e0       	ldi	r25, 0x00	; 0
    4fe4:	2a 85       	ldd	r18, Y+10	; 0x0a
    4fe6:	3b 85       	ldd	r19, Y+11	; 0x0b
    4fe8:	88 0f       	add	r24, r24
    4fea:	99 1f       	adc	r25, r25
    4fec:	88 0f       	add	r24, r24
    4fee:	99 1f       	adc	r25, r25
    4ff0:	82 0f       	add	r24, r18
    4ff2:	93 1f       	adc	r25, r19
    4ff4:	fc 01       	movw	r30, r24
    4ff6:	b1 96       	adiw	r30, 0x21	; 33
    4ff8:	20 81       	ld	r18, Z
    4ffa:	31 81       	ldd	r19, Z+1	; 0x01
    4ffc:	42 81       	ldd	r20, Z+2	; 0x02
    4ffe:	53 81       	ldd	r21, Z+3	; 0x03
    5000:	8f 85       	ldd	r24, Y+15	; 0x0f
    5002:	98 89       	ldd	r25, Y+16	; 0x10
    5004:	a9 89       	ldd	r26, Y+17	; 0x11
    5006:	ba 89       	ldd	r27, Y+18	; 0x12
    5008:	ba 01       	movw	r22, r20
    500a:	a9 01       	movw	r20, r18
    500c:	48 2b       	or	r20, r24
    500e:	59 2b       	or	r21, r25
    5010:	6a 2b       	or	r22, r26
    5012:	7b 2b       	or	r23, r27
    5014:	2a 85       	ldd	r18, Y+10	; 0x0a
    5016:	3b 85       	ldd	r19, Y+11	; 0x0b
    5018:	c8 01       	movw	r24, r16
    501a:	88 0f       	add	r24, r24
    501c:	99 1f       	adc	r25, r25
    501e:	88 0f       	add	r24, r24
    5020:	99 1f       	adc	r25, r25
    5022:	82 0f       	add	r24, r18
    5024:	93 1f       	adc	r25, r19
    5026:	fc 01       	movw	r30, r24
    5028:	b1 96       	adiw	r30, 0x21	; 33
    502a:	40 83       	st	Z, r20
    502c:	51 83       	std	Z+1, r21	; 0x01
    502e:	62 83       	std	Z+2, r22	; 0x02
    5030:	73 83       	std	Z+3, r23	; 0x03
    5032:	58 c0       	rjmp	.+176    	; 0x50e4 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    5034:	8e 85       	ldd	r24, Y+14	; 0x0e
    5036:	08 2f       	mov	r16, r24
    5038:	10 e0       	ldi	r17, 0x00	; 0
    503a:	2a 85       	ldd	r18, Y+10	; 0x0a
    503c:	3b 85       	ldd	r19, Y+11	; 0x0b
    503e:	c8 01       	movw	r24, r16
    5040:	88 0f       	add	r24, r24
    5042:	99 1f       	adc	r25, r25
    5044:	88 0f       	add	r24, r24
    5046:	99 1f       	adc	r25, r25
    5048:	82 0f       	add	r24, r18
    504a:	93 1f       	adc	r25, r19
    504c:	fc 01       	movw	r30, r24
    504e:	b1 96       	adiw	r30, 0x21	; 33
    5050:	80 81       	ld	r24, Z
    5052:	91 81       	ldd	r25, Z+1	; 0x01
    5054:	a2 81       	ldd	r26, Z+2	; 0x02
    5056:	b3 81       	ldd	r27, Z+3	; 0x03
    5058:	ac 01       	movw	r20, r24
    505a:	bd 01       	movw	r22, r26
    505c:	4f 5f       	subi	r20, 0xFF	; 255
    505e:	5f 4f       	sbci	r21, 0xFF	; 255
    5060:	6f 4f       	sbci	r22, 0xFF	; 255
    5062:	7f 4f       	sbci	r23, 0xFF	; 255
    5064:	2a 85       	ldd	r18, Y+10	; 0x0a
    5066:	3b 85       	ldd	r19, Y+11	; 0x0b
    5068:	c8 01       	movw	r24, r16
    506a:	88 0f       	add	r24, r24
    506c:	99 1f       	adc	r25, r25
    506e:	88 0f       	add	r24, r24
    5070:	99 1f       	adc	r25, r25
    5072:	82 0f       	add	r24, r18
    5074:	93 1f       	adc	r25, r19
    5076:	fc 01       	movw	r30, r24
    5078:	b1 96       	adiw	r30, 0x21	; 33
    507a:	40 83       	st	Z, r20
    507c:	51 83       	std	Z+1, r21	; 0x01
    507e:	62 83       	std	Z+2, r22	; 0x02
    5080:	73 83       	std	Z+3, r23	; 0x03
    5082:	30 c0       	rjmp	.+96     	; 0x50e4 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5084:	8e 85       	ldd	r24, Y+14	; 0x0e
    5086:	88 2f       	mov	r24, r24
    5088:	90 e0       	ldi	r25, 0x00	; 0
    508a:	2a 85       	ldd	r18, Y+10	; 0x0a
    508c:	3b 85       	ldd	r19, Y+11	; 0x0b
    508e:	88 0f       	add	r24, r24
    5090:	99 1f       	adc	r25, r25
    5092:	88 0f       	add	r24, r24
    5094:	99 1f       	adc	r25, r25
    5096:	82 0f       	add	r24, r18
    5098:	93 1f       	adc	r25, r19
    509a:	fc 01       	movw	r30, r24
    509c:	b1 96       	adiw	r30, 0x21	; 33
    509e:	8f 85       	ldd	r24, Y+15	; 0x0f
    50a0:	98 89       	ldd	r25, Y+16	; 0x10
    50a2:	a9 89       	ldd	r26, Y+17	; 0x11
    50a4:	ba 89       	ldd	r27, Y+18	; 0x12
    50a6:	80 83       	st	Z, r24
    50a8:	91 83       	std	Z+1, r25	; 0x01
    50aa:	a2 83       	std	Z+2, r26	; 0x02
    50ac:	b3 83       	std	Z+3, r27	; 0x03
    50ae:	1a c0       	rjmp	.+52     	; 0x50e4 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    50b0:	89 85       	ldd	r24, Y+9	; 0x09
    50b2:	82 30       	cpi	r24, 0x02	; 2
    50b4:	b1 f0       	breq	.+44     	; 0x50e2 <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    50b6:	8e 85       	ldd	r24, Y+14	; 0x0e
    50b8:	88 2f       	mov	r24, r24
    50ba:	90 e0       	ldi	r25, 0x00	; 0
    50bc:	2a 85       	ldd	r18, Y+10	; 0x0a
    50be:	3b 85       	ldd	r19, Y+11	; 0x0b
    50c0:	88 0f       	add	r24, r24
    50c2:	99 1f       	adc	r25, r25
    50c4:	88 0f       	add	r24, r24
    50c6:	99 1f       	adc	r25, r25
    50c8:	82 0f       	add	r24, r18
    50ca:	93 1f       	adc	r25, r19
    50cc:	fc 01       	movw	r30, r24
    50ce:	b1 96       	adiw	r30, 0x21	; 33
    50d0:	8f 85       	ldd	r24, Y+15	; 0x0f
    50d2:	98 89       	ldd	r25, Y+16	; 0x10
    50d4:	a9 89       	ldd	r26, Y+17	; 0x11
    50d6:	ba 89       	ldd	r27, Y+18	; 0x12
    50d8:	80 83       	st	Z, r24
    50da:	91 83       	std	Z+1, r25	; 0x01
    50dc:	a2 83       	std	Z+2, r26	; 0x02
    50de:	b3 83       	std	Z+3, r27	; 0x03
    50e0:	01 c0       	rjmp	.+2      	; 0x50e4 <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    50e2:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    50e4:	89 85       	ldd	r24, Y+9	; 0x09
    50e6:	81 30       	cpi	r24, 0x01	; 1
    50e8:	09 f0       	breq	.+2      	; 0x50ec <xTaskGenericNotifyFromISR+0x202>
    50ea:	ee c0       	rjmp	.+476    	; 0x52c8 <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    50ec:	80 91 b7 06 	lds	r24, 0x06B7
    50f0:	88 23       	and	r24, r24
    50f2:	09 f0       	breq	.+2      	; 0x50f6 <xTaskGenericNotifyFromISR+0x20c>
    50f4:	a4 c0       	rjmp	.+328    	; 0x523e <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    50f6:	ea 85       	ldd	r30, Y+10	; 0x0a
    50f8:	fb 85       	ldd	r31, Y+11	; 0x0b
    50fa:	82 85       	ldd	r24, Z+10	; 0x0a
    50fc:	93 85       	ldd	r25, Z+11	; 0x0b
    50fe:	9e 83       	std	Y+6, r25	; 0x06
    5100:	8d 83       	std	Y+5, r24	; 0x05
    5102:	ea 85       	ldd	r30, Y+10	; 0x0a
    5104:	fb 85       	ldd	r31, Y+11	; 0x0b
    5106:	a4 81       	ldd	r26, Z+4	; 0x04
    5108:	b5 81       	ldd	r27, Z+5	; 0x05
    510a:	ea 85       	ldd	r30, Y+10	; 0x0a
    510c:	fb 85       	ldd	r31, Y+11	; 0x0b
    510e:	86 81       	ldd	r24, Z+6	; 0x06
    5110:	97 81       	ldd	r25, Z+7	; 0x07
    5112:	15 96       	adiw	r26, 0x05	; 5
    5114:	9c 93       	st	X, r25
    5116:	8e 93       	st	-X, r24
    5118:	14 97       	sbiw	r26, 0x04	; 4
    511a:	ea 85       	ldd	r30, Y+10	; 0x0a
    511c:	fb 85       	ldd	r31, Y+11	; 0x0b
    511e:	a6 81       	ldd	r26, Z+6	; 0x06
    5120:	b7 81       	ldd	r27, Z+7	; 0x07
    5122:	ea 85       	ldd	r30, Y+10	; 0x0a
    5124:	fb 85       	ldd	r31, Y+11	; 0x0b
    5126:	84 81       	ldd	r24, Z+4	; 0x04
    5128:	95 81       	ldd	r25, Z+5	; 0x05
    512a:	13 96       	adiw	r26, 0x03	; 3
    512c:	9c 93       	st	X, r25
    512e:	8e 93       	st	-X, r24
    5130:	12 97       	sbiw	r26, 0x02	; 2
    5132:	ed 81       	ldd	r30, Y+5	; 0x05
    5134:	fe 81       	ldd	r31, Y+6	; 0x06
    5136:	21 81       	ldd	r18, Z+1	; 0x01
    5138:	32 81       	ldd	r19, Z+2	; 0x02
    513a:	8a 85       	ldd	r24, Y+10	; 0x0a
    513c:	9b 85       	ldd	r25, Y+11	; 0x0b
    513e:	02 96       	adiw	r24, 0x02	; 2
    5140:	28 17       	cp	r18, r24
    5142:	39 07       	cpc	r19, r25
    5144:	41 f4       	brne	.+16     	; 0x5156 <xTaskGenericNotifyFromISR+0x26c>
    5146:	ea 85       	ldd	r30, Y+10	; 0x0a
    5148:	fb 85       	ldd	r31, Y+11	; 0x0b
    514a:	86 81       	ldd	r24, Z+6	; 0x06
    514c:	97 81       	ldd	r25, Z+7	; 0x07
    514e:	ed 81       	ldd	r30, Y+5	; 0x05
    5150:	fe 81       	ldd	r31, Y+6	; 0x06
    5152:	92 83       	std	Z+2, r25	; 0x02
    5154:	81 83       	std	Z+1, r24	; 0x01
    5156:	ea 85       	ldd	r30, Y+10	; 0x0a
    5158:	fb 85       	ldd	r31, Y+11	; 0x0b
    515a:	13 86       	std	Z+11, r1	; 0x0b
    515c:	12 86       	std	Z+10, r1	; 0x0a
    515e:	ed 81       	ldd	r30, Y+5	; 0x05
    5160:	fe 81       	ldd	r31, Y+6	; 0x06
    5162:	80 81       	ld	r24, Z
    5164:	81 50       	subi	r24, 0x01	; 1
    5166:	ed 81       	ldd	r30, Y+5	; 0x05
    5168:	fe 81       	ldd	r31, Y+6	; 0x06
    516a:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    516c:	ea 85       	ldd	r30, Y+10	; 0x0a
    516e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5170:	96 89       	ldd	r25, Z+22	; 0x16
    5172:	80 91 ac 06 	lds	r24, 0x06AC
    5176:	89 17       	cp	r24, r25
    5178:	28 f4       	brcc	.+10     	; 0x5184 <xTaskGenericNotifyFromISR+0x29a>
    517a:	ea 85       	ldd	r30, Y+10	; 0x0a
    517c:	fb 85       	ldd	r31, Y+11	; 0x0b
    517e:	86 89       	ldd	r24, Z+22	; 0x16
    5180:	80 93 ac 06 	sts	0x06AC, r24
    5184:	ea 85       	ldd	r30, Y+10	; 0x0a
    5186:	fb 85       	ldd	r31, Y+11	; 0x0b
    5188:	86 89       	ldd	r24, Z+22	; 0x16
    518a:	28 2f       	mov	r18, r24
    518c:	30 e0       	ldi	r19, 0x00	; 0
    518e:	c9 01       	movw	r24, r18
    5190:	88 0f       	add	r24, r24
    5192:	99 1f       	adc	r25, r25
    5194:	88 0f       	add	r24, r24
    5196:	99 1f       	adc	r25, r25
    5198:	88 0f       	add	r24, r24
    519a:	99 1f       	adc	r25, r25
    519c:	82 0f       	add	r24, r18
    519e:	93 1f       	adc	r25, r19
    51a0:	fc 01       	movw	r30, r24
    51a2:	e8 54       	subi	r30, 0x48	; 72
    51a4:	f9 4f       	sbci	r31, 0xF9	; 249
    51a6:	81 81       	ldd	r24, Z+1	; 0x01
    51a8:	92 81       	ldd	r25, Z+2	; 0x02
    51aa:	9c 83       	std	Y+4, r25	; 0x04
    51ac:	8b 83       	std	Y+3, r24	; 0x03
    51ae:	ea 85       	ldd	r30, Y+10	; 0x0a
    51b0:	fb 85       	ldd	r31, Y+11	; 0x0b
    51b2:	8b 81       	ldd	r24, Y+3	; 0x03
    51b4:	9c 81       	ldd	r25, Y+4	; 0x04
    51b6:	95 83       	std	Z+5, r25	; 0x05
    51b8:	84 83       	std	Z+4, r24	; 0x04
    51ba:	eb 81       	ldd	r30, Y+3	; 0x03
    51bc:	fc 81       	ldd	r31, Y+4	; 0x04
    51be:	84 81       	ldd	r24, Z+4	; 0x04
    51c0:	95 81       	ldd	r25, Z+5	; 0x05
    51c2:	ea 85       	ldd	r30, Y+10	; 0x0a
    51c4:	fb 85       	ldd	r31, Y+11	; 0x0b
    51c6:	97 83       	std	Z+7, r25	; 0x07
    51c8:	86 83       	std	Z+6, r24	; 0x06
    51ca:	eb 81       	ldd	r30, Y+3	; 0x03
    51cc:	fc 81       	ldd	r31, Y+4	; 0x04
    51ce:	04 80       	ldd	r0, Z+4	; 0x04
    51d0:	f5 81       	ldd	r31, Z+5	; 0x05
    51d2:	e0 2d       	mov	r30, r0
    51d4:	8a 85       	ldd	r24, Y+10	; 0x0a
    51d6:	9b 85       	ldd	r25, Y+11	; 0x0b
    51d8:	02 96       	adiw	r24, 0x02	; 2
    51da:	93 83       	std	Z+3, r25	; 0x03
    51dc:	82 83       	std	Z+2, r24	; 0x02
    51de:	8a 85       	ldd	r24, Y+10	; 0x0a
    51e0:	9b 85       	ldd	r25, Y+11	; 0x0b
    51e2:	02 96       	adiw	r24, 0x02	; 2
    51e4:	eb 81       	ldd	r30, Y+3	; 0x03
    51e6:	fc 81       	ldd	r31, Y+4	; 0x04
    51e8:	95 83       	std	Z+5, r25	; 0x05
    51ea:	84 83       	std	Z+4, r24	; 0x04
    51ec:	ea 85       	ldd	r30, Y+10	; 0x0a
    51ee:	fb 85       	ldd	r31, Y+11	; 0x0b
    51f0:	86 89       	ldd	r24, Z+22	; 0x16
    51f2:	28 2f       	mov	r18, r24
    51f4:	30 e0       	ldi	r19, 0x00	; 0
    51f6:	c9 01       	movw	r24, r18
    51f8:	88 0f       	add	r24, r24
    51fa:	99 1f       	adc	r25, r25
    51fc:	88 0f       	add	r24, r24
    51fe:	99 1f       	adc	r25, r25
    5200:	88 0f       	add	r24, r24
    5202:	99 1f       	adc	r25, r25
    5204:	82 0f       	add	r24, r18
    5206:	93 1f       	adc	r25, r19
    5208:	88 54       	subi	r24, 0x48	; 72
    520a:	99 4f       	sbci	r25, 0xF9	; 249
    520c:	ea 85       	ldd	r30, Y+10	; 0x0a
    520e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5210:	93 87       	std	Z+11, r25	; 0x0b
    5212:	82 87       	std	Z+10, r24	; 0x0a
    5214:	ea 85       	ldd	r30, Y+10	; 0x0a
    5216:	fb 85       	ldd	r31, Y+11	; 0x0b
    5218:	86 89       	ldd	r24, Z+22	; 0x16
    521a:	28 2f       	mov	r18, r24
    521c:	30 e0       	ldi	r19, 0x00	; 0
    521e:	c9 01       	movw	r24, r18
    5220:	88 0f       	add	r24, r24
    5222:	99 1f       	adc	r25, r25
    5224:	88 0f       	add	r24, r24
    5226:	99 1f       	adc	r25, r25
    5228:	88 0f       	add	r24, r24
    522a:	99 1f       	adc	r25, r25
    522c:	82 0f       	add	r24, r18
    522e:	93 1f       	adc	r25, r19
    5230:	fc 01       	movw	r30, r24
    5232:	e8 54       	subi	r30, 0x48	; 72
    5234:	f9 4f       	sbci	r31, 0xF9	; 249
    5236:	80 81       	ld	r24, Z
    5238:	8f 5f       	subi	r24, 0xFF	; 255
    523a:	80 83       	st	Z, r24
    523c:	30 c0       	rjmp	.+96     	; 0x529e <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    523e:	80 91 f3 06 	lds	r24, 0x06F3
    5242:	90 91 f4 06 	lds	r25, 0x06F4
    5246:	9a 83       	std	Y+2, r25	; 0x02
    5248:	89 83       	std	Y+1, r24	; 0x01
    524a:	ea 85       	ldd	r30, Y+10	; 0x0a
    524c:	fb 85       	ldd	r31, Y+11	; 0x0b
    524e:	89 81       	ldd	r24, Y+1	; 0x01
    5250:	9a 81       	ldd	r25, Y+2	; 0x02
    5252:	97 87       	std	Z+15, r25	; 0x0f
    5254:	86 87       	std	Z+14, r24	; 0x0e
    5256:	e9 81       	ldd	r30, Y+1	; 0x01
    5258:	fa 81       	ldd	r31, Y+2	; 0x02
    525a:	84 81       	ldd	r24, Z+4	; 0x04
    525c:	95 81       	ldd	r25, Z+5	; 0x05
    525e:	ea 85       	ldd	r30, Y+10	; 0x0a
    5260:	fb 85       	ldd	r31, Y+11	; 0x0b
    5262:	91 8b       	std	Z+17, r25	; 0x11
    5264:	80 8b       	std	Z+16, r24	; 0x10
    5266:	e9 81       	ldd	r30, Y+1	; 0x01
    5268:	fa 81       	ldd	r31, Y+2	; 0x02
    526a:	04 80       	ldd	r0, Z+4	; 0x04
    526c:	f5 81       	ldd	r31, Z+5	; 0x05
    526e:	e0 2d       	mov	r30, r0
    5270:	8a 85       	ldd	r24, Y+10	; 0x0a
    5272:	9b 85       	ldd	r25, Y+11	; 0x0b
    5274:	0c 96       	adiw	r24, 0x0c	; 12
    5276:	93 83       	std	Z+3, r25	; 0x03
    5278:	82 83       	std	Z+2, r24	; 0x02
    527a:	8a 85       	ldd	r24, Y+10	; 0x0a
    527c:	9b 85       	ldd	r25, Y+11	; 0x0b
    527e:	0c 96       	adiw	r24, 0x0c	; 12
    5280:	e9 81       	ldd	r30, Y+1	; 0x01
    5282:	fa 81       	ldd	r31, Y+2	; 0x02
    5284:	95 83       	std	Z+5, r25	; 0x05
    5286:	84 83       	std	Z+4, r24	; 0x04
    5288:	ea 85       	ldd	r30, Y+10	; 0x0a
    528a:	fb 85       	ldd	r31, Y+11	; 0x0b
    528c:	82 ef       	ldi	r24, 0xF2	; 242
    528e:	96 e0       	ldi	r25, 0x06	; 6
    5290:	95 8b       	std	Z+21, r25	; 0x15
    5292:	84 8b       	std	Z+20, r24	; 0x14
    5294:	80 91 f2 06 	lds	r24, 0x06F2
    5298:	8f 5f       	subi	r24, 0xFF	; 255
    529a:	80 93 f2 06 	sts	0x06F2, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    529e:	ea 85       	ldd	r30, Y+10	; 0x0a
    52a0:	fb 85       	ldd	r31, Y+11	; 0x0b
    52a2:	96 89       	ldd	r25, Z+22	; 0x16
    52a4:	e0 91 a6 06 	lds	r30, 0x06A6
    52a8:	f0 91 a7 06 	lds	r31, 0x06A7
    52ac:	86 89       	ldd	r24, Z+22	; 0x16
    52ae:	89 17       	cp	r24, r25
    52b0:	58 f4       	brcc	.+22     	; 0x52c8 <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    52b2:	8e 89       	ldd	r24, Y+22	; 0x16
    52b4:	9f 89       	ldd	r25, Y+23	; 0x17
    52b6:	00 97       	sbiw	r24, 0x00	; 0
    52b8:	21 f0       	breq	.+8      	; 0x52c2 <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    52ba:	ee 89       	ldd	r30, Y+22	; 0x16
    52bc:	ff 89       	ldd	r31, Y+23	; 0x17
    52be:	81 e0       	ldi	r24, 0x01	; 1
    52c0:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    52c2:	81 e0       	ldi	r24, 0x01	; 1
    52c4:	80 93 b0 06 	sts	0x06B0, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    52c8:	88 85       	ldd	r24, Y+8	; 0x08
    }
    52ca:	69 96       	adiw	r28, 0x19	; 25
    52cc:	0f b6       	in	r0, 0x3f	; 63
    52ce:	f8 94       	cli
    52d0:	de bf       	out	0x3e, r29	; 62
    52d2:	0f be       	out	0x3f, r0	; 63
    52d4:	cd bf       	out	0x3d, r28	; 61
    52d6:	cf 91       	pop	r28
    52d8:	df 91       	pop	r29
    52da:	1f 91       	pop	r17
    52dc:	0f 91       	pop	r16
    52de:	ff 90       	pop	r15
    52e0:	ef 90       	pop	r14
    52e2:	df 90       	pop	r13
    52e4:	cf 90       	pop	r12
    52e6:	08 95       	ret

000052e8 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    52e8:	0f 93       	push	r16
    52ea:	1f 93       	push	r17
    52ec:	df 93       	push	r29
    52ee:	cf 93       	push	r28
    52f0:	cd b7       	in	r28, 0x3d	; 61
    52f2:	de b7       	in	r29, 0x3e	; 62
    52f4:	2f 97       	sbiw	r28, 0x0f	; 15
    52f6:	0f b6       	in	r0, 0x3f	; 63
    52f8:	f8 94       	cli
    52fa:	de bf       	out	0x3e, r29	; 62
    52fc:	0f be       	out	0x3f, r0	; 63
    52fe:	cd bf       	out	0x3d, r28	; 61
    5300:	9c 87       	std	Y+12, r25	; 0x0c
    5302:	8b 87       	std	Y+11, r24	; 0x0b
    5304:	6d 87       	std	Y+13, r22	; 0x0d
    5306:	5f 87       	std	Y+15, r21	; 0x0f
    5308:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    530a:	8b 85       	ldd	r24, Y+11	; 0x0b
    530c:	9c 85       	ldd	r25, Y+12	; 0x0c
    530e:	9a 87       	std	Y+10, r25	; 0x0a
    5310:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5312:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5314:	8d 85       	ldd	r24, Y+13	; 0x0d
    5316:	28 2f       	mov	r18, r24
    5318:	30 e0       	ldi	r19, 0x00	; 0
    531a:	89 85       	ldd	r24, Y+9	; 0x09
    531c:	9a 85       	ldd	r25, Y+10	; 0x0a
    531e:	82 0f       	add	r24, r18
    5320:	93 1f       	adc	r25, r19
    5322:	fc 01       	movw	r30, r24
    5324:	b5 96       	adiw	r30, 0x25	; 37
    5326:	80 81       	ld	r24, Z
    5328:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    532a:	8d 85       	ldd	r24, Y+13	; 0x0d
    532c:	28 2f       	mov	r18, r24
    532e:	30 e0       	ldi	r19, 0x00	; 0
    5330:	89 85       	ldd	r24, Y+9	; 0x09
    5332:	9a 85       	ldd	r25, Y+10	; 0x0a
    5334:	82 0f       	add	r24, r18
    5336:	93 1f       	adc	r25, r19
    5338:	fc 01       	movw	r30, r24
    533a:	b5 96       	adiw	r30, 0x25	; 37
    533c:	82 e0       	ldi	r24, 0x02	; 2
    533e:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    5340:	8d 85       	ldd	r24, Y+13	; 0x0d
    5342:	08 2f       	mov	r16, r24
    5344:	10 e0       	ldi	r17, 0x00	; 0
    5346:	29 85       	ldd	r18, Y+9	; 0x09
    5348:	3a 85       	ldd	r19, Y+10	; 0x0a
    534a:	c8 01       	movw	r24, r16
    534c:	88 0f       	add	r24, r24
    534e:	99 1f       	adc	r25, r25
    5350:	88 0f       	add	r24, r24
    5352:	99 1f       	adc	r25, r25
    5354:	82 0f       	add	r24, r18
    5356:	93 1f       	adc	r25, r19
    5358:	fc 01       	movw	r30, r24
    535a:	b1 96       	adiw	r30, 0x21	; 33
    535c:	80 81       	ld	r24, Z
    535e:	91 81       	ldd	r25, Z+1	; 0x01
    5360:	a2 81       	ldd	r26, Z+2	; 0x02
    5362:	b3 81       	ldd	r27, Z+3	; 0x03
    5364:	ac 01       	movw	r20, r24
    5366:	bd 01       	movw	r22, r26
    5368:	4f 5f       	subi	r20, 0xFF	; 255
    536a:	5f 4f       	sbci	r21, 0xFF	; 255
    536c:	6f 4f       	sbci	r22, 0xFF	; 255
    536e:	7f 4f       	sbci	r23, 0xFF	; 255
    5370:	29 85       	ldd	r18, Y+9	; 0x09
    5372:	3a 85       	ldd	r19, Y+10	; 0x0a
    5374:	c8 01       	movw	r24, r16
    5376:	88 0f       	add	r24, r24
    5378:	99 1f       	adc	r25, r25
    537a:	88 0f       	add	r24, r24
    537c:	99 1f       	adc	r25, r25
    537e:	82 0f       	add	r24, r18
    5380:	93 1f       	adc	r25, r19
    5382:	fc 01       	movw	r30, r24
    5384:	b1 96       	adiw	r30, 0x21	; 33
    5386:	40 83       	st	Z, r20
    5388:	51 83       	std	Z+1, r21	; 0x01
    538a:	62 83       	std	Z+2, r22	; 0x02
    538c:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    538e:	88 85       	ldd	r24, Y+8	; 0x08
    5390:	81 30       	cpi	r24, 0x01	; 1
    5392:	09 f0       	breq	.+2      	; 0x5396 <vTaskGenericNotifyGiveFromISR+0xae>
    5394:	ee c0       	rjmp	.+476    	; 0x5572 <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5396:	80 91 b7 06 	lds	r24, 0x06B7
    539a:	88 23       	and	r24, r24
    539c:	09 f0       	breq	.+2      	; 0x53a0 <vTaskGenericNotifyGiveFromISR+0xb8>
    539e:	a4 c0       	rjmp	.+328    	; 0x54e8 <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    53a0:	e9 85       	ldd	r30, Y+9	; 0x09
    53a2:	fa 85       	ldd	r31, Y+10	; 0x0a
    53a4:	82 85       	ldd	r24, Z+10	; 0x0a
    53a6:	93 85       	ldd	r25, Z+11	; 0x0b
    53a8:	9e 83       	std	Y+6, r25	; 0x06
    53aa:	8d 83       	std	Y+5, r24	; 0x05
    53ac:	e9 85       	ldd	r30, Y+9	; 0x09
    53ae:	fa 85       	ldd	r31, Y+10	; 0x0a
    53b0:	a4 81       	ldd	r26, Z+4	; 0x04
    53b2:	b5 81       	ldd	r27, Z+5	; 0x05
    53b4:	e9 85       	ldd	r30, Y+9	; 0x09
    53b6:	fa 85       	ldd	r31, Y+10	; 0x0a
    53b8:	86 81       	ldd	r24, Z+6	; 0x06
    53ba:	97 81       	ldd	r25, Z+7	; 0x07
    53bc:	15 96       	adiw	r26, 0x05	; 5
    53be:	9c 93       	st	X, r25
    53c0:	8e 93       	st	-X, r24
    53c2:	14 97       	sbiw	r26, 0x04	; 4
    53c4:	e9 85       	ldd	r30, Y+9	; 0x09
    53c6:	fa 85       	ldd	r31, Y+10	; 0x0a
    53c8:	a6 81       	ldd	r26, Z+6	; 0x06
    53ca:	b7 81       	ldd	r27, Z+7	; 0x07
    53cc:	e9 85       	ldd	r30, Y+9	; 0x09
    53ce:	fa 85       	ldd	r31, Y+10	; 0x0a
    53d0:	84 81       	ldd	r24, Z+4	; 0x04
    53d2:	95 81       	ldd	r25, Z+5	; 0x05
    53d4:	13 96       	adiw	r26, 0x03	; 3
    53d6:	9c 93       	st	X, r25
    53d8:	8e 93       	st	-X, r24
    53da:	12 97       	sbiw	r26, 0x02	; 2
    53dc:	ed 81       	ldd	r30, Y+5	; 0x05
    53de:	fe 81       	ldd	r31, Y+6	; 0x06
    53e0:	21 81       	ldd	r18, Z+1	; 0x01
    53e2:	32 81       	ldd	r19, Z+2	; 0x02
    53e4:	89 85       	ldd	r24, Y+9	; 0x09
    53e6:	9a 85       	ldd	r25, Y+10	; 0x0a
    53e8:	02 96       	adiw	r24, 0x02	; 2
    53ea:	28 17       	cp	r18, r24
    53ec:	39 07       	cpc	r19, r25
    53ee:	41 f4       	brne	.+16     	; 0x5400 <vTaskGenericNotifyGiveFromISR+0x118>
    53f0:	e9 85       	ldd	r30, Y+9	; 0x09
    53f2:	fa 85       	ldd	r31, Y+10	; 0x0a
    53f4:	86 81       	ldd	r24, Z+6	; 0x06
    53f6:	97 81       	ldd	r25, Z+7	; 0x07
    53f8:	ed 81       	ldd	r30, Y+5	; 0x05
    53fa:	fe 81       	ldd	r31, Y+6	; 0x06
    53fc:	92 83       	std	Z+2, r25	; 0x02
    53fe:	81 83       	std	Z+1, r24	; 0x01
    5400:	e9 85       	ldd	r30, Y+9	; 0x09
    5402:	fa 85       	ldd	r31, Y+10	; 0x0a
    5404:	13 86       	std	Z+11, r1	; 0x0b
    5406:	12 86       	std	Z+10, r1	; 0x0a
    5408:	ed 81       	ldd	r30, Y+5	; 0x05
    540a:	fe 81       	ldd	r31, Y+6	; 0x06
    540c:	80 81       	ld	r24, Z
    540e:	81 50       	subi	r24, 0x01	; 1
    5410:	ed 81       	ldd	r30, Y+5	; 0x05
    5412:	fe 81       	ldd	r31, Y+6	; 0x06
    5414:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    5416:	e9 85       	ldd	r30, Y+9	; 0x09
    5418:	fa 85       	ldd	r31, Y+10	; 0x0a
    541a:	96 89       	ldd	r25, Z+22	; 0x16
    541c:	80 91 ac 06 	lds	r24, 0x06AC
    5420:	89 17       	cp	r24, r25
    5422:	28 f4       	brcc	.+10     	; 0x542e <vTaskGenericNotifyGiveFromISR+0x146>
    5424:	e9 85       	ldd	r30, Y+9	; 0x09
    5426:	fa 85       	ldd	r31, Y+10	; 0x0a
    5428:	86 89       	ldd	r24, Z+22	; 0x16
    542a:	80 93 ac 06 	sts	0x06AC, r24
    542e:	e9 85       	ldd	r30, Y+9	; 0x09
    5430:	fa 85       	ldd	r31, Y+10	; 0x0a
    5432:	86 89       	ldd	r24, Z+22	; 0x16
    5434:	28 2f       	mov	r18, r24
    5436:	30 e0       	ldi	r19, 0x00	; 0
    5438:	c9 01       	movw	r24, r18
    543a:	88 0f       	add	r24, r24
    543c:	99 1f       	adc	r25, r25
    543e:	88 0f       	add	r24, r24
    5440:	99 1f       	adc	r25, r25
    5442:	88 0f       	add	r24, r24
    5444:	99 1f       	adc	r25, r25
    5446:	82 0f       	add	r24, r18
    5448:	93 1f       	adc	r25, r19
    544a:	fc 01       	movw	r30, r24
    544c:	e8 54       	subi	r30, 0x48	; 72
    544e:	f9 4f       	sbci	r31, 0xF9	; 249
    5450:	81 81       	ldd	r24, Z+1	; 0x01
    5452:	92 81       	ldd	r25, Z+2	; 0x02
    5454:	9c 83       	std	Y+4, r25	; 0x04
    5456:	8b 83       	std	Y+3, r24	; 0x03
    5458:	e9 85       	ldd	r30, Y+9	; 0x09
    545a:	fa 85       	ldd	r31, Y+10	; 0x0a
    545c:	8b 81       	ldd	r24, Y+3	; 0x03
    545e:	9c 81       	ldd	r25, Y+4	; 0x04
    5460:	95 83       	std	Z+5, r25	; 0x05
    5462:	84 83       	std	Z+4, r24	; 0x04
    5464:	eb 81       	ldd	r30, Y+3	; 0x03
    5466:	fc 81       	ldd	r31, Y+4	; 0x04
    5468:	84 81       	ldd	r24, Z+4	; 0x04
    546a:	95 81       	ldd	r25, Z+5	; 0x05
    546c:	e9 85       	ldd	r30, Y+9	; 0x09
    546e:	fa 85       	ldd	r31, Y+10	; 0x0a
    5470:	97 83       	std	Z+7, r25	; 0x07
    5472:	86 83       	std	Z+6, r24	; 0x06
    5474:	eb 81       	ldd	r30, Y+3	; 0x03
    5476:	fc 81       	ldd	r31, Y+4	; 0x04
    5478:	04 80       	ldd	r0, Z+4	; 0x04
    547a:	f5 81       	ldd	r31, Z+5	; 0x05
    547c:	e0 2d       	mov	r30, r0
    547e:	89 85       	ldd	r24, Y+9	; 0x09
    5480:	9a 85       	ldd	r25, Y+10	; 0x0a
    5482:	02 96       	adiw	r24, 0x02	; 2
    5484:	93 83       	std	Z+3, r25	; 0x03
    5486:	82 83       	std	Z+2, r24	; 0x02
    5488:	89 85       	ldd	r24, Y+9	; 0x09
    548a:	9a 85       	ldd	r25, Y+10	; 0x0a
    548c:	02 96       	adiw	r24, 0x02	; 2
    548e:	eb 81       	ldd	r30, Y+3	; 0x03
    5490:	fc 81       	ldd	r31, Y+4	; 0x04
    5492:	95 83       	std	Z+5, r25	; 0x05
    5494:	84 83       	std	Z+4, r24	; 0x04
    5496:	e9 85       	ldd	r30, Y+9	; 0x09
    5498:	fa 85       	ldd	r31, Y+10	; 0x0a
    549a:	86 89       	ldd	r24, Z+22	; 0x16
    549c:	28 2f       	mov	r18, r24
    549e:	30 e0       	ldi	r19, 0x00	; 0
    54a0:	c9 01       	movw	r24, r18
    54a2:	88 0f       	add	r24, r24
    54a4:	99 1f       	adc	r25, r25
    54a6:	88 0f       	add	r24, r24
    54a8:	99 1f       	adc	r25, r25
    54aa:	88 0f       	add	r24, r24
    54ac:	99 1f       	adc	r25, r25
    54ae:	82 0f       	add	r24, r18
    54b0:	93 1f       	adc	r25, r19
    54b2:	88 54       	subi	r24, 0x48	; 72
    54b4:	99 4f       	sbci	r25, 0xF9	; 249
    54b6:	e9 85       	ldd	r30, Y+9	; 0x09
    54b8:	fa 85       	ldd	r31, Y+10	; 0x0a
    54ba:	93 87       	std	Z+11, r25	; 0x0b
    54bc:	82 87       	std	Z+10, r24	; 0x0a
    54be:	e9 85       	ldd	r30, Y+9	; 0x09
    54c0:	fa 85       	ldd	r31, Y+10	; 0x0a
    54c2:	86 89       	ldd	r24, Z+22	; 0x16
    54c4:	28 2f       	mov	r18, r24
    54c6:	30 e0       	ldi	r19, 0x00	; 0
    54c8:	c9 01       	movw	r24, r18
    54ca:	88 0f       	add	r24, r24
    54cc:	99 1f       	adc	r25, r25
    54ce:	88 0f       	add	r24, r24
    54d0:	99 1f       	adc	r25, r25
    54d2:	88 0f       	add	r24, r24
    54d4:	99 1f       	adc	r25, r25
    54d6:	82 0f       	add	r24, r18
    54d8:	93 1f       	adc	r25, r19
    54da:	fc 01       	movw	r30, r24
    54dc:	e8 54       	subi	r30, 0x48	; 72
    54de:	f9 4f       	sbci	r31, 0xF9	; 249
    54e0:	80 81       	ld	r24, Z
    54e2:	8f 5f       	subi	r24, 0xFF	; 255
    54e4:	80 83       	st	Z, r24
    54e6:	30 c0       	rjmp	.+96     	; 0x5548 <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    54e8:	80 91 f3 06 	lds	r24, 0x06F3
    54ec:	90 91 f4 06 	lds	r25, 0x06F4
    54f0:	9a 83       	std	Y+2, r25	; 0x02
    54f2:	89 83       	std	Y+1, r24	; 0x01
    54f4:	e9 85       	ldd	r30, Y+9	; 0x09
    54f6:	fa 85       	ldd	r31, Y+10	; 0x0a
    54f8:	89 81       	ldd	r24, Y+1	; 0x01
    54fa:	9a 81       	ldd	r25, Y+2	; 0x02
    54fc:	97 87       	std	Z+15, r25	; 0x0f
    54fe:	86 87       	std	Z+14, r24	; 0x0e
    5500:	e9 81       	ldd	r30, Y+1	; 0x01
    5502:	fa 81       	ldd	r31, Y+2	; 0x02
    5504:	84 81       	ldd	r24, Z+4	; 0x04
    5506:	95 81       	ldd	r25, Z+5	; 0x05
    5508:	e9 85       	ldd	r30, Y+9	; 0x09
    550a:	fa 85       	ldd	r31, Y+10	; 0x0a
    550c:	91 8b       	std	Z+17, r25	; 0x11
    550e:	80 8b       	std	Z+16, r24	; 0x10
    5510:	e9 81       	ldd	r30, Y+1	; 0x01
    5512:	fa 81       	ldd	r31, Y+2	; 0x02
    5514:	04 80       	ldd	r0, Z+4	; 0x04
    5516:	f5 81       	ldd	r31, Z+5	; 0x05
    5518:	e0 2d       	mov	r30, r0
    551a:	89 85       	ldd	r24, Y+9	; 0x09
    551c:	9a 85       	ldd	r25, Y+10	; 0x0a
    551e:	0c 96       	adiw	r24, 0x0c	; 12
    5520:	93 83       	std	Z+3, r25	; 0x03
    5522:	82 83       	std	Z+2, r24	; 0x02
    5524:	89 85       	ldd	r24, Y+9	; 0x09
    5526:	9a 85       	ldd	r25, Y+10	; 0x0a
    5528:	0c 96       	adiw	r24, 0x0c	; 12
    552a:	e9 81       	ldd	r30, Y+1	; 0x01
    552c:	fa 81       	ldd	r31, Y+2	; 0x02
    552e:	95 83       	std	Z+5, r25	; 0x05
    5530:	84 83       	std	Z+4, r24	; 0x04
    5532:	e9 85       	ldd	r30, Y+9	; 0x09
    5534:	fa 85       	ldd	r31, Y+10	; 0x0a
    5536:	82 ef       	ldi	r24, 0xF2	; 242
    5538:	96 e0       	ldi	r25, 0x06	; 6
    553a:	95 8b       	std	Z+21, r25	; 0x15
    553c:	84 8b       	std	Z+20, r24	; 0x14
    553e:	80 91 f2 06 	lds	r24, 0x06F2
    5542:	8f 5f       	subi	r24, 0xFF	; 255
    5544:	80 93 f2 06 	sts	0x06F2, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5548:	e9 85       	ldd	r30, Y+9	; 0x09
    554a:	fa 85       	ldd	r31, Y+10	; 0x0a
    554c:	96 89       	ldd	r25, Z+22	; 0x16
    554e:	e0 91 a6 06 	lds	r30, 0x06A6
    5552:	f0 91 a7 06 	lds	r31, 0x06A7
    5556:	86 89       	ldd	r24, Z+22	; 0x16
    5558:	89 17       	cp	r24, r25
    555a:	58 f4       	brcc	.+22     	; 0x5572 <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    555c:	8e 85       	ldd	r24, Y+14	; 0x0e
    555e:	9f 85       	ldd	r25, Y+15	; 0x0f
    5560:	00 97       	sbiw	r24, 0x00	; 0
    5562:	21 f0       	breq	.+8      	; 0x556c <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5564:	ee 85       	ldd	r30, Y+14	; 0x0e
    5566:	ff 85       	ldd	r31, Y+15	; 0x0f
    5568:	81 e0       	ldi	r24, 0x01	; 1
    556a:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    556c:	81 e0       	ldi	r24, 0x01	; 1
    556e:	80 93 b0 06 	sts	0x06B0, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    5572:	2f 96       	adiw	r28, 0x0f	; 15
    5574:	0f b6       	in	r0, 0x3f	; 63
    5576:	f8 94       	cli
    5578:	de bf       	out	0x3e, r29	; 62
    557a:	0f be       	out	0x3f, r0	; 63
    557c:	cd bf       	out	0x3d, r28	; 61
    557e:	cf 91       	pop	r28
    5580:	df 91       	pop	r29
    5582:	1f 91       	pop	r17
    5584:	0f 91       	pop	r16
    5586:	08 95       	ret

00005588 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    5588:	df 93       	push	r29
    558a:	cf 93       	push	r28
    558c:	cd b7       	in	r28, 0x3d	; 61
    558e:	de b7       	in	r29, 0x3e	; 62
    5590:	28 97       	sbiw	r28, 0x08	; 8
    5592:	0f b6       	in	r0, 0x3f	; 63
    5594:	f8 94       	cli
    5596:	de bf       	out	0x3e, r29	; 62
    5598:	0f be       	out	0x3f, r0	; 63
    559a:	cd bf       	out	0x3d, r28	; 61
    559c:	9d 83       	std	Y+5, r25	; 0x05
    559e:	8c 83       	std	Y+4, r24	; 0x04
    55a0:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    55a2:	8c 81       	ldd	r24, Y+4	; 0x04
    55a4:	9d 81       	ldd	r25, Y+5	; 0x05
    55a6:	00 97       	sbiw	r24, 0x00	; 0
    55a8:	39 f4       	brne	.+14     	; 0x55b8 <xTaskGenericNotifyStateClear+0x30>
    55aa:	80 91 a6 06 	lds	r24, 0x06A6
    55ae:	90 91 a7 06 	lds	r25, 0x06A7
    55b2:	98 87       	std	Y+8, r25	; 0x08
    55b4:	8f 83       	std	Y+7, r24	; 0x07
    55b6:	04 c0       	rjmp	.+8      	; 0x55c0 <xTaskGenericNotifyStateClear+0x38>
    55b8:	8c 81       	ldd	r24, Y+4	; 0x04
    55ba:	9d 81       	ldd	r25, Y+5	; 0x05
    55bc:	98 87       	std	Y+8, r25	; 0x08
    55be:	8f 83       	std	Y+7, r24	; 0x07
    55c0:	8f 81       	ldd	r24, Y+7	; 0x07
    55c2:	98 85       	ldd	r25, Y+8	; 0x08
    55c4:	9b 83       	std	Y+3, r25	; 0x03
    55c6:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    55c8:	0f b6       	in	r0, 0x3f	; 63
    55ca:	f8 94       	cli
    55cc:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    55ce:	8e 81       	ldd	r24, Y+6	; 0x06
    55d0:	28 2f       	mov	r18, r24
    55d2:	30 e0       	ldi	r19, 0x00	; 0
    55d4:	8a 81       	ldd	r24, Y+2	; 0x02
    55d6:	9b 81       	ldd	r25, Y+3	; 0x03
    55d8:	82 0f       	add	r24, r18
    55da:	93 1f       	adc	r25, r19
    55dc:	fc 01       	movw	r30, r24
    55de:	b5 96       	adiw	r30, 0x25	; 37
    55e0:	80 81       	ld	r24, Z
    55e2:	82 30       	cpi	r24, 0x02	; 2
    55e4:	69 f4       	brne	.+26     	; 0x5600 <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    55e6:	8e 81       	ldd	r24, Y+6	; 0x06
    55e8:	28 2f       	mov	r18, r24
    55ea:	30 e0       	ldi	r19, 0x00	; 0
    55ec:	8a 81       	ldd	r24, Y+2	; 0x02
    55ee:	9b 81       	ldd	r25, Y+3	; 0x03
    55f0:	82 0f       	add	r24, r18
    55f2:	93 1f       	adc	r25, r19
    55f4:	fc 01       	movw	r30, r24
    55f6:	b5 96       	adiw	r30, 0x25	; 37
    55f8:	10 82       	st	Z, r1
                xReturn = pdPASS;
    55fa:	81 e0       	ldi	r24, 0x01	; 1
    55fc:	89 83       	std	Y+1, r24	; 0x01
    55fe:	01 c0       	rjmp	.+2      	; 0x5602 <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    5600:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    5602:	0f 90       	pop	r0
    5604:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5606:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5608:	28 96       	adiw	r28, 0x08	; 8
    560a:	0f b6       	in	r0, 0x3f	; 63
    560c:	f8 94       	cli
    560e:	de bf       	out	0x3e, r29	; 62
    5610:	0f be       	out	0x3f, r0	; 63
    5612:	cd bf       	out	0x3d, r28	; 61
    5614:	cf 91       	pop	r28
    5616:	df 91       	pop	r29
    5618:	08 95       	ret

0000561a <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    561a:	0f 93       	push	r16
    561c:	1f 93       	push	r17
    561e:	df 93       	push	r29
    5620:	cf 93       	push	r28
    5622:	cd b7       	in	r28, 0x3d	; 61
    5624:	de b7       	in	r29, 0x3e	; 62
    5626:	2f 97       	sbiw	r28, 0x0f	; 15
    5628:	0f b6       	in	r0, 0x3f	; 63
    562a:	f8 94       	cli
    562c:	de bf       	out	0x3e, r29	; 62
    562e:	0f be       	out	0x3f, r0	; 63
    5630:	cd bf       	out	0x3d, r28	; 61
    5632:	98 87       	std	Y+8, r25	; 0x08
    5634:	8f 83       	std	Y+7, r24	; 0x07
    5636:	69 87       	std	Y+9, r22	; 0x09
    5638:	2a 87       	std	Y+10, r18	; 0x0a
    563a:	3b 87       	std	Y+11, r19	; 0x0b
    563c:	4c 87       	std	Y+12, r20	; 0x0c
    563e:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    5640:	8f 81       	ldd	r24, Y+7	; 0x07
    5642:	98 85       	ldd	r25, Y+8	; 0x08
    5644:	00 97       	sbiw	r24, 0x00	; 0
    5646:	39 f4       	brne	.+14     	; 0x5656 <ulTaskGenericNotifyValueClear+0x3c>
    5648:	80 91 a6 06 	lds	r24, 0x06A6
    564c:	90 91 a7 06 	lds	r25, 0x06A7
    5650:	9f 87       	std	Y+15, r25	; 0x0f
    5652:	8e 87       	std	Y+14, r24	; 0x0e
    5654:	04 c0       	rjmp	.+8      	; 0x565e <ulTaskGenericNotifyValueClear+0x44>
    5656:	8f 81       	ldd	r24, Y+7	; 0x07
    5658:	98 85       	ldd	r25, Y+8	; 0x08
    565a:	9f 87       	std	Y+15, r25	; 0x0f
    565c:	8e 87       	std	Y+14, r24	; 0x0e
    565e:	8e 85       	ldd	r24, Y+14	; 0x0e
    5660:	9f 85       	ldd	r25, Y+15	; 0x0f
    5662:	9e 83       	std	Y+6, r25	; 0x06
    5664:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    5666:	0f b6       	in	r0, 0x3f	; 63
    5668:	f8 94       	cli
    566a:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    566c:	89 85       	ldd	r24, Y+9	; 0x09
    566e:	88 2f       	mov	r24, r24
    5670:	90 e0       	ldi	r25, 0x00	; 0
    5672:	2d 81       	ldd	r18, Y+5	; 0x05
    5674:	3e 81       	ldd	r19, Y+6	; 0x06
    5676:	88 0f       	add	r24, r24
    5678:	99 1f       	adc	r25, r25
    567a:	88 0f       	add	r24, r24
    567c:	99 1f       	adc	r25, r25
    567e:	82 0f       	add	r24, r18
    5680:	93 1f       	adc	r25, r19
    5682:	fc 01       	movw	r30, r24
    5684:	b1 96       	adiw	r30, 0x21	; 33
    5686:	80 81       	ld	r24, Z
    5688:	91 81       	ldd	r25, Z+1	; 0x01
    568a:	a2 81       	ldd	r26, Z+2	; 0x02
    568c:	b3 81       	ldd	r27, Z+3	; 0x03
    568e:	89 83       	std	Y+1, r24	; 0x01
    5690:	9a 83       	std	Y+2, r25	; 0x02
    5692:	ab 83       	std	Y+3, r26	; 0x03
    5694:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    5696:	89 85       	ldd	r24, Y+9	; 0x09
    5698:	08 2f       	mov	r16, r24
    569a:	10 e0       	ldi	r17, 0x00	; 0
    569c:	89 85       	ldd	r24, Y+9	; 0x09
    569e:	88 2f       	mov	r24, r24
    56a0:	90 e0       	ldi	r25, 0x00	; 0
    56a2:	2d 81       	ldd	r18, Y+5	; 0x05
    56a4:	3e 81       	ldd	r19, Y+6	; 0x06
    56a6:	88 0f       	add	r24, r24
    56a8:	99 1f       	adc	r25, r25
    56aa:	88 0f       	add	r24, r24
    56ac:	99 1f       	adc	r25, r25
    56ae:	82 0f       	add	r24, r18
    56b0:	93 1f       	adc	r25, r19
    56b2:	fc 01       	movw	r30, r24
    56b4:	b1 96       	adiw	r30, 0x21	; 33
    56b6:	20 81       	ld	r18, Z
    56b8:	31 81       	ldd	r19, Z+1	; 0x01
    56ba:	42 81       	ldd	r20, Z+2	; 0x02
    56bc:	53 81       	ldd	r21, Z+3	; 0x03
    56be:	8a 85       	ldd	r24, Y+10	; 0x0a
    56c0:	9b 85       	ldd	r25, Y+11	; 0x0b
    56c2:	ac 85       	ldd	r26, Y+12	; 0x0c
    56c4:	bd 85       	ldd	r27, Y+13	; 0x0d
    56c6:	80 95       	com	r24
    56c8:	90 95       	com	r25
    56ca:	a0 95       	com	r26
    56cc:	b0 95       	com	r27
    56ce:	ba 01       	movw	r22, r20
    56d0:	a9 01       	movw	r20, r18
    56d2:	48 23       	and	r20, r24
    56d4:	59 23       	and	r21, r25
    56d6:	6a 23       	and	r22, r26
    56d8:	7b 23       	and	r23, r27
    56da:	2d 81       	ldd	r18, Y+5	; 0x05
    56dc:	3e 81       	ldd	r19, Y+6	; 0x06
    56de:	c8 01       	movw	r24, r16
    56e0:	88 0f       	add	r24, r24
    56e2:	99 1f       	adc	r25, r25
    56e4:	88 0f       	add	r24, r24
    56e6:	99 1f       	adc	r25, r25
    56e8:	82 0f       	add	r24, r18
    56ea:	93 1f       	adc	r25, r19
    56ec:	fc 01       	movw	r30, r24
    56ee:	b1 96       	adiw	r30, 0x21	; 33
    56f0:	40 83       	st	Z, r20
    56f2:	51 83       	std	Z+1, r21	; 0x01
    56f4:	62 83       	std	Z+2, r22	; 0x02
    56f6:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    56f8:	0f 90       	pop	r0
    56fa:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    56fc:	89 81       	ldd	r24, Y+1	; 0x01
    56fe:	9a 81       	ldd	r25, Y+2	; 0x02
    5700:	ab 81       	ldd	r26, Y+3	; 0x03
    5702:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    5704:	bc 01       	movw	r22, r24
    5706:	cd 01       	movw	r24, r26
    5708:	2f 96       	adiw	r28, 0x0f	; 15
    570a:	0f b6       	in	r0, 0x3f	; 63
    570c:	f8 94       	cli
    570e:	de bf       	out	0x3e, r29	; 62
    5710:	0f be       	out	0x3f, r0	; 63
    5712:	cd bf       	out	0x3d, r28	; 61
    5714:	cf 91       	pop	r28
    5716:	df 91       	pop	r29
    5718:	1f 91       	pop	r17
    571a:	0f 91       	pop	r16
    571c:	08 95       	ret

0000571e <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    571e:	df 93       	push	r29
    5720:	cf 93       	push	r28
    5722:	cd b7       	in	r28, 0x3d	; 61
    5724:	de b7       	in	r29, 0x3e	; 62
    5726:	27 97       	sbiw	r28, 0x07	; 7
    5728:	0f b6       	in	r0, 0x3f	; 63
    572a:	f8 94       	cli
    572c:	de bf       	out	0x3e, r29	; 62
    572e:	0f be       	out	0x3f, r0	; 63
    5730:	cd bf       	out	0x3d, r28	; 61
    5732:	9e 83       	std	Y+6, r25	; 0x06
    5734:	8d 83       	std	Y+5, r24	; 0x05
    5736:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    5738:	80 91 aa 06 	lds	r24, 0x06AA
    573c:	90 91 ab 06 	lds	r25, 0x06AB
    5740:	9a 83       	std	Y+2, r25	; 0x02
    5742:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5744:	80 91 a6 06 	lds	r24, 0x06A6
    5748:	90 91 a7 06 	lds	r25, 0x06A7
    574c:	02 96       	adiw	r24, 0x02	; 2
    574e:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the kernel
             * will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    5752:	29 81       	ldd	r18, Y+1	; 0x01
    5754:	3a 81       	ldd	r19, Y+2	; 0x02
    5756:	8d 81       	ldd	r24, Y+5	; 0x05
    5758:	9e 81       	ldd	r25, Y+6	; 0x06
    575a:	82 0f       	add	r24, r18
    575c:	93 1f       	adc	r25, r19
    575e:	9c 83       	std	Y+4, r25	; 0x04
    5760:	8b 83       	std	Y+3, r24	; 0x03

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    5762:	e0 91 a6 06 	lds	r30, 0x06A6
    5766:	f0 91 a7 06 	lds	r31, 0x06A7
    576a:	8b 81       	ldd	r24, Y+3	; 0x03
    576c:	9c 81       	ldd	r25, Y+4	; 0x04
    576e:	93 83       	std	Z+3, r25	; 0x03
    5770:	82 83       	std	Z+2, r24	; 0x02

            if( xTimeToWake < xConstTickCount )
    5772:	2b 81       	ldd	r18, Y+3	; 0x03
    5774:	3c 81       	ldd	r19, Y+4	; 0x04
    5776:	89 81       	ldd	r24, Y+1	; 0x01
    5778:	9a 81       	ldd	r25, Y+2	; 0x02
    577a:	28 17       	cp	r18, r24
    577c:	39 07       	cpc	r19, r25
    577e:	70 f4       	brcc	.+28     	; 0x579c <prvAddCurrentTaskToDelayedList+0x7e>
            {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5780:	80 91 f0 06 	lds	r24, 0x06F0
    5784:	90 91 f1 06 	lds	r25, 0x06F1
    5788:	20 91 a6 06 	lds	r18, 0x06A6
    578c:	30 91 a7 06 	lds	r19, 0x06A7
    5790:	2e 5f       	subi	r18, 0xFE	; 254
    5792:	3f 4f       	sbci	r19, 0xFF	; 255
    5794:	b9 01       	movw	r22, r18
    5796:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <vListInsert>
    579a:	1e c0       	rjmp	.+60     	; 0x57d8 <prvAddCurrentTaskToDelayedList+0xba>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    579c:	40 91 ee 06 	lds	r20, 0x06EE
    57a0:	50 91 ef 06 	lds	r21, 0x06EF
    57a4:	80 91 a6 06 	lds	r24, 0x06A6
    57a8:	90 91 a7 06 	lds	r25, 0x06A7
    57ac:	9c 01       	movw	r18, r24
    57ae:	2e 5f       	subi	r18, 0xFE	; 254
    57b0:	3f 4f       	sbci	r19, 0xFF	; 255
    57b2:	ca 01       	movw	r24, r20
    57b4:	b9 01       	movw	r22, r18
    57b6:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <vListInsert>

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    57ba:	20 91 b3 06 	lds	r18, 0x06B3
    57be:	30 91 b4 06 	lds	r19, 0x06B4
    57c2:	8b 81       	ldd	r24, Y+3	; 0x03
    57c4:	9c 81       	ldd	r25, Y+4	; 0x04
    57c6:	82 17       	cp	r24, r18
    57c8:	93 07       	cpc	r25, r19
    57ca:	30 f4       	brcc	.+12     	; 0x57d8 <prvAddCurrentTaskToDelayedList+0xba>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    57cc:	8b 81       	ldd	r24, Y+3	; 0x03
    57ce:	9c 81       	ldd	r25, Y+4	; 0x04
    57d0:	90 93 b4 06 	sts	0x06B4, r25
    57d4:	80 93 b3 06 	sts	0x06B3, r24

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    57d8:	27 96       	adiw	r28, 0x07	; 7
    57da:	0f b6       	in	r0, 0x3f	; 63
    57dc:	f8 94       	cli
    57de:	de bf       	out	0x3e, r29	; 62
    57e0:	0f be       	out	0x3f, r0	; 63
    57e2:	cd bf       	out	0x3d, r28	; 61
    57e4:	cf 91       	pop	r28
    57e6:	df 91       	pop	r29
    57e8:	08 95       	ret

000057ea <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
    57ea:	ef 92       	push	r14
    57ec:	ff 92       	push	r15
    57ee:	0f 93       	push	r16
    57f0:	df 93       	push	r29
    57f2:	cf 93       	push	r28
    57f4:	0f 92       	push	r0
    57f6:	cd b7       	in	r28, 0x3d	; 61
    57f8:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn = pdFAIL;
    57fa:	19 82       	std	Y+1, r1	; 0x01

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
    57fc:	0e 94 b4 30 	call	0x6168	; 0x6168 <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
    5800:	80 91 04 07 	lds	r24, 0x0704
    5804:	90 91 05 07 	lds	r25, 0x0705
    5808:	00 97       	sbiw	r24, 0x00	; 0
    580a:	81 f0       	breq	.+32     	; 0x582c <xTimerCreateTimerTask+0x42>
                        xReturn = pdPASS;
                    }
                }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
    580c:	86 e4       	ldi	r24, 0x46	; 70
    580e:	9e e2       	ldi	r25, 0x2E	; 46
    5810:	25 e6       	ldi	r18, 0x65	; 101
    5812:	30 e0       	ldi	r19, 0x00	; 0
    5814:	e6 e0       	ldi	r30, 0x06	; 6
    5816:	f7 e0       	ldi	r31, 0x07	; 7
    5818:	b9 01       	movw	r22, r18
    581a:	45 e5       	ldi	r20, 0x55	; 85
    581c:	50 e0       	ldi	r21, 0x00	; 0
    581e:	20 e0       	ldi	r18, 0x00	; 0
    5820:	30 e0       	ldi	r19, 0x00	; 0
    5822:	03 e0       	ldi	r16, 0x03	; 3
    5824:	7f 01       	movw	r14, r30
    5826:	0e 94 05 18 	call	0x300a	; 0x300a <xTaskCreate>
    582a:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
        return xReturn;
    582c:	89 81       	ldd	r24, Y+1	; 0x01
    }
    582e:	0f 90       	pop	r0
    5830:	cf 91       	pop	r28
    5832:	df 91       	pop	r29
    5834:	0f 91       	pop	r16
    5836:	ff 90       	pop	r15
    5838:	ef 90       	pop	r14
    583a:	08 95       	ret

0000583c <xTimerCreate>:
        TimerHandle_t xTimerCreate( const char * const pcTimerName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                    const TickType_t xTimerPeriodInTicks,
                                    const UBaseType_t uxAutoReload,
                                    void * const pvTimerID,
                                    TimerCallbackFunction_t pxCallbackFunction )
        {
    583c:	ef 92       	push	r14
    583e:	ff 92       	push	r15
    5840:	0f 93       	push	r16
    5842:	1f 93       	push	r17
    5844:	df 93       	push	r29
    5846:	cf 93       	push	r28
    5848:	cd b7       	in	r28, 0x3d	; 61
    584a:	de b7       	in	r29, 0x3e	; 62
    584c:	2b 97       	sbiw	r28, 0x0b	; 11
    584e:	0f b6       	in	r0, 0x3f	; 63
    5850:	f8 94       	cli
    5852:	de bf       	out	0x3e, r29	; 62
    5854:	0f be       	out	0x3f, r0	; 63
    5856:	cd bf       	out	0x3d, r28	; 61
    5858:	9c 83       	std	Y+4, r25	; 0x04
    585a:	8b 83       	std	Y+3, r24	; 0x03
    585c:	7e 83       	std	Y+6, r23	; 0x06
    585e:	6d 83       	std	Y+5, r22	; 0x05
    5860:	4f 83       	std	Y+7, r20	; 0x07
    5862:	39 87       	std	Y+9, r19	; 0x09
    5864:	28 87       	std	Y+8, r18	; 0x08
    5866:	1b 87       	std	Y+11, r17	; 0x0b
    5868:	0a 87       	std	Y+10, r16	; 0x0a
            Timer_t * pxNewTimer;

            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
    586a:	83 e1       	ldi	r24, 0x13	; 19
    586c:	90 e0       	ldi	r25, 0x00	; 0
    586e:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    5872:	9a 83       	std	Y+2, r25	; 0x02
    5874:	89 83       	std	Y+1, r24	; 0x01

            if( pxNewTimer != NULL )
    5876:	89 81       	ldd	r24, Y+1	; 0x01
    5878:	9a 81       	ldd	r25, Y+2	; 0x02
    587a:	00 97       	sbiw	r24, 0x00	; 0
    587c:	99 f0       	breq	.+38     	; 0x58a4 <xTimerCreate+0x68>
            {
                /* Status is thus far zero as the timer is not created statically
                 * and has not been started.  The auto-reload bit may get set in
                 * prvInitialiseNewTimer. */
                pxNewTimer->ucStatus = 0x00;
    587e:	e9 81       	ldd	r30, Y+1	; 0x01
    5880:	fa 81       	ldd	r31, Y+2	; 0x02
    5882:	12 8a       	std	Z+18, r1	; 0x12
                prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
    5884:	8b 81       	ldd	r24, Y+3	; 0x03
    5886:	9c 81       	ldd	r25, Y+4	; 0x04
    5888:	2d 81       	ldd	r18, Y+5	; 0x05
    588a:	3e 81       	ldd	r19, Y+6	; 0x06
    588c:	e8 85       	ldd	r30, Y+8	; 0x08
    588e:	f9 85       	ldd	r31, Y+9	; 0x09
    5890:	aa 85       	ldd	r26, Y+10	; 0x0a
    5892:	bb 85       	ldd	r27, Y+11	; 0x0b
    5894:	e9 80       	ldd	r14, Y+1	; 0x01
    5896:	fa 80       	ldd	r15, Y+2	; 0x02
    5898:	b9 01       	movw	r22, r18
    589a:	4f 81       	ldd	r20, Y+7	; 0x07
    589c:	9f 01       	movw	r18, r30
    589e:	8d 01       	movw	r16, r26
    58a0:	0e 94 61 2c 	call	0x58c2	; 0x58c2 <prvInitialiseNewTimer>
            }

            return pxNewTimer;
    58a4:	89 81       	ldd	r24, Y+1	; 0x01
    58a6:	9a 81       	ldd	r25, Y+2	; 0x02
        }
    58a8:	2b 96       	adiw	r28, 0x0b	; 11
    58aa:	0f b6       	in	r0, 0x3f	; 63
    58ac:	f8 94       	cli
    58ae:	de bf       	out	0x3e, r29	; 62
    58b0:	0f be       	out	0x3f, r0	; 63
    58b2:	cd bf       	out	0x3d, r28	; 61
    58b4:	cf 91       	pop	r28
    58b6:	df 91       	pop	r29
    58b8:	1f 91       	pop	r17
    58ba:	0f 91       	pop	r16
    58bc:	ff 90       	pop	r15
    58be:	ef 90       	pop	r14
    58c0:	08 95       	ret

000058c2 <prvInitialiseNewTimer>:
                                       const TickType_t xTimerPeriodInTicks,
                                       const UBaseType_t uxAutoReload,
                                       void * const pvTimerID,
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer )
    {
    58c2:	ef 92       	push	r14
    58c4:	ff 92       	push	r15
    58c6:	0f 93       	push	r16
    58c8:	1f 93       	push	r17
    58ca:	df 93       	push	r29
    58cc:	cf 93       	push	r28
    58ce:	cd b7       	in	r28, 0x3d	; 61
    58d0:	de b7       	in	r29, 0x3e	; 62
    58d2:	2b 97       	sbiw	r28, 0x0b	; 11
    58d4:	0f b6       	in	r0, 0x3f	; 63
    58d6:	f8 94       	cli
    58d8:	de bf       	out	0x3e, r29	; 62
    58da:	0f be       	out	0x3f, r0	; 63
    58dc:	cd bf       	out	0x3d, r28	; 61
    58de:	9a 83       	std	Y+2, r25	; 0x02
    58e0:	89 83       	std	Y+1, r24	; 0x01
    58e2:	7c 83       	std	Y+4, r23	; 0x04
    58e4:	6b 83       	std	Y+3, r22	; 0x03
    58e6:	4d 83       	std	Y+5, r20	; 0x05
    58e8:	3f 83       	std	Y+7, r19	; 0x07
    58ea:	2e 83       	std	Y+6, r18	; 0x06
    58ec:	19 87       	std	Y+9, r17	; 0x09
    58ee:	08 87       	std	Y+8, r16	; 0x08
    58f0:	fb 86       	std	Y+11, r15	; 0x0b
    58f2:	ea 86       	std	Y+10, r14	; 0x0a
        /* 0 is not a valid value for xTimerPeriodInTicks. */
        configASSERT( ( xTimerPeriodInTicks > 0 ) );

        /* Ensure the infrastructure used by the timer service task has been
         * created/initialised. */
        prvCheckForValidListAndQueue();
    58f4:	0e 94 b4 30 	call	0x6168	; 0x6168 <prvCheckForValidListAndQueue>

        /* Initialise the timer structure members using the function
         * parameters. */
        pxNewTimer->pcTimerName = pcTimerName;
    58f8:	ea 85       	ldd	r30, Y+10	; 0x0a
    58fa:	fb 85       	ldd	r31, Y+11	; 0x0b
    58fc:	89 81       	ldd	r24, Y+1	; 0x01
    58fe:	9a 81       	ldd	r25, Y+2	; 0x02
    5900:	91 83       	std	Z+1, r25	; 0x01
    5902:	80 83       	st	Z, r24
        pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    5904:	ea 85       	ldd	r30, Y+10	; 0x0a
    5906:	fb 85       	ldd	r31, Y+11	; 0x0b
    5908:	8b 81       	ldd	r24, Y+3	; 0x03
    590a:	9c 81       	ldd	r25, Y+4	; 0x04
    590c:	95 87       	std	Z+13, r25	; 0x0d
    590e:	84 87       	std	Z+12, r24	; 0x0c
        pxNewTimer->pvTimerID = pvTimerID;
    5910:	ea 85       	ldd	r30, Y+10	; 0x0a
    5912:	fb 85       	ldd	r31, Y+11	; 0x0b
    5914:	8e 81       	ldd	r24, Y+6	; 0x06
    5916:	9f 81       	ldd	r25, Y+7	; 0x07
    5918:	97 87       	std	Z+15, r25	; 0x0f
    591a:	86 87       	std	Z+14, r24	; 0x0e
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    591c:	ea 85       	ldd	r30, Y+10	; 0x0a
    591e:	fb 85       	ldd	r31, Y+11	; 0x0b
    5920:	88 85       	ldd	r24, Y+8	; 0x08
    5922:	99 85       	ldd	r25, Y+9	; 0x09
    5924:	91 8b       	std	Z+17, r25	; 0x11
    5926:	80 8b       	std	Z+16, r24	; 0x10
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    5928:	8a 85       	ldd	r24, Y+10	; 0x0a
    592a:	9b 85       	ldd	r25, Y+11	; 0x0b
    592c:	02 96       	adiw	r24, 0x02	; 2
    592e:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <vListInitialiseItem>

        if( uxAutoReload != pdFALSE )
    5932:	8d 81       	ldd	r24, Y+5	; 0x05
    5934:	88 23       	and	r24, r24
    5936:	39 f0       	breq	.+14     	; 0x5946 <prvInitialiseNewTimer+0x84>
        {
            pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    5938:	ea 85       	ldd	r30, Y+10	; 0x0a
    593a:	fb 85       	ldd	r31, Y+11	; 0x0b
    593c:	82 89       	ldd	r24, Z+18	; 0x12
    593e:	84 60       	ori	r24, 0x04	; 4
    5940:	ea 85       	ldd	r30, Y+10	; 0x0a
    5942:	fb 85       	ldd	r31, Y+11	; 0x0b
    5944:	82 8b       	std	Z+18, r24	; 0x12
        }

        traceTIMER_CREATE( pxNewTimer );
    }
    5946:	2b 96       	adiw	r28, 0x0b	; 11
    5948:	0f b6       	in	r0, 0x3f	; 63
    594a:	f8 94       	cli
    594c:	de bf       	out	0x3e, r29	; 62
    594e:	0f be       	out	0x3f, r0	; 63
    5950:	cd bf       	out	0x3d, r28	; 61
    5952:	cf 91       	pop	r28
    5954:	df 91       	pop	r29
    5956:	1f 91       	pop	r17
    5958:	0f 91       	pop	r16
    595a:	ff 90       	pop	r15
    595c:	ef 90       	pop	r14
    595e:	08 95       	ret

00005960 <xTimerGenericCommand>:
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
    5960:	0f 93       	push	r16
    5962:	1f 93       	push	r17
    5964:	df 93       	push	r29
    5966:	cf 93       	push	r28
    5968:	cd b7       	in	r28, 0x3d	; 61
    596a:	de b7       	in	r29, 0x3e	; 62
    596c:	2f 97       	sbiw	r28, 0x0f	; 15
    596e:	0f b6       	in	r0, 0x3f	; 63
    5970:	f8 94       	cli
    5972:	de bf       	out	0x3e, r29	; 62
    5974:	0f be       	out	0x3f, r0	; 63
    5976:	cd bf       	out	0x3d, r28	; 61
    5978:	98 87       	std	Y+8, r25	; 0x08
    597a:	8f 83       	std	Y+7, r24	; 0x07
    597c:	69 87       	std	Y+9, r22	; 0x09
    597e:	5b 87       	std	Y+11, r21	; 0x0b
    5980:	4a 87       	std	Y+10, r20	; 0x0a
    5982:	3d 87       	std	Y+13, r19	; 0x0d
    5984:	2c 87       	std	Y+12, r18	; 0x0c
    5986:	1f 87       	std	Y+15, r17	; 0x0f
    5988:	0e 87       	std	Y+14, r16	; 0x0e
        BaseType_t xReturn = pdFAIL;
    598a:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTimer );

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
    598c:	80 91 04 07 	lds	r24, 0x0704
    5990:	90 91 05 07 	lds	r25, 0x0705
    5994:	00 97       	sbiw	r24, 0x00	; 0
    5996:	e9 f1       	breq	.+122    	; 0x5a12 <xTimerGenericCommand+0xb2>
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
    5998:	89 85       	ldd	r24, Y+9	; 0x09
    599a:	8a 83       	std	Y+2, r24	; 0x02
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    599c:	8a 85       	ldd	r24, Y+10	; 0x0a
    599e:	9b 85       	ldd	r25, Y+11	; 0x0b
    59a0:	9c 83       	std	Y+4, r25	; 0x04
    59a2:	8b 83       	std	Y+3, r24	; 0x03
            xMessage.u.xTimerParameters.pxTimer = xTimer;
    59a4:	8f 81       	ldd	r24, Y+7	; 0x07
    59a6:	98 85       	ldd	r25, Y+8	; 0x08
    59a8:	9e 83       	std	Y+6, r25	; 0x06
    59aa:	8d 83       	std	Y+5, r24	; 0x05

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    59ac:	89 85       	ldd	r24, Y+9	; 0x09
    59ae:	86 30       	cpi	r24, 0x06	; 6
    59b0:	14 f5       	brge	.+68     	; 0x59f6 <xTimerGenericCommand+0x96>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    59b2:	0e 94 ca 23 	call	0x4794	; 0x4794 <xTaskGetSchedulerState>
    59b6:	82 30       	cpi	r24, 0x02	; 2
    59b8:	79 f4       	brne	.+30     	; 0x59d8 <xTimerGenericCommand+0x78>
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    59ba:	80 91 04 07 	lds	r24, 0x0704
    59be:	90 91 05 07 	lds	r25, 0x0705
    59c2:	9e 01       	movw	r18, r28
    59c4:	2e 5f       	subi	r18, 0xFE	; 254
    59c6:	3f 4f       	sbci	r19, 0xFF	; 255
    59c8:	4e 85       	ldd	r20, Y+14	; 0x0e
    59ca:	5f 85       	ldd	r21, Y+15	; 0x0f
    59cc:	b9 01       	movw	r22, r18
    59ce:	20 e0       	ldi	r18, 0x00	; 0
    59d0:	0e 94 09 10 	call	0x2012	; 0x2012 <xQueueGenericSend>
    59d4:	89 83       	std	Y+1, r24	; 0x01
    59d6:	1d c0       	rjmp	.+58     	; 0x5a12 <xTimerGenericCommand+0xb2>
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    59d8:	80 91 04 07 	lds	r24, 0x0704
    59dc:	90 91 05 07 	lds	r25, 0x0705
    59e0:	9e 01       	movw	r18, r28
    59e2:	2e 5f       	subi	r18, 0xFE	; 254
    59e4:	3f 4f       	sbci	r19, 0xFF	; 255
    59e6:	b9 01       	movw	r22, r18
    59e8:	40 e0       	ldi	r20, 0x00	; 0
    59ea:	50 e0       	ldi	r21, 0x00	; 0
    59ec:	20 e0       	ldi	r18, 0x00	; 0
    59ee:	0e 94 09 10 	call	0x2012	; 0x2012 <xQueueGenericSend>
    59f2:	89 83       	std	Y+1, r24	; 0x01
    59f4:	0e c0       	rjmp	.+28     	; 0x5a12 <xTimerGenericCommand+0xb2>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    59f6:	80 91 04 07 	lds	r24, 0x0704
    59fa:	90 91 05 07 	lds	r25, 0x0705
    59fe:	9e 01       	movw	r18, r28
    5a00:	2e 5f       	subi	r18, 0xFE	; 254
    5a02:	3f 4f       	sbci	r19, 0xFF	; 255
    5a04:	4c 85       	ldd	r20, Y+12	; 0x0c
    5a06:	5d 85       	ldd	r21, Y+13	; 0x0d
    5a08:	b9 01       	movw	r22, r18
    5a0a:	20 e0       	ldi	r18, 0x00	; 0
    5a0c:	0e 94 b5 10 	call	0x216a	; 0x216a <xQueueGenericSendFromISR>
    5a10:	89 83       	std	Y+1, r24	; 0x01
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    5a12:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5a14:	2f 96       	adiw	r28, 0x0f	; 15
    5a16:	0f b6       	in	r0, 0x3f	; 63
    5a18:	f8 94       	cli
    5a1a:	de bf       	out	0x3e, r29	; 62
    5a1c:	0f be       	out	0x3f, r0	; 63
    5a1e:	cd bf       	out	0x3d, r28	; 61
    5a20:	cf 91       	pop	r28
    5a22:	df 91       	pop	r29
    5a24:	1f 91       	pop	r17
    5a26:	0f 91       	pop	r16
    5a28:	08 95       	ret

00005a2a <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
    {
    5a2a:	df 93       	push	r29
    5a2c:	cf 93       	push	r28
    5a2e:	cd b7       	in	r28, 0x3d	; 61
    5a30:	de b7       	in	r29, 0x3e	; 62
        /* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
         * started, then xTimerTaskHandle will be NULL. */
        configASSERT( ( xTimerTaskHandle != NULL ) );
        return xTimerTaskHandle;
    5a32:	80 91 06 07 	lds	r24, 0x0706
    5a36:	90 91 07 07 	lds	r25, 0x0707
    }
    5a3a:	cf 91       	pop	r28
    5a3c:	df 91       	pop	r29
    5a3e:	08 95       	ret

00005a40 <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
    {
    5a40:	df 93       	push	r29
    5a42:	cf 93       	push	r28
    5a44:	00 d0       	rcall	.+0      	; 0x5a46 <xTimerGetPeriod+0x6>
    5a46:	00 d0       	rcall	.+0      	; 0x5a48 <xTimerGetPeriod+0x8>
    5a48:	cd b7       	in	r28, 0x3d	; 61
    5a4a:	de b7       	in	r29, 0x3e	; 62
    5a4c:	9c 83       	std	Y+4, r25	; 0x04
    5a4e:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    5a50:	8b 81       	ldd	r24, Y+3	; 0x03
    5a52:	9c 81       	ldd	r25, Y+4	; 0x04
    5a54:	9a 83       	std	Y+2, r25	; 0x02
    5a56:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->xTimerPeriodInTicks;
    5a58:	e9 81       	ldd	r30, Y+1	; 0x01
    5a5a:	fa 81       	ldd	r31, Y+2	; 0x02
    5a5c:	84 85       	ldd	r24, Z+12	; 0x0c
    5a5e:	95 85       	ldd	r25, Z+13	; 0x0d
    }
    5a60:	0f 90       	pop	r0
    5a62:	0f 90       	pop	r0
    5a64:	0f 90       	pop	r0
    5a66:	0f 90       	pop	r0
    5a68:	cf 91       	pop	r28
    5a6a:	df 91       	pop	r29
    5a6c:	08 95       	ret

00005a6e <vTimerSetReloadMode>:
/*-----------------------------------------------------------*/

    void vTimerSetReloadMode( TimerHandle_t xTimer,
                              const UBaseType_t uxAutoReload )
    {
    5a6e:	df 93       	push	r29
    5a70:	cf 93       	push	r28
    5a72:	00 d0       	rcall	.+0      	; 0x5a74 <vTimerSetReloadMode+0x6>
    5a74:	00 d0       	rcall	.+0      	; 0x5a76 <vTimerSetReloadMode+0x8>
    5a76:	0f 92       	push	r0
    5a78:	cd b7       	in	r28, 0x3d	; 61
    5a7a:	de b7       	in	r29, 0x3e	; 62
    5a7c:	9c 83       	std	Y+4, r25	; 0x04
    5a7e:	8b 83       	std	Y+3, r24	; 0x03
    5a80:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * pxTimer = xTimer;
    5a82:	8b 81       	ldd	r24, Y+3	; 0x03
    5a84:	9c 81       	ldd	r25, Y+4	; 0x04
    5a86:	9a 83       	std	Y+2, r25	; 0x02
    5a88:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    5a8a:	0f b6       	in	r0, 0x3f	; 63
    5a8c:	f8 94       	cli
    5a8e:	0f 92       	push	r0
        {
            if( uxAutoReload != pdFALSE )
    5a90:	8d 81       	ldd	r24, Y+5	; 0x05
    5a92:	88 23       	and	r24, r24
    5a94:	41 f0       	breq	.+16     	; 0x5aa6 <vTimerSetReloadMode+0x38>
            {
                pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    5a96:	e9 81       	ldd	r30, Y+1	; 0x01
    5a98:	fa 81       	ldd	r31, Y+2	; 0x02
    5a9a:	82 89       	ldd	r24, Z+18	; 0x12
    5a9c:	84 60       	ori	r24, 0x04	; 4
    5a9e:	e9 81       	ldd	r30, Y+1	; 0x01
    5aa0:	fa 81       	ldd	r31, Y+2	; 0x02
    5aa2:	82 8b       	std	Z+18, r24	; 0x12
    5aa4:	07 c0       	rjmp	.+14     	; 0x5ab4 <vTimerSetReloadMode+0x46>
            }
            else
            {
                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_AUTORELOAD );
    5aa6:	e9 81       	ldd	r30, Y+1	; 0x01
    5aa8:	fa 81       	ldd	r31, Y+2	; 0x02
    5aaa:	82 89       	ldd	r24, Z+18	; 0x12
    5aac:	8b 7f       	andi	r24, 0xFB	; 251
    5aae:	e9 81       	ldd	r30, Y+1	; 0x01
    5ab0:	fa 81       	ldd	r31, Y+2	; 0x02
    5ab2:	82 8b       	std	Z+18, r24	; 0x12
            }
        }
        taskEXIT_CRITICAL();
    5ab4:	0f 90       	pop	r0
    5ab6:	0f be       	out	0x3f, r0	; 63
    }
    5ab8:	0f 90       	pop	r0
    5aba:	0f 90       	pop	r0
    5abc:	0f 90       	pop	r0
    5abe:	0f 90       	pop	r0
    5ac0:	0f 90       	pop	r0
    5ac2:	cf 91       	pop	r28
    5ac4:	df 91       	pop	r29
    5ac6:	08 95       	ret

00005ac8 <uxTimerGetReloadMode>:
/*-----------------------------------------------------------*/

    UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
    {
    5ac8:	df 93       	push	r29
    5aca:	cf 93       	push	r28
    5acc:	00 d0       	rcall	.+0      	; 0x5ace <uxTimerGetReloadMode+0x6>
    5ace:	00 d0       	rcall	.+0      	; 0x5ad0 <uxTimerGetReloadMode+0x8>
    5ad0:	0f 92       	push	r0
    5ad2:	cd b7       	in	r28, 0x3d	; 61
    5ad4:	de b7       	in	r29, 0x3e	; 62
    5ad6:	9d 83       	std	Y+5, r25	; 0x05
    5ad8:	8c 83       	std	Y+4, r24	; 0x04
        Timer_t * pxTimer = xTimer;
    5ada:	8c 81       	ldd	r24, Y+4	; 0x04
    5adc:	9d 81       	ldd	r25, Y+5	; 0x05
    5ade:	9b 83       	std	Y+3, r25	; 0x03
    5ae0:	8a 83       	std	Y+2, r24	; 0x02
        UBaseType_t uxReturn;

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    5ae2:	0f b6       	in	r0, 0x3f	; 63
    5ae4:	f8 94       	cli
    5ae6:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
    5ae8:	ea 81       	ldd	r30, Y+2	; 0x02
    5aea:	fb 81       	ldd	r31, Y+3	; 0x03
    5aec:	82 89       	ldd	r24, Z+18	; 0x12
    5aee:	88 2f       	mov	r24, r24
    5af0:	90 e0       	ldi	r25, 0x00	; 0
    5af2:	84 70       	andi	r24, 0x04	; 4
    5af4:	90 70       	andi	r25, 0x00	; 0
    5af6:	00 97       	sbiw	r24, 0x00	; 0
    5af8:	11 f4       	brne	.+4      	; 0x5afe <uxTimerGetReloadMode+0x36>
            {
                /* Not an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdFALSE;
    5afa:	19 82       	std	Y+1, r1	; 0x01
    5afc:	02 c0       	rjmp	.+4      	; 0x5b02 <uxTimerGetReloadMode+0x3a>
            }
            else
            {
                /* Is an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdTRUE;
    5afe:	81 e0       	ldi	r24, 0x01	; 1
    5b00:	89 83       	std	Y+1, r24	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    5b02:	0f 90       	pop	r0
    5b04:	0f be       	out	0x3f, r0	; 63

        return uxReturn;
    5b06:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5b08:	0f 90       	pop	r0
    5b0a:	0f 90       	pop	r0
    5b0c:	0f 90       	pop	r0
    5b0e:	0f 90       	pop	r0
    5b10:	0f 90       	pop	r0
    5b12:	cf 91       	pop	r28
    5b14:	df 91       	pop	r29
    5b16:	08 95       	ret

00005b18 <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
    {
    5b18:	df 93       	push	r29
    5b1a:	cf 93       	push	r28
    5b1c:	00 d0       	rcall	.+0      	; 0x5b1e <xTimerGetExpiryTime+0x6>
    5b1e:	00 d0       	rcall	.+0      	; 0x5b20 <xTimerGetExpiryTime+0x8>
    5b20:	00 d0       	rcall	.+0      	; 0x5b22 <xTimerGetExpiryTime+0xa>
    5b22:	cd b7       	in	r28, 0x3d	; 61
    5b24:	de b7       	in	r29, 0x3e	; 62
    5b26:	9e 83       	std	Y+6, r25	; 0x06
    5b28:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * pxTimer = xTimer;
    5b2a:	8d 81       	ldd	r24, Y+5	; 0x05
    5b2c:	9e 81       	ldd	r25, Y+6	; 0x06
    5b2e:	9c 83       	std	Y+4, r25	; 0x04
    5b30:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xReturn;

        configASSERT( xTimer );
        xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
    5b32:	eb 81       	ldd	r30, Y+3	; 0x03
    5b34:	fc 81       	ldd	r31, Y+4	; 0x04
    5b36:	82 81       	ldd	r24, Z+2	; 0x02
    5b38:	93 81       	ldd	r25, Z+3	; 0x03
    5b3a:	9a 83       	std	Y+2, r25	; 0x02
    5b3c:	89 83       	std	Y+1, r24	; 0x01
        return xReturn;
    5b3e:	89 81       	ldd	r24, Y+1	; 0x01
    5b40:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    5b42:	26 96       	adiw	r28, 0x06	; 6
    5b44:	0f b6       	in	r0, 0x3f	; 63
    5b46:	f8 94       	cli
    5b48:	de bf       	out	0x3e, r29	; 62
    5b4a:	0f be       	out	0x3f, r0	; 63
    5b4c:	cd bf       	out	0x3d, r28	; 61
    5b4e:	cf 91       	pop	r28
    5b50:	df 91       	pop	r29
    5b52:	08 95       	ret

00005b54 <pcTimerGetName>:
/*-----------------------------------------------------------*/

    const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
    5b54:	df 93       	push	r29
    5b56:	cf 93       	push	r28
    5b58:	00 d0       	rcall	.+0      	; 0x5b5a <pcTimerGetName+0x6>
    5b5a:	00 d0       	rcall	.+0      	; 0x5b5c <pcTimerGetName+0x8>
    5b5c:	cd b7       	in	r28, 0x3d	; 61
    5b5e:	de b7       	in	r29, 0x3e	; 62
    5b60:	9c 83       	std	Y+4, r25	; 0x04
    5b62:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    5b64:	8b 81       	ldd	r24, Y+3	; 0x03
    5b66:	9c 81       	ldd	r25, Y+4	; 0x04
    5b68:	9a 83       	std	Y+2, r25	; 0x02
    5b6a:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->pcTimerName;
    5b6c:	e9 81       	ldd	r30, Y+1	; 0x01
    5b6e:	fa 81       	ldd	r31, Y+2	; 0x02
    5b70:	80 81       	ld	r24, Z
    5b72:	91 81       	ldd	r25, Z+1	; 0x01
    }
    5b74:	0f 90       	pop	r0
    5b76:	0f 90       	pop	r0
    5b78:	0f 90       	pop	r0
    5b7a:	0f 90       	pop	r0
    5b7c:	cf 91       	pop	r28
    5b7e:	df 91       	pop	r29
    5b80:	08 95       	ret

00005b82 <prvReloadTimer>:
/*-----------------------------------------------------------*/

    static void prvReloadTimer( Timer_t * const pxTimer,
                                TickType_t xExpiredTime,
                                const TickType_t xTimeNow )
    {
    5b82:	df 93       	push	r29
    5b84:	cf 93       	push	r28
    5b86:	00 d0       	rcall	.+0      	; 0x5b88 <prvReloadTimer+0x6>
    5b88:	00 d0       	rcall	.+0      	; 0x5b8a <prvReloadTimer+0x8>
    5b8a:	00 d0       	rcall	.+0      	; 0x5b8c <prvReloadTimer+0xa>
    5b8c:	cd b7       	in	r28, 0x3d	; 61
    5b8e:	de b7       	in	r29, 0x3e	; 62
    5b90:	9a 83       	std	Y+2, r25	; 0x02
    5b92:	89 83       	std	Y+1, r24	; 0x01
    5b94:	7c 83       	std	Y+4, r23	; 0x04
    5b96:	6b 83       	std	Y+3, r22	; 0x03
    5b98:	5e 83       	std	Y+6, r21	; 0x06
    5b9a:	4d 83       	std	Y+5, r20	; 0x05
    5b9c:	12 c0       	rjmp	.+36     	; 0x5bc2 <prvReloadTimer+0x40>
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
        {
            /* Advance the expiry time. */
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
    5b9e:	e9 81       	ldd	r30, Y+1	; 0x01
    5ba0:	fa 81       	ldd	r31, Y+2	; 0x02
    5ba2:	24 85       	ldd	r18, Z+12	; 0x0c
    5ba4:	35 85       	ldd	r19, Z+13	; 0x0d
    5ba6:	8b 81       	ldd	r24, Y+3	; 0x03
    5ba8:	9c 81       	ldd	r25, Y+4	; 0x04
    5baa:	82 0f       	add	r24, r18
    5bac:	93 1f       	adc	r25, r19
    5bae:	9c 83       	std	Y+4, r25	; 0x04
    5bb0:	8b 83       	std	Y+3, r24	; 0x03

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    5bb2:	e9 81       	ldd	r30, Y+1	; 0x01
    5bb4:	fa 81       	ldd	r31, Y+2	; 0x02
    5bb6:	00 88       	ldd	r0, Z+16	; 0x10
    5bb8:	f1 89       	ldd	r31, Z+17	; 0x11
    5bba:	e0 2d       	mov	r30, r0
    5bbc:	89 81       	ldd	r24, Y+1	; 0x01
    5bbe:	9a 81       	ldd	r25, Y+2	; 0x02
    5bc0:	09 95       	icall
                                const TickType_t xTimeNow )
    {
        /* Insert the timer into the appropriate list for the next expiry time.
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
    5bc2:	e9 81       	ldd	r30, Y+1	; 0x01
    5bc4:	fa 81       	ldd	r31, Y+2	; 0x02
    5bc6:	24 85       	ldd	r18, Z+12	; 0x0c
    5bc8:	35 85       	ldd	r19, Z+13	; 0x0d
    5bca:	8b 81       	ldd	r24, Y+3	; 0x03
    5bcc:	9c 81       	ldd	r25, Y+4	; 0x04
    5bce:	a9 01       	movw	r20, r18
    5bd0:	48 0f       	add	r20, r24
    5bd2:	59 1f       	adc	r21, r25
    5bd4:	89 81       	ldd	r24, Y+1	; 0x01
    5bd6:	9a 81       	ldd	r25, Y+2	; 0x02
    5bd8:	2d 81       	ldd	r18, Y+5	; 0x05
    5bda:	3e 81       	ldd	r19, Y+6	; 0x06
    5bdc:	eb 81       	ldd	r30, Y+3	; 0x03
    5bde:	fc 81       	ldd	r31, Y+4	; 0x04
    5be0:	ba 01       	movw	r22, r20
    5be2:	a9 01       	movw	r20, r18
    5be4:	9f 01       	movw	r18, r30
    5be6:	0e 94 17 2f 	call	0x5e2e	; 0x5e2e <prvInsertTimerInActiveList>
    5bea:	88 23       	and	r24, r24
    5bec:	c1 f6       	brne	.-80     	; 0x5b9e <prvReloadTimer+0x1c>

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
        }
    }
    5bee:	26 96       	adiw	r28, 0x06	; 6
    5bf0:	0f b6       	in	r0, 0x3f	; 63
    5bf2:	f8 94       	cli
    5bf4:	de bf       	out	0x3e, r29	; 62
    5bf6:	0f be       	out	0x3f, r0	; 63
    5bf8:	cd bf       	out	0x3d, r28	; 61
    5bfa:	cf 91       	pop	r28
    5bfc:	df 91       	pop	r29
    5bfe:	08 95       	ret

00005c00 <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
    5c00:	df 93       	push	r29
    5c02:	cf 93       	push	r28
    5c04:	00 d0       	rcall	.+0      	; 0x5c06 <prvProcessExpiredTimer+0x6>
    5c06:	00 d0       	rcall	.+0      	; 0x5c08 <prvProcessExpiredTimer+0x8>
    5c08:	00 d0       	rcall	.+0      	; 0x5c0a <prvProcessExpiredTimer+0xa>
    5c0a:	cd b7       	in	r28, 0x3d	; 61
    5c0c:	de b7       	in	r29, 0x3e	; 62
    5c0e:	9c 83       	std	Y+4, r25	; 0x04
    5c10:	8b 83       	std	Y+3, r24	; 0x03
    5c12:	7e 83       	std	Y+6, r23	; 0x06
    5c14:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5c16:	e0 91 1c 07 	lds	r30, 0x071C
    5c1a:	f0 91 1d 07 	lds	r31, 0x071D
    5c1e:	05 80       	ldd	r0, Z+5	; 0x05
    5c20:	f6 81       	ldd	r31, Z+6	; 0x06
    5c22:	e0 2d       	mov	r30, r0
    5c24:	86 81       	ldd	r24, Z+6	; 0x06
    5c26:	97 81       	ldd	r25, Z+7	; 0x07
    5c28:	9a 83       	std	Y+2, r25	; 0x02
    5c2a:	89 83       	std	Y+1, r24	; 0x01

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    5c2c:	89 81       	ldd	r24, Y+1	; 0x01
    5c2e:	9a 81       	ldd	r25, Y+2	; 0x02
    5c30:	02 96       	adiw	r24, 0x02	; 2
    5c32:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <uxListRemove>

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    5c36:	e9 81       	ldd	r30, Y+1	; 0x01
    5c38:	fa 81       	ldd	r31, Y+2	; 0x02
    5c3a:	82 89       	ldd	r24, Z+18	; 0x12
    5c3c:	88 2f       	mov	r24, r24
    5c3e:	90 e0       	ldi	r25, 0x00	; 0
    5c40:	84 70       	andi	r24, 0x04	; 4
    5c42:	90 70       	andi	r25, 0x00	; 0
    5c44:	00 97       	sbiw	r24, 0x00	; 0
    5c46:	51 f0       	breq	.+20     	; 0x5c5c <prvProcessExpiredTimer+0x5c>
        {
            prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
    5c48:	89 81       	ldd	r24, Y+1	; 0x01
    5c4a:	9a 81       	ldd	r25, Y+2	; 0x02
    5c4c:	2b 81       	ldd	r18, Y+3	; 0x03
    5c4e:	3c 81       	ldd	r19, Y+4	; 0x04
    5c50:	4d 81       	ldd	r20, Y+5	; 0x05
    5c52:	5e 81       	ldd	r21, Y+6	; 0x06
    5c54:	b9 01       	movw	r22, r18
    5c56:	0e 94 c1 2d 	call	0x5b82	; 0x5b82 <prvReloadTimer>
    5c5a:	07 c0       	rjmp	.+14     	; 0x5c6a <prvProcessExpiredTimer+0x6a>
        }
        else
        {
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    5c5c:	e9 81       	ldd	r30, Y+1	; 0x01
    5c5e:	fa 81       	ldd	r31, Y+2	; 0x02
    5c60:	82 89       	ldd	r24, Z+18	; 0x12
    5c62:	8e 7f       	andi	r24, 0xFE	; 254
    5c64:	e9 81       	ldd	r30, Y+1	; 0x01
    5c66:	fa 81       	ldd	r31, Y+2	; 0x02
    5c68:	82 8b       	std	Z+18, r24	; 0x12
        }

        /* Call the timer callback. */
        traceTIMER_EXPIRED( pxTimer );
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    5c6a:	e9 81       	ldd	r30, Y+1	; 0x01
    5c6c:	fa 81       	ldd	r31, Y+2	; 0x02
    5c6e:	00 88       	ldd	r0, Z+16	; 0x10
    5c70:	f1 89       	ldd	r31, Z+17	; 0x11
    5c72:	e0 2d       	mov	r30, r0
    5c74:	89 81       	ldd	r24, Y+1	; 0x01
    5c76:	9a 81       	ldd	r25, Y+2	; 0x02
    5c78:	09 95       	icall
    }
    5c7a:	26 96       	adiw	r28, 0x06	; 6
    5c7c:	0f b6       	in	r0, 0x3f	; 63
    5c7e:	f8 94       	cli
    5c80:	de bf       	out	0x3e, r29	; 62
    5c82:	0f be       	out	0x3f, r0	; 63
    5c84:	cd bf       	out	0x3d, r28	; 61
    5c86:	cf 91       	pop	r28
    5c88:	df 91       	pop	r29
    5c8a:	08 95       	ret

00005c8c <prvTimerTask>:
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
    5c8c:	df 93       	push	r29
    5c8e:	cf 93       	push	r28
    5c90:	00 d0       	rcall	.+0      	; 0x5c92 <prvTimerTask+0x6>
    5c92:	00 d0       	rcall	.+0      	; 0x5c94 <prvTimerTask+0x8>
    5c94:	0f 92       	push	r0
    5c96:	cd b7       	in	r28, 0x3d	; 61
    5c98:	de b7       	in	r29, 0x3e	; 62
    5c9a:	9d 83       	std	Y+5, r25	; 0x05
    5c9c:	8c 83       	std	Y+4, r24	; 0x04

        for( ; ; )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    5c9e:	ce 01       	movw	r24, r28
    5ca0:	03 96       	adiw	r24, 0x03	; 3
    5ca2:	0e 94 b5 2e 	call	0x5d6a	; 0x5d6a <prvGetNextExpireTime>
    5ca6:	9a 83       	std	Y+2, r25	; 0x02
    5ca8:	89 83       	std	Y+1, r24	; 0x01

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    5caa:	2b 81       	ldd	r18, Y+3	; 0x03
    5cac:	89 81       	ldd	r24, Y+1	; 0x01
    5cae:	9a 81       	ldd	r25, Y+2	; 0x02
    5cb0:	62 2f       	mov	r22, r18
    5cb2:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
    5cb6:	0e 94 7f 2f 	call	0x5efe	; 0x5efe <prvProcessReceivedCommands>
    5cba:	f1 cf       	rjmp	.-30     	; 0x5c9e <prvTimerTask+0x12>

00005cbc <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
    5cbc:	df 93       	push	r29
    5cbe:	cf 93       	push	r28
    5cc0:	00 d0       	rcall	.+0      	; 0x5cc2 <prvProcessTimerOrBlockTask+0x6>
    5cc2:	00 d0       	rcall	.+0      	; 0x5cc4 <prvProcessTimerOrBlockTask+0x8>
    5cc4:	00 d0       	rcall	.+0      	; 0x5cc6 <prvProcessTimerOrBlockTask+0xa>
    5cc6:	cd b7       	in	r28, 0x3d	; 61
    5cc8:	de b7       	in	r29, 0x3e	; 62
    5cca:	9d 83       	std	Y+5, r25	; 0x05
    5ccc:	8c 83       	std	Y+4, r24	; 0x04
    5cce:	6e 83       	std	Y+6, r22	; 0x06
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
    5cd0:	0e 94 56 1b 	call	0x36ac	; 0x36ac <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    5cd4:	ce 01       	movw	r24, r28
    5cd6:	03 96       	adiw	r24, 0x03	; 3
    5cd8:	0e 94 e9 2e 	call	0x5dd2	; 0x5dd2 <prvSampleTimeNow>
    5cdc:	9a 83       	std	Y+2, r25	; 0x02
    5cde:	89 83       	std	Y+1, r24	; 0x01

            if( xTimerListsWereSwitched == pdFALSE )
    5ce0:	8b 81       	ldd	r24, Y+3	; 0x03
    5ce2:	88 23       	and	r24, r24
    5ce4:	b9 f5       	brne	.+110    	; 0x5d54 <prvProcessTimerOrBlockTask+0x98>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    5ce6:	8e 81       	ldd	r24, Y+6	; 0x06
    5ce8:	88 23       	and	r24, r24
    5cea:	89 f4       	brne	.+34     	; 0x5d0e <prvProcessTimerOrBlockTask+0x52>
    5cec:	2c 81       	ldd	r18, Y+4	; 0x04
    5cee:	3d 81       	ldd	r19, Y+5	; 0x05
    5cf0:	89 81       	ldd	r24, Y+1	; 0x01
    5cf2:	9a 81       	ldd	r25, Y+2	; 0x02
    5cf4:	82 17       	cp	r24, r18
    5cf6:	93 07       	cpc	r25, r19
    5cf8:	50 f0       	brcs	.+20     	; 0x5d0e <prvProcessTimerOrBlockTask+0x52>
                {
                    ( void ) xTaskResumeAll();
    5cfa:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    5cfe:	8c 81       	ldd	r24, Y+4	; 0x04
    5d00:	9d 81       	ldd	r25, Y+5	; 0x05
    5d02:	29 81       	ldd	r18, Y+1	; 0x01
    5d04:	3a 81       	ldd	r19, Y+2	; 0x02
    5d06:	b9 01       	movw	r22, r18
    5d08:	0e 94 00 2e 	call	0x5c00	; 0x5c00 <prvProcessExpiredTimer>
    5d0c:	25 c0       	rjmp	.+74     	; 0x5d58 <prvProcessTimerOrBlockTask+0x9c>
                     * time has not been reached yet.  This task should therefore
                     * block to wait for the next expire time or a command to be
                     * received - whichever comes first.  The following line cannot
                     * be reached unless xNextExpireTime > xTimeNow, except in the
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
    5d0e:	8e 81       	ldd	r24, Y+6	; 0x06
    5d10:	88 23       	and	r24, r24
    5d12:	51 f0       	breq	.+20     	; 0x5d28 <prvProcessTimerOrBlockTask+0x6c>
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    5d14:	e0 91 1e 07 	lds	r30, 0x071E
    5d18:	f0 91 1f 07 	lds	r31, 0x071F
    5d1c:	80 81       	ld	r24, Z
    5d1e:	1e 82       	std	Y+6, r1	; 0x06
    5d20:	88 23       	and	r24, r24
    5d22:	11 f4       	brne	.+4      	; 0x5d28 <prvProcessTimerOrBlockTask+0x6c>
    5d24:	81 e0       	ldi	r24, 0x01	; 1
    5d26:	8e 83       	std	Y+6, r24	; 0x06
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    5d28:	40 91 04 07 	lds	r20, 0x0704
    5d2c:	50 91 05 07 	lds	r21, 0x0705
    5d30:	2c 81       	ldd	r18, Y+4	; 0x04
    5d32:	3d 81       	ldd	r19, Y+5	; 0x05
    5d34:	89 81       	ldd	r24, Y+1	; 0x01
    5d36:	9a 81       	ldd	r25, Y+2	; 0x02
    5d38:	28 1b       	sub	r18, r24
    5d3a:	39 0b       	sbc	r19, r25
    5d3c:	ca 01       	movw	r24, r20
    5d3e:	b9 01       	movw	r22, r18
    5d40:	4e 81       	ldd	r20, Y+6	; 0x06
    5d42:	0e 94 c2 17 	call	0x2f84	; 0x2f84 <vQueueWaitForMessageRestricted>

                    if( xTaskResumeAll() == pdFALSE )
    5d46:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>
    5d4a:	88 23       	and	r24, r24
    5d4c:	29 f4       	brne	.+10     	; 0x5d58 <prvProcessTimerOrBlockTask+0x9c>
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
    5d4e:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    5d52:	02 c0       	rjmp	.+4      	; 0x5d58 <prvProcessTimerOrBlockTask+0x9c>
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
    5d54:	0e 94 62 1b 	call	0x36c4	; 0x36c4 <xTaskResumeAll>
            }
        }
    }
    5d58:	26 96       	adiw	r28, 0x06	; 6
    5d5a:	0f b6       	in	r0, 0x3f	; 63
    5d5c:	f8 94       	cli
    5d5e:	de bf       	out	0x3e, r29	; 62
    5d60:	0f be       	out	0x3f, r0	; 63
    5d62:	cd bf       	out	0x3d, r28	; 61
    5d64:	cf 91       	pop	r28
    5d66:	df 91       	pop	r29
    5d68:	08 95       	ret

00005d6a <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
    5d6a:	df 93       	push	r29
    5d6c:	cf 93       	push	r28
    5d6e:	00 d0       	rcall	.+0      	; 0x5d70 <prvGetNextExpireTime+0x6>
    5d70:	00 d0       	rcall	.+0      	; 0x5d72 <prvGetNextExpireTime+0x8>
    5d72:	0f 92       	push	r0
    5d74:	cd b7       	in	r28, 0x3d	; 61
    5d76:	de b7       	in	r29, 0x3e	; 62
    5d78:	9c 83       	std	Y+4, r25	; 0x04
    5d7a:	8b 83       	std	Y+3, r24	; 0x03
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    5d7c:	e0 91 1c 07 	lds	r30, 0x071C
    5d80:	f0 91 1d 07 	lds	r31, 0x071D
    5d84:	80 81       	ld	r24, Z
    5d86:	1d 82       	std	Y+5, r1	; 0x05
    5d88:	88 23       	and	r24, r24
    5d8a:	11 f4       	brne	.+4      	; 0x5d90 <prvGetNextExpireTime+0x26>
    5d8c:	81 e0       	ldi	r24, 0x01	; 1
    5d8e:	8d 83       	std	Y+5, r24	; 0x05
    5d90:	eb 81       	ldd	r30, Y+3	; 0x03
    5d92:	fc 81       	ldd	r31, Y+4	; 0x04
    5d94:	8d 81       	ldd	r24, Y+5	; 0x05
    5d96:	80 83       	st	Z, r24

        if( *pxListWasEmpty == pdFALSE )
    5d98:	eb 81       	ldd	r30, Y+3	; 0x03
    5d9a:	fc 81       	ldd	r31, Y+4	; 0x04
    5d9c:	80 81       	ld	r24, Z
    5d9e:	88 23       	and	r24, r24
    5da0:	61 f4       	brne	.+24     	; 0x5dba <prvGetNextExpireTime+0x50>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    5da2:	e0 91 1c 07 	lds	r30, 0x071C
    5da6:	f0 91 1d 07 	lds	r31, 0x071D
    5daa:	05 80       	ldd	r0, Z+5	; 0x05
    5dac:	f6 81       	ldd	r31, Z+6	; 0x06
    5dae:	e0 2d       	mov	r30, r0
    5db0:	80 81       	ld	r24, Z
    5db2:	91 81       	ldd	r25, Z+1	; 0x01
    5db4:	9a 83       	std	Y+2, r25	; 0x02
    5db6:	89 83       	std	Y+1, r24	; 0x01
    5db8:	02 c0       	rjmp	.+4      	; 0x5dbe <prvGetNextExpireTime+0x54>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
    5dba:	1a 82       	std	Y+2, r1	; 0x02
    5dbc:	19 82       	std	Y+1, r1	; 0x01
        }

        return xNextExpireTime;
    5dbe:	89 81       	ldd	r24, Y+1	; 0x01
    5dc0:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    5dc2:	0f 90       	pop	r0
    5dc4:	0f 90       	pop	r0
    5dc6:	0f 90       	pop	r0
    5dc8:	0f 90       	pop	r0
    5dca:	0f 90       	pop	r0
    5dcc:	cf 91       	pop	r28
    5dce:	df 91       	pop	r29
    5dd0:	08 95       	ret

00005dd2 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
    5dd2:	df 93       	push	r29
    5dd4:	cf 93       	push	r28
    5dd6:	00 d0       	rcall	.+0      	; 0x5dd8 <prvSampleTimeNow+0x6>
    5dd8:	00 d0       	rcall	.+0      	; 0x5dda <prvSampleTimeNow+0x8>
    5dda:	cd b7       	in	r28, 0x3d	; 61
    5ddc:	de b7       	in	r29, 0x3e	; 62
    5dde:	9c 83       	std	Y+4, r25	; 0x04
    5de0:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
    5de2:	0e 94 b2 1c 	call	0x3964	; 0x3964 <xTaskGetTickCount>
    5de6:	9a 83       	std	Y+2, r25	; 0x02
    5de8:	89 83       	std	Y+1, r24	; 0x01

        if( xTimeNow < xLastTime )
    5dea:	20 91 08 07 	lds	r18, 0x0708
    5dee:	30 91 09 07 	lds	r19, 0x0709
    5df2:	89 81       	ldd	r24, Y+1	; 0x01
    5df4:	9a 81       	ldd	r25, Y+2	; 0x02
    5df6:	82 17       	cp	r24, r18
    5df8:	93 07       	cpc	r25, r19
    5dfa:	38 f4       	brcc	.+14     	; 0x5e0a <prvSampleTimeNow+0x38>
        {
            prvSwitchTimerLists();
    5dfc:	0e 94 7a 30 	call	0x60f4	; 0x60f4 <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
    5e00:	eb 81       	ldd	r30, Y+3	; 0x03
    5e02:	fc 81       	ldd	r31, Y+4	; 0x04
    5e04:	81 e0       	ldi	r24, 0x01	; 1
    5e06:	80 83       	st	Z, r24
    5e08:	03 c0       	rjmp	.+6      	; 0x5e10 <prvSampleTimeNow+0x3e>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
    5e0a:	eb 81       	ldd	r30, Y+3	; 0x03
    5e0c:	fc 81       	ldd	r31, Y+4	; 0x04
    5e0e:	10 82       	st	Z, r1
        }

        xLastTime = xTimeNow;
    5e10:	89 81       	ldd	r24, Y+1	; 0x01
    5e12:	9a 81       	ldd	r25, Y+2	; 0x02
    5e14:	90 93 09 07 	sts	0x0709, r25
    5e18:	80 93 08 07 	sts	0x0708, r24

        return xTimeNow;
    5e1c:	89 81       	ldd	r24, Y+1	; 0x01
    5e1e:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    5e20:	0f 90       	pop	r0
    5e22:	0f 90       	pop	r0
    5e24:	0f 90       	pop	r0
    5e26:	0f 90       	pop	r0
    5e28:	cf 91       	pop	r28
    5e2a:	df 91       	pop	r29
    5e2c:	08 95       	ret

00005e2e <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
    5e2e:	df 93       	push	r29
    5e30:	cf 93       	push	r28
    5e32:	cd b7       	in	r28, 0x3d	; 61
    5e34:	de b7       	in	r29, 0x3e	; 62
    5e36:	29 97       	sbiw	r28, 0x09	; 9
    5e38:	0f b6       	in	r0, 0x3f	; 63
    5e3a:	f8 94       	cli
    5e3c:	de bf       	out	0x3e, r29	; 62
    5e3e:	0f be       	out	0x3f, r0	; 63
    5e40:	cd bf       	out	0x3d, r28	; 61
    5e42:	9b 83       	std	Y+3, r25	; 0x03
    5e44:	8a 83       	std	Y+2, r24	; 0x02
    5e46:	7d 83       	std	Y+5, r23	; 0x05
    5e48:	6c 83       	std	Y+4, r22	; 0x04
    5e4a:	5f 83       	std	Y+7, r21	; 0x07
    5e4c:	4e 83       	std	Y+6, r20	; 0x06
    5e4e:	39 87       	std	Y+9, r19	; 0x09
    5e50:	28 87       	std	Y+8, r18	; 0x08
        BaseType_t xProcessTimerNow = pdFALSE;
    5e52:	19 82       	std	Y+1, r1	; 0x01

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    5e54:	ea 81       	ldd	r30, Y+2	; 0x02
    5e56:	fb 81       	ldd	r31, Y+3	; 0x03
    5e58:	8c 81       	ldd	r24, Y+4	; 0x04
    5e5a:	9d 81       	ldd	r25, Y+5	; 0x05
    5e5c:	93 83       	std	Z+3, r25	; 0x03
    5e5e:	82 83       	std	Z+2, r24	; 0x02
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    5e60:	ea 81       	ldd	r30, Y+2	; 0x02
    5e62:	fb 81       	ldd	r31, Y+3	; 0x03
    5e64:	8a 81       	ldd	r24, Y+2	; 0x02
    5e66:	9b 81       	ldd	r25, Y+3	; 0x03
    5e68:	91 87       	std	Z+9, r25	; 0x09
    5e6a:	80 87       	std	Z+8, r24	; 0x08

        if( xNextExpiryTime <= xTimeNow )
    5e6c:	2c 81       	ldd	r18, Y+4	; 0x04
    5e6e:	3d 81       	ldd	r19, Y+5	; 0x05
    5e70:	8e 81       	ldd	r24, Y+6	; 0x06
    5e72:	9f 81       	ldd	r25, Y+7	; 0x07
    5e74:	82 17       	cp	r24, r18
    5e76:	93 07       	cpc	r25, r19
    5e78:	e0 f0       	brcs	.+56     	; 0x5eb2 <prvInsertTimerInActiveList+0x84>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5e7a:	2e 81       	ldd	r18, Y+6	; 0x06
    5e7c:	3f 81       	ldd	r19, Y+7	; 0x07
    5e7e:	88 85       	ldd	r24, Y+8	; 0x08
    5e80:	99 85       	ldd	r25, Y+9	; 0x09
    5e82:	28 1b       	sub	r18, r24
    5e84:	39 0b       	sbc	r19, r25
    5e86:	ea 81       	ldd	r30, Y+2	; 0x02
    5e88:	fb 81       	ldd	r31, Y+3	; 0x03
    5e8a:	84 85       	ldd	r24, Z+12	; 0x0c
    5e8c:	95 85       	ldd	r25, Z+13	; 0x0d
    5e8e:	28 17       	cp	r18, r24
    5e90:	39 07       	cpc	r19, r25
    5e92:	18 f0       	brcs	.+6      	; 0x5e9a <prvInsertTimerInActiveList+0x6c>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
    5e94:	81 e0       	ldi	r24, 0x01	; 1
    5e96:	89 83       	std	Y+1, r24	; 0x01
    5e98:	28 c0       	rjmp	.+80     	; 0x5eea <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    5e9a:	80 91 1e 07 	lds	r24, 0x071E
    5e9e:	90 91 1f 07 	lds	r25, 0x071F
    5ea2:	2a 81       	ldd	r18, Y+2	; 0x02
    5ea4:	3b 81       	ldd	r19, Y+3	; 0x03
    5ea6:	2e 5f       	subi	r18, 0xFE	; 254
    5ea8:	3f 4f       	sbci	r19, 0xFF	; 255
    5eaa:	b9 01       	movw	r22, r18
    5eac:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <vListInsert>
    5eb0:	1c c0       	rjmp	.+56     	; 0x5eea <prvInsertTimerInActiveList+0xbc>
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    5eb2:	2e 81       	ldd	r18, Y+6	; 0x06
    5eb4:	3f 81       	ldd	r19, Y+7	; 0x07
    5eb6:	88 85       	ldd	r24, Y+8	; 0x08
    5eb8:	99 85       	ldd	r25, Y+9	; 0x09
    5eba:	28 17       	cp	r18, r24
    5ebc:	39 07       	cpc	r19, r25
    5ebe:	50 f4       	brcc	.+20     	; 0x5ed4 <prvInsertTimerInActiveList+0xa6>
    5ec0:	2c 81       	ldd	r18, Y+4	; 0x04
    5ec2:	3d 81       	ldd	r19, Y+5	; 0x05
    5ec4:	88 85       	ldd	r24, Y+8	; 0x08
    5ec6:	99 85       	ldd	r25, Y+9	; 0x09
    5ec8:	28 17       	cp	r18, r24
    5eca:	39 07       	cpc	r19, r25
    5ecc:	18 f0       	brcs	.+6      	; 0x5ed4 <prvInsertTimerInActiveList+0xa6>
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
    5ece:	81 e0       	ldi	r24, 0x01	; 1
    5ed0:	89 83       	std	Y+1, r24	; 0x01
    5ed2:	0b c0       	rjmp	.+22     	; 0x5eea <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    5ed4:	80 91 1c 07 	lds	r24, 0x071C
    5ed8:	90 91 1d 07 	lds	r25, 0x071D
    5edc:	2a 81       	ldd	r18, Y+2	; 0x02
    5ede:	3b 81       	ldd	r19, Y+3	; 0x03
    5ee0:	2e 5f       	subi	r18, 0xFE	; 254
    5ee2:	3f 4f       	sbci	r19, 0xFF	; 255
    5ee4:	b9 01       	movw	r22, r18
    5ee6:	0e 94 f7 0d 	call	0x1bee	; 0x1bee <vListInsert>
            }
        }

        return xProcessTimerNow;
    5eea:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5eec:	29 96       	adiw	r28, 0x09	; 9
    5eee:	0f b6       	in	r0, 0x3f	; 63
    5ef0:	f8 94       	cli
    5ef2:	de bf       	out	0x3e, r29	; 62
    5ef4:	0f be       	out	0x3f, r0	; 63
    5ef6:	cd bf       	out	0x3d, r28	; 61
    5ef8:	cf 91       	pop	r28
    5efa:	df 91       	pop	r29
    5efc:	08 95       	ret

00005efe <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
    5efe:	df 93       	push	r29
    5f00:	cf 93       	push	r28
    5f02:	cd b7       	in	r28, 0x3d	; 61
    5f04:	de b7       	in	r29, 0x3e	; 62
    5f06:	2c 97       	sbiw	r28, 0x0c	; 12
    5f08:	0f b6       	in	r0, 0x3f	; 63
    5f0a:	f8 94       	cli
    5f0c:	de bf       	out	0x3e, r29	; 62
    5f0e:	0f be       	out	0x3f, r0	; 63
    5f10:	cd bf       	out	0x3d, r28	; 61
    5f12:	d8 c0       	rjmp	.+432    	; 0x60c4 <prvProcessReceivedCommands+0x1c6>
                }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    5f14:	8d 81       	ldd	r24, Y+5	; 0x05
    5f16:	88 23       	and	r24, r24
    5f18:	0c f4       	brge	.+2      	; 0x5f1c <prvProcessReceivedCommands+0x1e>
    5f1a:	d4 c0       	rjmp	.+424    	; 0x60c4 <prvProcessReceivedCommands+0x1c6>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
    5f1c:	88 85       	ldd	r24, Y+8	; 0x08
    5f1e:	99 85       	ldd	r25, Y+9	; 0x09
    5f20:	9c 83       	std	Y+4, r25	; 0x04
    5f22:	8b 83       	std	Y+3, r24	; 0x03

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    5f24:	eb 81       	ldd	r30, Y+3	; 0x03
    5f26:	fc 81       	ldd	r31, Y+4	; 0x04
    5f28:	82 85       	ldd	r24, Z+10	; 0x0a
    5f2a:	93 85       	ldd	r25, Z+11	; 0x0b
    5f2c:	00 97       	sbiw	r24, 0x00	; 0
    5f2e:	29 f0       	breq	.+10     	; 0x5f3a <prvProcessReceivedCommands+0x3c>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    5f30:	8b 81       	ldd	r24, Y+3	; 0x03
    5f32:	9c 81       	ldd	r25, Y+4	; 0x04
    5f34:	02 96       	adiw	r24, 0x02	; 2
    5f36:	0e 94 63 0e 	call	0x1cc6	; 0x1cc6 <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    5f3a:	ce 01       	movw	r24, r28
    5f3c:	0a 96       	adiw	r24, 0x0a	; 10
    5f3e:	0e 94 e9 2e 	call	0x5dd2	; 0x5dd2 <prvSampleTimeNow>
    5f42:	9a 83       	std	Y+2, r25	; 0x02
    5f44:	89 83       	std	Y+1, r24	; 0x01

                switch( xMessage.xMessageID )
    5f46:	8d 81       	ldd	r24, Y+5	; 0x05
    5f48:	28 2f       	mov	r18, r24
    5f4a:	33 27       	eor	r19, r19
    5f4c:	27 fd       	sbrc	r18, 7
    5f4e:	30 95       	com	r19
    5f50:	3c 87       	std	Y+12, r19	; 0x0c
    5f52:	2b 87       	std	Y+11, r18	; 0x0b
    5f54:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f56:	9c 85       	ldd	r25, Y+12	; 0x0c
    5f58:	85 30       	cpi	r24, 0x05	; 5
    5f5a:	91 05       	cpc	r25, r1
    5f5c:	09 f4       	brne	.+2      	; 0x5f60 <prvProcessReceivedCommands+0x62>
    5f5e:	9d c0       	rjmp	.+314    	; 0x609a <prvProcessReceivedCommands+0x19c>
    5f60:	2b 85       	ldd	r18, Y+11	; 0x0b
    5f62:	3c 85       	ldd	r19, Y+12	; 0x0c
    5f64:	26 30       	cpi	r18, 0x06	; 6
    5f66:	31 05       	cpc	r19, r1
    5f68:	9c f4       	brge	.+38     	; 0x5f90 <prvProcessReceivedCommands+0x92>
    5f6a:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f6c:	9c 85       	ldd	r25, Y+12	; 0x0c
    5f6e:	83 30       	cpi	r24, 0x03	; 3
    5f70:	91 05       	cpc	r25, r1
    5f72:	09 f4       	brne	.+2      	; 0x5f76 <prvProcessReceivedCommands+0x78>
    5f74:	68 c0       	rjmp	.+208    	; 0x6046 <prvProcessReceivedCommands+0x148>
    5f76:	2b 85       	ldd	r18, Y+11	; 0x0b
    5f78:	3c 85       	ldd	r19, Y+12	; 0x0c
    5f7a:	24 30       	cpi	r18, 0x04	; 4
    5f7c:	31 05       	cpc	r19, r1
    5f7e:	0c f0       	brlt	.+2      	; 0x5f82 <prvProcessReceivedCommands+0x84>
    5f80:	6a c0       	rjmp	.+212    	; 0x6056 <prvProcessReceivedCommands+0x158>
    5f82:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f84:	9c 85       	ldd	r25, Y+12	; 0x0c
    5f86:	81 30       	cpi	r24, 0x01	; 1
    5f88:	91 05       	cpc	r25, r1
    5f8a:	0c f4       	brge	.+2      	; 0x5f8e <prvProcessReceivedCommands+0x90>
    5f8c:	9b c0       	rjmp	.+310    	; 0x60c4 <prvProcessReceivedCommands+0x1c6>
    5f8e:	12 c0       	rjmp	.+36     	; 0x5fb4 <prvProcessReceivedCommands+0xb6>
    5f90:	2b 85       	ldd	r18, Y+11	; 0x0b
    5f92:	3c 85       	ldd	r19, Y+12	; 0x0c
    5f94:	28 30       	cpi	r18, 0x08	; 8
    5f96:	31 05       	cpc	r19, r1
    5f98:	09 f4       	brne	.+2      	; 0x5f9c <prvProcessReceivedCommands+0x9e>
    5f9a:	55 c0       	rjmp	.+170    	; 0x6046 <prvProcessReceivedCommands+0x148>
    5f9c:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f9e:	9c 85       	ldd	r25, Y+12	; 0x0c
    5fa0:	88 30       	cpi	r24, 0x08	; 8
    5fa2:	91 05       	cpc	r25, r1
    5fa4:	3c f0       	brlt	.+14     	; 0x5fb4 <prvProcessReceivedCommands+0xb6>
    5fa6:	2b 85       	ldd	r18, Y+11	; 0x0b
    5fa8:	3c 85       	ldd	r19, Y+12	; 0x0c
    5faa:	29 30       	cpi	r18, 0x09	; 9
    5fac:	31 05       	cpc	r19, r1
    5fae:	09 f4       	brne	.+2      	; 0x5fb2 <prvProcessReceivedCommands+0xb4>
    5fb0:	52 c0       	rjmp	.+164    	; 0x6056 <prvProcessReceivedCommands+0x158>
    5fb2:	88 c0       	rjmp	.+272    	; 0x60c4 <prvProcessReceivedCommands+0x1c6>
                    case tmrCOMMAND_START:
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    5fb4:	eb 81       	ldd	r30, Y+3	; 0x03
    5fb6:	fc 81       	ldd	r31, Y+4	; 0x04
    5fb8:	82 89       	ldd	r24, Z+18	; 0x12
    5fba:	81 60       	ori	r24, 0x01	; 1
    5fbc:	eb 81       	ldd	r30, Y+3	; 0x03
    5fbe:	fc 81       	ldd	r31, Y+4	; 0x04
    5fc0:	82 8b       	std	Z+18, r24	; 0x12

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    5fc2:	2e 81       	ldd	r18, Y+6	; 0x06
    5fc4:	3f 81       	ldd	r19, Y+7	; 0x07
    5fc6:	eb 81       	ldd	r30, Y+3	; 0x03
    5fc8:	fc 81       	ldd	r31, Y+4	; 0x04
    5fca:	84 85       	ldd	r24, Z+12	; 0x0c
    5fcc:	95 85       	ldd	r25, Z+13	; 0x0d
    5fce:	a9 01       	movw	r20, r18
    5fd0:	48 0f       	add	r20, r24
    5fd2:	59 1f       	adc	r21, r25
    5fd4:	ee 81       	ldd	r30, Y+6	; 0x06
    5fd6:	ff 81       	ldd	r31, Y+7	; 0x07
    5fd8:	8b 81       	ldd	r24, Y+3	; 0x03
    5fda:	9c 81       	ldd	r25, Y+4	; 0x04
    5fdc:	29 81       	ldd	r18, Y+1	; 0x01
    5fde:	3a 81       	ldd	r19, Y+2	; 0x02
    5fe0:	ba 01       	movw	r22, r20
    5fe2:	a9 01       	movw	r20, r18
    5fe4:	9f 01       	movw	r18, r30
    5fe6:	0e 94 17 2f 	call	0x5e2e	; 0x5e2e <prvInsertTimerInActiveList>
    5fea:	88 23       	and	r24, r24
    5fec:	09 f4       	brne	.+2      	; 0x5ff0 <prvProcessReceivedCommands+0xf2>
    5fee:	6a c0       	rjmp	.+212    	; 0x60c4 <prvProcessReceivedCommands+0x1c6>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    5ff0:	eb 81       	ldd	r30, Y+3	; 0x03
    5ff2:	fc 81       	ldd	r31, Y+4	; 0x04
    5ff4:	82 89       	ldd	r24, Z+18	; 0x12
    5ff6:	88 2f       	mov	r24, r24
    5ff8:	90 e0       	ldi	r25, 0x00	; 0
    5ffa:	84 70       	andi	r24, 0x04	; 4
    5ffc:	90 70       	andi	r25, 0x00	; 0
    5ffe:	00 97       	sbiw	r24, 0x00	; 0
    6000:	91 f0       	breq	.+36     	; 0x6026 <prvProcessReceivedCommands+0x128>
                            {
                                prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow );
    6002:	2e 81       	ldd	r18, Y+6	; 0x06
    6004:	3f 81       	ldd	r19, Y+7	; 0x07
    6006:	eb 81       	ldd	r30, Y+3	; 0x03
    6008:	fc 81       	ldd	r31, Y+4	; 0x04
    600a:	84 85       	ldd	r24, Z+12	; 0x0c
    600c:	95 85       	ldd	r25, Z+13	; 0x0d
    600e:	a9 01       	movw	r20, r18
    6010:	48 0f       	add	r20, r24
    6012:	59 1f       	adc	r21, r25
    6014:	8b 81       	ldd	r24, Y+3	; 0x03
    6016:	9c 81       	ldd	r25, Y+4	; 0x04
    6018:	29 81       	ldd	r18, Y+1	; 0x01
    601a:	3a 81       	ldd	r19, Y+2	; 0x02
    601c:	ba 01       	movw	r22, r20
    601e:	a9 01       	movw	r20, r18
    6020:	0e 94 c1 2d 	call	0x5b82	; 0x5b82 <prvReloadTimer>
    6024:	07 c0       	rjmp	.+14     	; 0x6034 <prvProcessReceivedCommands+0x136>
                            }
                            else
                            {
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    6026:	eb 81       	ldd	r30, Y+3	; 0x03
    6028:	fc 81       	ldd	r31, Y+4	; 0x04
    602a:	82 89       	ldd	r24, Z+18	; 0x12
    602c:	8e 7f       	andi	r24, 0xFE	; 254
    602e:	eb 81       	ldd	r30, Y+3	; 0x03
    6030:	fc 81       	ldd	r31, Y+4	; 0x04
    6032:	82 8b       	std	Z+18, r24	; 0x12
                            }

                            /* Call the timer callback. */
                            traceTIMER_EXPIRED( pxTimer );
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    6034:	eb 81       	ldd	r30, Y+3	; 0x03
    6036:	fc 81       	ldd	r31, Y+4	; 0x04
    6038:	00 88       	ldd	r0, Z+16	; 0x10
    603a:	f1 89       	ldd	r31, Z+17	; 0x11
    603c:	e0 2d       	mov	r30, r0
    603e:	8b 81       	ldd	r24, Y+3	; 0x03
    6040:	9c 81       	ldd	r25, Y+4	; 0x04
    6042:	09 95       	icall
    6044:	3f c0       	rjmp	.+126    	; 0x60c4 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    6046:	eb 81       	ldd	r30, Y+3	; 0x03
    6048:	fc 81       	ldd	r31, Y+4	; 0x04
    604a:	82 89       	ldd	r24, Z+18	; 0x12
    604c:	8e 7f       	andi	r24, 0xFE	; 254
    604e:	eb 81       	ldd	r30, Y+3	; 0x03
    6050:	fc 81       	ldd	r31, Y+4	; 0x04
    6052:	82 8b       	std	Z+18, r24	; 0x12
    6054:	37 c0       	rjmp	.+110    	; 0x60c4 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    6056:	eb 81       	ldd	r30, Y+3	; 0x03
    6058:	fc 81       	ldd	r31, Y+4	; 0x04
    605a:	82 89       	ldd	r24, Z+18	; 0x12
    605c:	81 60       	ori	r24, 0x01	; 1
    605e:	eb 81       	ldd	r30, Y+3	; 0x03
    6060:	fc 81       	ldd	r31, Y+4	; 0x04
    6062:	82 8b       	std	Z+18, r24	; 0x12
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    6064:	8e 81       	ldd	r24, Y+6	; 0x06
    6066:	9f 81       	ldd	r25, Y+7	; 0x07
    6068:	eb 81       	ldd	r30, Y+3	; 0x03
    606a:	fc 81       	ldd	r31, Y+4	; 0x04
    606c:	95 87       	std	Z+13, r25	; 0x0d
    606e:	84 87       	std	Z+12, r24	; 0x0c
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    6070:	eb 81       	ldd	r30, Y+3	; 0x03
    6072:	fc 81       	ldd	r31, Y+4	; 0x04
    6074:	24 85       	ldd	r18, Z+12	; 0x0c
    6076:	35 85       	ldd	r19, Z+13	; 0x0d
    6078:	89 81       	ldd	r24, Y+1	; 0x01
    607a:	9a 81       	ldd	r25, Y+2	; 0x02
    607c:	a9 01       	movw	r20, r18
    607e:	48 0f       	add	r20, r24
    6080:	59 1f       	adc	r21, r25
    6082:	8b 81       	ldd	r24, Y+3	; 0x03
    6084:	9c 81       	ldd	r25, Y+4	; 0x04
    6086:	29 81       	ldd	r18, Y+1	; 0x01
    6088:	3a 81       	ldd	r19, Y+2	; 0x02
    608a:	e9 81       	ldd	r30, Y+1	; 0x01
    608c:	fa 81       	ldd	r31, Y+2	; 0x02
    608e:	ba 01       	movw	r22, r20
    6090:	a9 01       	movw	r20, r18
    6092:	9f 01       	movw	r18, r30
    6094:	0e 94 17 2f 	call	0x5e2e	; 0x5e2e <prvInsertTimerInActiveList>
    6098:	15 c0       	rjmp	.+42     	; 0x60c4 <prvProcessReceivedCommands+0x1c6>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                            {
                                /* The timer has already been removed from the active list,
                                 * just free up the memory if the memory was dynamically
                                 * allocated. */
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    609a:	eb 81       	ldd	r30, Y+3	; 0x03
    609c:	fc 81       	ldd	r31, Y+4	; 0x04
    609e:	82 89       	ldd	r24, Z+18	; 0x12
    60a0:	88 2f       	mov	r24, r24
    60a2:	90 e0       	ldi	r25, 0x00	; 0
    60a4:	82 70       	andi	r24, 0x02	; 2
    60a6:	90 70       	andi	r25, 0x00	; 0
    60a8:	00 97       	sbiw	r24, 0x00	; 0
    60aa:	29 f4       	brne	.+10     	; 0x60b6 <prvProcessReceivedCommands+0x1b8>
                                {
                                    vPortFree( pxTimer );
    60ac:	8b 81       	ldd	r24, Y+3	; 0x03
    60ae:	9c 81       	ldd	r25, Y+4	; 0x04
    60b0:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
    60b4:	07 c0       	rjmp	.+14     	; 0x60c4 <prvProcessReceivedCommands+0x1c6>
                                }
                                else
                                {
                                    pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    60b6:	eb 81       	ldd	r30, Y+3	; 0x03
    60b8:	fc 81       	ldd	r31, Y+4	; 0x04
    60ba:	82 89       	ldd	r24, Z+18	; 0x12
    60bc:	8e 7f       	andi	r24, 0xFE	; 254
    60be:	eb 81       	ldd	r30, Y+3	; 0x03
    60c0:	fc 81       	ldd	r31, Y+4	; 0x04
    60c2:	82 8b       	std	Z+18, r24	; 0x12
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    60c4:	80 91 04 07 	lds	r24, 0x0704
    60c8:	90 91 05 07 	lds	r25, 0x0705
    60cc:	9e 01       	movw	r18, r28
    60ce:	2b 5f       	subi	r18, 0xFB	; 251
    60d0:	3f 4f       	sbci	r19, 0xFF	; 255
    60d2:	b9 01       	movw	r22, r18
    60d4:	40 e0       	ldi	r20, 0x00	; 0
    60d6:	50 e0       	ldi	r21, 0x00	; 0
    60d8:	0e 94 62 11 	call	0x22c4	; 0x22c4 <xQueueReceive>
    60dc:	88 23       	and	r24, r24
    60de:	09 f0       	breq	.+2      	; 0x60e2 <prvProcessReceivedCommands+0x1e4>
    60e0:	19 cf       	rjmp	.-462    	; 0x5f14 <prvProcessReceivedCommands+0x16>
                        /* Don't expect to get here. */
                        break;
                }
            }
        }
    }
    60e2:	2c 96       	adiw	r28, 0x0c	; 12
    60e4:	0f b6       	in	r0, 0x3f	; 63
    60e6:	f8 94       	cli
    60e8:	de bf       	out	0x3e, r29	; 62
    60ea:	0f be       	out	0x3f, r0	; 63
    60ec:	cd bf       	out	0x3d, r28	; 61
    60ee:	cf 91       	pop	r28
    60f0:	df 91       	pop	r29
    60f2:	08 95       	ret

000060f4 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
    60f4:	df 93       	push	r29
    60f6:	cf 93       	push	r28
    60f8:	00 d0       	rcall	.+0      	; 0x60fa <prvSwitchTimerLists+0x6>
    60fa:	00 d0       	rcall	.+0      	; 0x60fc <prvSwitchTimerLists+0x8>
    60fc:	cd b7       	in	r28, 0x3d	; 61
    60fe:	de b7       	in	r29, 0x3e	; 62
    6100:	11 c0       	rjmp	.+34     	; 0x6124 <prvSwitchTimerLists+0x30>
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    6102:	e0 91 1c 07 	lds	r30, 0x071C
    6106:	f0 91 1d 07 	lds	r31, 0x071D
    610a:	05 80       	ldd	r0, Z+5	; 0x05
    610c:	f6 81       	ldd	r31, Z+6	; 0x06
    610e:	e0 2d       	mov	r30, r0
    6110:	80 81       	ld	r24, Z
    6112:	91 81       	ldd	r25, Z+1	; 0x01
    6114:	9c 83       	std	Y+4, r25	; 0x04
    6116:	8b 83       	std	Y+3, r24	; 0x03

            /* Process the expired timer.  For auto-reload timers, be careful to
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
    6118:	8b 81       	ldd	r24, Y+3	; 0x03
    611a:	9c 81       	ldd	r25, Y+4	; 0x04
    611c:	6f ef       	ldi	r22, 0xFF	; 255
    611e:	7f ef       	ldi	r23, 0xFF	; 255
    6120:	0e 94 00 2e 	call	0x5c00	; 0x5c00 <prvProcessExpiredTimer>

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    6124:	e0 91 1c 07 	lds	r30, 0x071C
    6128:	f0 91 1d 07 	lds	r31, 0x071D
    612c:	80 81       	ld	r24, Z
    612e:	88 23       	and	r24, r24
    6130:	41 f7       	brne	.-48     	; 0x6102 <prvSwitchTimerLists+0xe>
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
        }

        pxTemp = pxCurrentTimerList;
    6132:	80 91 1c 07 	lds	r24, 0x071C
    6136:	90 91 1d 07 	lds	r25, 0x071D
    613a:	9a 83       	std	Y+2, r25	; 0x02
    613c:	89 83       	std	Y+1, r24	; 0x01
        pxCurrentTimerList = pxOverflowTimerList;
    613e:	80 91 1e 07 	lds	r24, 0x071E
    6142:	90 91 1f 07 	lds	r25, 0x071F
    6146:	90 93 1d 07 	sts	0x071D, r25
    614a:	80 93 1c 07 	sts	0x071C, r24
        pxOverflowTimerList = pxTemp;
    614e:	89 81       	ldd	r24, Y+1	; 0x01
    6150:	9a 81       	ldd	r25, Y+2	; 0x02
    6152:	90 93 1f 07 	sts	0x071F, r25
    6156:	80 93 1e 07 	sts	0x071E, r24
    }
    615a:	0f 90       	pop	r0
    615c:	0f 90       	pop	r0
    615e:	0f 90       	pop	r0
    6160:	0f 90       	pop	r0
    6162:	cf 91       	pop	r28
    6164:	df 91       	pop	r29
    6166:	08 95       	ret

00006168 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
    6168:	df 93       	push	r29
    616a:	cf 93       	push	r28
    616c:	cd b7       	in	r28, 0x3d	; 61
    616e:	de b7       	in	r29, 0x3e	; 62
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
    6170:	0f b6       	in	r0, 0x3f	; 63
    6172:	f8 94       	cli
    6174:	0f 92       	push	r0
        {
            if( xTimerQueue == NULL )
    6176:	80 91 04 07 	lds	r24, 0x0704
    617a:	90 91 05 07 	lds	r25, 0x0705
    617e:	00 97       	sbiw	r24, 0x00	; 0
    6180:	e9 f4       	brne	.+58     	; 0x61bc <prvCheckForValidListAndQueue+0x54>
            {
                vListInitialise( &xActiveTimerList1 );
    6182:	8a e0       	ldi	r24, 0x0A	; 10
    6184:	97 e0       	ldi	r25, 0x07	; 7
    6186:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
    618a:	83 e1       	ldi	r24, 0x13	; 19
    618c:	97 e0       	ldi	r25, 0x07	; 7
    618e:	0e 94 79 0d 	call	0x1af2	; 0x1af2 <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
    6192:	8a e0       	ldi	r24, 0x0A	; 10
    6194:	97 e0       	ldi	r25, 0x07	; 7
    6196:	90 93 1d 07 	sts	0x071D, r25
    619a:	80 93 1c 07 	sts	0x071C, r24
                pxOverflowTimerList = &xActiveTimerList2;
    619e:	83 e1       	ldi	r24, 0x13	; 19
    61a0:	97 e0       	ldi	r25, 0x07	; 7
    61a2:	90 93 1f 07 	sts	0x071F, r25
    61a6:	80 93 1e 07 	sts	0x071E, r24

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    61aa:	8a e0       	ldi	r24, 0x0A	; 10
    61ac:	65 e0       	ldi	r22, 0x05	; 5
    61ae:	40 e0       	ldi	r20, 0x00	; 0
    61b0:	0e 94 5a 0f 	call	0x1eb4	; 0x1eb4 <xQueueGenericCreate>
    61b4:	90 93 05 07 	sts	0x0705, r25
    61b8:	80 93 04 07 	sts	0x0704, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    61bc:	0f 90       	pop	r0
    61be:	0f be       	out	0x3f, r0	; 63
    }
    61c0:	cf 91       	pop	r28
    61c2:	df 91       	pop	r29
    61c4:	08 95       	ret

000061c6 <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
    {
    61c6:	df 93       	push	r29
    61c8:	cf 93       	push	r28
    61ca:	00 d0       	rcall	.+0      	; 0x61cc <xTimerIsTimerActive+0x6>
    61cc:	00 d0       	rcall	.+0      	; 0x61ce <xTimerIsTimerActive+0x8>
    61ce:	0f 92       	push	r0
    61d0:	cd b7       	in	r28, 0x3d	; 61
    61d2:	de b7       	in	r29, 0x3e	; 62
    61d4:	9d 83       	std	Y+5, r25	; 0x05
    61d6:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;
        Timer_t * pxTimer = xTimer;
    61d8:	8c 81       	ldd	r24, Y+4	; 0x04
    61da:	9d 81       	ldd	r25, Y+5	; 0x05
    61dc:	9a 83       	std	Y+2, r25	; 0x02
    61de:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        /* Is the timer in the list of active timers? */
        taskENTER_CRITICAL();
    61e0:	0f b6       	in	r0, 0x3f	; 63
    61e2:	f8 94       	cli
    61e4:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
    61e6:	e9 81       	ldd	r30, Y+1	; 0x01
    61e8:	fa 81       	ldd	r31, Y+2	; 0x02
    61ea:	82 89       	ldd	r24, Z+18	; 0x12
    61ec:	88 2f       	mov	r24, r24
    61ee:	90 e0       	ldi	r25, 0x00	; 0
    61f0:	81 70       	andi	r24, 0x01	; 1
    61f2:	90 70       	andi	r25, 0x00	; 0
    61f4:	00 97       	sbiw	r24, 0x00	; 0
    61f6:	11 f4       	brne	.+4      	; 0x61fc <xTimerIsTimerActive+0x36>
            {
                xReturn = pdFALSE;
    61f8:	1b 82       	std	Y+3, r1	; 0x03
    61fa:	02 c0       	rjmp	.+4      	; 0x6200 <xTimerIsTimerActive+0x3a>
            }
            else
            {
                xReturn = pdTRUE;
    61fc:	81 e0       	ldi	r24, 0x01	; 1
    61fe:	8b 83       	std	Y+3, r24	; 0x03
            }
        }
        taskEXIT_CRITICAL();
    6200:	0f 90       	pop	r0
    6202:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    6204:	8b 81       	ldd	r24, Y+3	; 0x03
    } /*lint !e818 Can't be pointer to const due to the typedef. */
    6206:	0f 90       	pop	r0
    6208:	0f 90       	pop	r0
    620a:	0f 90       	pop	r0
    620c:	0f 90       	pop	r0
    620e:	0f 90       	pop	r0
    6210:	cf 91       	pop	r28
    6212:	df 91       	pop	r29
    6214:	08 95       	ret

00006216 <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

    void * pvTimerGetTimerID( const TimerHandle_t xTimer )
    {
    6216:	df 93       	push	r29
    6218:	cf 93       	push	r28
    621a:	00 d0       	rcall	.+0      	; 0x621c <pvTimerGetTimerID+0x6>
    621c:	00 d0       	rcall	.+0      	; 0x621e <pvTimerGetTimerID+0x8>
    621e:	00 d0       	rcall	.+0      	; 0x6220 <pvTimerGetTimerID+0xa>
    6220:	cd b7       	in	r28, 0x3d	; 61
    6222:	de b7       	in	r29, 0x3e	; 62
    6224:	9e 83       	std	Y+6, r25	; 0x06
    6226:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * const pxTimer = xTimer;
    6228:	8d 81       	ldd	r24, Y+5	; 0x05
    622a:	9e 81       	ldd	r25, Y+6	; 0x06
    622c:	9c 83       	std	Y+4, r25	; 0x04
    622e:	8b 83       	std	Y+3, r24	; 0x03
        void * pvReturn;

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    6230:	0f b6       	in	r0, 0x3f	; 63
    6232:	f8 94       	cli
    6234:	0f 92       	push	r0
        {
            pvReturn = pxTimer->pvTimerID;
    6236:	eb 81       	ldd	r30, Y+3	; 0x03
    6238:	fc 81       	ldd	r31, Y+4	; 0x04
    623a:	86 85       	ldd	r24, Z+14	; 0x0e
    623c:	97 85       	ldd	r25, Z+15	; 0x0f
    623e:	9a 83       	std	Y+2, r25	; 0x02
    6240:	89 83       	std	Y+1, r24	; 0x01
        }
        taskEXIT_CRITICAL();
    6242:	0f 90       	pop	r0
    6244:	0f be       	out	0x3f, r0	; 63

        return pvReturn;
    6246:	89 81       	ldd	r24, Y+1	; 0x01
    6248:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    624a:	26 96       	adiw	r28, 0x06	; 6
    624c:	0f b6       	in	r0, 0x3f	; 63
    624e:	f8 94       	cli
    6250:	de bf       	out	0x3e, r29	; 62
    6252:	0f be       	out	0x3f, r0	; 63
    6254:	cd bf       	out	0x3d, r28	; 61
    6256:	cf 91       	pop	r28
    6258:	df 91       	pop	r29
    625a:	08 95       	ret

0000625c <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

    void vTimerSetTimerID( TimerHandle_t xTimer,
                           void * pvNewID )
    {
    625c:	df 93       	push	r29
    625e:	cf 93       	push	r28
    6260:	00 d0       	rcall	.+0      	; 0x6262 <vTimerSetTimerID+0x6>
    6262:	00 d0       	rcall	.+0      	; 0x6264 <vTimerSetTimerID+0x8>
    6264:	00 d0       	rcall	.+0      	; 0x6266 <vTimerSetTimerID+0xa>
    6266:	cd b7       	in	r28, 0x3d	; 61
    6268:	de b7       	in	r29, 0x3e	; 62
    626a:	9c 83       	std	Y+4, r25	; 0x04
    626c:	8b 83       	std	Y+3, r24	; 0x03
    626e:	7e 83       	std	Y+6, r23	; 0x06
    6270:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = xTimer;
    6272:	8b 81       	ldd	r24, Y+3	; 0x03
    6274:	9c 81       	ldd	r25, Y+4	; 0x04
    6276:	9a 83       	std	Y+2, r25	; 0x02
    6278:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    627a:	0f b6       	in	r0, 0x3f	; 63
    627c:	f8 94       	cli
    627e:	0f 92       	push	r0
        {
            pxTimer->pvTimerID = pvNewID;
    6280:	e9 81       	ldd	r30, Y+1	; 0x01
    6282:	fa 81       	ldd	r31, Y+2	; 0x02
    6284:	8d 81       	ldd	r24, Y+5	; 0x05
    6286:	9e 81       	ldd	r25, Y+6	; 0x06
    6288:	97 87       	std	Z+15, r25	; 0x0f
    628a:	86 87       	std	Z+14, r24	; 0x0e
        }
        taskEXIT_CRITICAL();
    628c:	0f 90       	pop	r0
    628e:	0f be       	out	0x3f, r0	; 63
    }
    6290:	26 96       	adiw	r28, 0x06	; 6
    6292:	0f b6       	in	r0, 0x3f	; 63
    6294:	f8 94       	cli
    6296:	de bf       	out	0x3e, r29	; 62
    6298:	0f be       	out	0x3f, r0	; 63
    629a:	cd bf       	out	0x3d, r28	; 61
    629c:	cf 91       	pop	r28
    629e:	df 91       	pop	r29
    62a0:	08 95       	ret

000062a2 <main>:
void toggle_led_mode(void);

TaskHandle_t task2ptr;

int main(void)
{
    62a2:	ef 92       	push	r14
    62a4:	ff 92       	push	r15
    62a6:	0f 93       	push	r16
    62a8:	1f 93       	push	r17
    62aa:	df 93       	push	r29
    62ac:	cf 93       	push	r28
    62ae:	cd b7       	in	r28, 0x3d	; 61
    62b0:	de b7       	in	r29, 0x3e	; 62


	PWM_INIT();
    62b2:	0e 94 76 06 	call	0xcec	; 0xcec <PWM_INIT>
	xButtonTimer = xTimerCreate
    62b6:	e0 ec       	ldi	r30, 0xC0	; 192
    62b8:	f1 e3       	ldi	r31, 0x31	; 49
    62ba:	8d e6       	ldi	r24, 0x6D	; 109
    62bc:	90 e0       	ldi	r25, 0x00	; 0
    62be:	65 e0       	ldi	r22, 0x05	; 5
    62c0:	70 e0       	ldi	r23, 0x00	; 0
    62c2:	41 e0       	ldi	r20, 0x01	; 1
    62c4:	20 e0       	ldi	r18, 0x00	; 0
    62c6:	30 e0       	ldi	r19, 0x00	; 0
    62c8:	8f 01       	movw	r16, r30
    62ca:	0e 94 1e 2c 	call	0x583c	; 0x583c <xTimerCreate>
    62ce:	90 93 21 07 	sts	0x0721, r25
    62d2:	80 93 20 07 	sts	0x0720, r24
	                     ( void * ) 0,
	                     /* Each timer calls the same callback when
	                     it expires. */
						 get_readings
	                   );
	xLedBlinkingTimer = xTimerCreate
    62d6:	ed ea       	ldi	r30, 0xAD	; 173
    62d8:	f1 e3       	ldi	r31, 0x31	; 49
    62da:	8a e7       	ldi	r24, 0x7A	; 122
    62dc:	90 e0       	ldi	r25, 0x00	; 0
    62de:	64 ef       	ldi	r22, 0xF4	; 244
    62e0:	71 e0       	ldi	r23, 0x01	; 1
    62e2:	41 e0       	ldi	r20, 0x01	; 1
    62e4:	20 e0       	ldi	r18, 0x00	; 0
    62e6:	30 e0       	ldi	r19, 0x00	; 0
    62e8:	8f 01       	movw	r16, r30
    62ea:	0e 94 1e 2c 	call	0x583c	; 0x583c <xTimerCreate>
    62ee:	90 93 23 07 	sts	0x0723, r25
    62f2:	80 93 22 07 	sts	0x0722, r24
		                     ( void * ) 0,
		                     /* Each timer calls the same callback when
		                     it expires. */
							 toggle_led_mode
		                   );
	xTaskCreate(vState_machine,"first",configMINIMAL_STACK_SIZE,NULL,1,&task1ptr);
    62f6:	87 e5       	ldi	r24, 0x57	; 87
    62f8:	92 e3       	ldi	r25, 0x32	; 50
    62fa:	24 e8       	ldi	r18, 0x84	; 132
    62fc:	30 e0       	ldi	r19, 0x00	; 0
    62fe:	ec e2       	ldi	r30, 0x2C	; 44
    6300:	f7 e0       	ldi	r31, 0x07	; 7
    6302:	b9 01       	movw	r22, r18
    6304:	45 e5       	ldi	r20, 0x55	; 85
    6306:	50 e0       	ldi	r21, 0x00	; 0
    6308:	20 e0       	ldi	r18, 0x00	; 0
    630a:	30 e0       	ldi	r19, 0x00	; 0
    630c:	01 e0       	ldi	r16, 0x01	; 1
    630e:	7f 01       	movw	r14, r30
    6310:	0e 94 05 18 	call	0x300a	; 0x300a <xTaskCreate>
	xTimerStart(xButtonTimer, 10 );
    6314:	00 91 20 07 	lds	r16, 0x0720
    6318:	10 91 21 07 	lds	r17, 0x0721
    631c:	0e 94 b2 1c 	call	0x3964	; 0x3964 <xTaskGetTickCount>
    6320:	9c 01       	movw	r18, r24
    6322:	c8 01       	movw	r24, r16
    6324:	61 e0       	ldi	r22, 0x01	; 1
    6326:	a9 01       	movw	r20, r18
    6328:	20 e0       	ldi	r18, 0x00	; 0
    632a:	30 e0       	ldi	r19, 0x00	; 0
    632c:	0a e0       	ldi	r16, 0x0A	; 10
    632e:	10 e0       	ldi	r17, 0x00	; 0
    6330:	0e 94 b0 2c 	call	0x5960	; 0x5960 <xTimerGenericCommand>
	xTimerStart(xLedBlinkingTimer, 10 );
    6334:	00 91 22 07 	lds	r16, 0x0722
    6338:	10 91 23 07 	lds	r17, 0x0723
    633c:	0e 94 b2 1c 	call	0x3964	; 0x3964 <xTaskGetTickCount>
    6340:	9c 01       	movw	r18, r24
    6342:	c8 01       	movw	r24, r16
    6344:	61 e0       	ldi	r22, 0x01	; 1
    6346:	a9 01       	movw	r20, r18
    6348:	20 e0       	ldi	r18, 0x00	; 0
    634a:	30 e0       	ldi	r19, 0x00	; 0
    634c:	0a e0       	ldi	r16, 0x0A	; 10
    634e:	10 e0       	ldi	r17, 0x00	; 0
    6350:	0e 94 b0 2c 	call	0x5960	; 0x5960 <xTimerGenericCommand>
	vTaskStartScheduler();
    6354:	0e 94 0f 1b 	call	0x361e	; 0x361e <vTaskStartScheduler>
    6358:	ff cf       	rjmp	.-2      	; 0x6358 <main+0xb6>

0000635a <toggle_led_mode>:


	}
}

void toggle_led_mode(void){
    635a:	df 93       	push	r29
    635c:	cf 93       	push	r28
    635e:	0f 92       	push	r0
    6360:	cd b7       	in	r28, 0x3d	; 61
    6362:	de b7       	in	r29, 0x3e	; 62
		led_mode = !led_mode;
    6364:	80 91 24 07 	lds	r24, 0x0724
    6368:	19 82       	std	Y+1, r1	; 0x01
    636a:	88 23       	and	r24, r24
    636c:	11 f4       	brne	.+4      	; 0x6372 <toggle_led_mode+0x18>
    636e:	81 e0       	ldi	r24, 0x01	; 1
    6370:	89 83       	std	Y+1, r24	; 0x01
    6372:	89 81       	ldd	r24, Y+1	; 0x01
    6374:	80 93 24 07 	sts	0x0724, r24
}
    6378:	0f 90       	pop	r0
    637a:	cf 91       	pop	r28
    637c:	df 91       	pop	r29
    637e:	08 95       	ret

00006380 <get_readings>:
void get_readings(void)
{
    6380:	df 93       	push	r29
    6382:	cf 93       	push	r28
    6384:	00 d0       	rcall	.+0      	; 0x6386 <get_readings+0x6>
    6386:	0f 92       	push	r0
    6388:	cd b7       	in	r28, 0x3d	; 61
    638a:	de b7       	in	r29, 0x3e	; 62

		ignition_button = READ_IGNITON();
    638c:	0e 94 cf 06 	call	0xd9e	; 0xd9e <READ_IGNITON>
    6390:	80 93 27 07 	sts	0x0727, r24

		if(!ignition_button){
    6394:	80 91 27 07 	lds	r24, 0x0727
    6398:	88 23       	and	r24, r24
    639a:	09 f0       	breq	.+2      	; 0x639e <get_readings+0x1e>
    639c:	7e c0       	rjmp	.+252    	; 0x649a <get_readings+0x11a>
			uint8_t hazard_data = READ_HAZARD_Button();
    639e:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <READ_HAZARD_Button>
    63a2:	8b 83       	std	Y+3, r24	; 0x03
			uint8_t right_data = READ_RIGHT_Button();
    63a4:	0e 94 f7 06 	call	0xdee	; 0xdee <READ_RIGHT_Button>
    63a8:	8a 83       	std	Y+2, r24	; 0x02
			uint8_t left_data = READ_LEFT_Button();
    63aa:	0e 94 0b 07 	call	0xe16	; 0xe16 <READ_LEFT_Button>
    63ae:	89 83       	std	Y+1, r24	; 0x01
			if(hazard_data){
    63b0:	8b 81       	ldd	r24, Y+3	; 0x03
    63b2:	88 23       	and	r24, r24
    63b4:	41 f0       	breq	.+16     	; 0x63c6 <get_readings+0x46>
				/*hazard btton pressed state*/
					Hazzred_button = 1;
    63b6:	81 e0       	ldi	r24, 0x01	; 1
    63b8:	80 93 2e 07 	sts	0x072E, r24
					L_button = 0;
    63bc:	10 92 2b 07 	sts	0x072B, r1
					R_button = 0;
    63c0:	10 92 28 07 	sts	0x0728, r1
    63c4:	6e c0       	rjmp	.+220    	; 0x64a2 <get_readings+0x122>
			}
			else if(right_data){
    63c6:	8a 81       	ldd	r24, Y+2	; 0x02
    63c8:	88 23       	and	r24, r24
    63ca:	39 f1       	breq	.+78     	; 0x641a <get_readings+0x9a>
				/*Right button pressed state*/
				right_button_pressed_counter++;
    63cc:	80 91 31 07 	lds	r24, 0x0731
    63d0:	90 91 32 07 	lds	r25, 0x0732
    63d4:	01 96       	adiw	r24, 0x01	; 1
    63d6:	90 93 32 07 	sts	0x0732, r25
    63da:	80 93 31 07 	sts	0x0731, r24
				hazzred_button_pressed_counter=0;
    63de:	10 92 26 07 	sts	0x0726, r1
    63e2:	10 92 25 07 	sts	0x0725, r1
				left_button_pressed_counter=0;
    63e6:	10 92 30 07 	sts	0x0730, r1
    63ea:	10 92 2f 07 	sts	0x072F, r1
				if(!(right_button_pressed_counter%10)){
    63ee:	80 91 31 07 	lds	r24, 0x0731
    63f2:	90 91 32 07 	lds	r25, 0x0732
    63f6:	2a e0       	ldi	r18, 0x0A	; 10
    63f8:	30 e0       	ldi	r19, 0x00	; 0
    63fa:	b9 01       	movw	r22, r18
    63fc:	0e 94 92 32 	call	0x6524	; 0x6524 <__divmodhi4>
    6400:	00 97       	sbiw	r24, 0x00	; 0
    6402:	09 f0       	breq	.+2      	; 0x6406 <get_readings+0x86>
    6404:	4e c0       	rjmp	.+156    	; 0x64a2 <get_readings+0x122>
					R_button = 1;
    6406:	81 e0       	ldi	r24, 0x01	; 1
    6408:	80 93 28 07 	sts	0x0728, r24
					Hazzred_button = 0;
    640c:	10 92 2e 07 	sts	0x072E, r1
					L_button = 0;
    6410:	10 92 2b 07 	sts	0x072B, r1
					Stop_Blinking_Left();
    6414:	0e 94 4c 07 	call	0xe98	; 0xe98 <Stop_Blinking_Left>
    6418:	44 c0       	rjmp	.+136    	; 0x64a2 <get_readings+0x122>
				}
			}
			else if(left_data){
    641a:	89 81       	ldd	r24, Y+1	; 0x01
    641c:	88 23       	and	r24, r24
    641e:	31 f1       	breq	.+76     	; 0x646c <get_readings+0xec>
				/*Left Button pressed state*/
				left_button_pressed_counter++;
    6420:	80 91 2f 07 	lds	r24, 0x072F
    6424:	90 91 30 07 	lds	r25, 0x0730
    6428:	01 96       	adiw	r24, 0x01	; 1
    642a:	90 93 30 07 	sts	0x0730, r25
    642e:	80 93 2f 07 	sts	0x072F, r24
				hazzred_button_pressed_counter=0;
    6432:	10 92 26 07 	sts	0x0726, r1
    6436:	10 92 25 07 	sts	0x0725, r1
				right_button_pressed_counter=0;
    643a:	10 92 32 07 	sts	0x0732, r1
    643e:	10 92 31 07 	sts	0x0731, r1
				if(!(left_button_pressed_counter%10)){
    6442:	80 91 2f 07 	lds	r24, 0x072F
    6446:	90 91 30 07 	lds	r25, 0x0730
    644a:	2a e0       	ldi	r18, 0x0A	; 10
    644c:	30 e0       	ldi	r19, 0x00	; 0
    644e:	b9 01       	movw	r22, r18
    6450:	0e 94 92 32 	call	0x6524	; 0x6524 <__divmodhi4>
    6454:	00 97       	sbiw	r24, 0x00	; 0
    6456:	29 f5       	brne	.+74     	; 0x64a2 <get_readings+0x122>
					L_button = 1;
    6458:	81 e0       	ldi	r24, 0x01	; 1
    645a:	80 93 2b 07 	sts	0x072B, r24
					R_button = 0;
    645e:	10 92 28 07 	sts	0x0728, r1
					Hazzred_button = 0;
    6462:	10 92 2e 07 	sts	0x072E, r1
					Stop_Blinking_Right();
    6466:	0e 94 43 07 	call	0xe86	; 0xe86 <Stop_Blinking_Right>
    646a:	1b c0       	rjmp	.+54     	; 0x64a2 <get_readings+0x122>
				}
			}
			else{
				/*neutral state no button pressed*/
				Stop_Blinking_Right();
    646c:	0e 94 43 07 	call	0xe86	; 0xe86 <Stop_Blinking_Right>
				Stop_Blinking_Left();
    6470:	0e 94 4c 07 	call	0xe98	; 0xe98 <Stop_Blinking_Left>
				hazzred_button_pressed_counter=0;
    6474:	10 92 26 07 	sts	0x0726, r1
    6478:	10 92 25 07 	sts	0x0725, r1
				right_button_pressed_counter=0;
    647c:	10 92 32 07 	sts	0x0732, r1
    6480:	10 92 31 07 	sts	0x0731, r1
				left_button_pressed_counter=0;
    6484:	10 92 30 07 	sts	0x0730, r1
    6488:	10 92 2f 07 	sts	0x072F, r1
				L_button = 0;
    648c:	10 92 2b 07 	sts	0x072B, r1
				R_button = 0;
    6490:	10 92 28 07 	sts	0x0728, r1
				Hazzred_button = 0;
    6494:	10 92 2e 07 	sts	0x072E, r1
    6498:	04 c0       	rjmp	.+8      	; 0x64a2 <get_readings+0x122>

			}
		}else{
			/*Ignition is off*/
			Stop_Blinking_Right();
    649a:	0e 94 43 07 	call	0xe86	; 0xe86 <Stop_Blinking_Right>
			Stop_Blinking_Left();
    649e:	0e 94 4c 07 	call	0xe98	; 0xe98 <Stop_Blinking_Left>
		}

}
    64a2:	0f 90       	pop	r0
    64a4:	0f 90       	pop	r0
    64a6:	0f 90       	pop	r0
    64a8:	cf 91       	pop	r28
    64aa:	df 91       	pop	r29
    64ac:	08 95       	ret

000064ae <vState_machine>:


void vState_machine(void)
{
    64ae:	df 93       	push	r29
    64b0:	cf 93       	push	r28
    64b2:	cd b7       	in	r28, 0x3d	; 61
    64b4:	de b7       	in	r29, 0x3e	; 62
	while(1)
	{

		if(!ignition_button){
    64b6:	80 91 27 07 	lds	r24, 0x0727
    64ba:	88 23       	and	r24, r24
    64bc:	e1 f7       	brne	.-8      	; 0x64b6 <vState_machine+0x8>
			if(Hazzred_button){
    64be:	80 91 2e 07 	lds	r24, 0x072E
    64c2:	88 23       	and	r24, r24
    64c4:	49 f0       	breq	.+18     	; 0x64d8 <vState_machine+0x2a>
				vBlink_Right(led_mode);
    64c6:	80 91 24 07 	lds	r24, 0x0724
    64ca:	0e 94 1f 07 	call	0xe3e	; 0xe3e <vBlink_Right>
				Blink_LEFT(led_mode);
    64ce:	80 91 24 07 	lds	r24, 0x0724
    64d2:	0e 94 31 07 	call	0xe62	; 0xe62 <Blink_LEFT>
    64d6:	ef cf       	rjmp	.-34     	; 0x64b6 <vState_machine+0x8>
			}
			else if(R_button ){
    64d8:	80 91 28 07 	lds	r24, 0x0728
    64dc:	88 23       	and	r24, r24
    64de:	29 f0       	breq	.+10     	; 0x64ea <vState_machine+0x3c>
				vBlink_Right(led_mode);
    64e0:	80 91 24 07 	lds	r24, 0x0724
    64e4:	0e 94 1f 07 	call	0xe3e	; 0xe3e <vBlink_Right>
    64e8:	e6 cf       	rjmp	.-52     	; 0x64b6 <vState_machine+0x8>
			}
			else if(L_button ){
    64ea:	80 91 2b 07 	lds	r24, 0x072B
    64ee:	88 23       	and	r24, r24
    64f0:	11 f3       	breq	.-60     	; 0x64b6 <vState_machine+0x8>
				Blink_LEFT(led_mode);
    64f2:	80 91 24 07 	lds	r24, 0x0724
    64f6:	0e 94 31 07 	call	0xe62	; 0xe62 <Blink_LEFT>
    64fa:	dd cf       	rjmp	.-70     	; 0x64b6 <vState_machine+0x8>

000064fc <__udivmodhi4>:
    64fc:	aa 1b       	sub	r26, r26
    64fe:	bb 1b       	sub	r27, r27
    6500:	51 e1       	ldi	r21, 0x11	; 17
    6502:	07 c0       	rjmp	.+14     	; 0x6512 <__udivmodhi4_ep>

00006504 <__udivmodhi4_loop>:
    6504:	aa 1f       	adc	r26, r26
    6506:	bb 1f       	adc	r27, r27
    6508:	a6 17       	cp	r26, r22
    650a:	b7 07       	cpc	r27, r23
    650c:	10 f0       	brcs	.+4      	; 0x6512 <__udivmodhi4_ep>
    650e:	a6 1b       	sub	r26, r22
    6510:	b7 0b       	sbc	r27, r23

00006512 <__udivmodhi4_ep>:
    6512:	88 1f       	adc	r24, r24
    6514:	99 1f       	adc	r25, r25
    6516:	5a 95       	dec	r21
    6518:	a9 f7       	brne	.-22     	; 0x6504 <__udivmodhi4_loop>
    651a:	80 95       	com	r24
    651c:	90 95       	com	r25
    651e:	bc 01       	movw	r22, r24
    6520:	cd 01       	movw	r24, r26
    6522:	08 95       	ret

00006524 <__divmodhi4>:
    6524:	97 fb       	bst	r25, 7
    6526:	09 2e       	mov	r0, r25
    6528:	07 26       	eor	r0, r23
    652a:	0a d0       	rcall	.+20     	; 0x6540 <__divmodhi4_neg1>
    652c:	77 fd       	sbrc	r23, 7
    652e:	04 d0       	rcall	.+8      	; 0x6538 <__divmodhi4_neg2>
    6530:	e5 df       	rcall	.-54     	; 0x64fc <__udivmodhi4>
    6532:	06 d0       	rcall	.+12     	; 0x6540 <__divmodhi4_neg1>
    6534:	00 20       	and	r0, r0
    6536:	1a f4       	brpl	.+6      	; 0x653e <__divmodhi4_exit>

00006538 <__divmodhi4_neg2>:
    6538:	70 95       	com	r23
    653a:	61 95       	neg	r22
    653c:	7f 4f       	sbci	r23, 0xFF	; 255

0000653e <__divmodhi4_exit>:
    653e:	08 95       	ret

00006540 <__divmodhi4_neg1>:
    6540:	f6 f7       	brtc	.-4      	; 0x653e <__divmodhi4_exit>
    6542:	90 95       	com	r25
    6544:	81 95       	neg	r24
    6546:	9f 4f       	sbci	r25, 0xFF	; 255
    6548:	08 95       	ret

0000654a <memcpy>:
    654a:	fb 01       	movw	r30, r22
    654c:	dc 01       	movw	r26, r24
    654e:	02 c0       	rjmp	.+4      	; 0x6554 <memcpy+0xa>
    6550:	01 90       	ld	r0, Z+
    6552:	0d 92       	st	X+, r0
    6554:	41 50       	subi	r20, 0x01	; 1
    6556:	50 40       	sbci	r21, 0x00	; 0
    6558:	d8 f7       	brcc	.-10     	; 0x6550 <memcpy+0x6>
    655a:	08 95       	ret

0000655c <memset>:
    655c:	dc 01       	movw	r26, r24
    655e:	01 c0       	rjmp	.+2      	; 0x6562 <memset+0x6>
    6560:	6d 93       	st	X+, r22
    6562:	41 50       	subi	r20, 0x01	; 1
    6564:	50 40       	sbci	r21, 0x00	; 0
    6566:	e0 f7       	brcc	.-8      	; 0x6560 <memset+0x4>
    6568:	08 95       	ret

0000656a <_exit>:
    656a:	f8 94       	cli

0000656c <__stop_program>:
    656c:	ff cf       	rjmp	.-2      	; 0x656c <__stop_program>
