
RTOS_2023.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006650  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000002c  00800060  00006650  000066e4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000006a9  0080008c  0080008c  00006710  2**0
                  ALLOC
  3 .stab         000094d4  00000000  00000000  00006710  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00005e12  00000000  00000000  0000fbe4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 9a 03 	jmp	0x734	; 0x734 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 e5       	ldi	r30, 0x50	; 80
      68:	f6 e6       	ldi	r31, 0x66	; 102
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 38       	cpi	r26, 0x8C	; 140
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	ac e8       	ldi	r26, 0x8C	; 140
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 33       	cpi	r26, 0x35	; 53
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 36 31 	call	0x626c	; 0x626c <main>
      8a:	0c 94 26 33 	jmp	0x664c	; 0x664c <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <pvPortMalloc+0x6>
      98:	00 d0       	rcall	.+0      	; 0x9a <pvPortMalloc+0x8>
      9a:	cd b7       	in	r28, 0x3d	; 61
      9c:	de b7       	in	r29, 0x3e	; 62
      9e:	9c 83       	std	Y+4, r25	; 0x04
      a0:	8b 83       	std	Y+3, r24	; 0x03
    void * pvReturn = NULL;
      a2:	1a 82       	std	Y+2, r1	; 0x02
      a4:	19 82       	std	Y+1, r1	; 0x01
                }
            }
        }
    #endif

    vTaskSuspendAll();
      a6:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
      aa:	80 91 8e 00 	lds	r24, 0x008E
      ae:	90 91 8f 00 	lds	r25, 0x008F
      b2:	00 97       	sbiw	r24, 0x00	; 0
      b4:	31 f4       	brne	.+12     	; 0xc2 <pvPortMalloc+0x30>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
      b6:	80 e9       	ldi	r24, 0x90	; 144
      b8:	90 e0       	ldi	r25, 0x00	; 0
      ba:	90 93 8f 00 	sts	0x008F, r25
      be:	80 93 8e 00 	sts	0x008E, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) && /* valid size */
      c2:	8b 81       	ldd	r24, Y+3	; 0x03
      c4:	9c 81       	ldd	r25, Y+4	; 0x04
      c6:	00 97       	sbiw	r24, 0x00	; 0
      c8:	99 f1       	breq	.+102    	; 0x130 <pvPortMalloc+0x9e>
      ca:	80 91 8c 00 	lds	r24, 0x008C
      ce:	90 91 8d 00 	lds	r25, 0x008D
      d2:	2b 81       	ldd	r18, Y+3	; 0x03
      d4:	3c 81       	ldd	r19, Y+4	; 0x04
      d6:	82 0f       	add	r24, r18
      d8:	93 1f       	adc	r25, r19
      da:	25 e0       	ldi	r18, 0x05	; 5
      dc:	8b 3d       	cpi	r24, 0xDB	; 219
      de:	92 07       	cpc	r25, r18
      e0:	38 f5       	brcc	.+78     	; 0x130 <pvPortMalloc+0x9e>
      e2:	20 91 8c 00 	lds	r18, 0x008C
      e6:	30 91 8d 00 	lds	r19, 0x008D
      ea:	8b 81       	ldd	r24, Y+3	; 0x03
      ec:	9c 81       	ldd	r25, Y+4	; 0x04
      ee:	28 0f       	add	r18, r24
      f0:	39 1f       	adc	r19, r25
      f2:	80 91 8c 00 	lds	r24, 0x008C
      f6:	90 91 8d 00 	lds	r25, 0x008D
      fa:	82 17       	cp	r24, r18
      fc:	93 07       	cpc	r25, r19
      fe:	c0 f4       	brcc	.+48     	; 0x130 <pvPortMalloc+0x9e>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
     100:	20 91 8e 00 	lds	r18, 0x008E
     104:	30 91 8f 00 	lds	r19, 0x008F
     108:	80 91 8c 00 	lds	r24, 0x008C
     10c:	90 91 8d 00 	lds	r25, 0x008D
     110:	82 0f       	add	r24, r18
     112:	93 1f       	adc	r25, r19
     114:	9a 83       	std	Y+2, r25	; 0x02
     116:	89 83       	std	Y+1, r24	; 0x01
            xNextFreeByte += xWantedSize;
     118:	20 91 8c 00 	lds	r18, 0x008C
     11c:	30 91 8d 00 	lds	r19, 0x008D
     120:	8b 81       	ldd	r24, Y+3	; 0x03
     122:	9c 81       	ldd	r25, Y+4	; 0x04
     124:	82 0f       	add	r24, r18
     126:	93 1f       	adc	r25, r19
     128:	90 93 8d 00 	sts	0x008D, r25
     12c:	80 93 8c 00 	sts	0x008C, r24
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
     130:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>
                vApplicationMallocFailedHook();
            }
        }
    #endif

    return pvReturn;
     134:	89 81       	ldd	r24, Y+1	; 0x01
     136:	9a 81       	ldd	r25, Y+2	; 0x02
}
     138:	0f 90       	pop	r0
     13a:	0f 90       	pop	r0
     13c:	0f 90       	pop	r0
     13e:	0f 90       	pop	r0
     140:	cf 91       	pop	r28
     142:	df 91       	pop	r29
     144:	08 95       	ret

00000146 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
     146:	df 93       	push	r29
     148:	cf 93       	push	r28
     14a:	00 d0       	rcall	.+0      	; 0x14c <vPortFree+0x6>
     14c:	cd b7       	in	r28, 0x3d	; 61
     14e:	de b7       	in	r29, 0x3e	; 62
     150:	9a 83       	std	Y+2, r25	; 0x02
     152:	89 83       	std	Y+1, r24	; 0x01
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
     154:	0f 90       	pop	r0
     156:	0f 90       	pop	r0
     158:	cf 91       	pop	r28
     15a:	df 91       	pop	r29
     15c:	08 95       	ret

0000015e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     15e:	df 93       	push	r29
     160:	cf 93       	push	r28
     162:	cd b7       	in	r28, 0x3d	; 61
     164:	de b7       	in	r29, 0x3e	; 62
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
     166:	10 92 8d 00 	sts	0x008D, r1
     16a:	10 92 8c 00 	sts	0x008C, r1
}
     16e:	cf 91       	pop	r28
     170:	df 91       	pop	r29
     172:	08 95       	ret

00000174 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     174:	df 93       	push	r29
     176:	cf 93       	push	r28
     178:	cd b7       	in	r28, 0x3d	; 61
     17a:	de b7       	in	r29, 0x3e	; 62
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     17c:	20 91 8c 00 	lds	r18, 0x008C
     180:	30 91 8d 00 	lds	r19, 0x008D
     184:	8b ed       	ldi	r24, 0xDB	; 219
     186:	95 e0       	ldi	r25, 0x05	; 5
     188:	82 1b       	sub	r24, r18
     18a:	93 0b       	sbc	r25, r19
}
     18c:	cf 91       	pop	r28
     18e:	df 91       	pop	r29
     190:	08 95       	ret

00000192 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     192:	df 93       	push	r29
     194:	cf 93       	push	r28
     196:	cd b7       	in	r28, 0x3d	; 61
     198:	de b7       	in	r29, 0x3e	; 62
     19a:	28 97       	sbiw	r28, 0x08	; 8
     19c:	0f b6       	in	r0, 0x3f	; 63
     19e:	f8 94       	cli
     1a0:	de bf       	out	0x3e, r29	; 62
     1a2:	0f be       	out	0x3f, r0	; 63
     1a4:	cd bf       	out	0x3d, r28	; 61
     1a6:	9c 83       	std	Y+4, r25	; 0x04
     1a8:	8b 83       	std	Y+3, r24	; 0x03
     1aa:	7e 83       	std	Y+6, r23	; 0x06
     1ac:	6d 83       	std	Y+5, r22	; 0x05
     1ae:	58 87       	std	Y+8, r21	; 0x08
     1b0:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     1b2:	eb 81       	ldd	r30, Y+3	; 0x03
     1b4:	fc 81       	ldd	r31, Y+4	; 0x04
     1b6:	81 e1       	ldi	r24, 0x11	; 17
     1b8:	80 83       	st	Z, r24
	pxTopOfStack--;
     1ba:	8b 81       	ldd	r24, Y+3	; 0x03
     1bc:	9c 81       	ldd	r25, Y+4	; 0x04
     1be:	01 97       	sbiw	r24, 0x01	; 1
     1c0:	9c 83       	std	Y+4, r25	; 0x04
     1c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     1c4:	eb 81       	ldd	r30, Y+3	; 0x03
     1c6:	fc 81       	ldd	r31, Y+4	; 0x04
     1c8:	82 e2       	ldi	r24, 0x22	; 34
     1ca:	80 83       	st	Z, r24
	pxTopOfStack--;
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	01 97       	sbiw	r24, 0x01	; 1
     1d2:	9c 83       	std	Y+4, r25	; 0x04
     1d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     1d6:	eb 81       	ldd	r30, Y+3	; 0x03
     1d8:	fc 81       	ldd	r31, Y+4	; 0x04
     1da:	83 e3       	ldi	r24, 0x33	; 51
     1dc:	80 83       	st	Z, r24
	pxTopOfStack--;
     1de:	8b 81       	ldd	r24, Y+3	; 0x03
     1e0:	9c 81       	ldd	r25, Y+4	; 0x04
     1e2:	01 97       	sbiw	r24, 0x01	; 1
     1e4:	9c 83       	std	Y+4, r25	; 0x04
     1e6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     1e8:	8d 81       	ldd	r24, Y+5	; 0x05
     1ea:	9e 81       	ldd	r25, Y+6	; 0x06
     1ec:	9a 83       	std	Y+2, r25	; 0x02
     1ee:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     1f0:	89 81       	ldd	r24, Y+1	; 0x01
     1f2:	eb 81       	ldd	r30, Y+3	; 0x03
     1f4:	fc 81       	ldd	r31, Y+4	; 0x04
     1f6:	80 83       	st	Z, r24
	pxTopOfStack--;
     1f8:	8b 81       	ldd	r24, Y+3	; 0x03
     1fa:	9c 81       	ldd	r25, Y+4	; 0x04
     1fc:	01 97       	sbiw	r24, 0x01	; 1
     1fe:	9c 83       	std	Y+4, r25	; 0x04
     200:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     202:	89 81       	ldd	r24, Y+1	; 0x01
     204:	9a 81       	ldd	r25, Y+2	; 0x02
     206:	89 2f       	mov	r24, r25
     208:	99 27       	eor	r25, r25
     20a:	9a 83       	std	Y+2, r25	; 0x02
     20c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     20e:	89 81       	ldd	r24, Y+1	; 0x01
     210:	eb 81       	ldd	r30, Y+3	; 0x03
     212:	fc 81       	ldd	r31, Y+4	; 0x04
     214:	80 83       	st	Z, r24
	pxTopOfStack--;
     216:	8b 81       	ldd	r24, Y+3	; 0x03
     218:	9c 81       	ldd	r25, Y+4	; 0x04
     21a:	01 97       	sbiw	r24, 0x01	; 1
     21c:	9c 83       	std	Y+4, r25	; 0x04
     21e:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     220:	eb 81       	ldd	r30, Y+3	; 0x03
     222:	fc 81       	ldd	r31, Y+4	; 0x04
     224:	10 82       	st	Z, r1
	pxTopOfStack--;
     226:	8b 81       	ldd	r24, Y+3	; 0x03
     228:	9c 81       	ldd	r25, Y+4	; 0x04
     22a:	01 97       	sbiw	r24, 0x01	; 1
     22c:	9c 83       	std	Y+4, r25	; 0x04
     22e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     230:	eb 81       	ldd	r30, Y+3	; 0x03
     232:	fc 81       	ldd	r31, Y+4	; 0x04
     234:	80 e8       	ldi	r24, 0x80	; 128
     236:	80 83       	st	Z, r24
	pxTopOfStack--;
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	01 97       	sbiw	r24, 0x01	; 1
     23e:	9c 83       	std	Y+4, r25	; 0x04
     240:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     242:	eb 81       	ldd	r30, Y+3	; 0x03
     244:	fc 81       	ldd	r31, Y+4	; 0x04
     246:	10 82       	st	Z, r1
	pxTopOfStack--;
     248:	8b 81       	ldd	r24, Y+3	; 0x03
     24a:	9c 81       	ldd	r25, Y+4	; 0x04
     24c:	01 97       	sbiw	r24, 0x01	; 1
     24e:	9c 83       	std	Y+4, r25	; 0x04
     250:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     252:	eb 81       	ldd	r30, Y+3	; 0x03
     254:	fc 81       	ldd	r31, Y+4	; 0x04
     256:	82 e0       	ldi	r24, 0x02	; 2
     258:	80 83       	st	Z, r24
	pxTopOfStack--;
     25a:	8b 81       	ldd	r24, Y+3	; 0x03
     25c:	9c 81       	ldd	r25, Y+4	; 0x04
     25e:	01 97       	sbiw	r24, 0x01	; 1
     260:	9c 83       	std	Y+4, r25	; 0x04
     262:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     264:	eb 81       	ldd	r30, Y+3	; 0x03
     266:	fc 81       	ldd	r31, Y+4	; 0x04
     268:	83 e0       	ldi	r24, 0x03	; 3
     26a:	80 83       	st	Z, r24
	pxTopOfStack--;
     26c:	8b 81       	ldd	r24, Y+3	; 0x03
     26e:	9c 81       	ldd	r25, Y+4	; 0x04
     270:	01 97       	sbiw	r24, 0x01	; 1
     272:	9c 83       	std	Y+4, r25	; 0x04
     274:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     276:	eb 81       	ldd	r30, Y+3	; 0x03
     278:	fc 81       	ldd	r31, Y+4	; 0x04
     27a:	84 e0       	ldi	r24, 0x04	; 4
     27c:	80 83       	st	Z, r24
	pxTopOfStack--;
     27e:	8b 81       	ldd	r24, Y+3	; 0x03
     280:	9c 81       	ldd	r25, Y+4	; 0x04
     282:	01 97       	sbiw	r24, 0x01	; 1
     284:	9c 83       	std	Y+4, r25	; 0x04
     286:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     288:	eb 81       	ldd	r30, Y+3	; 0x03
     28a:	fc 81       	ldd	r31, Y+4	; 0x04
     28c:	85 e0       	ldi	r24, 0x05	; 5
     28e:	80 83       	st	Z, r24
	pxTopOfStack--;
     290:	8b 81       	ldd	r24, Y+3	; 0x03
     292:	9c 81       	ldd	r25, Y+4	; 0x04
     294:	01 97       	sbiw	r24, 0x01	; 1
     296:	9c 83       	std	Y+4, r25	; 0x04
     298:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     29a:	eb 81       	ldd	r30, Y+3	; 0x03
     29c:	fc 81       	ldd	r31, Y+4	; 0x04
     29e:	86 e0       	ldi	r24, 0x06	; 6
     2a0:	80 83       	st	Z, r24
	pxTopOfStack--;
     2a2:	8b 81       	ldd	r24, Y+3	; 0x03
     2a4:	9c 81       	ldd	r25, Y+4	; 0x04
     2a6:	01 97       	sbiw	r24, 0x01	; 1
     2a8:	9c 83       	std	Y+4, r25	; 0x04
     2aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     2ac:	eb 81       	ldd	r30, Y+3	; 0x03
     2ae:	fc 81       	ldd	r31, Y+4	; 0x04
     2b0:	87 e0       	ldi	r24, 0x07	; 7
     2b2:	80 83       	st	Z, r24
	pxTopOfStack--;
     2b4:	8b 81       	ldd	r24, Y+3	; 0x03
     2b6:	9c 81       	ldd	r25, Y+4	; 0x04
     2b8:	01 97       	sbiw	r24, 0x01	; 1
     2ba:	9c 83       	std	Y+4, r25	; 0x04
     2bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     2be:	eb 81       	ldd	r30, Y+3	; 0x03
     2c0:	fc 81       	ldd	r31, Y+4	; 0x04
     2c2:	88 e0       	ldi	r24, 0x08	; 8
     2c4:	80 83       	st	Z, r24
	pxTopOfStack--;
     2c6:	8b 81       	ldd	r24, Y+3	; 0x03
     2c8:	9c 81       	ldd	r25, Y+4	; 0x04
     2ca:	01 97       	sbiw	r24, 0x01	; 1
     2cc:	9c 83       	std	Y+4, r25	; 0x04
     2ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     2d0:	eb 81       	ldd	r30, Y+3	; 0x03
     2d2:	fc 81       	ldd	r31, Y+4	; 0x04
     2d4:	89 e0       	ldi	r24, 0x09	; 9
     2d6:	80 83       	st	Z, r24
	pxTopOfStack--;
     2d8:	8b 81       	ldd	r24, Y+3	; 0x03
     2da:	9c 81       	ldd	r25, Y+4	; 0x04
     2dc:	01 97       	sbiw	r24, 0x01	; 1
     2de:	9c 83       	std	Y+4, r25	; 0x04
     2e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     2e2:	eb 81       	ldd	r30, Y+3	; 0x03
     2e4:	fc 81       	ldd	r31, Y+4	; 0x04
     2e6:	80 e1       	ldi	r24, 0x10	; 16
     2e8:	80 83       	st	Z, r24
	pxTopOfStack--;
     2ea:	8b 81       	ldd	r24, Y+3	; 0x03
     2ec:	9c 81       	ldd	r25, Y+4	; 0x04
     2ee:	01 97       	sbiw	r24, 0x01	; 1
     2f0:	9c 83       	std	Y+4, r25	; 0x04
     2f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     2f4:	eb 81       	ldd	r30, Y+3	; 0x03
     2f6:	fc 81       	ldd	r31, Y+4	; 0x04
     2f8:	81 e1       	ldi	r24, 0x11	; 17
     2fa:	80 83       	st	Z, r24
	pxTopOfStack--;
     2fc:	8b 81       	ldd	r24, Y+3	; 0x03
     2fe:	9c 81       	ldd	r25, Y+4	; 0x04
     300:	01 97       	sbiw	r24, 0x01	; 1
     302:	9c 83       	std	Y+4, r25	; 0x04
     304:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     306:	eb 81       	ldd	r30, Y+3	; 0x03
     308:	fc 81       	ldd	r31, Y+4	; 0x04
     30a:	82 e1       	ldi	r24, 0x12	; 18
     30c:	80 83       	st	Z, r24
	pxTopOfStack--;
     30e:	8b 81       	ldd	r24, Y+3	; 0x03
     310:	9c 81       	ldd	r25, Y+4	; 0x04
     312:	01 97       	sbiw	r24, 0x01	; 1
     314:	9c 83       	std	Y+4, r25	; 0x04
     316:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     318:	eb 81       	ldd	r30, Y+3	; 0x03
     31a:	fc 81       	ldd	r31, Y+4	; 0x04
     31c:	83 e1       	ldi	r24, 0x13	; 19
     31e:	80 83       	st	Z, r24
	pxTopOfStack--;
     320:	8b 81       	ldd	r24, Y+3	; 0x03
     322:	9c 81       	ldd	r25, Y+4	; 0x04
     324:	01 97       	sbiw	r24, 0x01	; 1
     326:	9c 83       	std	Y+4, r25	; 0x04
     328:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     32a:	eb 81       	ldd	r30, Y+3	; 0x03
     32c:	fc 81       	ldd	r31, Y+4	; 0x04
     32e:	84 e1       	ldi	r24, 0x14	; 20
     330:	80 83       	st	Z, r24
	pxTopOfStack--;
     332:	8b 81       	ldd	r24, Y+3	; 0x03
     334:	9c 81       	ldd	r25, Y+4	; 0x04
     336:	01 97       	sbiw	r24, 0x01	; 1
     338:	9c 83       	std	Y+4, r25	; 0x04
     33a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     33c:	eb 81       	ldd	r30, Y+3	; 0x03
     33e:	fc 81       	ldd	r31, Y+4	; 0x04
     340:	85 e1       	ldi	r24, 0x15	; 21
     342:	80 83       	st	Z, r24
	pxTopOfStack--;
     344:	8b 81       	ldd	r24, Y+3	; 0x03
     346:	9c 81       	ldd	r25, Y+4	; 0x04
     348:	01 97       	sbiw	r24, 0x01	; 1
     34a:	9c 83       	std	Y+4, r25	; 0x04
     34c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     34e:	eb 81       	ldd	r30, Y+3	; 0x03
     350:	fc 81       	ldd	r31, Y+4	; 0x04
     352:	86 e1       	ldi	r24, 0x16	; 22
     354:	80 83       	st	Z, r24
	pxTopOfStack--;
     356:	8b 81       	ldd	r24, Y+3	; 0x03
     358:	9c 81       	ldd	r25, Y+4	; 0x04
     35a:	01 97       	sbiw	r24, 0x01	; 1
     35c:	9c 83       	std	Y+4, r25	; 0x04
     35e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     360:	eb 81       	ldd	r30, Y+3	; 0x03
     362:	fc 81       	ldd	r31, Y+4	; 0x04
     364:	87 e1       	ldi	r24, 0x17	; 23
     366:	80 83       	st	Z, r24
	pxTopOfStack--;
     368:	8b 81       	ldd	r24, Y+3	; 0x03
     36a:	9c 81       	ldd	r25, Y+4	; 0x04
     36c:	01 97       	sbiw	r24, 0x01	; 1
     36e:	9c 83       	std	Y+4, r25	; 0x04
     370:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     372:	eb 81       	ldd	r30, Y+3	; 0x03
     374:	fc 81       	ldd	r31, Y+4	; 0x04
     376:	88 e1       	ldi	r24, 0x18	; 24
     378:	80 83       	st	Z, r24
	pxTopOfStack--;
     37a:	8b 81       	ldd	r24, Y+3	; 0x03
     37c:	9c 81       	ldd	r25, Y+4	; 0x04
     37e:	01 97       	sbiw	r24, 0x01	; 1
     380:	9c 83       	std	Y+4, r25	; 0x04
     382:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     384:	eb 81       	ldd	r30, Y+3	; 0x03
     386:	fc 81       	ldd	r31, Y+4	; 0x04
     388:	89 e1       	ldi	r24, 0x19	; 25
     38a:	80 83       	st	Z, r24
	pxTopOfStack--;
     38c:	8b 81       	ldd	r24, Y+3	; 0x03
     38e:	9c 81       	ldd	r25, Y+4	; 0x04
     390:	01 97       	sbiw	r24, 0x01	; 1
     392:	9c 83       	std	Y+4, r25	; 0x04
     394:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     396:	eb 81       	ldd	r30, Y+3	; 0x03
     398:	fc 81       	ldd	r31, Y+4	; 0x04
     39a:	80 e2       	ldi	r24, 0x20	; 32
     39c:	80 83       	st	Z, r24
	pxTopOfStack--;
     39e:	8b 81       	ldd	r24, Y+3	; 0x03
     3a0:	9c 81       	ldd	r25, Y+4	; 0x04
     3a2:	01 97       	sbiw	r24, 0x01	; 1
     3a4:	9c 83       	std	Y+4, r25	; 0x04
     3a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     3a8:	eb 81       	ldd	r30, Y+3	; 0x03
     3aa:	fc 81       	ldd	r31, Y+4	; 0x04
     3ac:	81 e2       	ldi	r24, 0x21	; 33
     3ae:	80 83       	st	Z, r24
	pxTopOfStack--;
     3b0:	8b 81       	ldd	r24, Y+3	; 0x03
     3b2:	9c 81       	ldd	r25, Y+4	; 0x04
     3b4:	01 97       	sbiw	r24, 0x01	; 1
     3b6:	9c 83       	std	Y+4, r25	; 0x04
     3b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     3ba:	eb 81       	ldd	r30, Y+3	; 0x03
     3bc:	fc 81       	ldd	r31, Y+4	; 0x04
     3be:	82 e2       	ldi	r24, 0x22	; 34
     3c0:	80 83       	st	Z, r24
	pxTopOfStack--;
     3c2:	8b 81       	ldd	r24, Y+3	; 0x03
     3c4:	9c 81       	ldd	r25, Y+4	; 0x04
     3c6:	01 97       	sbiw	r24, 0x01	; 1
     3c8:	9c 83       	std	Y+4, r25	; 0x04
     3ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     3cc:	eb 81       	ldd	r30, Y+3	; 0x03
     3ce:	fc 81       	ldd	r31, Y+4	; 0x04
     3d0:	83 e2       	ldi	r24, 0x23	; 35
     3d2:	80 83       	st	Z, r24
	pxTopOfStack--;
     3d4:	8b 81       	ldd	r24, Y+3	; 0x03
     3d6:	9c 81       	ldd	r25, Y+4	; 0x04
     3d8:	01 97       	sbiw	r24, 0x01	; 1
     3da:	9c 83       	std	Y+4, r25	; 0x04
     3dc:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     3de:	8f 81       	ldd	r24, Y+7	; 0x07
     3e0:	98 85       	ldd	r25, Y+8	; 0x08
     3e2:	9a 83       	std	Y+2, r25	; 0x02
     3e4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     3e6:	89 81       	ldd	r24, Y+1	; 0x01
     3e8:	eb 81       	ldd	r30, Y+3	; 0x03
     3ea:	fc 81       	ldd	r31, Y+4	; 0x04
     3ec:	80 83       	st	Z, r24
	pxTopOfStack--;
     3ee:	8b 81       	ldd	r24, Y+3	; 0x03
     3f0:	9c 81       	ldd	r25, Y+4	; 0x04
     3f2:	01 97       	sbiw	r24, 0x01	; 1
     3f4:	9c 83       	std	Y+4, r25	; 0x04
     3f6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     3f8:	89 81       	ldd	r24, Y+1	; 0x01
     3fa:	9a 81       	ldd	r25, Y+2	; 0x02
     3fc:	89 2f       	mov	r24, r25
     3fe:	99 27       	eor	r25, r25
     400:	9a 83       	std	Y+2, r25	; 0x02
     402:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     404:	89 81       	ldd	r24, Y+1	; 0x01
     406:	eb 81       	ldd	r30, Y+3	; 0x03
     408:	fc 81       	ldd	r31, Y+4	; 0x04
     40a:	80 83       	st	Z, r24
	pxTopOfStack--;
     40c:	8b 81       	ldd	r24, Y+3	; 0x03
     40e:	9c 81       	ldd	r25, Y+4	; 0x04
     410:	01 97       	sbiw	r24, 0x01	; 1
     412:	9c 83       	std	Y+4, r25	; 0x04
     414:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     416:	eb 81       	ldd	r30, Y+3	; 0x03
     418:	fc 81       	ldd	r31, Y+4	; 0x04
     41a:	86 e2       	ldi	r24, 0x26	; 38
     41c:	80 83       	st	Z, r24
	pxTopOfStack--;
     41e:	8b 81       	ldd	r24, Y+3	; 0x03
     420:	9c 81       	ldd	r25, Y+4	; 0x04
     422:	01 97       	sbiw	r24, 0x01	; 1
     424:	9c 83       	std	Y+4, r25	; 0x04
     426:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     428:	eb 81       	ldd	r30, Y+3	; 0x03
     42a:	fc 81       	ldd	r31, Y+4	; 0x04
     42c:	87 e2       	ldi	r24, 0x27	; 39
     42e:	80 83       	st	Z, r24
	pxTopOfStack--;
     430:	8b 81       	ldd	r24, Y+3	; 0x03
     432:	9c 81       	ldd	r25, Y+4	; 0x04
     434:	01 97       	sbiw	r24, 0x01	; 1
     436:	9c 83       	std	Y+4, r25	; 0x04
     438:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     43a:	eb 81       	ldd	r30, Y+3	; 0x03
     43c:	fc 81       	ldd	r31, Y+4	; 0x04
     43e:	88 e2       	ldi	r24, 0x28	; 40
     440:	80 83       	st	Z, r24
	pxTopOfStack--;
     442:	8b 81       	ldd	r24, Y+3	; 0x03
     444:	9c 81       	ldd	r25, Y+4	; 0x04
     446:	01 97       	sbiw	r24, 0x01	; 1
     448:	9c 83       	std	Y+4, r25	; 0x04
     44a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     44c:	eb 81       	ldd	r30, Y+3	; 0x03
     44e:	fc 81       	ldd	r31, Y+4	; 0x04
     450:	89 e2       	ldi	r24, 0x29	; 41
     452:	80 83       	st	Z, r24
	pxTopOfStack--;
     454:	8b 81       	ldd	r24, Y+3	; 0x03
     456:	9c 81       	ldd	r25, Y+4	; 0x04
     458:	01 97       	sbiw	r24, 0x01	; 1
     45a:	9c 83       	std	Y+4, r25	; 0x04
     45c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     45e:	eb 81       	ldd	r30, Y+3	; 0x03
     460:	fc 81       	ldd	r31, Y+4	; 0x04
     462:	80 e3       	ldi	r24, 0x30	; 48
     464:	80 83       	st	Z, r24
	pxTopOfStack--;
     466:	8b 81       	ldd	r24, Y+3	; 0x03
     468:	9c 81       	ldd	r25, Y+4	; 0x04
     46a:	01 97       	sbiw	r24, 0x01	; 1
     46c:	9c 83       	std	Y+4, r25	; 0x04
     46e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     470:	eb 81       	ldd	r30, Y+3	; 0x03
     472:	fc 81       	ldd	r31, Y+4	; 0x04
     474:	81 e3       	ldi	r24, 0x31	; 49
     476:	80 83       	st	Z, r24
	pxTopOfStack--;
     478:	8b 81       	ldd	r24, Y+3	; 0x03
     47a:	9c 81       	ldd	r25, Y+4	; 0x04
     47c:	01 97       	sbiw	r24, 0x01	; 1
     47e:	9c 83       	std	Y+4, r25	; 0x04
     480:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     482:	8b 81       	ldd	r24, Y+3	; 0x03
     484:	9c 81       	ldd	r25, Y+4	; 0x04
}
     486:	28 96       	adiw	r28, 0x08	; 8
     488:	0f b6       	in	r0, 0x3f	; 63
     48a:	f8 94       	cli
     48c:	de bf       	out	0x3e, r29	; 62
     48e:	0f be       	out	0x3f, r0	; 63
     490:	cd bf       	out	0x3d, r28	; 61
     492:	cf 91       	pop	r28
     494:	df 91       	pop	r29
     496:	08 95       	ret

00000498 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     498:	df 93       	push	r29
     49a:	cf 93       	push	r28
     49c:	cd b7       	in	r28, 0x3d	; 61
     49e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     4a0:	0e 94 3e 03 	call	0x67c	; 0x67c <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     4a4:	a0 91 a6 06 	lds	r26, 0x06A6
     4a8:	b0 91 a7 06 	lds	r27, 0x06A7
     4ac:	cd 91       	ld	r28, X+
     4ae:	cd bf       	out	0x3d, r28	; 61
     4b0:	dd 91       	ld	r29, X+
     4b2:	de bf       	out	0x3e, r29	; 62
     4b4:	ff 91       	pop	r31
     4b6:	ef 91       	pop	r30
     4b8:	df 91       	pop	r29
     4ba:	cf 91       	pop	r28
     4bc:	bf 91       	pop	r27
     4be:	af 91       	pop	r26
     4c0:	9f 91       	pop	r25
     4c2:	8f 91       	pop	r24
     4c4:	7f 91       	pop	r23
     4c6:	6f 91       	pop	r22
     4c8:	5f 91       	pop	r21
     4ca:	4f 91       	pop	r20
     4cc:	3f 91       	pop	r19
     4ce:	2f 91       	pop	r18
     4d0:	1f 91       	pop	r17
     4d2:	0f 91       	pop	r16
     4d4:	ff 90       	pop	r15
     4d6:	ef 90       	pop	r14
     4d8:	df 90       	pop	r13
     4da:	cf 90       	pop	r12
     4dc:	bf 90       	pop	r11
     4de:	af 90       	pop	r10
     4e0:	9f 90       	pop	r9
     4e2:	8f 90       	pop	r8
     4e4:	7f 90       	pop	r7
     4e6:	6f 90       	pop	r6
     4e8:	5f 90       	pop	r5
     4ea:	4f 90       	pop	r4
     4ec:	3f 90       	pop	r3
     4ee:	2f 90       	pop	r2
     4f0:	1f 90       	pop	r1
     4f2:	0f 90       	pop	r0
     4f4:	0f be       	out	0x3f, r0	; 63
     4f6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     4f8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     4fa:	81 e0       	ldi	r24, 0x01	; 1
}
     4fc:	cf 91       	pop	r28
     4fe:	df 91       	pop	r29
     500:	08 95       	ret

00000502 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     502:	df 93       	push	r29
     504:	cf 93       	push	r28
     506:	cd b7       	in	r28, 0x3d	; 61
     508:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     50a:	cf 91       	pop	r28
     50c:	df 91       	pop	r29
     50e:	08 95       	ret

00000510 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     510:	0f 92       	push	r0
     512:	0f b6       	in	r0, 0x3f	; 63
     514:	f8 94       	cli
     516:	0f 92       	push	r0
     518:	1f 92       	push	r1
     51a:	11 24       	eor	r1, r1
     51c:	2f 92       	push	r2
     51e:	3f 92       	push	r3
     520:	4f 92       	push	r4
     522:	5f 92       	push	r5
     524:	6f 92       	push	r6
     526:	7f 92       	push	r7
     528:	8f 92       	push	r8
     52a:	9f 92       	push	r9
     52c:	af 92       	push	r10
     52e:	bf 92       	push	r11
     530:	cf 92       	push	r12
     532:	df 92       	push	r13
     534:	ef 92       	push	r14
     536:	ff 92       	push	r15
     538:	0f 93       	push	r16
     53a:	1f 93       	push	r17
     53c:	2f 93       	push	r18
     53e:	3f 93       	push	r19
     540:	4f 93       	push	r20
     542:	5f 93       	push	r21
     544:	6f 93       	push	r22
     546:	7f 93       	push	r23
     548:	8f 93       	push	r24
     54a:	9f 93       	push	r25
     54c:	af 93       	push	r26
     54e:	bf 93       	push	r27
     550:	cf 93       	push	r28
     552:	df 93       	push	r29
     554:	ef 93       	push	r30
     556:	ff 93       	push	r31
     558:	a0 91 a6 06 	lds	r26, 0x06A6
     55c:	b0 91 a7 06 	lds	r27, 0x06A7
     560:	0d b6       	in	r0, 0x3d	; 61
     562:	0d 92       	st	X+, r0
     564:	0e b6       	in	r0, 0x3e	; 62
     566:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     568:	0e 94 0e 1b 	call	0x361c	; 0x361c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     56c:	a0 91 a6 06 	lds	r26, 0x06A6
     570:	b0 91 a7 06 	lds	r27, 0x06A7
     574:	cd 91       	ld	r28, X+
     576:	cd bf       	out	0x3d, r28	; 61
     578:	dd 91       	ld	r29, X+
     57a:	de bf       	out	0x3e, r29	; 62
     57c:	ff 91       	pop	r31
     57e:	ef 91       	pop	r30
     580:	df 91       	pop	r29
     582:	cf 91       	pop	r28
     584:	bf 91       	pop	r27
     586:	af 91       	pop	r26
     588:	9f 91       	pop	r25
     58a:	8f 91       	pop	r24
     58c:	7f 91       	pop	r23
     58e:	6f 91       	pop	r22
     590:	5f 91       	pop	r21
     592:	4f 91       	pop	r20
     594:	3f 91       	pop	r19
     596:	2f 91       	pop	r18
     598:	1f 91       	pop	r17
     59a:	0f 91       	pop	r16
     59c:	ff 90       	pop	r15
     59e:	ef 90       	pop	r14
     5a0:	df 90       	pop	r13
     5a2:	cf 90       	pop	r12
     5a4:	bf 90       	pop	r11
     5a6:	af 90       	pop	r10
     5a8:	9f 90       	pop	r9
     5aa:	8f 90       	pop	r8
     5ac:	7f 90       	pop	r7
     5ae:	6f 90       	pop	r6
     5b0:	5f 90       	pop	r5
     5b2:	4f 90       	pop	r4
     5b4:	3f 90       	pop	r3
     5b6:	2f 90       	pop	r2
     5b8:	1f 90       	pop	r1
     5ba:	0f 90       	pop	r0
     5bc:	0f be       	out	0x3f, r0	; 63
     5be:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5c0:	08 95       	ret

000005c2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     5c2:	0f 92       	push	r0
     5c4:	0f b6       	in	r0, 0x3f	; 63
     5c6:	f8 94       	cli
     5c8:	0f 92       	push	r0
     5ca:	1f 92       	push	r1
     5cc:	11 24       	eor	r1, r1
     5ce:	2f 92       	push	r2
     5d0:	3f 92       	push	r3
     5d2:	4f 92       	push	r4
     5d4:	5f 92       	push	r5
     5d6:	6f 92       	push	r6
     5d8:	7f 92       	push	r7
     5da:	8f 92       	push	r8
     5dc:	9f 92       	push	r9
     5de:	af 92       	push	r10
     5e0:	bf 92       	push	r11
     5e2:	cf 92       	push	r12
     5e4:	df 92       	push	r13
     5e6:	ef 92       	push	r14
     5e8:	ff 92       	push	r15
     5ea:	0f 93       	push	r16
     5ec:	1f 93       	push	r17
     5ee:	2f 93       	push	r18
     5f0:	3f 93       	push	r19
     5f2:	4f 93       	push	r20
     5f4:	5f 93       	push	r21
     5f6:	6f 93       	push	r22
     5f8:	7f 93       	push	r23
     5fa:	8f 93       	push	r24
     5fc:	9f 93       	push	r25
     5fe:	af 93       	push	r26
     600:	bf 93       	push	r27
     602:	cf 93       	push	r28
     604:	df 93       	push	r29
     606:	ef 93       	push	r30
     608:	ff 93       	push	r31
     60a:	a0 91 a6 06 	lds	r26, 0x06A6
     60e:	b0 91 a7 06 	lds	r27, 0x06A7
     612:	0d b6       	in	r0, 0x3d	; 61
     614:	0d 92       	st	X+, r0
     616:	0e b6       	in	r0, 0x3e	; 62
     618:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     61a:	0e 94 77 19 	call	0x32ee	; 0x32ee <xTaskIncrementTick>
     61e:	88 23       	and	r24, r24
     620:	11 f0       	breq	.+4      	; 0x626 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     622:	0e 94 0e 1b 	call	0x361c	; 0x361c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     626:	a0 91 a6 06 	lds	r26, 0x06A6
     62a:	b0 91 a7 06 	lds	r27, 0x06A7
     62e:	cd 91       	ld	r28, X+
     630:	cd bf       	out	0x3d, r28	; 61
     632:	dd 91       	ld	r29, X+
     634:	de bf       	out	0x3e, r29	; 62
     636:	ff 91       	pop	r31
     638:	ef 91       	pop	r30
     63a:	df 91       	pop	r29
     63c:	cf 91       	pop	r28
     63e:	bf 91       	pop	r27
     640:	af 91       	pop	r26
     642:	9f 91       	pop	r25
     644:	8f 91       	pop	r24
     646:	7f 91       	pop	r23
     648:	6f 91       	pop	r22
     64a:	5f 91       	pop	r21
     64c:	4f 91       	pop	r20
     64e:	3f 91       	pop	r19
     650:	2f 91       	pop	r18
     652:	1f 91       	pop	r17
     654:	0f 91       	pop	r16
     656:	ff 90       	pop	r15
     658:	ef 90       	pop	r14
     65a:	df 90       	pop	r13
     65c:	cf 90       	pop	r12
     65e:	bf 90       	pop	r11
     660:	af 90       	pop	r10
     662:	9f 90       	pop	r9
     664:	8f 90       	pop	r8
     666:	7f 90       	pop	r7
     668:	6f 90       	pop	r6
     66a:	5f 90       	pop	r5
     66c:	4f 90       	pop	r4
     66e:	3f 90       	pop	r3
     670:	2f 90       	pop	r2
     672:	1f 90       	pop	r1
     674:	0f 90       	pop	r0
     676:	0f be       	out	0x3f, r0	; 63
     678:	0f 90       	pop	r0

	asm volatile ( "ret" );
     67a:	08 95       	ret

0000067c <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     67c:	df 93       	push	r29
     67e:	cf 93       	push	r28
     680:	00 d0       	rcall	.+0      	; 0x682 <prvSetupTimerInterrupt+0x6>
     682:	00 d0       	rcall	.+0      	; 0x684 <prvSetupTimerInterrupt+0x8>
     684:	00 d0       	rcall	.+0      	; 0x686 <prvSetupTimerInterrupt+0xa>
     686:	cd b7       	in	r28, 0x3d	; 61
     688:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     68a:	80 e4       	ldi	r24, 0x40	; 64
     68c:	9f e1       	ldi	r25, 0x1F	; 31
     68e:	a0 e0       	ldi	r26, 0x00	; 0
     690:	b0 e0       	ldi	r27, 0x00	; 0
     692:	8b 83       	std	Y+3, r24	; 0x03
     694:	9c 83       	std	Y+4, r25	; 0x04
     696:	ad 83       	std	Y+5, r26	; 0x05
     698:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     69a:	8b 81       	ldd	r24, Y+3	; 0x03
     69c:	9c 81       	ldd	r25, Y+4	; 0x04
     69e:	ad 81       	ldd	r26, Y+5	; 0x05
     6a0:	be 81       	ldd	r27, Y+6	; 0x06
     6a2:	68 94       	set
     6a4:	15 f8       	bld	r1, 5
     6a6:	b6 95       	lsr	r27
     6a8:	a7 95       	ror	r26
     6aa:	97 95       	ror	r25
     6ac:	87 95       	ror	r24
     6ae:	16 94       	lsr	r1
     6b0:	d1 f7       	brne	.-12     	; 0x6a6 <prvSetupTimerInterrupt+0x2a>
     6b2:	8b 83       	std	Y+3, r24	; 0x03
     6b4:	9c 83       	std	Y+4, r25	; 0x04
     6b6:	ad 83       	std	Y+5, r26	; 0x05
     6b8:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     6ba:	8b 81       	ldd	r24, Y+3	; 0x03
     6bc:	9c 81       	ldd	r25, Y+4	; 0x04
     6be:	ad 81       	ldd	r26, Y+5	; 0x05
     6c0:	be 81       	ldd	r27, Y+6	; 0x06
     6c2:	01 97       	sbiw	r24, 0x01	; 1
     6c4:	a1 09       	sbc	r26, r1
     6c6:	b1 09       	sbc	r27, r1
     6c8:	8b 83       	std	Y+3, r24	; 0x03
     6ca:	9c 83       	std	Y+4, r25	; 0x04
     6cc:	ad 83       	std	Y+5, r26	; 0x05
     6ce:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     6d0:	8b 81       	ldd	r24, Y+3	; 0x03
     6d2:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     6d4:	8b 81       	ldd	r24, Y+3	; 0x03
     6d6:	9c 81       	ldd	r25, Y+4	; 0x04
     6d8:	ad 81       	ldd	r26, Y+5	; 0x05
     6da:	be 81       	ldd	r27, Y+6	; 0x06
     6dc:	89 2f       	mov	r24, r25
     6de:	9a 2f       	mov	r25, r26
     6e0:	ab 2f       	mov	r26, r27
     6e2:	bb 27       	eor	r27, r27
     6e4:	8b 83       	std	Y+3, r24	; 0x03
     6e6:	9c 83       	std	Y+4, r25	; 0x04
     6e8:	ad 83       	std	Y+5, r26	; 0x05
     6ea:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     6ec:	8b 81       	ldd	r24, Y+3	; 0x03
     6ee:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     6f0:	eb e4       	ldi	r30, 0x4B	; 75
     6f2:	f0 e0       	ldi	r31, 0x00	; 0
     6f4:	8a 81       	ldd	r24, Y+2	; 0x02
     6f6:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     6f8:	ea e4       	ldi	r30, 0x4A	; 74
     6fa:	f0 e0       	ldi	r31, 0x00	; 0
     6fc:	89 81       	ldd	r24, Y+1	; 0x01
     6fe:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     700:	8b e0       	ldi	r24, 0x0B	; 11
     702:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     704:	ee e4       	ldi	r30, 0x4E	; 78
     706:	f0 e0       	ldi	r31, 0x00	; 0
     708:	89 81       	ldd	r24, Y+1	; 0x01
     70a:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     70c:	e9 e5       	ldi	r30, 0x59	; 89
     70e:	f0 e0       	ldi	r31, 0x00	; 0
     710:	80 81       	ld	r24, Z
     712:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     714:	89 81       	ldd	r24, Y+1	; 0x01
     716:	80 61       	ori	r24, 0x10	; 16
     718:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
     71a:	e9 e5       	ldi	r30, 0x59	; 89
     71c:	f0 e0       	ldi	r31, 0x00	; 0
     71e:	89 81       	ldd	r24, Y+1	; 0x01
     720:	80 83       	st	Z, r24
}
     722:	26 96       	adiw	r28, 0x06	; 6
     724:	0f b6       	in	r0, 0x3f	; 63
     726:	f8 94       	cli
     728:	de bf       	out	0x3e, r29	; 62
     72a:	0f be       	out	0x3f, r0	; 63
     72c:	cd bf       	out	0x3d, r28	; 61
     72e:	cf 91       	pop	r28
     730:	df 91       	pop	r29
     732:	08 95       	ret

00000734 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     734:	0e 94 e1 02 	call	0x5c2	; 0x5c2 <vPortYieldFromTick>
		asm volatile ( "reti" );
     738:	18 95       	reti

0000073a <xCoRoutineCreate>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode,
                                 UBaseType_t uxPriority,
                                 UBaseType_t uxIndex )
    {
     73a:	df 93       	push	r29
     73c:	cf 93       	push	r28
     73e:	cd b7       	in	r28, 0x3d	; 61
     740:	de b7       	in	r29, 0x3e	; 62
     742:	27 97       	sbiw	r28, 0x07	; 7
     744:	0f b6       	in	r0, 0x3f	; 63
     746:	f8 94       	cli
     748:	de bf       	out	0x3e, r29	; 62
     74a:	0f be       	out	0x3f, r0	; 63
     74c:	cd bf       	out	0x3d, r28	; 61
     74e:	9d 83       	std	Y+5, r25	; 0x05
     750:	8c 83       	std	Y+4, r24	; 0x04
     752:	6e 83       	std	Y+6, r22	; 0x06
     754:	4f 83       	std	Y+7, r20	; 0x07
        BaseType_t xReturn;
        CRCB_t * pxCoRoutine;

        /* Allocate the memory that will store the co-routine control block. */
        pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
     756:	8a e1       	ldi	r24, 0x1A	; 26
     758:	90 e0       	ldi	r25, 0x00	; 0
     75a:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     75e:	9a 83       	std	Y+2, r25	; 0x02
     760:	89 83       	std	Y+1, r24	; 0x01

        if( pxCoRoutine )
     762:	89 81       	ldd	r24, Y+1	; 0x01
     764:	9a 81       	ldd	r25, Y+2	; 0x02
     766:	00 97       	sbiw	r24, 0x00	; 0
     768:	09 f4       	brne	.+2      	; 0x76c <xCoRoutineCreate+0x32>
     76a:	6f c0       	rjmp	.+222    	; 0x84a <xCoRoutineCreate+0x110>
        {
            /* If pxCurrentCoRoutine is NULL then this is the first co-routine to
            * be created and the co-routine data structures need initialising. */
            if( pxCurrentCoRoutine == NULL )
     76c:	80 91 70 06 	lds	r24, 0x0670
     770:	90 91 71 06 	lds	r25, 0x0671
     774:	00 97       	sbiw	r24, 0x00	; 0
     776:	41 f4       	brne	.+16     	; 0x788 <xCoRoutineCreate+0x4e>
            {
                pxCurrentCoRoutine = pxCoRoutine;
     778:	89 81       	ldd	r24, Y+1	; 0x01
     77a:	9a 81       	ldd	r25, Y+2	; 0x02
     77c:	90 93 71 06 	sts	0x0671, r25
     780:	80 93 70 06 	sts	0x0670, r24
                prvInitialiseCoRoutineLists();
     784:	0e 94 0b 06 	call	0xc16	; 0xc16 <prvInitialiseCoRoutineLists>
            }

            /* Check the priority is within limits. */
            if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     788:	8e 81       	ldd	r24, Y+6	; 0x06
     78a:	82 30       	cpi	r24, 0x02	; 2
     78c:	10 f0       	brcs	.+4      	; 0x792 <xCoRoutineCreate+0x58>
            {
                uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     78e:	81 e0       	ldi	r24, 0x01	; 1
     790:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Fill out the co-routine control block from the function parameters. */
            pxCoRoutine->uxState = corINITIAL_STATE;
     792:	e9 81       	ldd	r30, Y+1	; 0x01
     794:	fa 81       	ldd	r31, Y+2	; 0x02
     796:	11 8e       	std	Z+25, r1	; 0x19
     798:	10 8e       	std	Z+24, r1	; 0x18
            pxCoRoutine->uxPriority = uxPriority;
     79a:	e9 81       	ldd	r30, Y+1	; 0x01
     79c:	fa 81       	ldd	r31, Y+2	; 0x02
     79e:	8e 81       	ldd	r24, Y+6	; 0x06
     7a0:	86 8b       	std	Z+22, r24	; 0x16
            pxCoRoutine->uxIndex = uxIndex;
     7a2:	e9 81       	ldd	r30, Y+1	; 0x01
     7a4:	fa 81       	ldd	r31, Y+2	; 0x02
     7a6:	8f 81       	ldd	r24, Y+7	; 0x07
     7a8:	87 8b       	std	Z+23, r24	; 0x17
            pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     7aa:	e9 81       	ldd	r30, Y+1	; 0x01
     7ac:	fa 81       	ldd	r31, Y+2	; 0x02
     7ae:	8c 81       	ldd	r24, Y+4	; 0x04
     7b0:	9d 81       	ldd	r25, Y+5	; 0x05
     7b2:	91 83       	std	Z+1, r25	; 0x01
     7b4:	80 83       	st	Z, r24

            /* Initialise all the other co-routine control block parameters. */
            vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     7b6:	89 81       	ldd	r24, Y+1	; 0x01
     7b8:	9a 81       	ldd	r25, Y+2	; 0x02
     7ba:	02 96       	adiw	r24, 0x02	; 2
     7bc:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <vListInitialiseItem>
            vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     7c0:	89 81       	ldd	r24, Y+1	; 0x01
     7c2:	9a 81       	ldd	r25, Y+2	; 0x02
     7c4:	0c 96       	adiw	r24, 0x0c	; 12
     7c6:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <vListInitialiseItem>

            /* Set the co-routine control block as a link back from the ListItem_t.
             * This is so we can get back to the containing CRCB from a generic item
             * in a list. */
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     7ca:	e9 81       	ldd	r30, Y+1	; 0x01
     7cc:	fa 81       	ldd	r31, Y+2	; 0x02
     7ce:	89 81       	ldd	r24, Y+1	; 0x01
     7d0:	9a 81       	ldd	r25, Y+2	; 0x02
     7d2:	91 87       	std	Z+9, r25	; 0x09
     7d4:	80 87       	std	Z+8, r24	; 0x08
            listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     7d6:	e9 81       	ldd	r30, Y+1	; 0x01
     7d8:	fa 81       	ldd	r31, Y+2	; 0x02
     7da:	89 81       	ldd	r24, Y+1	; 0x01
     7dc:	9a 81       	ldd	r25, Y+2	; 0x02
     7de:	93 8b       	std	Z+19, r25	; 0x13
     7e0:	82 8b       	std	Z+18, r24	; 0x12

            /* Event lists are always in priority order. */
            listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
     7e2:	8e 81       	ldd	r24, Y+6	; 0x06
     7e4:	28 2f       	mov	r18, r24
     7e6:	30 e0       	ldi	r19, 0x00	; 0
     7e8:	82 e0       	ldi	r24, 0x02	; 2
     7ea:	90 e0       	ldi	r25, 0x00	; 0
     7ec:	82 1b       	sub	r24, r18
     7ee:	93 0b       	sbc	r25, r19
     7f0:	e9 81       	ldd	r30, Y+1	; 0x01
     7f2:	fa 81       	ldd	r31, Y+2	; 0x02
     7f4:	95 87       	std	Z+13, r25	; 0x0d
     7f6:	84 87       	std	Z+12, r24	; 0x0c

            /* Now the co-routine has been initialised it can be added to the ready
             * list at the correct priority. */
            prvAddCoRoutineToReadyQueue( pxCoRoutine );
     7f8:	e9 81       	ldd	r30, Y+1	; 0x01
     7fa:	fa 81       	ldd	r31, Y+2	; 0x02
     7fc:	96 89       	ldd	r25, Z+22	; 0x16
     7fe:	80 91 72 06 	lds	r24, 0x0672
     802:	89 17       	cp	r24, r25
     804:	28 f4       	brcc	.+10     	; 0x810 <xCoRoutineCreate+0xd6>
     806:	e9 81       	ldd	r30, Y+1	; 0x01
     808:	fa 81       	ldd	r31, Y+2	; 0x02
     80a:	86 89       	ldd	r24, Z+22	; 0x16
     80c:	80 93 72 06 	sts	0x0672, r24
     810:	e9 81       	ldd	r30, Y+1	; 0x01
     812:	fa 81       	ldd	r31, Y+2	; 0x02
     814:	86 89       	ldd	r24, Z+22	; 0x16
     816:	28 2f       	mov	r18, r24
     818:	30 e0       	ldi	r19, 0x00	; 0
     81a:	c9 01       	movw	r24, r18
     81c:	88 0f       	add	r24, r24
     81e:	99 1f       	adc	r25, r25
     820:	88 0f       	add	r24, r24
     822:	99 1f       	adc	r25, r25
     824:	88 0f       	add	r24, r24
     826:	99 1f       	adc	r25, r25
     828:	82 0f       	add	r24, r18
     82a:	93 1f       	adc	r25, r19
     82c:	ac 01       	movw	r20, r24
     82e:	47 58       	subi	r20, 0x87	; 135
     830:	59 4f       	sbci	r21, 0xF9	; 249
     832:	89 81       	ldd	r24, Y+1	; 0x01
     834:	9a 81       	ldd	r25, Y+2	; 0x02
     836:	9c 01       	movw	r18, r24
     838:	2e 5f       	subi	r18, 0xFE	; 254
     83a:	3f 4f       	sbci	r19, 0xFF	; 255
     83c:	ca 01       	movw	r24, r20
     83e:	b9 01       	movw	r22, r18
     840:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vListInsertEnd>

            xReturn = pdPASS;
     844:	81 e0       	ldi	r24, 0x01	; 1
     846:	8b 83       	std	Y+3, r24	; 0x03
     848:	02 c0       	rjmp	.+4      	; 0x84e <xCoRoutineCreate+0x114>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     84a:	8f ef       	ldi	r24, 0xFF	; 255
     84c:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
     84e:	8b 81       	ldd	r24, Y+3	; 0x03
    }
     850:	27 96       	adiw	r28, 0x07	; 7
     852:	0f b6       	in	r0, 0x3f	; 63
     854:	f8 94       	cli
     856:	de bf       	out	0x3e, r29	; 62
     858:	0f be       	out	0x3f, r0	; 63
     85a:	cd bf       	out	0x3d, r28	; 61
     85c:	cf 91       	pop	r28
     85e:	df 91       	pop	r29
     860:	08 95       	ret

00000862 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

    void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay,
                                     List_t * pxEventList )
    {
     862:	df 93       	push	r29
     864:	cf 93       	push	r28
     866:	00 d0       	rcall	.+0      	; 0x868 <vCoRoutineAddToDelayedList+0x6>
     868:	00 d0       	rcall	.+0      	; 0x86a <vCoRoutineAddToDelayedList+0x8>
     86a:	00 d0       	rcall	.+0      	; 0x86c <vCoRoutineAddToDelayedList+0xa>
     86c:	cd b7       	in	r28, 0x3d	; 61
     86e:	de b7       	in	r29, 0x3e	; 62
     870:	9c 83       	std	Y+4, r25	; 0x04
     872:	8b 83       	std	Y+3, r24	; 0x03
     874:	7e 83       	std	Y+6, r23	; 0x06
     876:	6d 83       	std	Y+5, r22	; 0x05
        TickType_t xTimeToWake;

        /* Calculate the time to wake - this may overflow but this is
         * not a problem. */
        xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     878:	20 91 73 06 	lds	r18, 0x0673
     87c:	30 91 74 06 	lds	r19, 0x0674
     880:	8b 81       	ldd	r24, Y+3	; 0x03
     882:	9c 81       	ldd	r25, Y+4	; 0x04
     884:	82 0f       	add	r24, r18
     886:	93 1f       	adc	r25, r19
     888:	9a 83       	std	Y+2, r25	; 0x02
     88a:	89 83       	std	Y+1, r24	; 0x01

        /* We must remove ourselves from the ready list before adding
         * ourselves to the blocked list as the same list item is used for
         * both lists. */
        ( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     88c:	80 91 70 06 	lds	r24, 0x0670
     890:	90 91 71 06 	lds	r25, 0x0671
     894:	02 96       	adiw	r24, 0x02	; 2
     896:	0e 94 ab 0a 	call	0x1556	; 0x1556 <uxListRemove>

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     89a:	e0 91 70 06 	lds	r30, 0x0670
     89e:	f0 91 71 06 	lds	r31, 0x0671
     8a2:	89 81       	ldd	r24, Y+1	; 0x01
     8a4:	9a 81       	ldd	r25, Y+2	; 0x02
     8a6:	93 83       	std	Z+3, r25	; 0x03
     8a8:	82 83       	std	Z+2, r24	; 0x02

        if( xTimeToWake < xCoRoutineTickCount )
     8aa:	20 91 73 06 	lds	r18, 0x0673
     8ae:	30 91 74 06 	lds	r19, 0x0674
     8b2:	89 81       	ldd	r24, Y+1	; 0x01
     8b4:	9a 81       	ldd	r25, Y+2	; 0x02
     8b6:	82 17       	cp	r24, r18
     8b8:	93 07       	cpc	r25, r19
     8ba:	70 f4       	brcc	.+28     	; 0x8d8 <vCoRoutineAddToDelayedList+0x76>
        {
            /* Wake time has overflowed.  Place this item in the
             * overflow list. */
            vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     8bc:	80 91 6e 06 	lds	r24, 0x066E
     8c0:	90 91 6f 06 	lds	r25, 0x066F
     8c4:	20 91 70 06 	lds	r18, 0x0670
     8c8:	30 91 71 06 	lds	r19, 0x0671
     8cc:	2e 5f       	subi	r18, 0xFE	; 254
     8ce:	3f 4f       	sbci	r19, 0xFF	; 255
     8d0:	b9 01       	movw	r22, r18
     8d2:	0e 94 3f 0a 	call	0x147e	; 0x147e <vListInsert>
     8d6:	0d c0       	rjmp	.+26     	; 0x8f2 <vCoRoutineAddToDelayedList+0x90>
        }
        else
        {
            /* The wake time has not overflowed, so we can use the
             * current block list. */
            vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     8d8:	80 91 6c 06 	lds	r24, 0x066C
     8dc:	90 91 6d 06 	lds	r25, 0x066D
     8e0:	20 91 70 06 	lds	r18, 0x0670
     8e4:	30 91 71 06 	lds	r19, 0x0671
     8e8:	2e 5f       	subi	r18, 0xFE	; 254
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	b9 01       	movw	r22, r18
     8ee:	0e 94 3f 0a 	call	0x147e	; 0x147e <vListInsert>
        }

        if( pxEventList )
     8f2:	8d 81       	ldd	r24, Y+5	; 0x05
     8f4:	9e 81       	ldd	r25, Y+6	; 0x06
     8f6:	00 97       	sbiw	r24, 0x00	; 0
     8f8:	61 f0       	breq	.+24     	; 0x912 <vCoRoutineAddToDelayedList+0xb0>
        {
            /* Also add the co-routine to an event list.  If this is done then the
             * function must be called with interrupts disabled. */
            vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     8fa:	80 91 70 06 	lds	r24, 0x0670
     8fe:	90 91 71 06 	lds	r25, 0x0671
     902:	9c 01       	movw	r18, r24
     904:	24 5f       	subi	r18, 0xF4	; 244
     906:	3f 4f       	sbci	r19, 0xFF	; 255
     908:	8d 81       	ldd	r24, Y+5	; 0x05
     90a:	9e 81       	ldd	r25, Y+6	; 0x06
     90c:	b9 01       	movw	r22, r18
     90e:	0e 94 3f 0a 	call	0x147e	; 0x147e <vListInsert>
        }
    }
     912:	26 96       	adiw	r28, 0x06	; 6
     914:	0f b6       	in	r0, 0x3f	; 63
     916:	f8 94       	cli
     918:	de bf       	out	0x3e, r29	; 62
     91a:	0f be       	out	0x3f, r0	; 63
     91c:	cd bf       	out	0x3d, r28	; 61
     91e:	cf 91       	pop	r28
     920:	df 91       	pop	r29
     922:	08 95       	ret

00000924 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

    static void prvCheckPendingReadyList( void )
    {
     924:	df 93       	push	r29
     926:	cf 93       	push	r28
     928:	00 d0       	rcall	.+0      	; 0x92a <prvCheckPendingReadyList+0x6>
     92a:	cd b7       	in	r28, 0x3d	; 61
     92c:	de b7       	in	r29, 0x3e	; 62
     92e:	3a c0       	rjmp	.+116    	; 0x9a4 <prvCheckPendingReadyList+0x80>
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
        {
            CRCB_t * pxUnblockedCRCB;

            /* The pending ready list can be accessed by an ISR. */
            portDISABLE_INTERRUPTS();
     930:	f8 94       	cli
            {
                pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyCoRoutineList ) );
     932:	e0 91 a2 06 	lds	r30, 0x06A2
     936:	f0 91 a3 06 	lds	r31, 0x06A3
     93a:	86 81       	ldd	r24, Z+6	; 0x06
     93c:	97 81       	ldd	r25, Z+7	; 0x07
     93e:	9a 83       	std	Y+2, r25	; 0x02
     940:	89 83       	std	Y+1, r24	; 0x01
                ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     942:	89 81       	ldd	r24, Y+1	; 0x01
     944:	9a 81       	ldd	r25, Y+2	; 0x02
     946:	0c 96       	adiw	r24, 0x0c	; 12
     948:	0e 94 ab 0a 	call	0x1556	; 0x1556 <uxListRemove>
            }
            portENABLE_INTERRUPTS();
     94c:	78 94       	sei

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     94e:	89 81       	ldd	r24, Y+1	; 0x01
     950:	9a 81       	ldd	r25, Y+2	; 0x02
     952:	02 96       	adiw	r24, 0x02	; 2
     954:	0e 94 ab 0a 	call	0x1556	; 0x1556 <uxListRemove>
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     958:	e9 81       	ldd	r30, Y+1	; 0x01
     95a:	fa 81       	ldd	r31, Y+2	; 0x02
     95c:	96 89       	ldd	r25, Z+22	; 0x16
     95e:	80 91 72 06 	lds	r24, 0x0672
     962:	89 17       	cp	r24, r25
     964:	28 f4       	brcc	.+10     	; 0x970 <prvCheckPendingReadyList+0x4c>
     966:	e9 81       	ldd	r30, Y+1	; 0x01
     968:	fa 81       	ldd	r31, Y+2	; 0x02
     96a:	86 89       	ldd	r24, Z+22	; 0x16
     96c:	80 93 72 06 	sts	0x0672, r24
     970:	e9 81       	ldd	r30, Y+1	; 0x01
     972:	fa 81       	ldd	r31, Y+2	; 0x02
     974:	86 89       	ldd	r24, Z+22	; 0x16
     976:	28 2f       	mov	r18, r24
     978:	30 e0       	ldi	r19, 0x00	; 0
     97a:	c9 01       	movw	r24, r18
     97c:	88 0f       	add	r24, r24
     97e:	99 1f       	adc	r25, r25
     980:	88 0f       	add	r24, r24
     982:	99 1f       	adc	r25, r25
     984:	88 0f       	add	r24, r24
     986:	99 1f       	adc	r25, r25
     988:	82 0f       	add	r24, r18
     98a:	93 1f       	adc	r25, r19
     98c:	ac 01       	movw	r20, r24
     98e:	47 58       	subi	r20, 0x87	; 135
     990:	59 4f       	sbci	r21, 0xF9	; 249
     992:	89 81       	ldd	r24, Y+1	; 0x01
     994:	9a 81       	ldd	r25, Y+2	; 0x02
     996:	9c 01       	movw	r18, r24
     998:	2e 5f       	subi	r18, 0xFE	; 254
     99a:	3f 4f       	sbci	r19, 0xFF	; 255
     99c:	ca 01       	movw	r24, r20
     99e:	b9 01       	movw	r22, r18
     9a0:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vListInsertEnd>
    static void prvCheckPendingReadyList( void )
    {
        /* Are there any co-routines waiting to get moved to the ready list?  These
         * are co-routines that have been readied by an ISR.  The ISR cannot access
         * the ready lists itself. */
        while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     9a4:	80 91 9d 06 	lds	r24, 0x069D
     9a8:	88 23       	and	r24, r24
     9aa:	09 f0       	breq	.+2      	; 0x9ae <prvCheckPendingReadyList+0x8a>
     9ac:	c1 cf       	rjmp	.-126    	; 0x930 <prvCheckPendingReadyList+0xc>
            portENABLE_INTERRUPTS();

            ( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
            prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
        }
    }
     9ae:	0f 90       	pop	r0
     9b0:	0f 90       	pop	r0
     9b2:	cf 91       	pop	r28
     9b4:	df 91       	pop	r29
     9b6:	08 95       	ret

000009b8 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

    static void prvCheckDelayedList( void )
    {
     9b8:	df 93       	push	r29
     9ba:	cf 93       	push	r28
     9bc:	00 d0       	rcall	.+0      	; 0x9be <prvCheckDelayedList+0x6>
     9be:	00 d0       	rcall	.+0      	; 0x9c0 <prvCheckDelayedList+0x8>
     9c0:	cd b7       	in	r28, 0x3d	; 61
     9c2:	de b7       	in	r29, 0x3e	; 62
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     9c4:	0e 94 fa 18 	call	0x31f4	; 0x31f4 <xTaskGetTickCount>
     9c8:	20 91 75 06 	lds	r18, 0x0675
     9cc:	30 91 76 06 	lds	r19, 0x0676
     9d0:	82 1b       	sub	r24, r18
     9d2:	93 0b       	sbc	r25, r19
     9d4:	90 93 78 06 	sts	0x0678, r25
     9d8:	80 93 77 06 	sts	0x0677, r24
     9dc:	85 c0       	rjmp	.+266    	; 0xae8 <prvCheckDelayedList+0x130>

        while( xPassedTicks )
        {
            xCoRoutineTickCount++;
     9de:	80 91 73 06 	lds	r24, 0x0673
     9e2:	90 91 74 06 	lds	r25, 0x0674
     9e6:	01 96       	adiw	r24, 0x01	; 1
     9e8:	90 93 74 06 	sts	0x0674, r25
     9ec:	80 93 73 06 	sts	0x0673, r24
            xPassedTicks--;
     9f0:	80 91 77 06 	lds	r24, 0x0677
     9f4:	90 91 78 06 	lds	r25, 0x0678
     9f8:	01 97       	sbiw	r24, 0x01	; 1
     9fa:	90 93 78 06 	sts	0x0678, r25
     9fe:	80 93 77 06 	sts	0x0677, r24

            /* If the tick count has overflowed we need to swap the ready lists. */
            if( xCoRoutineTickCount == 0 )
     a02:	80 91 73 06 	lds	r24, 0x0673
     a06:	90 91 74 06 	lds	r25, 0x0674
     a0a:	00 97       	sbiw	r24, 0x00	; 0
     a0c:	09 f0       	breq	.+2      	; 0xa10 <prvCheckDelayedList+0x58>
     a0e:	64 c0       	rjmp	.+200    	; 0xad8 <prvCheckDelayedList+0x120>
            {
                List_t * pxTemp;

                /* Tick count has overflowed so we need to swap the delay lists.  If there are
                 * any items in pxDelayedCoRoutineList here then there is an error! */
                pxTemp = pxDelayedCoRoutineList;
     a10:	80 91 6c 06 	lds	r24, 0x066C
     a14:	90 91 6d 06 	lds	r25, 0x066D
     a18:	9a 83       	std	Y+2, r25	; 0x02
     a1a:	89 83       	std	Y+1, r24	; 0x01
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     a1c:	80 91 6e 06 	lds	r24, 0x066E
     a20:	90 91 6f 06 	lds	r25, 0x066F
     a24:	90 93 6d 06 	sts	0x066D, r25
     a28:	80 93 6c 06 	sts	0x066C, r24
                pxOverflowDelayedCoRoutineList = pxTemp;
     a2c:	89 81       	ldd	r24, Y+1	; 0x01
     a2e:	9a 81       	ldd	r25, Y+2	; 0x02
     a30:	90 93 6f 06 	sts	0x066F, r25
     a34:	80 93 6e 06 	sts	0x066E, r24
     a38:	4f c0       	rjmp	.+158    	; 0xad8 <prvCheckDelayedList+0x120>
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
            {
                pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     a3a:	e0 91 6c 06 	lds	r30, 0x066C
     a3e:	f0 91 6d 06 	lds	r31, 0x066D
     a42:	05 80       	ldd	r0, Z+5	; 0x05
     a44:	f6 81       	ldd	r31, Z+6	; 0x06
     a46:	e0 2d       	mov	r30, r0
     a48:	86 81       	ldd	r24, Z+6	; 0x06
     a4a:	97 81       	ldd	r25, Z+7	; 0x07
     a4c:	9c 83       	std	Y+4, r25	; 0x04
     a4e:	8b 83       	std	Y+3, r24	; 0x03

                if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     a50:	eb 81       	ldd	r30, Y+3	; 0x03
     a52:	fc 81       	ldd	r31, Y+4	; 0x04
     a54:	22 81       	ldd	r18, Z+2	; 0x02
     a56:	33 81       	ldd	r19, Z+3	; 0x03
     a58:	80 91 73 06 	lds	r24, 0x0673
     a5c:	90 91 74 06 	lds	r25, 0x0674
     a60:	82 17       	cp	r24, r18
     a62:	93 07       	cpc	r25, r19
     a64:	08 f4       	brcc	.+2      	; 0xa68 <prvCheckDelayedList+0xb0>
     a66:	40 c0       	rjmp	.+128    	; 0xae8 <prvCheckDelayedList+0x130>
                {
                    /* Timeout not yet expired. */
                    break;
                }

                portDISABLE_INTERRUPTS();
     a68:	f8 94       	cli
                    /* The event could have occurred just before this critical
                     *  section.  If this is the case then the generic list item will
                     *  have been moved to the pending ready list and the following
                     *  line is still valid.  Also the pvContainer parameter will have
                     *  been set to NULL so the following lines are also valid. */
                    ( void ) uxListRemove( &( pxCRCB->xGenericListItem ) );
     a6a:	8b 81       	ldd	r24, Y+3	; 0x03
     a6c:	9c 81       	ldd	r25, Y+4	; 0x04
     a6e:	02 96       	adiw	r24, 0x02	; 2
     a70:	0e 94 ab 0a 	call	0x1556	; 0x1556 <uxListRemove>

                    /* Is the co-routine waiting on an event also? */
                    if( pxCRCB->xEventListItem.pxContainer )
     a74:	eb 81       	ldd	r30, Y+3	; 0x03
     a76:	fc 81       	ldd	r31, Y+4	; 0x04
     a78:	84 89       	ldd	r24, Z+20	; 0x14
     a7a:	95 89       	ldd	r25, Z+21	; 0x15
     a7c:	00 97       	sbiw	r24, 0x00	; 0
     a7e:	29 f0       	breq	.+10     	; 0xa8a <prvCheckDelayedList+0xd2>
                    {
                        ( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
     a80:	8b 81       	ldd	r24, Y+3	; 0x03
     a82:	9c 81       	ldd	r25, Y+4	; 0x04
     a84:	0c 96       	adiw	r24, 0x0c	; 12
     a86:	0e 94 ab 0a 	call	0x1556	; 0x1556 <uxListRemove>
                    }
                }
                portENABLE_INTERRUPTS();
     a8a:	78 94       	sei

                prvAddCoRoutineToReadyQueue( pxCRCB );
     a8c:	eb 81       	ldd	r30, Y+3	; 0x03
     a8e:	fc 81       	ldd	r31, Y+4	; 0x04
     a90:	96 89       	ldd	r25, Z+22	; 0x16
     a92:	80 91 72 06 	lds	r24, 0x0672
     a96:	89 17       	cp	r24, r25
     a98:	28 f4       	brcc	.+10     	; 0xaa4 <prvCheckDelayedList+0xec>
     a9a:	eb 81       	ldd	r30, Y+3	; 0x03
     a9c:	fc 81       	ldd	r31, Y+4	; 0x04
     a9e:	86 89       	ldd	r24, Z+22	; 0x16
     aa0:	80 93 72 06 	sts	0x0672, r24
     aa4:	eb 81       	ldd	r30, Y+3	; 0x03
     aa6:	fc 81       	ldd	r31, Y+4	; 0x04
     aa8:	86 89       	ldd	r24, Z+22	; 0x16
     aaa:	28 2f       	mov	r18, r24
     aac:	30 e0       	ldi	r19, 0x00	; 0
     aae:	c9 01       	movw	r24, r18
     ab0:	88 0f       	add	r24, r24
     ab2:	99 1f       	adc	r25, r25
     ab4:	88 0f       	add	r24, r24
     ab6:	99 1f       	adc	r25, r25
     ab8:	88 0f       	add	r24, r24
     aba:	99 1f       	adc	r25, r25
     abc:	82 0f       	add	r24, r18
     abe:	93 1f       	adc	r25, r19
     ac0:	ac 01       	movw	r20, r24
     ac2:	47 58       	subi	r20, 0x87	; 135
     ac4:	59 4f       	sbci	r21, 0xF9	; 249
     ac6:	8b 81       	ldd	r24, Y+3	; 0x03
     ac8:	9c 81       	ldd	r25, Y+4	; 0x04
     aca:	9c 01       	movw	r18, r24
     acc:	2e 5f       	subi	r18, 0xFE	; 254
     ace:	3f 4f       	sbci	r19, 0xFF	; 255
     ad0:	ca 01       	movw	r24, r20
     ad2:	b9 01       	movw	r22, r18
     ad4:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vListInsertEnd>
                pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
                pxOverflowDelayedCoRoutineList = pxTemp;
            }

            /* See if this tick has made a timeout expire. */
            while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     ad8:	e0 91 6c 06 	lds	r30, 0x066C
     adc:	f0 91 6d 06 	lds	r31, 0x066D
     ae0:	80 81       	ld	r24, Z
     ae2:	88 23       	and	r24, r24
     ae4:	09 f0       	breq	.+2      	; 0xae8 <prvCheckDelayedList+0x130>
     ae6:	a9 cf       	rjmp	.-174    	; 0xa3a <prvCheckDelayedList+0x82>
    {
        CRCB_t * pxCRCB;

        xPassedTicks = xTaskGetTickCount() - xLastTickCount;

        while( xPassedTicks )
     ae8:	80 91 77 06 	lds	r24, 0x0677
     aec:	90 91 78 06 	lds	r25, 0x0678
     af0:	00 97       	sbiw	r24, 0x00	; 0
     af2:	09 f0       	breq	.+2      	; 0xaf6 <prvCheckDelayedList+0x13e>
     af4:	74 cf       	rjmp	.-280    	; 0x9de <prvCheckDelayedList+0x26>

                prvAddCoRoutineToReadyQueue( pxCRCB );
            }
        }

        xLastTickCount = xCoRoutineTickCount;
     af6:	80 91 73 06 	lds	r24, 0x0673
     afa:	90 91 74 06 	lds	r25, 0x0674
     afe:	90 93 76 06 	sts	0x0676, r25
     b02:	80 93 75 06 	sts	0x0675, r24
    }
     b06:	0f 90       	pop	r0
     b08:	0f 90       	pop	r0
     b0a:	0f 90       	pop	r0
     b0c:	0f 90       	pop	r0
     b0e:	cf 91       	pop	r28
     b10:	df 91       	pop	r29
     b12:	08 95       	ret

00000b14 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

    void vCoRoutineSchedule( void )
    {
     b14:	df 93       	push	r29
     b16:	cf 93       	push	r28
     b18:	00 d0       	rcall	.+0      	; 0xb1a <vCoRoutineSchedule+0x6>
     b1a:	cd b7       	in	r28, 0x3d	; 61
     b1c:	de b7       	in	r29, 0x3e	; 62
        /* Only run a co-routine after prvInitialiseCoRoutineLists() has been
         * called.  prvInitialiseCoRoutineLists() is called automatically when a
         * co-routine is created. */
        if( pxDelayedCoRoutineList != NULL )
     b1e:	80 91 6c 06 	lds	r24, 0x066C
     b22:	90 91 6d 06 	lds	r25, 0x066D
     b26:	00 97       	sbiw	r24, 0x00	; 0
     b28:	09 f4       	brne	.+2      	; 0xb2c <vCoRoutineSchedule+0x18>
     b2a:	70 c0       	rjmp	.+224    	; 0xc0c <vCoRoutineSchedule+0xf8>
        {
            /* See if any co-routines readied by events need moving to the ready lists. */
            prvCheckPendingReadyList();
     b2c:	0e 94 92 04 	call	0x924	; 0x924 <prvCheckPendingReadyList>

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();
     b30:	0e 94 dc 04 	call	0x9b8	; 0x9b8 <prvCheckDelayedList>
     b34:	0a c0       	rjmp	.+20     	; 0xb4a <vCoRoutineSchedule+0x36>

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
            {
                if( uxTopCoRoutineReadyPriority == 0 )
     b36:	80 91 72 06 	lds	r24, 0x0672
     b3a:	88 23       	and	r24, r24
     b3c:	09 f4       	brne	.+2      	; 0xb40 <vCoRoutineSchedule+0x2c>
     b3e:	66 c0       	rjmp	.+204    	; 0xc0c <vCoRoutineSchedule+0xf8>
                {
                    /* No more co-routines to check. */
                    return;
                }

                --uxTopCoRoutineReadyPriority;
     b40:	80 91 72 06 	lds	r24, 0x0672
     b44:	81 50       	subi	r24, 0x01	; 1
     b46:	80 93 72 06 	sts	0x0672, r24

            /* See if any delayed co-routines have timed out. */
            prvCheckDelayedList();

            /* Find the highest priority queue that contains ready co-routines. */
            while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     b4a:	80 91 72 06 	lds	r24, 0x0672
     b4e:	28 2f       	mov	r18, r24
     b50:	30 e0       	ldi	r19, 0x00	; 0
     b52:	c9 01       	movw	r24, r18
     b54:	88 0f       	add	r24, r24
     b56:	99 1f       	adc	r25, r25
     b58:	88 0f       	add	r24, r24
     b5a:	99 1f       	adc	r25, r25
     b5c:	88 0f       	add	r24, r24
     b5e:	99 1f       	adc	r25, r25
     b60:	82 0f       	add	r24, r18
     b62:	93 1f       	adc	r25, r19
     b64:	fc 01       	movw	r30, r24
     b66:	e7 58       	subi	r30, 0x87	; 135
     b68:	f9 4f       	sbci	r31, 0xF9	; 249
     b6a:	80 81       	ld	r24, Z
     b6c:	88 23       	and	r24, r24
     b6e:	19 f3       	breq	.-58     	; 0xb36 <vCoRoutineSchedule+0x22>
                --uxTopCoRoutineReadyPriority;
            }

            /* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
             * of the same priority get an equal share of the processor time. */
            listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     b70:	80 91 72 06 	lds	r24, 0x0672
     b74:	28 2f       	mov	r18, r24
     b76:	30 e0       	ldi	r19, 0x00	; 0
     b78:	c9 01       	movw	r24, r18
     b7a:	88 0f       	add	r24, r24
     b7c:	99 1f       	adc	r25, r25
     b7e:	88 0f       	add	r24, r24
     b80:	99 1f       	adc	r25, r25
     b82:	88 0f       	add	r24, r24
     b84:	99 1f       	adc	r25, r25
     b86:	82 0f       	add	r24, r18
     b88:	93 1f       	adc	r25, r19
     b8a:	87 58       	subi	r24, 0x87	; 135
     b8c:	99 4f       	sbci	r25, 0xF9	; 249
     b8e:	9a 83       	std	Y+2, r25	; 0x02
     b90:	89 83       	std	Y+1, r24	; 0x01
     b92:	e9 81       	ldd	r30, Y+1	; 0x01
     b94:	fa 81       	ldd	r31, Y+2	; 0x02
     b96:	01 80       	ldd	r0, Z+1	; 0x01
     b98:	f2 81       	ldd	r31, Z+2	; 0x02
     b9a:	e0 2d       	mov	r30, r0
     b9c:	82 81       	ldd	r24, Z+2	; 0x02
     b9e:	93 81       	ldd	r25, Z+3	; 0x03
     ba0:	e9 81       	ldd	r30, Y+1	; 0x01
     ba2:	fa 81       	ldd	r31, Y+2	; 0x02
     ba4:	92 83       	std	Z+2, r25	; 0x02
     ba6:	81 83       	std	Z+1, r24	; 0x01
     ba8:	e9 81       	ldd	r30, Y+1	; 0x01
     baa:	fa 81       	ldd	r31, Y+2	; 0x02
     bac:	21 81       	ldd	r18, Z+1	; 0x01
     bae:	32 81       	ldd	r19, Z+2	; 0x02
     bb0:	89 81       	ldd	r24, Y+1	; 0x01
     bb2:	9a 81       	ldd	r25, Y+2	; 0x02
     bb4:	03 96       	adiw	r24, 0x03	; 3
     bb6:	28 17       	cp	r18, r24
     bb8:	39 07       	cpc	r19, r25
     bba:	59 f4       	brne	.+22     	; 0xbd2 <vCoRoutineSchedule+0xbe>
     bbc:	e9 81       	ldd	r30, Y+1	; 0x01
     bbe:	fa 81       	ldd	r31, Y+2	; 0x02
     bc0:	01 80       	ldd	r0, Z+1	; 0x01
     bc2:	f2 81       	ldd	r31, Z+2	; 0x02
     bc4:	e0 2d       	mov	r30, r0
     bc6:	82 81       	ldd	r24, Z+2	; 0x02
     bc8:	93 81       	ldd	r25, Z+3	; 0x03
     bca:	e9 81       	ldd	r30, Y+1	; 0x01
     bcc:	fa 81       	ldd	r31, Y+2	; 0x02
     bce:	92 83       	std	Z+2, r25	; 0x02
     bd0:	81 83       	std	Z+1, r24	; 0x01
     bd2:	e9 81       	ldd	r30, Y+1	; 0x01
     bd4:	fa 81       	ldd	r31, Y+2	; 0x02
     bd6:	01 80       	ldd	r0, Z+1	; 0x01
     bd8:	f2 81       	ldd	r31, Z+2	; 0x02
     bda:	e0 2d       	mov	r30, r0
     bdc:	86 81       	ldd	r24, Z+6	; 0x06
     bde:	97 81       	ldd	r25, Z+7	; 0x07
     be0:	90 93 71 06 	sts	0x0671, r25
     be4:	80 93 70 06 	sts	0x0670, r24

            /* Call the co-routine. */
            ( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     be8:	e0 91 70 06 	lds	r30, 0x0670
     bec:	f0 91 71 06 	lds	r31, 0x0671
     bf0:	40 81       	ld	r20, Z
     bf2:	51 81       	ldd	r21, Z+1	; 0x01
     bf4:	80 91 70 06 	lds	r24, 0x0670
     bf8:	90 91 71 06 	lds	r25, 0x0671
     bfc:	e0 91 70 06 	lds	r30, 0x0670
     c00:	f0 91 71 06 	lds	r31, 0x0671
     c04:	27 89       	ldd	r18, Z+23	; 0x17
     c06:	62 2f       	mov	r22, r18
     c08:	fa 01       	movw	r30, r20
     c0a:	09 95       	icall
        }
    }
     c0c:	0f 90       	pop	r0
     c0e:	0f 90       	pop	r0
     c10:	cf 91       	pop	r28
     c12:	df 91       	pop	r29
     c14:	08 95       	ret

00000c16 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

    static void prvInitialiseCoRoutineLists( void )
    {
     c16:	df 93       	push	r29
     c18:	cf 93       	push	r28
     c1a:	0f 92       	push	r0
     c1c:	cd b7       	in	r28, 0x3d	; 61
     c1e:	de b7       	in	r29, 0x3e	; 62
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     c20:	19 82       	std	Y+1, r1	; 0x01
     c22:	13 c0       	rjmp	.+38     	; 0xc4a <prvInitialiseCoRoutineLists+0x34>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     c24:	89 81       	ldd	r24, Y+1	; 0x01
     c26:	28 2f       	mov	r18, r24
     c28:	30 e0       	ldi	r19, 0x00	; 0
     c2a:	c9 01       	movw	r24, r18
     c2c:	88 0f       	add	r24, r24
     c2e:	99 1f       	adc	r25, r25
     c30:	88 0f       	add	r24, r24
     c32:	99 1f       	adc	r25, r25
     c34:	88 0f       	add	r24, r24
     c36:	99 1f       	adc	r25, r25
     c38:	82 0f       	add	r24, r18
     c3a:	93 1f       	adc	r25, r19
     c3c:	87 58       	subi	r24, 0x87	; 135
     c3e:	99 4f       	sbci	r25, 0xF9	; 249
     c40:	0e 94 c1 09 	call	0x1382	; 0x1382 <vListInitialise>

    static void prvInitialiseCoRoutineLists( void )
    {
        UBaseType_t uxPriority;

        for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     c44:	89 81       	ldd	r24, Y+1	; 0x01
     c46:	8f 5f       	subi	r24, 0xFF	; 255
     c48:	89 83       	std	Y+1, r24	; 0x01
     c4a:	89 81       	ldd	r24, Y+1	; 0x01
     c4c:	82 30       	cpi	r24, 0x02	; 2
     c4e:	50 f3       	brcs	.-44     	; 0xc24 <prvInitialiseCoRoutineLists+0xe>
        {
            vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
        }

        vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
     c50:	8b e8       	ldi	r24, 0x8B	; 139
     c52:	96 e0       	ldi	r25, 0x06	; 6
     c54:	0e 94 c1 09 	call	0x1382	; 0x1382 <vListInitialise>
        vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
     c58:	84 e9       	ldi	r24, 0x94	; 148
     c5a:	96 e0       	ldi	r25, 0x06	; 6
     c5c:	0e 94 c1 09 	call	0x1382	; 0x1382 <vListInitialise>
        vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
     c60:	8d e9       	ldi	r24, 0x9D	; 157
     c62:	96 e0       	ldi	r25, 0x06	; 6
     c64:	0e 94 c1 09 	call	0x1382	; 0x1382 <vListInitialise>

        /* Start with pxDelayedCoRoutineList using list1 and the
         * pxOverflowDelayedCoRoutineList using list2. */
        pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     c68:	8b e8       	ldi	r24, 0x8B	; 139
     c6a:	96 e0       	ldi	r25, 0x06	; 6
     c6c:	90 93 6d 06 	sts	0x066D, r25
     c70:	80 93 6c 06 	sts	0x066C, r24
        pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     c74:	84 e9       	ldi	r24, 0x94	; 148
     c76:	96 e0       	ldi	r25, 0x06	; 6
     c78:	90 93 6f 06 	sts	0x066F, r25
     c7c:	80 93 6e 06 	sts	0x066E, r24
    }
     c80:	0f 90       	pop	r0
     c82:	cf 91       	pop	r28
     c84:	df 91       	pop	r29
     c86:	08 95       	ret

00000c88 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

    BaseType_t xCoRoutineRemoveFromEventList( const List_t * pxEventList )
    {
     c88:	df 93       	push	r29
     c8a:	cf 93       	push	r28
     c8c:	00 d0       	rcall	.+0      	; 0xc8e <xCoRoutineRemoveFromEventList+0x6>
     c8e:	00 d0       	rcall	.+0      	; 0xc90 <xCoRoutineRemoveFromEventList+0x8>
     c90:	0f 92       	push	r0
     c92:	cd b7       	in	r28, 0x3d	; 61
     c94:	de b7       	in	r29, 0x3e	; 62
     c96:	9d 83       	std	Y+5, r25	; 0x05
     c98:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;

        /* This function is called from within an interrupt.  It can only access
         * event lists and the pending ready list.  This function assumes that a
         * check has already been made to ensure pxEventList is not empty. */
        pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     c9a:	ec 81       	ldd	r30, Y+4	; 0x04
     c9c:	fd 81       	ldd	r31, Y+5	; 0x05
     c9e:	05 80       	ldd	r0, Z+5	; 0x05
     ca0:	f6 81       	ldd	r31, Z+6	; 0x06
     ca2:	e0 2d       	mov	r30, r0
     ca4:	86 81       	ldd	r24, Z+6	; 0x06
     ca6:	97 81       	ldd	r25, Z+7	; 0x07
     ca8:	9b 83       	std	Y+3, r25	; 0x03
     caa:	8a 83       	std	Y+2, r24	; 0x02
        ( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     cac:	8a 81       	ldd	r24, Y+2	; 0x02
     cae:	9b 81       	ldd	r25, Y+3	; 0x03
     cb0:	0c 96       	adiw	r24, 0x0c	; 12
     cb2:	0e 94 ab 0a 	call	0x1556	; 0x1556 <uxListRemove>
        vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     cb6:	8a 81       	ldd	r24, Y+2	; 0x02
     cb8:	9b 81       	ldd	r25, Y+3	; 0x03
     cba:	9c 01       	movw	r18, r24
     cbc:	24 5f       	subi	r18, 0xF4	; 244
     cbe:	3f 4f       	sbci	r19, 0xFF	; 255
     cc0:	8d e9       	ldi	r24, 0x9D	; 157
     cc2:	96 e0       	ldi	r25, 0x06	; 6
     cc4:	b9 01       	movw	r22, r18
     cc6:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vListInsertEnd>

        if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     cca:	ea 81       	ldd	r30, Y+2	; 0x02
     ccc:	fb 81       	ldd	r31, Y+3	; 0x03
     cce:	96 89       	ldd	r25, Z+22	; 0x16
     cd0:	e0 91 70 06 	lds	r30, 0x0670
     cd4:	f0 91 71 06 	lds	r31, 0x0671
     cd8:	86 89       	ldd	r24, Z+22	; 0x16
     cda:	98 17       	cp	r25, r24
     cdc:	18 f0       	brcs	.+6      	; 0xce4 <xCoRoutineRemoveFromEventList+0x5c>
        {
            xReturn = pdTRUE;
     cde:	81 e0       	ldi	r24, 0x01	; 1
     ce0:	89 83       	std	Y+1, r24	; 0x01
     ce2:	01 c0       	rjmp	.+2      	; 0xce6 <xCoRoutineRemoveFromEventList+0x5e>
        }
        else
        {
            xReturn = pdFALSE;
     ce4:	19 82       	std	Y+1, r1	; 0x01
        }

        return xReturn;
     ce6:	89 81       	ldd	r24, Y+1	; 0x01
    }
     ce8:	0f 90       	pop	r0
     cea:	0f 90       	pop	r0
     cec:	0f 90       	pop	r0
     cee:	0f 90       	pop	r0
     cf0:	0f 90       	pop	r0
     cf2:	cf 91       	pop	r28
     cf4:	df 91       	pop	r29
     cf6:	08 95       	ret

00000cf8 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
     cf8:	df 93       	push	r29
     cfa:	cf 93       	push	r28
     cfc:	00 d0       	rcall	.+0      	; 0xcfe <xEventGroupCreate+0x6>
     cfe:	cd b7       	in	r28, 0x3d	; 61
     d00:	de b7       	in	r29, 0x3e	; 62
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     d02:	8b e0       	ldi	r24, 0x0B	; 11
     d04:	90 e0       	ldi	r25, 0x00	; 0
     d06:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     d0a:	9a 83       	std	Y+2, r25	; 0x02
     d0c:	89 83       	std	Y+1, r24	; 0x01

        if( pxEventBits != NULL )
     d0e:	89 81       	ldd	r24, Y+1	; 0x01
     d10:	9a 81       	ldd	r25, Y+2	; 0x02
     d12:	00 97       	sbiw	r24, 0x00	; 0
     d14:	49 f0       	breq	.+18     	; 0xd28 <xEventGroupCreate+0x30>
        {
            pxEventBits->uxEventBits = 0;
     d16:	e9 81       	ldd	r30, Y+1	; 0x01
     d18:	fa 81       	ldd	r31, Y+2	; 0x02
     d1a:	11 82       	std	Z+1, r1	; 0x01
     d1c:	10 82       	st	Z, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     d1e:	89 81       	ldd	r24, Y+1	; 0x01
     d20:	9a 81       	ldd	r25, Y+2	; 0x02
     d22:	02 96       	adiw	r24, 0x02	; 2
     d24:	0e 94 c1 09 	call	0x1382	; 0x1382 <vListInitialise>
        else
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
     d28:	89 81       	ldd	r24, Y+1	; 0x01
     d2a:	9a 81       	ldd	r25, Y+2	; 0x02
    }
     d2c:	0f 90       	pop	r0
     d2e:	0f 90       	pop	r0
     d30:	cf 91       	pop	r28
     d32:	df 91       	pop	r29
     d34:	08 95       	ret

00000d36 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
     d36:	df 93       	push	r29
     d38:	cf 93       	push	r28
     d3a:	cd b7       	in	r28, 0x3d	; 61
     d3c:	de b7       	in	r29, 0x3e	; 62
     d3e:	60 97       	sbiw	r28, 0x10	; 16
     d40:	0f b6       	in	r0, 0x3f	; 63
     d42:	f8 94       	cli
     d44:	de bf       	out	0x3e, r29	; 62
     d46:	0f be       	out	0x3f, r0	; 63
     d48:	cd bf       	out	0x3d, r28	; 61
     d4a:	9a 87       	std	Y+10, r25	; 0x0a
     d4c:	89 87       	std	Y+9, r24	; 0x09
     d4e:	7c 87       	std	Y+12, r23	; 0x0c
     d50:	6b 87       	std	Y+11, r22	; 0x0b
     d52:	5e 87       	std	Y+14, r21	; 0x0e
     d54:	4d 87       	std	Y+13, r20	; 0x0d
     d56:	38 8b       	std	Y+16, r19	; 0x10
     d58:	2f 87       	std	Y+15, r18	; 0x0f
    EventBits_t uxOriginalBitValue, uxReturn;
    EventGroup_t * pxEventBits = xEventGroup;
     d5a:	89 85       	ldd	r24, Y+9	; 0x09
     d5c:	9a 85       	ldd	r25, Y+10	; 0x0a
     d5e:	9c 83       	std	Y+4, r25	; 0x04
     d60:	8b 83       	std	Y+3, r24	; 0x03
    BaseType_t xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
     d62:	19 82       	std	Y+1, r1	; 0x01
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
     d64:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
     d68:	eb 81       	ldd	r30, Y+3	; 0x03
     d6a:	fc 81       	ldd	r31, Y+4	; 0x04
     d6c:	80 81       	ld	r24, Z
     d6e:	91 81       	ldd	r25, Z+1	; 0x01
     d70:	98 87       	std	Y+8, r25	; 0x08
     d72:	8f 83       	std	Y+7, r24	; 0x07

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     d74:	89 85       	ldd	r24, Y+9	; 0x09
     d76:	9a 85       	ldd	r25, Y+10	; 0x0a
     d78:	2b 85       	ldd	r18, Y+11	; 0x0b
     d7a:	3c 85       	ldd	r19, Y+12	; 0x0c
     d7c:	b9 01       	movw	r22, r18
     d7e:	0e 94 72 08 	call	0x10e4	; 0x10e4 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     d82:	2f 81       	ldd	r18, Y+7	; 0x07
     d84:	38 85       	ldd	r19, Y+8	; 0x08
     d86:	8b 85       	ldd	r24, Y+11	; 0x0b
     d88:	9c 85       	ldd	r25, Y+12	; 0x0c
     d8a:	28 2b       	or	r18, r24
     d8c:	39 2b       	or	r19, r25
     d8e:	8d 85       	ldd	r24, Y+13	; 0x0d
     d90:	9e 85       	ldd	r25, Y+14	; 0x0e
     d92:	28 23       	and	r18, r24
     d94:	39 23       	and	r19, r25
     d96:	8d 85       	ldd	r24, Y+13	; 0x0d
     d98:	9e 85       	ldd	r25, Y+14	; 0x0e
     d9a:	28 17       	cp	r18, r24
     d9c:	39 07       	cpc	r19, r25
     d9e:	c9 f4       	brne	.+50     	; 0xdd2 <xEventGroupSync+0x9c>
        {
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     da0:	2f 81       	ldd	r18, Y+7	; 0x07
     da2:	38 85       	ldd	r19, Y+8	; 0x08
     da4:	8b 85       	ldd	r24, Y+11	; 0x0b
     da6:	9c 85       	ldd	r25, Y+12	; 0x0c
     da8:	82 2b       	or	r24, r18
     daa:	93 2b       	or	r25, r19
     dac:	9e 83       	std	Y+6, r25	; 0x06
     dae:	8d 83       	std	Y+5, r24	; 0x05

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     db0:	eb 81       	ldd	r30, Y+3	; 0x03
     db2:	fc 81       	ldd	r31, Y+4	; 0x04
     db4:	20 81       	ld	r18, Z
     db6:	31 81       	ldd	r19, Z+1	; 0x01
     db8:	8d 85       	ldd	r24, Y+13	; 0x0d
     dba:	9e 85       	ldd	r25, Y+14	; 0x0e
     dbc:	80 95       	com	r24
     dbe:	90 95       	com	r25
     dc0:	82 23       	and	r24, r18
     dc2:	93 23       	and	r25, r19
     dc4:	eb 81       	ldd	r30, Y+3	; 0x03
     dc6:	fc 81       	ldd	r31, Y+4	; 0x04
     dc8:	91 83       	std	Z+1, r25	; 0x01
     dca:	80 83       	st	Z, r24

            xTicksToWait = 0;
     dcc:	18 8a       	std	Y+16, r1	; 0x10
     dce:	1f 86       	std	Y+15, r1	; 0x0f
     dd0:	1e c0       	rjmp	.+60     	; 0xe0e <xEventGroupSync+0xd8>
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
     dd2:	8f 85       	ldd	r24, Y+15	; 0x0f
     dd4:	98 89       	ldd	r25, Y+16	; 0x10
     dd6:	00 97       	sbiw	r24, 0x00	; 0
     dd8:	91 f0       	breq	.+36     	; 0xdfe <xEventGroupSync+0xc8>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     dda:	8b 81       	ldd	r24, Y+3	; 0x03
     ddc:	9c 81       	ldd	r25, Y+4	; 0x04
     dde:	bc 01       	movw	r22, r24
     de0:	6e 5f       	subi	r22, 0xFE	; 254
     de2:	7f 4f       	sbci	r23, 0xFF	; 255
     de4:	8d 85       	ldd	r24, Y+13	; 0x0d
     de6:	9e 85       	ldd	r25, Y+14	; 0x0e
     de8:	9c 01       	movw	r18, r24
     dea:	35 60       	ori	r19, 0x05	; 5
     dec:	4f 85       	ldd	r20, Y+15	; 0x0f
     dee:	58 89       	ldd	r21, Y+16	; 0x10
     df0:	cb 01       	movw	r24, r22
     df2:	b9 01       	movw	r22, r18
     df4:	0e 94 9d 1b 	call	0x373a	; 0x373a <vTaskPlaceOnUnorderedEventList>

                /* This assignment is obsolete as uxReturn will get set after
                 * the task unblocks, but some compilers mistakenly generate a
                 * warning about uxReturn being returned without being set if the
                 * assignment is omitted. */
                uxReturn = 0;
     df8:	1e 82       	std	Y+6, r1	; 0x06
     dfa:	1d 82       	std	Y+5, r1	; 0x05
     dfc:	08 c0       	rjmp	.+16     	; 0xe0e <xEventGroupSync+0xd8>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
     dfe:	eb 81       	ldd	r30, Y+3	; 0x03
     e00:	fc 81       	ldd	r31, Y+4	; 0x04
     e02:	80 81       	ld	r24, Z
     e04:	91 81       	ldd	r25, Z+1	; 0x01
     e06:	9e 83       	std	Y+6, r25	; 0x06
     e08:	8d 83       	std	Y+5, r24	; 0x05
                xTimeoutOccurred = pdTRUE;
     e0a:	81 e0       	ldi	r24, 0x01	; 1
     e0c:	89 83       	std	Y+1, r24	; 0x01
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
     e0e:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>
     e12:	8a 83       	std	Y+2, r24	; 0x02

    if( xTicksToWait != ( TickType_t ) 0 )
     e14:	8f 85       	ldd	r24, Y+15	; 0x0f
     e16:	98 89       	ldd	r25, Y+16	; 0x10
     e18:	00 97       	sbiw	r24, 0x00	; 0
     e1a:	09 f4       	brne	.+2      	; 0xe1e <xEventGroupSync+0xe8>
     e1c:	3a c0       	rjmp	.+116    	; 0xe92 <xEventGroupSync+0x15c>
    {
        if( xAlreadyYielded == pdFALSE )
     e1e:	8a 81       	ldd	r24, Y+2	; 0x02
     e20:	88 23       	and	r24, r24
     e22:	11 f4       	brne	.+4      	; 0xe28 <xEventGroupSync+0xf2>
        {
            portYIELD_WITHIN_API();
     e24:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
     e28:	0e 94 2b 20 	call	0x4056	; 0x4056 <uxTaskResetEventItemValue>
     e2c:	9e 83       	std	Y+6, r25	; 0x06
     e2e:	8d 83       	std	Y+5, r24	; 0x05

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     e30:	8d 81       	ldd	r24, Y+5	; 0x05
     e32:	9e 81       	ldd	r25, Y+6	; 0x06
     e34:	80 70       	andi	r24, 0x00	; 0
     e36:	92 70       	andi	r25, 0x02	; 2
     e38:	00 97       	sbiw	r24, 0x00	; 0
     e3a:	31 f5       	brne	.+76     	; 0xe88 <xEventGroupSync+0x152>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
     e3c:	0f b6       	in	r0, 0x3f	; 63
     e3e:	f8 94       	cli
     e40:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
     e42:	eb 81       	ldd	r30, Y+3	; 0x03
     e44:	fc 81       	ldd	r31, Y+4	; 0x04
     e46:	80 81       	ld	r24, Z
     e48:	91 81       	ldd	r25, Z+1	; 0x01
     e4a:	9e 83       	std	Y+6, r25	; 0x06
     e4c:	8d 83       	std	Y+5, r24	; 0x05

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     e4e:	2d 81       	ldd	r18, Y+5	; 0x05
     e50:	3e 81       	ldd	r19, Y+6	; 0x06
     e52:	8d 85       	ldd	r24, Y+13	; 0x0d
     e54:	9e 85       	ldd	r25, Y+14	; 0x0e
     e56:	28 23       	and	r18, r24
     e58:	39 23       	and	r19, r25
     e5a:	8d 85       	ldd	r24, Y+13	; 0x0d
     e5c:	9e 85       	ldd	r25, Y+14	; 0x0e
     e5e:	28 17       	cp	r18, r24
     e60:	39 07       	cpc	r19, r25
     e62:	71 f4       	brne	.+28     	; 0xe80 <xEventGroupSync+0x14a>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     e64:	eb 81       	ldd	r30, Y+3	; 0x03
     e66:	fc 81       	ldd	r31, Y+4	; 0x04
     e68:	20 81       	ld	r18, Z
     e6a:	31 81       	ldd	r19, Z+1	; 0x01
     e6c:	8d 85       	ldd	r24, Y+13	; 0x0d
     e6e:	9e 85       	ldd	r25, Y+14	; 0x0e
     e70:	80 95       	com	r24
     e72:	90 95       	com	r25
     e74:	82 23       	and	r24, r18
     e76:	93 23       	and	r25, r19
     e78:	eb 81       	ldd	r30, Y+3	; 0x03
     e7a:	fc 81       	ldd	r31, Y+4	; 0x04
     e7c:	91 83       	std	Z+1, r25	; 0x01
     e7e:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
     e80:	0f 90       	pop	r0
     e82:	0f be       	out	0x3f, r0	; 63

            xTimeoutOccurred = pdTRUE;
     e84:	81 e0       	ldi	r24, 0x01	; 1
     e86:	89 83       	std	Y+1, r24	; 0x01
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     e88:	8d 81       	ldd	r24, Y+5	; 0x05
     e8a:	9e 81       	ldd	r25, Y+6	; 0x06
     e8c:	90 70       	andi	r25, 0x00	; 0
     e8e:	9e 83       	std	Y+6, r25	; 0x06
     e90:	8d 83       	std	Y+5, r24	; 0x05
    traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
     e92:	8d 81       	ldd	r24, Y+5	; 0x05
     e94:	9e 81       	ldd	r25, Y+6	; 0x06
}
     e96:	60 96       	adiw	r28, 0x10	; 16
     e98:	0f b6       	in	r0, 0x3f	; 63
     e9a:	f8 94       	cli
     e9c:	de bf       	out	0x3e, r29	; 62
     e9e:	0f be       	out	0x3f, r0	; 63
     ea0:	cd bf       	out	0x3d, r28	; 61
     ea2:	cf 91       	pop	r28
     ea4:	df 91       	pop	r29
     ea6:	08 95       	ret

00000ea8 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
     ea8:	0f 93       	push	r16
     eaa:	1f 93       	push	r17
     eac:	df 93       	push	r29
     eae:	cf 93       	push	r28
     eb0:	cd b7       	in	r28, 0x3d	; 61
     eb2:	de b7       	in	r29, 0x3e	; 62
     eb4:	63 97       	sbiw	r28, 0x13	; 19
     eb6:	0f b6       	in	r0, 0x3f	; 63
     eb8:	f8 94       	cli
     eba:	de bf       	out	0x3e, r29	; 62
     ebc:	0f be       	out	0x3f, r0	; 63
     ebe:	cd bf       	out	0x3d, r28	; 61
     ec0:	9d 87       	std	Y+13, r25	; 0x0d
     ec2:	8c 87       	std	Y+12, r24	; 0x0c
     ec4:	7f 87       	std	Y+15, r23	; 0x0f
     ec6:	6e 87       	std	Y+14, r22	; 0x0e
     ec8:	48 8b       	std	Y+16, r20	; 0x10
     eca:	29 8b       	std	Y+17, r18	; 0x11
     ecc:	1b 8b       	std	Y+19, r17	; 0x13
     ece:	0a 8b       	std	Y+18, r16	; 0x12
    EventGroup_t * pxEventBits = xEventGroup;
     ed0:	8c 85       	ldd	r24, Y+12	; 0x0c
     ed2:	9d 85       	ldd	r25, Y+13	; 0x0d
     ed4:	9b 87       	std	Y+11, r25	; 0x0b
     ed6:	8a 87       	std	Y+10, r24	; 0x0a
    EventBits_t uxReturn, uxControlBits = 0;
     ed8:	1f 82       	std	Y+7, r1	; 0x07
     eda:	1e 82       	std	Y+6, r1	; 0x06
    BaseType_t xWaitConditionMet, xAlreadyYielded;
    BaseType_t xTimeoutOccurred = pdFALSE;
     edc:	1b 82       	std	Y+3, r1	; 0x03
        {
            configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
        }
    #endif

    vTaskSuspendAll();
     ede:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     ee2:	ea 85       	ldd	r30, Y+10	; 0x0a
     ee4:	fb 85       	ldd	r31, Y+11	; 0x0b
     ee6:	80 81       	ld	r24, Z
     ee8:	91 81       	ldd	r25, Z+1	; 0x01
     eea:	9a 83       	std	Y+2, r25	; 0x02
     eec:	89 83       	std	Y+1, r24	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     eee:	89 81       	ldd	r24, Y+1	; 0x01
     ef0:	9a 81       	ldd	r25, Y+2	; 0x02
     ef2:	2e 85       	ldd	r18, Y+14	; 0x0e
     ef4:	3f 85       	ldd	r19, Y+15	; 0x0f
     ef6:	b9 01       	movw	r22, r18
     ef8:	49 89       	ldd	r20, Y+17	; 0x11
     efa:	0e 94 8f 09 	call	0x131e	; 0x131e <prvTestWaitCondition>
     efe:	8d 83       	std	Y+5, r24	; 0x05

        if( xWaitConditionMet != pdFALSE )
     f00:	8d 81       	ldd	r24, Y+5	; 0x05
     f02:	88 23       	and	r24, r24
     f04:	c1 f0       	breq	.+48     	; 0xf36 <xEventGroupWaitBits+0x8e>
        {
            /* The wait condition has already been met so there is no need to
             * block. */
            uxReturn = uxCurrentEventBits;
     f06:	89 81       	ldd	r24, Y+1	; 0x01
     f08:	9a 81       	ldd	r25, Y+2	; 0x02
     f0a:	99 87       	std	Y+9, r25	; 0x09
     f0c:	88 87       	std	Y+8, r24	; 0x08
            xTicksToWait = ( TickType_t ) 0;
     f0e:	1b 8a       	std	Y+19, r1	; 0x13
     f10:	1a 8a       	std	Y+18, r1	; 0x12

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
     f12:	88 89       	ldd	r24, Y+16	; 0x10
     f14:	88 23       	and	r24, r24
     f16:	e9 f1       	breq	.+122    	; 0xf92 <xEventGroupWaitBits+0xea>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     f18:	ea 85       	ldd	r30, Y+10	; 0x0a
     f1a:	fb 85       	ldd	r31, Y+11	; 0x0b
     f1c:	20 81       	ld	r18, Z
     f1e:	31 81       	ldd	r19, Z+1	; 0x01
     f20:	8e 85       	ldd	r24, Y+14	; 0x0e
     f22:	9f 85       	ldd	r25, Y+15	; 0x0f
     f24:	80 95       	com	r24
     f26:	90 95       	com	r25
     f28:	82 23       	and	r24, r18
     f2a:	93 23       	and	r25, r19
     f2c:	ea 85       	ldd	r30, Y+10	; 0x0a
     f2e:	fb 85       	ldd	r31, Y+11	; 0x0b
     f30:	91 83       	std	Z+1, r25	; 0x01
     f32:	80 83       	st	Z, r24
     f34:	2e c0       	rjmp	.+92     	; 0xf92 <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
     f36:	8a 89       	ldd	r24, Y+18	; 0x12
     f38:	9b 89       	ldd	r25, Y+19	; 0x13
     f3a:	00 97       	sbiw	r24, 0x00	; 0
     f3c:	39 f4       	brne	.+14     	; 0xf4c <xEventGroupWaitBits+0xa4>
        {
            /* The wait condition has not been met, but no block time was
             * specified, so just return the current value. */
            uxReturn = uxCurrentEventBits;
     f3e:	89 81       	ldd	r24, Y+1	; 0x01
     f40:	9a 81       	ldd	r25, Y+2	; 0x02
     f42:	99 87       	std	Y+9, r25	; 0x09
     f44:	88 87       	std	Y+8, r24	; 0x08
            xTimeoutOccurred = pdTRUE;
     f46:	81 e0       	ldi	r24, 0x01	; 1
     f48:	8b 83       	std	Y+3, r24	; 0x03
     f4a:	23 c0       	rjmp	.+70     	; 0xf92 <xEventGroupWaitBits+0xea>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
     f4c:	88 89       	ldd	r24, Y+16	; 0x10
     f4e:	88 23       	and	r24, r24
     f50:	29 f0       	breq	.+10     	; 0xf5c <xEventGroupWaitBits+0xb4>
            {
                uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     f52:	8e 81       	ldd	r24, Y+6	; 0x06
     f54:	9f 81       	ldd	r25, Y+7	; 0x07
     f56:	91 60       	ori	r25, 0x01	; 1
     f58:	9f 83       	std	Y+7, r25	; 0x07
     f5a:	8e 83       	std	Y+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
     f5c:	89 89       	ldd	r24, Y+17	; 0x11
     f5e:	88 23       	and	r24, r24
     f60:	29 f0       	breq	.+10     	; 0xf6c <xEventGroupWaitBits+0xc4>
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
     f62:	8e 81       	ldd	r24, Y+6	; 0x06
     f64:	9f 81       	ldd	r25, Y+7	; 0x07
     f66:	94 60       	ori	r25, 0x04	; 4
     f68:	9f 83       	std	Y+7, r25	; 0x07
     f6a:	8e 83       	std	Y+6, r24	; 0x06
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     f6c:	8a 85       	ldd	r24, Y+10	; 0x0a
     f6e:	9b 85       	ldd	r25, Y+11	; 0x0b
     f70:	bc 01       	movw	r22, r24
     f72:	6e 5f       	subi	r22, 0xFE	; 254
     f74:	7f 4f       	sbci	r23, 0xFF	; 255
     f76:	2e 85       	ldd	r18, Y+14	; 0x0e
     f78:	3f 85       	ldd	r19, Y+15	; 0x0f
     f7a:	8e 81       	ldd	r24, Y+6	; 0x06
     f7c:	9f 81       	ldd	r25, Y+7	; 0x07
     f7e:	28 2b       	or	r18, r24
     f80:	39 2b       	or	r19, r25
     f82:	4a 89       	ldd	r20, Y+18	; 0x12
     f84:	5b 89       	ldd	r21, Y+19	; 0x13
     f86:	cb 01       	movw	r24, r22
     f88:	b9 01       	movw	r22, r18
     f8a:	0e 94 9d 1b 	call	0x373a	; 0x373a <vTaskPlaceOnUnorderedEventList>

            /* This is obsolete as it will get set after the task unblocks, but
             * some compilers mistakenly generate a warning about the variable
             * being returned without being set if it is not done. */
            uxReturn = 0;
     f8e:	19 86       	std	Y+9, r1	; 0x09
     f90:	18 86       	std	Y+8, r1	; 0x08

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
     f92:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>
     f96:	8c 83       	std	Y+4, r24	; 0x04

    if( xTicksToWait != ( TickType_t ) 0 )
     f98:	8a 89       	ldd	r24, Y+18	; 0x12
     f9a:	9b 89       	ldd	r25, Y+19	; 0x13
     f9c:	00 97       	sbiw	r24, 0x00	; 0
     f9e:	09 f4       	brne	.+2      	; 0xfa2 <xEventGroupWaitBits+0xfa>
     fa0:	3c c0       	rjmp	.+120    	; 0x101a <xEventGroupWaitBits+0x172>
    {
        if( xAlreadyYielded == pdFALSE )
     fa2:	8c 81       	ldd	r24, Y+4	; 0x04
     fa4:	88 23       	and	r24, r24
     fa6:	11 f4       	brne	.+4      	; 0xfac <xEventGroupWaitBits+0x104>
        {
            portYIELD_WITHIN_API();
     fa8:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
     fac:	0e 94 2b 20 	call	0x4056	; 0x4056 <uxTaskResetEventItemValue>
     fb0:	99 87       	std	Y+9, r25	; 0x09
     fb2:	88 87       	std	Y+8, r24	; 0x08

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     fb4:	88 85       	ldd	r24, Y+8	; 0x08
     fb6:	99 85       	ldd	r25, Y+9	; 0x09
     fb8:	80 70       	andi	r24, 0x00	; 0
     fba:	92 70       	andi	r25, 0x02	; 2
     fbc:	00 97       	sbiw	r24, 0x00	; 0
     fbe:	41 f5       	brne	.+80     	; 0x1010 <xEventGroupWaitBits+0x168>
        {
            taskENTER_CRITICAL();
     fc0:	0f b6       	in	r0, 0x3f	; 63
     fc2:	f8 94       	cli
     fc4:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
     fc6:	ea 85       	ldd	r30, Y+10	; 0x0a
     fc8:	fb 85       	ldd	r31, Y+11	; 0x0b
     fca:	80 81       	ld	r24, Z
     fcc:	91 81       	ldd	r25, Z+1	; 0x01
     fce:	99 87       	std	Y+9, r25	; 0x09
     fd0:	88 87       	std	Y+8, r24	; 0x08

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     fd2:	88 85       	ldd	r24, Y+8	; 0x08
     fd4:	99 85       	ldd	r25, Y+9	; 0x09
     fd6:	2e 85       	ldd	r18, Y+14	; 0x0e
     fd8:	3f 85       	ldd	r19, Y+15	; 0x0f
     fda:	b9 01       	movw	r22, r18
     fdc:	49 89       	ldd	r20, Y+17	; 0x11
     fde:	0e 94 8f 09 	call	0x131e	; 0x131e <prvTestWaitCondition>
     fe2:	88 23       	and	r24, r24
     fe4:	89 f0       	breq	.+34     	; 0x1008 <xEventGroupWaitBits+0x160>
                {
                    if( xClearOnExit != pdFALSE )
     fe6:	88 89       	ldd	r24, Y+16	; 0x10
     fe8:	88 23       	and	r24, r24
     fea:	71 f0       	breq	.+28     	; 0x1008 <xEventGroupWaitBits+0x160>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     fec:	ea 85       	ldd	r30, Y+10	; 0x0a
     fee:	fb 85       	ldd	r31, Y+11	; 0x0b
     ff0:	20 81       	ld	r18, Z
     ff2:	31 81       	ldd	r19, Z+1	; 0x01
     ff4:	8e 85       	ldd	r24, Y+14	; 0x0e
     ff6:	9f 85       	ldd	r25, Y+15	; 0x0f
     ff8:	80 95       	com	r24
     ffa:	90 95       	com	r25
     ffc:	82 23       	and	r24, r18
     ffe:	93 23       	and	r25, r19
    1000:	ea 85       	ldd	r30, Y+10	; 0x0a
    1002:	fb 85       	ldd	r31, Y+11	; 0x0b
    1004:	91 83       	std	Z+1, r25	; 0x01
    1006:	80 83       	st	Z, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
    1008:	81 e0       	ldi	r24, 0x01	; 1
    100a:	8b 83       	std	Y+3, r24	; 0x03
            }
            taskEXIT_CRITICAL();
    100c:	0f 90       	pop	r0
    100e:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1010:	88 85       	ldd	r24, Y+8	; 0x08
    1012:	99 85       	ldd	r25, Y+9	; 0x09
    1014:	90 70       	andi	r25, 0x00	; 0
    1016:	99 87       	std	Y+9, r25	; 0x09
    1018:	88 87       	std	Y+8, r24	; 0x08
    traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
    101a:	88 85       	ldd	r24, Y+8	; 0x08
    101c:	99 85       	ldd	r25, Y+9	; 0x09
}
    101e:	63 96       	adiw	r28, 0x13	; 19
    1020:	0f b6       	in	r0, 0x3f	; 63
    1022:	f8 94       	cli
    1024:	de bf       	out	0x3e, r29	; 62
    1026:	0f be       	out	0x3f, r0	; 63
    1028:	cd bf       	out	0x3d, r28	; 61
    102a:	cf 91       	pop	r28
    102c:	df 91       	pop	r29
    102e:	1f 91       	pop	r17
    1030:	0f 91       	pop	r16
    1032:	08 95       	ret

00001034 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    1034:	df 93       	push	r29
    1036:	cf 93       	push	r28
    1038:	cd b7       	in	r28, 0x3d	; 61
    103a:	de b7       	in	r29, 0x3e	; 62
    103c:	28 97       	sbiw	r28, 0x08	; 8
    103e:	0f b6       	in	r0, 0x3f	; 63
    1040:	f8 94       	cli
    1042:	de bf       	out	0x3e, r29	; 62
    1044:	0f be       	out	0x3f, r0	; 63
    1046:	cd bf       	out	0x3d, r28	; 61
    1048:	9e 83       	std	Y+6, r25	; 0x06
    104a:	8d 83       	std	Y+5, r24	; 0x05
    104c:	78 87       	std	Y+8, r23	; 0x08
    104e:	6f 83       	std	Y+7, r22	; 0x07
    EventGroup_t * pxEventBits = xEventGroup;
    1050:	8d 81       	ldd	r24, Y+5	; 0x05
    1052:	9e 81       	ldd	r25, Y+6	; 0x06
    1054:	9c 83       	std	Y+4, r25	; 0x04
    1056:	8b 83       	std	Y+3, r24	; 0x03
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    1058:	0f b6       	in	r0, 0x3f	; 63
    105a:	f8 94       	cli
    105c:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    105e:	eb 81       	ldd	r30, Y+3	; 0x03
    1060:	fc 81       	ldd	r31, Y+4	; 0x04
    1062:	80 81       	ld	r24, Z
    1064:	91 81       	ldd	r25, Z+1	; 0x01
    1066:	9a 83       	std	Y+2, r25	; 0x02
    1068:	89 83       	std	Y+1, r24	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    106a:	eb 81       	ldd	r30, Y+3	; 0x03
    106c:	fc 81       	ldd	r31, Y+4	; 0x04
    106e:	20 81       	ld	r18, Z
    1070:	31 81       	ldd	r19, Z+1	; 0x01
    1072:	8f 81       	ldd	r24, Y+7	; 0x07
    1074:	98 85       	ldd	r25, Y+8	; 0x08
    1076:	80 95       	com	r24
    1078:	90 95       	com	r25
    107a:	82 23       	and	r24, r18
    107c:	93 23       	and	r25, r19
    107e:	eb 81       	ldd	r30, Y+3	; 0x03
    1080:	fc 81       	ldd	r31, Y+4	; 0x04
    1082:	91 83       	std	Z+1, r25	; 0x01
    1084:	80 83       	st	Z, r24
    }
    taskEXIT_CRITICAL();
    1086:	0f 90       	pop	r0
    1088:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    108a:	89 81       	ldd	r24, Y+1	; 0x01
    108c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    108e:	28 96       	adiw	r28, 0x08	; 8
    1090:	0f b6       	in	r0, 0x3f	; 63
    1092:	f8 94       	cli
    1094:	de bf       	out	0x3e, r29	; 62
    1096:	0f be       	out	0x3f, r0	; 63
    1098:	cd bf       	out	0x3d, r28	; 61
    109a:	cf 91       	pop	r28
    109c:	df 91       	pop	r29
    109e:	08 95       	ret

000010a0 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    10a0:	df 93       	push	r29
    10a2:	cf 93       	push	r28
    10a4:	cd b7       	in	r28, 0x3d	; 61
    10a6:	de b7       	in	r29, 0x3e	; 62
    10a8:	27 97       	sbiw	r28, 0x07	; 7
    10aa:	0f b6       	in	r0, 0x3f	; 63
    10ac:	f8 94       	cli
    10ae:	de bf       	out	0x3e, r29	; 62
    10b0:	0f be       	out	0x3f, r0	; 63
    10b2:	cd bf       	out	0x3d, r28	; 61
    10b4:	9f 83       	std	Y+7, r25	; 0x07
    10b6:	8e 83       	std	Y+6, r24	; 0x06
    UBaseType_t uxSavedInterruptStatus;
    EventGroup_t const * const pxEventBits = xEventGroup;
    10b8:	8e 81       	ldd	r24, Y+6	; 0x06
    10ba:	9f 81       	ldd	r25, Y+7	; 0x07
    10bc:	9c 83       	std	Y+4, r25	; 0x04
    10be:	8b 83       	std	Y+3, r24	; 0x03
    EventBits_t uxReturn;

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    10c0:	1d 82       	std	Y+5, r1	; 0x05
    {
        uxReturn = pxEventBits->uxEventBits;
    10c2:	eb 81       	ldd	r30, Y+3	; 0x03
    10c4:	fc 81       	ldd	r31, Y+4	; 0x04
    10c6:	80 81       	ld	r24, Z
    10c8:	91 81       	ldd	r25, Z+1	; 0x01
    10ca:	9a 83       	std	Y+2, r25	; 0x02
    10cc:	89 83       	std	Y+1, r24	; 0x01
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
    10ce:	89 81       	ldd	r24, Y+1	; 0x01
    10d0:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    10d2:	27 96       	adiw	r28, 0x07	; 7
    10d4:	0f b6       	in	r0, 0x3f	; 63
    10d6:	f8 94       	cli
    10d8:	de bf       	out	0x3e, r29	; 62
    10da:	0f be       	out	0x3f, r0	; 63
    10dc:	cd bf       	out	0x3d, r28	; 61
    10de:	cf 91       	pop	r28
    10e0:	df 91       	pop	r29
    10e2:	08 95       	ret

000010e4 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    10e4:	df 93       	push	r29
    10e6:	cf 93       	push	r28
    10e8:	cd b7       	in	r28, 0x3d	; 61
    10ea:	de b7       	in	r29, 0x3e	; 62
    10ec:	65 97       	sbiw	r28, 0x15	; 21
    10ee:	0f b6       	in	r0, 0x3f	; 63
    10f0:	f8 94       	cli
    10f2:	de bf       	out	0x3e, r29	; 62
    10f4:	0f be       	out	0x3f, r0	; 63
    10f6:	cd bf       	out	0x3d, r28	; 61
    10f8:	9b 8b       	std	Y+19, r25	; 0x13
    10fa:	8a 8b       	std	Y+18, r24	; 0x12
    10fc:	7d 8b       	std	Y+21, r23	; 0x15
    10fe:	6c 8b       	std	Y+20, r22	; 0x14
    ListItem_t * pxListItem, * pxNext;
    ListItem_t const * pxListEnd;
    List_t const * pxList;
    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    1100:	19 86       	std	Y+9, r1	; 0x09
    1102:	18 86       	std	Y+8, r1	; 0x08
    EventGroup_t * pxEventBits = xEventGroup;
    1104:	8a 89       	ldd	r24, Y+18	; 0x12
    1106:	9b 89       	ldd	r25, Y+19	; 0x13
    1108:	9b 83       	std	Y+3, r25	; 0x03
    110a:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xMatchFound = pdFALSE;
    110c:	19 82       	std	Y+1, r1	; 0x01
    /* Check the user is not attempting to set the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    110e:	8a 81       	ldd	r24, Y+2	; 0x02
    1110:	9b 81       	ldd	r25, Y+3	; 0x03
    1112:	02 96       	adiw	r24, 0x02	; 2
    1114:	9b 87       	std	Y+11, r25	; 0x0b
    1116:	8a 87       	std	Y+10, r24	; 0x0a
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1118:	8a 85       	ldd	r24, Y+10	; 0x0a
    111a:	9b 85       	ldd	r25, Y+11	; 0x0b
    111c:	03 96       	adiw	r24, 0x03	; 3
    111e:	9d 87       	std	Y+13, r25	; 0x0d
    1120:	8c 87       	std	Y+12, r24	; 0x0c
    vTaskSuspendAll();
    1122:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    1126:	ea 85       	ldd	r30, Y+10	; 0x0a
    1128:	fb 85       	ldd	r31, Y+11	; 0x0b
    112a:	85 81       	ldd	r24, Z+5	; 0x05
    112c:	96 81       	ldd	r25, Z+6	; 0x06
    112e:	99 8b       	std	Y+17, r25	; 0x11
    1130:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    1132:	ea 81       	ldd	r30, Y+2	; 0x02
    1134:	fb 81       	ldd	r31, Y+3	; 0x03
    1136:	20 81       	ld	r18, Z
    1138:	31 81       	ldd	r19, Z+1	; 0x01
    113a:	8c 89       	ldd	r24, Y+20	; 0x14
    113c:	9d 89       	ldd	r25, Y+21	; 0x15
    113e:	82 2b       	or	r24, r18
    1140:	93 2b       	or	r25, r19
    1142:	ea 81       	ldd	r30, Y+2	; 0x02
    1144:	fb 81       	ldd	r31, Y+3	; 0x03
    1146:	91 83       	std	Z+1, r25	; 0x01
    1148:	80 83       	st	Z, r24
    114a:	59 c0       	rjmp	.+178    	; 0x11fe <xEventGroupSetBits+0x11a>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    114c:	e8 89       	ldd	r30, Y+16	; 0x10
    114e:	f9 89       	ldd	r31, Y+17	; 0x11
    1150:	82 81       	ldd	r24, Z+2	; 0x02
    1152:	93 81       	ldd	r25, Z+3	; 0x03
    1154:	9f 87       	std	Y+15, r25	; 0x0f
    1156:	8e 87       	std	Y+14, r24	; 0x0e
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    1158:	e8 89       	ldd	r30, Y+16	; 0x10
    115a:	f9 89       	ldd	r31, Y+17	; 0x11
    115c:	80 81       	ld	r24, Z
    115e:	91 81       	ldd	r25, Z+1	; 0x01
    1160:	9f 83       	std	Y+7, r25	; 0x07
    1162:	8e 83       	std	Y+6, r24	; 0x06
            xMatchFound = pdFALSE;
    1164:	19 82       	std	Y+1, r1	; 0x01

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    1166:	8e 81       	ldd	r24, Y+6	; 0x06
    1168:	9f 81       	ldd	r25, Y+7	; 0x07
    116a:	80 70       	andi	r24, 0x00	; 0
    116c:	9d 83       	std	Y+5, r25	; 0x05
    116e:	8c 83       	std	Y+4, r24	; 0x04
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    1170:	8e 81       	ldd	r24, Y+6	; 0x06
    1172:	9f 81       	ldd	r25, Y+7	; 0x07
    1174:	90 70       	andi	r25, 0x00	; 0
    1176:	9f 83       	std	Y+7, r25	; 0x07
    1178:	8e 83       	std	Y+6, r24	; 0x06

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    117a:	8c 81       	ldd	r24, Y+4	; 0x04
    117c:	9d 81       	ldd	r25, Y+5	; 0x05
    117e:	80 70       	andi	r24, 0x00	; 0
    1180:	94 70       	andi	r25, 0x04	; 4
    1182:	00 97       	sbiw	r24, 0x00	; 0
    1184:	69 f4       	brne	.+26     	; 0x11a0 <xEventGroupSetBits+0xbc>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    1186:	ea 81       	ldd	r30, Y+2	; 0x02
    1188:	fb 81       	ldd	r31, Y+3	; 0x03
    118a:	20 81       	ld	r18, Z
    118c:	31 81       	ldd	r19, Z+1	; 0x01
    118e:	8e 81       	ldd	r24, Y+6	; 0x06
    1190:	9f 81       	ldd	r25, Y+7	; 0x07
    1192:	82 23       	and	r24, r18
    1194:	93 23       	and	r25, r19
    1196:	00 97       	sbiw	r24, 0x00	; 0
    1198:	91 f0       	breq	.+36     	; 0x11be <xEventGroupSetBits+0xda>
                {
                    xMatchFound = pdTRUE;
    119a:	81 e0       	ldi	r24, 0x01	; 1
    119c:	89 83       	std	Y+1, r24	; 0x01
    119e:	0f c0       	rjmp	.+30     	; 0x11be <xEventGroupSetBits+0xda>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    11a0:	ea 81       	ldd	r30, Y+2	; 0x02
    11a2:	fb 81       	ldd	r31, Y+3	; 0x03
    11a4:	20 81       	ld	r18, Z
    11a6:	31 81       	ldd	r19, Z+1	; 0x01
    11a8:	8e 81       	ldd	r24, Y+6	; 0x06
    11aa:	9f 81       	ldd	r25, Y+7	; 0x07
    11ac:	28 23       	and	r18, r24
    11ae:	39 23       	and	r19, r25
    11b0:	8e 81       	ldd	r24, Y+6	; 0x06
    11b2:	9f 81       	ldd	r25, Y+7	; 0x07
    11b4:	28 17       	cp	r18, r24
    11b6:	39 07       	cpc	r19, r25
    11b8:	11 f4       	brne	.+4      	; 0x11be <xEventGroupSetBits+0xda>
            {
                /* All bits are set. */
                xMatchFound = pdTRUE;
    11ba:	81 e0       	ldi	r24, 0x01	; 1
    11bc:	89 83       	std	Y+1, r24	; 0x01
            else
            {
                /* Need all bits to be set, but not all the bits were set. */
            }

            if( xMatchFound != pdFALSE )
    11be:	89 81       	ldd	r24, Y+1	; 0x01
    11c0:	88 23       	and	r24, r24
    11c2:	c9 f0       	breq	.+50     	; 0x11f6 <xEventGroupSetBits+0x112>
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    11c4:	8c 81       	ldd	r24, Y+4	; 0x04
    11c6:	9d 81       	ldd	r25, Y+5	; 0x05
    11c8:	80 70       	andi	r24, 0x00	; 0
    11ca:	91 70       	andi	r25, 0x01	; 1
    11cc:	00 97       	sbiw	r24, 0x00	; 0
    11ce:	41 f0       	breq	.+16     	; 0x11e0 <xEventGroupSetBits+0xfc>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    11d0:	88 85       	ldd	r24, Y+8	; 0x08
    11d2:	99 85       	ldd	r25, Y+9	; 0x09
    11d4:	2e 81       	ldd	r18, Y+6	; 0x06
    11d6:	3f 81       	ldd	r19, Y+7	; 0x07
    11d8:	82 2b       	or	r24, r18
    11da:	93 2b       	or	r25, r19
    11dc:	99 87       	std	Y+9, r25	; 0x09
    11de:	88 87       	std	Y+8, r24	; 0x08
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    11e0:	ea 81       	ldd	r30, Y+2	; 0x02
    11e2:	fb 81       	ldd	r31, Y+3	; 0x03
    11e4:	80 81       	ld	r24, Z
    11e6:	91 81       	ldd	r25, Z+1	; 0x01
    11e8:	9c 01       	movw	r18, r24
    11ea:	32 60       	ori	r19, 0x02	; 2
    11ec:	88 89       	ldd	r24, Y+16	; 0x10
    11ee:	99 89       	ldd	r25, Y+17	; 0x11
    11f0:	b9 01       	movw	r22, r18
    11f2:	0e 94 a8 1d 	call	0x3b50	; 0x3b50 <vTaskRemoveFromUnorderedEventList>
            }

            /* Move onto the next list item.  Note pxListItem->pxNext is not
             * used here as the list item may have been removed from the event list
             * and inserted into the ready/pending reading list. */
            pxListItem = pxNext;
    11f6:	8e 85       	ldd	r24, Y+14	; 0x0e
    11f8:	9f 85       	ldd	r25, Y+15	; 0x0f
    11fa:	99 8b       	std	Y+17, r25	; 0x11
    11fc:	88 8b       	std	Y+16, r24	; 0x10

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    11fe:	28 89       	ldd	r18, Y+16	; 0x10
    1200:	39 89       	ldd	r19, Y+17	; 0x11
    1202:	8c 85       	ldd	r24, Y+12	; 0x0c
    1204:	9d 85       	ldd	r25, Y+13	; 0x0d
    1206:	28 17       	cp	r18, r24
    1208:	39 07       	cpc	r19, r25
    120a:	09 f0       	breq	.+2      	; 0x120e <xEventGroupSetBits+0x12a>
    120c:	9f cf       	rjmp	.-194    	; 0x114c <xEventGroupSetBits+0x68>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    120e:	ea 81       	ldd	r30, Y+2	; 0x02
    1210:	fb 81       	ldd	r31, Y+3	; 0x03
    1212:	20 81       	ld	r18, Z
    1214:	31 81       	ldd	r19, Z+1	; 0x01
    1216:	88 85       	ldd	r24, Y+8	; 0x08
    1218:	99 85       	ldd	r25, Y+9	; 0x09
    121a:	80 95       	com	r24
    121c:	90 95       	com	r25
    121e:	82 23       	and	r24, r18
    1220:	93 23       	and	r25, r19
    1222:	ea 81       	ldd	r30, Y+2	; 0x02
    1224:	fb 81       	ldd	r31, Y+3	; 0x03
    1226:	91 83       	std	Z+1, r25	; 0x01
    1228:	80 83       	st	Z, r24
    }
    ( void ) xTaskResumeAll();
    122a:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
    122e:	ea 81       	ldd	r30, Y+2	; 0x02
    1230:	fb 81       	ldd	r31, Y+3	; 0x03
    1232:	80 81       	ld	r24, Z
    1234:	91 81       	ldd	r25, Z+1	; 0x01
}
    1236:	65 96       	adiw	r28, 0x15	; 21
    1238:	0f b6       	in	r0, 0x3f	; 63
    123a:	f8 94       	cli
    123c:	de bf       	out	0x3e, r29	; 62
    123e:	0f be       	out	0x3f, r0	; 63
    1240:	cd bf       	out	0x3d, r28	; 61
    1242:	cf 91       	pop	r28
    1244:	df 91       	pop	r29
    1246:	08 95       	ret

00001248 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1248:	df 93       	push	r29
    124a:	cf 93       	push	r28
    124c:	00 d0       	rcall	.+0      	; 0x124e <vEventGroupDelete+0x6>
    124e:	00 d0       	rcall	.+0      	; 0x1250 <vEventGroupDelete+0x8>
    1250:	00 d0       	rcall	.+0      	; 0x1252 <vEventGroupDelete+0xa>
    1252:	cd b7       	in	r28, 0x3d	; 61
    1254:	de b7       	in	r29, 0x3e	; 62
    1256:	9e 83       	std	Y+6, r25	; 0x06
    1258:	8d 83       	std	Y+5, r24	; 0x05
    EventGroup_t * pxEventBits = xEventGroup;
    125a:	8d 81       	ldd	r24, Y+5	; 0x05
    125c:	9e 81       	ldd	r25, Y+6	; 0x06
    125e:	9c 83       	std	Y+4, r25	; 0x04
    1260:	8b 83       	std	Y+3, r24	; 0x03
    const List_t * pxTasksWaitingForBits;

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    1262:	8b 81       	ldd	r24, Y+3	; 0x03
    1264:	9c 81       	ldd	r25, Y+4	; 0x04
    1266:	02 96       	adiw	r24, 0x02	; 2
    1268:	9a 83       	std	Y+2, r25	; 0x02
    126a:	89 83       	std	Y+1, r24	; 0x01

    vTaskSuspendAll();
    126c:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <vTaskSuspendAll>
    1270:	08 c0       	rjmp	.+16     	; 0x1282 <vEventGroupDelete+0x3a>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1272:	e9 81       	ldd	r30, Y+1	; 0x01
    1274:	fa 81       	ldd	r31, Y+2	; 0x02
    1276:	85 81       	ldd	r24, Z+5	; 0x05
    1278:	96 81       	ldd	r25, Z+6	; 0x06
    127a:	60 e0       	ldi	r22, 0x00	; 0
    127c:	72 e0       	ldi	r23, 0x02	; 2
    127e:	0e 94 a8 1d 	call	0x3b50	; 0x3b50 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1282:	e9 81       	ldd	r30, Y+1	; 0x01
    1284:	fa 81       	ldd	r31, Y+2	; 0x02
    1286:	80 81       	ld	r24, Z
    1288:	88 23       	and	r24, r24
    128a:	99 f7       	brne	.-26     	; 0x1272 <vEventGroupDelete+0x2a>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
            {
                /* The event group can only have been allocated dynamically - free
                 * it again. */
                vPortFree( pxEventBits );
    128c:	8b 81       	ldd	r24, Y+3	; 0x03
    128e:	9c 81       	ldd	r25, Y+4	; 0x04
    1290:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    ( void ) xTaskResumeAll();
    1294:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>
}
    1298:	26 96       	adiw	r28, 0x06	; 6
    129a:	0f b6       	in	r0, 0x3f	; 63
    129c:	f8 94       	cli
    129e:	de bf       	out	0x3e, r29	; 62
    12a0:	0f be       	out	0x3f, r0	; 63
    12a2:	cd bf       	out	0x3d, r28	; 61
    12a4:	cf 91       	pop	r28
    12a6:	df 91       	pop	r29
    12a8:	08 95       	ret

000012aa <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    12aa:	df 93       	push	r29
    12ac:	cf 93       	push	r28
    12ae:	00 d0       	rcall	.+0      	; 0x12b0 <vEventGroupSetBitsCallback+0x6>
    12b0:	00 d0       	rcall	.+0      	; 0x12b2 <vEventGroupSetBitsCallback+0x8>
    12b2:	00 d0       	rcall	.+0      	; 0x12b4 <vEventGroupSetBitsCallback+0xa>
    12b4:	cd b7       	in	r28, 0x3d	; 61
    12b6:	de b7       	in	r29, 0x3e	; 62
    12b8:	9a 83       	std	Y+2, r25	; 0x02
    12ba:	89 83       	std	Y+1, r24	; 0x01
    12bc:	4b 83       	std	Y+3, r20	; 0x03
    12be:	5c 83       	std	Y+4, r21	; 0x04
    12c0:	6d 83       	std	Y+5, r22	; 0x05
    12c2:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    12c4:	89 81       	ldd	r24, Y+1	; 0x01
    12c6:	9a 81       	ldd	r25, Y+2	; 0x02
    12c8:	2b 81       	ldd	r18, Y+3	; 0x03
    12ca:	3c 81       	ldd	r19, Y+4	; 0x04
    12cc:	b9 01       	movw	r22, r18
    12ce:	0e 94 72 08 	call	0x10e4	; 0x10e4 <xEventGroupSetBits>
}
    12d2:	26 96       	adiw	r28, 0x06	; 6
    12d4:	0f b6       	in	r0, 0x3f	; 63
    12d6:	f8 94       	cli
    12d8:	de bf       	out	0x3e, r29	; 62
    12da:	0f be       	out	0x3f, r0	; 63
    12dc:	cd bf       	out	0x3d, r28	; 61
    12de:	cf 91       	pop	r28
    12e0:	df 91       	pop	r29
    12e2:	08 95       	ret

000012e4 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    12e4:	df 93       	push	r29
    12e6:	cf 93       	push	r28
    12e8:	00 d0       	rcall	.+0      	; 0x12ea <vEventGroupClearBitsCallback+0x6>
    12ea:	00 d0       	rcall	.+0      	; 0x12ec <vEventGroupClearBitsCallback+0x8>
    12ec:	00 d0       	rcall	.+0      	; 0x12ee <vEventGroupClearBitsCallback+0xa>
    12ee:	cd b7       	in	r28, 0x3d	; 61
    12f0:	de b7       	in	r29, 0x3e	; 62
    12f2:	9a 83       	std	Y+2, r25	; 0x02
    12f4:	89 83       	std	Y+1, r24	; 0x01
    12f6:	4b 83       	std	Y+3, r20	; 0x03
    12f8:	5c 83       	std	Y+4, r21	; 0x04
    12fa:	6d 83       	std	Y+5, r22	; 0x05
    12fc:	7e 83       	std	Y+6, r23	; 0x06
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    12fe:	89 81       	ldd	r24, Y+1	; 0x01
    1300:	9a 81       	ldd	r25, Y+2	; 0x02
    1302:	2b 81       	ldd	r18, Y+3	; 0x03
    1304:	3c 81       	ldd	r19, Y+4	; 0x04
    1306:	b9 01       	movw	r22, r18
    1308:	0e 94 1a 08 	call	0x1034	; 0x1034 <xEventGroupClearBits>
}
    130c:	26 96       	adiw	r28, 0x06	; 6
    130e:	0f b6       	in	r0, 0x3f	; 63
    1310:	f8 94       	cli
    1312:	de bf       	out	0x3e, r29	; 62
    1314:	0f be       	out	0x3f, r0	; 63
    1316:	cd bf       	out	0x3d, r28	; 61
    1318:	cf 91       	pop	r28
    131a:	df 91       	pop	r29
    131c:	08 95       	ret

0000131e <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits,
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    131e:	df 93       	push	r29
    1320:	cf 93       	push	r28
    1322:	00 d0       	rcall	.+0      	; 0x1324 <prvTestWaitCondition+0x6>
    1324:	00 d0       	rcall	.+0      	; 0x1326 <prvTestWaitCondition+0x8>
    1326:	00 d0       	rcall	.+0      	; 0x1328 <prvTestWaitCondition+0xa>
    1328:	cd b7       	in	r28, 0x3d	; 61
    132a:	de b7       	in	r29, 0x3e	; 62
    132c:	9b 83       	std	Y+3, r25	; 0x03
    132e:	8a 83       	std	Y+2, r24	; 0x02
    1330:	7d 83       	std	Y+5, r23	; 0x05
    1332:	6c 83       	std	Y+4, r22	; 0x04
    1334:	4e 83       	std	Y+6, r20	; 0x06
    BaseType_t xWaitConditionMet = pdFALSE;
    1336:	19 82       	std	Y+1, r1	; 0x01

    if( xWaitForAllBits == pdFALSE )
    1338:	8e 81       	ldd	r24, Y+6	; 0x06
    133a:	88 23       	and	r24, r24
    133c:	59 f4       	brne	.+22     	; 0x1354 <prvTestWaitCondition+0x36>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    133e:	8a 81       	ldd	r24, Y+2	; 0x02
    1340:	9b 81       	ldd	r25, Y+3	; 0x03
    1342:	2c 81       	ldd	r18, Y+4	; 0x04
    1344:	3d 81       	ldd	r19, Y+5	; 0x05
    1346:	82 23       	and	r24, r18
    1348:	93 23       	and	r25, r19
    134a:	00 97       	sbiw	r24, 0x00	; 0
    134c:	81 f0       	breq	.+32     	; 0x136e <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    134e:	81 e0       	ldi	r24, 0x01	; 1
    1350:	89 83       	std	Y+1, r24	; 0x01
    1352:	0d c0       	rjmp	.+26     	; 0x136e <prvTestWaitCondition+0x50>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1354:	2a 81       	ldd	r18, Y+2	; 0x02
    1356:	3b 81       	ldd	r19, Y+3	; 0x03
    1358:	8c 81       	ldd	r24, Y+4	; 0x04
    135a:	9d 81       	ldd	r25, Y+5	; 0x05
    135c:	28 23       	and	r18, r24
    135e:	39 23       	and	r19, r25
    1360:	8c 81       	ldd	r24, Y+4	; 0x04
    1362:	9d 81       	ldd	r25, Y+5	; 0x05
    1364:	28 17       	cp	r18, r24
    1366:	39 07       	cpc	r19, r25
    1368:	11 f4       	brne	.+4      	; 0x136e <prvTestWaitCondition+0x50>
        {
            xWaitConditionMet = pdTRUE;
    136a:	81 e0       	ldi	r24, 0x01	; 1
    136c:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
    136e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1370:	26 96       	adiw	r28, 0x06	; 6
    1372:	0f b6       	in	r0, 0x3f	; 63
    1374:	f8 94       	cli
    1376:	de bf       	out	0x3e, r29	; 62
    1378:	0f be       	out	0x3f, r0	; 63
    137a:	cd bf       	out	0x3d, r28	; 61
    137c:	cf 91       	pop	r28
    137e:	df 91       	pop	r29
    1380:	08 95       	ret

00001382 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1382:	df 93       	push	r29
    1384:	cf 93       	push	r28
    1386:	00 d0       	rcall	.+0      	; 0x1388 <vListInitialise+0x6>
    1388:	cd b7       	in	r28, 0x3d	; 61
    138a:	de b7       	in	r29, 0x3e	; 62
    138c:	9a 83       	std	Y+2, r25	; 0x02
    138e:	89 83       	std	Y+1, r24	; 0x01
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1390:	89 81       	ldd	r24, Y+1	; 0x01
    1392:	9a 81       	ldd	r25, Y+2	; 0x02
    1394:	03 96       	adiw	r24, 0x03	; 3
    1396:	e9 81       	ldd	r30, Y+1	; 0x01
    1398:	fa 81       	ldd	r31, Y+2	; 0x02
    139a:	92 83       	std	Z+2, r25	; 0x02
    139c:	81 83       	std	Z+1, r24	; 0x01

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    139e:	e9 81       	ldd	r30, Y+1	; 0x01
    13a0:	fa 81       	ldd	r31, Y+2	; 0x02
    13a2:	8f ef       	ldi	r24, 0xFF	; 255
    13a4:	9f ef       	ldi	r25, 0xFF	; 255
    13a6:	94 83       	std	Z+4, r25	; 0x04
    13a8:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    13aa:	89 81       	ldd	r24, Y+1	; 0x01
    13ac:	9a 81       	ldd	r25, Y+2	; 0x02
    13ae:	03 96       	adiw	r24, 0x03	; 3
    13b0:	e9 81       	ldd	r30, Y+1	; 0x01
    13b2:	fa 81       	ldd	r31, Y+2	; 0x02
    13b4:	96 83       	std	Z+6, r25	; 0x06
    13b6:	85 83       	std	Z+5, r24	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    13b8:	89 81       	ldd	r24, Y+1	; 0x01
    13ba:	9a 81       	ldd	r25, Y+2	; 0x02
    13bc:	03 96       	adiw	r24, 0x03	; 3
    13be:	e9 81       	ldd	r30, Y+1	; 0x01
    13c0:	fa 81       	ldd	r31, Y+2	; 0x02
    13c2:	90 87       	std	Z+8, r25	; 0x08
    13c4:	87 83       	std	Z+7, r24	; 0x07

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    13c6:	e9 81       	ldd	r30, Y+1	; 0x01
    13c8:	fa 81       	ldd	r31, Y+2	; 0x02
    13ca:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    13cc:	0f 90       	pop	r0
    13ce:	0f 90       	pop	r0
    13d0:	cf 91       	pop	r28
    13d2:	df 91       	pop	r29
    13d4:	08 95       	ret

000013d6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    13d6:	df 93       	push	r29
    13d8:	cf 93       	push	r28
    13da:	00 d0       	rcall	.+0      	; 0x13dc <vListInitialiseItem+0x6>
    13dc:	cd b7       	in	r28, 0x3d	; 61
    13de:	de b7       	in	r29, 0x3e	; 62
    13e0:	9a 83       	std	Y+2, r25	; 0x02
    13e2:	89 83       	std	Y+1, r24	; 0x01
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    13e4:	e9 81       	ldd	r30, Y+1	; 0x01
    13e6:	fa 81       	ldd	r31, Y+2	; 0x02
    13e8:	11 86       	std	Z+9, r1	; 0x09
    13ea:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    13ec:	0f 90       	pop	r0
    13ee:	0f 90       	pop	r0
    13f0:	cf 91       	pop	r28
    13f2:	df 91       	pop	r29
    13f4:	08 95       	ret

000013f6 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    13f6:	df 93       	push	r29
    13f8:	cf 93       	push	r28
    13fa:	00 d0       	rcall	.+0      	; 0x13fc <vListInsertEnd+0x6>
    13fc:	00 d0       	rcall	.+0      	; 0x13fe <vListInsertEnd+0x8>
    13fe:	00 d0       	rcall	.+0      	; 0x1400 <vListInsertEnd+0xa>
    1400:	cd b7       	in	r28, 0x3d	; 61
    1402:	de b7       	in	r29, 0x3e	; 62
    1404:	9c 83       	std	Y+4, r25	; 0x04
    1406:	8b 83       	std	Y+3, r24	; 0x03
    1408:	7e 83       	std	Y+6, r23	; 0x06
    140a:	6d 83       	std	Y+5, r22	; 0x05
    ListItem_t * const pxIndex = pxList->pxIndex;
    140c:	eb 81       	ldd	r30, Y+3	; 0x03
    140e:	fc 81       	ldd	r31, Y+4	; 0x04
    1410:	81 81       	ldd	r24, Z+1	; 0x01
    1412:	92 81       	ldd	r25, Z+2	; 0x02
    1414:	9a 83       	std	Y+2, r25	; 0x02
    1416:	89 83       	std	Y+1, r24	; 0x01
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    1418:	ed 81       	ldd	r30, Y+5	; 0x05
    141a:	fe 81       	ldd	r31, Y+6	; 0x06
    141c:	89 81       	ldd	r24, Y+1	; 0x01
    141e:	9a 81       	ldd	r25, Y+2	; 0x02
    1420:	93 83       	std	Z+3, r25	; 0x03
    1422:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1424:	e9 81       	ldd	r30, Y+1	; 0x01
    1426:	fa 81       	ldd	r31, Y+2	; 0x02
    1428:	84 81       	ldd	r24, Z+4	; 0x04
    142a:	95 81       	ldd	r25, Z+5	; 0x05
    142c:	ed 81       	ldd	r30, Y+5	; 0x05
    142e:	fe 81       	ldd	r31, Y+6	; 0x06
    1430:	95 83       	std	Z+5, r25	; 0x05
    1432:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    1434:	e9 81       	ldd	r30, Y+1	; 0x01
    1436:	fa 81       	ldd	r31, Y+2	; 0x02
    1438:	04 80       	ldd	r0, Z+4	; 0x04
    143a:	f5 81       	ldd	r31, Z+5	; 0x05
    143c:	e0 2d       	mov	r30, r0
    143e:	8d 81       	ldd	r24, Y+5	; 0x05
    1440:	9e 81       	ldd	r25, Y+6	; 0x06
    1442:	93 83       	std	Z+3, r25	; 0x03
    1444:	82 83       	std	Z+2, r24	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    1446:	e9 81       	ldd	r30, Y+1	; 0x01
    1448:	fa 81       	ldd	r31, Y+2	; 0x02
    144a:	8d 81       	ldd	r24, Y+5	; 0x05
    144c:	9e 81       	ldd	r25, Y+6	; 0x06
    144e:	95 83       	std	Z+5, r25	; 0x05
    1450:	84 83       	std	Z+4, r24	; 0x04

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    1452:	ed 81       	ldd	r30, Y+5	; 0x05
    1454:	fe 81       	ldd	r31, Y+6	; 0x06
    1456:	8b 81       	ldd	r24, Y+3	; 0x03
    1458:	9c 81       	ldd	r25, Y+4	; 0x04
    145a:	91 87       	std	Z+9, r25	; 0x09
    145c:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    145e:	eb 81       	ldd	r30, Y+3	; 0x03
    1460:	fc 81       	ldd	r31, Y+4	; 0x04
    1462:	80 81       	ld	r24, Z
    1464:	8f 5f       	subi	r24, 0xFF	; 255
    1466:	eb 81       	ldd	r30, Y+3	; 0x03
    1468:	fc 81       	ldd	r31, Y+4	; 0x04
    146a:	80 83       	st	Z, r24
}
    146c:	26 96       	adiw	r28, 0x06	; 6
    146e:	0f b6       	in	r0, 0x3f	; 63
    1470:	f8 94       	cli
    1472:	de bf       	out	0x3e, r29	; 62
    1474:	0f be       	out	0x3f, r0	; 63
    1476:	cd bf       	out	0x3d, r28	; 61
    1478:	cf 91       	pop	r28
    147a:	df 91       	pop	r29
    147c:	08 95       	ret

0000147e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    147e:	df 93       	push	r29
    1480:	cf 93       	push	r28
    1482:	cd b7       	in	r28, 0x3d	; 61
    1484:	de b7       	in	r29, 0x3e	; 62
    1486:	28 97       	sbiw	r28, 0x08	; 8
    1488:	0f b6       	in	r0, 0x3f	; 63
    148a:	f8 94       	cli
    148c:	de bf       	out	0x3e, r29	; 62
    148e:	0f be       	out	0x3f, r0	; 63
    1490:	cd bf       	out	0x3d, r28	; 61
    1492:	9e 83       	std	Y+6, r25	; 0x06
    1494:	8d 83       	std	Y+5, r24	; 0x05
    1496:	78 87       	std	Y+8, r23	; 0x08
    1498:	6f 83       	std	Y+7, r22	; 0x07
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    149a:	ef 81       	ldd	r30, Y+7	; 0x07
    149c:	f8 85       	ldd	r31, Y+8	; 0x08
    149e:	80 81       	ld	r24, Z
    14a0:	91 81       	ldd	r25, Z+1	; 0x01
    14a2:	9a 83       	std	Y+2, r25	; 0x02
    14a4:	89 83       	std	Y+1, r24	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    14a6:	89 81       	ldd	r24, Y+1	; 0x01
    14a8:	9a 81       	ldd	r25, Y+2	; 0x02
    14aa:	2f ef       	ldi	r18, 0xFF	; 255
    14ac:	8f 3f       	cpi	r24, 0xFF	; 255
    14ae:	92 07       	cpc	r25, r18
    14b0:	39 f4       	brne	.+14     	; 0x14c0 <vListInsert+0x42>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    14b2:	ed 81       	ldd	r30, Y+5	; 0x05
    14b4:	fe 81       	ldd	r31, Y+6	; 0x06
    14b6:	87 81       	ldd	r24, Z+7	; 0x07
    14b8:	90 85       	ldd	r25, Z+8	; 0x08
    14ba:	9c 83       	std	Y+4, r25	; 0x04
    14bc:	8b 83       	std	Y+3, r24	; 0x03
    14be:	18 c0       	rjmp	.+48     	; 0x14f0 <vListInsert+0x72>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    14c0:	8d 81       	ldd	r24, Y+5	; 0x05
    14c2:	9e 81       	ldd	r25, Y+6	; 0x06
    14c4:	03 96       	adiw	r24, 0x03	; 3
    14c6:	9c 83       	std	Y+4, r25	; 0x04
    14c8:	8b 83       	std	Y+3, r24	; 0x03
    14ca:	06 c0       	rjmp	.+12     	; 0x14d8 <vListInsert+0x5a>
    14cc:	eb 81       	ldd	r30, Y+3	; 0x03
    14ce:	fc 81       	ldd	r31, Y+4	; 0x04
    14d0:	82 81       	ldd	r24, Z+2	; 0x02
    14d2:	93 81       	ldd	r25, Z+3	; 0x03
    14d4:	9c 83       	std	Y+4, r25	; 0x04
    14d6:	8b 83       	std	Y+3, r24	; 0x03
    14d8:	eb 81       	ldd	r30, Y+3	; 0x03
    14da:	fc 81       	ldd	r31, Y+4	; 0x04
    14dc:	02 80       	ldd	r0, Z+2	; 0x02
    14de:	f3 81       	ldd	r31, Z+3	; 0x03
    14e0:	e0 2d       	mov	r30, r0
    14e2:	20 81       	ld	r18, Z
    14e4:	31 81       	ldd	r19, Z+1	; 0x01
    14e6:	89 81       	ldd	r24, Y+1	; 0x01
    14e8:	9a 81       	ldd	r25, Y+2	; 0x02
    14ea:	82 17       	cp	r24, r18
    14ec:	93 07       	cpc	r25, r19
    14ee:	70 f7       	brcc	.-36     	; 0x14cc <vListInsert+0x4e>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    14f0:	eb 81       	ldd	r30, Y+3	; 0x03
    14f2:	fc 81       	ldd	r31, Y+4	; 0x04
    14f4:	82 81       	ldd	r24, Z+2	; 0x02
    14f6:	93 81       	ldd	r25, Z+3	; 0x03
    14f8:	ef 81       	ldd	r30, Y+7	; 0x07
    14fa:	f8 85       	ldd	r31, Y+8	; 0x08
    14fc:	93 83       	std	Z+3, r25	; 0x03
    14fe:	82 83       	std	Z+2, r24	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1500:	ef 81       	ldd	r30, Y+7	; 0x07
    1502:	f8 85       	ldd	r31, Y+8	; 0x08
    1504:	02 80       	ldd	r0, Z+2	; 0x02
    1506:	f3 81       	ldd	r31, Z+3	; 0x03
    1508:	e0 2d       	mov	r30, r0
    150a:	8f 81       	ldd	r24, Y+7	; 0x07
    150c:	98 85       	ldd	r25, Y+8	; 0x08
    150e:	95 83       	std	Z+5, r25	; 0x05
    1510:	84 83       	std	Z+4, r24	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1512:	ef 81       	ldd	r30, Y+7	; 0x07
    1514:	f8 85       	ldd	r31, Y+8	; 0x08
    1516:	8b 81       	ldd	r24, Y+3	; 0x03
    1518:	9c 81       	ldd	r25, Y+4	; 0x04
    151a:	95 83       	std	Z+5, r25	; 0x05
    151c:	84 83       	std	Z+4, r24	; 0x04
    pxIterator->pxNext = pxNewListItem;
    151e:	eb 81       	ldd	r30, Y+3	; 0x03
    1520:	fc 81       	ldd	r31, Y+4	; 0x04
    1522:	8f 81       	ldd	r24, Y+7	; 0x07
    1524:	98 85       	ldd	r25, Y+8	; 0x08
    1526:	93 83       	std	Z+3, r25	; 0x03
    1528:	82 83       	std	Z+2, r24	; 0x02

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    152a:	ef 81       	ldd	r30, Y+7	; 0x07
    152c:	f8 85       	ldd	r31, Y+8	; 0x08
    152e:	8d 81       	ldd	r24, Y+5	; 0x05
    1530:	9e 81       	ldd	r25, Y+6	; 0x06
    1532:	91 87       	std	Z+9, r25	; 0x09
    1534:	80 87       	std	Z+8, r24	; 0x08

    ( pxList->uxNumberOfItems )++;
    1536:	ed 81       	ldd	r30, Y+5	; 0x05
    1538:	fe 81       	ldd	r31, Y+6	; 0x06
    153a:	80 81       	ld	r24, Z
    153c:	8f 5f       	subi	r24, 0xFF	; 255
    153e:	ed 81       	ldd	r30, Y+5	; 0x05
    1540:	fe 81       	ldd	r31, Y+6	; 0x06
    1542:	80 83       	st	Z, r24
}
    1544:	28 96       	adiw	r28, 0x08	; 8
    1546:	0f b6       	in	r0, 0x3f	; 63
    1548:	f8 94       	cli
    154a:	de bf       	out	0x3e, r29	; 62
    154c:	0f be       	out	0x3f, r0	; 63
    154e:	cd bf       	out	0x3d, r28	; 61
    1550:	cf 91       	pop	r28
    1552:	df 91       	pop	r29
    1554:	08 95       	ret

00001556 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1556:	df 93       	push	r29
    1558:	cf 93       	push	r28
    155a:	00 d0       	rcall	.+0      	; 0x155c <uxListRemove+0x6>
    155c:	00 d0       	rcall	.+0      	; 0x155e <uxListRemove+0x8>
    155e:	cd b7       	in	r28, 0x3d	; 61
    1560:	de b7       	in	r29, 0x3e	; 62
    1562:	9c 83       	std	Y+4, r25	; 0x04
    1564:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    1566:	eb 81       	ldd	r30, Y+3	; 0x03
    1568:	fc 81       	ldd	r31, Y+4	; 0x04
    156a:	80 85       	ldd	r24, Z+8	; 0x08
    156c:	91 85       	ldd	r25, Z+9	; 0x09
    156e:	9a 83       	std	Y+2, r25	; 0x02
    1570:	89 83       	std	Y+1, r24	; 0x01

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1572:	eb 81       	ldd	r30, Y+3	; 0x03
    1574:	fc 81       	ldd	r31, Y+4	; 0x04
    1576:	a2 81       	ldd	r26, Z+2	; 0x02
    1578:	b3 81       	ldd	r27, Z+3	; 0x03
    157a:	eb 81       	ldd	r30, Y+3	; 0x03
    157c:	fc 81       	ldd	r31, Y+4	; 0x04
    157e:	84 81       	ldd	r24, Z+4	; 0x04
    1580:	95 81       	ldd	r25, Z+5	; 0x05
    1582:	15 96       	adiw	r26, 0x05	; 5
    1584:	9c 93       	st	X, r25
    1586:	8e 93       	st	-X, r24
    1588:	14 97       	sbiw	r26, 0x04	; 4
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    158a:	eb 81       	ldd	r30, Y+3	; 0x03
    158c:	fc 81       	ldd	r31, Y+4	; 0x04
    158e:	a4 81       	ldd	r26, Z+4	; 0x04
    1590:	b5 81       	ldd	r27, Z+5	; 0x05
    1592:	eb 81       	ldd	r30, Y+3	; 0x03
    1594:	fc 81       	ldd	r31, Y+4	; 0x04
    1596:	82 81       	ldd	r24, Z+2	; 0x02
    1598:	93 81       	ldd	r25, Z+3	; 0x03
    159a:	13 96       	adiw	r26, 0x03	; 3
    159c:	9c 93       	st	X, r25
    159e:	8e 93       	st	-X, r24
    15a0:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    15a2:	e9 81       	ldd	r30, Y+1	; 0x01
    15a4:	fa 81       	ldd	r31, Y+2	; 0x02
    15a6:	21 81       	ldd	r18, Z+1	; 0x01
    15a8:	32 81       	ldd	r19, Z+2	; 0x02
    15aa:	8b 81       	ldd	r24, Y+3	; 0x03
    15ac:	9c 81       	ldd	r25, Y+4	; 0x04
    15ae:	28 17       	cp	r18, r24
    15b0:	39 07       	cpc	r19, r25
    15b2:	41 f4       	brne	.+16     	; 0x15c4 <uxListRemove+0x6e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    15b4:	eb 81       	ldd	r30, Y+3	; 0x03
    15b6:	fc 81       	ldd	r31, Y+4	; 0x04
    15b8:	84 81       	ldd	r24, Z+4	; 0x04
    15ba:	95 81       	ldd	r25, Z+5	; 0x05
    15bc:	e9 81       	ldd	r30, Y+1	; 0x01
    15be:	fa 81       	ldd	r31, Y+2	; 0x02
    15c0:	92 83       	std	Z+2, r25	; 0x02
    15c2:	81 83       	std	Z+1, r24	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    15c4:	eb 81       	ldd	r30, Y+3	; 0x03
    15c6:	fc 81       	ldd	r31, Y+4	; 0x04
    15c8:	11 86       	std	Z+9, r1	; 0x09
    15ca:	10 86       	std	Z+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    15cc:	e9 81       	ldd	r30, Y+1	; 0x01
    15ce:	fa 81       	ldd	r31, Y+2	; 0x02
    15d0:	80 81       	ld	r24, Z
    15d2:	81 50       	subi	r24, 0x01	; 1
    15d4:	e9 81       	ldd	r30, Y+1	; 0x01
    15d6:	fa 81       	ldd	r31, Y+2	; 0x02
    15d8:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    15da:	e9 81       	ldd	r30, Y+1	; 0x01
    15dc:	fa 81       	ldd	r31, Y+2	; 0x02
    15de:	80 81       	ld	r24, Z
}
    15e0:	0f 90       	pop	r0
    15e2:	0f 90       	pop	r0
    15e4:	0f 90       	pop	r0
    15e6:	0f 90       	pop	r0
    15e8:	cf 91       	pop	r28
    15ea:	df 91       	pop	r29
    15ec:	08 95       	ret

000015ee <xQueueGenericReset>:
    taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    15ee:	df 93       	push	r29
    15f0:	cf 93       	push	r28
    15f2:	00 d0       	rcall	.+0      	; 0x15f4 <xQueueGenericReset+0x6>
    15f4:	00 d0       	rcall	.+0      	; 0x15f6 <xQueueGenericReset+0x8>
    15f6:	00 d0       	rcall	.+0      	; 0x15f8 <xQueueGenericReset+0xa>
    15f8:	cd b7       	in	r28, 0x3d	; 61
    15fa:	de b7       	in	r29, 0x3e	; 62
    15fc:	9d 83       	std	Y+5, r25	; 0x05
    15fe:	8c 83       	std	Y+4, r24	; 0x04
    1600:	6e 83       	std	Y+6, r22	; 0x06
    BaseType_t xReturn = pdPASS;
    1602:	81 e0       	ldi	r24, 0x01	; 1
    1604:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    1606:	8c 81       	ldd	r24, Y+4	; 0x04
    1608:	9d 81       	ldd	r25, Y+5	; 0x05
    160a:	9a 83       	std	Y+2, r25	; 0x02
    160c:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    160e:	89 81       	ldd	r24, Y+1	; 0x01
    1610:	9a 81       	ldd	r25, Y+2	; 0x02
    1612:	00 97       	sbiw	r24, 0x00	; 0
    1614:	09 f4       	brne	.+2      	; 0x1618 <xQueueGenericReset+0x2a>
    1616:	8b c0       	rjmp	.+278    	; 0x172e <xQueueGenericReset+0x140>
    1618:	e9 81       	ldd	r30, Y+1	; 0x01
    161a:	fa 81       	ldd	r31, Y+2	; 0x02
    161c:	83 8d       	ldd	r24, Z+27	; 0x1b
    161e:	88 23       	and	r24, r24
    1620:	09 f4       	brne	.+2      	; 0x1624 <xQueueGenericReset+0x36>
    1622:	85 c0       	rjmp	.+266    	; 0x172e <xQueueGenericReset+0x140>
    1624:	e9 81       	ldd	r30, Y+1	; 0x01
    1626:	fa 81       	ldd	r31, Y+2	; 0x02
    1628:	83 8d       	ldd	r24, Z+27	; 0x1b
    162a:	28 2f       	mov	r18, r24
    162c:	30 e0       	ldi	r19, 0x00	; 0
    162e:	8f ef       	ldi	r24, 0xFF	; 255
    1630:	9f e7       	ldi	r25, 0x7F	; 127
    1632:	b9 01       	movw	r22, r18
    1634:	0e 94 ef 32 	call	0x65de	; 0x65de <__udivmodhi4>
    1638:	cb 01       	movw	r24, r22
    163a:	9c 01       	movw	r18, r24
    163c:	e9 81       	ldd	r30, Y+1	; 0x01
    163e:	fa 81       	ldd	r31, Y+2	; 0x02
    1640:	84 8d       	ldd	r24, Z+28	; 0x1c
    1642:	88 2f       	mov	r24, r24
    1644:	90 e0       	ldi	r25, 0x00	; 0
    1646:	28 17       	cp	r18, r24
    1648:	39 07       	cpc	r19, r25
    164a:	08 f4       	brcc	.+2      	; 0x164e <xQueueGenericReset+0x60>
    164c:	70 c0       	rjmp	.+224    	; 0x172e <xQueueGenericReset+0x140>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    164e:	0f b6       	in	r0, 0x3f	; 63
    1650:	f8 94       	cli
    1652:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1654:	e9 81       	ldd	r30, Y+1	; 0x01
    1656:	fa 81       	ldd	r31, Y+2	; 0x02
    1658:	40 81       	ld	r20, Z
    165a:	51 81       	ldd	r21, Z+1	; 0x01
    165c:	e9 81       	ldd	r30, Y+1	; 0x01
    165e:	fa 81       	ldd	r31, Y+2	; 0x02
    1660:	83 8d       	ldd	r24, Z+27	; 0x1b
    1662:	28 2f       	mov	r18, r24
    1664:	30 e0       	ldi	r19, 0x00	; 0
    1666:	e9 81       	ldd	r30, Y+1	; 0x01
    1668:	fa 81       	ldd	r31, Y+2	; 0x02
    166a:	84 8d       	ldd	r24, Z+28	; 0x1c
    166c:	88 2f       	mov	r24, r24
    166e:	90 e0       	ldi	r25, 0x00	; 0
    1670:	bc 01       	movw	r22, r24
    1672:	26 9f       	mul	r18, r22
    1674:	c0 01       	movw	r24, r0
    1676:	27 9f       	mul	r18, r23
    1678:	90 0d       	add	r25, r0
    167a:	36 9f       	mul	r19, r22
    167c:	90 0d       	add	r25, r0
    167e:	11 24       	eor	r1, r1
    1680:	84 0f       	add	r24, r20
    1682:	95 1f       	adc	r25, r21
    1684:	e9 81       	ldd	r30, Y+1	; 0x01
    1686:	fa 81       	ldd	r31, Y+2	; 0x02
    1688:	95 83       	std	Z+5, r25	; 0x05
    168a:	84 83       	std	Z+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    168c:	e9 81       	ldd	r30, Y+1	; 0x01
    168e:	fa 81       	ldd	r31, Y+2	; 0x02
    1690:	12 8e       	std	Z+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    1692:	e9 81       	ldd	r30, Y+1	; 0x01
    1694:	fa 81       	ldd	r31, Y+2	; 0x02
    1696:	80 81       	ld	r24, Z
    1698:	91 81       	ldd	r25, Z+1	; 0x01
    169a:	e9 81       	ldd	r30, Y+1	; 0x01
    169c:	fa 81       	ldd	r31, Y+2	; 0x02
    169e:	93 83       	std	Z+3, r25	; 0x03
    16a0:	82 83       	std	Z+2, r24	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    16a2:	e9 81       	ldd	r30, Y+1	; 0x01
    16a4:	fa 81       	ldd	r31, Y+2	; 0x02
    16a6:	40 81       	ld	r20, Z
    16a8:	51 81       	ldd	r21, Z+1	; 0x01
    16aa:	e9 81       	ldd	r30, Y+1	; 0x01
    16ac:	fa 81       	ldd	r31, Y+2	; 0x02
    16ae:	83 8d       	ldd	r24, Z+27	; 0x1b
    16b0:	88 2f       	mov	r24, r24
    16b2:	90 e0       	ldi	r25, 0x00	; 0
    16b4:	9c 01       	movw	r18, r24
    16b6:	21 50       	subi	r18, 0x01	; 1
    16b8:	30 40       	sbci	r19, 0x00	; 0
    16ba:	e9 81       	ldd	r30, Y+1	; 0x01
    16bc:	fa 81       	ldd	r31, Y+2	; 0x02
    16be:	84 8d       	ldd	r24, Z+28	; 0x1c
    16c0:	88 2f       	mov	r24, r24
    16c2:	90 e0       	ldi	r25, 0x00	; 0
    16c4:	bc 01       	movw	r22, r24
    16c6:	26 9f       	mul	r18, r22
    16c8:	c0 01       	movw	r24, r0
    16ca:	27 9f       	mul	r18, r23
    16cc:	90 0d       	add	r25, r0
    16ce:	36 9f       	mul	r19, r22
    16d0:	90 0d       	add	r25, r0
    16d2:	11 24       	eor	r1, r1
    16d4:	84 0f       	add	r24, r20
    16d6:	95 1f       	adc	r25, r21
    16d8:	e9 81       	ldd	r30, Y+1	; 0x01
    16da:	fa 81       	ldd	r31, Y+2	; 0x02
    16dc:	97 83       	std	Z+7, r25	; 0x07
    16de:	86 83       	std	Z+6, r24	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    16e0:	e9 81       	ldd	r30, Y+1	; 0x01
    16e2:	fa 81       	ldd	r31, Y+2	; 0x02
    16e4:	8f ef       	ldi	r24, 0xFF	; 255
    16e6:	85 8f       	std	Z+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    16e8:	e9 81       	ldd	r30, Y+1	; 0x01
    16ea:	fa 81       	ldd	r31, Y+2	; 0x02
    16ec:	8f ef       	ldi	r24, 0xFF	; 255
    16ee:	86 8f       	std	Z+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    16f0:	8e 81       	ldd	r24, Y+6	; 0x06
    16f2:	88 23       	and	r24, r24
    16f4:	79 f4       	brne	.+30     	; 0x1714 <xQueueGenericReset+0x126>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16f6:	e9 81       	ldd	r30, Y+1	; 0x01
    16f8:	fa 81       	ldd	r31, Y+2	; 0x02
    16fa:	80 85       	ldd	r24, Z+8	; 0x08
    16fc:	88 23       	and	r24, r24
    16fe:	a1 f0       	breq	.+40     	; 0x1728 <xQueueGenericReset+0x13a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1700:	89 81       	ldd	r24, Y+1	; 0x01
    1702:	9a 81       	ldd	r25, Y+2	; 0x02
    1704:	08 96       	adiw	r24, 0x08	; 8
    1706:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <xTaskRemoveFromEventList>
    170a:	88 23       	and	r24, r24
    170c:	69 f0       	breq	.+26     	; 0x1728 <xQueueGenericReset+0x13a>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    170e:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    1712:	0a c0       	rjmp	.+20     	; 0x1728 <xQueueGenericReset+0x13a>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1714:	89 81       	ldd	r24, Y+1	; 0x01
    1716:	9a 81       	ldd	r25, Y+2	; 0x02
    1718:	08 96       	adiw	r24, 0x08	; 8
    171a:	0e 94 c1 09 	call	0x1382	; 0x1382 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    171e:	89 81       	ldd	r24, Y+1	; 0x01
    1720:	9a 81       	ldd	r25, Y+2	; 0x02
    1722:	41 96       	adiw	r24, 0x11	; 17
    1724:	0e 94 c1 09 	call	0x1382	; 0x1382 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    1728:	0f 90       	pop	r0
    172a:	0f be       	out	0x3f, r0	; 63
    172c:	01 c0       	rjmp	.+2      	; 0x1730 <xQueueGenericReset+0x142>
    }
    else
    {
        xReturn = pdFAIL;
    172e:	1b 82       	std	Y+3, r1	; 0x03

    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
    1730:	8b 81       	ldd	r24, Y+3	; 0x03
}
    1732:	26 96       	adiw	r28, 0x06	; 6
    1734:	0f b6       	in	r0, 0x3f	; 63
    1736:	f8 94       	cli
    1738:	de bf       	out	0x3e, r29	; 62
    173a:	0f be       	out	0x3f, r0	; 63
    173c:	cd bf       	out	0x3d, r28	; 61
    173e:	cf 91       	pop	r28
    1740:	df 91       	pop	r29
    1742:	08 95       	ret

00001744 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    1744:	0f 93       	push	r16
    1746:	1f 93       	push	r17
    1748:	df 93       	push	r29
    174a:	cf 93       	push	r28
    174c:	cd b7       	in	r28, 0x3d	; 61
    174e:	de b7       	in	r29, 0x3e	; 62
    1750:	29 97       	sbiw	r28, 0x09	; 9
    1752:	0f b6       	in	r0, 0x3f	; 63
    1754:	f8 94       	cli
    1756:	de bf       	out	0x3e, r29	; 62
    1758:	0f be       	out	0x3f, r0	; 63
    175a:	cd bf       	out	0x3d, r28	; 61
    175c:	8f 83       	std	Y+7, r24	; 0x07
    175e:	68 87       	std	Y+8, r22	; 0x08
    1760:	49 87       	std	Y+9, r20	; 0x09
        Queue_t * pxNewQueue = NULL;
    1762:	1e 82       	std	Y+6, r1	; 0x06
    1764:	1d 82       	std	Y+5, r1	; 0x05
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    1766:	8f 81       	ldd	r24, Y+7	; 0x07
    1768:	88 23       	and	r24, r24
    176a:	09 f4       	brne	.+2      	; 0x176e <xQueueGenericCreate+0x2a>
    176c:	52 c0       	rjmp	.+164    	; 0x1812 <xQueueGenericCreate+0xce>
    176e:	8f 81       	ldd	r24, Y+7	; 0x07
    1770:	28 2f       	mov	r18, r24
    1772:	30 e0       	ldi	r19, 0x00	; 0
    1774:	8f ef       	ldi	r24, 0xFF	; 255
    1776:	9f e7       	ldi	r25, 0x7F	; 127
    1778:	b9 01       	movw	r22, r18
    177a:	0e 94 ef 32 	call	0x65de	; 0x65de <__udivmodhi4>
    177e:	cb 01       	movw	r24, r22
    1780:	9c 01       	movw	r18, r24
    1782:	88 85       	ldd	r24, Y+8	; 0x08
    1784:	88 2f       	mov	r24, r24
    1786:	90 e0       	ldi	r25, 0x00	; 0
    1788:	28 17       	cp	r18, r24
    178a:	39 07       	cpc	r19, r25
    178c:	08 f4       	brcc	.+2      	; 0x1790 <xQueueGenericCreate+0x4c>
    178e:	41 c0       	rjmp	.+130    	; 0x1812 <xQueueGenericCreate+0xce>
    1790:	8f 81       	ldd	r24, Y+7	; 0x07
    1792:	28 2f       	mov	r18, r24
    1794:	30 e0       	ldi	r19, 0x00	; 0
    1796:	88 85       	ldd	r24, Y+8	; 0x08
    1798:	88 2f       	mov	r24, r24
    179a:	90 e0       	ldi	r25, 0x00	; 0
    179c:	ac 01       	movw	r20, r24
    179e:	24 9f       	mul	r18, r20
    17a0:	c0 01       	movw	r24, r0
    17a2:	25 9f       	mul	r18, r21
    17a4:	90 0d       	add	r25, r0
    17a6:	34 9f       	mul	r19, r20
    17a8:	90 0d       	add	r25, r0
    17aa:	11 24       	eor	r1, r1
    17ac:	5f e7       	ldi	r21, 0x7F	; 127
    17ae:	81 3e       	cpi	r24, 0xE1	; 225
    17b0:	95 07       	cpc	r25, r21
    17b2:	78 f5       	brcc	.+94     	; 0x1812 <xQueueGenericCreate+0xce>
            ( ( SIZE_MAX - sizeof( Queue_t ) ) >= ( uxQueueLength * uxItemSize ) ) )
        {
            /* Allocate enough space to hold the maximum number of items that
             * can be in the queue at any time.  It is valid for uxItemSize to be
             * zero in the case the queue is used as a semaphore. */
            xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    17b4:	8f 81       	ldd	r24, Y+7	; 0x07
    17b6:	28 2f       	mov	r18, r24
    17b8:	30 e0       	ldi	r19, 0x00	; 0
    17ba:	88 85       	ldd	r24, Y+8	; 0x08
    17bc:	88 2f       	mov	r24, r24
    17be:	90 e0       	ldi	r25, 0x00	; 0
    17c0:	ac 01       	movw	r20, r24
    17c2:	24 9f       	mul	r18, r20
    17c4:	c0 01       	movw	r24, r0
    17c6:	25 9f       	mul	r18, r21
    17c8:	90 0d       	add	r25, r0
    17ca:	34 9f       	mul	r19, r20
    17cc:	90 0d       	add	r25, r0
    17ce:	11 24       	eor	r1, r1
    17d0:	9c 83       	std	Y+4, r25	; 0x04
    17d2:	8b 83       	std	Y+3, r24	; 0x03
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    17d4:	8b 81       	ldd	r24, Y+3	; 0x03
    17d6:	9c 81       	ldd	r25, Y+4	; 0x04
    17d8:	4f 96       	adiw	r24, 0x1f	; 31
    17da:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    17de:	9e 83       	std	Y+6, r25	; 0x06
    17e0:	8d 83       	std	Y+5, r24	; 0x05

            if( pxNewQueue != NULL )
    17e2:	8d 81       	ldd	r24, Y+5	; 0x05
    17e4:	9e 81       	ldd	r25, Y+6	; 0x06
    17e6:	00 97       	sbiw	r24, 0x00	; 0
    17e8:	a1 f0       	breq	.+40     	; 0x1812 <xQueueGenericCreate+0xce>
            {
                /* Jump past the queue structure to find the location of the queue
                 * storage area. */
                pucQueueStorage = ( uint8_t * ) pxNewQueue;
    17ea:	8d 81       	ldd	r24, Y+5	; 0x05
    17ec:	9e 81       	ldd	r25, Y+6	; 0x06
    17ee:	9a 83       	std	Y+2, r25	; 0x02
    17f0:	89 83       	std	Y+1, r24	; 0x01
                pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    17f2:	89 81       	ldd	r24, Y+1	; 0x01
    17f4:	9a 81       	ldd	r25, Y+2	; 0x02
    17f6:	4f 96       	adiw	r24, 0x1f	; 31
    17f8:	9a 83       	std	Y+2, r25	; 0x02
    17fa:	89 83       	std	Y+1, r24	; 0x01
                         * deleted. */
                        pxNewQueue->ucStaticallyAllocated = pdFALSE;
                    }
                #endif /* configSUPPORT_STATIC_ALLOCATION */

                prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    17fc:	29 81       	ldd	r18, Y+1	; 0x01
    17fe:	3a 81       	ldd	r19, Y+2	; 0x02
    1800:	ed 81       	ldd	r30, Y+5	; 0x05
    1802:	fe 81       	ldd	r31, Y+6	; 0x06
    1804:	8f 81       	ldd	r24, Y+7	; 0x07
    1806:	68 85       	ldd	r22, Y+8	; 0x08
    1808:	a9 01       	movw	r20, r18
    180a:	29 85       	ldd	r18, Y+9	; 0x09
    180c:	8f 01       	movw	r16, r30
    180e:	0e 94 16 0c 	call	0x182c	; 0x182c <prvInitialiseNewQueue>
        {
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    1812:	8d 81       	ldd	r24, Y+5	; 0x05
    1814:	9e 81       	ldd	r25, Y+6	; 0x06
    }
    1816:	29 96       	adiw	r28, 0x09	; 9
    1818:	0f b6       	in	r0, 0x3f	; 63
    181a:	f8 94       	cli
    181c:	de bf       	out	0x3e, r29	; 62
    181e:	0f be       	out	0x3f, r0	; 63
    1820:	cd bf       	out	0x3d, r28	; 61
    1822:	cf 91       	pop	r28
    1824:	df 91       	pop	r29
    1826:	1f 91       	pop	r17
    1828:	0f 91       	pop	r16
    182a:	08 95       	ret

0000182c <prvInitialiseNewQueue>:
static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength,
                                   const UBaseType_t uxItemSize,
                                   uint8_t * pucQueueStorage,
                                   const uint8_t ucQueueType,
                                   Queue_t * pxNewQueue )
{
    182c:	0f 93       	push	r16
    182e:	1f 93       	push	r17
    1830:	df 93       	push	r29
    1832:	cf 93       	push	r28
    1834:	cd b7       	in	r28, 0x3d	; 61
    1836:	de b7       	in	r29, 0x3e	; 62
    1838:	27 97       	sbiw	r28, 0x07	; 7
    183a:	0f b6       	in	r0, 0x3f	; 63
    183c:	f8 94       	cli
    183e:	de bf       	out	0x3e, r29	; 62
    1840:	0f be       	out	0x3f, r0	; 63
    1842:	cd bf       	out	0x3d, r28	; 61
    1844:	89 83       	std	Y+1, r24	; 0x01
    1846:	6a 83       	std	Y+2, r22	; 0x02
    1848:	5c 83       	std	Y+4, r21	; 0x04
    184a:	4b 83       	std	Y+3, r20	; 0x03
    184c:	2d 83       	std	Y+5, r18	; 0x05
    184e:	1f 83       	std	Y+7, r17	; 0x07
    1850:	0e 83       	std	Y+6, r16	; 0x06
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    1852:	8a 81       	ldd	r24, Y+2	; 0x02
    1854:	88 23       	and	r24, r24
    1856:	39 f4       	brne	.+14     	; 0x1866 <prvInitialiseNewQueue+0x3a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1858:	8e 81       	ldd	r24, Y+6	; 0x06
    185a:	9f 81       	ldd	r25, Y+7	; 0x07
    185c:	ee 81       	ldd	r30, Y+6	; 0x06
    185e:	ff 81       	ldd	r31, Y+7	; 0x07
    1860:	91 83       	std	Z+1, r25	; 0x01
    1862:	80 83       	st	Z, r24
    1864:	06 c0       	rjmp	.+12     	; 0x1872 <prvInitialiseNewQueue+0x46>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1866:	8b 81       	ldd	r24, Y+3	; 0x03
    1868:	9c 81       	ldd	r25, Y+4	; 0x04
    186a:	ee 81       	ldd	r30, Y+6	; 0x06
    186c:	ff 81       	ldd	r31, Y+7	; 0x07
    186e:	91 83       	std	Z+1, r25	; 0x01
    1870:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    1872:	ee 81       	ldd	r30, Y+6	; 0x06
    1874:	ff 81       	ldd	r31, Y+7	; 0x07
    1876:	89 81       	ldd	r24, Y+1	; 0x01
    1878:	83 8f       	std	Z+27, r24	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    187a:	ee 81       	ldd	r30, Y+6	; 0x06
    187c:	ff 81       	ldd	r31, Y+7	; 0x07
    187e:	8a 81       	ldd	r24, Y+2	; 0x02
    1880:	84 8f       	std	Z+28, r24	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1882:	8e 81       	ldd	r24, Y+6	; 0x06
    1884:	9f 81       	ldd	r25, Y+7	; 0x07
    1886:	61 e0       	ldi	r22, 0x01	; 1
    1888:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <xQueueGenericReset>
            pxNewQueue->pxQueueSetContainer = NULL;
        }
    #endif /* configUSE_QUEUE_SETS */

    traceQUEUE_CREATE( pxNewQueue );
}
    188c:	27 96       	adiw	r28, 0x07	; 7
    188e:	0f b6       	in	r0, 0x3f	; 63
    1890:	f8 94       	cli
    1892:	de bf       	out	0x3e, r29	; 62
    1894:	0f be       	out	0x3f, r0	; 63
    1896:	cd bf       	out	0x3d, r28	; 61
    1898:	cf 91       	pop	r28
    189a:	df 91       	pop	r29
    189c:	1f 91       	pop	r17
    189e:	0f 91       	pop	r16
    18a0:	08 95       	ret

000018a2 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    18a2:	df 93       	push	r29
    18a4:	cf 93       	push	r28
    18a6:	cd b7       	in	r28, 0x3d	; 61
    18a8:	de b7       	in	r29, 0x3e	; 62
    18aa:	2f 97       	sbiw	r28, 0x0f	; 15
    18ac:	0f b6       	in	r0, 0x3f	; 63
    18ae:	f8 94       	cli
    18b0:	de bf       	out	0x3e, r29	; 62
    18b2:	0f be       	out	0x3f, r0	; 63
    18b4:	cd bf       	out	0x3d, r28	; 61
    18b6:	99 87       	std	Y+9, r25	; 0x09
    18b8:	88 87       	std	Y+8, r24	; 0x08
    18ba:	7b 87       	std	Y+11, r23	; 0x0b
    18bc:	6a 87       	std	Y+10, r22	; 0x0a
    18be:	5d 87       	std	Y+13, r21	; 0x0d
    18c0:	4c 87       	std	Y+12, r20	; 0x0c
    18c2:	2e 87       	std	Y+14, r18	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    18c4:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    18c6:	88 85       	ldd	r24, Y+8	; 0x08
    18c8:	99 85       	ldd	r25, Y+9	; 0x09
    18ca:	9a 83       	std	Y+2, r25	; 0x02
    18cc:	89 83       	std	Y+1, r24	; 0x01
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    18ce:	0f b6       	in	r0, 0x3f	; 63
    18d0:	f8 94       	cli
    18d2:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    18d4:	e9 81       	ldd	r30, Y+1	; 0x01
    18d6:	fa 81       	ldd	r31, Y+2	; 0x02
    18d8:	92 8d       	ldd	r25, Z+26	; 0x1a
    18da:	e9 81       	ldd	r30, Y+1	; 0x01
    18dc:	fa 81       	ldd	r31, Y+2	; 0x02
    18de:	83 8d       	ldd	r24, Z+27	; 0x1b
    18e0:	98 17       	cp	r25, r24
    18e2:	18 f0       	brcs	.+6      	; 0x18ea <xQueueGenericSend+0x48>
    18e4:	8e 85       	ldd	r24, Y+14	; 0x0e
    18e6:	82 30       	cpi	r24, 0x02	; 2
    18e8:	11 f5       	brne	.+68     	; 0x192e <xQueueGenericSend+0x8c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    18ea:	89 81       	ldd	r24, Y+1	; 0x01
    18ec:	9a 81       	ldd	r25, Y+2	; 0x02
    18ee:	2a 85       	ldd	r18, Y+10	; 0x0a
    18f0:	3b 85       	ldd	r19, Y+11	; 0x0b
    18f2:	b9 01       	movw	r22, r18
    18f4:	4e 85       	ldd	r20, Y+14	; 0x0e
    18f6:	0e 94 a7 10 	call	0x214e	; 0x214e <prvCopyDataToQueue>
    18fa:	8b 83       	std	Y+3, r24	; 0x03

                        /* If there was a task waiting for data to arrive on the
                         * queue then unblock it now. */
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18fc:	e9 81       	ldd	r30, Y+1	; 0x01
    18fe:	fa 81       	ldd	r31, Y+2	; 0x02
    1900:	81 89       	ldd	r24, Z+17	; 0x11
    1902:	88 23       	and	r24, r24
    1904:	51 f0       	breq	.+20     	; 0x191a <xQueueGenericSend+0x78>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1906:	89 81       	ldd	r24, Y+1	; 0x01
    1908:	9a 81       	ldd	r25, Y+2	; 0x02
    190a:	41 96       	adiw	r24, 0x11	; 17
    190c:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <xTaskRemoveFromEventList>
    1910:	88 23       	and	r24, r24
    1912:	41 f0       	breq	.+16     	; 0x1924 <xQueueGenericSend+0x82>
                            {
                                /* The unblocked task has a priority higher than
                                 * our own so yield immediately.  Yes it is ok to do
                                 * this from within the critical section - the kernel
                                 * takes care of that. */
                                queueYIELD_IF_USING_PREEMPTION();
    1914:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    1918:	05 c0       	rjmp	.+10     	; 0x1924 <xQueueGenericSend+0x82>
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }
                        }
                        else if( xYieldRequired != pdFALSE )
    191a:	8b 81       	ldd	r24, Y+3	; 0x03
    191c:	88 23       	and	r24, r24
    191e:	11 f0       	breq	.+4      	; 0x1924 <xQueueGenericSend+0x82>
                        {
                            /* This path is a special case that will only get
                             * executed if the task was holding multiple mutexes and
                             * the mutexes were given back in an order that is
                             * different to that in which they were taken. */
                            queueYIELD_IF_USING_PREEMPTION();
    1920:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    1924:	0f 90       	pop	r0
    1926:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    1928:	81 e0       	ldi	r24, 0x01	; 1
    192a:	8f 87       	std	Y+15, r24	; 0x0f
    192c:	5c c0       	rjmp	.+184    	; 0x19e6 <xQueueGenericSend+0x144>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    192e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1930:	9d 85       	ldd	r25, Y+13	; 0x0d
    1932:	00 97       	sbiw	r24, 0x00	; 0
    1934:	21 f4       	brne	.+8      	; 0x193e <xQueueGenericSend+0x9c>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1936:	0f 90       	pop	r0
    1938:	0f be       	out	0x3f, r0	; 63

                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
    193a:	1f 86       	std	Y+15, r1	; 0x0f
    193c:	54 c0       	rjmp	.+168    	; 0x19e6 <xQueueGenericSend+0x144>
                }
                else if( xEntryTimeSet == pdFALSE )
    193e:	8c 81       	ldd	r24, Y+4	; 0x04
    1940:	88 23       	and	r24, r24
    1942:	31 f4       	brne	.+12     	; 0x1950 <xQueueGenericSend+0xae>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1944:	ce 01       	movw	r24, r28
    1946:	05 96       	adiw	r24, 0x05	; 5
    1948:	0e 94 d4 1e 	call	0x3da8	; 0x3da8 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    194c:	81 e0       	ldi	r24, 0x01	; 1
    194e:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1950:	0f 90       	pop	r0
    1952:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1954:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1958:	0f b6       	in	r0, 0x3f	; 63
    195a:	f8 94       	cli
    195c:	0f 92       	push	r0
    195e:	e9 81       	ldd	r30, Y+1	; 0x01
    1960:	fa 81       	ldd	r31, Y+2	; 0x02
    1962:	85 8d       	ldd	r24, Z+29	; 0x1d
    1964:	8f 3f       	cpi	r24, 0xFF	; 255
    1966:	19 f4       	brne	.+6      	; 0x196e <xQueueGenericSend+0xcc>
    1968:	e9 81       	ldd	r30, Y+1	; 0x01
    196a:	fa 81       	ldd	r31, Y+2	; 0x02
    196c:	15 8e       	std	Z+29, r1	; 0x1d
    196e:	e9 81       	ldd	r30, Y+1	; 0x01
    1970:	fa 81       	ldd	r31, Y+2	; 0x02
    1972:	86 8d       	ldd	r24, Z+30	; 0x1e
    1974:	8f 3f       	cpi	r24, 0xFF	; 255
    1976:	19 f4       	brne	.+6      	; 0x197e <xQueueGenericSend+0xdc>
    1978:	e9 81       	ldd	r30, Y+1	; 0x01
    197a:	fa 81       	ldd	r31, Y+2	; 0x02
    197c:	16 8e       	std	Z+30, r1	; 0x1e
    197e:	0f 90       	pop	r0
    1980:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1982:	ce 01       	movw	r24, r28
    1984:	05 96       	adiw	r24, 0x05	; 5
    1986:	9e 01       	movw	r18, r28
    1988:	24 5f       	subi	r18, 0xF4	; 244
    198a:	3f 4f       	sbci	r19, 0xFF	; 255
    198c:	b9 01       	movw	r22, r18
    198e:	0e 94 ed 1e 	call	0x3dda	; 0x3dda <xTaskCheckForTimeOut>
    1992:	88 23       	and	r24, r24
    1994:	09 f5       	brne	.+66     	; 0x19d8 <xQueueGenericSend+0x136>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1996:	89 81       	ldd	r24, Y+1	; 0x01
    1998:	9a 81       	ldd	r25, Y+2	; 0x02
    199a:	0e 94 23 12 	call	0x2446	; 0x2446 <prvIsQueueFull>
    199e:	88 23       	and	r24, r24
    19a0:	a1 f0       	breq	.+40     	; 0x19ca <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    19a2:	89 81       	ldd	r24, Y+1	; 0x01
    19a4:	9a 81       	ldd	r25, Y+2	; 0x02
    19a6:	08 96       	adiw	r24, 0x08	; 8
    19a8:	2c 85       	ldd	r18, Y+12	; 0x0c
    19aa:	3d 85       	ldd	r19, Y+13	; 0x0d
    19ac:	b9 01       	movw	r22, r18
    19ae:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    19b2:	89 81       	ldd	r24, Y+1	; 0x01
    19b4:	9a 81       	ldd	r25, Y+2	; 0x02
    19b6:	0e 94 94 11 	call	0x2328	; 0x2328 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    19ba:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>
    19be:	88 23       	and	r24, r24
    19c0:	09 f0       	breq	.+2      	; 0x19c4 <xQueueGenericSend+0x122>
    19c2:	85 cf       	rjmp	.-246    	; 0x18ce <xQueueGenericSend+0x2c>
                {
                    portYIELD_WITHIN_API();
    19c4:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    19c8:	82 cf       	rjmp	.-252    	; 0x18ce <xQueueGenericSend+0x2c>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    19ca:	89 81       	ldd	r24, Y+1	; 0x01
    19cc:	9a 81       	ldd	r25, Y+2	; 0x02
    19ce:	0e 94 94 11 	call	0x2328	; 0x2328 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    19d2:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>
    19d6:	7b cf       	rjmp	.-266    	; 0x18ce <xQueueGenericSend+0x2c>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    19d8:	89 81       	ldd	r24, Y+1	; 0x01
    19da:	9a 81       	ldd	r25, Y+2	; 0x02
    19dc:	0e 94 94 11 	call	0x2328	; 0x2328 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    19e0:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
    19e4:	1f 86       	std	Y+15, r1	; 0x0f
    19e6:	8f 85       	ldd	r24, Y+15	; 0x0f
        }
    } /*lint -restore */
}
    19e8:	2f 96       	adiw	r28, 0x0f	; 15
    19ea:	0f b6       	in	r0, 0x3f	; 63
    19ec:	f8 94       	cli
    19ee:	de bf       	out	0x3e, r29	; 62
    19f0:	0f be       	out	0x3f, r0	; 63
    19f2:	cd bf       	out	0x3d, r28	; 61
    19f4:	cf 91       	pop	r28
    19f6:	df 91       	pop	r29
    19f8:	08 95       	ret

000019fa <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    19fa:	df 93       	push	r29
    19fc:	cf 93       	push	r28
    19fe:	cd b7       	in	r28, 0x3d	; 61
    1a00:	de b7       	in	r29, 0x3e	; 62
    1a02:	2d 97       	sbiw	r28, 0x0d	; 13
    1a04:	0f b6       	in	r0, 0x3f	; 63
    1a06:	f8 94       	cli
    1a08:	de bf       	out	0x3e, r29	; 62
    1a0a:	0f be       	out	0x3f, r0	; 63
    1a0c:	cd bf       	out	0x3d, r28	; 61
    1a0e:	98 87       	std	Y+8, r25	; 0x08
    1a10:	8f 83       	std	Y+7, r24	; 0x07
    1a12:	7a 87       	std	Y+10, r23	; 0x0a
    1a14:	69 87       	std	Y+9, r22	; 0x09
    1a16:	5c 87       	std	Y+12, r21	; 0x0c
    1a18:	4b 87       	std	Y+11, r20	; 0x0b
    1a1a:	2d 87       	std	Y+13, r18	; 0x0d
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    1a1c:	8f 81       	ldd	r24, Y+7	; 0x07
    1a1e:	98 85       	ldd	r25, Y+8	; 0x08
    1a20:	9c 83       	std	Y+4, r25	; 0x04
    1a22:	8b 83       	std	Y+3, r24	; 0x03
    /* Similar to xQueueGenericSend, except without blocking if there is no room
     * in the queue.  Also don't directly wake a task that was blocked on a queue
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1a24:	1d 82       	std	Y+5, r1	; 0x05
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1a26:	eb 81       	ldd	r30, Y+3	; 0x03
    1a28:	fc 81       	ldd	r31, Y+4	; 0x04
    1a2a:	92 8d       	ldd	r25, Z+26	; 0x1a
    1a2c:	eb 81       	ldd	r30, Y+3	; 0x03
    1a2e:	fc 81       	ldd	r31, Y+4	; 0x04
    1a30:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a32:	98 17       	cp	r25, r24
    1a34:	18 f0       	brcs	.+6      	; 0x1a3c <xQueueGenericSendFromISR+0x42>
    1a36:	8d 85       	ldd	r24, Y+13	; 0x0d
    1a38:	82 30       	cpi	r24, 0x02	; 2
    1a3a:	81 f5       	brne	.+96     	; 0x1a9c <xQueueGenericSendFromISR+0xa2>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    1a3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1a3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1a40:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a42:	8a 83       	std	Y+2, r24	; 0x02
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    1a44:	eb 81       	ldd	r30, Y+3	; 0x03
    1a46:	fc 81       	ldd	r31, Y+4	; 0x04
    1a48:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a4a:	89 83       	std	Y+1, r24	; 0x01
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1a4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a50:	29 85       	ldd	r18, Y+9	; 0x09
    1a52:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a54:	b9 01       	movw	r22, r18
    1a56:	4d 85       	ldd	r20, Y+13	; 0x0d
    1a58:	0e 94 a7 10 	call	0x214e	; 0x214e <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    1a5c:	8a 81       	ldd	r24, Y+2	; 0x02
    1a5e:	8f 3f       	cpi	r24, 0xFF	; 255
    1a60:	a9 f4       	brne	.+42     	; 0x1a8c <xQueueGenericSendFromISR+0x92>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1a62:	eb 81       	ldd	r30, Y+3	; 0x03
    1a64:	fc 81       	ldd	r31, Y+4	; 0x04
    1a66:	81 89       	ldd	r24, Z+17	; 0x11
    1a68:	88 23       	and	r24, r24
    1a6a:	a9 f0       	breq	.+42     	; 0x1a96 <xQueueGenericSendFromISR+0x9c>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1a6c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a6e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a70:	41 96       	adiw	r24, 0x11	; 17
    1a72:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <xTaskRemoveFromEventList>
    1a76:	88 23       	and	r24, r24
    1a78:	71 f0       	breq	.+28     	; 0x1a96 <xQueueGenericSendFromISR+0x9c>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    1a7a:	8b 85       	ldd	r24, Y+11	; 0x0b
    1a7c:	9c 85       	ldd	r25, Y+12	; 0x0c
    1a7e:	00 97       	sbiw	r24, 0x00	; 0
    1a80:	51 f0       	breq	.+20     	; 0x1a96 <xQueueGenericSendFromISR+0x9c>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    1a82:	eb 85       	ldd	r30, Y+11	; 0x0b
    1a84:	fc 85       	ldd	r31, Y+12	; 0x0c
    1a86:	81 e0       	ldi	r24, 0x01	; 1
    1a88:	80 83       	st	Z, r24
    1a8a:	05 c0       	rjmp	.+10     	; 0x1a96 <xQueueGenericSendFromISR+0x9c>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1a8c:	8a 81       	ldd	r24, Y+2	; 0x02
    1a8e:	8f 5f       	subi	r24, 0xFF	; 255
    1a90:	eb 81       	ldd	r30, Y+3	; 0x03
    1a92:	fc 81       	ldd	r31, Y+4	; 0x04
    1a94:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    1a96:	81 e0       	ldi	r24, 0x01	; 1
    1a98:	8e 83       	std	Y+6, r24	; 0x06
    1a9a:	01 c0       	rjmp	.+2      	; 0x1a9e <xQueueGenericSendFromISR+0xa4>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    1a9c:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    1a9e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1aa0:	2d 96       	adiw	r28, 0x0d	; 13
    1aa2:	0f b6       	in	r0, 0x3f	; 63
    1aa4:	f8 94       	cli
    1aa6:	de bf       	out	0x3e, r29	; 62
    1aa8:	0f be       	out	0x3f, r0	; 63
    1aaa:	cd bf       	out	0x3d, r28	; 61
    1aac:	cf 91       	pop	r28
    1aae:	df 91       	pop	r29
    1ab0:	08 95       	ret

00001ab2 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    1ab2:	df 93       	push	r29
    1ab4:	cf 93       	push	r28
    1ab6:	cd b7       	in	r28, 0x3d	; 61
    1ab8:	de b7       	in	r29, 0x3e	; 62
    1aba:	2a 97       	sbiw	r28, 0x0a	; 10
    1abc:	0f b6       	in	r0, 0x3f	; 63
    1abe:	f8 94       	cli
    1ac0:	de bf       	out	0x3e, r29	; 62
    1ac2:	0f be       	out	0x3f, r0	; 63
    1ac4:	cd bf       	out	0x3d, r28	; 61
    1ac6:	98 87       	std	Y+8, r25	; 0x08
    1ac8:	8f 83       	std	Y+7, r24	; 0x07
    1aca:	7a 87       	std	Y+10, r23	; 0x0a
    1acc:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    1ace:	8f 81       	ldd	r24, Y+7	; 0x07
    1ad0:	98 85       	ldd	r25, Y+8	; 0x08
    1ad2:	9c 83       	std	Y+4, r25	; 0x04
    1ad4:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1ad6:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1ad8:	eb 81       	ldd	r30, Y+3	; 0x03
    1ada:	fc 81       	ldd	r31, Y+4	; 0x04
    1adc:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ade:	8a 83       	std	Y+2, r24	; 0x02

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    1ae0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ae2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ae4:	93 8d       	ldd	r25, Z+27	; 0x1b
    1ae6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ae8:	89 17       	cp	r24, r25
    1aea:	48 f5       	brcc	.+82     	; 0x1b3e <xQueueGiveFromISR+0x8c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    1aec:	eb 81       	ldd	r30, Y+3	; 0x03
    1aee:	fc 81       	ldd	r31, Y+4	; 0x04
    1af0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1af2:	89 83       	std	Y+1, r24	; 0x01
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1af4:	8a 81       	ldd	r24, Y+2	; 0x02
    1af6:	8f 5f       	subi	r24, 0xFF	; 255
    1af8:	eb 81       	ldd	r30, Y+3	; 0x03
    1afa:	fc 81       	ldd	r31, Y+4	; 0x04
    1afc:	82 8f       	std	Z+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    1afe:	89 81       	ldd	r24, Y+1	; 0x01
    1b00:	8f 3f       	cpi	r24, 0xFF	; 255
    1b02:	a9 f4       	brne	.+42     	; 0x1b2e <xQueueGiveFromISR+0x7c>
                            }
                        }
                    }
                #else /* configUSE_QUEUE_SETS */
                    {
                        if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1b04:	eb 81       	ldd	r30, Y+3	; 0x03
    1b06:	fc 81       	ldd	r31, Y+4	; 0x04
    1b08:	81 89       	ldd	r24, Z+17	; 0x11
    1b0a:	88 23       	and	r24, r24
    1b0c:	a9 f0       	breq	.+42     	; 0x1b38 <xQueueGiveFromISR+0x86>
                        {
                            if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1b0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1b10:	9c 81       	ldd	r25, Y+4	; 0x04
    1b12:	41 96       	adiw	r24, 0x11	; 17
    1b14:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <xTaskRemoveFromEventList>
    1b18:	88 23       	and	r24, r24
    1b1a:	71 f0       	breq	.+28     	; 0x1b38 <xQueueGiveFromISR+0x86>
                            {
                                /* The task waiting has a higher priority so record that a
                                 * context switch is required. */
                                if( pxHigherPriorityTaskWoken != NULL )
    1b1c:	89 85       	ldd	r24, Y+9	; 0x09
    1b1e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1b20:	00 97       	sbiw	r24, 0x00	; 0
    1b22:	51 f0       	breq	.+20     	; 0x1b38 <xQueueGiveFromISR+0x86>
                                {
                                    *pxHigherPriorityTaskWoken = pdTRUE;
    1b24:	e9 85       	ldd	r30, Y+9	; 0x09
    1b26:	fa 85       	ldd	r31, Y+10	; 0x0a
    1b28:	81 e0       	ldi	r24, 0x01	; 1
    1b2a:	80 83       	st	Z, r24
    1b2c:	05 c0       	rjmp	.+10     	; 0x1b38 <xQueueGiveFromISR+0x86>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                configASSERT( cTxLock != queueINT8_MAX );

                pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1b2e:	89 81       	ldd	r24, Y+1	; 0x01
    1b30:	8f 5f       	subi	r24, 0xFF	; 255
    1b32:	eb 81       	ldd	r30, Y+3	; 0x03
    1b34:	fc 81       	ldd	r31, Y+4	; 0x04
    1b36:	86 8f       	std	Z+30, r24	; 0x1e
            }

            xReturn = pdPASS;
    1b38:	81 e0       	ldi	r24, 0x01	; 1
    1b3a:	8e 83       	std	Y+6, r24	; 0x06
    1b3c:	01 c0       	rjmp	.+2      	; 0x1b40 <xQueueGiveFromISR+0x8e>
        }
        else
        {
            traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
            xReturn = errQUEUE_FULL;
    1b3e:	1e 82       	std	Y+6, r1	; 0x06
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    1b40:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1b42:	2a 96       	adiw	r28, 0x0a	; 10
    1b44:	0f b6       	in	r0, 0x3f	; 63
    1b46:	f8 94       	cli
    1b48:	de bf       	out	0x3e, r29	; 62
    1b4a:	0f be       	out	0x3f, r0	; 63
    1b4c:	cd bf       	out	0x3d, r28	; 61
    1b4e:	cf 91       	pop	r28
    1b50:	df 91       	pop	r29
    1b52:	08 95       	ret

00001b54 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    1b54:	df 93       	push	r29
    1b56:	cf 93       	push	r28
    1b58:	cd b7       	in	r28, 0x3d	; 61
    1b5a:	de b7       	in	r29, 0x3e	; 62
    1b5c:	2e 97       	sbiw	r28, 0x0e	; 14
    1b5e:	0f b6       	in	r0, 0x3f	; 63
    1b60:	f8 94       	cli
    1b62:	de bf       	out	0x3e, r29	; 62
    1b64:	0f be       	out	0x3f, r0	; 63
    1b66:	cd bf       	out	0x3d, r28	; 61
    1b68:	99 87       	std	Y+9, r25	; 0x09
    1b6a:	88 87       	std	Y+8, r24	; 0x08
    1b6c:	7b 87       	std	Y+11, r23	; 0x0b
    1b6e:	6a 87       	std	Y+10, r22	; 0x0a
    1b70:	5d 87       	std	Y+13, r21	; 0x0d
    1b72:	4c 87       	std	Y+12, r20	; 0x0c
    BaseType_t xEntryTimeSet = pdFALSE;
    1b74:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    1b76:	88 85       	ldd	r24, Y+8	; 0x08
    1b78:	99 85       	ldd	r25, Y+9	; 0x09
    1b7a:	9b 83       	std	Y+3, r25	; 0x03
    1b7c:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1b7e:	0f b6       	in	r0, 0x3f	; 63
    1b80:	f8 94       	cli
    1b82:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1b84:	ea 81       	ldd	r30, Y+2	; 0x02
    1b86:	fb 81       	ldd	r31, Y+3	; 0x03
    1b88:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b8a:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1b8c:	89 81       	ldd	r24, Y+1	; 0x01
    1b8e:	88 23       	and	r24, r24
    1b90:	f9 f0       	breq	.+62     	; 0x1bd0 <xQueueReceive+0x7c>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    1b92:	8a 81       	ldd	r24, Y+2	; 0x02
    1b94:	9b 81       	ldd	r25, Y+3	; 0x03
    1b96:	2a 85       	ldd	r18, Y+10	; 0x0a
    1b98:	3b 85       	ldd	r19, Y+11	; 0x0b
    1b9a:	b9 01       	movw	r22, r18
    1b9c:	0e 94 4d 11 	call	0x229a	; 0x229a <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1ba0:	89 81       	ldd	r24, Y+1	; 0x01
    1ba2:	81 50       	subi	r24, 0x01	; 1
    1ba4:	ea 81       	ldd	r30, Y+2	; 0x02
    1ba6:	fb 81       	ldd	r31, Y+3	; 0x03
    1ba8:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1baa:	ea 81       	ldd	r30, Y+2	; 0x02
    1bac:	fb 81       	ldd	r31, Y+3	; 0x03
    1bae:	80 85       	ldd	r24, Z+8	; 0x08
    1bb0:	88 23       	and	r24, r24
    1bb2:	49 f0       	breq	.+18     	; 0x1bc6 <xQueueReceive+0x72>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1bb4:	8a 81       	ldd	r24, Y+2	; 0x02
    1bb6:	9b 81       	ldd	r25, Y+3	; 0x03
    1bb8:	08 96       	adiw	r24, 0x08	; 8
    1bba:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <xTaskRemoveFromEventList>
    1bbe:	88 23       	and	r24, r24
    1bc0:	11 f0       	breq	.+4      	; 0x1bc6 <xQueueReceive+0x72>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1bc2:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    1bc6:	0f 90       	pop	r0
    1bc8:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    1bca:	81 e0       	ldi	r24, 0x01	; 1
    1bcc:	8e 87       	std	Y+14, r24	; 0x0e
    1bce:	63 c0       	rjmp	.+198    	; 0x1c96 <xQueueReceive+0x142>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1bd0:	8c 85       	ldd	r24, Y+12	; 0x0c
    1bd2:	9d 85       	ldd	r25, Y+13	; 0x0d
    1bd4:	00 97       	sbiw	r24, 0x00	; 0
    1bd6:	21 f4       	brne	.+8      	; 0x1be0 <xQueueReceive+0x8c>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1bd8:	0f 90       	pop	r0
    1bda:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    1bdc:	1e 86       	std	Y+14, r1	; 0x0e
    1bde:	5b c0       	rjmp	.+182    	; 0x1c96 <xQueueReceive+0x142>
                }
                else if( xEntryTimeSet == pdFALSE )
    1be0:	8c 81       	ldd	r24, Y+4	; 0x04
    1be2:	88 23       	and	r24, r24
    1be4:	31 f4       	brne	.+12     	; 0x1bf2 <xQueueReceive+0x9e>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1be6:	ce 01       	movw	r24, r28
    1be8:	05 96       	adiw	r24, 0x05	; 5
    1bea:	0e 94 d4 1e 	call	0x3da8	; 0x3da8 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    1bee:	81 e0       	ldi	r24, 0x01	; 1
    1bf0:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1bf2:	0f 90       	pop	r0
    1bf4:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1bf6:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1bfa:	0f b6       	in	r0, 0x3f	; 63
    1bfc:	f8 94       	cli
    1bfe:	0f 92       	push	r0
    1c00:	ea 81       	ldd	r30, Y+2	; 0x02
    1c02:	fb 81       	ldd	r31, Y+3	; 0x03
    1c04:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c06:	8f 3f       	cpi	r24, 0xFF	; 255
    1c08:	19 f4       	brne	.+6      	; 0x1c10 <xQueueReceive+0xbc>
    1c0a:	ea 81       	ldd	r30, Y+2	; 0x02
    1c0c:	fb 81       	ldd	r31, Y+3	; 0x03
    1c0e:	15 8e       	std	Z+29, r1	; 0x1d
    1c10:	ea 81       	ldd	r30, Y+2	; 0x02
    1c12:	fb 81       	ldd	r31, Y+3	; 0x03
    1c14:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c16:	8f 3f       	cpi	r24, 0xFF	; 255
    1c18:	19 f4       	brne	.+6      	; 0x1c20 <xQueueReceive+0xcc>
    1c1a:	ea 81       	ldd	r30, Y+2	; 0x02
    1c1c:	fb 81       	ldd	r31, Y+3	; 0x03
    1c1e:	16 8e       	std	Z+30, r1	; 0x1e
    1c20:	0f 90       	pop	r0
    1c22:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1c24:	ce 01       	movw	r24, r28
    1c26:	05 96       	adiw	r24, 0x05	; 5
    1c28:	9e 01       	movw	r18, r28
    1c2a:	24 5f       	subi	r18, 0xF4	; 244
    1c2c:	3f 4f       	sbci	r19, 0xFF	; 255
    1c2e:	b9 01       	movw	r22, r18
    1c30:	0e 94 ed 1e 	call	0x3dda	; 0x3dda <xTaskCheckForTimeOut>
    1c34:	88 23       	and	r24, r24
    1c36:	09 f5       	brne	.+66     	; 0x1c7a <xQueueReceive+0x126>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c38:	8a 81       	ldd	r24, Y+2	; 0x02
    1c3a:	9b 81       	ldd	r25, Y+3	; 0x03
    1c3c:	0e 94 e7 11 	call	0x23ce	; 0x23ce <prvIsQueueEmpty>
    1c40:	88 23       	and	r24, r24
    1c42:	a1 f0       	breq	.+40     	; 0x1c6c <xQueueReceive+0x118>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1c44:	8a 81       	ldd	r24, Y+2	; 0x02
    1c46:	9b 81       	ldd	r25, Y+3	; 0x03
    1c48:	41 96       	adiw	r24, 0x11	; 17
    1c4a:	2c 85       	ldd	r18, Y+12	; 0x0c
    1c4c:	3d 85       	ldd	r19, Y+13	; 0x0d
    1c4e:	b9 01       	movw	r22, r18
    1c50:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    1c54:	8a 81       	ldd	r24, Y+2	; 0x02
    1c56:	9b 81       	ldd	r25, Y+3	; 0x03
    1c58:	0e 94 94 11 	call	0x2328	; 0x2328 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    1c5c:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>
    1c60:	88 23       	and	r24, r24
    1c62:	09 f0       	breq	.+2      	; 0x1c66 <xQueueReceive+0x112>
    1c64:	8c cf       	rjmp	.-232    	; 0x1b7e <xQueueReceive+0x2a>
                {
                    portYIELD_WITHIN_API();
    1c66:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    1c6a:	89 cf       	rjmp	.-238    	; 0x1b7e <xQueueReceive+0x2a>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    1c6c:	8a 81       	ldd	r24, Y+2	; 0x02
    1c6e:	9b 81       	ldd	r25, Y+3	; 0x03
    1c70:	0e 94 94 11 	call	0x2328	; 0x2328 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    1c74:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>
    1c78:	82 cf       	rjmp	.-252    	; 0x1b7e <xQueueReceive+0x2a>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    1c7a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c7c:	9b 81       	ldd	r25, Y+3	; 0x03
    1c7e:	0e 94 94 11 	call	0x2328	; 0x2328 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1c82:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1c86:	8a 81       	ldd	r24, Y+2	; 0x02
    1c88:	9b 81       	ldd	r25, Y+3	; 0x03
    1c8a:	0e 94 e7 11 	call	0x23ce	; 0x23ce <prvIsQueueEmpty>
    1c8e:	88 23       	and	r24, r24
    1c90:	09 f4       	brne	.+2      	; 0x1c94 <xQueueReceive+0x140>
    1c92:	75 cf       	rjmp	.-278    	; 0x1b7e <xQueueReceive+0x2a>
            {
                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    1c94:	1e 86       	std	Y+14, r1	; 0x0e
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    1c96:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    1c98:	2e 96       	adiw	r28, 0x0e	; 14
    1c9a:	0f b6       	in	r0, 0x3f	; 63
    1c9c:	f8 94       	cli
    1c9e:	de bf       	out	0x3e, r29	; 62
    1ca0:	0f be       	out	0x3f, r0	; 63
    1ca2:	cd bf       	out	0x3d, r28	; 61
    1ca4:	cf 91       	pop	r28
    1ca6:	df 91       	pop	r29
    1ca8:	08 95       	ret

00001caa <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    1caa:	df 93       	push	r29
    1cac:	cf 93       	push	r28
    1cae:	cd b7       	in	r28, 0x3d	; 61
    1cb0:	de b7       	in	r29, 0x3e	; 62
    1cb2:	2c 97       	sbiw	r28, 0x0c	; 12
    1cb4:	0f b6       	in	r0, 0x3f	; 63
    1cb6:	f8 94       	cli
    1cb8:	de bf       	out	0x3e, r29	; 62
    1cba:	0f be       	out	0x3f, r0	; 63
    1cbc:	cd bf       	out	0x3d, r28	; 61
    1cbe:	99 87       	std	Y+9, r25	; 0x09
    1cc0:	88 87       	std	Y+8, r24	; 0x08
    1cc2:	7b 87       	std	Y+11, r23	; 0x0b
    1cc4:	6a 87       	std	Y+10, r22	; 0x0a
    BaseType_t xEntryTimeSet = pdFALSE;
    1cc6:	1c 82       	std	Y+4, r1	; 0x04
    TimeOut_t xTimeOut;
    Queue_t * const pxQueue = xQueue;
    1cc8:	88 85       	ldd	r24, Y+8	; 0x08
    1cca:	99 85       	ldd	r25, Y+9	; 0x09
    1ccc:	9b 83       	std	Y+3, r25	; 0x03
    1cce:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1cd0:	0f b6       	in	r0, 0x3f	; 63
    1cd2:	f8 94       	cli
    1cd4:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1cd6:	ea 81       	ldd	r30, Y+2	; 0x02
    1cd8:	fb 81       	ldd	r31, Y+3	; 0x03
    1cda:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cdc:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    1cde:	89 81       	ldd	r24, Y+1	; 0x01
    1ce0:	88 23       	and	r24, r24
    1ce2:	c1 f0       	breq	.+48     	; 0x1d14 <xQueueSemaphoreTake+0x6a>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1ce4:	89 81       	ldd	r24, Y+1	; 0x01
    1ce6:	81 50       	subi	r24, 0x01	; 1
    1ce8:	ea 81       	ldd	r30, Y+2	; 0x02
    1cea:	fb 81       	ldd	r31, Y+3	; 0x03
    1cec:	82 8f       	std	Z+26, r24	; 0x1a
                    }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1cee:	ea 81       	ldd	r30, Y+2	; 0x02
    1cf0:	fb 81       	ldd	r31, Y+3	; 0x03
    1cf2:	80 85       	ldd	r24, Z+8	; 0x08
    1cf4:	88 23       	and	r24, r24
    1cf6:	49 f0       	breq	.+18     	; 0x1d0a <xQueueSemaphoreTake+0x60>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1cf8:	8a 81       	ldd	r24, Y+2	; 0x02
    1cfa:	9b 81       	ldd	r25, Y+3	; 0x03
    1cfc:	08 96       	adiw	r24, 0x08	; 8
    1cfe:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <xTaskRemoveFromEventList>
    1d02:	88 23       	and	r24, r24
    1d04:	11 f0       	breq	.+4      	; 0x1d0a <xQueueSemaphoreTake+0x60>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    1d06:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    1d0a:	0f 90       	pop	r0
    1d0c:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    1d0e:	81 e0       	ldi	r24, 0x01	; 1
    1d10:	8c 87       	std	Y+12, r24	; 0x0c
    1d12:	63 c0       	rjmp	.+198    	; 0x1dda <xQueueSemaphoreTake+0x130>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1d14:	8a 85       	ldd	r24, Y+10	; 0x0a
    1d16:	9b 85       	ldd	r25, Y+11	; 0x0b
    1d18:	00 97       	sbiw	r24, 0x00	; 0
    1d1a:	21 f4       	brne	.+8      	; 0x1d24 <xQueueSemaphoreTake+0x7a>
                        }
                    #endif /* configUSE_MUTEXES */

                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    1d1c:	0f 90       	pop	r0
    1d1e:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    1d20:	1c 86       	std	Y+12, r1	; 0x0c
    1d22:	5b c0       	rjmp	.+182    	; 0x1dda <xQueueSemaphoreTake+0x130>
                }
                else if( xEntryTimeSet == pdFALSE )
    1d24:	8c 81       	ldd	r24, Y+4	; 0x04
    1d26:	88 23       	and	r24, r24
    1d28:	31 f4       	brne	.+12     	; 0x1d36 <xQueueSemaphoreTake+0x8c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1d2a:	ce 01       	movw	r24, r28
    1d2c:	05 96       	adiw	r24, 0x05	; 5
    1d2e:	0e 94 d4 1e 	call	0x3da8	; 0x3da8 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    1d32:	81 e0       	ldi	r24, 0x01	; 1
    1d34:	8c 83       	std	Y+4, r24	; 0x04
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1d36:	0f 90       	pop	r0
    1d38:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    1d3a:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1d3e:	0f b6       	in	r0, 0x3f	; 63
    1d40:	f8 94       	cli
    1d42:	0f 92       	push	r0
    1d44:	ea 81       	ldd	r30, Y+2	; 0x02
    1d46:	fb 81       	ldd	r31, Y+3	; 0x03
    1d48:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d4a:	8f 3f       	cpi	r24, 0xFF	; 255
    1d4c:	19 f4       	brne	.+6      	; 0x1d54 <xQueueSemaphoreTake+0xaa>
    1d4e:	ea 81       	ldd	r30, Y+2	; 0x02
    1d50:	fb 81       	ldd	r31, Y+3	; 0x03
    1d52:	15 8e       	std	Z+29, r1	; 0x1d
    1d54:	ea 81       	ldd	r30, Y+2	; 0x02
    1d56:	fb 81       	ldd	r31, Y+3	; 0x03
    1d58:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d5a:	8f 3f       	cpi	r24, 0xFF	; 255
    1d5c:	19 f4       	brne	.+6      	; 0x1d64 <xQueueSemaphoreTake+0xba>
    1d5e:	ea 81       	ldd	r30, Y+2	; 0x02
    1d60:	fb 81       	ldd	r31, Y+3	; 0x03
    1d62:	16 8e       	std	Z+30, r1	; 0x1e
    1d64:	0f 90       	pop	r0
    1d66:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1d68:	ce 01       	movw	r24, r28
    1d6a:	05 96       	adiw	r24, 0x05	; 5
    1d6c:	9e 01       	movw	r18, r28
    1d6e:	26 5f       	subi	r18, 0xF6	; 246
    1d70:	3f 4f       	sbci	r19, 0xFF	; 255
    1d72:	b9 01       	movw	r22, r18
    1d74:	0e 94 ed 1e 	call	0x3dda	; 0x3dda <xTaskCheckForTimeOut>
    1d78:	88 23       	and	r24, r24
    1d7a:	09 f5       	brne	.+66     	; 0x1dbe <xQueueSemaphoreTake+0x114>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1d7c:	8a 81       	ldd	r24, Y+2	; 0x02
    1d7e:	9b 81       	ldd	r25, Y+3	; 0x03
    1d80:	0e 94 e7 11 	call	0x23ce	; 0x23ce <prvIsQueueEmpty>
    1d84:	88 23       	and	r24, r24
    1d86:	a1 f0       	breq	.+40     	; 0x1db0 <xQueueSemaphoreTake+0x106>
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1d88:	8a 81       	ldd	r24, Y+2	; 0x02
    1d8a:	9b 81       	ldd	r25, Y+3	; 0x03
    1d8c:	41 96       	adiw	r24, 0x11	; 17
    1d8e:	2a 85       	ldd	r18, Y+10	; 0x0a
    1d90:	3b 85       	ldd	r19, Y+11	; 0x0b
    1d92:	b9 01       	movw	r22, r18
    1d94:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    1d98:	8a 81       	ldd	r24, Y+2	; 0x02
    1d9a:	9b 81       	ldd	r25, Y+3	; 0x03
    1d9c:	0e 94 94 11 	call	0x2328	; 0x2328 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    1da0:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>
    1da4:	88 23       	and	r24, r24
    1da6:	09 f0       	breq	.+2      	; 0x1daa <xQueueSemaphoreTake+0x100>
    1da8:	93 cf       	rjmp	.-218    	; 0x1cd0 <xQueueSemaphoreTake+0x26>
                {
                    portYIELD_WITHIN_API();
    1daa:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    1dae:	90 cf       	rjmp	.-224    	; 0x1cd0 <xQueueSemaphoreTake+0x26>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    1db0:	8a 81       	ldd	r24, Y+2	; 0x02
    1db2:	9b 81       	ldd	r25, Y+3	; 0x03
    1db4:	0e 94 94 11 	call	0x2328	; 0x2328 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    1db8:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>
    1dbc:	89 cf       	rjmp	.-238    	; 0x1cd0 <xQueueSemaphoreTake+0x26>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    1dbe:	8a 81       	ldd	r24, Y+2	; 0x02
    1dc0:	9b 81       	ldd	r25, Y+3	; 0x03
    1dc2:	0e 94 94 11 	call	0x2328	; 0x2328 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1dc6:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1dca:	8a 81       	ldd	r24, Y+2	; 0x02
    1dcc:	9b 81       	ldd	r25, Y+3	; 0x03
    1dce:	0e 94 e7 11 	call	0x23ce	; 0x23ce <prvIsQueueEmpty>
    1dd2:	88 23       	and	r24, r24
    1dd4:	09 f4       	brne	.+2      	; 0x1dd8 <xQueueSemaphoreTake+0x12e>
    1dd6:	7c cf       	rjmp	.-264    	; 0x1cd0 <xQueueSemaphoreTake+0x26>
                        }
                    }
                #endif /* configUSE_MUTEXES */

                traceQUEUE_RECEIVE_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    1dd8:	1c 86       	std	Y+12, r1	; 0x0c
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    1dda:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    1ddc:	2c 96       	adiw	r28, 0x0c	; 12
    1dde:	0f b6       	in	r0, 0x3f	; 63
    1de0:	f8 94       	cli
    1de2:	de bf       	out	0x3e, r29	; 62
    1de4:	0f be       	out	0x3f, r0	; 63
    1de6:	cd bf       	out	0x3d, r28	; 61
    1de8:	cf 91       	pop	r28
    1dea:	df 91       	pop	r29
    1dec:	08 95       	ret

00001dee <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    1dee:	df 93       	push	r29
    1df0:	cf 93       	push	r28
    1df2:	cd b7       	in	r28, 0x3d	; 61
    1df4:	de b7       	in	r29, 0x3e	; 62
    1df6:	60 97       	sbiw	r28, 0x10	; 16
    1df8:	0f b6       	in	r0, 0x3f	; 63
    1dfa:	f8 94       	cli
    1dfc:	de bf       	out	0x3e, r29	; 62
    1dfe:	0f be       	out	0x3f, r0	; 63
    1e00:	cd bf       	out	0x3d, r28	; 61
    1e02:	9b 87       	std	Y+11, r25	; 0x0b
    1e04:	8a 87       	std	Y+10, r24	; 0x0a
    1e06:	7d 87       	std	Y+13, r23	; 0x0d
    1e08:	6c 87       	std	Y+12, r22	; 0x0c
    1e0a:	5f 87       	std	Y+15, r21	; 0x0f
    1e0c:	4e 87       	std	Y+14, r20	; 0x0e
    BaseType_t xEntryTimeSet = pdFALSE;
    1e0e:	1e 82       	std	Y+6, r1	; 0x06
    TimeOut_t xTimeOut;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    1e10:	8a 85       	ldd	r24, Y+10	; 0x0a
    1e12:	9b 85       	ldd	r25, Y+11	; 0x0b
    1e14:	9b 83       	std	Y+3, r25	; 0x03
    1e16:	8a 83       	std	Y+2, r24	; 0x02
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    1e18:	0f b6       	in	r0, 0x3f	; 63
    1e1a:	f8 94       	cli
    1e1c:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1e1e:	ea 81       	ldd	r30, Y+2	; 0x02
    1e20:	fb 81       	ldd	r31, Y+3	; 0x03
    1e22:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e24:	89 83       	std	Y+1, r24	; 0x01

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1e26:	89 81       	ldd	r24, Y+1	; 0x01
    1e28:	88 23       	and	r24, r24
    1e2a:	31 f1       	breq	.+76     	; 0x1e78 <xQueuePeek+0x8a>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1e2c:	ea 81       	ldd	r30, Y+2	; 0x02
    1e2e:	fb 81       	ldd	r31, Y+3	; 0x03
    1e30:	86 81       	ldd	r24, Z+6	; 0x06
    1e32:	97 81       	ldd	r25, Z+7	; 0x07
    1e34:	9d 83       	std	Y+5, r25	; 0x05
    1e36:	8c 83       	std	Y+4, r24	; 0x04

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    1e38:	8a 81       	ldd	r24, Y+2	; 0x02
    1e3a:	9b 81       	ldd	r25, Y+3	; 0x03
    1e3c:	2c 85       	ldd	r18, Y+12	; 0x0c
    1e3e:	3d 85       	ldd	r19, Y+13	; 0x0d
    1e40:	b9 01       	movw	r22, r18
    1e42:	0e 94 4d 11 	call	0x229a	; 0x229a <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1e46:	ea 81       	ldd	r30, Y+2	; 0x02
    1e48:	fb 81       	ldd	r31, Y+3	; 0x03
    1e4a:	8c 81       	ldd	r24, Y+4	; 0x04
    1e4c:	9d 81       	ldd	r25, Y+5	; 0x05
    1e4e:	97 83       	std	Z+7, r25	; 0x07
    1e50:	86 83       	std	Z+6, r24	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e52:	ea 81       	ldd	r30, Y+2	; 0x02
    1e54:	fb 81       	ldd	r31, Y+3	; 0x03
    1e56:	81 89       	ldd	r24, Z+17	; 0x11
    1e58:	88 23       	and	r24, r24
    1e5a:	49 f0       	breq	.+18     	; 0x1e6e <xQueuePeek+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e5c:	8a 81       	ldd	r24, Y+2	; 0x02
    1e5e:	9b 81       	ldd	r25, Y+3	; 0x03
    1e60:	41 96       	adiw	r24, 0x11	; 17
    1e62:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <xTaskRemoveFromEventList>
    1e66:	88 23       	and	r24, r24
    1e68:	11 f0       	breq	.+4      	; 0x1e6e <xQueuePeek+0x80>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    1e6a:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    1e6e:	0f 90       	pop	r0
    1e70:	0f be       	out	0x3f, r0	; 63
                return pdPASS;
    1e72:	81 e0       	ldi	r24, 0x01	; 1
    1e74:	88 8b       	std	Y+16, r24	; 0x10
    1e76:	63 c0       	rjmp	.+198    	; 0x1f3e <xQueuePeek+0x150>
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    1e78:	8e 85       	ldd	r24, Y+14	; 0x0e
    1e7a:	9f 85       	ldd	r25, Y+15	; 0x0f
    1e7c:	00 97       	sbiw	r24, 0x00	; 0
    1e7e:	21 f4       	brne	.+8      	; 0x1e88 <xQueuePeek+0x9a>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    1e80:	0f 90       	pop	r0
    1e82:	0f be       	out	0x3f, r0	; 63
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
    1e84:	18 8a       	std	Y+16, r1	; 0x10
    1e86:	5b c0       	rjmp	.+182    	; 0x1f3e <xQueuePeek+0x150>
                }
                else if( xEntryTimeSet == pdFALSE )
    1e88:	8e 81       	ldd	r24, Y+6	; 0x06
    1e8a:	88 23       	and	r24, r24
    1e8c:	31 f4       	brne	.+12     	; 0x1e9a <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    1e8e:	ce 01       	movw	r24, r28
    1e90:	07 96       	adiw	r24, 0x07	; 7
    1e92:	0e 94 d4 1e 	call	0x3da8	; 0x3da8 <vTaskInternalSetTimeOutState>
                    xEntryTimeSet = pdTRUE;
    1e96:	81 e0       	ldi	r24, 0x01	; 1
    1e98:	8e 83       	std	Y+6, r24	; 0x06
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    1e9a:	0f 90       	pop	r0
    1e9c:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    1e9e:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    1ea2:	0f b6       	in	r0, 0x3f	; 63
    1ea4:	f8 94       	cli
    1ea6:	0f 92       	push	r0
    1ea8:	ea 81       	ldd	r30, Y+2	; 0x02
    1eaa:	fb 81       	ldd	r31, Y+3	; 0x03
    1eac:	85 8d       	ldd	r24, Z+29	; 0x1d
    1eae:	8f 3f       	cpi	r24, 0xFF	; 255
    1eb0:	19 f4       	brne	.+6      	; 0x1eb8 <xQueuePeek+0xca>
    1eb2:	ea 81       	ldd	r30, Y+2	; 0x02
    1eb4:	fb 81       	ldd	r31, Y+3	; 0x03
    1eb6:	15 8e       	std	Z+29, r1	; 0x1d
    1eb8:	ea 81       	ldd	r30, Y+2	; 0x02
    1eba:	fb 81       	ldd	r31, Y+3	; 0x03
    1ebc:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ebe:	8f 3f       	cpi	r24, 0xFF	; 255
    1ec0:	19 f4       	brne	.+6      	; 0x1ec8 <xQueuePeek+0xda>
    1ec2:	ea 81       	ldd	r30, Y+2	; 0x02
    1ec4:	fb 81       	ldd	r31, Y+3	; 0x03
    1ec6:	16 8e       	std	Z+30, r1	; 0x1e
    1ec8:	0f 90       	pop	r0
    1eca:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1ecc:	ce 01       	movw	r24, r28
    1ece:	07 96       	adiw	r24, 0x07	; 7
    1ed0:	9e 01       	movw	r18, r28
    1ed2:	22 5f       	subi	r18, 0xF2	; 242
    1ed4:	3f 4f       	sbci	r19, 0xFF	; 255
    1ed6:	b9 01       	movw	r22, r18
    1ed8:	0e 94 ed 1e 	call	0x3dda	; 0x3dda <xTaskCheckForTimeOut>
    1edc:	88 23       	and	r24, r24
    1ede:	09 f5       	brne	.+66     	; 0x1f22 <xQueuePeek+0x134>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1ee0:	8a 81       	ldd	r24, Y+2	; 0x02
    1ee2:	9b 81       	ldd	r25, Y+3	; 0x03
    1ee4:	0e 94 e7 11 	call	0x23ce	; 0x23ce <prvIsQueueEmpty>
    1ee8:	88 23       	and	r24, r24
    1eea:	a1 f0       	breq	.+40     	; 0x1f14 <xQueuePeek+0x126>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1eec:	8a 81       	ldd	r24, Y+2	; 0x02
    1eee:	9b 81       	ldd	r25, Y+3	; 0x03
    1ef0:	41 96       	adiw	r24, 0x11	; 17
    1ef2:	2e 85       	ldd	r18, Y+14	; 0x0e
    1ef4:	3f 85       	ldd	r19, Y+15	; 0x0f
    1ef6:	b9 01       	movw	r22, r18
    1ef8:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    1efc:	8a 81       	ldd	r24, Y+2	; 0x02
    1efe:	9b 81       	ldd	r25, Y+3	; 0x03
    1f00:	0e 94 94 11 	call	0x2328	; 0x2328 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    1f04:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>
    1f08:	88 23       	and	r24, r24
    1f0a:	09 f0       	breq	.+2      	; 0x1f0e <xQueuePeek+0x120>
    1f0c:	85 cf       	rjmp	.-246    	; 0x1e18 <xQueuePeek+0x2a>
                {
                    portYIELD_WITHIN_API();
    1f0e:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    1f12:	82 cf       	rjmp	.-252    	; 0x1e18 <xQueuePeek+0x2a>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    1f14:	8a 81       	ldd	r24, Y+2	; 0x02
    1f16:	9b 81       	ldd	r25, Y+3	; 0x03
    1f18:	0e 94 94 11 	call	0x2328	; 0x2328 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    1f1c:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>
    1f20:	7b cf       	rjmp	.-266    	; 0x1e18 <xQueuePeek+0x2a>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    1f22:	8a 81       	ldd	r24, Y+2	; 0x02
    1f24:	9b 81       	ldd	r25, Y+3	; 0x03
    1f26:	0e 94 94 11 	call	0x2328	; 0x2328 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    1f2a:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1f2e:	8a 81       	ldd	r24, Y+2	; 0x02
    1f30:	9b 81       	ldd	r25, Y+3	; 0x03
    1f32:	0e 94 e7 11 	call	0x23ce	; 0x23ce <prvIsQueueEmpty>
    1f36:	88 23       	and	r24, r24
    1f38:	09 f4       	brne	.+2      	; 0x1f3c <xQueuePeek+0x14e>
    1f3a:	6e cf       	rjmp	.-292    	; 0x1e18 <xQueuePeek+0x2a>
            {
                traceQUEUE_PEEK_FAILED( pxQueue );
                return errQUEUE_EMPTY;
    1f3c:	18 8a       	std	Y+16, r1	; 0x10
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
    1f3e:	88 89       	ldd	r24, Y+16	; 0x10
}
    1f40:	60 96       	adiw	r28, 0x10	; 16
    1f42:	0f b6       	in	r0, 0x3f	; 63
    1f44:	f8 94       	cli
    1f46:	de bf       	out	0x3e, r29	; 62
    1f48:	0f be       	out	0x3f, r0	; 63
    1f4a:	cd bf       	out	0x3d, r28	; 61
    1f4c:	cf 91       	pop	r28
    1f4e:	df 91       	pop	r29
    1f50:	08 95       	ret

00001f52 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    1f52:	df 93       	push	r29
    1f54:	cf 93       	push	r28
    1f56:	cd b7       	in	r28, 0x3d	; 61
    1f58:	de b7       	in	r29, 0x3e	; 62
    1f5a:	2c 97       	sbiw	r28, 0x0c	; 12
    1f5c:	0f b6       	in	r0, 0x3f	; 63
    1f5e:	f8 94       	cli
    1f60:	de bf       	out	0x3e, r29	; 62
    1f62:	0f be       	out	0x3f, r0	; 63
    1f64:	cd bf       	out	0x3d, r28	; 61
    1f66:	98 87       	std	Y+8, r25	; 0x08
    1f68:	8f 83       	std	Y+7, r24	; 0x07
    1f6a:	7a 87       	std	Y+10, r23	; 0x0a
    1f6c:	69 87       	std	Y+9, r22	; 0x09
    1f6e:	5c 87       	std	Y+12, r21	; 0x0c
    1f70:	4b 87       	std	Y+11, r20	; 0x0b
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    Queue_t * const pxQueue = xQueue;
    1f72:	8f 81       	ldd	r24, Y+7	; 0x07
    1f74:	98 85       	ldd	r25, Y+8	; 0x08
    1f76:	9c 83       	std	Y+4, r25	; 0x04
    1f78:	8b 83       	std	Y+3, r24	; 0x03
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1f7a:	1d 82       	std	Y+5, r1	; 0x05
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1f7c:	eb 81       	ldd	r30, Y+3	; 0x03
    1f7e:	fc 81       	ldd	r31, Y+4	; 0x04
    1f80:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f82:	8a 83       	std	Y+2, r24	; 0x02

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1f84:	8a 81       	ldd	r24, Y+2	; 0x02
    1f86:	88 23       	and	r24, r24
    1f88:	81 f1       	breq	.+96     	; 0x1fea <xQueueReceiveFromISR+0x98>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    1f8a:	eb 81       	ldd	r30, Y+3	; 0x03
    1f8c:	fc 81       	ldd	r31, Y+4	; 0x04
    1f8e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f90:	89 83       	std	Y+1, r24	; 0x01

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    1f92:	8b 81       	ldd	r24, Y+3	; 0x03
    1f94:	9c 81       	ldd	r25, Y+4	; 0x04
    1f96:	29 85       	ldd	r18, Y+9	; 0x09
    1f98:	3a 85       	ldd	r19, Y+10	; 0x0a
    1f9a:	b9 01       	movw	r22, r18
    1f9c:	0e 94 4d 11 	call	0x229a	; 0x229a <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1fa0:	8a 81       	ldd	r24, Y+2	; 0x02
    1fa2:	81 50       	subi	r24, 0x01	; 1
    1fa4:	eb 81       	ldd	r30, Y+3	; 0x03
    1fa6:	fc 81       	ldd	r31, Y+4	; 0x04
    1fa8:	82 8f       	std	Z+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    1faa:	89 81       	ldd	r24, Y+1	; 0x01
    1fac:	8f 3f       	cpi	r24, 0xFF	; 255
    1fae:	a9 f4       	brne	.+42     	; 0x1fda <xQueueReceiveFromISR+0x88>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1fb0:	eb 81       	ldd	r30, Y+3	; 0x03
    1fb2:	fc 81       	ldd	r31, Y+4	; 0x04
    1fb4:	80 85       	ldd	r24, Z+8	; 0x08
    1fb6:	88 23       	and	r24, r24
    1fb8:	a9 f0       	breq	.+42     	; 0x1fe4 <xQueueReceiveFromISR+0x92>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1fba:	8b 81       	ldd	r24, Y+3	; 0x03
    1fbc:	9c 81       	ldd	r25, Y+4	; 0x04
    1fbe:	08 96       	adiw	r24, 0x08	; 8
    1fc0:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <xTaskRemoveFromEventList>
    1fc4:	88 23       	and	r24, r24
    1fc6:	71 f0       	breq	.+28     	; 0x1fe4 <xQueueReceiveFromISR+0x92>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    1fc8:	8b 85       	ldd	r24, Y+11	; 0x0b
    1fca:	9c 85       	ldd	r25, Y+12	; 0x0c
    1fcc:	00 97       	sbiw	r24, 0x00	; 0
    1fce:	51 f0       	breq	.+20     	; 0x1fe4 <xQueueReceiveFromISR+0x92>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    1fd0:	eb 85       	ldd	r30, Y+11	; 0x0b
    1fd2:	fc 85       	ldd	r31, Y+12	; 0x0c
    1fd4:	81 e0       	ldi	r24, 0x01	; 1
    1fd6:	80 83       	st	Z, r24
    1fd8:	05 c0       	rjmp	.+10     	; 0x1fe4 <xQueueReceiveFromISR+0x92>
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                configASSERT( cRxLock != queueINT8_MAX );

                pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1fda:	89 81       	ldd	r24, Y+1	; 0x01
    1fdc:	8f 5f       	subi	r24, 0xFF	; 255
    1fde:	eb 81       	ldd	r30, Y+3	; 0x03
    1fe0:	fc 81       	ldd	r31, Y+4	; 0x04
    1fe2:	85 8f       	std	Z+29, r24	; 0x1d
            }

            xReturn = pdPASS;
    1fe4:	81 e0       	ldi	r24, 0x01	; 1
    1fe6:	8e 83       	std	Y+6, r24	; 0x06
    1fe8:	01 c0       	rjmp	.+2      	; 0x1fec <xQueueReceiveFromISR+0x9a>
        }
        else
        {
            xReturn = pdFAIL;
    1fea:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    1fec:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1fee:	2c 96       	adiw	r28, 0x0c	; 12
    1ff0:	0f b6       	in	r0, 0x3f	; 63
    1ff2:	f8 94       	cli
    1ff4:	de bf       	out	0x3e, r29	; 62
    1ff6:	0f be       	out	0x3f, r0	; 63
    1ff8:	cd bf       	out	0x3d, r28	; 61
    1ffa:	cf 91       	pop	r28
    1ffc:	df 91       	pop	r29
    1ffe:	08 95       	ret

00002000 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    2000:	df 93       	push	r29
    2002:	cf 93       	push	r28
    2004:	cd b7       	in	r28, 0x3d	; 61
    2006:	de b7       	in	r29, 0x3e	; 62
    2008:	2a 97       	sbiw	r28, 0x0a	; 10
    200a:	0f b6       	in	r0, 0x3f	; 63
    200c:	f8 94       	cli
    200e:	de bf       	out	0x3e, r29	; 62
    2010:	0f be       	out	0x3f, r0	; 63
    2012:	cd bf       	out	0x3d, r28	; 61
    2014:	98 87       	std	Y+8, r25	; 0x08
    2016:	8f 83       	std	Y+7, r24	; 0x07
    2018:	7a 87       	std	Y+10, r23	; 0x0a
    201a:	69 87       	std	Y+9, r22	; 0x09
    BaseType_t xReturn;
    UBaseType_t uxSavedInterruptStatus;
    int8_t * pcOriginalReadPosition;
    Queue_t * const pxQueue = xQueue;
    201c:	8f 81       	ldd	r24, Y+7	; 0x07
    201e:	98 85       	ldd	r25, Y+8	; 0x08
    2020:	9a 83       	std	Y+2, r25	; 0x02
    2022:	89 83       	std	Y+1, r24	; 0x01
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2024:	1d 82       	std	Y+5, r1	; 0x05
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2026:	e9 81       	ldd	r30, Y+1	; 0x01
    2028:	fa 81       	ldd	r31, Y+2	; 0x02
    202a:	82 8d       	ldd	r24, Z+26	; 0x1a
    202c:	88 23       	and	r24, r24
    202e:	b1 f0       	breq	.+44     	; 0x205c <xQueuePeekFromISR+0x5c>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2030:	e9 81       	ldd	r30, Y+1	; 0x01
    2032:	fa 81       	ldd	r31, Y+2	; 0x02
    2034:	86 81       	ldd	r24, Z+6	; 0x06
    2036:	97 81       	ldd	r25, Z+7	; 0x07
    2038:	9c 83       	std	Y+4, r25	; 0x04
    203a:	8b 83       	std	Y+3, r24	; 0x03
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    203c:	89 81       	ldd	r24, Y+1	; 0x01
    203e:	9a 81       	ldd	r25, Y+2	; 0x02
    2040:	29 85       	ldd	r18, Y+9	; 0x09
    2042:	3a 85       	ldd	r19, Y+10	; 0x0a
    2044:	b9 01       	movw	r22, r18
    2046:	0e 94 4d 11 	call	0x229a	; 0x229a <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    204a:	e9 81       	ldd	r30, Y+1	; 0x01
    204c:	fa 81       	ldd	r31, Y+2	; 0x02
    204e:	8b 81       	ldd	r24, Y+3	; 0x03
    2050:	9c 81       	ldd	r25, Y+4	; 0x04
    2052:	97 83       	std	Z+7, r25	; 0x07
    2054:	86 83       	std	Z+6, r24	; 0x06

            xReturn = pdPASS;
    2056:	81 e0       	ldi	r24, 0x01	; 1
    2058:	8e 83       	std	Y+6, r24	; 0x06
    205a:	01 c0       	rjmp	.+2      	; 0x205e <xQueuePeekFromISR+0x5e>
        }
        else
        {
            xReturn = pdFAIL;
    205c:	1e 82       	std	Y+6, r1	; 0x06
            traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    205e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2060:	2a 96       	adiw	r28, 0x0a	; 10
    2062:	0f b6       	in	r0, 0x3f	; 63
    2064:	f8 94       	cli
    2066:	de bf       	out	0x3e, r29	; 62
    2068:	0f be       	out	0x3f, r0	; 63
    206a:	cd bf       	out	0x3d, r28	; 61
    206c:	cf 91       	pop	r28
    206e:	df 91       	pop	r29
    2070:	08 95       	ret

00002072 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    2072:	df 93       	push	r29
    2074:	cf 93       	push	r28
    2076:	00 d0       	rcall	.+0      	; 0x2078 <uxQueueMessagesWaiting+0x6>
    2078:	0f 92       	push	r0
    207a:	cd b7       	in	r28, 0x3d	; 61
    207c:	de b7       	in	r29, 0x3e	; 62
    207e:	9b 83       	std	Y+3, r25	; 0x03
    2080:	8a 83       	std	Y+2, r24	; 0x02
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    2082:	0f b6       	in	r0, 0x3f	; 63
    2084:	f8 94       	cli
    2086:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    2088:	ea 81       	ldd	r30, Y+2	; 0x02
    208a:	fb 81       	ldd	r31, Y+3	; 0x03
    208c:	82 8d       	ldd	r24, Z+26	; 0x1a
    208e:	89 83       	std	Y+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    2090:	0f 90       	pop	r0
    2092:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    2094:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2096:	0f 90       	pop	r0
    2098:	0f 90       	pop	r0
    209a:	0f 90       	pop	r0
    209c:	cf 91       	pop	r28
    209e:	df 91       	pop	r29
    20a0:	08 95       	ret

000020a2 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    20a2:	df 93       	push	r29
    20a4:	cf 93       	push	r28
    20a6:	00 d0       	rcall	.+0      	; 0x20a8 <uxQueueSpacesAvailable+0x6>
    20a8:	00 d0       	rcall	.+0      	; 0x20aa <uxQueueSpacesAvailable+0x8>
    20aa:	0f 92       	push	r0
    20ac:	cd b7       	in	r28, 0x3d	; 61
    20ae:	de b7       	in	r29, 0x3e	; 62
    20b0:	9d 83       	std	Y+5, r25	; 0x05
    20b2:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    20b4:	8c 81       	ldd	r24, Y+4	; 0x04
    20b6:	9d 81       	ldd	r25, Y+5	; 0x05
    20b8:	9a 83       	std	Y+2, r25	; 0x02
    20ba:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    20bc:	0f b6       	in	r0, 0x3f	; 63
    20be:	f8 94       	cli
    20c0:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    20c2:	e9 81       	ldd	r30, Y+1	; 0x01
    20c4:	fa 81       	ldd	r31, Y+2	; 0x02
    20c6:	93 8d       	ldd	r25, Z+27	; 0x1b
    20c8:	e9 81       	ldd	r30, Y+1	; 0x01
    20ca:	fa 81       	ldd	r31, Y+2	; 0x02
    20cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    20ce:	29 2f       	mov	r18, r25
    20d0:	28 1b       	sub	r18, r24
    20d2:	82 2f       	mov	r24, r18
    20d4:	8b 83       	std	Y+3, r24	; 0x03
    }
    taskEXIT_CRITICAL();
    20d6:	0f 90       	pop	r0
    20d8:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
    20da:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    20dc:	0f 90       	pop	r0
    20de:	0f 90       	pop	r0
    20e0:	0f 90       	pop	r0
    20e2:	0f 90       	pop	r0
    20e4:	0f 90       	pop	r0
    20e6:	cf 91       	pop	r28
    20e8:	df 91       	pop	r29
    20ea:	08 95       	ret

000020ec <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    20ec:	df 93       	push	r29
    20ee:	cf 93       	push	r28
    20f0:	00 d0       	rcall	.+0      	; 0x20f2 <uxQueueMessagesWaitingFromISR+0x6>
    20f2:	00 d0       	rcall	.+0      	; 0x20f4 <uxQueueMessagesWaitingFromISR+0x8>
    20f4:	0f 92       	push	r0
    20f6:	cd b7       	in	r28, 0x3d	; 61
    20f8:	de b7       	in	r29, 0x3e	; 62
    20fa:	9d 83       	std	Y+5, r25	; 0x05
    20fc:	8c 83       	std	Y+4, r24	; 0x04
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;
    20fe:	8c 81       	ldd	r24, Y+4	; 0x04
    2100:	9d 81       	ldd	r25, Y+5	; 0x05
    2102:	9a 83       	std	Y+2, r25	; 0x02
    2104:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    2106:	e9 81       	ldd	r30, Y+1	; 0x01
    2108:	fa 81       	ldd	r31, Y+2	; 0x02
    210a:	82 8d       	ldd	r24, Z+26	; 0x1a
    210c:	8b 83       	std	Y+3, r24	; 0x03

    return uxReturn;
    210e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    2110:	0f 90       	pop	r0
    2112:	0f 90       	pop	r0
    2114:	0f 90       	pop	r0
    2116:	0f 90       	pop	r0
    2118:	0f 90       	pop	r0
    211a:	cf 91       	pop	r28
    211c:	df 91       	pop	r29
    211e:	08 95       	ret

00002120 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    2120:	df 93       	push	r29
    2122:	cf 93       	push	r28
    2124:	00 d0       	rcall	.+0      	; 0x2126 <vQueueDelete+0x6>
    2126:	00 d0       	rcall	.+0      	; 0x2128 <vQueueDelete+0x8>
    2128:	cd b7       	in	r28, 0x3d	; 61
    212a:	de b7       	in	r29, 0x3e	; 62
    212c:	9c 83       	std	Y+4, r25	; 0x04
    212e:	8b 83       	std	Y+3, r24	; 0x03
    Queue_t * const pxQueue = xQueue;
    2130:	8b 81       	ldd	r24, Y+3	; 0x03
    2132:	9c 81       	ldd	r25, Y+4	; 0x04
    2134:	9a 83       	std	Y+2, r25	; 0x02
    2136:	89 83       	std	Y+1, r24	; 0x01

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
        {
            /* The queue can only have been allocated dynamically - free it
             * again. */
            vPortFree( pxQueue );
    2138:	89 81       	ldd	r24, Y+1	; 0x01
    213a:	9a 81       	ldd	r25, Y+2	; 0x02
    213c:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
            /* The queue must have been statically allocated, so is not going to be
             * deleted.  Avoid compiler warnings about the unused parameter. */
            ( void ) pxQueue;
        }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2140:	0f 90       	pop	r0
    2142:	0f 90       	pop	r0
    2144:	0f 90       	pop	r0
    2146:	0f 90       	pop	r0
    2148:	cf 91       	pop	r28
    214a:	df 91       	pop	r29
    214c:	08 95       	ret

0000214e <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    214e:	df 93       	push	r29
    2150:	cf 93       	push	r28
    2152:	cd b7       	in	r28, 0x3d	; 61
    2154:	de b7       	in	r29, 0x3e	; 62
    2156:	27 97       	sbiw	r28, 0x07	; 7
    2158:	0f b6       	in	r0, 0x3f	; 63
    215a:	f8 94       	cli
    215c:	de bf       	out	0x3e, r29	; 62
    215e:	0f be       	out	0x3f, r0	; 63
    2160:	cd bf       	out	0x3d, r28	; 61
    2162:	9c 83       	std	Y+4, r25	; 0x04
    2164:	8b 83       	std	Y+3, r24	; 0x03
    2166:	7e 83       	std	Y+6, r23	; 0x06
    2168:	6d 83       	std	Y+5, r22	; 0x05
    216a:	4f 83       	std	Y+7, r20	; 0x07
    BaseType_t xReturn = pdFALSE;
    216c:	1a 82       	std	Y+2, r1	; 0x02
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    216e:	eb 81       	ldd	r30, Y+3	; 0x03
    2170:	fc 81       	ldd	r31, Y+4	; 0x04
    2172:	82 8d       	ldd	r24, Z+26	; 0x1a
    2174:	89 83       	std	Y+1, r24	; 0x01

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2176:	eb 81       	ldd	r30, Y+3	; 0x03
    2178:	fc 81       	ldd	r31, Y+4	; 0x04
    217a:	84 8d       	ldd	r24, Z+28	; 0x1c
    217c:	88 23       	and	r24, r24
    217e:	09 f4       	brne	.+2      	; 0x2182 <prvCopyDataToQueue+0x34>
    2180:	7d c0       	rjmp	.+250    	; 0x227c <prvCopyDataToQueue+0x12e>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    2182:	8f 81       	ldd	r24, Y+7	; 0x07
    2184:	88 23       	and	r24, r24
    2186:	99 f5       	brne	.+102    	; 0x21ee <prvCopyDataToQueue+0xa0>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    2188:	eb 81       	ldd	r30, Y+3	; 0x03
    218a:	fc 81       	ldd	r31, Y+4	; 0x04
    218c:	62 81       	ldd	r22, Z+2	; 0x02
    218e:	73 81       	ldd	r23, Z+3	; 0x03
    2190:	eb 81       	ldd	r30, Y+3	; 0x03
    2192:	fc 81       	ldd	r31, Y+4	; 0x04
    2194:	84 8d       	ldd	r24, Z+28	; 0x1c
    2196:	48 2f       	mov	r20, r24
    2198:	50 e0       	ldi	r21, 0x00	; 0
    219a:	2d 81       	ldd	r18, Y+5	; 0x05
    219c:	3e 81       	ldd	r19, Y+6	; 0x06
    219e:	cb 01       	movw	r24, r22
    21a0:	b9 01       	movw	r22, r18
    21a2:	0e 94 16 33 	call	0x662c	; 0x662c <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    21a6:	eb 81       	ldd	r30, Y+3	; 0x03
    21a8:	fc 81       	ldd	r31, Y+4	; 0x04
    21aa:	22 81       	ldd	r18, Z+2	; 0x02
    21ac:	33 81       	ldd	r19, Z+3	; 0x03
    21ae:	eb 81       	ldd	r30, Y+3	; 0x03
    21b0:	fc 81       	ldd	r31, Y+4	; 0x04
    21b2:	84 8d       	ldd	r24, Z+28	; 0x1c
    21b4:	88 2f       	mov	r24, r24
    21b6:	90 e0       	ldi	r25, 0x00	; 0
    21b8:	82 0f       	add	r24, r18
    21ba:	93 1f       	adc	r25, r19
    21bc:	eb 81       	ldd	r30, Y+3	; 0x03
    21be:	fc 81       	ldd	r31, Y+4	; 0x04
    21c0:	93 83       	std	Z+3, r25	; 0x03
    21c2:	82 83       	std	Z+2, r24	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    21c4:	eb 81       	ldd	r30, Y+3	; 0x03
    21c6:	fc 81       	ldd	r31, Y+4	; 0x04
    21c8:	22 81       	ldd	r18, Z+2	; 0x02
    21ca:	33 81       	ldd	r19, Z+3	; 0x03
    21cc:	eb 81       	ldd	r30, Y+3	; 0x03
    21ce:	fc 81       	ldd	r31, Y+4	; 0x04
    21d0:	84 81       	ldd	r24, Z+4	; 0x04
    21d2:	95 81       	ldd	r25, Z+5	; 0x05
    21d4:	28 17       	cp	r18, r24
    21d6:	39 07       	cpc	r19, r25
    21d8:	08 f4       	brcc	.+2      	; 0x21dc <prvCopyDataToQueue+0x8e>
    21da:	50 c0       	rjmp	.+160    	; 0x227c <prvCopyDataToQueue+0x12e>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    21dc:	eb 81       	ldd	r30, Y+3	; 0x03
    21de:	fc 81       	ldd	r31, Y+4	; 0x04
    21e0:	80 81       	ld	r24, Z
    21e2:	91 81       	ldd	r25, Z+1	; 0x01
    21e4:	eb 81       	ldd	r30, Y+3	; 0x03
    21e6:	fc 81       	ldd	r31, Y+4	; 0x04
    21e8:	93 83       	std	Z+3, r25	; 0x03
    21ea:	82 83       	std	Z+2, r24	; 0x02
    21ec:	47 c0       	rjmp	.+142    	; 0x227c <prvCopyDataToQueue+0x12e>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    21ee:	eb 81       	ldd	r30, Y+3	; 0x03
    21f0:	fc 81       	ldd	r31, Y+4	; 0x04
    21f2:	66 81       	ldd	r22, Z+6	; 0x06
    21f4:	77 81       	ldd	r23, Z+7	; 0x07
    21f6:	eb 81       	ldd	r30, Y+3	; 0x03
    21f8:	fc 81       	ldd	r31, Y+4	; 0x04
    21fa:	84 8d       	ldd	r24, Z+28	; 0x1c
    21fc:	48 2f       	mov	r20, r24
    21fe:	50 e0       	ldi	r21, 0x00	; 0
    2200:	2d 81       	ldd	r18, Y+5	; 0x05
    2202:	3e 81       	ldd	r19, Y+6	; 0x06
    2204:	cb 01       	movw	r24, r22
    2206:	b9 01       	movw	r22, r18
    2208:	0e 94 16 33 	call	0x662c	; 0x662c <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    220c:	eb 81       	ldd	r30, Y+3	; 0x03
    220e:	fc 81       	ldd	r31, Y+4	; 0x04
    2210:	26 81       	ldd	r18, Z+6	; 0x06
    2212:	37 81       	ldd	r19, Z+7	; 0x07
    2214:	eb 81       	ldd	r30, Y+3	; 0x03
    2216:	fc 81       	ldd	r31, Y+4	; 0x04
    2218:	84 8d       	ldd	r24, Z+28	; 0x1c
    221a:	88 2f       	mov	r24, r24
    221c:	90 e0       	ldi	r25, 0x00	; 0
    221e:	90 95       	com	r25
    2220:	81 95       	neg	r24
    2222:	9f 4f       	sbci	r25, 0xFF	; 255
    2224:	82 0f       	add	r24, r18
    2226:	93 1f       	adc	r25, r19
    2228:	eb 81       	ldd	r30, Y+3	; 0x03
    222a:	fc 81       	ldd	r31, Y+4	; 0x04
    222c:	97 83       	std	Z+7, r25	; 0x07
    222e:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2230:	eb 81       	ldd	r30, Y+3	; 0x03
    2232:	fc 81       	ldd	r31, Y+4	; 0x04
    2234:	26 81       	ldd	r18, Z+6	; 0x06
    2236:	37 81       	ldd	r19, Z+7	; 0x07
    2238:	eb 81       	ldd	r30, Y+3	; 0x03
    223a:	fc 81       	ldd	r31, Y+4	; 0x04
    223c:	80 81       	ld	r24, Z
    223e:	91 81       	ldd	r25, Z+1	; 0x01
    2240:	28 17       	cp	r18, r24
    2242:	39 07       	cpc	r19, r25
    2244:	90 f4       	brcc	.+36     	; 0x226a <prvCopyDataToQueue+0x11c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    2246:	eb 81       	ldd	r30, Y+3	; 0x03
    2248:	fc 81       	ldd	r31, Y+4	; 0x04
    224a:	24 81       	ldd	r18, Z+4	; 0x04
    224c:	35 81       	ldd	r19, Z+5	; 0x05
    224e:	eb 81       	ldd	r30, Y+3	; 0x03
    2250:	fc 81       	ldd	r31, Y+4	; 0x04
    2252:	84 8d       	ldd	r24, Z+28	; 0x1c
    2254:	88 2f       	mov	r24, r24
    2256:	90 e0       	ldi	r25, 0x00	; 0
    2258:	90 95       	com	r25
    225a:	81 95       	neg	r24
    225c:	9f 4f       	sbci	r25, 0xFF	; 255
    225e:	82 0f       	add	r24, r18
    2260:	93 1f       	adc	r25, r19
    2262:	eb 81       	ldd	r30, Y+3	; 0x03
    2264:	fc 81       	ldd	r31, Y+4	; 0x04
    2266:	97 83       	std	Z+7, r25	; 0x07
    2268:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    226a:	8f 81       	ldd	r24, Y+7	; 0x07
    226c:	82 30       	cpi	r24, 0x02	; 2
    226e:	31 f4       	brne	.+12     	; 0x227c <prvCopyDataToQueue+0x12e>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2270:	89 81       	ldd	r24, Y+1	; 0x01
    2272:	88 23       	and	r24, r24
    2274:	19 f0       	breq	.+6      	; 0x227c <prvCopyDataToQueue+0x12e>
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    2276:	89 81       	ldd	r24, Y+1	; 0x01
    2278:	81 50       	subi	r24, 0x01	; 1
    227a:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    227c:	89 81       	ldd	r24, Y+1	; 0x01
    227e:	8f 5f       	subi	r24, 0xFF	; 255
    2280:	eb 81       	ldd	r30, Y+3	; 0x03
    2282:	fc 81       	ldd	r31, Y+4	; 0x04
    2284:	82 8f       	std	Z+26, r24	; 0x1a

    return xReturn;
    2286:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2288:	27 96       	adiw	r28, 0x07	; 7
    228a:	0f b6       	in	r0, 0x3f	; 63
    228c:	f8 94       	cli
    228e:	de bf       	out	0x3e, r29	; 62
    2290:	0f be       	out	0x3f, r0	; 63
    2292:	cd bf       	out	0x3d, r28	; 61
    2294:	cf 91       	pop	r28
    2296:	df 91       	pop	r29
    2298:	08 95       	ret

0000229a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    229a:	df 93       	push	r29
    229c:	cf 93       	push	r28
    229e:	00 d0       	rcall	.+0      	; 0x22a0 <prvCopyDataFromQueue+0x6>
    22a0:	00 d0       	rcall	.+0      	; 0x22a2 <prvCopyDataFromQueue+0x8>
    22a2:	cd b7       	in	r28, 0x3d	; 61
    22a4:	de b7       	in	r29, 0x3e	; 62
    22a6:	9a 83       	std	Y+2, r25	; 0x02
    22a8:	89 83       	std	Y+1, r24	; 0x01
    22aa:	7c 83       	std	Y+4, r23	; 0x04
    22ac:	6b 83       	std	Y+3, r22	; 0x03
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    22ae:	e9 81       	ldd	r30, Y+1	; 0x01
    22b0:	fa 81       	ldd	r31, Y+2	; 0x02
    22b2:	84 8d       	ldd	r24, Z+28	; 0x1c
    22b4:	88 23       	and	r24, r24
    22b6:	89 f1       	breq	.+98     	; 0x231a <prvCopyDataFromQueue+0x80>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    22b8:	e9 81       	ldd	r30, Y+1	; 0x01
    22ba:	fa 81       	ldd	r31, Y+2	; 0x02
    22bc:	26 81       	ldd	r18, Z+6	; 0x06
    22be:	37 81       	ldd	r19, Z+7	; 0x07
    22c0:	e9 81       	ldd	r30, Y+1	; 0x01
    22c2:	fa 81       	ldd	r31, Y+2	; 0x02
    22c4:	84 8d       	ldd	r24, Z+28	; 0x1c
    22c6:	88 2f       	mov	r24, r24
    22c8:	90 e0       	ldi	r25, 0x00	; 0
    22ca:	82 0f       	add	r24, r18
    22cc:	93 1f       	adc	r25, r19
    22ce:	e9 81       	ldd	r30, Y+1	; 0x01
    22d0:	fa 81       	ldd	r31, Y+2	; 0x02
    22d2:	97 83       	std	Z+7, r25	; 0x07
    22d4:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    22d6:	e9 81       	ldd	r30, Y+1	; 0x01
    22d8:	fa 81       	ldd	r31, Y+2	; 0x02
    22da:	26 81       	ldd	r18, Z+6	; 0x06
    22dc:	37 81       	ldd	r19, Z+7	; 0x07
    22de:	e9 81       	ldd	r30, Y+1	; 0x01
    22e0:	fa 81       	ldd	r31, Y+2	; 0x02
    22e2:	84 81       	ldd	r24, Z+4	; 0x04
    22e4:	95 81       	ldd	r25, Z+5	; 0x05
    22e6:	28 17       	cp	r18, r24
    22e8:	39 07       	cpc	r19, r25
    22ea:	40 f0       	brcs	.+16     	; 0x22fc <prvCopyDataFromQueue+0x62>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    22ec:	e9 81       	ldd	r30, Y+1	; 0x01
    22ee:	fa 81       	ldd	r31, Y+2	; 0x02
    22f0:	80 81       	ld	r24, Z
    22f2:	91 81       	ldd	r25, Z+1	; 0x01
    22f4:	e9 81       	ldd	r30, Y+1	; 0x01
    22f6:	fa 81       	ldd	r31, Y+2	; 0x02
    22f8:	97 83       	std	Z+7, r25	; 0x07
    22fa:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    22fc:	e9 81       	ldd	r30, Y+1	; 0x01
    22fe:	fa 81       	ldd	r31, Y+2	; 0x02
    2300:	46 81       	ldd	r20, Z+6	; 0x06
    2302:	57 81       	ldd	r21, Z+7	; 0x07
    2304:	e9 81       	ldd	r30, Y+1	; 0x01
    2306:	fa 81       	ldd	r31, Y+2	; 0x02
    2308:	84 8d       	ldd	r24, Z+28	; 0x1c
    230a:	28 2f       	mov	r18, r24
    230c:	30 e0       	ldi	r19, 0x00	; 0
    230e:	8b 81       	ldd	r24, Y+3	; 0x03
    2310:	9c 81       	ldd	r25, Y+4	; 0x04
    2312:	ba 01       	movw	r22, r20
    2314:	a9 01       	movw	r20, r18
    2316:	0e 94 16 33 	call	0x662c	; 0x662c <memcpy>
    }
}
    231a:	0f 90       	pop	r0
    231c:	0f 90       	pop	r0
    231e:	0f 90       	pop	r0
    2320:	0f 90       	pop	r0
    2322:	cf 91       	pop	r28
    2324:	df 91       	pop	r29
    2326:	08 95       	ret

00002328 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2328:	df 93       	push	r29
    232a:	cf 93       	push	r28
    232c:	00 d0       	rcall	.+0      	; 0x232e <prvUnlockQueue+0x6>
    232e:	00 d0       	rcall	.+0      	; 0x2330 <prvUnlockQueue+0x8>
    2330:	cd b7       	in	r28, 0x3d	; 61
    2332:	de b7       	in	r29, 0x3e	; 62
    2334:	9c 83       	std	Y+4, r25	; 0x04
    2336:	8b 83       	std	Y+3, r24	; 0x03

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    2338:	0f b6       	in	r0, 0x3f	; 63
    233a:	f8 94       	cli
    233c:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    233e:	eb 81       	ldd	r30, Y+3	; 0x03
    2340:	fc 81       	ldd	r31, Y+4	; 0x04
    2342:	86 8d       	ldd	r24, Z+30	; 0x1e
    2344:	8a 83       	std	Y+2, r24	; 0x02
    2346:	11 c0       	rjmp	.+34     	; 0x236a <prvUnlockQueue+0x42>
                }
            #else /* configUSE_QUEUE_SETS */
                {
                    /* Tasks that are removed from the event list will get added to
                     * the pending ready list as the scheduler is still suspended. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2348:	eb 81       	ldd	r30, Y+3	; 0x03
    234a:	fc 81       	ldd	r31, Y+4	; 0x04
    234c:	81 89       	ldd	r24, Z+17	; 0x11
    234e:	88 23       	and	r24, r24
    2350:	79 f0       	breq	.+30     	; 0x2370 <prvUnlockQueue+0x48>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2352:	8b 81       	ldd	r24, Y+3	; 0x03
    2354:	9c 81       	ldd	r25, Y+4	; 0x04
    2356:	41 96       	adiw	r24, 0x11	; 17
    2358:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <xTaskRemoveFromEventList>
    235c:	88 23       	and	r24, r24
    235e:	11 f0       	breq	.+4      	; 0x2364 <prvUnlockQueue+0x3c>
                        {
                            /* The task waiting has a higher priority so record that
                             * a context switch is required. */
                            vTaskMissedYield();
    2360:	0e 94 54 1f 	call	0x3ea8	; 0x3ea8 <vTaskMissedYield>
                        break;
                    }
                }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    2364:	8a 81       	ldd	r24, Y+2	; 0x02
    2366:	81 50       	subi	r24, 0x01	; 1
    2368:	8a 83       	std	Y+2, r24	; 0x02
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    236a:	8a 81       	ldd	r24, Y+2	; 0x02
    236c:	18 16       	cp	r1, r24
    236e:	64 f3       	brlt	.-40     	; 0x2348 <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    2370:	eb 81       	ldd	r30, Y+3	; 0x03
    2372:	fc 81       	ldd	r31, Y+4	; 0x04
    2374:	8f ef       	ldi	r24, 0xFF	; 255
    2376:	86 8f       	std	Z+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    2378:	0f 90       	pop	r0
    237a:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    237c:	0f b6       	in	r0, 0x3f	; 63
    237e:	f8 94       	cli
    2380:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    2382:	eb 81       	ldd	r30, Y+3	; 0x03
    2384:	fc 81       	ldd	r31, Y+4	; 0x04
    2386:	85 8d       	ldd	r24, Z+29	; 0x1d
    2388:	89 83       	std	Y+1, r24	; 0x01
    238a:	11 c0       	rjmp	.+34     	; 0x23ae <prvUnlockQueue+0x86>

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    238c:	eb 81       	ldd	r30, Y+3	; 0x03
    238e:	fc 81       	ldd	r31, Y+4	; 0x04
    2390:	80 85       	ldd	r24, Z+8	; 0x08
    2392:	88 23       	and	r24, r24
    2394:	79 f0       	breq	.+30     	; 0x23b4 <prvUnlockQueue+0x8c>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2396:	8b 81       	ldd	r24, Y+3	; 0x03
    2398:	9c 81       	ldd	r25, Y+4	; 0x04
    239a:	08 96       	adiw	r24, 0x08	; 8
    239c:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <xTaskRemoveFromEventList>
    23a0:	88 23       	and	r24, r24
    23a2:	11 f0       	breq	.+4      	; 0x23a8 <prvUnlockQueue+0x80>
                {
                    vTaskMissedYield();
    23a4:	0e 94 54 1f 	call	0x3ea8	; 0x3ea8 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    23a8:	89 81       	ldd	r24, Y+1	; 0x01
    23aa:	81 50       	subi	r24, 0x01	; 1
    23ac:	89 83       	std	Y+1, r24	; 0x01
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    23ae:	89 81       	ldd	r24, Y+1	; 0x01
    23b0:	18 16       	cp	r1, r24
    23b2:	64 f3       	brlt	.-40     	; 0x238c <prvUnlockQueue+0x64>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    23b4:	eb 81       	ldd	r30, Y+3	; 0x03
    23b6:	fc 81       	ldd	r31, Y+4	; 0x04
    23b8:	8f ef       	ldi	r24, 0xFF	; 255
    23ba:	85 8f       	std	Z+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    23bc:	0f 90       	pop	r0
    23be:	0f be       	out	0x3f, r0	; 63
}
    23c0:	0f 90       	pop	r0
    23c2:	0f 90       	pop	r0
    23c4:	0f 90       	pop	r0
    23c6:	0f 90       	pop	r0
    23c8:	cf 91       	pop	r28
    23ca:	df 91       	pop	r29
    23cc:	08 95       	ret

000023ce <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    23ce:	df 93       	push	r29
    23d0:	cf 93       	push	r28
    23d2:	00 d0       	rcall	.+0      	; 0x23d4 <prvIsQueueEmpty+0x6>
    23d4:	0f 92       	push	r0
    23d6:	cd b7       	in	r28, 0x3d	; 61
    23d8:	de b7       	in	r29, 0x3e	; 62
    23da:	9b 83       	std	Y+3, r25	; 0x03
    23dc:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    23de:	0f b6       	in	r0, 0x3f	; 63
    23e0:	f8 94       	cli
    23e2:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    23e4:	ea 81       	ldd	r30, Y+2	; 0x02
    23e6:	fb 81       	ldd	r31, Y+3	; 0x03
    23e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    23ea:	88 23       	and	r24, r24
    23ec:	19 f4       	brne	.+6      	; 0x23f4 <prvIsQueueEmpty+0x26>
        {
            xReturn = pdTRUE;
    23ee:	81 e0       	ldi	r24, 0x01	; 1
    23f0:	89 83       	std	Y+1, r24	; 0x01
    23f2:	01 c0       	rjmp	.+2      	; 0x23f6 <prvIsQueueEmpty+0x28>
        }
        else
        {
            xReturn = pdFALSE;
    23f4:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    23f6:	0f 90       	pop	r0
    23f8:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    23fa:	89 81       	ldd	r24, Y+1	; 0x01
}
    23fc:	0f 90       	pop	r0
    23fe:	0f 90       	pop	r0
    2400:	0f 90       	pop	r0
    2402:	cf 91       	pop	r28
    2404:	df 91       	pop	r29
    2406:	08 95       	ret

00002408 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2408:	df 93       	push	r29
    240a:	cf 93       	push	r28
    240c:	00 d0       	rcall	.+0      	; 0x240e <xQueueIsQueueEmptyFromISR+0x6>
    240e:	00 d0       	rcall	.+0      	; 0x2410 <xQueueIsQueueEmptyFromISR+0x8>
    2410:	0f 92       	push	r0
    2412:	cd b7       	in	r28, 0x3d	; 61
    2414:	de b7       	in	r29, 0x3e	; 62
    2416:	9d 83       	std	Y+5, r25	; 0x05
    2418:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    241a:	8c 81       	ldd	r24, Y+4	; 0x04
    241c:	9d 81       	ldd	r25, Y+5	; 0x05
    241e:	9a 83       	std	Y+2, r25	; 0x02
    2420:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2422:	e9 81       	ldd	r30, Y+1	; 0x01
    2424:	fa 81       	ldd	r31, Y+2	; 0x02
    2426:	82 8d       	ldd	r24, Z+26	; 0x1a
    2428:	88 23       	and	r24, r24
    242a:	19 f4       	brne	.+6      	; 0x2432 <xQueueIsQueueEmptyFromISR+0x2a>
    {
        xReturn = pdTRUE;
    242c:	81 e0       	ldi	r24, 0x01	; 1
    242e:	8b 83       	std	Y+3, r24	; 0x03
    2430:	01 c0       	rjmp	.+2      	; 0x2434 <xQueueIsQueueEmptyFromISR+0x2c>
    }
    else
    {
        xReturn = pdFALSE;
    2432:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    2434:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2436:	0f 90       	pop	r0
    2438:	0f 90       	pop	r0
    243a:	0f 90       	pop	r0
    243c:	0f 90       	pop	r0
    243e:	0f 90       	pop	r0
    2440:	cf 91       	pop	r28
    2442:	df 91       	pop	r29
    2444:	08 95       	ret

00002446 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    2446:	df 93       	push	r29
    2448:	cf 93       	push	r28
    244a:	00 d0       	rcall	.+0      	; 0x244c <prvIsQueueFull+0x6>
    244c:	0f 92       	push	r0
    244e:	cd b7       	in	r28, 0x3d	; 61
    2450:	de b7       	in	r29, 0x3e	; 62
    2452:	9b 83       	std	Y+3, r25	; 0x03
    2454:	8a 83       	std	Y+2, r24	; 0x02
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2456:	0f b6       	in	r0, 0x3f	; 63
    2458:	f8 94       	cli
    245a:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    245c:	ea 81       	ldd	r30, Y+2	; 0x02
    245e:	fb 81       	ldd	r31, Y+3	; 0x03
    2460:	92 8d       	ldd	r25, Z+26	; 0x1a
    2462:	ea 81       	ldd	r30, Y+2	; 0x02
    2464:	fb 81       	ldd	r31, Y+3	; 0x03
    2466:	83 8d       	ldd	r24, Z+27	; 0x1b
    2468:	98 17       	cp	r25, r24
    246a:	19 f4       	brne	.+6      	; 0x2472 <prvIsQueueFull+0x2c>
        {
            xReturn = pdTRUE;
    246c:	81 e0       	ldi	r24, 0x01	; 1
    246e:	89 83       	std	Y+1, r24	; 0x01
    2470:	01 c0       	rjmp	.+2      	; 0x2474 <prvIsQueueFull+0x2e>
        }
        else
        {
            xReturn = pdFALSE;
    2472:	19 82       	std	Y+1, r1	; 0x01
        }
    }
    taskEXIT_CRITICAL();
    2474:	0f 90       	pop	r0
    2476:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    2478:	89 81       	ldd	r24, Y+1	; 0x01
}
    247a:	0f 90       	pop	r0
    247c:	0f 90       	pop	r0
    247e:	0f 90       	pop	r0
    2480:	cf 91       	pop	r28
    2482:	df 91       	pop	r29
    2484:	08 95       	ret

00002486 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2486:	df 93       	push	r29
    2488:	cf 93       	push	r28
    248a:	00 d0       	rcall	.+0      	; 0x248c <xQueueIsQueueFullFromISR+0x6>
    248c:	00 d0       	rcall	.+0      	; 0x248e <xQueueIsQueueFullFromISR+0x8>
    248e:	0f 92       	push	r0
    2490:	cd b7       	in	r28, 0x3d	; 61
    2492:	de b7       	in	r29, 0x3e	; 62
    2494:	9d 83       	std	Y+5, r25	; 0x05
    2496:	8c 83       	std	Y+4, r24	; 0x04
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;
    2498:	8c 81       	ldd	r24, Y+4	; 0x04
    249a:	9d 81       	ldd	r25, Y+5	; 0x05
    249c:	9a 83       	std	Y+2, r25	; 0x02
    249e:	89 83       	std	Y+1, r24	; 0x01

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    24a0:	e9 81       	ldd	r30, Y+1	; 0x01
    24a2:	fa 81       	ldd	r31, Y+2	; 0x02
    24a4:	92 8d       	ldd	r25, Z+26	; 0x1a
    24a6:	e9 81       	ldd	r30, Y+1	; 0x01
    24a8:	fa 81       	ldd	r31, Y+2	; 0x02
    24aa:	83 8d       	ldd	r24, Z+27	; 0x1b
    24ac:	98 17       	cp	r25, r24
    24ae:	19 f4       	brne	.+6      	; 0x24b6 <xQueueIsQueueFullFromISR+0x30>
    {
        xReturn = pdTRUE;
    24b0:	81 e0       	ldi	r24, 0x01	; 1
    24b2:	8b 83       	std	Y+3, r24	; 0x03
    24b4:	01 c0       	rjmp	.+2      	; 0x24b8 <xQueueIsQueueFullFromISR+0x32>
    }
    else
    {
        xReturn = pdFALSE;
    24b6:	1b 82       	std	Y+3, r1	; 0x03
    }

    return xReturn;
    24b8:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    24ba:	0f 90       	pop	r0
    24bc:	0f 90       	pop	r0
    24be:	0f 90       	pop	r0
    24c0:	0f 90       	pop	r0
    24c2:	0f 90       	pop	r0
    24c4:	cf 91       	pop	r28
    24c6:	df 91       	pop	r29
    24c8:	08 95       	ret

000024ca <xQueueCRSend>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSend( QueueHandle_t xQueue,
                             const void * pvItemToQueue,
                             TickType_t xTicksToWait )
    {
    24ca:	df 93       	push	r29
    24cc:	cf 93       	push	r28
    24ce:	cd b7       	in	r28, 0x3d	; 61
    24d0:	de b7       	in	r29, 0x3e	; 62
    24d2:	2a 97       	sbiw	r28, 0x0a	; 10
    24d4:	0f b6       	in	r0, 0x3f	; 63
    24d6:	f8 94       	cli
    24d8:	de bf       	out	0x3e, r29	; 62
    24da:	0f be       	out	0x3f, r0	; 63
    24dc:	cd bf       	out	0x3d, r28	; 61
    24de:	9d 83       	std	Y+5, r25	; 0x05
    24e0:	8c 83       	std	Y+4, r24	; 0x04
    24e2:	7f 83       	std	Y+7, r23	; 0x07
    24e4:	6e 83       	std	Y+6, r22	; 0x06
    24e6:	59 87       	std	Y+9, r21	; 0x09
    24e8:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    24ea:	8c 81       	ldd	r24, Y+4	; 0x04
    24ec:	9d 81       	ldd	r25, Y+5	; 0x05
    24ee:	9a 83       	std	Y+2, r25	; 0x02
    24f0:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already full we may have to block.  A critical section
         * is required to prevent an interrupt removing something from the queue
         * between the check to see if the queue is full and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    24f2:	f8 94       	cli
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    24f4:	89 81       	ldd	r24, Y+1	; 0x01
    24f6:	9a 81       	ldd	r25, Y+2	; 0x02
    24f8:	0e 94 23 12 	call	0x2446	; 0x2446 <prvIsQueueFull>
    24fc:	88 23       	and	r24, r24
    24fe:	a9 f0       	breq	.+42     	; 0x252a <xQueueCRSend+0x60>
            {
                /* The queue is full - do we want to block or just leave without
                 * posting? */
                if( xTicksToWait > ( TickType_t ) 0 )
    2500:	88 85       	ldd	r24, Y+8	; 0x08
    2502:	99 85       	ldd	r25, Y+9	; 0x09
    2504:	00 97       	sbiw	r24, 0x00	; 0
    2506:	71 f0       	breq	.+28     	; 0x2524 <xQueueCRSend+0x5a>
                {
                    /* As this is called from a coroutine we cannot block directly, but
                     * return indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    2508:	89 81       	ldd	r24, Y+1	; 0x01
    250a:	9a 81       	ldd	r25, Y+2	; 0x02
    250c:	9c 01       	movw	r18, r24
    250e:	28 5f       	subi	r18, 0xF8	; 248
    2510:	3f 4f       	sbci	r19, 0xFF	; 255
    2512:	88 85       	ldd	r24, Y+8	; 0x08
    2514:	99 85       	ldd	r25, Y+9	; 0x09
    2516:	b9 01       	movw	r22, r18
    2518:	0e 94 31 04 	call	0x862	; 0x862 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    251c:	78 94       	sei
                    return errQUEUE_BLOCKED;
    251e:	8c ef       	ldi	r24, 0xFC	; 252
    2520:	8a 87       	std	Y+10, r24	; 0x0a
    2522:	2a c0       	rjmp	.+84     	; 0x2578 <xQueueCRSend+0xae>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    2524:	78 94       	sei
                    return errQUEUE_FULL;
    2526:	1a 86       	std	Y+10, r1	; 0x0a
    2528:	27 c0       	rjmp	.+78     	; 0x2578 <xQueueCRSend+0xae>
                }
            }
        }
        portENABLE_INTERRUPTS();
    252a:	78 94       	sei

        portDISABLE_INTERRUPTS();
    252c:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    252e:	e9 81       	ldd	r30, Y+1	; 0x01
    2530:	fa 81       	ldd	r31, Y+2	; 0x02
    2532:	92 8d       	ldd	r25, Z+26	; 0x1a
    2534:	e9 81       	ldd	r30, Y+1	; 0x01
    2536:	fa 81       	ldd	r31, Y+2	; 0x02
    2538:	83 8d       	ldd	r24, Z+27	; 0x1b
    253a:	98 17       	cp	r25, r24
    253c:	c8 f4       	brcc	.+50     	; 0x2570 <xQueueCRSend+0xa6>
            {
                /* There is room in the queue, copy the data into the queue. */
                prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    253e:	89 81       	ldd	r24, Y+1	; 0x01
    2540:	9a 81       	ldd	r25, Y+2	; 0x02
    2542:	2e 81       	ldd	r18, Y+6	; 0x06
    2544:	3f 81       	ldd	r19, Y+7	; 0x07
    2546:	b9 01       	movw	r22, r18
    2548:	40 e0       	ldi	r20, 0x00	; 0
    254a:	0e 94 a7 10 	call	0x214e	; 0x214e <prvCopyDataToQueue>
                xReturn = pdPASS;
    254e:	81 e0       	ldi	r24, 0x01	; 1
    2550:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for data to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2552:	e9 81       	ldd	r30, Y+1	; 0x01
    2554:	fa 81       	ldd	r31, Y+2	; 0x02
    2556:	81 89       	ldd	r24, Z+17	; 0x11
    2558:	88 23       	and	r24, r24
    255a:	59 f0       	breq	.+22     	; 0x2572 <xQueueCRSend+0xa8>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    255c:	89 81       	ldd	r24, Y+1	; 0x01
    255e:	9a 81       	ldd	r25, Y+2	; 0x02
    2560:	41 96       	adiw	r24, 0x11	; 17
    2562:	0e 94 44 06 	call	0xc88	; 0xc88 <xCoRoutineRemoveFromEventList>
    2566:	88 23       	and	r24, r24
    2568:	21 f0       	breq	.+8      	; 0x2572 <xQueueCRSend+0xa8>
                    {
                        /* The co-routine waiting has a higher priority so record
                         * that a yield might be appropriate. */
                        xReturn = errQUEUE_YIELD;
    256a:	8b ef       	ldi	r24, 0xFB	; 251
    256c:	8b 83       	std	Y+3, r24	; 0x03
    256e:	01 c0       	rjmp	.+2      	; 0x2572 <xQueueCRSend+0xa8>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = errQUEUE_FULL;
    2570:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    2572:	78 94       	sei

        return xReturn;
    2574:	8b 81       	ldd	r24, Y+3	; 0x03
    2576:	8a 87       	std	Y+10, r24	; 0x0a
    2578:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    257a:	2a 96       	adiw	r28, 0x0a	; 10
    257c:	0f b6       	in	r0, 0x3f	; 63
    257e:	f8 94       	cli
    2580:	de bf       	out	0x3e, r29	; 62
    2582:	0f be       	out	0x3f, r0	; 63
    2584:	cd bf       	out	0x3d, r28	; 61
    2586:	cf 91       	pop	r28
    2588:	df 91       	pop	r29
    258a:	08 95       	ret

0000258c <xQueueCRReceive>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceive( QueueHandle_t xQueue,
                                void * pvBuffer,
                                TickType_t xTicksToWait )
    {
    258c:	df 93       	push	r29
    258e:	cf 93       	push	r28
    2590:	cd b7       	in	r28, 0x3d	; 61
    2592:	de b7       	in	r29, 0x3e	; 62
    2594:	2a 97       	sbiw	r28, 0x0a	; 10
    2596:	0f b6       	in	r0, 0x3f	; 63
    2598:	f8 94       	cli
    259a:	de bf       	out	0x3e, r29	; 62
    259c:	0f be       	out	0x3f, r0	; 63
    259e:	cd bf       	out	0x3d, r28	; 61
    25a0:	9d 83       	std	Y+5, r25	; 0x05
    25a2:	8c 83       	std	Y+4, r24	; 0x04
    25a4:	7f 83       	std	Y+7, r23	; 0x07
    25a6:	6e 83       	std	Y+6, r22	; 0x06
    25a8:	59 87       	std	Y+9, r21	; 0x09
    25aa:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    25ac:	8c 81       	ldd	r24, Y+4	; 0x04
    25ae:	9d 81       	ldd	r25, Y+5	; 0x05
    25b0:	9a 83       	std	Y+2, r25	; 0x02
    25b2:	89 83       	std	Y+1, r24	; 0x01

        /* If the queue is already empty we may have to block.  A critical section
         * is required to prevent an interrupt adding something to the queue
         * between the check to see if the queue is empty and blocking on the queue. */
        portDISABLE_INTERRUPTS();
    25b4:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    25b6:	e9 81       	ldd	r30, Y+1	; 0x01
    25b8:	fa 81       	ldd	r31, Y+2	; 0x02
    25ba:	82 8d       	ldd	r24, Z+26	; 0x1a
    25bc:	88 23       	and	r24, r24
    25be:	a9 f4       	brne	.+42     	; 0x25ea <xQueueCRReceive+0x5e>
            {
                /* There are no messages in the queue, do we want to block or just
                 * leave with nothing? */
                if( xTicksToWait > ( TickType_t ) 0 )
    25c0:	88 85       	ldd	r24, Y+8	; 0x08
    25c2:	99 85       	ldd	r25, Y+9	; 0x09
    25c4:	00 97       	sbiw	r24, 0x00	; 0
    25c6:	71 f0       	breq	.+28     	; 0x25e4 <xQueueCRReceive+0x58>
                {
                    /* As this is a co-routine we cannot block directly, but return
                     * indicating that we need to block. */
                    vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    25c8:	89 81       	ldd	r24, Y+1	; 0x01
    25ca:	9a 81       	ldd	r25, Y+2	; 0x02
    25cc:	9c 01       	movw	r18, r24
    25ce:	2f 5e       	subi	r18, 0xEF	; 239
    25d0:	3f 4f       	sbci	r19, 0xFF	; 255
    25d2:	88 85       	ldd	r24, Y+8	; 0x08
    25d4:	99 85       	ldd	r25, Y+9	; 0x09
    25d6:	b9 01       	movw	r22, r18
    25d8:	0e 94 31 04 	call	0x862	; 0x862 <vCoRoutineAddToDelayedList>
                    portENABLE_INTERRUPTS();
    25dc:	78 94       	sei
                    return errQUEUE_BLOCKED;
    25de:	8c ef       	ldi	r24, 0xFC	; 252
    25e0:	8a 87       	std	Y+10, r24	; 0x0a
    25e2:	58 c0       	rjmp	.+176    	; 0x2694 <xQueueCRReceive+0x108>
                }
                else
                {
                    portENABLE_INTERRUPTS();
    25e4:	78 94       	sei
                    return errQUEUE_FULL;
    25e6:	1a 86       	std	Y+10, r1	; 0x0a
    25e8:	55 c0       	rjmp	.+170    	; 0x2694 <xQueueCRReceive+0x108>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        portENABLE_INTERRUPTS();
    25ea:	78 94       	sei

        portDISABLE_INTERRUPTS();
    25ec:	f8 94       	cli
        {
            if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    25ee:	e9 81       	ldd	r30, Y+1	; 0x01
    25f0:	fa 81       	ldd	r31, Y+2	; 0x02
    25f2:	82 8d       	ldd	r24, Z+26	; 0x1a
    25f4:	88 23       	and	r24, r24
    25f6:	09 f4       	brne	.+2      	; 0x25fa <xQueueCRReceive+0x6e>
    25f8:	49 c0       	rjmp	.+146    	; 0x268c <xQueueCRReceive+0x100>
            {
                /* Data is available from the queue. */
                pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    25fa:	e9 81       	ldd	r30, Y+1	; 0x01
    25fc:	fa 81       	ldd	r31, Y+2	; 0x02
    25fe:	26 81       	ldd	r18, Z+6	; 0x06
    2600:	37 81       	ldd	r19, Z+7	; 0x07
    2602:	e9 81       	ldd	r30, Y+1	; 0x01
    2604:	fa 81       	ldd	r31, Y+2	; 0x02
    2606:	84 8d       	ldd	r24, Z+28	; 0x1c
    2608:	88 2f       	mov	r24, r24
    260a:	90 e0       	ldi	r25, 0x00	; 0
    260c:	82 0f       	add	r24, r18
    260e:	93 1f       	adc	r25, r19
    2610:	e9 81       	ldd	r30, Y+1	; 0x01
    2612:	fa 81       	ldd	r31, Y+2	; 0x02
    2614:	97 83       	std	Z+7, r25	; 0x07
    2616:	86 83       	std	Z+6, r24	; 0x06

                if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    2618:	e9 81       	ldd	r30, Y+1	; 0x01
    261a:	fa 81       	ldd	r31, Y+2	; 0x02
    261c:	26 81       	ldd	r18, Z+6	; 0x06
    261e:	37 81       	ldd	r19, Z+7	; 0x07
    2620:	e9 81       	ldd	r30, Y+1	; 0x01
    2622:	fa 81       	ldd	r31, Y+2	; 0x02
    2624:	84 81       	ldd	r24, Z+4	; 0x04
    2626:	95 81       	ldd	r25, Z+5	; 0x05
    2628:	28 17       	cp	r18, r24
    262a:	39 07       	cpc	r19, r25
    262c:	40 f0       	brcs	.+16     	; 0x263e <xQueueCRReceive+0xb2>
                {
                    pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    262e:	e9 81       	ldd	r30, Y+1	; 0x01
    2630:	fa 81       	ldd	r31, Y+2	; 0x02
    2632:	80 81       	ld	r24, Z
    2634:	91 81       	ldd	r25, Z+1	; 0x01
    2636:	e9 81       	ldd	r30, Y+1	; 0x01
    2638:	fa 81       	ldd	r31, Y+2	; 0x02
    263a:	97 83       	std	Z+7, r25	; 0x07
    263c:	86 83       	std	Z+6, r24	; 0x06
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --( pxQueue->uxMessagesWaiting );
    263e:	e9 81       	ldd	r30, Y+1	; 0x01
    2640:	fa 81       	ldd	r31, Y+2	; 0x02
    2642:	82 8d       	ldd	r24, Z+26	; 0x1a
    2644:	81 50       	subi	r24, 0x01	; 1
    2646:	e9 81       	ldd	r30, Y+1	; 0x01
    2648:	fa 81       	ldd	r31, Y+2	; 0x02
    264a:	82 8f       	std	Z+26, r24	; 0x1a
                ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    264c:	e9 81       	ldd	r30, Y+1	; 0x01
    264e:	fa 81       	ldd	r31, Y+2	; 0x02
    2650:	46 81       	ldd	r20, Z+6	; 0x06
    2652:	57 81       	ldd	r21, Z+7	; 0x07
    2654:	e9 81       	ldd	r30, Y+1	; 0x01
    2656:	fa 81       	ldd	r31, Y+2	; 0x02
    2658:	84 8d       	ldd	r24, Z+28	; 0x1c
    265a:	28 2f       	mov	r18, r24
    265c:	30 e0       	ldi	r19, 0x00	; 0
    265e:	8e 81       	ldd	r24, Y+6	; 0x06
    2660:	9f 81       	ldd	r25, Y+7	; 0x07
    2662:	ba 01       	movw	r22, r20
    2664:	a9 01       	movw	r20, r18
    2666:	0e 94 16 33 	call	0x662c	; 0x662c <memcpy>

                xReturn = pdPASS;
    266a:	81 e0       	ldi	r24, 0x01	; 1
    266c:	8b 83       	std	Y+3, r24	; 0x03

                /* Were any co-routines waiting for space to become available? */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    266e:	e9 81       	ldd	r30, Y+1	; 0x01
    2670:	fa 81       	ldd	r31, Y+2	; 0x02
    2672:	80 85       	ldd	r24, Z+8	; 0x08
    2674:	88 23       	and	r24, r24
    2676:	59 f0       	breq	.+22     	; 0x268e <xQueueCRReceive+0x102>
                {
                    /* In this instance the co-routine could be placed directly
                     * into the ready list as we are within a critical section.
                     * Instead the same pending ready list mechanism is used as if
                     * the event were caused from within an interrupt. */
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2678:	89 81       	ldd	r24, Y+1	; 0x01
    267a:	9a 81       	ldd	r25, Y+2	; 0x02
    267c:	08 96       	adiw	r24, 0x08	; 8
    267e:	0e 94 44 06 	call	0xc88	; 0xc88 <xCoRoutineRemoveFromEventList>
    2682:	88 23       	and	r24, r24
    2684:	21 f0       	breq	.+8      	; 0x268e <xQueueCRReceive+0x102>
                    {
                        xReturn = errQUEUE_YIELD;
    2686:	8b ef       	ldi	r24, 0xFB	; 251
    2688:	8b 83       	std	Y+3, r24	; 0x03
    268a:	01 c0       	rjmp	.+2      	; 0x268e <xQueueCRReceive+0x102>
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else
            {
                xReturn = pdFAIL;
    268c:	1b 82       	std	Y+3, r1	; 0x03
            }
        }
        portENABLE_INTERRUPTS();
    268e:	78 94       	sei

        return xReturn;
    2690:	8b 81       	ldd	r24, Y+3	; 0x03
    2692:	8a 87       	std	Y+10, r24	; 0x0a
    2694:	8a 85       	ldd	r24, Y+10	; 0x0a
    }
    2696:	2a 96       	adiw	r28, 0x0a	; 10
    2698:	0f b6       	in	r0, 0x3f	; 63
    269a:	f8 94       	cli
    269c:	de bf       	out	0x3e, r29	; 62
    269e:	0f be       	out	0x3f, r0	; 63
    26a0:	cd bf       	out	0x3d, r28	; 61
    26a2:	cf 91       	pop	r28
    26a4:	df 91       	pop	r29
    26a6:	08 95       	ret

000026a8 <xQueueCRSendFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue,
                                    const void * pvItemToQueue,
                                    BaseType_t xCoRoutinePreviouslyWoken )
    {
    26a8:	df 93       	push	r29
    26aa:	cf 93       	push	r28
    26ac:	cd b7       	in	r28, 0x3d	; 61
    26ae:	de b7       	in	r29, 0x3e	; 62
    26b0:	28 97       	sbiw	r28, 0x08	; 8
    26b2:	0f b6       	in	r0, 0x3f	; 63
    26b4:	f8 94       	cli
    26b6:	de bf       	out	0x3e, r29	; 62
    26b8:	0f be       	out	0x3f, r0	; 63
    26ba:	cd bf       	out	0x3d, r28	; 61
    26bc:	9c 83       	std	Y+4, r25	; 0x04
    26be:	8b 83       	std	Y+3, r24	; 0x03
    26c0:	7e 83       	std	Y+6, r23	; 0x06
    26c2:	6d 83       	std	Y+5, r22	; 0x05
    26c4:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    26c6:	8b 81       	ldd	r24, Y+3	; 0x03
    26c8:	9c 81       	ldd	r25, Y+4	; 0x04
    26ca:	9a 83       	std	Y+2, r25	; 0x02
    26cc:	89 83       	std	Y+1, r24	; 0x01

        /* Cannot block within an ISR so if there is no space on the queue then
         * exit without doing anything. */
        if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    26ce:	e9 81       	ldd	r30, Y+1	; 0x01
    26d0:	fa 81       	ldd	r31, Y+2	; 0x02
    26d2:	92 8d       	ldd	r25, Z+26	; 0x1a
    26d4:	e9 81       	ldd	r30, Y+1	; 0x01
    26d6:	fa 81       	ldd	r31, Y+2	; 0x02
    26d8:	83 8d       	ldd	r24, Z+27	; 0x1b
    26da:	98 17       	cp	r25, r24
    26dc:	d0 f4       	brcc	.+52     	; 0x2712 <xQueueCRSendFromISR+0x6a>
        {
            prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    26de:	89 81       	ldd	r24, Y+1	; 0x01
    26e0:	9a 81       	ldd	r25, Y+2	; 0x02
    26e2:	2d 81       	ldd	r18, Y+5	; 0x05
    26e4:	3e 81       	ldd	r19, Y+6	; 0x06
    26e6:	b9 01       	movw	r22, r18
    26e8:	40 e0       	ldi	r20, 0x00	; 0
    26ea:	0e 94 a7 10 	call	0x214e	; 0x214e <prvCopyDataToQueue>

            /* We only want to wake one co-routine per ISR, so check that a
             * co-routine has not already been woken. */
            if( xCoRoutinePreviouslyWoken == pdFALSE )
    26ee:	8f 81       	ldd	r24, Y+7	; 0x07
    26f0:	88 23       	and	r24, r24
    26f2:	79 f4       	brne	.+30     	; 0x2712 <xQueueCRSendFromISR+0x6a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    26f4:	e9 81       	ldd	r30, Y+1	; 0x01
    26f6:	fa 81       	ldd	r31, Y+2	; 0x02
    26f8:	81 89       	ldd	r24, Z+17	; 0x11
    26fa:	88 23       	and	r24, r24
    26fc:	51 f0       	breq	.+20     	; 0x2712 <xQueueCRSendFromISR+0x6a>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    26fe:	89 81       	ldd	r24, Y+1	; 0x01
    2700:	9a 81       	ldd	r25, Y+2	; 0x02
    2702:	41 96       	adiw	r24, 0x11	; 17
    2704:	0e 94 44 06 	call	0xc88	; 0xc88 <xCoRoutineRemoveFromEventList>
    2708:	88 23       	and	r24, r24
    270a:	19 f0       	breq	.+6      	; 0x2712 <xQueueCRSendFromISR+0x6a>
                    {
                        return pdTRUE;
    270c:	81 e0       	ldi	r24, 0x01	; 1
    270e:	88 87       	std	Y+8, r24	; 0x08
    2710:	02 c0       	rjmp	.+4      	; 0x2716 <xQueueCRSendFromISR+0x6e>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xCoRoutinePreviouslyWoken;
    2712:	8f 81       	ldd	r24, Y+7	; 0x07
    2714:	88 87       	std	Y+8, r24	; 0x08
    2716:	88 85       	ldd	r24, Y+8	; 0x08
    }
    2718:	28 96       	adiw	r28, 0x08	; 8
    271a:	0f b6       	in	r0, 0x3f	; 63
    271c:	f8 94       	cli
    271e:	de bf       	out	0x3e, r29	; 62
    2720:	0f be       	out	0x3f, r0	; 63
    2722:	cd bf       	out	0x3d, r28	; 61
    2724:	cf 91       	pop	r28
    2726:	df 91       	pop	r29
    2728:	08 95       	ret

0000272a <xQueueCRReceiveFromISR>:
#if ( configUSE_CO_ROUTINES == 1 )

    BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue,
                                       void * pvBuffer,
                                       BaseType_t * pxCoRoutineWoken )
    {
    272a:	df 93       	push	r29
    272c:	cf 93       	push	r28
    272e:	cd b7       	in	r28, 0x3d	; 61
    2730:	de b7       	in	r29, 0x3e	; 62
    2732:	29 97       	sbiw	r28, 0x09	; 9
    2734:	0f b6       	in	r0, 0x3f	; 63
    2736:	f8 94       	cli
    2738:	de bf       	out	0x3e, r29	; 62
    273a:	0f be       	out	0x3f, r0	; 63
    273c:	cd bf       	out	0x3d, r28	; 61
    273e:	9d 83       	std	Y+5, r25	; 0x05
    2740:	8c 83       	std	Y+4, r24	; 0x04
    2742:	7f 83       	std	Y+7, r23	; 0x07
    2744:	6e 83       	std	Y+6, r22	; 0x06
    2746:	59 87       	std	Y+9, r21	; 0x09
    2748:	48 87       	std	Y+8, r20	; 0x08
        BaseType_t xReturn;
        Queue_t * const pxQueue = xQueue;
    274a:	8c 81       	ldd	r24, Y+4	; 0x04
    274c:	9d 81       	ldd	r25, Y+5	; 0x05
    274e:	9a 83       	std	Y+2, r25	; 0x02
    2750:	89 83       	std	Y+1, r24	; 0x01

        /* We cannot block from an ISR, so check there is data available. If
         * not then just leave without doing anything. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2752:	e9 81       	ldd	r30, Y+1	; 0x01
    2754:	fa 81       	ldd	r31, Y+2	; 0x02
    2756:	82 8d       	ldd	r24, Z+26	; 0x1a
    2758:	88 23       	and	r24, r24
    275a:	09 f4       	brne	.+2      	; 0x275e <xQueueCRReceiveFromISR+0x34>
    275c:	50 c0       	rjmp	.+160    	; 0x27fe <xQueueCRReceiveFromISR+0xd4>
        {
            /* Copy the data from the queue. */
            pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;
    275e:	e9 81       	ldd	r30, Y+1	; 0x01
    2760:	fa 81       	ldd	r31, Y+2	; 0x02
    2762:	26 81       	ldd	r18, Z+6	; 0x06
    2764:	37 81       	ldd	r19, Z+7	; 0x07
    2766:	e9 81       	ldd	r30, Y+1	; 0x01
    2768:	fa 81       	ldd	r31, Y+2	; 0x02
    276a:	84 8d       	ldd	r24, Z+28	; 0x1c
    276c:	88 2f       	mov	r24, r24
    276e:	90 e0       	ldi	r25, 0x00	; 0
    2770:	82 0f       	add	r24, r18
    2772:	93 1f       	adc	r25, r19
    2774:	e9 81       	ldd	r30, Y+1	; 0x01
    2776:	fa 81       	ldd	r31, Y+2	; 0x02
    2778:	97 83       	std	Z+7, r25	; 0x07
    277a:	86 83       	std	Z+6, r24	; 0x06

            if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail )
    277c:	e9 81       	ldd	r30, Y+1	; 0x01
    277e:	fa 81       	ldd	r31, Y+2	; 0x02
    2780:	26 81       	ldd	r18, Z+6	; 0x06
    2782:	37 81       	ldd	r19, Z+7	; 0x07
    2784:	e9 81       	ldd	r30, Y+1	; 0x01
    2786:	fa 81       	ldd	r31, Y+2	; 0x02
    2788:	84 81       	ldd	r24, Z+4	; 0x04
    278a:	95 81       	ldd	r25, Z+5	; 0x05
    278c:	28 17       	cp	r18, r24
    278e:	39 07       	cpc	r19, r25
    2790:	40 f0       	brcs	.+16     	; 0x27a2 <xQueueCRReceiveFromISR+0x78>
            {
                pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2792:	e9 81       	ldd	r30, Y+1	; 0x01
    2794:	fa 81       	ldd	r31, Y+2	; 0x02
    2796:	80 81       	ld	r24, Z
    2798:	91 81       	ldd	r25, Z+1	; 0x01
    279a:	e9 81       	ldd	r30, Y+1	; 0x01
    279c:	fa 81       	ldd	r31, Y+2	; 0x02
    279e:	97 83       	std	Z+7, r25	; 0x07
    27a0:	86 83       	std	Z+6, r24	; 0x06
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            --( pxQueue->uxMessagesWaiting );
    27a2:	e9 81       	ldd	r30, Y+1	; 0x01
    27a4:	fa 81       	ldd	r31, Y+2	; 0x02
    27a6:	82 8d       	ldd	r24, Z+26	; 0x1a
    27a8:	81 50       	subi	r24, 0x01	; 1
    27aa:	e9 81       	ldd	r30, Y+1	; 0x01
    27ac:	fa 81       	ldd	r31, Y+2	; 0x02
    27ae:	82 8f       	std	Z+26, r24	; 0x1a
            ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    27b0:	e9 81       	ldd	r30, Y+1	; 0x01
    27b2:	fa 81       	ldd	r31, Y+2	; 0x02
    27b4:	46 81       	ldd	r20, Z+6	; 0x06
    27b6:	57 81       	ldd	r21, Z+7	; 0x07
    27b8:	e9 81       	ldd	r30, Y+1	; 0x01
    27ba:	fa 81       	ldd	r31, Y+2	; 0x02
    27bc:	84 8d       	ldd	r24, Z+28	; 0x1c
    27be:	28 2f       	mov	r18, r24
    27c0:	30 e0       	ldi	r19, 0x00	; 0
    27c2:	8e 81       	ldd	r24, Y+6	; 0x06
    27c4:	9f 81       	ldd	r25, Y+7	; 0x07
    27c6:	ba 01       	movw	r22, r20
    27c8:	a9 01       	movw	r20, r18
    27ca:	0e 94 16 33 	call	0x662c	; 0x662c <memcpy>

            if( ( *pxCoRoutineWoken ) == pdFALSE )
    27ce:	e8 85       	ldd	r30, Y+8	; 0x08
    27d0:	f9 85       	ldd	r31, Y+9	; 0x09
    27d2:	80 81       	ld	r24, Z
    27d4:	88 23       	and	r24, r24
    27d6:	81 f4       	brne	.+32     	; 0x27f8 <xQueueCRReceiveFromISR+0xce>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    27d8:	e9 81       	ldd	r30, Y+1	; 0x01
    27da:	fa 81       	ldd	r31, Y+2	; 0x02
    27dc:	80 85       	ldd	r24, Z+8	; 0x08
    27de:	88 23       	and	r24, r24
    27e0:	59 f0       	breq	.+22     	; 0x27f8 <xQueueCRReceiveFromISR+0xce>
                {
                    if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    27e2:	89 81       	ldd	r24, Y+1	; 0x01
    27e4:	9a 81       	ldd	r25, Y+2	; 0x02
    27e6:	08 96       	adiw	r24, 0x08	; 8
    27e8:	0e 94 44 06 	call	0xc88	; 0xc88 <xCoRoutineRemoveFromEventList>
    27ec:	88 23       	and	r24, r24
    27ee:	21 f0       	breq	.+8      	; 0x27f8 <xQueueCRReceiveFromISR+0xce>
                    {
                        *pxCoRoutineWoken = pdTRUE;
    27f0:	e8 85       	ldd	r30, Y+8	; 0x08
    27f2:	f9 85       	ldd	r31, Y+9	; 0x09
    27f4:	81 e0       	ldi	r24, 0x01	; 1
    27f6:	80 83       	st	Z, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            xReturn = pdPASS;
    27f8:	81 e0       	ldi	r24, 0x01	; 1
    27fa:	8b 83       	std	Y+3, r24	; 0x03
    27fc:	01 c0       	rjmp	.+2      	; 0x2800 <xQueueCRReceiveFromISR+0xd6>
        }
        else
        {
            xReturn = pdFAIL;
    27fe:	1b 82       	std	Y+3, r1	; 0x03
        }

        return xReturn;
    2800:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    2802:	29 96       	adiw	r28, 0x09	; 9
    2804:	0f b6       	in	r0, 0x3f	; 63
    2806:	f8 94       	cli
    2808:	de bf       	out	0x3e, r29	; 62
    280a:	0f be       	out	0x3f, r0	; 63
    280c:	cd bf       	out	0x3d, r28	; 61
    280e:	cf 91       	pop	r28
    2810:	df 91       	pop	r29
    2812:	08 95       	ret

00002814 <vQueueWaitForMessageRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vQueueWaitForMessageRestricted( QueueHandle_t xQueue,
                                         TickType_t xTicksToWait,
                                         const BaseType_t xWaitIndefinitely )
    {
    2814:	df 93       	push	r29
    2816:	cf 93       	push	r28
    2818:	cd b7       	in	r28, 0x3d	; 61
    281a:	de b7       	in	r29, 0x3e	; 62
    281c:	27 97       	sbiw	r28, 0x07	; 7
    281e:	0f b6       	in	r0, 0x3f	; 63
    2820:	f8 94       	cli
    2822:	de bf       	out	0x3e, r29	; 62
    2824:	0f be       	out	0x3f, r0	; 63
    2826:	cd bf       	out	0x3d, r28	; 61
    2828:	9c 83       	std	Y+4, r25	; 0x04
    282a:	8b 83       	std	Y+3, r24	; 0x03
    282c:	7e 83       	std	Y+6, r23	; 0x06
    282e:	6d 83       	std	Y+5, r22	; 0x05
    2830:	4f 83       	std	Y+7, r20	; 0x07
        Queue_t * const pxQueue = xQueue;
    2832:	8b 81       	ldd	r24, Y+3	; 0x03
    2834:	9c 81       	ldd	r25, Y+4	; 0x04
    2836:	9a 83       	std	Y+2, r25	; 0x02
    2838:	89 83       	std	Y+1, r24	; 0x01
         *  will not actually cause the task to block, just place it on a blocked
         *  list.  It will not block until the scheduler is unlocked - at which
         *  time a yield will be performed.  If an item is added to the queue while
         *  the queue is locked, and the calling task blocks on the queue, then the
         *  calling task will be immediately unblocked when the queue is unlocked. */
        prvLockQueue( pxQueue );
    283a:	0f b6       	in	r0, 0x3f	; 63
    283c:	f8 94       	cli
    283e:	0f 92       	push	r0
    2840:	e9 81       	ldd	r30, Y+1	; 0x01
    2842:	fa 81       	ldd	r31, Y+2	; 0x02
    2844:	85 8d       	ldd	r24, Z+29	; 0x1d
    2846:	8f 3f       	cpi	r24, 0xFF	; 255
    2848:	19 f4       	brne	.+6      	; 0x2850 <vQueueWaitForMessageRestricted+0x3c>
    284a:	e9 81       	ldd	r30, Y+1	; 0x01
    284c:	fa 81       	ldd	r31, Y+2	; 0x02
    284e:	15 8e       	std	Z+29, r1	; 0x1d
    2850:	e9 81       	ldd	r30, Y+1	; 0x01
    2852:	fa 81       	ldd	r31, Y+2	; 0x02
    2854:	86 8d       	ldd	r24, Z+30	; 0x1e
    2856:	8f 3f       	cpi	r24, 0xFF	; 255
    2858:	19 f4       	brne	.+6      	; 0x2860 <vQueueWaitForMessageRestricted+0x4c>
    285a:	e9 81       	ldd	r30, Y+1	; 0x01
    285c:	fa 81       	ldd	r31, Y+2	; 0x02
    285e:	16 8e       	std	Z+30, r1	; 0x1e
    2860:	0f 90       	pop	r0
    2862:	0f be       	out	0x3f, r0	; 63

        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    2864:	e9 81       	ldd	r30, Y+1	; 0x01
    2866:	fa 81       	ldd	r31, Y+2	; 0x02
    2868:	82 8d       	ldd	r24, Z+26	; 0x1a
    286a:	88 23       	and	r24, r24
    286c:	49 f4       	brne	.+18     	; 0x2880 <vQueueWaitForMessageRestricted+0x6c>
        {
            /* There is nothing in the queue, block for the specified period. */
            vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    286e:	89 81       	ldd	r24, Y+1	; 0x01
    2870:	9a 81       	ldd	r25, Y+2	; 0x02
    2872:	41 96       	adiw	r24, 0x11	; 17
    2874:	2d 81       	ldd	r18, Y+5	; 0x05
    2876:	3e 81       	ldd	r19, Y+6	; 0x06
    2878:	b9 01       	movw	r22, r18
    287a:	4f 81       	ldd	r20, Y+7	; 0x07
    287c:	0e 94 02 1c 	call	0x3804	; 0x3804 <vTaskPlaceOnEventListRestricted>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        prvUnlockQueue( pxQueue );
    2880:	89 81       	ldd	r24, Y+1	; 0x01
    2882:	9a 81       	ldd	r25, Y+2	; 0x02
    2884:	0e 94 94 11 	call	0x2328	; 0x2328 <prvUnlockQueue>
    }
    2888:	27 96       	adiw	r28, 0x07	; 7
    288a:	0f b6       	in	r0, 0x3f	; 63
    288c:	f8 94       	cli
    288e:	de bf       	out	0x3e, r29	; 62
    2890:	0f be       	out	0x3f, r0	; 63
    2892:	cd bf       	out	0x3d, r28	; 61
    2894:	cf 91       	pop	r28
    2896:	df 91       	pop	r29
    2898:	08 95       	ret

0000289a <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    289a:	8f 92       	push	r8
    289c:	9f 92       	push	r9
    289e:	af 92       	push	r10
    28a0:	bf 92       	push	r11
    28a2:	cf 92       	push	r12
    28a4:	df 92       	push	r13
    28a6:	ef 92       	push	r14
    28a8:	ff 92       	push	r15
    28aa:	0f 93       	push	r16
    28ac:	1f 93       	push	r17
    28ae:	df 93       	push	r29
    28b0:	cf 93       	push	r28
    28b2:	cd b7       	in	r28, 0x3d	; 61
    28b4:	de b7       	in	r29, 0x3e	; 62
    28b6:	60 97       	sbiw	r28, 0x10	; 16
    28b8:	0f b6       	in	r0, 0x3f	; 63
    28ba:	f8 94       	cli
    28bc:	de bf       	out	0x3e, r29	; 62
    28be:	0f be       	out	0x3f, r0	; 63
    28c0:	cd bf       	out	0x3d, r28	; 61
    28c2:	9f 83       	std	Y+7, r25	; 0x07
    28c4:	8e 83       	std	Y+6, r24	; 0x06
    28c6:	79 87       	std	Y+9, r23	; 0x09
    28c8:	68 87       	std	Y+8, r22	; 0x08
    28ca:	5b 87       	std	Y+11, r21	; 0x0b
    28cc:	4a 87       	std	Y+10, r20	; 0x0a
    28ce:	3d 87       	std	Y+13, r19	; 0x0d
    28d0:	2c 87       	std	Y+12, r18	; 0x0c
    28d2:	0e 87       	std	Y+14, r16	; 0x0e
    28d4:	f8 8a       	std	Y+16, r15	; 0x10
    28d6:	ef 86       	std	Y+15, r14	; 0x0f
        #else /* portSTACK_GROWTH */
            {
                StackType_t * pxStack;

                /* Allocate space for the stack used by the task being created. */
                pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    28d8:	8a 85       	ldd	r24, Y+10	; 0x0a
    28da:	9b 85       	ldd	r25, Y+11	; 0x0b
    28dc:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    28e0:	9a 83       	std	Y+2, r25	; 0x02
    28e2:	89 83       	std	Y+1, r24	; 0x01

                if( pxStack != NULL )
    28e4:	89 81       	ldd	r24, Y+1	; 0x01
    28e6:	9a 81       	ldd	r25, Y+2	; 0x02
    28e8:	00 97       	sbiw	r24, 0x00	; 0
    28ea:	b1 f0       	breq	.+44     	; 0x2918 <xTaskCreate+0x7e>
                {
                    /* Allocate space for the TCB. */
                    pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    28ec:	86 e2       	ldi	r24, 0x26	; 38
    28ee:	90 e0       	ldi	r25, 0x00	; 0
    28f0:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    28f4:	9d 83       	std	Y+5, r25	; 0x05
    28f6:	8c 83       	std	Y+4, r24	; 0x04

                    if( pxNewTCB != NULL )
    28f8:	8c 81       	ldd	r24, Y+4	; 0x04
    28fa:	9d 81       	ldd	r25, Y+5	; 0x05
    28fc:	00 97       	sbiw	r24, 0x00	; 0
    28fe:	39 f0       	breq	.+14     	; 0x290e <xTaskCreate+0x74>
                    {
                        /* Store the stack location in the TCB. */
                        pxNewTCB->pxStack = pxStack;
    2900:	ec 81       	ldd	r30, Y+4	; 0x04
    2902:	fd 81       	ldd	r31, Y+5	; 0x05
    2904:	89 81       	ldd	r24, Y+1	; 0x01
    2906:	9a 81       	ldd	r25, Y+2	; 0x02
    2908:	90 8f       	std	Z+24, r25	; 0x18
    290a:	87 8b       	std	Z+23, r24	; 0x17
    290c:	07 c0       	rjmp	.+14     	; 0x291c <xTaskCreate+0x82>
                    }
                    else
                    {
                        /* The stack cannot be used as the TCB was not created.  Free
                         * it again. */
                        vPortFreeStack( pxStack );
    290e:	89 81       	ldd	r24, Y+1	; 0x01
    2910:	9a 81       	ldd	r25, Y+2	; 0x02
    2912:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
    2916:	02 c0       	rjmp	.+4      	; 0x291c <xTaskCreate+0x82>
                    }
                }
                else
                {
                    pxNewTCB = NULL;
    2918:	1d 82       	std	Y+5, r1	; 0x05
    291a:	1c 82       	std	Y+4, r1	; 0x04
                }
            }
        #endif /* portSTACK_GROWTH */

        if( pxNewTCB != NULL )
    291c:	8c 81       	ldd	r24, Y+4	; 0x04
    291e:	9d 81       	ldd	r25, Y+5	; 0x05
    2920:	00 97       	sbiw	r24, 0x00	; 0
    2922:	e9 f0       	breq	.+58     	; 0x295e <xTaskCreate+0xc4>
                     * task was created dynamically in case it is later deleted. */
                    pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
                }
            #endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

            prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    2924:	8a 85       	ldd	r24, Y+10	; 0x0a
    2926:	9b 85       	ldd	r25, Y+11	; 0x0b
    2928:	9c 01       	movw	r18, r24
    292a:	40 e0       	ldi	r20, 0x00	; 0
    292c:	50 e0       	ldi	r21, 0x00	; 0
    292e:	8e 81       	ldd	r24, Y+6	; 0x06
    2930:	9f 81       	ldd	r25, Y+7	; 0x07
    2932:	68 85       	ldd	r22, Y+8	; 0x08
    2934:	79 85       	ldd	r23, Y+9	; 0x09
    2936:	ec 85       	ldd	r30, Y+12	; 0x0c
    2938:	fd 85       	ldd	r31, Y+13	; 0x0d
    293a:	af 85       	ldd	r26, Y+15	; 0x0f
    293c:	b8 89       	ldd	r27, Y+16	; 0x10
    293e:	ac 80       	ldd	r10, Y+4	; 0x04
    2940:	bd 80       	ldd	r11, Y+5	; 0x05
    2942:	8f 01       	movw	r16, r30
    2944:	ee 84       	ldd	r14, Y+14	; 0x0e
    2946:	6d 01       	movw	r12, r26
    2948:	88 24       	eor	r8, r8
    294a:	99 24       	eor	r9, r9
    294c:	0e 94 c5 14 	call	0x298a	; 0x298a <prvInitialiseNewTask>
            prvAddNewTaskToReadyList( pxNewTCB );
    2950:	8c 81       	ldd	r24, Y+4	; 0x04
    2952:	9d 81       	ldd	r25, Y+5	; 0x05
    2954:	0e 94 8a 15 	call	0x2b14	; 0x2b14 <prvAddNewTaskToReadyList>
            xReturn = pdPASS;
    2958:	81 e0       	ldi	r24, 0x01	; 1
    295a:	8b 83       	std	Y+3, r24	; 0x03
    295c:	02 c0       	rjmp	.+4      	; 0x2962 <xTaskCreate+0xc8>
        }
        else
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    295e:	8f ef       	ldi	r24, 0xFF	; 255
    2960:	8b 83       	std	Y+3, r24	; 0x03
        }

        return xReturn;
    2962:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    2964:	60 96       	adiw	r28, 0x10	; 16
    2966:	0f b6       	in	r0, 0x3f	; 63
    2968:	f8 94       	cli
    296a:	de bf       	out	0x3e, r29	; 62
    296c:	0f be       	out	0x3f, r0	; 63
    296e:	cd bf       	out	0x3d, r28	; 61
    2970:	cf 91       	pop	r28
    2972:	df 91       	pop	r29
    2974:	1f 91       	pop	r17
    2976:	0f 91       	pop	r16
    2978:	ff 90       	pop	r15
    297a:	ef 90       	pop	r14
    297c:	df 90       	pop	r13
    297e:	cf 90       	pop	r12
    2980:	bf 90       	pop	r11
    2982:	af 90       	pop	r10
    2984:	9f 90       	pop	r9
    2986:	8f 90       	pop	r8
    2988:	08 95       	ret

0000298a <prvInitialiseNewTask>:
                                  void * const pvParameters,
                                  UBaseType_t uxPriority,
                                  TaskHandle_t * const pxCreatedTask,
                                  TCB_t * pxNewTCB,
                                  const MemoryRegion_t * const xRegions )
{
    298a:	8f 92       	push	r8
    298c:	9f 92       	push	r9
    298e:	af 92       	push	r10
    2990:	bf 92       	push	r11
    2992:	cf 92       	push	r12
    2994:	df 92       	push	r13
    2996:	ef 92       	push	r14
    2998:	0f 93       	push	r16
    299a:	1f 93       	push	r17
    299c:	df 93       	push	r29
    299e:	cf 93       	push	r28
    29a0:	cd b7       	in	r28, 0x3d	; 61
    29a2:	de b7       	in	r29, 0x3e	; 62
    29a4:	64 97       	sbiw	r28, 0x14	; 20
    29a6:	0f b6       	in	r0, 0x3f	; 63
    29a8:	f8 94       	cli
    29aa:	de bf       	out	0x3e, r29	; 62
    29ac:	0f be       	out	0x3f, r0	; 63
    29ae:	cd bf       	out	0x3d, r28	; 61
    29b0:	9d 83       	std	Y+5, r25	; 0x05
    29b2:	8c 83       	std	Y+4, r24	; 0x04
    29b4:	7f 83       	std	Y+7, r23	; 0x07
    29b6:	6e 83       	std	Y+6, r22	; 0x06
    29b8:	28 87       	std	Y+8, r18	; 0x08
    29ba:	39 87       	std	Y+9, r19	; 0x09
    29bc:	4a 87       	std	Y+10, r20	; 0x0a
    29be:	5b 87       	std	Y+11, r21	; 0x0b
    29c0:	1d 87       	std	Y+13, r17	; 0x0d
    29c2:	0c 87       	std	Y+12, r16	; 0x0c
    29c4:	ee 86       	std	Y+14, r14	; 0x0e
    29c6:	d8 8a       	std	Y+16, r13	; 0x10
    29c8:	cf 86       	std	Y+15, r12	; 0x0f
    29ca:	ba 8a       	std	Y+18, r11	; 0x12
    29cc:	a9 8a       	std	Y+17, r10	; 0x11
    29ce:	9c 8a       	std	Y+20, r9	; 0x14
    29d0:	8b 8a       	std	Y+19, r8	; 0x13
     * grows from high memory to low (as per the 80x86) or vice versa.
     * portSTACK_GROWTH is used to make the result positive or negative as required
     * by the port. */
    #if ( portSTACK_GROWTH < 0 )
        {
            pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    29d2:	e9 89       	ldd	r30, Y+17	; 0x11
    29d4:	fa 89       	ldd	r31, Y+18	; 0x12
    29d6:	27 89       	ldd	r18, Z+23	; 0x17
    29d8:	30 8d       	ldd	r19, Z+24	; 0x18
    29da:	88 85       	ldd	r24, Y+8	; 0x08
    29dc:	99 85       	ldd	r25, Y+9	; 0x09
    29de:	01 97       	sbiw	r24, 0x01	; 1
    29e0:	82 0f       	add	r24, r18
    29e2:	93 1f       	adc	r25, r19
    29e4:	9b 83       	std	Y+3, r25	; 0x03
    29e6:	8a 83       	std	Y+2, r24	; 0x02
            pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
        }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    29e8:	8e 81       	ldd	r24, Y+6	; 0x06
    29ea:	9f 81       	ldd	r25, Y+7	; 0x07
    29ec:	00 97       	sbiw	r24, 0x00	; 0
    29ee:	51 f1       	breq	.+84     	; 0x2a44 <prvInitialiseNewTask+0xba>
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    29f0:	19 82       	std	Y+1, r1	; 0x01
    29f2:	21 c0       	rjmp	.+66     	; 0x2a36 <prvInitialiseNewTask+0xac>
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    29f4:	89 81       	ldd	r24, Y+1	; 0x01
    29f6:	48 2f       	mov	r20, r24
    29f8:	50 e0       	ldi	r21, 0x00	; 0
    29fa:	89 81       	ldd	r24, Y+1	; 0x01
    29fc:	28 2f       	mov	r18, r24
    29fe:	30 e0       	ldi	r19, 0x00	; 0
    2a00:	8e 81       	ldd	r24, Y+6	; 0x06
    2a02:	9f 81       	ldd	r25, Y+7	; 0x07
    2a04:	fc 01       	movw	r30, r24
    2a06:	e2 0f       	add	r30, r18
    2a08:	f3 1f       	adc	r31, r19
    2a0a:	20 81       	ld	r18, Z
    2a0c:	89 89       	ldd	r24, Y+17	; 0x11
    2a0e:	9a 89       	ldd	r25, Y+18	; 0x12
    2a10:	84 0f       	add	r24, r20
    2a12:	95 1f       	adc	r25, r21
    2a14:	fc 01       	movw	r30, r24
    2a16:	79 96       	adiw	r30, 0x19	; 25
    2a18:	20 83       	st	Z, r18

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    2a1a:	89 81       	ldd	r24, Y+1	; 0x01
    2a1c:	28 2f       	mov	r18, r24
    2a1e:	30 e0       	ldi	r19, 0x00	; 0
    2a20:	8e 81       	ldd	r24, Y+6	; 0x06
    2a22:	9f 81       	ldd	r25, Y+7	; 0x07
    2a24:	fc 01       	movw	r30, r24
    2a26:	e2 0f       	add	r30, r18
    2a28:	f3 1f       	adc	r31, r19
    2a2a:	80 81       	ld	r24, Z
    2a2c:	88 23       	and	r24, r24
    2a2e:	31 f0       	breq	.+12     	; 0x2a3c <prvInitialiseNewTask+0xb2>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2a30:	89 81       	ldd	r24, Y+1	; 0x01
    2a32:	8f 5f       	subi	r24, 0xFF	; 255
    2a34:	89 83       	std	Y+1, r24	; 0x01
    2a36:	89 81       	ldd	r24, Y+1	; 0x01
    2a38:	88 30       	cpi	r24, 0x08	; 8
    2a3a:	e0 f2       	brcs	.-72     	; 0x29f4 <prvInitialiseNewTask+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    2a3c:	e9 89       	ldd	r30, Y+17	; 0x11
    2a3e:	fa 89       	ldd	r31, Y+18	; 0x12
    2a40:	10 a2       	std	Z+32, r1	; 0x20
    2a42:	03 c0       	rjmp	.+6      	; 0x2a4a <prvInitialiseNewTask+0xc0>
    }
    else
    {
        /* The task has not been given a name, so just ensure there is a NULL
         * terminator when it is read out. */
        pxNewTCB->pcTaskName[ 0 ] = 0x00;
    2a44:	e9 89       	ldd	r30, Y+17	; 0x11
    2a46:	fa 89       	ldd	r31, Y+18	; 0x12
    2a48:	11 8e       	std	Z+25, r1	; 0x19
    }

    /* This is used as an array index so must ensure it's not too large. */
    configASSERT( uxPriority < configMAX_PRIORITIES );

    if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    2a4a:	8e 85       	ldd	r24, Y+14	; 0x0e
    2a4c:	84 30       	cpi	r24, 0x04	; 4
    2a4e:	10 f0       	brcs	.+4      	; 0x2a54 <prvInitialiseNewTask+0xca>
    {
        uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    2a50:	83 e0       	ldi	r24, 0x03	; 3
    2a52:	8e 87       	std	Y+14, r24	; 0x0e
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    2a54:	e9 89       	ldd	r30, Y+17	; 0x11
    2a56:	fa 89       	ldd	r31, Y+18	; 0x12
    2a58:	8e 85       	ldd	r24, Y+14	; 0x0e
    2a5a:	86 8b       	std	Z+22, r24	; 0x16
            pxNewTCB->uxBasePriority = uxPriority;
            pxNewTCB->uxMutexesHeld = 0;
        }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    2a5c:	89 89       	ldd	r24, Y+17	; 0x11
    2a5e:	9a 89       	ldd	r25, Y+18	; 0x12
    2a60:	02 96       	adiw	r24, 0x02	; 2
    2a62:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    2a66:	89 89       	ldd	r24, Y+17	; 0x11
    2a68:	9a 89       	ldd	r25, Y+18	; 0x12
    2a6a:	0c 96       	adiw	r24, 0x0c	; 12
    2a6c:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    2a70:	e9 89       	ldd	r30, Y+17	; 0x11
    2a72:	fa 89       	ldd	r31, Y+18	; 0x12
    2a74:	89 89       	ldd	r24, Y+17	; 0x11
    2a76:	9a 89       	ldd	r25, Y+18	; 0x12
    2a78:	91 87       	std	Z+9, r25	; 0x09
    2a7a:	80 87       	std	Z+8, r24	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2a7c:	8e 85       	ldd	r24, Y+14	; 0x0e
    2a7e:	28 2f       	mov	r18, r24
    2a80:	30 e0       	ldi	r19, 0x00	; 0
    2a82:	84 e0       	ldi	r24, 0x04	; 4
    2a84:	90 e0       	ldi	r25, 0x00	; 0
    2a86:	82 1b       	sub	r24, r18
    2a88:	93 0b       	sbc	r25, r19
    2a8a:	e9 89       	ldd	r30, Y+17	; 0x11
    2a8c:	fa 89       	ldd	r31, Y+18	; 0x12
    2a8e:	95 87       	std	Z+13, r25	; 0x0d
    2a90:	84 87       	std	Z+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    2a92:	e9 89       	ldd	r30, Y+17	; 0x11
    2a94:	fa 89       	ldd	r31, Y+18	; 0x12
    2a96:	89 89       	ldd	r24, Y+17	; 0x11
    2a98:	9a 89       	ldd	r25, Y+18	; 0x12
    2a9a:	93 8b       	std	Z+19, r25	; 0x13
    2a9c:	82 8b       	std	Z+18, r24	; 0x12
        }
    #endif

    #if ( configUSE_TASK_NOTIFICATIONS == 1 )
        {
            memset( ( void * ) &( pxNewTCB->ulNotifiedValue[ 0 ] ), 0x00, sizeof( pxNewTCB->ulNotifiedValue ) );
    2a9e:	89 89       	ldd	r24, Y+17	; 0x11
    2aa0:	9a 89       	ldd	r25, Y+18	; 0x12
    2aa2:	81 96       	adiw	r24, 0x21	; 33
    2aa4:	60 e0       	ldi	r22, 0x00	; 0
    2aa6:	70 e0       	ldi	r23, 0x00	; 0
    2aa8:	44 e0       	ldi	r20, 0x04	; 4
    2aaa:	50 e0       	ldi	r21, 0x00	; 0
    2aac:	0e 94 1f 33 	call	0x663e	; 0x663e <memset>
            memset( ( void * ) &( pxNewTCB->ucNotifyState[ 0 ] ), 0x00, sizeof( pxNewTCB->ucNotifyState ) );
    2ab0:	89 89       	ldd	r24, Y+17	; 0x11
    2ab2:	9a 89       	ldd	r25, Y+18	; 0x12
    2ab4:	85 96       	adiw	r24, 0x25	; 37
    2ab6:	60 e0       	ldi	r22, 0x00	; 0
    2ab8:	70 e0       	ldi	r23, 0x00	; 0
    2aba:	41 e0       	ldi	r20, 0x01	; 1
    2abc:	50 e0       	ldi	r21, 0x00	; 0
    2abe:	0e 94 1f 33 	call	0x663e	; 0x663e <memset>
                        }
                    #endif /* portSTACK_GROWTH */
                }
            #else /* portHAS_STACK_OVERFLOW_CHECKING */
                {
                    pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2ac2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ac4:	9b 81       	ldd	r25, Y+3	; 0x03
    2ac6:	2c 81       	ldd	r18, Y+4	; 0x04
    2ac8:	3d 81       	ldd	r19, Y+5	; 0x05
    2aca:	4c 85       	ldd	r20, Y+12	; 0x0c
    2acc:	5d 85       	ldd	r21, Y+13	; 0x0d
    2ace:	b9 01       	movw	r22, r18
    2ad0:	0e 94 c9 00 	call	0x192	; 0x192 <pxPortInitialiseStack>
    2ad4:	e9 89       	ldd	r30, Y+17	; 0x11
    2ad6:	fa 89       	ldd	r31, Y+18	; 0x12
    2ad8:	91 83       	std	Z+1, r25	; 0x01
    2ada:	80 83       	st	Z, r24
                }
            #endif /* portHAS_STACK_OVERFLOW_CHECKING */
        }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    2adc:	8f 85       	ldd	r24, Y+15	; 0x0f
    2ade:	98 89       	ldd	r25, Y+16	; 0x10
    2ae0:	00 97       	sbiw	r24, 0x00	; 0
    2ae2:	31 f0       	breq	.+12     	; 0x2af0 <prvInitialiseNewTask+0x166>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    2ae4:	ef 85       	ldd	r30, Y+15	; 0x0f
    2ae6:	f8 89       	ldd	r31, Y+16	; 0x10
    2ae8:	89 89       	ldd	r24, Y+17	; 0x11
    2aea:	9a 89       	ldd	r25, Y+18	; 0x12
    2aec:	91 83       	std	Z+1, r25	; 0x01
    2aee:	80 83       	st	Z, r24
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    2af0:	64 96       	adiw	r28, 0x14	; 20
    2af2:	0f b6       	in	r0, 0x3f	; 63
    2af4:	f8 94       	cli
    2af6:	de bf       	out	0x3e, r29	; 62
    2af8:	0f be       	out	0x3f, r0	; 63
    2afa:	cd bf       	out	0x3d, r28	; 61
    2afc:	cf 91       	pop	r28
    2afe:	df 91       	pop	r29
    2b00:	1f 91       	pop	r17
    2b02:	0f 91       	pop	r16
    2b04:	ef 90       	pop	r14
    2b06:	df 90       	pop	r13
    2b08:	cf 90       	pop	r12
    2b0a:	bf 90       	pop	r11
    2b0c:	af 90       	pop	r10
    2b0e:	9f 90       	pop	r9
    2b10:	8f 90       	pop	r8
    2b12:	08 95       	ret

00002b14 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    2b14:	df 93       	push	r29
    2b16:	cf 93       	push	r28
    2b18:	00 d0       	rcall	.+0      	; 0x2b1a <prvAddNewTaskToReadyList+0x6>
    2b1a:	00 d0       	rcall	.+0      	; 0x2b1c <prvAddNewTaskToReadyList+0x8>
    2b1c:	cd b7       	in	r28, 0x3d	; 61
    2b1e:	de b7       	in	r29, 0x3e	; 62
    2b20:	9c 83       	std	Y+4, r25	; 0x04
    2b22:	8b 83       	std	Y+3, r24	; 0x03
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    2b24:	0f b6       	in	r0, 0x3f	; 63
    2b26:	f8 94       	cli
    2b28:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    2b2a:	80 91 a9 06 	lds	r24, 0x06A9
    2b2e:	8f 5f       	subi	r24, 0xFF	; 255
    2b30:	80 93 a9 06 	sts	0x06A9, r24

        if( pxCurrentTCB == NULL )
    2b34:	80 91 a6 06 	lds	r24, 0x06A6
    2b38:	90 91 a7 06 	lds	r25, 0x06A7
    2b3c:	00 97       	sbiw	r24, 0x00	; 0
    2b3e:	69 f4       	brne	.+26     	; 0x2b5a <prvAddNewTaskToReadyList+0x46>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    2b40:	8b 81       	ldd	r24, Y+3	; 0x03
    2b42:	9c 81       	ldd	r25, Y+4	; 0x04
    2b44:	90 93 a7 06 	sts	0x06A7, r25
    2b48:	80 93 a6 06 	sts	0x06A6, r24

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    2b4c:	80 91 a9 06 	lds	r24, 0x06A9
    2b50:	81 30       	cpi	r24, 0x01	; 1
    2b52:	b9 f4       	brne	.+46     	; 0x2b82 <prvAddNewTaskToReadyList+0x6e>
            {
                /* This is the first task to be created so do the preliminary
                 * initialisation required.  We will not recover if this call
                 * fails, but we will report the failure. */
                prvInitialiseTaskLists();
    2b54:	0e 94 6e 1f 	call	0x3edc	; 0x3edc <prvInitialiseTaskLists>
    2b58:	14 c0       	rjmp	.+40     	; 0x2b82 <prvAddNewTaskToReadyList+0x6e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    2b5a:	80 91 ad 06 	lds	r24, 0x06AD
    2b5e:	88 23       	and	r24, r24
    2b60:	81 f4       	brne	.+32     	; 0x2b82 <prvAddNewTaskToReadyList+0x6e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    2b62:	e0 91 a6 06 	lds	r30, 0x06A6
    2b66:	f0 91 a7 06 	lds	r31, 0x06A7
    2b6a:	96 89       	ldd	r25, Z+22	; 0x16
    2b6c:	eb 81       	ldd	r30, Y+3	; 0x03
    2b6e:	fc 81       	ldd	r31, Y+4	; 0x04
    2b70:	86 89       	ldd	r24, Z+22	; 0x16
    2b72:	89 17       	cp	r24, r25
    2b74:	30 f0       	brcs	.+12     	; 0x2b82 <prvAddNewTaskToReadyList+0x6e>
                {
                    pxCurrentTCB = pxNewTCB;
    2b76:	8b 81       	ldd	r24, Y+3	; 0x03
    2b78:	9c 81       	ldd	r25, Y+4	; 0x04
    2b7a:	90 93 a7 06 	sts	0x06A7, r25
    2b7e:	80 93 a6 06 	sts	0x06A6, r24
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    2b82:	80 91 b2 06 	lds	r24, 0x06B2
    2b86:	8f 5f       	subi	r24, 0xFF	; 255
    2b88:	80 93 b2 06 	sts	0x06B2, r24
                pxNewTCB->uxTCBNumber = uxTaskNumber;
            }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    2b8c:	eb 81       	ldd	r30, Y+3	; 0x03
    2b8e:	fc 81       	ldd	r31, Y+4	; 0x04
    2b90:	96 89       	ldd	r25, Z+22	; 0x16
    2b92:	80 91 ac 06 	lds	r24, 0x06AC
    2b96:	89 17       	cp	r24, r25
    2b98:	28 f4       	brcc	.+10     	; 0x2ba4 <prvAddNewTaskToReadyList+0x90>
    2b9a:	eb 81       	ldd	r30, Y+3	; 0x03
    2b9c:	fc 81       	ldd	r31, Y+4	; 0x04
    2b9e:	86 89       	ldd	r24, Z+22	; 0x16
    2ba0:	80 93 ac 06 	sts	0x06AC, r24
    2ba4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ba6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ba8:	86 89       	ldd	r24, Z+22	; 0x16
    2baa:	28 2f       	mov	r18, r24
    2bac:	30 e0       	ldi	r19, 0x00	; 0
    2bae:	c9 01       	movw	r24, r18
    2bb0:	88 0f       	add	r24, r24
    2bb2:	99 1f       	adc	r25, r25
    2bb4:	88 0f       	add	r24, r24
    2bb6:	99 1f       	adc	r25, r25
    2bb8:	88 0f       	add	r24, r24
    2bba:	99 1f       	adc	r25, r25
    2bbc:	82 0f       	add	r24, r18
    2bbe:	93 1f       	adc	r25, r19
    2bc0:	fc 01       	movw	r30, r24
    2bc2:	e8 54       	subi	r30, 0x48	; 72
    2bc4:	f9 4f       	sbci	r31, 0xF9	; 249
    2bc6:	81 81       	ldd	r24, Z+1	; 0x01
    2bc8:	92 81       	ldd	r25, Z+2	; 0x02
    2bca:	9a 83       	std	Y+2, r25	; 0x02
    2bcc:	89 83       	std	Y+1, r24	; 0x01
    2bce:	eb 81       	ldd	r30, Y+3	; 0x03
    2bd0:	fc 81       	ldd	r31, Y+4	; 0x04
    2bd2:	89 81       	ldd	r24, Y+1	; 0x01
    2bd4:	9a 81       	ldd	r25, Y+2	; 0x02
    2bd6:	95 83       	std	Z+5, r25	; 0x05
    2bd8:	84 83       	std	Z+4, r24	; 0x04
    2bda:	e9 81       	ldd	r30, Y+1	; 0x01
    2bdc:	fa 81       	ldd	r31, Y+2	; 0x02
    2bde:	84 81       	ldd	r24, Z+4	; 0x04
    2be0:	95 81       	ldd	r25, Z+5	; 0x05
    2be2:	eb 81       	ldd	r30, Y+3	; 0x03
    2be4:	fc 81       	ldd	r31, Y+4	; 0x04
    2be6:	97 83       	std	Z+7, r25	; 0x07
    2be8:	86 83       	std	Z+6, r24	; 0x06
    2bea:	e9 81       	ldd	r30, Y+1	; 0x01
    2bec:	fa 81       	ldd	r31, Y+2	; 0x02
    2bee:	04 80       	ldd	r0, Z+4	; 0x04
    2bf0:	f5 81       	ldd	r31, Z+5	; 0x05
    2bf2:	e0 2d       	mov	r30, r0
    2bf4:	8b 81       	ldd	r24, Y+3	; 0x03
    2bf6:	9c 81       	ldd	r25, Y+4	; 0x04
    2bf8:	02 96       	adiw	r24, 0x02	; 2
    2bfa:	93 83       	std	Z+3, r25	; 0x03
    2bfc:	82 83       	std	Z+2, r24	; 0x02
    2bfe:	8b 81       	ldd	r24, Y+3	; 0x03
    2c00:	9c 81       	ldd	r25, Y+4	; 0x04
    2c02:	02 96       	adiw	r24, 0x02	; 2
    2c04:	e9 81       	ldd	r30, Y+1	; 0x01
    2c06:	fa 81       	ldd	r31, Y+2	; 0x02
    2c08:	95 83       	std	Z+5, r25	; 0x05
    2c0a:	84 83       	std	Z+4, r24	; 0x04
    2c0c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c0e:	fc 81       	ldd	r31, Y+4	; 0x04
    2c10:	86 89       	ldd	r24, Z+22	; 0x16
    2c12:	28 2f       	mov	r18, r24
    2c14:	30 e0       	ldi	r19, 0x00	; 0
    2c16:	c9 01       	movw	r24, r18
    2c18:	88 0f       	add	r24, r24
    2c1a:	99 1f       	adc	r25, r25
    2c1c:	88 0f       	add	r24, r24
    2c1e:	99 1f       	adc	r25, r25
    2c20:	88 0f       	add	r24, r24
    2c22:	99 1f       	adc	r25, r25
    2c24:	82 0f       	add	r24, r18
    2c26:	93 1f       	adc	r25, r19
    2c28:	88 54       	subi	r24, 0x48	; 72
    2c2a:	99 4f       	sbci	r25, 0xF9	; 249
    2c2c:	eb 81       	ldd	r30, Y+3	; 0x03
    2c2e:	fc 81       	ldd	r31, Y+4	; 0x04
    2c30:	93 87       	std	Z+11, r25	; 0x0b
    2c32:	82 87       	std	Z+10, r24	; 0x0a
    2c34:	eb 81       	ldd	r30, Y+3	; 0x03
    2c36:	fc 81       	ldd	r31, Y+4	; 0x04
    2c38:	86 89       	ldd	r24, Z+22	; 0x16
    2c3a:	28 2f       	mov	r18, r24
    2c3c:	30 e0       	ldi	r19, 0x00	; 0
    2c3e:	c9 01       	movw	r24, r18
    2c40:	88 0f       	add	r24, r24
    2c42:	99 1f       	adc	r25, r25
    2c44:	88 0f       	add	r24, r24
    2c46:	99 1f       	adc	r25, r25
    2c48:	88 0f       	add	r24, r24
    2c4a:	99 1f       	adc	r25, r25
    2c4c:	82 0f       	add	r24, r18
    2c4e:	93 1f       	adc	r25, r19
    2c50:	fc 01       	movw	r30, r24
    2c52:	e8 54       	subi	r30, 0x48	; 72
    2c54:	f9 4f       	sbci	r31, 0xF9	; 249
    2c56:	80 81       	ld	r24, Z
    2c58:	8f 5f       	subi	r24, 0xFF	; 255
    2c5a:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    2c5c:	0f 90       	pop	r0
    2c5e:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    2c60:	80 91 ad 06 	lds	r24, 0x06AD
    2c64:	88 23       	and	r24, r24
    2c66:	61 f0       	breq	.+24     	; 0x2c80 <prvAddNewTaskToReadyList+0x16c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    2c68:	e0 91 a6 06 	lds	r30, 0x06A6
    2c6c:	f0 91 a7 06 	lds	r31, 0x06A7
    2c70:	96 89       	ldd	r25, Z+22	; 0x16
    2c72:	eb 81       	ldd	r30, Y+3	; 0x03
    2c74:	fc 81       	ldd	r31, Y+4	; 0x04
    2c76:	86 89       	ldd	r24, Z+22	; 0x16
    2c78:	98 17       	cp	r25, r24
    2c7a:	10 f4       	brcc	.+4      	; 0x2c80 <prvAddNewTaskToReadyList+0x16c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    2c7c:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    }
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }
}
    2c80:	0f 90       	pop	r0
    2c82:	0f 90       	pop	r0
    2c84:	0f 90       	pop	r0
    2c86:	0f 90       	pop	r0
    2c88:	cf 91       	pop	r28
    2c8a:	df 91       	pop	r29
    2c8c:	08 95       	ret

00002c8e <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    2c8e:	df 93       	push	r29
    2c90:	cf 93       	push	r28
    2c92:	00 d0       	rcall	.+0      	; 0x2c94 <vTaskDelete+0x6>
    2c94:	00 d0       	rcall	.+0      	; 0x2c96 <vTaskDelete+0x8>
    2c96:	00 d0       	rcall	.+0      	; 0x2c98 <vTaskDelete+0xa>
    2c98:	cd b7       	in	r28, 0x3d	; 61
    2c9a:	de b7       	in	r29, 0x3e	; 62
    2c9c:	9c 83       	std	Y+4, r25	; 0x04
    2c9e:	8b 83       	std	Y+3, r24	; 0x03
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    2ca0:	0f b6       	in	r0, 0x3f	; 63
    2ca2:	f8 94       	cli
    2ca4:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    2ca6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ca8:	9c 81       	ldd	r25, Y+4	; 0x04
    2caa:	00 97       	sbiw	r24, 0x00	; 0
    2cac:	39 f4       	brne	.+14     	; 0x2cbc <vTaskDelete+0x2e>
    2cae:	80 91 a6 06 	lds	r24, 0x06A6
    2cb2:	90 91 a7 06 	lds	r25, 0x06A7
    2cb6:	9e 83       	std	Y+6, r25	; 0x06
    2cb8:	8d 83       	std	Y+5, r24	; 0x05
    2cba:	04 c0       	rjmp	.+8      	; 0x2cc4 <vTaskDelete+0x36>
    2cbc:	8b 81       	ldd	r24, Y+3	; 0x03
    2cbe:	9c 81       	ldd	r25, Y+4	; 0x04
    2cc0:	9e 83       	std	Y+6, r25	; 0x06
    2cc2:	8d 83       	std	Y+5, r24	; 0x05
    2cc4:	8d 81       	ldd	r24, Y+5	; 0x05
    2cc6:	9e 81       	ldd	r25, Y+6	; 0x06
    2cc8:	9a 83       	std	Y+2, r25	; 0x02
    2cca:	89 83       	std	Y+1, r24	; 0x01

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2ccc:	89 81       	ldd	r24, Y+1	; 0x01
    2cce:	9a 81       	ldd	r25, Y+2	; 0x02
    2cd0:	02 96       	adiw	r24, 0x02	; 2
    2cd2:	0e 94 ab 0a 	call	0x1556	; 0x1556 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2cd6:	e9 81       	ldd	r30, Y+1	; 0x01
    2cd8:	fa 81       	ldd	r31, Y+2	; 0x02
    2cda:	84 89       	ldd	r24, Z+20	; 0x14
    2cdc:	95 89       	ldd	r25, Z+21	; 0x15
    2cde:	00 97       	sbiw	r24, 0x00	; 0
    2ce0:	29 f0       	breq	.+10     	; 0x2cec <vTaskDelete+0x5e>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2ce2:	89 81       	ldd	r24, Y+1	; 0x01
    2ce4:	9a 81       	ldd	r25, Y+2	; 0x02
    2ce6:	0c 96       	adiw	r24, 0x0c	; 12
    2ce8:	0e 94 ab 0a 	call	0x1556	; 0x1556 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    2cec:	80 91 b2 06 	lds	r24, 0x06B2
    2cf0:	8f 5f       	subi	r24, 0xFF	; 255
    2cf2:	80 93 b2 06 	sts	0x06B2, r24

            if( pxTCB == pxCurrentTCB )
    2cf6:	20 91 a6 06 	lds	r18, 0x06A6
    2cfa:	30 91 a7 06 	lds	r19, 0x06A7
    2cfe:	89 81       	ldd	r24, Y+1	; 0x01
    2d00:	9a 81       	ldd	r25, Y+2	; 0x02
    2d02:	82 17       	cp	r24, r18
    2d04:	93 07       	cpc	r25, r19
    2d06:	81 f4       	brne	.+32     	; 0x2d28 <vTaskDelete+0x9a>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    2d08:	89 81       	ldd	r24, Y+1	; 0x01
    2d0a:	9a 81       	ldd	r25, Y+2	; 0x02
    2d0c:	9c 01       	movw	r18, r24
    2d0e:	2e 5f       	subi	r18, 0xFE	; 254
    2d10:	3f 4f       	sbci	r19, 0xFF	; 255
    2d12:	8b ef       	ldi	r24, 0xFB	; 251
    2d14:	96 e0       	ldi	r25, 0x06	; 6
    2d16:	b9 01       	movw	r22, r18
    2d18:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    2d1c:	80 91 a8 06 	lds	r24, 0x06A8
    2d20:	8f 5f       	subi	r24, 0xFF	; 255
    2d22:	80 93 a8 06 	sts	0x06A8, r24
    2d26:	07 c0       	rjmp	.+14     	; 0x2d36 <vTaskDelete+0xa8>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    2d28:	80 91 a9 06 	lds	r24, 0x06A9
    2d2c:	81 50       	subi	r24, 0x01	; 1
    2d2e:	80 93 a9 06 	sts	0x06A9, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    2d32:	0e 94 f0 1f 	call	0x3fe0	; 0x3fe0 <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    2d36:	0f 90       	pop	r0
    2d38:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    2d3a:	20 91 a6 06 	lds	r18, 0x06A6
    2d3e:	30 91 a7 06 	lds	r19, 0x06A7
    2d42:	89 81       	ldd	r24, Y+1	; 0x01
    2d44:	9a 81       	ldd	r25, Y+2	; 0x02
    2d46:	82 17       	cp	r24, r18
    2d48:	93 07       	cpc	r25, r19
    2d4a:	21 f0       	breq	.+8      	; 0x2d54 <vTaskDelete+0xc6>
        {
            prvDeleteTCB( pxTCB );
    2d4c:	89 81       	ldd	r24, Y+1	; 0x01
    2d4e:	9a 81       	ldd	r25, Y+2	; 0x02
    2d50:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    2d54:	80 91 ad 06 	lds	r24, 0x06AD
    2d58:	88 23       	and	r24, r24
    2d5a:	59 f0       	breq	.+22     	; 0x2d72 <vTaskDelete+0xe4>
        {
            if( pxTCB == pxCurrentTCB )
    2d5c:	20 91 a6 06 	lds	r18, 0x06A6
    2d60:	30 91 a7 06 	lds	r19, 0x06A7
    2d64:	89 81       	ldd	r24, Y+1	; 0x01
    2d66:	9a 81       	ldd	r25, Y+2	; 0x02
    2d68:	82 17       	cp	r24, r18
    2d6a:	93 07       	cpc	r25, r19
    2d6c:	11 f4       	brne	.+4      	; 0x2d72 <vTaskDelete+0xe4>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    2d6e:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    2d72:	26 96       	adiw	r28, 0x06	; 6
    2d74:	0f b6       	in	r0, 0x3f	; 63
    2d76:	f8 94       	cli
    2d78:	de bf       	out	0x3e, r29	; 62
    2d7a:	0f be       	out	0x3f, r0	; 63
    2d7c:	cd bf       	out	0x3d, r28	; 61
    2d7e:	cf 91       	pop	r28
    2d80:	df 91       	pop	r29
    2d82:	08 95       	ret

00002d84 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    2d84:	df 93       	push	r29
    2d86:	cf 93       	push	r28
    2d88:	cd b7       	in	r28, 0x3d	; 61
    2d8a:	de b7       	in	r29, 0x3e	; 62
    2d8c:	2a 97       	sbiw	r28, 0x0a	; 10
    2d8e:	0f b6       	in	r0, 0x3f	; 63
    2d90:	f8 94       	cli
    2d92:	de bf       	out	0x3e, r29	; 62
    2d94:	0f be       	out	0x3f, r0	; 63
    2d96:	cd bf       	out	0x3d, r28	; 61
    2d98:	98 87       	std	Y+8, r25	; 0x08
    2d9a:	8f 83       	std	Y+7, r24	; 0x07
    2d9c:	7a 87       	std	Y+10, r23	; 0x0a
    2d9e:	69 87       	std	Y+9, r22	; 0x09
        TickType_t xTimeToWake;
        BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    2da0:	1b 82       	std	Y+3, r1	; 0x03

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    2da2:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    2da6:	80 91 aa 06 	lds	r24, 0x06AA
    2daa:	90 91 ab 06 	lds	r25, 0x06AB
    2dae:	9a 83       	std	Y+2, r25	; 0x02
    2db0:	89 83       	std	Y+1, r24	; 0x01

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2db2:	ef 81       	ldd	r30, Y+7	; 0x07
    2db4:	f8 85       	ldd	r31, Y+8	; 0x08
    2db6:	20 81       	ld	r18, Z
    2db8:	31 81       	ldd	r19, Z+1	; 0x01
    2dba:	89 85       	ldd	r24, Y+9	; 0x09
    2dbc:	9a 85       	ldd	r25, Y+10	; 0x0a
    2dbe:	82 0f       	add	r24, r18
    2dc0:	93 1f       	adc	r25, r19
    2dc2:	9e 83       	std	Y+6, r25	; 0x06
    2dc4:	8d 83       	std	Y+5, r24	; 0x05

            if( xConstTickCount < *pxPreviousWakeTime )
    2dc6:	ef 81       	ldd	r30, Y+7	; 0x07
    2dc8:	f8 85       	ldd	r31, Y+8	; 0x08
    2dca:	20 81       	ld	r18, Z
    2dcc:	31 81       	ldd	r19, Z+1	; 0x01
    2dce:	89 81       	ldd	r24, Y+1	; 0x01
    2dd0:	9a 81       	ldd	r25, Y+2	; 0x02
    2dd2:	82 17       	cp	r24, r18
    2dd4:	93 07       	cpc	r25, r19
    2dd6:	98 f4       	brcc	.+38     	; 0x2dfe <xTaskDelayUntil+0x7a>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    2dd8:	ef 81       	ldd	r30, Y+7	; 0x07
    2dda:	f8 85       	ldd	r31, Y+8	; 0x08
    2ddc:	20 81       	ld	r18, Z
    2dde:	31 81       	ldd	r19, Z+1	; 0x01
    2de0:	8d 81       	ldd	r24, Y+5	; 0x05
    2de2:	9e 81       	ldd	r25, Y+6	; 0x06
    2de4:	82 17       	cp	r24, r18
    2de6:	93 07       	cpc	r25, r19
    2de8:	e0 f4       	brcc	.+56     	; 0x2e22 <xTaskDelayUntil+0x9e>
    2dea:	2d 81       	ldd	r18, Y+5	; 0x05
    2dec:	3e 81       	ldd	r19, Y+6	; 0x06
    2dee:	89 81       	ldd	r24, Y+1	; 0x01
    2df0:	9a 81       	ldd	r25, Y+2	; 0x02
    2df2:	82 17       	cp	r24, r18
    2df4:	93 07       	cpc	r25, r19
    2df6:	a8 f4       	brcc	.+42     	; 0x2e22 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    2df8:	81 e0       	ldi	r24, 0x01	; 1
    2dfa:	8b 83       	std	Y+3, r24	; 0x03
    2dfc:	12 c0       	rjmp	.+36     	; 0x2e22 <xTaskDelayUntil+0x9e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    2dfe:	ef 81       	ldd	r30, Y+7	; 0x07
    2e00:	f8 85       	ldd	r31, Y+8	; 0x08
    2e02:	20 81       	ld	r18, Z
    2e04:	31 81       	ldd	r19, Z+1	; 0x01
    2e06:	8d 81       	ldd	r24, Y+5	; 0x05
    2e08:	9e 81       	ldd	r25, Y+6	; 0x06
    2e0a:	82 17       	cp	r24, r18
    2e0c:	93 07       	cpc	r25, r19
    2e0e:	38 f0       	brcs	.+14     	; 0x2e1e <xTaskDelayUntil+0x9a>
    2e10:	2d 81       	ldd	r18, Y+5	; 0x05
    2e12:	3e 81       	ldd	r19, Y+6	; 0x06
    2e14:	89 81       	ldd	r24, Y+1	; 0x01
    2e16:	9a 81       	ldd	r25, Y+2	; 0x02
    2e18:	82 17       	cp	r24, r18
    2e1a:	93 07       	cpc	r25, r19
    2e1c:	10 f4       	brcc	.+4      	; 0x2e22 <xTaskDelayUntil+0x9e>
                {
                    xShouldDelay = pdTRUE;
    2e1e:	81 e0       	ldi	r24, 0x01	; 1
    2e20:	8b 83       	std	Y+3, r24	; 0x03
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    2e22:	ef 81       	ldd	r30, Y+7	; 0x07
    2e24:	f8 85       	ldd	r31, Y+8	; 0x08
    2e26:	8d 81       	ldd	r24, Y+5	; 0x05
    2e28:	9e 81       	ldd	r25, Y+6	; 0x06
    2e2a:	91 83       	std	Z+1, r25	; 0x01
    2e2c:	80 83       	st	Z, r24

            if( xShouldDelay != pdFALSE )
    2e2e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e30:	88 23       	and	r24, r24
    2e32:	49 f0       	breq	.+18     	; 0x2e46 <xTaskDelayUntil+0xc2>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    2e34:	8d 81       	ldd	r24, Y+5	; 0x05
    2e36:	9e 81       	ldd	r25, Y+6	; 0x06
    2e38:	29 81       	ldd	r18, Y+1	; 0x01
    2e3a:	3a 81       	ldd	r19, Y+2	; 0x02
    2e3c:	82 1b       	sub	r24, r18
    2e3e:	93 0b       	sbc	r25, r19
    2e40:	60 e0       	ldi	r22, 0x00	; 0
    2e42:	0e 94 d7 27 	call	0x4fae	; 0x4fae <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    2e46:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>
    2e4a:	8c 83       	std	Y+4, r24	; 0x04

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    2e4c:	8c 81       	ldd	r24, Y+4	; 0x04
    2e4e:	88 23       	and	r24, r24
    2e50:	11 f4       	brne	.+4      	; 0x2e56 <xTaskDelayUntil+0xd2>
        {
            portYIELD_WITHIN_API();
    2e52:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    2e56:	8b 81       	ldd	r24, Y+3	; 0x03
    }
    2e58:	2a 96       	adiw	r28, 0x0a	; 10
    2e5a:	0f b6       	in	r0, 0x3f	; 63
    2e5c:	f8 94       	cli
    2e5e:	de bf       	out	0x3e, r29	; 62
    2e60:	0f be       	out	0x3f, r0	; 63
    2e62:	cd bf       	out	0x3d, r28	; 61
    2e64:	cf 91       	pop	r28
    2e66:	df 91       	pop	r29
    2e68:	08 95       	ret

00002e6a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    2e6a:	df 93       	push	r29
    2e6c:	cf 93       	push	r28
    2e6e:	00 d0       	rcall	.+0      	; 0x2e70 <vTaskDelay+0x6>
    2e70:	0f 92       	push	r0
    2e72:	cd b7       	in	r28, 0x3d	; 61
    2e74:	de b7       	in	r29, 0x3e	; 62
    2e76:	9b 83       	std	Y+3, r25	; 0x03
    2e78:	8a 83       	std	Y+2, r24	; 0x02
        BaseType_t xAlreadyYielded = pdFALSE;
    2e7a:	19 82       	std	Y+1, r1	; 0x01

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    2e7c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e7e:	9b 81       	ldd	r25, Y+3	; 0x03
    2e80:	00 97       	sbiw	r24, 0x00	; 0
    2e82:	51 f0       	breq	.+20     	; 0x2e98 <vTaskDelay+0x2e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    2e84:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    2e88:	8a 81       	ldd	r24, Y+2	; 0x02
    2e8a:	9b 81       	ldd	r25, Y+3	; 0x03
    2e8c:	60 e0       	ldi	r22, 0x00	; 0
    2e8e:	0e 94 d7 27 	call	0x4fae	; 0x4fae <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    2e92:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>
    2e96:	89 83       	std	Y+1, r24	; 0x01
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    2e98:	89 81       	ldd	r24, Y+1	; 0x01
    2e9a:	88 23       	and	r24, r24
    2e9c:	11 f4       	brne	.+4      	; 0x2ea2 <vTaskDelay+0x38>
        {
            portYIELD_WITHIN_API();
    2e9e:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    2ea2:	0f 90       	pop	r0
    2ea4:	0f 90       	pop	r0
    2ea6:	0f 90       	pop	r0
    2ea8:	cf 91       	pop	r28
    2eaa:	df 91       	pop	r29
    2eac:	08 95       	ret

00002eae <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    2eae:	ef 92       	push	r14
    2eb0:	ff 92       	push	r15
    2eb2:	0f 93       	push	r16
    2eb4:	df 93       	push	r29
    2eb6:	cf 93       	push	r28
    2eb8:	00 d0       	rcall	.+0      	; 0x2eba <vTaskStartScheduler+0xc>
    2eba:	cd b7       	in	r28, 0x3d	; 61
    2ebc:	de b7       	in	r29, 0x3e	; 62
            }
        }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
        {
            /* The Idle task is being created using dynamically allocated RAM. */
            xReturn = xTaskCreate( prvIdleTask,
    2ebe:	8e e5       	ldi	r24, 0x5E	; 94
    2ec0:	9f e1       	ldi	r25, 0x1F	; 31
    2ec2:	20 e6       	ldi	r18, 0x60	; 96
    2ec4:	30 e0       	ldi	r19, 0x00	; 0
    2ec6:	e5 eb       	ldi	r30, 0xB5	; 181
    2ec8:	f6 e0       	ldi	r31, 0x06	; 6
    2eca:	b9 01       	movw	r22, r18
    2ecc:	45 e5       	ldi	r20, 0x55	; 85
    2ece:	50 e0       	ldi	r21, 0x00	; 0
    2ed0:	20 e0       	ldi	r18, 0x00	; 0
    2ed2:	30 e0       	ldi	r19, 0x00	; 0
    2ed4:	00 e0       	ldi	r16, 0x00	; 0
    2ed6:	7f 01       	movw	r14, r30
    2ed8:	0e 94 4d 14 	call	0x289a	; 0x289a <xTaskCreate>
    2edc:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif /* configSUPPORT_STATIC_ALLOCATION */

    #if ( configUSE_TIMERS == 1 )
        {
            if( xReturn == pdPASS )
    2ede:	89 81       	ldd	r24, Y+1	; 0x01
    2ee0:	81 30       	cpi	r24, 0x01	; 1
    2ee2:	19 f4       	brne	.+6      	; 0x2eea <vTaskStartScheduler+0x3c>
            {
                xReturn = xTimerCreateTimerTask();
    2ee4:	0e 94 3d 28 	call	0x507a	; 0x507a <xTimerCreateTimerTask>
    2ee8:	89 83       	std	Y+1, r24	; 0x01
                mtCOVERAGE_TEST_MARKER();
            }
        }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    2eea:	89 81       	ldd	r24, Y+1	; 0x01
    2eec:	81 30       	cpi	r24, 0x01	; 1
    2eee:	81 f4       	brne	.+32     	; 0x2f10 <vTaskStartScheduler+0x62>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    2ef0:	f8 94       	cli
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */

        xNextTaskUnblockTime = portMAX_DELAY;
    2ef2:	8f ef       	ldi	r24, 0xFF	; 255
    2ef4:	9f ef       	ldi	r25, 0xFF	; 255
    2ef6:	90 93 b4 06 	sts	0x06B4, r25
    2efa:	80 93 b3 06 	sts	0x06B3, r24
        xSchedulerRunning = pdTRUE;
    2efe:	81 e0       	ldi	r24, 0x01	; 1
    2f00:	80 93 ad 06 	sts	0x06AD, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    2f04:	10 92 ab 06 	sts	0x06AB, r1
    2f08:	10 92 aa 06 	sts	0x06AA, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        if( xPortStartScheduler() != pdFALSE )
    2f0c:	0e 94 4c 02 	call	0x498	; 0x498 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    2f10:	80 91 8a 00 	lds	r24, 0x008A
}
    2f14:	0f 90       	pop	r0
    2f16:	0f 90       	pop	r0
    2f18:	cf 91       	pop	r28
    2f1a:	df 91       	pop	r29
    2f1c:	0f 91       	pop	r16
    2f1e:	ff 90       	pop	r15
    2f20:	ef 90       	pop	r14
    2f22:	08 95       	ret

00002f24 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2f24:	df 93       	push	r29
    2f26:	cf 93       	push	r28
    2f28:	cd b7       	in	r28, 0x3d	; 61
    2f2a:	de b7       	in	r29, 0x3e	; 62
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    2f2c:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    2f2e:	10 92 ad 06 	sts	0x06AD, r1
    vPortEndScheduler();
    2f32:	0e 94 81 02 	call	0x502	; 0x502 <vPortEndScheduler>
}
    2f36:	cf 91       	pop	r28
    2f38:	df 91       	pop	r29
    2f3a:	08 95       	ret

00002f3c <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2f3c:	df 93       	push	r29
    2f3e:	cf 93       	push	r28
    2f40:	cd b7       	in	r28, 0x3d	; 61
    2f42:	de b7       	in	r29, 0x3e	; 62
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    2f44:	80 91 b7 06 	lds	r24, 0x06B7
    2f48:	8f 5f       	subi	r24, 0xFF	; 255
    2f4a:	80 93 b7 06 	sts	0x06B7, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    2f4e:	cf 91       	pop	r28
    2f50:	df 91       	pop	r29
    2f52:	08 95       	ret

00002f54 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    2f54:	df 93       	push	r29
    2f56:	cf 93       	push	r28
    2f58:	cd b7       	in	r28, 0x3d	; 61
    2f5a:	de b7       	in	r29, 0x3e	; 62
    2f5c:	2b 97       	sbiw	r28, 0x0b	; 11
    2f5e:	0f b6       	in	r0, 0x3f	; 63
    2f60:	f8 94       	cli
    2f62:	de bf       	out	0x3e, r29	; 62
    2f64:	0f be       	out	0x3f, r0	; 63
    2f66:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB = NULL;
    2f68:	1b 86       	std	Y+11, r1	; 0x0b
    2f6a:	1a 86       	std	Y+10, r1	; 0x0a
    BaseType_t xAlreadyYielded = pdFALSE;
    2f6c:	19 86       	std	Y+9, r1	; 0x09
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    2f6e:	0f b6       	in	r0, 0x3f	; 63
    2f70:	f8 94       	cli
    2f72:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    2f74:	80 91 b7 06 	lds	r24, 0x06B7
    2f78:	81 50       	subi	r24, 0x01	; 1
    2f7a:	80 93 b7 06 	sts	0x06B7, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2f7e:	80 91 b7 06 	lds	r24, 0x06B7
    2f82:	88 23       	and	r24, r24
    2f84:	09 f0       	breq	.+2      	; 0x2f88 <xTaskResumeAll+0x34>
    2f86:	2a c1       	rjmp	.+596    	; 0x31dc <xTaskResumeAll+0x288>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    2f88:	80 91 a9 06 	lds	r24, 0x06A9
    2f8c:	88 23       	and	r24, r24
    2f8e:	09 f4       	brne	.+2      	; 0x2f92 <xTaskResumeAll+0x3e>
    2f90:	25 c1       	rjmp	.+586    	; 0x31dc <xTaskResumeAll+0x288>
    2f92:	f3 c0       	rjmp	.+486    	; 0x317a <xTaskResumeAll+0x226>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2f94:	e0 91 f7 06 	lds	r30, 0x06F7
    2f98:	f0 91 f8 06 	lds	r31, 0x06F8
    2f9c:	86 81       	ldd	r24, Z+6	; 0x06
    2f9e:	97 81       	ldd	r25, Z+7	; 0x07
    2fa0:	9b 87       	std	Y+11, r25	; 0x0b
    2fa2:	8a 87       	std	Y+10, r24	; 0x0a
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    2fa4:	ea 85       	ldd	r30, Y+10	; 0x0a
    2fa6:	fb 85       	ldd	r31, Y+11	; 0x0b
    2fa8:	84 89       	ldd	r24, Z+20	; 0x14
    2faa:	95 89       	ldd	r25, Z+21	; 0x15
    2fac:	98 87       	std	Y+8, r25	; 0x08
    2fae:	8f 83       	std	Y+7, r24	; 0x07
    2fb0:	ea 85       	ldd	r30, Y+10	; 0x0a
    2fb2:	fb 85       	ldd	r31, Y+11	; 0x0b
    2fb4:	a6 85       	ldd	r26, Z+14	; 0x0e
    2fb6:	b7 85       	ldd	r27, Z+15	; 0x0f
    2fb8:	ea 85       	ldd	r30, Y+10	; 0x0a
    2fba:	fb 85       	ldd	r31, Y+11	; 0x0b
    2fbc:	80 89       	ldd	r24, Z+16	; 0x10
    2fbe:	91 89       	ldd	r25, Z+17	; 0x11
    2fc0:	15 96       	adiw	r26, 0x05	; 5
    2fc2:	9c 93       	st	X, r25
    2fc4:	8e 93       	st	-X, r24
    2fc6:	14 97       	sbiw	r26, 0x04	; 4
    2fc8:	ea 85       	ldd	r30, Y+10	; 0x0a
    2fca:	fb 85       	ldd	r31, Y+11	; 0x0b
    2fcc:	a0 89       	ldd	r26, Z+16	; 0x10
    2fce:	b1 89       	ldd	r27, Z+17	; 0x11
    2fd0:	ea 85       	ldd	r30, Y+10	; 0x0a
    2fd2:	fb 85       	ldd	r31, Y+11	; 0x0b
    2fd4:	86 85       	ldd	r24, Z+14	; 0x0e
    2fd6:	97 85       	ldd	r25, Z+15	; 0x0f
    2fd8:	13 96       	adiw	r26, 0x03	; 3
    2fda:	9c 93       	st	X, r25
    2fdc:	8e 93       	st	-X, r24
    2fde:	12 97       	sbiw	r26, 0x02	; 2
    2fe0:	ef 81       	ldd	r30, Y+7	; 0x07
    2fe2:	f8 85       	ldd	r31, Y+8	; 0x08
    2fe4:	21 81       	ldd	r18, Z+1	; 0x01
    2fe6:	32 81       	ldd	r19, Z+2	; 0x02
    2fe8:	8a 85       	ldd	r24, Y+10	; 0x0a
    2fea:	9b 85       	ldd	r25, Y+11	; 0x0b
    2fec:	0c 96       	adiw	r24, 0x0c	; 12
    2fee:	28 17       	cp	r18, r24
    2ff0:	39 07       	cpc	r19, r25
    2ff2:	41 f4       	brne	.+16     	; 0x3004 <xTaskResumeAll+0xb0>
    2ff4:	ea 85       	ldd	r30, Y+10	; 0x0a
    2ff6:	fb 85       	ldd	r31, Y+11	; 0x0b
    2ff8:	80 89       	ldd	r24, Z+16	; 0x10
    2ffa:	91 89       	ldd	r25, Z+17	; 0x11
    2ffc:	ef 81       	ldd	r30, Y+7	; 0x07
    2ffe:	f8 85       	ldd	r31, Y+8	; 0x08
    3000:	92 83       	std	Z+2, r25	; 0x02
    3002:	81 83       	std	Z+1, r24	; 0x01
    3004:	ea 85       	ldd	r30, Y+10	; 0x0a
    3006:	fb 85       	ldd	r31, Y+11	; 0x0b
    3008:	15 8a       	std	Z+21, r1	; 0x15
    300a:	14 8a       	std	Z+20, r1	; 0x14
    300c:	ef 81       	ldd	r30, Y+7	; 0x07
    300e:	f8 85       	ldd	r31, Y+8	; 0x08
    3010:	80 81       	ld	r24, Z
    3012:	81 50       	subi	r24, 0x01	; 1
    3014:	ef 81       	ldd	r30, Y+7	; 0x07
    3016:	f8 85       	ldd	r31, Y+8	; 0x08
    3018:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    301a:	ea 85       	ldd	r30, Y+10	; 0x0a
    301c:	fb 85       	ldd	r31, Y+11	; 0x0b
    301e:	82 85       	ldd	r24, Z+10	; 0x0a
    3020:	93 85       	ldd	r25, Z+11	; 0x0b
    3022:	9e 83       	std	Y+6, r25	; 0x06
    3024:	8d 83       	std	Y+5, r24	; 0x05
    3026:	ea 85       	ldd	r30, Y+10	; 0x0a
    3028:	fb 85       	ldd	r31, Y+11	; 0x0b
    302a:	a4 81       	ldd	r26, Z+4	; 0x04
    302c:	b5 81       	ldd	r27, Z+5	; 0x05
    302e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3030:	fb 85       	ldd	r31, Y+11	; 0x0b
    3032:	86 81       	ldd	r24, Z+6	; 0x06
    3034:	97 81       	ldd	r25, Z+7	; 0x07
    3036:	15 96       	adiw	r26, 0x05	; 5
    3038:	9c 93       	st	X, r25
    303a:	8e 93       	st	-X, r24
    303c:	14 97       	sbiw	r26, 0x04	; 4
    303e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3040:	fb 85       	ldd	r31, Y+11	; 0x0b
    3042:	a6 81       	ldd	r26, Z+6	; 0x06
    3044:	b7 81       	ldd	r27, Z+7	; 0x07
    3046:	ea 85       	ldd	r30, Y+10	; 0x0a
    3048:	fb 85       	ldd	r31, Y+11	; 0x0b
    304a:	84 81       	ldd	r24, Z+4	; 0x04
    304c:	95 81       	ldd	r25, Z+5	; 0x05
    304e:	13 96       	adiw	r26, 0x03	; 3
    3050:	9c 93       	st	X, r25
    3052:	8e 93       	st	-X, r24
    3054:	12 97       	sbiw	r26, 0x02	; 2
    3056:	ed 81       	ldd	r30, Y+5	; 0x05
    3058:	fe 81       	ldd	r31, Y+6	; 0x06
    305a:	21 81       	ldd	r18, Z+1	; 0x01
    305c:	32 81       	ldd	r19, Z+2	; 0x02
    305e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3060:	9b 85       	ldd	r25, Y+11	; 0x0b
    3062:	02 96       	adiw	r24, 0x02	; 2
    3064:	28 17       	cp	r18, r24
    3066:	39 07       	cpc	r19, r25
    3068:	41 f4       	brne	.+16     	; 0x307a <xTaskResumeAll+0x126>
    306a:	ea 85       	ldd	r30, Y+10	; 0x0a
    306c:	fb 85       	ldd	r31, Y+11	; 0x0b
    306e:	86 81       	ldd	r24, Z+6	; 0x06
    3070:	97 81       	ldd	r25, Z+7	; 0x07
    3072:	ed 81       	ldd	r30, Y+5	; 0x05
    3074:	fe 81       	ldd	r31, Y+6	; 0x06
    3076:	92 83       	std	Z+2, r25	; 0x02
    3078:	81 83       	std	Z+1, r24	; 0x01
    307a:	ea 85       	ldd	r30, Y+10	; 0x0a
    307c:	fb 85       	ldd	r31, Y+11	; 0x0b
    307e:	13 86       	std	Z+11, r1	; 0x0b
    3080:	12 86       	std	Z+10, r1	; 0x0a
    3082:	ed 81       	ldd	r30, Y+5	; 0x05
    3084:	fe 81       	ldd	r31, Y+6	; 0x06
    3086:	80 81       	ld	r24, Z
    3088:	81 50       	subi	r24, 0x01	; 1
    308a:	ed 81       	ldd	r30, Y+5	; 0x05
    308c:	fe 81       	ldd	r31, Y+6	; 0x06
    308e:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    3090:	ea 85       	ldd	r30, Y+10	; 0x0a
    3092:	fb 85       	ldd	r31, Y+11	; 0x0b
    3094:	96 89       	ldd	r25, Z+22	; 0x16
    3096:	80 91 ac 06 	lds	r24, 0x06AC
    309a:	89 17       	cp	r24, r25
    309c:	28 f4       	brcc	.+10     	; 0x30a8 <xTaskResumeAll+0x154>
    309e:	ea 85       	ldd	r30, Y+10	; 0x0a
    30a0:	fb 85       	ldd	r31, Y+11	; 0x0b
    30a2:	86 89       	ldd	r24, Z+22	; 0x16
    30a4:	80 93 ac 06 	sts	0x06AC, r24
    30a8:	ea 85       	ldd	r30, Y+10	; 0x0a
    30aa:	fb 85       	ldd	r31, Y+11	; 0x0b
    30ac:	86 89       	ldd	r24, Z+22	; 0x16
    30ae:	28 2f       	mov	r18, r24
    30b0:	30 e0       	ldi	r19, 0x00	; 0
    30b2:	c9 01       	movw	r24, r18
    30b4:	88 0f       	add	r24, r24
    30b6:	99 1f       	adc	r25, r25
    30b8:	88 0f       	add	r24, r24
    30ba:	99 1f       	adc	r25, r25
    30bc:	88 0f       	add	r24, r24
    30be:	99 1f       	adc	r25, r25
    30c0:	82 0f       	add	r24, r18
    30c2:	93 1f       	adc	r25, r19
    30c4:	fc 01       	movw	r30, r24
    30c6:	e8 54       	subi	r30, 0x48	; 72
    30c8:	f9 4f       	sbci	r31, 0xF9	; 249
    30ca:	81 81       	ldd	r24, Z+1	; 0x01
    30cc:	92 81       	ldd	r25, Z+2	; 0x02
    30ce:	9c 83       	std	Y+4, r25	; 0x04
    30d0:	8b 83       	std	Y+3, r24	; 0x03
    30d2:	ea 85       	ldd	r30, Y+10	; 0x0a
    30d4:	fb 85       	ldd	r31, Y+11	; 0x0b
    30d6:	8b 81       	ldd	r24, Y+3	; 0x03
    30d8:	9c 81       	ldd	r25, Y+4	; 0x04
    30da:	95 83       	std	Z+5, r25	; 0x05
    30dc:	84 83       	std	Z+4, r24	; 0x04
    30de:	eb 81       	ldd	r30, Y+3	; 0x03
    30e0:	fc 81       	ldd	r31, Y+4	; 0x04
    30e2:	84 81       	ldd	r24, Z+4	; 0x04
    30e4:	95 81       	ldd	r25, Z+5	; 0x05
    30e6:	ea 85       	ldd	r30, Y+10	; 0x0a
    30e8:	fb 85       	ldd	r31, Y+11	; 0x0b
    30ea:	97 83       	std	Z+7, r25	; 0x07
    30ec:	86 83       	std	Z+6, r24	; 0x06
    30ee:	eb 81       	ldd	r30, Y+3	; 0x03
    30f0:	fc 81       	ldd	r31, Y+4	; 0x04
    30f2:	04 80       	ldd	r0, Z+4	; 0x04
    30f4:	f5 81       	ldd	r31, Z+5	; 0x05
    30f6:	e0 2d       	mov	r30, r0
    30f8:	8a 85       	ldd	r24, Y+10	; 0x0a
    30fa:	9b 85       	ldd	r25, Y+11	; 0x0b
    30fc:	02 96       	adiw	r24, 0x02	; 2
    30fe:	93 83       	std	Z+3, r25	; 0x03
    3100:	82 83       	std	Z+2, r24	; 0x02
    3102:	8a 85       	ldd	r24, Y+10	; 0x0a
    3104:	9b 85       	ldd	r25, Y+11	; 0x0b
    3106:	02 96       	adiw	r24, 0x02	; 2
    3108:	eb 81       	ldd	r30, Y+3	; 0x03
    310a:	fc 81       	ldd	r31, Y+4	; 0x04
    310c:	95 83       	std	Z+5, r25	; 0x05
    310e:	84 83       	std	Z+4, r24	; 0x04
    3110:	ea 85       	ldd	r30, Y+10	; 0x0a
    3112:	fb 85       	ldd	r31, Y+11	; 0x0b
    3114:	86 89       	ldd	r24, Z+22	; 0x16
    3116:	28 2f       	mov	r18, r24
    3118:	30 e0       	ldi	r19, 0x00	; 0
    311a:	c9 01       	movw	r24, r18
    311c:	88 0f       	add	r24, r24
    311e:	99 1f       	adc	r25, r25
    3120:	88 0f       	add	r24, r24
    3122:	99 1f       	adc	r25, r25
    3124:	88 0f       	add	r24, r24
    3126:	99 1f       	adc	r25, r25
    3128:	82 0f       	add	r24, r18
    312a:	93 1f       	adc	r25, r19
    312c:	88 54       	subi	r24, 0x48	; 72
    312e:	99 4f       	sbci	r25, 0xF9	; 249
    3130:	ea 85       	ldd	r30, Y+10	; 0x0a
    3132:	fb 85       	ldd	r31, Y+11	; 0x0b
    3134:	93 87       	std	Z+11, r25	; 0x0b
    3136:	82 87       	std	Z+10, r24	; 0x0a
    3138:	ea 85       	ldd	r30, Y+10	; 0x0a
    313a:	fb 85       	ldd	r31, Y+11	; 0x0b
    313c:	86 89       	ldd	r24, Z+22	; 0x16
    313e:	28 2f       	mov	r18, r24
    3140:	30 e0       	ldi	r19, 0x00	; 0
    3142:	c9 01       	movw	r24, r18
    3144:	88 0f       	add	r24, r24
    3146:	99 1f       	adc	r25, r25
    3148:	88 0f       	add	r24, r24
    314a:	99 1f       	adc	r25, r25
    314c:	88 0f       	add	r24, r24
    314e:	99 1f       	adc	r25, r25
    3150:	82 0f       	add	r24, r18
    3152:	93 1f       	adc	r25, r19
    3154:	fc 01       	movw	r30, r24
    3156:	e8 54       	subi	r30, 0x48	; 72
    3158:	f9 4f       	sbci	r31, 0xF9	; 249
    315a:	80 81       	ld	r24, Z
    315c:	8f 5f       	subi	r24, 0xFF	; 255
    315e:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3160:	ea 85       	ldd	r30, Y+10	; 0x0a
    3162:	fb 85       	ldd	r31, Y+11	; 0x0b
    3164:	96 89       	ldd	r25, Z+22	; 0x16
    3166:	e0 91 a6 06 	lds	r30, 0x06A6
    316a:	f0 91 a7 06 	lds	r31, 0x06A7
    316e:	86 89       	ldd	r24, Z+22	; 0x16
    3170:	98 17       	cp	r25, r24
    3172:	18 f0       	brcs	.+6      	; 0x317a <xTaskResumeAll+0x226>
                    {
                        xYieldPending = pdTRUE;
    3174:	81 e0       	ldi	r24, 0x01	; 1
    3176:	80 93 b0 06 	sts	0x06B0, r24
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    317a:	80 91 f2 06 	lds	r24, 0x06F2
    317e:	88 23       	and	r24, r24
    3180:	09 f0       	breq	.+2      	; 0x3184 <xTaskResumeAll+0x230>
    3182:	08 cf       	rjmp	.-496    	; 0x2f94 <xTaskResumeAll+0x40>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    3184:	8a 85       	ldd	r24, Y+10	; 0x0a
    3186:	9b 85       	ldd	r25, Y+11	; 0x0b
    3188:	00 97       	sbiw	r24, 0x00	; 0
    318a:	11 f0       	breq	.+4      	; 0x3190 <xTaskResumeAll+0x23c>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    318c:	0e 94 f0 1f 	call	0x3fe0	; 0x3fe0 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    3190:	80 91 ae 06 	lds	r24, 0x06AE
    3194:	90 91 af 06 	lds	r25, 0x06AF
    3198:	9a 83       	std	Y+2, r25	; 0x02
    319a:	89 83       	std	Y+1, r24	; 0x01

                    if( xPendedCounts > ( TickType_t ) 0U )
    319c:	89 81       	ldd	r24, Y+1	; 0x01
    319e:	9a 81       	ldd	r25, Y+2	; 0x02
    31a0:	00 97       	sbiw	r24, 0x00	; 0
    31a2:	a1 f0       	breq	.+40     	; 0x31cc <xTaskResumeAll+0x278>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    31a4:	0e 94 77 19 	call	0x32ee	; 0x32ee <xTaskIncrementTick>
    31a8:	88 23       	and	r24, r24
    31aa:	19 f0       	breq	.+6      	; 0x31b2 <xTaskResumeAll+0x25e>
                            {
                                xYieldPending = pdTRUE;
    31ac:	81 e0       	ldi	r24, 0x01	; 1
    31ae:	80 93 b0 06 	sts	0x06B0, r24
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    31b2:	89 81       	ldd	r24, Y+1	; 0x01
    31b4:	9a 81       	ldd	r25, Y+2	; 0x02
    31b6:	01 97       	sbiw	r24, 0x01	; 1
    31b8:	9a 83       	std	Y+2, r25	; 0x02
    31ba:	89 83       	std	Y+1, r24	; 0x01
                        } while( xPendedCounts > ( TickType_t ) 0U );
    31bc:	89 81       	ldd	r24, Y+1	; 0x01
    31be:	9a 81       	ldd	r25, Y+2	; 0x02
    31c0:	00 97       	sbiw	r24, 0x00	; 0
    31c2:	81 f7       	brne	.-32     	; 0x31a4 <xTaskResumeAll+0x250>

                        xPendedTicks = 0;
    31c4:	10 92 af 06 	sts	0x06AF, r1
    31c8:	10 92 ae 06 	sts	0x06AE, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    31cc:	80 91 b0 06 	lds	r24, 0x06B0
    31d0:	88 23       	and	r24, r24
    31d2:	21 f0       	breq	.+8      	; 0x31dc <xTaskResumeAll+0x288>
                {
                    #if ( configUSE_PREEMPTION != 0 )
                        {
                            xAlreadyYielded = pdTRUE;
    31d4:	81 e0       	ldi	r24, 0x01	; 1
    31d6:	89 87       	std	Y+9, r24	; 0x09
                        }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    31d8:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    31dc:	0f 90       	pop	r0
    31de:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
    31e0:	89 85       	ldd	r24, Y+9	; 0x09
}
    31e2:	2b 96       	adiw	r28, 0x0b	; 11
    31e4:	0f b6       	in	r0, 0x3f	; 63
    31e6:	f8 94       	cli
    31e8:	de bf       	out	0x3e, r29	; 62
    31ea:	0f be       	out	0x3f, r0	; 63
    31ec:	cd bf       	out	0x3d, r28	; 61
    31ee:	cf 91       	pop	r28
    31f0:	df 91       	pop	r29
    31f2:	08 95       	ret

000031f4 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    31f4:	df 93       	push	r29
    31f6:	cf 93       	push	r28
    31f8:	00 d0       	rcall	.+0      	; 0x31fa <xTaskGetTickCount+0x6>
    31fa:	cd b7       	in	r28, 0x3d	; 61
    31fc:	de b7       	in	r29, 0x3e	; 62
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    31fe:	0f b6       	in	r0, 0x3f	; 63
    3200:	f8 94       	cli
    3202:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    3204:	80 91 aa 06 	lds	r24, 0x06AA
    3208:	90 91 ab 06 	lds	r25, 0x06AB
    320c:	9a 83       	std	Y+2, r25	; 0x02
    320e:	89 83       	std	Y+1, r24	; 0x01
    }
    portTICK_TYPE_EXIT_CRITICAL();
    3210:	0f 90       	pop	r0
    3212:	0f be       	out	0x3f, r0	; 63

    return xTicks;
    3214:	89 81       	ldd	r24, Y+1	; 0x01
    3216:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3218:	0f 90       	pop	r0
    321a:	0f 90       	pop	r0
    321c:	cf 91       	pop	r28
    321e:	df 91       	pop	r29
    3220:	08 95       	ret

00003222 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3222:	df 93       	push	r29
    3224:	cf 93       	push	r28
    3226:	00 d0       	rcall	.+0      	; 0x3228 <xTaskGetTickCountFromISR+0x6>
    3228:	0f 92       	push	r0
    322a:	cd b7       	in	r28, 0x3d	; 61
    322c:	de b7       	in	r29, 0x3e	; 62
     * safe API to ensure interrupt entry is as fast and as simple as possible.
     * More information (albeit Cortex-M specific) is provided on the following
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    322e:	19 82       	std	Y+1, r1	; 0x01
    {
        xReturn = xTickCount;
    3230:	80 91 aa 06 	lds	r24, 0x06AA
    3234:	90 91 ab 06 	lds	r25, 0x06AB
    3238:	9b 83       	std	Y+3, r25	; 0x03
    323a:	8a 83       	std	Y+2, r24	; 0x02
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
    323c:	8a 81       	ldd	r24, Y+2	; 0x02
    323e:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3240:	0f 90       	pop	r0
    3242:	0f 90       	pop	r0
    3244:	0f 90       	pop	r0
    3246:	cf 91       	pop	r28
    3248:	df 91       	pop	r29
    324a:	08 95       	ret

0000324c <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    324c:	df 93       	push	r29
    324e:	cf 93       	push	r28
    3250:	cd b7       	in	r28, 0x3d	; 61
    3252:	de b7       	in	r29, 0x3e	; 62
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    3254:	80 91 a9 06 	lds	r24, 0x06A9
}
    3258:	cf 91       	pop	r28
    325a:	df 91       	pop	r29
    325c:	08 95       	ret

0000325e <pcTaskGetName>:
/*-----------------------------------------------------------*/

char * pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    325e:	df 93       	push	r29
    3260:	cf 93       	push	r28
    3262:	00 d0       	rcall	.+0      	; 0x3264 <pcTaskGetName+0x6>
    3264:	00 d0       	rcall	.+0      	; 0x3266 <pcTaskGetName+0x8>
    3266:	00 d0       	rcall	.+0      	; 0x3268 <pcTaskGetName+0xa>
    3268:	cd b7       	in	r28, 0x3d	; 61
    326a:	de b7       	in	r29, 0x3e	; 62
    326c:	9c 83       	std	Y+4, r25	; 0x04
    326e:	8b 83       	std	Y+3, r24	; 0x03
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    3270:	8b 81       	ldd	r24, Y+3	; 0x03
    3272:	9c 81       	ldd	r25, Y+4	; 0x04
    3274:	00 97       	sbiw	r24, 0x00	; 0
    3276:	39 f4       	brne	.+14     	; 0x3286 <pcTaskGetName+0x28>
    3278:	80 91 a6 06 	lds	r24, 0x06A6
    327c:	90 91 a7 06 	lds	r25, 0x06A7
    3280:	9e 83       	std	Y+6, r25	; 0x06
    3282:	8d 83       	std	Y+5, r24	; 0x05
    3284:	04 c0       	rjmp	.+8      	; 0x328e <pcTaskGetName+0x30>
    3286:	8b 81       	ldd	r24, Y+3	; 0x03
    3288:	9c 81       	ldd	r25, Y+4	; 0x04
    328a:	9e 83       	std	Y+6, r25	; 0x06
    328c:	8d 83       	std	Y+5, r24	; 0x05
    328e:	8d 81       	ldd	r24, Y+5	; 0x05
    3290:	9e 81       	ldd	r25, Y+6	; 0x06
    3292:	9a 83       	std	Y+2, r25	; 0x02
    3294:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
    3296:	89 81       	ldd	r24, Y+1	; 0x01
    3298:	9a 81       	ldd	r25, Y+2	; 0x02
    329a:	49 96       	adiw	r24, 0x19	; 25
}
    329c:	26 96       	adiw	r28, 0x06	; 6
    329e:	0f b6       	in	r0, 0x3f	; 63
    32a0:	f8 94       	cli
    32a2:	de bf       	out	0x3e, r29	; 62
    32a4:	0f be       	out	0x3f, r0	; 63
    32a6:	cd bf       	out	0x3d, r28	; 61
    32a8:	cf 91       	pop	r28
    32aa:	df 91       	pop	r29
    32ac:	08 95       	ret

000032ae <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    32ae:	df 93       	push	r29
    32b0:	cf 93       	push	r28
    32b2:	00 d0       	rcall	.+0      	; 0x32b4 <xTaskCatchUpTicks+0x6>
    32b4:	0f 92       	push	r0
    32b6:	cd b7       	in	r28, 0x3d	; 61
    32b8:	de b7       	in	r29, 0x3e	; 62
    32ba:	9b 83       	std	Y+3, r25	; 0x03
    32bc:	8a 83       	std	Y+2, r24	; 0x02
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    32be:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <vTaskSuspendAll>
    xPendedTicks += xTicksToCatchUp;
    32c2:	20 91 ae 06 	lds	r18, 0x06AE
    32c6:	30 91 af 06 	lds	r19, 0x06AF
    32ca:	8a 81       	ldd	r24, Y+2	; 0x02
    32cc:	9b 81       	ldd	r25, Y+3	; 0x03
    32ce:	82 0f       	add	r24, r18
    32d0:	93 1f       	adc	r25, r19
    32d2:	90 93 af 06 	sts	0x06AF, r25
    32d6:	80 93 ae 06 	sts	0x06AE, r24
    xYieldOccurred = xTaskResumeAll();
    32da:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>
    32de:	89 83       	std	Y+1, r24	; 0x01

    return xYieldOccurred;
    32e0:	89 81       	ldd	r24, Y+1	; 0x01
}
    32e2:	0f 90       	pop	r0
    32e4:	0f 90       	pop	r0
    32e6:	0f 90       	pop	r0
    32e8:	cf 91       	pop	r28
    32ea:	df 91       	pop	r29
    32ec:	08 95       	ret

000032ee <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    32ee:	df 93       	push	r29
    32f0:	cf 93       	push	r28
    32f2:	cd b7       	in	r28, 0x3d	; 61
    32f4:	de b7       	in	r29, 0x3e	; 62
    32f6:	2f 97       	sbiw	r28, 0x0f	; 15
    32f8:	0f b6       	in	r0, 0x3f	; 63
    32fa:	f8 94       	cli
    32fc:	de bf       	out	0x3e, r29	; 62
    32fe:	0f be       	out	0x3f, r0	; 63
    3300:	cd bf       	out	0x3d, r28	; 61
    TCB_t * pxTCB;
    TickType_t xItemValue;
    BaseType_t xSwitchRequired = pdFALSE;
    3302:	1b 86       	std	Y+11, r1	; 0x0b
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3304:	80 91 b7 06 	lds	r24, 0x06B7
    3308:	88 23       	and	r24, r24
    330a:	09 f0       	breq	.+2      	; 0x330e <xTaskIncrementTick+0x20>
    330c:	74 c1       	rjmp	.+744    	; 0x35f6 <xTaskIncrementTick+0x308>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    330e:	80 91 aa 06 	lds	r24, 0x06AA
    3312:	90 91 ab 06 	lds	r25, 0x06AB
    3316:	01 96       	adiw	r24, 0x01	; 1
    3318:	9a 87       	std	Y+10, r25	; 0x0a
    331a:	89 87       	std	Y+9, r24	; 0x09

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    331c:	89 85       	ldd	r24, Y+9	; 0x09
    331e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3320:	90 93 ab 06 	sts	0x06AB, r25
    3324:	80 93 aa 06 	sts	0x06AA, r24

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    3328:	89 85       	ldd	r24, Y+9	; 0x09
    332a:	9a 85       	ldd	r25, Y+10	; 0x0a
    332c:	00 97       	sbiw	r24, 0x00	; 0
    332e:	d9 f4       	brne	.+54     	; 0x3366 <xTaskIncrementTick+0x78>
        {
            taskSWITCH_DELAYED_LISTS();
    3330:	80 91 ee 06 	lds	r24, 0x06EE
    3334:	90 91 ef 06 	lds	r25, 0x06EF
    3338:	98 87       	std	Y+8, r25	; 0x08
    333a:	8f 83       	std	Y+7, r24	; 0x07
    333c:	80 91 f0 06 	lds	r24, 0x06F0
    3340:	90 91 f1 06 	lds	r25, 0x06F1
    3344:	90 93 ef 06 	sts	0x06EF, r25
    3348:	80 93 ee 06 	sts	0x06EE, r24
    334c:	8f 81       	ldd	r24, Y+7	; 0x07
    334e:	98 85       	ldd	r25, Y+8	; 0x08
    3350:	90 93 f1 06 	sts	0x06F1, r25
    3354:	80 93 f0 06 	sts	0x06F0, r24
    3358:	80 91 b1 06 	lds	r24, 0x06B1
    335c:	8f 5f       	subi	r24, 0xFF	; 255
    335e:	80 93 b1 06 	sts	0x06B1, r24
    3362:	0e 94 f0 1f 	call	0x3fe0	; 0x3fe0 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    3366:	20 91 b3 06 	lds	r18, 0x06B3
    336a:	30 91 b4 06 	lds	r19, 0x06B4
    336e:	89 85       	ldd	r24, Y+9	; 0x09
    3370:	9a 85       	ldd	r25, Y+10	; 0x0a
    3372:	82 17       	cp	r24, r18
    3374:	93 07       	cpc	r25, r19
    3376:	08 f4       	brcc	.+2      	; 0x337a <xTaskIncrementTick+0x8c>
    3378:	1f c1       	rjmp	.+574    	; 0x35b8 <xTaskIncrementTick+0x2ca>
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    337a:	e0 91 ee 06 	lds	r30, 0x06EE
    337e:	f0 91 ef 06 	lds	r31, 0x06EF
    3382:	80 81       	ld	r24, Z
    3384:	88 23       	and	r24, r24
    3386:	39 f4       	brne	.+14     	; 0x3396 <xTaskIncrementTick+0xa8>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3388:	8f ef       	ldi	r24, 0xFF	; 255
    338a:	9f ef       	ldi	r25, 0xFF	; 255
    338c:	90 93 b4 06 	sts	0x06B4, r25
    3390:	80 93 b3 06 	sts	0x06B3, r24
    3394:	11 c1       	rjmp	.+546    	; 0x35b8 <xTaskIncrementTick+0x2ca>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3396:	e0 91 ee 06 	lds	r30, 0x06EE
    339a:	f0 91 ef 06 	lds	r31, 0x06EF
    339e:	05 80       	ldd	r0, Z+5	; 0x05
    33a0:	f6 81       	ldd	r31, Z+6	; 0x06
    33a2:	e0 2d       	mov	r30, r0
    33a4:	86 81       	ldd	r24, Z+6	; 0x06
    33a6:	97 81       	ldd	r25, Z+7	; 0x07
    33a8:	9f 87       	std	Y+15, r25	; 0x0f
    33aa:	8e 87       	std	Y+14, r24	; 0x0e
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    33ac:	ee 85       	ldd	r30, Y+14	; 0x0e
    33ae:	ff 85       	ldd	r31, Y+15	; 0x0f
    33b0:	82 81       	ldd	r24, Z+2	; 0x02
    33b2:	93 81       	ldd	r25, Z+3	; 0x03
    33b4:	9d 87       	std	Y+13, r25	; 0x0d
    33b6:	8c 87       	std	Y+12, r24	; 0x0c

                    if( xConstTickCount < xItemValue )
    33b8:	29 85       	ldd	r18, Y+9	; 0x09
    33ba:	3a 85       	ldd	r19, Y+10	; 0x0a
    33bc:	8c 85       	ldd	r24, Y+12	; 0x0c
    33be:	9d 85       	ldd	r25, Y+13	; 0x0d
    33c0:	28 17       	cp	r18, r24
    33c2:	39 07       	cpc	r19, r25
    33c4:	38 f4       	brcc	.+14     	; 0x33d4 <xTaskIncrementTick+0xe6>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    33c6:	8c 85       	ldd	r24, Y+12	; 0x0c
    33c8:	9d 85       	ldd	r25, Y+13	; 0x0d
    33ca:	90 93 b4 06 	sts	0x06B4, r25
    33ce:	80 93 b3 06 	sts	0x06B3, r24
    33d2:	f2 c0       	rjmp	.+484    	; 0x35b8 <xTaskIncrementTick+0x2ca>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    33d4:	ee 85       	ldd	r30, Y+14	; 0x0e
    33d6:	ff 85       	ldd	r31, Y+15	; 0x0f
    33d8:	82 85       	ldd	r24, Z+10	; 0x0a
    33da:	93 85       	ldd	r25, Z+11	; 0x0b
    33dc:	9e 83       	std	Y+6, r25	; 0x06
    33de:	8d 83       	std	Y+5, r24	; 0x05
    33e0:	ee 85       	ldd	r30, Y+14	; 0x0e
    33e2:	ff 85       	ldd	r31, Y+15	; 0x0f
    33e4:	a4 81       	ldd	r26, Z+4	; 0x04
    33e6:	b5 81       	ldd	r27, Z+5	; 0x05
    33e8:	ee 85       	ldd	r30, Y+14	; 0x0e
    33ea:	ff 85       	ldd	r31, Y+15	; 0x0f
    33ec:	86 81       	ldd	r24, Z+6	; 0x06
    33ee:	97 81       	ldd	r25, Z+7	; 0x07
    33f0:	15 96       	adiw	r26, 0x05	; 5
    33f2:	9c 93       	st	X, r25
    33f4:	8e 93       	st	-X, r24
    33f6:	14 97       	sbiw	r26, 0x04	; 4
    33f8:	ee 85       	ldd	r30, Y+14	; 0x0e
    33fa:	ff 85       	ldd	r31, Y+15	; 0x0f
    33fc:	a6 81       	ldd	r26, Z+6	; 0x06
    33fe:	b7 81       	ldd	r27, Z+7	; 0x07
    3400:	ee 85       	ldd	r30, Y+14	; 0x0e
    3402:	ff 85       	ldd	r31, Y+15	; 0x0f
    3404:	84 81       	ldd	r24, Z+4	; 0x04
    3406:	95 81       	ldd	r25, Z+5	; 0x05
    3408:	13 96       	adiw	r26, 0x03	; 3
    340a:	9c 93       	st	X, r25
    340c:	8e 93       	st	-X, r24
    340e:	12 97       	sbiw	r26, 0x02	; 2
    3410:	ed 81       	ldd	r30, Y+5	; 0x05
    3412:	fe 81       	ldd	r31, Y+6	; 0x06
    3414:	21 81       	ldd	r18, Z+1	; 0x01
    3416:	32 81       	ldd	r19, Z+2	; 0x02
    3418:	8e 85       	ldd	r24, Y+14	; 0x0e
    341a:	9f 85       	ldd	r25, Y+15	; 0x0f
    341c:	02 96       	adiw	r24, 0x02	; 2
    341e:	28 17       	cp	r18, r24
    3420:	39 07       	cpc	r19, r25
    3422:	41 f4       	brne	.+16     	; 0x3434 <xTaskIncrementTick+0x146>
    3424:	ee 85       	ldd	r30, Y+14	; 0x0e
    3426:	ff 85       	ldd	r31, Y+15	; 0x0f
    3428:	86 81       	ldd	r24, Z+6	; 0x06
    342a:	97 81       	ldd	r25, Z+7	; 0x07
    342c:	ed 81       	ldd	r30, Y+5	; 0x05
    342e:	fe 81       	ldd	r31, Y+6	; 0x06
    3430:	92 83       	std	Z+2, r25	; 0x02
    3432:	81 83       	std	Z+1, r24	; 0x01
    3434:	ee 85       	ldd	r30, Y+14	; 0x0e
    3436:	ff 85       	ldd	r31, Y+15	; 0x0f
    3438:	13 86       	std	Z+11, r1	; 0x0b
    343a:	12 86       	std	Z+10, r1	; 0x0a
    343c:	ed 81       	ldd	r30, Y+5	; 0x05
    343e:	fe 81       	ldd	r31, Y+6	; 0x06
    3440:	80 81       	ld	r24, Z
    3442:	81 50       	subi	r24, 0x01	; 1
    3444:	ed 81       	ldd	r30, Y+5	; 0x05
    3446:	fe 81       	ldd	r31, Y+6	; 0x06
    3448:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    344a:	ee 85       	ldd	r30, Y+14	; 0x0e
    344c:	ff 85       	ldd	r31, Y+15	; 0x0f
    344e:	84 89       	ldd	r24, Z+20	; 0x14
    3450:	95 89       	ldd	r25, Z+21	; 0x15
    3452:	00 97       	sbiw	r24, 0x00	; 0
    3454:	d9 f1       	breq	.+118    	; 0x34cc <xTaskIncrementTick+0x1de>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3456:	ee 85       	ldd	r30, Y+14	; 0x0e
    3458:	ff 85       	ldd	r31, Y+15	; 0x0f
    345a:	84 89       	ldd	r24, Z+20	; 0x14
    345c:	95 89       	ldd	r25, Z+21	; 0x15
    345e:	9c 83       	std	Y+4, r25	; 0x04
    3460:	8b 83       	std	Y+3, r24	; 0x03
    3462:	ee 85       	ldd	r30, Y+14	; 0x0e
    3464:	ff 85       	ldd	r31, Y+15	; 0x0f
    3466:	a6 85       	ldd	r26, Z+14	; 0x0e
    3468:	b7 85       	ldd	r27, Z+15	; 0x0f
    346a:	ee 85       	ldd	r30, Y+14	; 0x0e
    346c:	ff 85       	ldd	r31, Y+15	; 0x0f
    346e:	80 89       	ldd	r24, Z+16	; 0x10
    3470:	91 89       	ldd	r25, Z+17	; 0x11
    3472:	15 96       	adiw	r26, 0x05	; 5
    3474:	9c 93       	st	X, r25
    3476:	8e 93       	st	-X, r24
    3478:	14 97       	sbiw	r26, 0x04	; 4
    347a:	ee 85       	ldd	r30, Y+14	; 0x0e
    347c:	ff 85       	ldd	r31, Y+15	; 0x0f
    347e:	a0 89       	ldd	r26, Z+16	; 0x10
    3480:	b1 89       	ldd	r27, Z+17	; 0x11
    3482:	ee 85       	ldd	r30, Y+14	; 0x0e
    3484:	ff 85       	ldd	r31, Y+15	; 0x0f
    3486:	86 85       	ldd	r24, Z+14	; 0x0e
    3488:	97 85       	ldd	r25, Z+15	; 0x0f
    348a:	13 96       	adiw	r26, 0x03	; 3
    348c:	9c 93       	st	X, r25
    348e:	8e 93       	st	-X, r24
    3490:	12 97       	sbiw	r26, 0x02	; 2
    3492:	eb 81       	ldd	r30, Y+3	; 0x03
    3494:	fc 81       	ldd	r31, Y+4	; 0x04
    3496:	21 81       	ldd	r18, Z+1	; 0x01
    3498:	32 81       	ldd	r19, Z+2	; 0x02
    349a:	8e 85       	ldd	r24, Y+14	; 0x0e
    349c:	9f 85       	ldd	r25, Y+15	; 0x0f
    349e:	0c 96       	adiw	r24, 0x0c	; 12
    34a0:	28 17       	cp	r18, r24
    34a2:	39 07       	cpc	r19, r25
    34a4:	41 f4       	brne	.+16     	; 0x34b6 <xTaskIncrementTick+0x1c8>
    34a6:	ee 85       	ldd	r30, Y+14	; 0x0e
    34a8:	ff 85       	ldd	r31, Y+15	; 0x0f
    34aa:	80 89       	ldd	r24, Z+16	; 0x10
    34ac:	91 89       	ldd	r25, Z+17	; 0x11
    34ae:	eb 81       	ldd	r30, Y+3	; 0x03
    34b0:	fc 81       	ldd	r31, Y+4	; 0x04
    34b2:	92 83       	std	Z+2, r25	; 0x02
    34b4:	81 83       	std	Z+1, r24	; 0x01
    34b6:	ee 85       	ldd	r30, Y+14	; 0x0e
    34b8:	ff 85       	ldd	r31, Y+15	; 0x0f
    34ba:	15 8a       	std	Z+21, r1	; 0x15
    34bc:	14 8a       	std	Z+20, r1	; 0x14
    34be:	eb 81       	ldd	r30, Y+3	; 0x03
    34c0:	fc 81       	ldd	r31, Y+4	; 0x04
    34c2:	80 81       	ld	r24, Z
    34c4:	81 50       	subi	r24, 0x01	; 1
    34c6:	eb 81       	ldd	r30, Y+3	; 0x03
    34c8:	fc 81       	ldd	r31, Y+4	; 0x04
    34ca:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    34cc:	ee 85       	ldd	r30, Y+14	; 0x0e
    34ce:	ff 85       	ldd	r31, Y+15	; 0x0f
    34d0:	96 89       	ldd	r25, Z+22	; 0x16
    34d2:	80 91 ac 06 	lds	r24, 0x06AC
    34d6:	89 17       	cp	r24, r25
    34d8:	28 f4       	brcc	.+10     	; 0x34e4 <xTaskIncrementTick+0x1f6>
    34da:	ee 85       	ldd	r30, Y+14	; 0x0e
    34dc:	ff 85       	ldd	r31, Y+15	; 0x0f
    34de:	86 89       	ldd	r24, Z+22	; 0x16
    34e0:	80 93 ac 06 	sts	0x06AC, r24
    34e4:	ee 85       	ldd	r30, Y+14	; 0x0e
    34e6:	ff 85       	ldd	r31, Y+15	; 0x0f
    34e8:	86 89       	ldd	r24, Z+22	; 0x16
    34ea:	28 2f       	mov	r18, r24
    34ec:	30 e0       	ldi	r19, 0x00	; 0
    34ee:	c9 01       	movw	r24, r18
    34f0:	88 0f       	add	r24, r24
    34f2:	99 1f       	adc	r25, r25
    34f4:	88 0f       	add	r24, r24
    34f6:	99 1f       	adc	r25, r25
    34f8:	88 0f       	add	r24, r24
    34fa:	99 1f       	adc	r25, r25
    34fc:	82 0f       	add	r24, r18
    34fe:	93 1f       	adc	r25, r19
    3500:	fc 01       	movw	r30, r24
    3502:	e8 54       	subi	r30, 0x48	; 72
    3504:	f9 4f       	sbci	r31, 0xF9	; 249
    3506:	81 81       	ldd	r24, Z+1	; 0x01
    3508:	92 81       	ldd	r25, Z+2	; 0x02
    350a:	9a 83       	std	Y+2, r25	; 0x02
    350c:	89 83       	std	Y+1, r24	; 0x01
    350e:	ee 85       	ldd	r30, Y+14	; 0x0e
    3510:	ff 85       	ldd	r31, Y+15	; 0x0f
    3512:	89 81       	ldd	r24, Y+1	; 0x01
    3514:	9a 81       	ldd	r25, Y+2	; 0x02
    3516:	95 83       	std	Z+5, r25	; 0x05
    3518:	84 83       	std	Z+4, r24	; 0x04
    351a:	e9 81       	ldd	r30, Y+1	; 0x01
    351c:	fa 81       	ldd	r31, Y+2	; 0x02
    351e:	84 81       	ldd	r24, Z+4	; 0x04
    3520:	95 81       	ldd	r25, Z+5	; 0x05
    3522:	ee 85       	ldd	r30, Y+14	; 0x0e
    3524:	ff 85       	ldd	r31, Y+15	; 0x0f
    3526:	97 83       	std	Z+7, r25	; 0x07
    3528:	86 83       	std	Z+6, r24	; 0x06
    352a:	e9 81       	ldd	r30, Y+1	; 0x01
    352c:	fa 81       	ldd	r31, Y+2	; 0x02
    352e:	04 80       	ldd	r0, Z+4	; 0x04
    3530:	f5 81       	ldd	r31, Z+5	; 0x05
    3532:	e0 2d       	mov	r30, r0
    3534:	8e 85       	ldd	r24, Y+14	; 0x0e
    3536:	9f 85       	ldd	r25, Y+15	; 0x0f
    3538:	02 96       	adiw	r24, 0x02	; 2
    353a:	93 83       	std	Z+3, r25	; 0x03
    353c:	82 83       	std	Z+2, r24	; 0x02
    353e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3540:	9f 85       	ldd	r25, Y+15	; 0x0f
    3542:	02 96       	adiw	r24, 0x02	; 2
    3544:	e9 81       	ldd	r30, Y+1	; 0x01
    3546:	fa 81       	ldd	r31, Y+2	; 0x02
    3548:	95 83       	std	Z+5, r25	; 0x05
    354a:	84 83       	std	Z+4, r24	; 0x04
    354c:	ee 85       	ldd	r30, Y+14	; 0x0e
    354e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3550:	86 89       	ldd	r24, Z+22	; 0x16
    3552:	28 2f       	mov	r18, r24
    3554:	30 e0       	ldi	r19, 0x00	; 0
    3556:	c9 01       	movw	r24, r18
    3558:	88 0f       	add	r24, r24
    355a:	99 1f       	adc	r25, r25
    355c:	88 0f       	add	r24, r24
    355e:	99 1f       	adc	r25, r25
    3560:	88 0f       	add	r24, r24
    3562:	99 1f       	adc	r25, r25
    3564:	82 0f       	add	r24, r18
    3566:	93 1f       	adc	r25, r19
    3568:	88 54       	subi	r24, 0x48	; 72
    356a:	99 4f       	sbci	r25, 0xF9	; 249
    356c:	ee 85       	ldd	r30, Y+14	; 0x0e
    356e:	ff 85       	ldd	r31, Y+15	; 0x0f
    3570:	93 87       	std	Z+11, r25	; 0x0b
    3572:	82 87       	std	Z+10, r24	; 0x0a
    3574:	ee 85       	ldd	r30, Y+14	; 0x0e
    3576:	ff 85       	ldd	r31, Y+15	; 0x0f
    3578:	86 89       	ldd	r24, Z+22	; 0x16
    357a:	28 2f       	mov	r18, r24
    357c:	30 e0       	ldi	r19, 0x00	; 0
    357e:	c9 01       	movw	r24, r18
    3580:	88 0f       	add	r24, r24
    3582:	99 1f       	adc	r25, r25
    3584:	88 0f       	add	r24, r24
    3586:	99 1f       	adc	r25, r25
    3588:	88 0f       	add	r24, r24
    358a:	99 1f       	adc	r25, r25
    358c:	82 0f       	add	r24, r18
    358e:	93 1f       	adc	r25, r19
    3590:	fc 01       	movw	r30, r24
    3592:	e8 54       	subi	r30, 0x48	; 72
    3594:	f9 4f       	sbci	r31, 0xF9	; 249
    3596:	80 81       	ld	r24, Z
    3598:	8f 5f       	subi	r24, 0xFF	; 255
    359a:	80 83       	st	Z, r24
                        {
                            /* Preemption is on, but a context switch should
                             * only be performed if the unblocked task has a
                             * priority that is equal to or higher than the
                             * currently executing task. */
                            if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    359c:	ee 85       	ldd	r30, Y+14	; 0x0e
    359e:	ff 85       	ldd	r31, Y+15	; 0x0f
    35a0:	96 89       	ldd	r25, Z+22	; 0x16
    35a2:	e0 91 a6 06 	lds	r30, 0x06A6
    35a6:	f0 91 a7 06 	lds	r31, 0x06A7
    35aa:	86 89       	ldd	r24, Z+22	; 0x16
    35ac:	98 17       	cp	r25, r24
    35ae:	08 f4       	brcc	.+2      	; 0x35b2 <xTaskIncrementTick+0x2c4>
    35b0:	e4 ce       	rjmp	.-568    	; 0x337a <xTaskIncrementTick+0x8c>
                            {
                                xSwitchRequired = pdTRUE;
    35b2:	81 e0       	ldi	r24, 0x01	; 1
    35b4:	8b 87       	std	Y+11, r24	; 0x0b
    35b6:	e1 ce       	rjmp	.-574    	; 0x337a <xTaskIncrementTick+0x8c>
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
            {
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    35b8:	e0 91 a6 06 	lds	r30, 0x06A6
    35bc:	f0 91 a7 06 	lds	r31, 0x06A7
    35c0:	86 89       	ldd	r24, Z+22	; 0x16
    35c2:	28 2f       	mov	r18, r24
    35c4:	30 e0       	ldi	r19, 0x00	; 0
    35c6:	c9 01       	movw	r24, r18
    35c8:	88 0f       	add	r24, r24
    35ca:	99 1f       	adc	r25, r25
    35cc:	88 0f       	add	r24, r24
    35ce:	99 1f       	adc	r25, r25
    35d0:	88 0f       	add	r24, r24
    35d2:	99 1f       	adc	r25, r25
    35d4:	82 0f       	add	r24, r18
    35d6:	93 1f       	adc	r25, r19
    35d8:	fc 01       	movw	r30, r24
    35da:	e8 54       	subi	r30, 0x48	; 72
    35dc:	f9 4f       	sbci	r31, 0xF9	; 249
    35de:	80 81       	ld	r24, Z
    35e0:	82 30       	cpi	r24, 0x02	; 2
    35e2:	10 f0       	brcs	.+4      	; 0x35e8 <xTaskIncrementTick+0x2fa>
                {
                    xSwitchRequired = pdTRUE;
    35e4:	81 e0       	ldi	r24, 0x01	; 1
    35e6:	8b 87       	std	Y+11, r24	; 0x0b
            }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
            {
                if( xYieldPending != pdFALSE )
    35e8:	80 91 b0 06 	lds	r24, 0x06B0
    35ec:	88 23       	and	r24, r24
    35ee:	61 f0       	breq	.+24     	; 0x3608 <xTaskIncrementTick+0x31a>
                {
                    xSwitchRequired = pdTRUE;
    35f0:	81 e0       	ldi	r24, 0x01	; 1
    35f2:	8b 87       	std	Y+11, r24	; 0x0b
    35f4:	09 c0       	rjmp	.+18     	; 0x3608 <xTaskIncrementTick+0x31a>
            }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    35f6:	80 91 ae 06 	lds	r24, 0x06AE
    35fa:	90 91 af 06 	lds	r25, 0x06AF
    35fe:	01 96       	adiw	r24, 0x01	; 1
    3600:	90 93 af 06 	sts	0x06AF, r25
    3604:	80 93 ae 06 	sts	0x06AE, r24
                vApplicationTickHook();
            }
        #endif
    }

    return xSwitchRequired;
    3608:	8b 85       	ldd	r24, Y+11	; 0x0b
}
    360a:	2f 96       	adiw	r28, 0x0f	; 15
    360c:	0f b6       	in	r0, 0x3f	; 63
    360e:	f8 94       	cli
    3610:	de bf       	out	0x3e, r29	; 62
    3612:	0f be       	out	0x3f, r0	; 63
    3614:	cd bf       	out	0x3d, r28	; 61
    3616:	cf 91       	pop	r28
    3618:	df 91       	pop	r29
    361a:	08 95       	ret

0000361c <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    361c:	df 93       	push	r29
    361e:	cf 93       	push	r28
    3620:	00 d0       	rcall	.+0      	; 0x3622 <vTaskSwitchContext+0x6>
    3622:	0f 92       	push	r0
    3624:	cd b7       	in	r28, 0x3d	; 61
    3626:	de b7       	in	r29, 0x3e	; 62
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3628:	80 91 b7 06 	lds	r24, 0x06B7
    362c:	88 23       	and	r24, r24
    362e:	21 f0       	breq	.+8      	; 0x3638 <vTaskSwitchContext+0x1c>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    3630:	81 e0       	ldi	r24, 0x01	; 1
    3632:	80 93 b0 06 	sts	0x06B0, r24
    3636:	59 c0       	rjmp	.+178    	; 0x36ea <vTaskSwitchContext+0xce>
    }
    else
    {
        xYieldPending = pdFALSE;
    3638:	10 92 b0 06 	sts	0x06B0, r1
            }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    363c:	80 91 ac 06 	lds	r24, 0x06AC
    3640:	8b 83       	std	Y+3, r24	; 0x03
    3642:	03 c0       	rjmp	.+6      	; 0x364a <vTaskSwitchContext+0x2e>
    3644:	8b 81       	ldd	r24, Y+3	; 0x03
    3646:	81 50       	subi	r24, 0x01	; 1
    3648:	8b 83       	std	Y+3, r24	; 0x03
    364a:	8b 81       	ldd	r24, Y+3	; 0x03
    364c:	28 2f       	mov	r18, r24
    364e:	30 e0       	ldi	r19, 0x00	; 0
    3650:	c9 01       	movw	r24, r18
    3652:	88 0f       	add	r24, r24
    3654:	99 1f       	adc	r25, r25
    3656:	88 0f       	add	r24, r24
    3658:	99 1f       	adc	r25, r25
    365a:	88 0f       	add	r24, r24
    365c:	99 1f       	adc	r25, r25
    365e:	82 0f       	add	r24, r18
    3660:	93 1f       	adc	r25, r19
    3662:	fc 01       	movw	r30, r24
    3664:	e8 54       	subi	r30, 0x48	; 72
    3666:	f9 4f       	sbci	r31, 0xF9	; 249
    3668:	80 81       	ld	r24, Z
    366a:	88 23       	and	r24, r24
    366c:	59 f3       	breq	.-42     	; 0x3644 <vTaskSwitchContext+0x28>
    366e:	8b 81       	ldd	r24, Y+3	; 0x03
    3670:	28 2f       	mov	r18, r24
    3672:	30 e0       	ldi	r19, 0x00	; 0
    3674:	c9 01       	movw	r24, r18
    3676:	88 0f       	add	r24, r24
    3678:	99 1f       	adc	r25, r25
    367a:	88 0f       	add	r24, r24
    367c:	99 1f       	adc	r25, r25
    367e:	88 0f       	add	r24, r24
    3680:	99 1f       	adc	r25, r25
    3682:	82 0f       	add	r24, r18
    3684:	93 1f       	adc	r25, r19
    3686:	88 54       	subi	r24, 0x48	; 72
    3688:	99 4f       	sbci	r25, 0xF9	; 249
    368a:	9a 83       	std	Y+2, r25	; 0x02
    368c:	89 83       	std	Y+1, r24	; 0x01
    368e:	e9 81       	ldd	r30, Y+1	; 0x01
    3690:	fa 81       	ldd	r31, Y+2	; 0x02
    3692:	01 80       	ldd	r0, Z+1	; 0x01
    3694:	f2 81       	ldd	r31, Z+2	; 0x02
    3696:	e0 2d       	mov	r30, r0
    3698:	82 81       	ldd	r24, Z+2	; 0x02
    369a:	93 81       	ldd	r25, Z+3	; 0x03
    369c:	e9 81       	ldd	r30, Y+1	; 0x01
    369e:	fa 81       	ldd	r31, Y+2	; 0x02
    36a0:	92 83       	std	Z+2, r25	; 0x02
    36a2:	81 83       	std	Z+1, r24	; 0x01
    36a4:	e9 81       	ldd	r30, Y+1	; 0x01
    36a6:	fa 81       	ldd	r31, Y+2	; 0x02
    36a8:	21 81       	ldd	r18, Z+1	; 0x01
    36aa:	32 81       	ldd	r19, Z+2	; 0x02
    36ac:	89 81       	ldd	r24, Y+1	; 0x01
    36ae:	9a 81       	ldd	r25, Y+2	; 0x02
    36b0:	03 96       	adiw	r24, 0x03	; 3
    36b2:	28 17       	cp	r18, r24
    36b4:	39 07       	cpc	r19, r25
    36b6:	59 f4       	brne	.+22     	; 0x36ce <vTaskSwitchContext+0xb2>
    36b8:	e9 81       	ldd	r30, Y+1	; 0x01
    36ba:	fa 81       	ldd	r31, Y+2	; 0x02
    36bc:	01 80       	ldd	r0, Z+1	; 0x01
    36be:	f2 81       	ldd	r31, Z+2	; 0x02
    36c0:	e0 2d       	mov	r30, r0
    36c2:	82 81       	ldd	r24, Z+2	; 0x02
    36c4:	93 81       	ldd	r25, Z+3	; 0x03
    36c6:	e9 81       	ldd	r30, Y+1	; 0x01
    36c8:	fa 81       	ldd	r31, Y+2	; 0x02
    36ca:	92 83       	std	Z+2, r25	; 0x02
    36cc:	81 83       	std	Z+1, r24	; 0x01
    36ce:	e9 81       	ldd	r30, Y+1	; 0x01
    36d0:	fa 81       	ldd	r31, Y+2	; 0x02
    36d2:	01 80       	ldd	r0, Z+1	; 0x01
    36d4:	f2 81       	ldd	r31, Z+2	; 0x02
    36d6:	e0 2d       	mov	r30, r0
    36d8:	86 81       	ldd	r24, Z+6	; 0x06
    36da:	97 81       	ldd	r25, Z+7	; 0x07
    36dc:	90 93 a7 06 	sts	0x06A7, r25
    36e0:	80 93 a6 06 	sts	0x06A6, r24
    36e4:	8b 81       	ldd	r24, Y+3	; 0x03
    36e6:	80 93 ac 06 	sts	0x06AC, r24
                 * for additional information. */
                _impure_ptr = &( pxCurrentTCB->xNewLib_reent );
            }
        #endif /* configUSE_NEWLIB_REENTRANT */
    }
}
    36ea:	0f 90       	pop	r0
    36ec:	0f 90       	pop	r0
    36ee:	0f 90       	pop	r0
    36f0:	cf 91       	pop	r28
    36f2:	df 91       	pop	r29
    36f4:	08 95       	ret

000036f6 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    36f6:	df 93       	push	r29
    36f8:	cf 93       	push	r28
    36fa:	00 d0       	rcall	.+0      	; 0x36fc <vTaskPlaceOnEventList+0x6>
    36fc:	00 d0       	rcall	.+0      	; 0x36fe <vTaskPlaceOnEventList+0x8>
    36fe:	cd b7       	in	r28, 0x3d	; 61
    3700:	de b7       	in	r29, 0x3e	; 62
    3702:	9a 83       	std	Y+2, r25	; 0x02
    3704:	89 83       	std	Y+1, r24	; 0x01
    3706:	7c 83       	std	Y+4, r23	; 0x04
    3708:	6b 83       	std	Y+3, r22	; 0x03
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    370a:	80 91 a6 06 	lds	r24, 0x06A6
    370e:	90 91 a7 06 	lds	r25, 0x06A7
    3712:	9c 01       	movw	r18, r24
    3714:	24 5f       	subi	r18, 0xF4	; 244
    3716:	3f 4f       	sbci	r19, 0xFF	; 255
    3718:	89 81       	ldd	r24, Y+1	; 0x01
    371a:	9a 81       	ldd	r25, Y+2	; 0x02
    371c:	b9 01       	movw	r22, r18
    371e:	0e 94 3f 0a 	call	0x147e	; 0x147e <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3722:	8b 81       	ldd	r24, Y+3	; 0x03
    3724:	9c 81       	ldd	r25, Y+4	; 0x04
    3726:	61 e0       	ldi	r22, 0x01	; 1
    3728:	0e 94 d7 27 	call	0x4fae	; 0x4fae <prvAddCurrentTaskToDelayedList>
}
    372c:	0f 90       	pop	r0
    372e:	0f 90       	pop	r0
    3730:	0f 90       	pop	r0
    3732:	0f 90       	pop	r0
    3734:	cf 91       	pop	r28
    3736:	df 91       	pop	r29
    3738:	08 95       	ret

0000373a <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    373a:	df 93       	push	r29
    373c:	cf 93       	push	r28
    373e:	cd b7       	in	r28, 0x3d	; 61
    3740:	de b7       	in	r29, 0x3e	; 62
    3742:	28 97       	sbiw	r28, 0x08	; 8
    3744:	0f b6       	in	r0, 0x3f	; 63
    3746:	f8 94       	cli
    3748:	de bf       	out	0x3e, r29	; 62
    374a:	0f be       	out	0x3f, r0	; 63
    374c:	cd bf       	out	0x3d, r28	; 61
    374e:	9c 83       	std	Y+4, r25	; 0x04
    3750:	8b 83       	std	Y+3, r24	; 0x03
    3752:	7e 83       	std	Y+6, r23	; 0x06
    3754:	6d 83       	std	Y+5, r22	; 0x05
    3756:	58 87       	std	Y+8, r21	; 0x08
    3758:	4f 83       	std	Y+7, r20	; 0x07
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    375a:	e0 91 a6 06 	lds	r30, 0x06A6
    375e:	f0 91 a7 06 	lds	r31, 0x06A7
    3762:	8d 81       	ldd	r24, Y+5	; 0x05
    3764:	9e 81       	ldd	r25, Y+6	; 0x06
    3766:	90 68       	ori	r25, 0x80	; 128
    3768:	95 87       	std	Z+13, r25	; 0x0d
    376a:	84 87       	std	Z+12, r24	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    376c:	eb 81       	ldd	r30, Y+3	; 0x03
    376e:	fc 81       	ldd	r31, Y+4	; 0x04
    3770:	81 81       	ldd	r24, Z+1	; 0x01
    3772:	92 81       	ldd	r25, Z+2	; 0x02
    3774:	9a 83       	std	Y+2, r25	; 0x02
    3776:	89 83       	std	Y+1, r24	; 0x01
    3778:	e0 91 a6 06 	lds	r30, 0x06A6
    377c:	f0 91 a7 06 	lds	r31, 0x06A7
    3780:	89 81       	ldd	r24, Y+1	; 0x01
    3782:	9a 81       	ldd	r25, Y+2	; 0x02
    3784:	97 87       	std	Z+15, r25	; 0x0f
    3786:	86 87       	std	Z+14, r24	; 0x0e
    3788:	a0 91 a6 06 	lds	r26, 0x06A6
    378c:	b0 91 a7 06 	lds	r27, 0x06A7
    3790:	e9 81       	ldd	r30, Y+1	; 0x01
    3792:	fa 81       	ldd	r31, Y+2	; 0x02
    3794:	84 81       	ldd	r24, Z+4	; 0x04
    3796:	95 81       	ldd	r25, Z+5	; 0x05
    3798:	51 96       	adiw	r26, 0x11	; 17
    379a:	9c 93       	st	X, r25
    379c:	8e 93       	st	-X, r24
    379e:	50 97       	sbiw	r26, 0x10	; 16
    37a0:	e9 81       	ldd	r30, Y+1	; 0x01
    37a2:	fa 81       	ldd	r31, Y+2	; 0x02
    37a4:	04 80       	ldd	r0, Z+4	; 0x04
    37a6:	f5 81       	ldd	r31, Z+5	; 0x05
    37a8:	e0 2d       	mov	r30, r0
    37aa:	80 91 a6 06 	lds	r24, 0x06A6
    37ae:	90 91 a7 06 	lds	r25, 0x06A7
    37b2:	0c 96       	adiw	r24, 0x0c	; 12
    37b4:	93 83       	std	Z+3, r25	; 0x03
    37b6:	82 83       	std	Z+2, r24	; 0x02
    37b8:	80 91 a6 06 	lds	r24, 0x06A6
    37bc:	90 91 a7 06 	lds	r25, 0x06A7
    37c0:	0c 96       	adiw	r24, 0x0c	; 12
    37c2:	e9 81       	ldd	r30, Y+1	; 0x01
    37c4:	fa 81       	ldd	r31, Y+2	; 0x02
    37c6:	95 83       	std	Z+5, r25	; 0x05
    37c8:	84 83       	std	Z+4, r24	; 0x04
    37ca:	e0 91 a6 06 	lds	r30, 0x06A6
    37ce:	f0 91 a7 06 	lds	r31, 0x06A7
    37d2:	8b 81       	ldd	r24, Y+3	; 0x03
    37d4:	9c 81       	ldd	r25, Y+4	; 0x04
    37d6:	95 8b       	std	Z+21, r25	; 0x15
    37d8:	84 8b       	std	Z+20, r24	; 0x14
    37da:	eb 81       	ldd	r30, Y+3	; 0x03
    37dc:	fc 81       	ldd	r31, Y+4	; 0x04
    37de:	80 81       	ld	r24, Z
    37e0:	8f 5f       	subi	r24, 0xFF	; 255
    37e2:	eb 81       	ldd	r30, Y+3	; 0x03
    37e4:	fc 81       	ldd	r31, Y+4	; 0x04
    37e6:	80 83       	st	Z, r24

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    37e8:	8f 81       	ldd	r24, Y+7	; 0x07
    37ea:	98 85       	ldd	r25, Y+8	; 0x08
    37ec:	61 e0       	ldi	r22, 0x01	; 1
    37ee:	0e 94 d7 27 	call	0x4fae	; 0x4fae <prvAddCurrentTaskToDelayedList>
}
    37f2:	28 96       	adiw	r28, 0x08	; 8
    37f4:	0f b6       	in	r0, 0x3f	; 63
    37f6:	f8 94       	cli
    37f8:	de bf       	out	0x3e, r29	; 62
    37fa:	0f be       	out	0x3f, r0	; 63
    37fc:	cd bf       	out	0x3d, r28	; 61
    37fe:	cf 91       	pop	r28
    3800:	df 91       	pop	r29
    3802:	08 95       	ret

00003804 <vTaskPlaceOnEventListRestricted>:
#if ( configUSE_TIMERS == 1 )

    void vTaskPlaceOnEventListRestricted( List_t * const pxEventList,
                                          TickType_t xTicksToWait,
                                          const BaseType_t xWaitIndefinitely )
    {
    3804:	df 93       	push	r29
    3806:	cf 93       	push	r28
    3808:	cd b7       	in	r28, 0x3d	; 61
    380a:	de b7       	in	r29, 0x3e	; 62
    380c:	27 97       	sbiw	r28, 0x07	; 7
    380e:	0f b6       	in	r0, 0x3f	; 63
    3810:	f8 94       	cli
    3812:	de bf       	out	0x3e, r29	; 62
    3814:	0f be       	out	0x3f, r0	; 63
    3816:	cd bf       	out	0x3d, r28	; 61
    3818:	9c 83       	std	Y+4, r25	; 0x04
    381a:	8b 83       	std	Y+3, r24	; 0x03
    381c:	7e 83       	std	Y+6, r23	; 0x06
    381e:	6d 83       	std	Y+5, r22	; 0x05
    3820:	4f 83       	std	Y+7, r20	; 0x07

        /* Place the event list item of the TCB in the appropriate event list.
         * In this case it is assume that this is the only task that is going to
         * be waiting on this event list, so the faster vListInsertEnd() function
         * can be used in place of vListInsert. */
        listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3822:	eb 81       	ldd	r30, Y+3	; 0x03
    3824:	fc 81       	ldd	r31, Y+4	; 0x04
    3826:	81 81       	ldd	r24, Z+1	; 0x01
    3828:	92 81       	ldd	r25, Z+2	; 0x02
    382a:	9a 83       	std	Y+2, r25	; 0x02
    382c:	89 83       	std	Y+1, r24	; 0x01
    382e:	e0 91 a6 06 	lds	r30, 0x06A6
    3832:	f0 91 a7 06 	lds	r31, 0x06A7
    3836:	89 81       	ldd	r24, Y+1	; 0x01
    3838:	9a 81       	ldd	r25, Y+2	; 0x02
    383a:	97 87       	std	Z+15, r25	; 0x0f
    383c:	86 87       	std	Z+14, r24	; 0x0e
    383e:	a0 91 a6 06 	lds	r26, 0x06A6
    3842:	b0 91 a7 06 	lds	r27, 0x06A7
    3846:	e9 81       	ldd	r30, Y+1	; 0x01
    3848:	fa 81       	ldd	r31, Y+2	; 0x02
    384a:	84 81       	ldd	r24, Z+4	; 0x04
    384c:	95 81       	ldd	r25, Z+5	; 0x05
    384e:	51 96       	adiw	r26, 0x11	; 17
    3850:	9c 93       	st	X, r25
    3852:	8e 93       	st	-X, r24
    3854:	50 97       	sbiw	r26, 0x10	; 16
    3856:	e9 81       	ldd	r30, Y+1	; 0x01
    3858:	fa 81       	ldd	r31, Y+2	; 0x02
    385a:	04 80       	ldd	r0, Z+4	; 0x04
    385c:	f5 81       	ldd	r31, Z+5	; 0x05
    385e:	e0 2d       	mov	r30, r0
    3860:	80 91 a6 06 	lds	r24, 0x06A6
    3864:	90 91 a7 06 	lds	r25, 0x06A7
    3868:	0c 96       	adiw	r24, 0x0c	; 12
    386a:	93 83       	std	Z+3, r25	; 0x03
    386c:	82 83       	std	Z+2, r24	; 0x02
    386e:	80 91 a6 06 	lds	r24, 0x06A6
    3872:	90 91 a7 06 	lds	r25, 0x06A7
    3876:	0c 96       	adiw	r24, 0x0c	; 12
    3878:	e9 81       	ldd	r30, Y+1	; 0x01
    387a:	fa 81       	ldd	r31, Y+2	; 0x02
    387c:	95 83       	std	Z+5, r25	; 0x05
    387e:	84 83       	std	Z+4, r24	; 0x04
    3880:	e0 91 a6 06 	lds	r30, 0x06A6
    3884:	f0 91 a7 06 	lds	r31, 0x06A7
    3888:	8b 81       	ldd	r24, Y+3	; 0x03
    388a:	9c 81       	ldd	r25, Y+4	; 0x04
    388c:	95 8b       	std	Z+21, r25	; 0x15
    388e:	84 8b       	std	Z+20, r24	; 0x14
    3890:	eb 81       	ldd	r30, Y+3	; 0x03
    3892:	fc 81       	ldd	r31, Y+4	; 0x04
    3894:	80 81       	ld	r24, Z
    3896:	8f 5f       	subi	r24, 0xFF	; 255
    3898:	eb 81       	ldd	r30, Y+3	; 0x03
    389a:	fc 81       	ldd	r31, Y+4	; 0x04
    389c:	80 83       	st	Z, r24

        /* If the task should block indefinitely then set the block time to a
         * value that will be recognised as an indefinite delay inside the
         * prvAddCurrentTaskToDelayedList() function. */
        if( xWaitIndefinitely != pdFALSE )
    389e:	8f 81       	ldd	r24, Y+7	; 0x07
    38a0:	88 23       	and	r24, r24
    38a2:	21 f0       	breq	.+8      	; 0x38ac <vTaskPlaceOnEventListRestricted+0xa8>
        {
            xTicksToWait = portMAX_DELAY;
    38a4:	8f ef       	ldi	r24, 0xFF	; 255
    38a6:	9f ef       	ldi	r25, 0xFF	; 255
    38a8:	9e 83       	std	Y+6, r25	; 0x06
    38aa:	8d 83       	std	Y+5, r24	; 0x05
        }

        traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
        prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
    38ac:	8d 81       	ldd	r24, Y+5	; 0x05
    38ae:	9e 81       	ldd	r25, Y+6	; 0x06
    38b0:	6f 81       	ldd	r22, Y+7	; 0x07
    38b2:	0e 94 d7 27 	call	0x4fae	; 0x4fae <prvAddCurrentTaskToDelayedList>
    }
    38b6:	27 96       	adiw	r28, 0x07	; 7
    38b8:	0f b6       	in	r0, 0x3f	; 63
    38ba:	f8 94       	cli
    38bc:	de bf       	out	0x3e, r29	; 62
    38be:	0f be       	out	0x3f, r0	; 63
    38c0:	cd bf       	out	0x3d, r28	; 61
    38c2:	cf 91       	pop	r28
    38c4:	df 91       	pop	r29
    38c6:	08 95       	ret

000038c8 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    38c8:	df 93       	push	r29
    38ca:	cf 93       	push	r28
    38cc:	cd b7       	in	r28, 0x3d	; 61
    38ce:	de b7       	in	r29, 0x3e	; 62
    38d0:	2d 97       	sbiw	r28, 0x0d	; 13
    38d2:	0f b6       	in	r0, 0x3f	; 63
    38d4:	f8 94       	cli
    38d6:	de bf       	out	0x3e, r29	; 62
    38d8:	0f be       	out	0x3f, r0	; 63
    38da:	cd bf       	out	0x3d, r28	; 61
    38dc:	9d 87       	std	Y+13, r25	; 0x0d
    38de:	8c 87       	std	Y+12, r24	; 0x0c
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    38e0:	ec 85       	ldd	r30, Y+12	; 0x0c
    38e2:	fd 85       	ldd	r31, Y+13	; 0x0d
    38e4:	05 80       	ldd	r0, Z+5	; 0x05
    38e6:	f6 81       	ldd	r31, Z+6	; 0x06
    38e8:	e0 2d       	mov	r30, r0
    38ea:	86 81       	ldd	r24, Z+6	; 0x06
    38ec:	97 81       	ldd	r25, Z+7	; 0x07
    38ee:	9b 87       	std	Y+11, r25	; 0x0b
    38f0:	8a 87       	std	Y+10, r24	; 0x0a
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    38f2:	ea 85       	ldd	r30, Y+10	; 0x0a
    38f4:	fb 85       	ldd	r31, Y+11	; 0x0b
    38f6:	84 89       	ldd	r24, Z+20	; 0x14
    38f8:	95 89       	ldd	r25, Z+21	; 0x15
    38fa:	98 87       	std	Y+8, r25	; 0x08
    38fc:	8f 83       	std	Y+7, r24	; 0x07
    38fe:	ea 85       	ldd	r30, Y+10	; 0x0a
    3900:	fb 85       	ldd	r31, Y+11	; 0x0b
    3902:	a6 85       	ldd	r26, Z+14	; 0x0e
    3904:	b7 85       	ldd	r27, Z+15	; 0x0f
    3906:	ea 85       	ldd	r30, Y+10	; 0x0a
    3908:	fb 85       	ldd	r31, Y+11	; 0x0b
    390a:	80 89       	ldd	r24, Z+16	; 0x10
    390c:	91 89       	ldd	r25, Z+17	; 0x11
    390e:	15 96       	adiw	r26, 0x05	; 5
    3910:	9c 93       	st	X, r25
    3912:	8e 93       	st	-X, r24
    3914:	14 97       	sbiw	r26, 0x04	; 4
    3916:	ea 85       	ldd	r30, Y+10	; 0x0a
    3918:	fb 85       	ldd	r31, Y+11	; 0x0b
    391a:	a0 89       	ldd	r26, Z+16	; 0x10
    391c:	b1 89       	ldd	r27, Z+17	; 0x11
    391e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3920:	fb 85       	ldd	r31, Y+11	; 0x0b
    3922:	86 85       	ldd	r24, Z+14	; 0x0e
    3924:	97 85       	ldd	r25, Z+15	; 0x0f
    3926:	13 96       	adiw	r26, 0x03	; 3
    3928:	9c 93       	st	X, r25
    392a:	8e 93       	st	-X, r24
    392c:	12 97       	sbiw	r26, 0x02	; 2
    392e:	ef 81       	ldd	r30, Y+7	; 0x07
    3930:	f8 85       	ldd	r31, Y+8	; 0x08
    3932:	21 81       	ldd	r18, Z+1	; 0x01
    3934:	32 81       	ldd	r19, Z+2	; 0x02
    3936:	8a 85       	ldd	r24, Y+10	; 0x0a
    3938:	9b 85       	ldd	r25, Y+11	; 0x0b
    393a:	0c 96       	adiw	r24, 0x0c	; 12
    393c:	28 17       	cp	r18, r24
    393e:	39 07       	cpc	r19, r25
    3940:	41 f4       	brne	.+16     	; 0x3952 <xTaskRemoveFromEventList+0x8a>
    3942:	ea 85       	ldd	r30, Y+10	; 0x0a
    3944:	fb 85       	ldd	r31, Y+11	; 0x0b
    3946:	80 89       	ldd	r24, Z+16	; 0x10
    3948:	91 89       	ldd	r25, Z+17	; 0x11
    394a:	ef 81       	ldd	r30, Y+7	; 0x07
    394c:	f8 85       	ldd	r31, Y+8	; 0x08
    394e:	92 83       	std	Z+2, r25	; 0x02
    3950:	81 83       	std	Z+1, r24	; 0x01
    3952:	ea 85       	ldd	r30, Y+10	; 0x0a
    3954:	fb 85       	ldd	r31, Y+11	; 0x0b
    3956:	15 8a       	std	Z+21, r1	; 0x15
    3958:	14 8a       	std	Z+20, r1	; 0x14
    395a:	ef 81       	ldd	r30, Y+7	; 0x07
    395c:	f8 85       	ldd	r31, Y+8	; 0x08
    395e:	80 81       	ld	r24, Z
    3960:	81 50       	subi	r24, 0x01	; 1
    3962:	ef 81       	ldd	r30, Y+7	; 0x07
    3964:	f8 85       	ldd	r31, Y+8	; 0x08
    3966:	80 83       	st	Z, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3968:	80 91 b7 06 	lds	r24, 0x06B7
    396c:	88 23       	and	r24, r24
    396e:	09 f0       	breq	.+2      	; 0x3972 <xTaskRemoveFromEventList+0xaa>
    3970:	a4 c0       	rjmp	.+328    	; 0x3aba <xTaskRemoveFromEventList+0x1f2>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    3972:	ea 85       	ldd	r30, Y+10	; 0x0a
    3974:	fb 85       	ldd	r31, Y+11	; 0x0b
    3976:	82 85       	ldd	r24, Z+10	; 0x0a
    3978:	93 85       	ldd	r25, Z+11	; 0x0b
    397a:	9e 83       	std	Y+6, r25	; 0x06
    397c:	8d 83       	std	Y+5, r24	; 0x05
    397e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3980:	fb 85       	ldd	r31, Y+11	; 0x0b
    3982:	a4 81       	ldd	r26, Z+4	; 0x04
    3984:	b5 81       	ldd	r27, Z+5	; 0x05
    3986:	ea 85       	ldd	r30, Y+10	; 0x0a
    3988:	fb 85       	ldd	r31, Y+11	; 0x0b
    398a:	86 81       	ldd	r24, Z+6	; 0x06
    398c:	97 81       	ldd	r25, Z+7	; 0x07
    398e:	15 96       	adiw	r26, 0x05	; 5
    3990:	9c 93       	st	X, r25
    3992:	8e 93       	st	-X, r24
    3994:	14 97       	sbiw	r26, 0x04	; 4
    3996:	ea 85       	ldd	r30, Y+10	; 0x0a
    3998:	fb 85       	ldd	r31, Y+11	; 0x0b
    399a:	a6 81       	ldd	r26, Z+6	; 0x06
    399c:	b7 81       	ldd	r27, Z+7	; 0x07
    399e:	ea 85       	ldd	r30, Y+10	; 0x0a
    39a0:	fb 85       	ldd	r31, Y+11	; 0x0b
    39a2:	84 81       	ldd	r24, Z+4	; 0x04
    39a4:	95 81       	ldd	r25, Z+5	; 0x05
    39a6:	13 96       	adiw	r26, 0x03	; 3
    39a8:	9c 93       	st	X, r25
    39aa:	8e 93       	st	-X, r24
    39ac:	12 97       	sbiw	r26, 0x02	; 2
    39ae:	ed 81       	ldd	r30, Y+5	; 0x05
    39b0:	fe 81       	ldd	r31, Y+6	; 0x06
    39b2:	21 81       	ldd	r18, Z+1	; 0x01
    39b4:	32 81       	ldd	r19, Z+2	; 0x02
    39b6:	8a 85       	ldd	r24, Y+10	; 0x0a
    39b8:	9b 85       	ldd	r25, Y+11	; 0x0b
    39ba:	02 96       	adiw	r24, 0x02	; 2
    39bc:	28 17       	cp	r18, r24
    39be:	39 07       	cpc	r19, r25
    39c0:	41 f4       	brne	.+16     	; 0x39d2 <xTaskRemoveFromEventList+0x10a>
    39c2:	ea 85       	ldd	r30, Y+10	; 0x0a
    39c4:	fb 85       	ldd	r31, Y+11	; 0x0b
    39c6:	86 81       	ldd	r24, Z+6	; 0x06
    39c8:	97 81       	ldd	r25, Z+7	; 0x07
    39ca:	ed 81       	ldd	r30, Y+5	; 0x05
    39cc:	fe 81       	ldd	r31, Y+6	; 0x06
    39ce:	92 83       	std	Z+2, r25	; 0x02
    39d0:	81 83       	std	Z+1, r24	; 0x01
    39d2:	ea 85       	ldd	r30, Y+10	; 0x0a
    39d4:	fb 85       	ldd	r31, Y+11	; 0x0b
    39d6:	13 86       	std	Z+11, r1	; 0x0b
    39d8:	12 86       	std	Z+10, r1	; 0x0a
    39da:	ed 81       	ldd	r30, Y+5	; 0x05
    39dc:	fe 81       	ldd	r31, Y+6	; 0x06
    39de:	80 81       	ld	r24, Z
    39e0:	81 50       	subi	r24, 0x01	; 1
    39e2:	ed 81       	ldd	r30, Y+5	; 0x05
    39e4:	fe 81       	ldd	r31, Y+6	; 0x06
    39e6:	80 83       	st	Z, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    39e8:	ea 85       	ldd	r30, Y+10	; 0x0a
    39ea:	fb 85       	ldd	r31, Y+11	; 0x0b
    39ec:	96 89       	ldd	r25, Z+22	; 0x16
    39ee:	80 91 ac 06 	lds	r24, 0x06AC
    39f2:	89 17       	cp	r24, r25
    39f4:	28 f4       	brcc	.+10     	; 0x3a00 <xTaskRemoveFromEventList+0x138>
    39f6:	ea 85       	ldd	r30, Y+10	; 0x0a
    39f8:	fb 85       	ldd	r31, Y+11	; 0x0b
    39fa:	86 89       	ldd	r24, Z+22	; 0x16
    39fc:	80 93 ac 06 	sts	0x06AC, r24
    3a00:	ea 85       	ldd	r30, Y+10	; 0x0a
    3a02:	fb 85       	ldd	r31, Y+11	; 0x0b
    3a04:	86 89       	ldd	r24, Z+22	; 0x16
    3a06:	28 2f       	mov	r18, r24
    3a08:	30 e0       	ldi	r19, 0x00	; 0
    3a0a:	c9 01       	movw	r24, r18
    3a0c:	88 0f       	add	r24, r24
    3a0e:	99 1f       	adc	r25, r25
    3a10:	88 0f       	add	r24, r24
    3a12:	99 1f       	adc	r25, r25
    3a14:	88 0f       	add	r24, r24
    3a16:	99 1f       	adc	r25, r25
    3a18:	82 0f       	add	r24, r18
    3a1a:	93 1f       	adc	r25, r19
    3a1c:	fc 01       	movw	r30, r24
    3a1e:	e8 54       	subi	r30, 0x48	; 72
    3a20:	f9 4f       	sbci	r31, 0xF9	; 249
    3a22:	81 81       	ldd	r24, Z+1	; 0x01
    3a24:	92 81       	ldd	r25, Z+2	; 0x02
    3a26:	9c 83       	std	Y+4, r25	; 0x04
    3a28:	8b 83       	std	Y+3, r24	; 0x03
    3a2a:	ea 85       	ldd	r30, Y+10	; 0x0a
    3a2c:	fb 85       	ldd	r31, Y+11	; 0x0b
    3a2e:	8b 81       	ldd	r24, Y+3	; 0x03
    3a30:	9c 81       	ldd	r25, Y+4	; 0x04
    3a32:	95 83       	std	Z+5, r25	; 0x05
    3a34:	84 83       	std	Z+4, r24	; 0x04
    3a36:	eb 81       	ldd	r30, Y+3	; 0x03
    3a38:	fc 81       	ldd	r31, Y+4	; 0x04
    3a3a:	84 81       	ldd	r24, Z+4	; 0x04
    3a3c:	95 81       	ldd	r25, Z+5	; 0x05
    3a3e:	ea 85       	ldd	r30, Y+10	; 0x0a
    3a40:	fb 85       	ldd	r31, Y+11	; 0x0b
    3a42:	97 83       	std	Z+7, r25	; 0x07
    3a44:	86 83       	std	Z+6, r24	; 0x06
    3a46:	eb 81       	ldd	r30, Y+3	; 0x03
    3a48:	fc 81       	ldd	r31, Y+4	; 0x04
    3a4a:	04 80       	ldd	r0, Z+4	; 0x04
    3a4c:	f5 81       	ldd	r31, Z+5	; 0x05
    3a4e:	e0 2d       	mov	r30, r0
    3a50:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a52:	9b 85       	ldd	r25, Y+11	; 0x0b
    3a54:	02 96       	adiw	r24, 0x02	; 2
    3a56:	93 83       	std	Z+3, r25	; 0x03
    3a58:	82 83       	std	Z+2, r24	; 0x02
    3a5a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a5c:	9b 85       	ldd	r25, Y+11	; 0x0b
    3a5e:	02 96       	adiw	r24, 0x02	; 2
    3a60:	eb 81       	ldd	r30, Y+3	; 0x03
    3a62:	fc 81       	ldd	r31, Y+4	; 0x04
    3a64:	95 83       	std	Z+5, r25	; 0x05
    3a66:	84 83       	std	Z+4, r24	; 0x04
    3a68:	ea 85       	ldd	r30, Y+10	; 0x0a
    3a6a:	fb 85       	ldd	r31, Y+11	; 0x0b
    3a6c:	86 89       	ldd	r24, Z+22	; 0x16
    3a6e:	28 2f       	mov	r18, r24
    3a70:	30 e0       	ldi	r19, 0x00	; 0
    3a72:	c9 01       	movw	r24, r18
    3a74:	88 0f       	add	r24, r24
    3a76:	99 1f       	adc	r25, r25
    3a78:	88 0f       	add	r24, r24
    3a7a:	99 1f       	adc	r25, r25
    3a7c:	88 0f       	add	r24, r24
    3a7e:	99 1f       	adc	r25, r25
    3a80:	82 0f       	add	r24, r18
    3a82:	93 1f       	adc	r25, r19
    3a84:	88 54       	subi	r24, 0x48	; 72
    3a86:	99 4f       	sbci	r25, 0xF9	; 249
    3a88:	ea 85       	ldd	r30, Y+10	; 0x0a
    3a8a:	fb 85       	ldd	r31, Y+11	; 0x0b
    3a8c:	93 87       	std	Z+11, r25	; 0x0b
    3a8e:	82 87       	std	Z+10, r24	; 0x0a
    3a90:	ea 85       	ldd	r30, Y+10	; 0x0a
    3a92:	fb 85       	ldd	r31, Y+11	; 0x0b
    3a94:	86 89       	ldd	r24, Z+22	; 0x16
    3a96:	28 2f       	mov	r18, r24
    3a98:	30 e0       	ldi	r19, 0x00	; 0
    3a9a:	c9 01       	movw	r24, r18
    3a9c:	88 0f       	add	r24, r24
    3a9e:	99 1f       	adc	r25, r25
    3aa0:	88 0f       	add	r24, r24
    3aa2:	99 1f       	adc	r25, r25
    3aa4:	88 0f       	add	r24, r24
    3aa6:	99 1f       	adc	r25, r25
    3aa8:	82 0f       	add	r24, r18
    3aaa:	93 1f       	adc	r25, r19
    3aac:	fc 01       	movw	r30, r24
    3aae:	e8 54       	subi	r30, 0x48	; 72
    3ab0:	f9 4f       	sbci	r31, 0xF9	; 249
    3ab2:	80 81       	ld	r24, Z
    3ab4:	8f 5f       	subi	r24, 0xFF	; 255
    3ab6:	80 83       	st	Z, r24
    3ab8:	30 c0       	rjmp	.+96     	; 0x3b1a <xTaskRemoveFromEventList+0x252>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3aba:	80 91 f3 06 	lds	r24, 0x06F3
    3abe:	90 91 f4 06 	lds	r25, 0x06F4
    3ac2:	9a 83       	std	Y+2, r25	; 0x02
    3ac4:	89 83       	std	Y+1, r24	; 0x01
    3ac6:	ea 85       	ldd	r30, Y+10	; 0x0a
    3ac8:	fb 85       	ldd	r31, Y+11	; 0x0b
    3aca:	89 81       	ldd	r24, Y+1	; 0x01
    3acc:	9a 81       	ldd	r25, Y+2	; 0x02
    3ace:	97 87       	std	Z+15, r25	; 0x0f
    3ad0:	86 87       	std	Z+14, r24	; 0x0e
    3ad2:	e9 81       	ldd	r30, Y+1	; 0x01
    3ad4:	fa 81       	ldd	r31, Y+2	; 0x02
    3ad6:	84 81       	ldd	r24, Z+4	; 0x04
    3ad8:	95 81       	ldd	r25, Z+5	; 0x05
    3ada:	ea 85       	ldd	r30, Y+10	; 0x0a
    3adc:	fb 85       	ldd	r31, Y+11	; 0x0b
    3ade:	91 8b       	std	Z+17, r25	; 0x11
    3ae0:	80 8b       	std	Z+16, r24	; 0x10
    3ae2:	e9 81       	ldd	r30, Y+1	; 0x01
    3ae4:	fa 81       	ldd	r31, Y+2	; 0x02
    3ae6:	04 80       	ldd	r0, Z+4	; 0x04
    3ae8:	f5 81       	ldd	r31, Z+5	; 0x05
    3aea:	e0 2d       	mov	r30, r0
    3aec:	8a 85       	ldd	r24, Y+10	; 0x0a
    3aee:	9b 85       	ldd	r25, Y+11	; 0x0b
    3af0:	0c 96       	adiw	r24, 0x0c	; 12
    3af2:	93 83       	std	Z+3, r25	; 0x03
    3af4:	82 83       	std	Z+2, r24	; 0x02
    3af6:	8a 85       	ldd	r24, Y+10	; 0x0a
    3af8:	9b 85       	ldd	r25, Y+11	; 0x0b
    3afa:	0c 96       	adiw	r24, 0x0c	; 12
    3afc:	e9 81       	ldd	r30, Y+1	; 0x01
    3afe:	fa 81       	ldd	r31, Y+2	; 0x02
    3b00:	95 83       	std	Z+5, r25	; 0x05
    3b02:	84 83       	std	Z+4, r24	; 0x04
    3b04:	ea 85       	ldd	r30, Y+10	; 0x0a
    3b06:	fb 85       	ldd	r31, Y+11	; 0x0b
    3b08:	82 ef       	ldi	r24, 0xF2	; 242
    3b0a:	96 e0       	ldi	r25, 0x06	; 6
    3b0c:	95 8b       	std	Z+21, r25	; 0x15
    3b0e:	84 8b       	std	Z+20, r24	; 0x14
    3b10:	80 91 f2 06 	lds	r24, 0x06F2
    3b14:	8f 5f       	subi	r24, 0xFF	; 255
    3b16:	80 93 f2 06 	sts	0x06F2, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3b1a:	ea 85       	ldd	r30, Y+10	; 0x0a
    3b1c:	fb 85       	ldd	r31, Y+11	; 0x0b
    3b1e:	96 89       	ldd	r25, Z+22	; 0x16
    3b20:	e0 91 a6 06 	lds	r30, 0x06A6
    3b24:	f0 91 a7 06 	lds	r31, 0x06A7
    3b28:	86 89       	ldd	r24, Z+22	; 0x16
    3b2a:	89 17       	cp	r24, r25
    3b2c:	30 f4       	brcc	.+12     	; 0x3b3a <xTaskRemoveFromEventList+0x272>
    {
        /* Return true if the task removed from the event list has a higher
         * priority than the calling task.  This allows the calling task to know if
         * it should force a context switch now. */
        xReturn = pdTRUE;
    3b2e:	81 e0       	ldi	r24, 0x01	; 1
    3b30:	89 87       	std	Y+9, r24	; 0x09

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    3b32:	81 e0       	ldi	r24, 0x01	; 1
    3b34:	80 93 b0 06 	sts	0x06B0, r24
    3b38:	01 c0       	rjmp	.+2      	; 0x3b3c <xTaskRemoveFromEventList+0x274>
    }
    else
    {
        xReturn = pdFALSE;
    3b3a:	19 86       	std	Y+9, r1	; 0x09
    }

    return xReturn;
    3b3c:	89 85       	ldd	r24, Y+9	; 0x09
}
    3b3e:	2d 96       	adiw	r28, 0x0d	; 13
    3b40:	0f b6       	in	r0, 0x3f	; 63
    3b42:	f8 94       	cli
    3b44:	de bf       	out	0x3e, r29	; 62
    3b46:	0f be       	out	0x3f, r0	; 63
    3b48:	cd bf       	out	0x3d, r28	; 61
    3b4a:	cf 91       	pop	r28
    3b4c:	df 91       	pop	r29
    3b4e:	08 95       	ret

00003b50 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    3b50:	df 93       	push	r29
    3b52:	cf 93       	push	r28
    3b54:	cd b7       	in	r28, 0x3d	; 61
    3b56:	de b7       	in	r29, 0x3e	; 62
    3b58:	2c 97       	sbiw	r28, 0x0c	; 12
    3b5a:	0f b6       	in	r0, 0x3f	; 63
    3b5c:	f8 94       	cli
    3b5e:	de bf       	out	0x3e, r29	; 62
    3b60:	0f be       	out	0x3f, r0	; 63
    3b62:	cd bf       	out	0x3d, r28	; 61
    3b64:	9a 87       	std	Y+10, r25	; 0x0a
    3b66:	89 87       	std	Y+9, r24	; 0x09
    3b68:	7c 87       	std	Y+12, r23	; 0x0c
    3b6a:	6b 87       	std	Y+11, r22	; 0x0b
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3b6c:	8b 85       	ldd	r24, Y+11	; 0x0b
    3b6e:	9c 85       	ldd	r25, Y+12	; 0x0c
    3b70:	90 68       	ori	r25, 0x80	; 128
    3b72:	e9 85       	ldd	r30, Y+9	; 0x09
    3b74:	fa 85       	ldd	r31, Y+10	; 0x0a
    3b76:	91 83       	std	Z+1, r25	; 0x01
    3b78:	80 83       	st	Z, r24

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3b7a:	e9 85       	ldd	r30, Y+9	; 0x09
    3b7c:	fa 85       	ldd	r31, Y+10	; 0x0a
    3b7e:	86 81       	ldd	r24, Z+6	; 0x06
    3b80:	97 81       	ldd	r25, Z+7	; 0x07
    3b82:	98 87       	std	Y+8, r25	; 0x08
    3b84:	8f 83       	std	Y+7, r24	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    3b86:	e9 85       	ldd	r30, Y+9	; 0x09
    3b88:	fa 85       	ldd	r31, Y+10	; 0x0a
    3b8a:	80 85       	ldd	r24, Z+8	; 0x08
    3b8c:	91 85       	ldd	r25, Z+9	; 0x09
    3b8e:	9e 83       	std	Y+6, r25	; 0x06
    3b90:	8d 83       	std	Y+5, r24	; 0x05
    3b92:	e9 85       	ldd	r30, Y+9	; 0x09
    3b94:	fa 85       	ldd	r31, Y+10	; 0x0a
    3b96:	a2 81       	ldd	r26, Z+2	; 0x02
    3b98:	b3 81       	ldd	r27, Z+3	; 0x03
    3b9a:	e9 85       	ldd	r30, Y+9	; 0x09
    3b9c:	fa 85       	ldd	r31, Y+10	; 0x0a
    3b9e:	84 81       	ldd	r24, Z+4	; 0x04
    3ba0:	95 81       	ldd	r25, Z+5	; 0x05
    3ba2:	15 96       	adiw	r26, 0x05	; 5
    3ba4:	9c 93       	st	X, r25
    3ba6:	8e 93       	st	-X, r24
    3ba8:	14 97       	sbiw	r26, 0x04	; 4
    3baa:	e9 85       	ldd	r30, Y+9	; 0x09
    3bac:	fa 85       	ldd	r31, Y+10	; 0x0a
    3bae:	a4 81       	ldd	r26, Z+4	; 0x04
    3bb0:	b5 81       	ldd	r27, Z+5	; 0x05
    3bb2:	e9 85       	ldd	r30, Y+9	; 0x09
    3bb4:	fa 85       	ldd	r31, Y+10	; 0x0a
    3bb6:	82 81       	ldd	r24, Z+2	; 0x02
    3bb8:	93 81       	ldd	r25, Z+3	; 0x03
    3bba:	13 96       	adiw	r26, 0x03	; 3
    3bbc:	9c 93       	st	X, r25
    3bbe:	8e 93       	st	-X, r24
    3bc0:	12 97       	sbiw	r26, 0x02	; 2
    3bc2:	ed 81       	ldd	r30, Y+5	; 0x05
    3bc4:	fe 81       	ldd	r31, Y+6	; 0x06
    3bc6:	21 81       	ldd	r18, Z+1	; 0x01
    3bc8:	32 81       	ldd	r19, Z+2	; 0x02
    3bca:	89 85       	ldd	r24, Y+9	; 0x09
    3bcc:	9a 85       	ldd	r25, Y+10	; 0x0a
    3bce:	28 17       	cp	r18, r24
    3bd0:	39 07       	cpc	r19, r25
    3bd2:	41 f4       	brne	.+16     	; 0x3be4 <vTaskRemoveFromUnorderedEventList+0x94>
    3bd4:	e9 85       	ldd	r30, Y+9	; 0x09
    3bd6:	fa 85       	ldd	r31, Y+10	; 0x0a
    3bd8:	84 81       	ldd	r24, Z+4	; 0x04
    3bda:	95 81       	ldd	r25, Z+5	; 0x05
    3bdc:	ed 81       	ldd	r30, Y+5	; 0x05
    3bde:	fe 81       	ldd	r31, Y+6	; 0x06
    3be0:	92 83       	std	Z+2, r25	; 0x02
    3be2:	81 83       	std	Z+1, r24	; 0x01
    3be4:	e9 85       	ldd	r30, Y+9	; 0x09
    3be6:	fa 85       	ldd	r31, Y+10	; 0x0a
    3be8:	11 86       	std	Z+9, r1	; 0x09
    3bea:	10 86       	std	Z+8, r1	; 0x08
    3bec:	ed 81       	ldd	r30, Y+5	; 0x05
    3bee:	fe 81       	ldd	r31, Y+6	; 0x06
    3bf0:	80 81       	ld	r24, Z
    3bf2:	81 50       	subi	r24, 0x01	; 1
    3bf4:	ed 81       	ldd	r30, Y+5	; 0x05
    3bf6:	fe 81       	ldd	r31, Y+6	; 0x06
    3bf8:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    3bfa:	ef 81       	ldd	r30, Y+7	; 0x07
    3bfc:	f8 85       	ldd	r31, Y+8	; 0x08
    3bfe:	82 85       	ldd	r24, Z+10	; 0x0a
    3c00:	93 85       	ldd	r25, Z+11	; 0x0b
    3c02:	9c 83       	std	Y+4, r25	; 0x04
    3c04:	8b 83       	std	Y+3, r24	; 0x03
    3c06:	ef 81       	ldd	r30, Y+7	; 0x07
    3c08:	f8 85       	ldd	r31, Y+8	; 0x08
    3c0a:	a4 81       	ldd	r26, Z+4	; 0x04
    3c0c:	b5 81       	ldd	r27, Z+5	; 0x05
    3c0e:	ef 81       	ldd	r30, Y+7	; 0x07
    3c10:	f8 85       	ldd	r31, Y+8	; 0x08
    3c12:	86 81       	ldd	r24, Z+6	; 0x06
    3c14:	97 81       	ldd	r25, Z+7	; 0x07
    3c16:	15 96       	adiw	r26, 0x05	; 5
    3c18:	9c 93       	st	X, r25
    3c1a:	8e 93       	st	-X, r24
    3c1c:	14 97       	sbiw	r26, 0x04	; 4
    3c1e:	ef 81       	ldd	r30, Y+7	; 0x07
    3c20:	f8 85       	ldd	r31, Y+8	; 0x08
    3c22:	a6 81       	ldd	r26, Z+6	; 0x06
    3c24:	b7 81       	ldd	r27, Z+7	; 0x07
    3c26:	ef 81       	ldd	r30, Y+7	; 0x07
    3c28:	f8 85       	ldd	r31, Y+8	; 0x08
    3c2a:	84 81       	ldd	r24, Z+4	; 0x04
    3c2c:	95 81       	ldd	r25, Z+5	; 0x05
    3c2e:	13 96       	adiw	r26, 0x03	; 3
    3c30:	9c 93       	st	X, r25
    3c32:	8e 93       	st	-X, r24
    3c34:	12 97       	sbiw	r26, 0x02	; 2
    3c36:	eb 81       	ldd	r30, Y+3	; 0x03
    3c38:	fc 81       	ldd	r31, Y+4	; 0x04
    3c3a:	21 81       	ldd	r18, Z+1	; 0x01
    3c3c:	32 81       	ldd	r19, Z+2	; 0x02
    3c3e:	8f 81       	ldd	r24, Y+7	; 0x07
    3c40:	98 85       	ldd	r25, Y+8	; 0x08
    3c42:	02 96       	adiw	r24, 0x02	; 2
    3c44:	28 17       	cp	r18, r24
    3c46:	39 07       	cpc	r19, r25
    3c48:	41 f4       	brne	.+16     	; 0x3c5a <vTaskRemoveFromUnorderedEventList+0x10a>
    3c4a:	ef 81       	ldd	r30, Y+7	; 0x07
    3c4c:	f8 85       	ldd	r31, Y+8	; 0x08
    3c4e:	86 81       	ldd	r24, Z+6	; 0x06
    3c50:	97 81       	ldd	r25, Z+7	; 0x07
    3c52:	eb 81       	ldd	r30, Y+3	; 0x03
    3c54:	fc 81       	ldd	r31, Y+4	; 0x04
    3c56:	92 83       	std	Z+2, r25	; 0x02
    3c58:	81 83       	std	Z+1, r24	; 0x01
    3c5a:	ef 81       	ldd	r30, Y+7	; 0x07
    3c5c:	f8 85       	ldd	r31, Y+8	; 0x08
    3c5e:	13 86       	std	Z+11, r1	; 0x0b
    3c60:	12 86       	std	Z+10, r1	; 0x0a
    3c62:	eb 81       	ldd	r30, Y+3	; 0x03
    3c64:	fc 81       	ldd	r31, Y+4	; 0x04
    3c66:	80 81       	ld	r24, Z
    3c68:	81 50       	subi	r24, 0x01	; 1
    3c6a:	eb 81       	ldd	r30, Y+3	; 0x03
    3c6c:	fc 81       	ldd	r31, Y+4	; 0x04
    3c6e:	80 83       	st	Z, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    3c70:	ef 81       	ldd	r30, Y+7	; 0x07
    3c72:	f8 85       	ldd	r31, Y+8	; 0x08
    3c74:	96 89       	ldd	r25, Z+22	; 0x16
    3c76:	80 91 ac 06 	lds	r24, 0x06AC
    3c7a:	89 17       	cp	r24, r25
    3c7c:	28 f4       	brcc	.+10     	; 0x3c88 <vTaskRemoveFromUnorderedEventList+0x138>
    3c7e:	ef 81       	ldd	r30, Y+7	; 0x07
    3c80:	f8 85       	ldd	r31, Y+8	; 0x08
    3c82:	86 89       	ldd	r24, Z+22	; 0x16
    3c84:	80 93 ac 06 	sts	0x06AC, r24
    3c88:	ef 81       	ldd	r30, Y+7	; 0x07
    3c8a:	f8 85       	ldd	r31, Y+8	; 0x08
    3c8c:	86 89       	ldd	r24, Z+22	; 0x16
    3c8e:	28 2f       	mov	r18, r24
    3c90:	30 e0       	ldi	r19, 0x00	; 0
    3c92:	c9 01       	movw	r24, r18
    3c94:	88 0f       	add	r24, r24
    3c96:	99 1f       	adc	r25, r25
    3c98:	88 0f       	add	r24, r24
    3c9a:	99 1f       	adc	r25, r25
    3c9c:	88 0f       	add	r24, r24
    3c9e:	99 1f       	adc	r25, r25
    3ca0:	82 0f       	add	r24, r18
    3ca2:	93 1f       	adc	r25, r19
    3ca4:	fc 01       	movw	r30, r24
    3ca6:	e8 54       	subi	r30, 0x48	; 72
    3ca8:	f9 4f       	sbci	r31, 0xF9	; 249
    3caa:	81 81       	ldd	r24, Z+1	; 0x01
    3cac:	92 81       	ldd	r25, Z+2	; 0x02
    3cae:	9a 83       	std	Y+2, r25	; 0x02
    3cb0:	89 83       	std	Y+1, r24	; 0x01
    3cb2:	ef 81       	ldd	r30, Y+7	; 0x07
    3cb4:	f8 85       	ldd	r31, Y+8	; 0x08
    3cb6:	89 81       	ldd	r24, Y+1	; 0x01
    3cb8:	9a 81       	ldd	r25, Y+2	; 0x02
    3cba:	95 83       	std	Z+5, r25	; 0x05
    3cbc:	84 83       	std	Z+4, r24	; 0x04
    3cbe:	e9 81       	ldd	r30, Y+1	; 0x01
    3cc0:	fa 81       	ldd	r31, Y+2	; 0x02
    3cc2:	84 81       	ldd	r24, Z+4	; 0x04
    3cc4:	95 81       	ldd	r25, Z+5	; 0x05
    3cc6:	ef 81       	ldd	r30, Y+7	; 0x07
    3cc8:	f8 85       	ldd	r31, Y+8	; 0x08
    3cca:	97 83       	std	Z+7, r25	; 0x07
    3ccc:	86 83       	std	Z+6, r24	; 0x06
    3cce:	e9 81       	ldd	r30, Y+1	; 0x01
    3cd0:	fa 81       	ldd	r31, Y+2	; 0x02
    3cd2:	04 80       	ldd	r0, Z+4	; 0x04
    3cd4:	f5 81       	ldd	r31, Z+5	; 0x05
    3cd6:	e0 2d       	mov	r30, r0
    3cd8:	8f 81       	ldd	r24, Y+7	; 0x07
    3cda:	98 85       	ldd	r25, Y+8	; 0x08
    3cdc:	02 96       	adiw	r24, 0x02	; 2
    3cde:	93 83       	std	Z+3, r25	; 0x03
    3ce0:	82 83       	std	Z+2, r24	; 0x02
    3ce2:	8f 81       	ldd	r24, Y+7	; 0x07
    3ce4:	98 85       	ldd	r25, Y+8	; 0x08
    3ce6:	02 96       	adiw	r24, 0x02	; 2
    3ce8:	e9 81       	ldd	r30, Y+1	; 0x01
    3cea:	fa 81       	ldd	r31, Y+2	; 0x02
    3cec:	95 83       	std	Z+5, r25	; 0x05
    3cee:	84 83       	std	Z+4, r24	; 0x04
    3cf0:	ef 81       	ldd	r30, Y+7	; 0x07
    3cf2:	f8 85       	ldd	r31, Y+8	; 0x08
    3cf4:	86 89       	ldd	r24, Z+22	; 0x16
    3cf6:	28 2f       	mov	r18, r24
    3cf8:	30 e0       	ldi	r19, 0x00	; 0
    3cfa:	c9 01       	movw	r24, r18
    3cfc:	88 0f       	add	r24, r24
    3cfe:	99 1f       	adc	r25, r25
    3d00:	88 0f       	add	r24, r24
    3d02:	99 1f       	adc	r25, r25
    3d04:	88 0f       	add	r24, r24
    3d06:	99 1f       	adc	r25, r25
    3d08:	82 0f       	add	r24, r18
    3d0a:	93 1f       	adc	r25, r19
    3d0c:	88 54       	subi	r24, 0x48	; 72
    3d0e:	99 4f       	sbci	r25, 0xF9	; 249
    3d10:	ef 81       	ldd	r30, Y+7	; 0x07
    3d12:	f8 85       	ldd	r31, Y+8	; 0x08
    3d14:	93 87       	std	Z+11, r25	; 0x0b
    3d16:	82 87       	std	Z+10, r24	; 0x0a
    3d18:	ef 81       	ldd	r30, Y+7	; 0x07
    3d1a:	f8 85       	ldd	r31, Y+8	; 0x08
    3d1c:	86 89       	ldd	r24, Z+22	; 0x16
    3d1e:	28 2f       	mov	r18, r24
    3d20:	30 e0       	ldi	r19, 0x00	; 0
    3d22:	c9 01       	movw	r24, r18
    3d24:	88 0f       	add	r24, r24
    3d26:	99 1f       	adc	r25, r25
    3d28:	88 0f       	add	r24, r24
    3d2a:	99 1f       	adc	r25, r25
    3d2c:	88 0f       	add	r24, r24
    3d2e:	99 1f       	adc	r25, r25
    3d30:	82 0f       	add	r24, r18
    3d32:	93 1f       	adc	r25, r19
    3d34:	fc 01       	movw	r30, r24
    3d36:	e8 54       	subi	r30, 0x48	; 72
    3d38:	f9 4f       	sbci	r31, 0xF9	; 249
    3d3a:	80 81       	ld	r24, Z
    3d3c:	8f 5f       	subi	r24, 0xFF	; 255
    3d3e:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3d40:	ef 81       	ldd	r30, Y+7	; 0x07
    3d42:	f8 85       	ldd	r31, Y+8	; 0x08
    3d44:	96 89       	ldd	r25, Z+22	; 0x16
    3d46:	e0 91 a6 06 	lds	r30, 0x06A6
    3d4a:	f0 91 a7 06 	lds	r31, 0x06A7
    3d4e:	86 89       	ldd	r24, Z+22	; 0x16
    3d50:	89 17       	cp	r24, r25
    3d52:	18 f4       	brcc	.+6      	; 0x3d5a <vTaskRemoveFromUnorderedEventList+0x20a>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    3d54:	81 e0       	ldi	r24, 0x01	; 1
    3d56:	80 93 b0 06 	sts	0x06B0, r24
    }
}
    3d5a:	2c 96       	adiw	r28, 0x0c	; 12
    3d5c:	0f b6       	in	r0, 0x3f	; 63
    3d5e:	f8 94       	cli
    3d60:	de bf       	out	0x3e, r29	; 62
    3d62:	0f be       	out	0x3f, r0	; 63
    3d64:	cd bf       	out	0x3d, r28	; 61
    3d66:	cf 91       	pop	r28
    3d68:	df 91       	pop	r29
    3d6a:	08 95       	ret

00003d6c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3d6c:	df 93       	push	r29
    3d6e:	cf 93       	push	r28
    3d70:	00 d0       	rcall	.+0      	; 0x3d72 <vTaskSetTimeOutState+0x6>
    3d72:	cd b7       	in	r28, 0x3d	; 61
    3d74:	de b7       	in	r29, 0x3e	; 62
    3d76:	9a 83       	std	Y+2, r25	; 0x02
    3d78:	89 83       	std	Y+1, r24	; 0x01
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    3d7a:	0f b6       	in	r0, 0x3f	; 63
    3d7c:	f8 94       	cli
    3d7e:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    3d80:	80 91 b1 06 	lds	r24, 0x06B1
    3d84:	e9 81       	ldd	r30, Y+1	; 0x01
    3d86:	fa 81       	ldd	r31, Y+2	; 0x02
    3d88:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    3d8a:	80 91 aa 06 	lds	r24, 0x06AA
    3d8e:	90 91 ab 06 	lds	r25, 0x06AB
    3d92:	e9 81       	ldd	r30, Y+1	; 0x01
    3d94:	fa 81       	ldd	r31, Y+2	; 0x02
    3d96:	92 83       	std	Z+2, r25	; 0x02
    3d98:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    3d9a:	0f 90       	pop	r0
    3d9c:	0f be       	out	0x3f, r0	; 63
}
    3d9e:	0f 90       	pop	r0
    3da0:	0f 90       	pop	r0
    3da2:	cf 91       	pop	r28
    3da4:	df 91       	pop	r29
    3da6:	08 95       	ret

00003da8 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3da8:	df 93       	push	r29
    3daa:	cf 93       	push	r28
    3dac:	00 d0       	rcall	.+0      	; 0x3dae <vTaskInternalSetTimeOutState+0x6>
    3dae:	cd b7       	in	r28, 0x3d	; 61
    3db0:	de b7       	in	r29, 0x3e	; 62
    3db2:	9a 83       	std	Y+2, r25	; 0x02
    3db4:	89 83       	std	Y+1, r24	; 0x01
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    3db6:	80 91 b1 06 	lds	r24, 0x06B1
    3dba:	e9 81       	ldd	r30, Y+1	; 0x01
    3dbc:	fa 81       	ldd	r31, Y+2	; 0x02
    3dbe:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    3dc0:	80 91 aa 06 	lds	r24, 0x06AA
    3dc4:	90 91 ab 06 	lds	r25, 0x06AB
    3dc8:	e9 81       	ldd	r30, Y+1	; 0x01
    3dca:	fa 81       	ldd	r31, Y+2	; 0x02
    3dcc:	92 83       	std	Z+2, r25	; 0x02
    3dce:	81 83       	std	Z+1, r24	; 0x01
}
    3dd0:	0f 90       	pop	r0
    3dd2:	0f 90       	pop	r0
    3dd4:	cf 91       	pop	r28
    3dd6:	df 91       	pop	r29
    3dd8:	08 95       	ret

00003dda <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    3dda:	df 93       	push	r29
    3ddc:	cf 93       	push	r28
    3dde:	cd b7       	in	r28, 0x3d	; 61
    3de0:	de b7       	in	r29, 0x3e	; 62
    3de2:	29 97       	sbiw	r28, 0x09	; 9
    3de4:	0f b6       	in	r0, 0x3f	; 63
    3de6:	f8 94       	cli
    3de8:	de bf       	out	0x3e, r29	; 62
    3dea:	0f be       	out	0x3f, r0	; 63
    3dec:	cd bf       	out	0x3d, r28	; 61
    3dee:	9f 83       	std	Y+7, r25	; 0x07
    3df0:	8e 83       	std	Y+6, r24	; 0x06
    3df2:	79 87       	std	Y+9, r23	; 0x09
    3df4:	68 87       	std	Y+8, r22	; 0x08
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    3df6:	0f b6       	in	r0, 0x3f	; 63
    3df8:	f8 94       	cli
    3dfa:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    3dfc:	80 91 aa 06 	lds	r24, 0x06AA
    3e00:	90 91 ab 06 	lds	r25, 0x06AB
    3e04:	9c 83       	std	Y+4, r25	; 0x04
    3e06:	8b 83       	std	Y+3, r24	; 0x03
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    3e08:	ee 81       	ldd	r30, Y+6	; 0x06
    3e0a:	ff 81       	ldd	r31, Y+7	; 0x07
    3e0c:	21 81       	ldd	r18, Z+1	; 0x01
    3e0e:	32 81       	ldd	r19, Z+2	; 0x02
    3e10:	8b 81       	ldd	r24, Y+3	; 0x03
    3e12:	9c 81       	ldd	r25, Y+4	; 0x04
    3e14:	82 1b       	sub	r24, r18
    3e16:	93 0b       	sbc	r25, r19
    3e18:	9a 83       	std	Y+2, r25	; 0x02
    3e1a:	89 83       	std	Y+1, r24	; 0x01
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3e1c:	ee 81       	ldd	r30, Y+6	; 0x06
    3e1e:	ff 81       	ldd	r31, Y+7	; 0x07
    3e20:	90 81       	ld	r25, Z
    3e22:	80 91 b1 06 	lds	r24, 0x06B1
    3e26:	98 17       	cp	r25, r24
    3e28:	81 f0       	breq	.+32     	; 0x3e4a <xTaskCheckForTimeOut+0x70>
    3e2a:	ee 81       	ldd	r30, Y+6	; 0x06
    3e2c:	ff 81       	ldd	r31, Y+7	; 0x07
    3e2e:	21 81       	ldd	r18, Z+1	; 0x01
    3e30:	32 81       	ldd	r19, Z+2	; 0x02
    3e32:	8b 81       	ldd	r24, Y+3	; 0x03
    3e34:	9c 81       	ldd	r25, Y+4	; 0x04
    3e36:	82 17       	cp	r24, r18
    3e38:	93 07       	cpc	r25, r19
    3e3a:	38 f0       	brcs	.+14     	; 0x3e4a <xTaskCheckForTimeOut+0x70>
            /* The tick count is greater than the time at which
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
    3e3c:	81 e0       	ldi	r24, 0x01	; 1
    3e3e:	8d 83       	std	Y+5, r24	; 0x05
            *pxTicksToWait = ( TickType_t ) 0;
    3e40:	e8 85       	ldd	r30, Y+8	; 0x08
    3e42:	f9 85       	ldd	r31, Y+9	; 0x09
    3e44:	11 82       	std	Z+1, r1	; 0x01
    3e46:	10 82       	st	Z, r1
    3e48:	23 c0       	rjmp	.+70     	; 0x3e90 <xTaskCheckForTimeOut+0xb6>
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    3e4a:	e8 85       	ldd	r30, Y+8	; 0x08
    3e4c:	f9 85       	ldd	r31, Y+9	; 0x09
    3e4e:	20 81       	ld	r18, Z
    3e50:	31 81       	ldd	r19, Z+1	; 0x01
    3e52:	89 81       	ldd	r24, Y+1	; 0x01
    3e54:	9a 81       	ldd	r25, Y+2	; 0x02
    3e56:	82 17       	cp	r24, r18
    3e58:	93 07       	cpc	r25, r19
    3e5a:	a0 f4       	brcc	.+40     	; 0x3e84 <xTaskCheckForTimeOut+0xaa>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    3e5c:	e8 85       	ldd	r30, Y+8	; 0x08
    3e5e:	f9 85       	ldd	r31, Y+9	; 0x09
    3e60:	20 81       	ld	r18, Z
    3e62:	31 81       	ldd	r19, Z+1	; 0x01
    3e64:	89 81       	ldd	r24, Y+1	; 0x01
    3e66:	9a 81       	ldd	r25, Y+2	; 0x02
    3e68:	a9 01       	movw	r20, r18
    3e6a:	48 1b       	sub	r20, r24
    3e6c:	59 0b       	sbc	r21, r25
    3e6e:	ca 01       	movw	r24, r20
    3e70:	e8 85       	ldd	r30, Y+8	; 0x08
    3e72:	f9 85       	ldd	r31, Y+9	; 0x09
    3e74:	91 83       	std	Z+1, r25	; 0x01
    3e76:	80 83       	st	Z, r24
            vTaskInternalSetTimeOutState( pxTimeOut );
    3e78:	8e 81       	ldd	r24, Y+6	; 0x06
    3e7a:	9f 81       	ldd	r25, Y+7	; 0x07
    3e7c:	0e 94 d4 1e 	call	0x3da8	; 0x3da8 <vTaskInternalSetTimeOutState>
            xReturn = pdFALSE;
    3e80:	1d 82       	std	Y+5, r1	; 0x05
    3e82:	06 c0       	rjmp	.+12     	; 0x3e90 <xTaskCheckForTimeOut+0xb6>
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    3e84:	e8 85       	ldd	r30, Y+8	; 0x08
    3e86:	f9 85       	ldd	r31, Y+9	; 0x09
    3e88:	11 82       	std	Z+1, r1	; 0x01
    3e8a:	10 82       	st	Z, r1
            xReturn = pdTRUE;
    3e8c:	81 e0       	ldi	r24, 0x01	; 1
    3e8e:	8d 83       	std	Y+5, r24	; 0x05
        }
    }
    taskEXIT_CRITICAL();
    3e90:	0f 90       	pop	r0
    3e92:	0f be       	out	0x3f, r0	; 63

    return xReturn;
    3e94:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3e96:	29 96       	adiw	r28, 0x09	; 9
    3e98:	0f b6       	in	r0, 0x3f	; 63
    3e9a:	f8 94       	cli
    3e9c:	de bf       	out	0x3e, r29	; 62
    3e9e:	0f be       	out	0x3f, r0	; 63
    3ea0:	cd bf       	out	0x3d, r28	; 61
    3ea2:	cf 91       	pop	r28
    3ea4:	df 91       	pop	r29
    3ea6:	08 95       	ret

00003ea8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    3ea8:	df 93       	push	r29
    3eaa:	cf 93       	push	r28
    3eac:	cd b7       	in	r28, 0x3d	; 61
    3eae:	de b7       	in	r29, 0x3e	; 62
    xYieldPending = pdTRUE;
    3eb0:	81 e0       	ldi	r24, 0x01	; 1
    3eb2:	80 93 b0 06 	sts	0x06B0, r24
}
    3eb6:	cf 91       	pop	r28
    3eb8:	df 91       	pop	r29
    3eba:	08 95       	ret

00003ebc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    3ebc:	df 93       	push	r29
    3ebe:	cf 93       	push	r28
    3ec0:	00 d0       	rcall	.+0      	; 0x3ec2 <prvIdleTask+0x6>
    3ec2:	cd b7       	in	r28, 0x3d	; 61
    3ec4:	de b7       	in	r29, 0x3e	; 62
    3ec6:	9a 83       	std	Y+2, r25	; 0x02
    3ec8:	89 83       	std	Y+1, r24	; 0x01

    for( ; ; )
    {
        /* See if any tasks have deleted themselves - if so then the idle task
         * is responsible for freeing the deleted task's TCB and stack. */
        prvCheckTasksWaitingTermination();
    3eca:	0e 94 ab 1f 	call	0x3f56	; 0x3f56 <prvCheckTasksWaitingTermination>
                 *
                 * A critical region is not required here as we are just reading from
                 * the list, and an occasional incorrect value will not matter.  If
                 * the ready list at the idle priority contains more than one task
                 * then a task other than the idle task is ready to execute. */
                if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    3ece:	80 91 b8 06 	lds	r24, 0x06B8
    3ed2:	82 30       	cpi	r24, 0x02	; 2
    3ed4:	d0 f3       	brcs	.-12     	; 0x3eca <prvIdleTask+0xe>
                {
                    taskYIELD();
    3ed6:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    3eda:	f7 cf       	rjmp	.-18     	; 0x3eca <prvIdleTask+0xe>

00003edc <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    3edc:	df 93       	push	r29
    3ede:	cf 93       	push	r28
    3ee0:	0f 92       	push	r0
    3ee2:	cd b7       	in	r28, 0x3d	; 61
    3ee4:	de b7       	in	r29, 0x3e	; 62
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3ee6:	19 82       	std	Y+1, r1	; 0x01
    3ee8:	13 c0       	rjmp	.+38     	; 0x3f10 <prvInitialiseTaskLists+0x34>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    3eea:	89 81       	ldd	r24, Y+1	; 0x01
    3eec:	28 2f       	mov	r18, r24
    3eee:	30 e0       	ldi	r19, 0x00	; 0
    3ef0:	c9 01       	movw	r24, r18
    3ef2:	88 0f       	add	r24, r24
    3ef4:	99 1f       	adc	r25, r25
    3ef6:	88 0f       	add	r24, r24
    3ef8:	99 1f       	adc	r25, r25
    3efa:	88 0f       	add	r24, r24
    3efc:	99 1f       	adc	r25, r25
    3efe:	82 0f       	add	r24, r18
    3f00:	93 1f       	adc	r25, r19
    3f02:	88 54       	subi	r24, 0x48	; 72
    3f04:	99 4f       	sbci	r25, 0xF9	; 249
    3f06:	0e 94 c1 09 	call	0x1382	; 0x1382 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3f0a:	89 81       	ldd	r24, Y+1	; 0x01
    3f0c:	8f 5f       	subi	r24, 0xFF	; 255
    3f0e:	89 83       	std	Y+1, r24	; 0x01
    3f10:	89 81       	ldd	r24, Y+1	; 0x01
    3f12:	84 30       	cpi	r24, 0x04	; 4
    3f14:	50 f3       	brcs	.-44     	; 0x3eea <prvInitialiseTaskLists+0xe>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    3f16:	8c ed       	ldi	r24, 0xDC	; 220
    3f18:	96 e0       	ldi	r25, 0x06	; 6
    3f1a:	0e 94 c1 09 	call	0x1382	; 0x1382 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    3f1e:	85 ee       	ldi	r24, 0xE5	; 229
    3f20:	96 e0       	ldi	r25, 0x06	; 6
    3f22:	0e 94 c1 09 	call	0x1382	; 0x1382 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    3f26:	82 ef       	ldi	r24, 0xF2	; 242
    3f28:	96 e0       	ldi	r25, 0x06	; 6
    3f2a:	0e 94 c1 09 	call	0x1382	; 0x1382 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
        {
            vListInitialise( &xTasksWaitingTermination );
    3f2e:	8b ef       	ldi	r24, 0xFB	; 251
    3f30:	96 e0       	ldi	r25, 0x06	; 6
    3f32:	0e 94 c1 09 	call	0x1382	; 0x1382 <vListInitialise>
        }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    3f36:	8c ed       	ldi	r24, 0xDC	; 220
    3f38:	96 e0       	ldi	r25, 0x06	; 6
    3f3a:	90 93 ef 06 	sts	0x06EF, r25
    3f3e:	80 93 ee 06 	sts	0x06EE, r24
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3f42:	85 ee       	ldi	r24, 0xE5	; 229
    3f44:	96 e0       	ldi	r25, 0x06	; 6
    3f46:	90 93 f1 06 	sts	0x06F1, r25
    3f4a:	80 93 f0 06 	sts	0x06F0, r24
}
    3f4e:	0f 90       	pop	r0
    3f50:	cf 91       	pop	r28
    3f52:	df 91       	pop	r29
    3f54:	08 95       	ret

00003f56 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    3f56:	df 93       	push	r29
    3f58:	cf 93       	push	r28
    3f5a:	00 d0       	rcall	.+0      	; 0x3f5c <prvCheckTasksWaitingTermination+0x6>
    3f5c:	cd b7       	in	r28, 0x3d	; 61
    3f5e:	de b7       	in	r29, 0x3e	; 62
    3f60:	20 c0       	rjmp	.+64     	; 0x3fa2 <prvCheckTasksWaitingTermination+0x4c>

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
            {
                taskENTER_CRITICAL();
    3f62:	0f b6       	in	r0, 0x3f	; 63
    3f64:	f8 94       	cli
    3f66:	0f 92       	push	r0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3f68:	e0 91 00 07 	lds	r30, 0x0700
    3f6c:	f0 91 01 07 	lds	r31, 0x0701
    3f70:	86 81       	ldd	r24, Z+6	; 0x06
    3f72:	97 81       	ldd	r25, Z+7	; 0x07
    3f74:	9a 83       	std	Y+2, r25	; 0x02
    3f76:	89 83       	std	Y+1, r24	; 0x01
                    ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3f78:	89 81       	ldd	r24, Y+1	; 0x01
    3f7a:	9a 81       	ldd	r25, Y+2	; 0x02
    3f7c:	02 96       	adiw	r24, 0x02	; 2
    3f7e:	0e 94 ab 0a 	call	0x1556	; 0x1556 <uxListRemove>
                    --uxCurrentNumberOfTasks;
    3f82:	80 91 a9 06 	lds	r24, 0x06A9
    3f86:	81 50       	subi	r24, 0x01	; 1
    3f88:	80 93 a9 06 	sts	0x06A9, r24
                    --uxDeletedTasksWaitingCleanUp;
    3f8c:	80 91 a8 06 	lds	r24, 0x06A8
    3f90:	81 50       	subi	r24, 0x01	; 1
    3f92:	80 93 a8 06 	sts	0x06A8, r24
                }
                taskEXIT_CRITICAL();
    3f96:	0f 90       	pop	r0
    3f98:	0f be       	out	0x3f, r0	; 63

                prvDeleteTCB( pxTCB );
    3f9a:	89 81       	ldd	r24, Y+1	; 0x01
    3f9c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f9e:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <prvDeleteTCB>
        {
            TCB_t * pxTCB;

            /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
             * being called too often in the idle task. */
            while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    3fa2:	80 91 a8 06 	lds	r24, 0x06A8
    3fa6:	88 23       	and	r24, r24
    3fa8:	e1 f6       	brne	.-72     	; 0x3f62 <prvCheckTasksWaitingTermination+0xc>

                prvDeleteTCB( pxTCB );
            }
        }
    #endif /* INCLUDE_vTaskDelete */
}
    3faa:	0f 90       	pop	r0
    3fac:	0f 90       	pop	r0
    3fae:	cf 91       	pop	r28
    3fb0:	df 91       	pop	r29
    3fb2:	08 95       	ret

00003fb4 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    3fb4:	df 93       	push	r29
    3fb6:	cf 93       	push	r28
    3fb8:	00 d0       	rcall	.+0      	; 0x3fba <prvDeleteTCB+0x6>
    3fba:	cd b7       	in	r28, 0x3d	; 61
    3fbc:	de b7       	in	r29, 0x3e	; 62
    3fbe:	9a 83       	std	Y+2, r25	; 0x02
    3fc0:	89 83       	std	Y+1, r24	; 0x01

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
            {
                /* The task can only have been allocated dynamically - free both
                 * the stack and TCB. */
                vPortFreeStack( pxTCB->pxStack );
    3fc2:	e9 81       	ldd	r30, Y+1	; 0x01
    3fc4:	fa 81       	ldd	r31, Y+2	; 0x02
    3fc6:	87 89       	ldd	r24, Z+23	; 0x17
    3fc8:	90 8d       	ldd	r25, Z+24	; 0x18
    3fca:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                vPortFree( pxTCB );
    3fce:	89 81       	ldd	r24, Y+1	; 0x01
    3fd0:	9a 81       	ldd	r25, Y+2	; 0x02
    3fd2:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
                    configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    3fd6:	0f 90       	pop	r0
    3fd8:	0f 90       	pop	r0
    3fda:	cf 91       	pop	r28
    3fdc:	df 91       	pop	r29
    3fde:	08 95       	ret

00003fe0 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    3fe0:	df 93       	push	r29
    3fe2:	cf 93       	push	r28
    3fe4:	cd b7       	in	r28, 0x3d	; 61
    3fe6:	de b7       	in	r29, 0x3e	; 62
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3fe8:	e0 91 ee 06 	lds	r30, 0x06EE
    3fec:	f0 91 ef 06 	lds	r31, 0x06EF
    3ff0:	80 81       	ld	r24, Z
    3ff2:	88 23       	and	r24, r24
    3ff4:	39 f4       	brne	.+14     	; 0x4004 <prvResetNextTaskUnblockTime+0x24>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    3ff6:	8f ef       	ldi	r24, 0xFF	; 255
    3ff8:	9f ef       	ldi	r25, 0xFF	; 255
    3ffa:	90 93 b4 06 	sts	0x06B4, r25
    3ffe:	80 93 b3 06 	sts	0x06B3, r24
    4002:	0d c0       	rjmp	.+26     	; 0x401e <prvResetNextTaskUnblockTime+0x3e>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    4004:	e0 91 ee 06 	lds	r30, 0x06EE
    4008:	f0 91 ef 06 	lds	r31, 0x06EF
    400c:	05 80       	ldd	r0, Z+5	; 0x05
    400e:	f6 81       	ldd	r31, Z+6	; 0x06
    4010:	e0 2d       	mov	r30, r0
    4012:	80 81       	ld	r24, Z
    4014:	91 81       	ldd	r25, Z+1	; 0x01
    4016:	90 93 b4 06 	sts	0x06B4, r25
    401a:	80 93 b3 06 	sts	0x06B3, r24
    }
}
    401e:	cf 91       	pop	r28
    4020:	df 91       	pop	r29
    4022:	08 95       	ret

00004024 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

    BaseType_t xTaskGetSchedulerState( void )
    {
    4024:	df 93       	push	r29
    4026:	cf 93       	push	r28
    4028:	0f 92       	push	r0
    402a:	cd b7       	in	r28, 0x3d	; 61
    402c:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn;

        if( xSchedulerRunning == pdFALSE )
    402e:	80 91 ad 06 	lds	r24, 0x06AD
    4032:	88 23       	and	r24, r24
    4034:	19 f4       	brne	.+6      	; 0x403c <xTaskGetSchedulerState+0x18>
        {
            xReturn = taskSCHEDULER_NOT_STARTED;
    4036:	81 e0       	ldi	r24, 0x01	; 1
    4038:	89 83       	std	Y+1, r24	; 0x01
    403a:	08 c0       	rjmp	.+16     	; 0x404c <xTaskGetSchedulerState+0x28>
        }
        else
        {
            if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    403c:	80 91 b7 06 	lds	r24, 0x06B7
    4040:	88 23       	and	r24, r24
    4042:	19 f4       	brne	.+6      	; 0x404a <xTaskGetSchedulerState+0x26>
            {
                xReturn = taskSCHEDULER_RUNNING;
    4044:	82 e0       	ldi	r24, 0x02	; 2
    4046:	89 83       	std	Y+1, r24	; 0x01
    4048:	01 c0       	rjmp	.+2      	; 0x404c <xTaskGetSchedulerState+0x28>
            }
            else
            {
                xReturn = taskSCHEDULER_SUSPENDED;
    404a:	19 82       	std	Y+1, r1	; 0x01
            }
        }

        return xReturn;
    404c:	89 81       	ldd	r24, Y+1	; 0x01
    }
    404e:	0f 90       	pop	r0
    4050:	cf 91       	pop	r28
    4052:	df 91       	pop	r29
    4054:	08 95       	ret

00004056 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4056:	df 93       	push	r29
    4058:	cf 93       	push	r28
    405a:	00 d0       	rcall	.+0      	; 0x405c <uxTaskResetEventItemValue+0x6>
    405c:	cd b7       	in	r28, 0x3d	; 61
    405e:	de b7       	in	r29, 0x3e	; 62
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    4060:	e0 91 a6 06 	lds	r30, 0x06A6
    4064:	f0 91 a7 06 	lds	r31, 0x06A7
    4068:	84 85       	ldd	r24, Z+12	; 0x0c
    406a:	95 85       	ldd	r25, Z+13	; 0x0d
    406c:	9a 83       	std	Y+2, r25	; 0x02
    406e:	89 83       	std	Y+1, r24	; 0x01

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4070:	a0 91 a6 06 	lds	r26, 0x06A6
    4074:	b0 91 a7 06 	lds	r27, 0x06A7
    4078:	e0 91 a6 06 	lds	r30, 0x06A6
    407c:	f0 91 a7 06 	lds	r31, 0x06A7
    4080:	86 89       	ldd	r24, Z+22	; 0x16
    4082:	28 2f       	mov	r18, r24
    4084:	30 e0       	ldi	r19, 0x00	; 0
    4086:	84 e0       	ldi	r24, 0x04	; 4
    4088:	90 e0       	ldi	r25, 0x00	; 0
    408a:	82 1b       	sub	r24, r18
    408c:	93 0b       	sbc	r25, r19
    408e:	1d 96       	adiw	r26, 0x0d	; 13
    4090:	9c 93       	st	X, r25
    4092:	8e 93       	st	-X, r24
    4094:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
    4096:	89 81       	ldd	r24, Y+1	; 0x01
    4098:	9a 81       	ldd	r25, Y+2	; 0x02
}
    409a:	0f 90       	pop	r0
    409c:	0f 90       	pop	r0
    409e:	cf 91       	pop	r28
    40a0:	df 91       	pop	r29
    40a2:	08 95       	ret

000040a4 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    40a4:	df 93       	push	r29
    40a6:	cf 93       	push	r28
    40a8:	cd b7       	in	r28, 0x3d	; 61
    40aa:	de b7       	in	r29, 0x3e	; 62
    40ac:	28 97       	sbiw	r28, 0x08	; 8
    40ae:	0f b6       	in	r0, 0x3f	; 63
    40b0:	f8 94       	cli
    40b2:	de bf       	out	0x3e, r29	; 62
    40b4:	0f be       	out	0x3f, r0	; 63
    40b6:	cd bf       	out	0x3d, r28	; 61
    40b8:	8d 83       	std	Y+5, r24	; 0x05
    40ba:	6e 83       	std	Y+6, r22	; 0x06
    40bc:	58 87       	std	Y+8, r21	; 0x08
    40be:	4f 83       	std	Y+7, r20	; 0x07
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    40c0:	0f b6       	in	r0, 0x3f	; 63
    40c2:	f8 94       	cli
    40c4:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    40c6:	20 91 a6 06 	lds	r18, 0x06A6
    40ca:	30 91 a7 06 	lds	r19, 0x06A7
    40ce:	8d 81       	ldd	r24, Y+5	; 0x05
    40d0:	88 2f       	mov	r24, r24
    40d2:	90 e0       	ldi	r25, 0x00	; 0
    40d4:	88 0f       	add	r24, r24
    40d6:	99 1f       	adc	r25, r25
    40d8:	88 0f       	add	r24, r24
    40da:	99 1f       	adc	r25, r25
    40dc:	82 0f       	add	r24, r18
    40de:	93 1f       	adc	r25, r19
    40e0:	fc 01       	movw	r30, r24
    40e2:	b1 96       	adiw	r30, 0x21	; 33
    40e4:	80 81       	ld	r24, Z
    40e6:	91 81       	ldd	r25, Z+1	; 0x01
    40e8:	a2 81       	ldd	r26, Z+2	; 0x02
    40ea:	b3 81       	ldd	r27, Z+3	; 0x03
    40ec:	00 97       	sbiw	r24, 0x00	; 0
    40ee:	a1 05       	cpc	r26, r1
    40f0:	b1 05       	cpc	r27, r1
    40f2:	c1 f4       	brne	.+48     	; 0x4124 <ulTaskGenericNotifyTake+0x80>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    40f4:	20 91 a6 06 	lds	r18, 0x06A6
    40f8:	30 91 a7 06 	lds	r19, 0x06A7
    40fc:	8d 81       	ldd	r24, Y+5	; 0x05
    40fe:	88 2f       	mov	r24, r24
    4100:	90 e0       	ldi	r25, 0x00	; 0
    4102:	82 0f       	add	r24, r18
    4104:	93 1f       	adc	r25, r19
    4106:	fc 01       	movw	r30, r24
    4108:	b5 96       	adiw	r30, 0x25	; 37
    410a:	81 e0       	ldi	r24, 0x01	; 1
    410c:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    410e:	8f 81       	ldd	r24, Y+7	; 0x07
    4110:	98 85       	ldd	r25, Y+8	; 0x08
    4112:	00 97       	sbiw	r24, 0x00	; 0
    4114:	39 f0       	breq	.+14     	; 0x4124 <ulTaskGenericNotifyTake+0x80>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4116:	8f 81       	ldd	r24, Y+7	; 0x07
    4118:	98 85       	ldd	r25, Y+8	; 0x08
    411a:	61 e0       	ldi	r22, 0x01	; 1
    411c:	0e 94 d7 27 	call	0x4fae	; 0x4fae <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    4120:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4124:	0f 90       	pop	r0
    4126:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4128:	0f b6       	in	r0, 0x3f	; 63
    412a:	f8 94       	cli
    412c:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    412e:	20 91 a6 06 	lds	r18, 0x06A6
    4132:	30 91 a7 06 	lds	r19, 0x06A7
    4136:	8d 81       	ldd	r24, Y+5	; 0x05
    4138:	88 2f       	mov	r24, r24
    413a:	90 e0       	ldi	r25, 0x00	; 0
    413c:	88 0f       	add	r24, r24
    413e:	99 1f       	adc	r25, r25
    4140:	88 0f       	add	r24, r24
    4142:	99 1f       	adc	r25, r25
    4144:	82 0f       	add	r24, r18
    4146:	93 1f       	adc	r25, r19
    4148:	fc 01       	movw	r30, r24
    414a:	b1 96       	adiw	r30, 0x21	; 33
    414c:	80 81       	ld	r24, Z
    414e:	91 81       	ldd	r25, Z+1	; 0x01
    4150:	a2 81       	ldd	r26, Z+2	; 0x02
    4152:	b3 81       	ldd	r27, Z+3	; 0x03
    4154:	89 83       	std	Y+1, r24	; 0x01
    4156:	9a 83       	std	Y+2, r25	; 0x02
    4158:	ab 83       	std	Y+3, r26	; 0x03
    415a:	bc 83       	std	Y+4, r27	; 0x04

            if( ulReturn != 0UL )
    415c:	89 81       	ldd	r24, Y+1	; 0x01
    415e:	9a 81       	ldd	r25, Y+2	; 0x02
    4160:	ab 81       	ldd	r26, Y+3	; 0x03
    4162:	bc 81       	ldd	r27, Y+4	; 0x04
    4164:	00 97       	sbiw	r24, 0x00	; 0
    4166:	a1 05       	cpc	r26, r1
    4168:	b1 05       	cpc	r27, r1
    416a:	a9 f1       	breq	.+106    	; 0x41d6 <ulTaskGenericNotifyTake+0x132>
            {
                if( xClearCountOnExit != pdFALSE )
    416c:	8e 81       	ldd	r24, Y+6	; 0x06
    416e:	88 23       	and	r24, r24
    4170:	a1 f0       	breq	.+40     	; 0x419a <ulTaskGenericNotifyTake+0xf6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    4172:	20 91 a6 06 	lds	r18, 0x06A6
    4176:	30 91 a7 06 	lds	r19, 0x06A7
    417a:	8d 81       	ldd	r24, Y+5	; 0x05
    417c:	88 2f       	mov	r24, r24
    417e:	90 e0       	ldi	r25, 0x00	; 0
    4180:	88 0f       	add	r24, r24
    4182:	99 1f       	adc	r25, r25
    4184:	88 0f       	add	r24, r24
    4186:	99 1f       	adc	r25, r25
    4188:	82 0f       	add	r24, r18
    418a:	93 1f       	adc	r25, r19
    418c:	fc 01       	movw	r30, r24
    418e:	b1 96       	adiw	r30, 0x21	; 33
    4190:	10 82       	st	Z, r1
    4192:	11 82       	std	Z+1, r1	; 0x01
    4194:	12 82       	std	Z+2, r1	; 0x02
    4196:	13 82       	std	Z+3, r1	; 0x03
    4198:	1e c0       	rjmp	.+60     	; 0x41d6 <ulTaskGenericNotifyTake+0x132>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    419a:	e0 91 a6 06 	lds	r30, 0x06A6
    419e:	f0 91 a7 06 	lds	r31, 0x06A7
    41a2:	8d 81       	ldd	r24, Y+5	; 0x05
    41a4:	68 2f       	mov	r22, r24
    41a6:	70 e0       	ldi	r23, 0x00	; 0
    41a8:	89 81       	ldd	r24, Y+1	; 0x01
    41aa:	9a 81       	ldd	r25, Y+2	; 0x02
    41ac:	ab 81       	ldd	r26, Y+3	; 0x03
    41ae:	bc 81       	ldd	r27, Y+4	; 0x04
    41b0:	9c 01       	movw	r18, r24
    41b2:	ad 01       	movw	r20, r26
    41b4:	21 50       	subi	r18, 0x01	; 1
    41b6:	30 40       	sbci	r19, 0x00	; 0
    41b8:	40 40       	sbci	r20, 0x00	; 0
    41ba:	50 40       	sbci	r21, 0x00	; 0
    41bc:	cb 01       	movw	r24, r22
    41be:	88 0f       	add	r24, r24
    41c0:	99 1f       	adc	r25, r25
    41c2:	88 0f       	add	r24, r24
    41c4:	99 1f       	adc	r25, r25
    41c6:	8e 0f       	add	r24, r30
    41c8:	9f 1f       	adc	r25, r31
    41ca:	fc 01       	movw	r30, r24
    41cc:	b1 96       	adiw	r30, 0x21	; 33
    41ce:	20 83       	st	Z, r18
    41d0:	31 83       	std	Z+1, r19	; 0x01
    41d2:	42 83       	std	Z+2, r20	; 0x02
    41d4:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    41d6:	20 91 a6 06 	lds	r18, 0x06A6
    41da:	30 91 a7 06 	lds	r19, 0x06A7
    41de:	8d 81       	ldd	r24, Y+5	; 0x05
    41e0:	88 2f       	mov	r24, r24
    41e2:	90 e0       	ldi	r25, 0x00	; 0
    41e4:	82 0f       	add	r24, r18
    41e6:	93 1f       	adc	r25, r19
    41e8:	fc 01       	movw	r30, r24
    41ea:	b5 96       	adiw	r30, 0x25	; 37
    41ec:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    41ee:	0f 90       	pop	r0
    41f0:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    41f2:	89 81       	ldd	r24, Y+1	; 0x01
    41f4:	9a 81       	ldd	r25, Y+2	; 0x02
    41f6:	ab 81       	ldd	r26, Y+3	; 0x03
    41f8:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    41fa:	bc 01       	movw	r22, r24
    41fc:	cd 01       	movw	r24, r26
    41fe:	28 96       	adiw	r28, 0x08	; 8
    4200:	0f b6       	in	r0, 0x3f	; 63
    4202:	f8 94       	cli
    4204:	de bf       	out	0x3e, r29	; 62
    4206:	0f be       	out	0x3f, r0	; 63
    4208:	cd bf       	out	0x3d, r28	; 61
    420a:	cf 91       	pop	r28
    420c:	df 91       	pop	r29
    420e:	08 95       	ret

00004210 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    4210:	cf 92       	push	r12
    4212:	df 92       	push	r13
    4214:	ef 92       	push	r14
    4216:	ff 92       	push	r15
    4218:	0f 93       	push	r16
    421a:	1f 93       	push	r17
    421c:	df 93       	push	r29
    421e:	cf 93       	push	r28
    4220:	cd b7       	in	r28, 0x3d	; 61
    4222:	de b7       	in	r29, 0x3e	; 62
    4224:	2e 97       	sbiw	r28, 0x0e	; 14
    4226:	0f b6       	in	r0, 0x3f	; 63
    4228:	f8 94       	cli
    422a:	de bf       	out	0x3e, r29	; 62
    422c:	0f be       	out	0x3f, r0	; 63
    422e:	cd bf       	out	0x3d, r28	; 61
    4230:	8a 83       	std	Y+2, r24	; 0x02
    4232:	4b 83       	std	Y+3, r20	; 0x03
    4234:	5c 83       	std	Y+4, r21	; 0x04
    4236:	6d 83       	std	Y+5, r22	; 0x05
    4238:	7e 83       	std	Y+6, r23	; 0x06
    423a:	0f 83       	std	Y+7, r16	; 0x07
    423c:	18 87       	std	Y+8, r17	; 0x08
    423e:	29 87       	std	Y+9, r18	; 0x09
    4240:	3a 87       	std	Y+10, r19	; 0x0a
    4242:	fc 86       	std	Y+12, r15	; 0x0c
    4244:	eb 86       	std	Y+11, r14	; 0x0b
    4246:	de 86       	std	Y+14, r13	; 0x0e
    4248:	cd 86       	std	Y+13, r12	; 0x0d
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    424a:	0f b6       	in	r0, 0x3f	; 63
    424c:	f8 94       	cli
    424e:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    4250:	20 91 a6 06 	lds	r18, 0x06A6
    4254:	30 91 a7 06 	lds	r19, 0x06A7
    4258:	8a 81       	ldd	r24, Y+2	; 0x02
    425a:	88 2f       	mov	r24, r24
    425c:	90 e0       	ldi	r25, 0x00	; 0
    425e:	82 0f       	add	r24, r18
    4260:	93 1f       	adc	r25, r19
    4262:	fc 01       	movw	r30, r24
    4264:	b5 96       	adiw	r30, 0x25	; 37
    4266:	80 81       	ld	r24, Z
    4268:	82 30       	cpi	r24, 0x02	; 2
    426a:	09 f4       	brne	.+2      	; 0x426e <xTaskGenericNotifyWait+0x5e>
    426c:	47 c0       	rjmp	.+142    	; 0x42fc <xTaskGenericNotifyWait+0xec>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    426e:	60 91 a6 06 	lds	r22, 0x06A6
    4272:	70 91 a7 06 	lds	r23, 0x06A7
    4276:	8a 81       	ldd	r24, Y+2	; 0x02
    4278:	08 2f       	mov	r16, r24
    427a:	10 e0       	ldi	r17, 0x00	; 0
    427c:	8a 81       	ldd	r24, Y+2	; 0x02
    427e:	88 2f       	mov	r24, r24
    4280:	90 e0       	ldi	r25, 0x00	; 0
    4282:	88 0f       	add	r24, r24
    4284:	99 1f       	adc	r25, r25
    4286:	88 0f       	add	r24, r24
    4288:	99 1f       	adc	r25, r25
    428a:	86 0f       	add	r24, r22
    428c:	97 1f       	adc	r25, r23
    428e:	fc 01       	movw	r30, r24
    4290:	b1 96       	adiw	r30, 0x21	; 33
    4292:	20 81       	ld	r18, Z
    4294:	31 81       	ldd	r19, Z+1	; 0x01
    4296:	42 81       	ldd	r20, Z+2	; 0x02
    4298:	53 81       	ldd	r21, Z+3	; 0x03
    429a:	8b 81       	ldd	r24, Y+3	; 0x03
    429c:	9c 81       	ldd	r25, Y+4	; 0x04
    429e:	ad 81       	ldd	r26, Y+5	; 0x05
    42a0:	be 81       	ldd	r27, Y+6	; 0x06
    42a2:	80 95       	com	r24
    42a4:	90 95       	com	r25
    42a6:	a0 95       	com	r26
    42a8:	b0 95       	com	r27
    42aa:	28 23       	and	r18, r24
    42ac:	39 23       	and	r19, r25
    42ae:	4a 23       	and	r20, r26
    42b0:	5b 23       	and	r21, r27
    42b2:	c8 01       	movw	r24, r16
    42b4:	88 0f       	add	r24, r24
    42b6:	99 1f       	adc	r25, r25
    42b8:	88 0f       	add	r24, r24
    42ba:	99 1f       	adc	r25, r25
    42bc:	86 0f       	add	r24, r22
    42be:	97 1f       	adc	r25, r23
    42c0:	fc 01       	movw	r30, r24
    42c2:	b1 96       	adiw	r30, 0x21	; 33
    42c4:	20 83       	st	Z, r18
    42c6:	31 83       	std	Z+1, r19	; 0x01
    42c8:	42 83       	std	Z+2, r20	; 0x02
    42ca:	53 83       	std	Z+3, r21	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    42cc:	20 91 a6 06 	lds	r18, 0x06A6
    42d0:	30 91 a7 06 	lds	r19, 0x06A7
    42d4:	8a 81       	ldd	r24, Y+2	; 0x02
    42d6:	88 2f       	mov	r24, r24
    42d8:	90 e0       	ldi	r25, 0x00	; 0
    42da:	82 0f       	add	r24, r18
    42dc:	93 1f       	adc	r25, r19
    42de:	fc 01       	movw	r30, r24
    42e0:	b5 96       	adiw	r30, 0x25	; 37
    42e2:	81 e0       	ldi	r24, 0x01	; 1
    42e4:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    42e6:	8d 85       	ldd	r24, Y+13	; 0x0d
    42e8:	9e 85       	ldd	r25, Y+14	; 0x0e
    42ea:	00 97       	sbiw	r24, 0x00	; 0
    42ec:	39 f0       	breq	.+14     	; 0x42fc <xTaskGenericNotifyWait+0xec>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    42ee:	8d 85       	ldd	r24, Y+13	; 0x0d
    42f0:	9e 85       	ldd	r25, Y+14	; 0x0e
    42f2:	61 e0       	ldi	r22, 0x01	; 1
    42f4:	0e 94 d7 27 	call	0x4fae	; 0x4fae <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    42f8:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    42fc:	0f 90       	pop	r0
    42fe:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4300:	0f b6       	in	r0, 0x3f	; 63
    4302:	f8 94       	cli
    4304:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    4306:	8b 85       	ldd	r24, Y+11	; 0x0b
    4308:	9c 85       	ldd	r25, Y+12	; 0x0c
    430a:	00 97       	sbiw	r24, 0x00	; 0
    430c:	c9 f0       	breq	.+50     	; 0x4340 <xTaskGenericNotifyWait+0x130>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    430e:	20 91 a6 06 	lds	r18, 0x06A6
    4312:	30 91 a7 06 	lds	r19, 0x06A7
    4316:	8a 81       	ldd	r24, Y+2	; 0x02
    4318:	88 2f       	mov	r24, r24
    431a:	90 e0       	ldi	r25, 0x00	; 0
    431c:	88 0f       	add	r24, r24
    431e:	99 1f       	adc	r25, r25
    4320:	88 0f       	add	r24, r24
    4322:	99 1f       	adc	r25, r25
    4324:	82 0f       	add	r24, r18
    4326:	93 1f       	adc	r25, r19
    4328:	fc 01       	movw	r30, r24
    432a:	b1 96       	adiw	r30, 0x21	; 33
    432c:	80 81       	ld	r24, Z
    432e:	91 81       	ldd	r25, Z+1	; 0x01
    4330:	a2 81       	ldd	r26, Z+2	; 0x02
    4332:	b3 81       	ldd	r27, Z+3	; 0x03
    4334:	eb 85       	ldd	r30, Y+11	; 0x0b
    4336:	fc 85       	ldd	r31, Y+12	; 0x0c
    4338:	80 83       	st	Z, r24
    433a:	91 83       	std	Z+1, r25	; 0x01
    433c:	a2 83       	std	Z+2, r26	; 0x02
    433e:	b3 83       	std	Z+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    4340:	20 91 a6 06 	lds	r18, 0x06A6
    4344:	30 91 a7 06 	lds	r19, 0x06A7
    4348:	8a 81       	ldd	r24, Y+2	; 0x02
    434a:	88 2f       	mov	r24, r24
    434c:	90 e0       	ldi	r25, 0x00	; 0
    434e:	82 0f       	add	r24, r18
    4350:	93 1f       	adc	r25, r19
    4352:	fc 01       	movw	r30, r24
    4354:	b5 96       	adiw	r30, 0x25	; 37
    4356:	80 81       	ld	r24, Z
    4358:	82 30       	cpi	r24, 0x02	; 2
    435a:	11 f0       	breq	.+4      	; 0x4360 <xTaskGenericNotifyWait+0x150>
            {
                /* A notification was not received. */
                xReturn = pdFALSE;
    435c:	19 82       	std	Y+1, r1	; 0x01
    435e:	31 c0       	rjmp	.+98     	; 0x43c2 <xTaskGenericNotifyWait+0x1b2>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    4360:	60 91 a6 06 	lds	r22, 0x06A6
    4364:	70 91 a7 06 	lds	r23, 0x06A7
    4368:	8a 81       	ldd	r24, Y+2	; 0x02
    436a:	08 2f       	mov	r16, r24
    436c:	10 e0       	ldi	r17, 0x00	; 0
    436e:	8a 81       	ldd	r24, Y+2	; 0x02
    4370:	88 2f       	mov	r24, r24
    4372:	90 e0       	ldi	r25, 0x00	; 0
    4374:	88 0f       	add	r24, r24
    4376:	99 1f       	adc	r25, r25
    4378:	88 0f       	add	r24, r24
    437a:	99 1f       	adc	r25, r25
    437c:	86 0f       	add	r24, r22
    437e:	97 1f       	adc	r25, r23
    4380:	fc 01       	movw	r30, r24
    4382:	b1 96       	adiw	r30, 0x21	; 33
    4384:	20 81       	ld	r18, Z
    4386:	31 81       	ldd	r19, Z+1	; 0x01
    4388:	42 81       	ldd	r20, Z+2	; 0x02
    438a:	53 81       	ldd	r21, Z+3	; 0x03
    438c:	8f 81       	ldd	r24, Y+7	; 0x07
    438e:	98 85       	ldd	r25, Y+8	; 0x08
    4390:	a9 85       	ldd	r26, Y+9	; 0x09
    4392:	ba 85       	ldd	r27, Y+10	; 0x0a
    4394:	80 95       	com	r24
    4396:	90 95       	com	r25
    4398:	a0 95       	com	r26
    439a:	b0 95       	com	r27
    439c:	28 23       	and	r18, r24
    439e:	39 23       	and	r19, r25
    43a0:	4a 23       	and	r20, r26
    43a2:	5b 23       	and	r21, r27
    43a4:	c8 01       	movw	r24, r16
    43a6:	88 0f       	add	r24, r24
    43a8:	99 1f       	adc	r25, r25
    43aa:	88 0f       	add	r24, r24
    43ac:	99 1f       	adc	r25, r25
    43ae:	86 0f       	add	r24, r22
    43b0:	97 1f       	adc	r25, r23
    43b2:	fc 01       	movw	r30, r24
    43b4:	b1 96       	adiw	r30, 0x21	; 33
    43b6:	20 83       	st	Z, r18
    43b8:	31 83       	std	Z+1, r19	; 0x01
    43ba:	42 83       	std	Z+2, r20	; 0x02
    43bc:	53 83       	std	Z+3, r21	; 0x03
                xReturn = pdTRUE;
    43be:	81 e0       	ldi	r24, 0x01	; 1
    43c0:	89 83       	std	Y+1, r24	; 0x01
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    43c2:	20 91 a6 06 	lds	r18, 0x06A6
    43c6:	30 91 a7 06 	lds	r19, 0x06A7
    43ca:	8a 81       	ldd	r24, Y+2	; 0x02
    43cc:	88 2f       	mov	r24, r24
    43ce:	90 e0       	ldi	r25, 0x00	; 0
    43d0:	82 0f       	add	r24, r18
    43d2:	93 1f       	adc	r25, r19
    43d4:	fc 01       	movw	r30, r24
    43d6:	b5 96       	adiw	r30, 0x25	; 37
    43d8:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    43da:	0f 90       	pop	r0
    43dc:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    43de:	89 81       	ldd	r24, Y+1	; 0x01
    }
    43e0:	2e 96       	adiw	r28, 0x0e	; 14
    43e2:	0f b6       	in	r0, 0x3f	; 63
    43e4:	f8 94       	cli
    43e6:	de bf       	out	0x3e, r29	; 62
    43e8:	0f be       	out	0x3f, r0	; 63
    43ea:	cd bf       	out	0x3d, r28	; 61
    43ec:	cf 91       	pop	r28
    43ee:	df 91       	pop	r29
    43f0:	1f 91       	pop	r17
    43f2:	0f 91       	pop	r16
    43f4:	ff 90       	pop	r15
    43f6:	ef 90       	pop	r14
    43f8:	df 90       	pop	r13
    43fa:	cf 90       	pop	r12
    43fc:	08 95       	ret

000043fe <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    43fe:	ef 92       	push	r14
    4400:	ff 92       	push	r15
    4402:	0f 93       	push	r16
    4404:	1f 93       	push	r17
    4406:	df 93       	push	r29
    4408:	cf 93       	push	r28
    440a:	cd b7       	in	r28, 0x3d	; 61
    440c:	de b7       	in	r29, 0x3e	; 62
    440e:	64 97       	sbiw	r28, 0x14	; 20
    4410:	0f b6       	in	r0, 0x3f	; 63
    4412:	f8 94       	cli
    4414:	de bf       	out	0x3e, r29	; 62
    4416:	0f be       	out	0x3f, r0	; 63
    4418:	cd bf       	out	0x3d, r28	; 61
    441a:	9a 87       	std	Y+10, r25	; 0x0a
    441c:	89 87       	std	Y+9, r24	; 0x09
    441e:	6b 87       	std	Y+11, r22	; 0x0b
    4420:	2c 87       	std	Y+12, r18	; 0x0c
    4422:	3d 87       	std	Y+13, r19	; 0x0d
    4424:	4e 87       	std	Y+14, r20	; 0x0e
    4426:	5f 87       	std	Y+15, r21	; 0x0f
    4428:	08 8b       	std	Y+16, r16	; 0x10
    442a:	fa 8a       	std	Y+18, r15	; 0x12
    442c:	e9 8a       	std	Y+17, r14	; 0x11
        TCB_t * pxTCB;
        BaseType_t xReturn = pdPASS;
    442e:	81 e0       	ldi	r24, 0x01	; 1
    4430:	8e 83       	std	Y+6, r24	; 0x06
        uint8_t ucOriginalNotifyState;

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;
    4432:	89 85       	ldd	r24, Y+9	; 0x09
    4434:	9a 85       	ldd	r25, Y+10	; 0x0a
    4436:	98 87       	std	Y+8, r25	; 0x08
    4438:	8f 83       	std	Y+7, r24	; 0x07

        taskENTER_CRITICAL();
    443a:	0f b6       	in	r0, 0x3f	; 63
    443c:	f8 94       	cli
    443e:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    4440:	89 89       	ldd	r24, Y+17	; 0x11
    4442:	9a 89       	ldd	r25, Y+18	; 0x12
    4444:	00 97       	sbiw	r24, 0x00	; 0
    4446:	b9 f0       	breq	.+46     	; 0x4476 <xTaskGenericNotify+0x78>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    4448:	8b 85       	ldd	r24, Y+11	; 0x0b
    444a:	88 2f       	mov	r24, r24
    444c:	90 e0       	ldi	r25, 0x00	; 0
    444e:	2f 81       	ldd	r18, Y+7	; 0x07
    4450:	38 85       	ldd	r19, Y+8	; 0x08
    4452:	88 0f       	add	r24, r24
    4454:	99 1f       	adc	r25, r25
    4456:	88 0f       	add	r24, r24
    4458:	99 1f       	adc	r25, r25
    445a:	82 0f       	add	r24, r18
    445c:	93 1f       	adc	r25, r19
    445e:	fc 01       	movw	r30, r24
    4460:	b1 96       	adiw	r30, 0x21	; 33
    4462:	80 81       	ld	r24, Z
    4464:	91 81       	ldd	r25, Z+1	; 0x01
    4466:	a2 81       	ldd	r26, Z+2	; 0x02
    4468:	b3 81       	ldd	r27, Z+3	; 0x03
    446a:	e9 89       	ldd	r30, Y+17	; 0x11
    446c:	fa 89       	ldd	r31, Y+18	; 0x12
    446e:	80 83       	st	Z, r24
    4470:	91 83       	std	Z+1, r25	; 0x01
    4472:	a2 83       	std	Z+2, r26	; 0x02
    4474:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4476:	8b 85       	ldd	r24, Y+11	; 0x0b
    4478:	28 2f       	mov	r18, r24
    447a:	30 e0       	ldi	r19, 0x00	; 0
    447c:	8f 81       	ldd	r24, Y+7	; 0x07
    447e:	98 85       	ldd	r25, Y+8	; 0x08
    4480:	82 0f       	add	r24, r18
    4482:	93 1f       	adc	r25, r19
    4484:	fc 01       	movw	r30, r24
    4486:	b5 96       	adiw	r30, 0x25	; 37
    4488:	80 81       	ld	r24, Z
    448a:	8d 83       	std	Y+5, r24	; 0x05

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    448c:	8b 85       	ldd	r24, Y+11	; 0x0b
    448e:	28 2f       	mov	r18, r24
    4490:	30 e0       	ldi	r19, 0x00	; 0
    4492:	8f 81       	ldd	r24, Y+7	; 0x07
    4494:	98 85       	ldd	r25, Y+8	; 0x08
    4496:	82 0f       	add	r24, r18
    4498:	93 1f       	adc	r25, r19
    449a:	fc 01       	movw	r30, r24
    449c:	b5 96       	adiw	r30, 0x25	; 37
    449e:	82 e0       	ldi	r24, 0x02	; 2
    44a0:	80 83       	st	Z, r24

            switch( eAction )
    44a2:	88 89       	ldd	r24, Y+16	; 0x10
    44a4:	28 2f       	mov	r18, r24
    44a6:	30 e0       	ldi	r19, 0x00	; 0
    44a8:	3c 8b       	std	Y+20, r19	; 0x14
    44aa:	2b 8b       	std	Y+19, r18	; 0x13
    44ac:	8b 89       	ldd	r24, Y+19	; 0x13
    44ae:	9c 89       	ldd	r25, Y+20	; 0x14
    44b0:	82 30       	cpi	r24, 0x02	; 2
    44b2:	91 05       	cpc	r25, r1
    44b4:	09 f4       	brne	.+2      	; 0x44b8 <xTaskGenericNotify+0xba>
    44b6:	46 c0       	rjmp	.+140    	; 0x4544 <xTaskGenericNotify+0x146>
    44b8:	2b 89       	ldd	r18, Y+19	; 0x13
    44ba:	3c 89       	ldd	r19, Y+20	; 0x14
    44bc:	23 30       	cpi	r18, 0x03	; 3
    44be:	31 05       	cpc	r19, r1
    44c0:	34 f4       	brge	.+12     	; 0x44ce <xTaskGenericNotify+0xd0>
    44c2:	8b 89       	ldd	r24, Y+19	; 0x13
    44c4:	9c 89       	ldd	r25, Y+20	; 0x14
    44c6:	81 30       	cpi	r24, 0x01	; 1
    44c8:	91 05       	cpc	r25, r1
    44ca:	71 f0       	breq	.+28     	; 0x44e8 <xTaskGenericNotify+0xea>
    44cc:	93 c0       	rjmp	.+294    	; 0x45f4 <xTaskGenericNotify+0x1f6>
    44ce:	2b 89       	ldd	r18, Y+19	; 0x13
    44d0:	3c 89       	ldd	r19, Y+20	; 0x14
    44d2:	23 30       	cpi	r18, 0x03	; 3
    44d4:	31 05       	cpc	r19, r1
    44d6:	09 f4       	brne	.+2      	; 0x44da <xTaskGenericNotify+0xdc>
    44d8:	5d c0       	rjmp	.+186    	; 0x4594 <xTaskGenericNotify+0x196>
    44da:	8b 89       	ldd	r24, Y+19	; 0x13
    44dc:	9c 89       	ldd	r25, Y+20	; 0x14
    44de:	84 30       	cpi	r24, 0x04	; 4
    44e0:	91 05       	cpc	r25, r1
    44e2:	09 f4       	brne	.+2      	; 0x44e6 <xTaskGenericNotify+0xe8>
    44e4:	6d c0       	rjmp	.+218    	; 0x45c0 <xTaskGenericNotify+0x1c2>
    44e6:	86 c0       	rjmp	.+268    	; 0x45f4 <xTaskGenericNotify+0x1f6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    44e8:	8b 85       	ldd	r24, Y+11	; 0x0b
    44ea:	08 2f       	mov	r16, r24
    44ec:	10 e0       	ldi	r17, 0x00	; 0
    44ee:	8b 85       	ldd	r24, Y+11	; 0x0b
    44f0:	88 2f       	mov	r24, r24
    44f2:	90 e0       	ldi	r25, 0x00	; 0
    44f4:	2f 81       	ldd	r18, Y+7	; 0x07
    44f6:	38 85       	ldd	r19, Y+8	; 0x08
    44f8:	88 0f       	add	r24, r24
    44fa:	99 1f       	adc	r25, r25
    44fc:	88 0f       	add	r24, r24
    44fe:	99 1f       	adc	r25, r25
    4500:	82 0f       	add	r24, r18
    4502:	93 1f       	adc	r25, r19
    4504:	fc 01       	movw	r30, r24
    4506:	b1 96       	adiw	r30, 0x21	; 33
    4508:	20 81       	ld	r18, Z
    450a:	31 81       	ldd	r19, Z+1	; 0x01
    450c:	42 81       	ldd	r20, Z+2	; 0x02
    450e:	53 81       	ldd	r21, Z+3	; 0x03
    4510:	8c 85       	ldd	r24, Y+12	; 0x0c
    4512:	9d 85       	ldd	r25, Y+13	; 0x0d
    4514:	ae 85       	ldd	r26, Y+14	; 0x0e
    4516:	bf 85       	ldd	r27, Y+15	; 0x0f
    4518:	ba 01       	movw	r22, r20
    451a:	a9 01       	movw	r20, r18
    451c:	48 2b       	or	r20, r24
    451e:	59 2b       	or	r21, r25
    4520:	6a 2b       	or	r22, r26
    4522:	7b 2b       	or	r23, r27
    4524:	2f 81       	ldd	r18, Y+7	; 0x07
    4526:	38 85       	ldd	r19, Y+8	; 0x08
    4528:	c8 01       	movw	r24, r16
    452a:	88 0f       	add	r24, r24
    452c:	99 1f       	adc	r25, r25
    452e:	88 0f       	add	r24, r24
    4530:	99 1f       	adc	r25, r25
    4532:	82 0f       	add	r24, r18
    4534:	93 1f       	adc	r25, r19
    4536:	fc 01       	movw	r30, r24
    4538:	b1 96       	adiw	r30, 0x21	; 33
    453a:	40 83       	st	Z, r20
    453c:	51 83       	std	Z+1, r21	; 0x01
    453e:	62 83       	std	Z+2, r22	; 0x02
    4540:	73 83       	std	Z+3, r23	; 0x03
    4542:	58 c0       	rjmp	.+176    	; 0x45f4 <xTaskGenericNotify+0x1f6>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    4544:	8b 85       	ldd	r24, Y+11	; 0x0b
    4546:	08 2f       	mov	r16, r24
    4548:	10 e0       	ldi	r17, 0x00	; 0
    454a:	2f 81       	ldd	r18, Y+7	; 0x07
    454c:	38 85       	ldd	r19, Y+8	; 0x08
    454e:	c8 01       	movw	r24, r16
    4550:	88 0f       	add	r24, r24
    4552:	99 1f       	adc	r25, r25
    4554:	88 0f       	add	r24, r24
    4556:	99 1f       	adc	r25, r25
    4558:	82 0f       	add	r24, r18
    455a:	93 1f       	adc	r25, r19
    455c:	fc 01       	movw	r30, r24
    455e:	b1 96       	adiw	r30, 0x21	; 33
    4560:	80 81       	ld	r24, Z
    4562:	91 81       	ldd	r25, Z+1	; 0x01
    4564:	a2 81       	ldd	r26, Z+2	; 0x02
    4566:	b3 81       	ldd	r27, Z+3	; 0x03
    4568:	ac 01       	movw	r20, r24
    456a:	bd 01       	movw	r22, r26
    456c:	4f 5f       	subi	r20, 0xFF	; 255
    456e:	5f 4f       	sbci	r21, 0xFF	; 255
    4570:	6f 4f       	sbci	r22, 0xFF	; 255
    4572:	7f 4f       	sbci	r23, 0xFF	; 255
    4574:	2f 81       	ldd	r18, Y+7	; 0x07
    4576:	38 85       	ldd	r19, Y+8	; 0x08
    4578:	c8 01       	movw	r24, r16
    457a:	88 0f       	add	r24, r24
    457c:	99 1f       	adc	r25, r25
    457e:	88 0f       	add	r24, r24
    4580:	99 1f       	adc	r25, r25
    4582:	82 0f       	add	r24, r18
    4584:	93 1f       	adc	r25, r19
    4586:	fc 01       	movw	r30, r24
    4588:	b1 96       	adiw	r30, 0x21	; 33
    458a:	40 83       	st	Z, r20
    458c:	51 83       	std	Z+1, r21	; 0x01
    458e:	62 83       	std	Z+2, r22	; 0x02
    4590:	73 83       	std	Z+3, r23	; 0x03
    4592:	30 c0       	rjmp	.+96     	; 0x45f4 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4594:	8b 85       	ldd	r24, Y+11	; 0x0b
    4596:	88 2f       	mov	r24, r24
    4598:	90 e0       	ldi	r25, 0x00	; 0
    459a:	2f 81       	ldd	r18, Y+7	; 0x07
    459c:	38 85       	ldd	r19, Y+8	; 0x08
    459e:	88 0f       	add	r24, r24
    45a0:	99 1f       	adc	r25, r25
    45a2:	88 0f       	add	r24, r24
    45a4:	99 1f       	adc	r25, r25
    45a6:	82 0f       	add	r24, r18
    45a8:	93 1f       	adc	r25, r19
    45aa:	fc 01       	movw	r30, r24
    45ac:	b1 96       	adiw	r30, 0x21	; 33
    45ae:	8c 85       	ldd	r24, Y+12	; 0x0c
    45b0:	9d 85       	ldd	r25, Y+13	; 0x0d
    45b2:	ae 85       	ldd	r26, Y+14	; 0x0e
    45b4:	bf 85       	ldd	r27, Y+15	; 0x0f
    45b6:	80 83       	st	Z, r24
    45b8:	91 83       	std	Z+1, r25	; 0x01
    45ba:	a2 83       	std	Z+2, r26	; 0x02
    45bc:	b3 83       	std	Z+3, r27	; 0x03
    45be:	1a c0       	rjmp	.+52     	; 0x45f4 <xTaskGenericNotify+0x1f6>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    45c0:	8d 81       	ldd	r24, Y+5	; 0x05
    45c2:	82 30       	cpi	r24, 0x02	; 2
    45c4:	b1 f0       	breq	.+44     	; 0x45f2 <xTaskGenericNotify+0x1f4>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    45c6:	8b 85       	ldd	r24, Y+11	; 0x0b
    45c8:	88 2f       	mov	r24, r24
    45ca:	90 e0       	ldi	r25, 0x00	; 0
    45cc:	2f 81       	ldd	r18, Y+7	; 0x07
    45ce:	38 85       	ldd	r19, Y+8	; 0x08
    45d0:	88 0f       	add	r24, r24
    45d2:	99 1f       	adc	r25, r25
    45d4:	88 0f       	add	r24, r24
    45d6:	99 1f       	adc	r25, r25
    45d8:	82 0f       	add	r24, r18
    45da:	93 1f       	adc	r25, r19
    45dc:	fc 01       	movw	r30, r24
    45de:	b1 96       	adiw	r30, 0x21	; 33
    45e0:	8c 85       	ldd	r24, Y+12	; 0x0c
    45e2:	9d 85       	ldd	r25, Y+13	; 0x0d
    45e4:	ae 85       	ldd	r26, Y+14	; 0x0e
    45e6:	bf 85       	ldd	r27, Y+15	; 0x0f
    45e8:	80 83       	st	Z, r24
    45ea:	91 83       	std	Z+1, r25	; 0x01
    45ec:	a2 83       	std	Z+2, r26	; 0x02
    45ee:	b3 83       	std	Z+3, r27	; 0x03
    45f0:	01 c0       	rjmp	.+2      	; 0x45f4 <xTaskGenericNotify+0x1f6>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    45f2:	1e 82       	std	Y+6, r1	; 0x06

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    45f4:	8d 81       	ldd	r24, Y+5	; 0x05
    45f6:	81 30       	cpi	r24, 0x01	; 1
    45f8:	09 f0       	breq	.+2      	; 0x45fc <xTaskGenericNotify+0x1fe>
    45fa:	af c0       	rjmp	.+350    	; 0x475a <xTaskGenericNotify+0x35c>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    45fc:	ef 81       	ldd	r30, Y+7	; 0x07
    45fe:	f8 85       	ldd	r31, Y+8	; 0x08
    4600:	82 85       	ldd	r24, Z+10	; 0x0a
    4602:	93 85       	ldd	r25, Z+11	; 0x0b
    4604:	9c 83       	std	Y+4, r25	; 0x04
    4606:	8b 83       	std	Y+3, r24	; 0x03
    4608:	ef 81       	ldd	r30, Y+7	; 0x07
    460a:	f8 85       	ldd	r31, Y+8	; 0x08
    460c:	a4 81       	ldd	r26, Z+4	; 0x04
    460e:	b5 81       	ldd	r27, Z+5	; 0x05
    4610:	ef 81       	ldd	r30, Y+7	; 0x07
    4612:	f8 85       	ldd	r31, Y+8	; 0x08
    4614:	86 81       	ldd	r24, Z+6	; 0x06
    4616:	97 81       	ldd	r25, Z+7	; 0x07
    4618:	15 96       	adiw	r26, 0x05	; 5
    461a:	9c 93       	st	X, r25
    461c:	8e 93       	st	-X, r24
    461e:	14 97       	sbiw	r26, 0x04	; 4
    4620:	ef 81       	ldd	r30, Y+7	; 0x07
    4622:	f8 85       	ldd	r31, Y+8	; 0x08
    4624:	a6 81       	ldd	r26, Z+6	; 0x06
    4626:	b7 81       	ldd	r27, Z+7	; 0x07
    4628:	ef 81       	ldd	r30, Y+7	; 0x07
    462a:	f8 85       	ldd	r31, Y+8	; 0x08
    462c:	84 81       	ldd	r24, Z+4	; 0x04
    462e:	95 81       	ldd	r25, Z+5	; 0x05
    4630:	13 96       	adiw	r26, 0x03	; 3
    4632:	9c 93       	st	X, r25
    4634:	8e 93       	st	-X, r24
    4636:	12 97       	sbiw	r26, 0x02	; 2
    4638:	eb 81       	ldd	r30, Y+3	; 0x03
    463a:	fc 81       	ldd	r31, Y+4	; 0x04
    463c:	21 81       	ldd	r18, Z+1	; 0x01
    463e:	32 81       	ldd	r19, Z+2	; 0x02
    4640:	8f 81       	ldd	r24, Y+7	; 0x07
    4642:	98 85       	ldd	r25, Y+8	; 0x08
    4644:	02 96       	adiw	r24, 0x02	; 2
    4646:	28 17       	cp	r18, r24
    4648:	39 07       	cpc	r19, r25
    464a:	41 f4       	brne	.+16     	; 0x465c <xTaskGenericNotify+0x25e>
    464c:	ef 81       	ldd	r30, Y+7	; 0x07
    464e:	f8 85       	ldd	r31, Y+8	; 0x08
    4650:	86 81       	ldd	r24, Z+6	; 0x06
    4652:	97 81       	ldd	r25, Z+7	; 0x07
    4654:	eb 81       	ldd	r30, Y+3	; 0x03
    4656:	fc 81       	ldd	r31, Y+4	; 0x04
    4658:	92 83       	std	Z+2, r25	; 0x02
    465a:	81 83       	std	Z+1, r24	; 0x01
    465c:	ef 81       	ldd	r30, Y+7	; 0x07
    465e:	f8 85       	ldd	r31, Y+8	; 0x08
    4660:	13 86       	std	Z+11, r1	; 0x0b
    4662:	12 86       	std	Z+10, r1	; 0x0a
    4664:	eb 81       	ldd	r30, Y+3	; 0x03
    4666:	fc 81       	ldd	r31, Y+4	; 0x04
    4668:	80 81       	ld	r24, Z
    466a:	81 50       	subi	r24, 0x01	; 1
    466c:	eb 81       	ldd	r30, Y+3	; 0x03
    466e:	fc 81       	ldd	r31, Y+4	; 0x04
    4670:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    4672:	ef 81       	ldd	r30, Y+7	; 0x07
    4674:	f8 85       	ldd	r31, Y+8	; 0x08
    4676:	96 89       	ldd	r25, Z+22	; 0x16
    4678:	80 91 ac 06 	lds	r24, 0x06AC
    467c:	89 17       	cp	r24, r25
    467e:	28 f4       	brcc	.+10     	; 0x468a <xTaskGenericNotify+0x28c>
    4680:	ef 81       	ldd	r30, Y+7	; 0x07
    4682:	f8 85       	ldd	r31, Y+8	; 0x08
    4684:	86 89       	ldd	r24, Z+22	; 0x16
    4686:	80 93 ac 06 	sts	0x06AC, r24
    468a:	ef 81       	ldd	r30, Y+7	; 0x07
    468c:	f8 85       	ldd	r31, Y+8	; 0x08
    468e:	86 89       	ldd	r24, Z+22	; 0x16
    4690:	28 2f       	mov	r18, r24
    4692:	30 e0       	ldi	r19, 0x00	; 0
    4694:	c9 01       	movw	r24, r18
    4696:	88 0f       	add	r24, r24
    4698:	99 1f       	adc	r25, r25
    469a:	88 0f       	add	r24, r24
    469c:	99 1f       	adc	r25, r25
    469e:	88 0f       	add	r24, r24
    46a0:	99 1f       	adc	r25, r25
    46a2:	82 0f       	add	r24, r18
    46a4:	93 1f       	adc	r25, r19
    46a6:	fc 01       	movw	r30, r24
    46a8:	e8 54       	subi	r30, 0x48	; 72
    46aa:	f9 4f       	sbci	r31, 0xF9	; 249
    46ac:	81 81       	ldd	r24, Z+1	; 0x01
    46ae:	92 81       	ldd	r25, Z+2	; 0x02
    46b0:	9a 83       	std	Y+2, r25	; 0x02
    46b2:	89 83       	std	Y+1, r24	; 0x01
    46b4:	ef 81       	ldd	r30, Y+7	; 0x07
    46b6:	f8 85       	ldd	r31, Y+8	; 0x08
    46b8:	89 81       	ldd	r24, Y+1	; 0x01
    46ba:	9a 81       	ldd	r25, Y+2	; 0x02
    46bc:	95 83       	std	Z+5, r25	; 0x05
    46be:	84 83       	std	Z+4, r24	; 0x04
    46c0:	e9 81       	ldd	r30, Y+1	; 0x01
    46c2:	fa 81       	ldd	r31, Y+2	; 0x02
    46c4:	84 81       	ldd	r24, Z+4	; 0x04
    46c6:	95 81       	ldd	r25, Z+5	; 0x05
    46c8:	ef 81       	ldd	r30, Y+7	; 0x07
    46ca:	f8 85       	ldd	r31, Y+8	; 0x08
    46cc:	97 83       	std	Z+7, r25	; 0x07
    46ce:	86 83       	std	Z+6, r24	; 0x06
    46d0:	e9 81       	ldd	r30, Y+1	; 0x01
    46d2:	fa 81       	ldd	r31, Y+2	; 0x02
    46d4:	04 80       	ldd	r0, Z+4	; 0x04
    46d6:	f5 81       	ldd	r31, Z+5	; 0x05
    46d8:	e0 2d       	mov	r30, r0
    46da:	8f 81       	ldd	r24, Y+7	; 0x07
    46dc:	98 85       	ldd	r25, Y+8	; 0x08
    46de:	02 96       	adiw	r24, 0x02	; 2
    46e0:	93 83       	std	Z+3, r25	; 0x03
    46e2:	82 83       	std	Z+2, r24	; 0x02
    46e4:	8f 81       	ldd	r24, Y+7	; 0x07
    46e6:	98 85       	ldd	r25, Y+8	; 0x08
    46e8:	02 96       	adiw	r24, 0x02	; 2
    46ea:	e9 81       	ldd	r30, Y+1	; 0x01
    46ec:	fa 81       	ldd	r31, Y+2	; 0x02
    46ee:	95 83       	std	Z+5, r25	; 0x05
    46f0:	84 83       	std	Z+4, r24	; 0x04
    46f2:	ef 81       	ldd	r30, Y+7	; 0x07
    46f4:	f8 85       	ldd	r31, Y+8	; 0x08
    46f6:	86 89       	ldd	r24, Z+22	; 0x16
    46f8:	28 2f       	mov	r18, r24
    46fa:	30 e0       	ldi	r19, 0x00	; 0
    46fc:	c9 01       	movw	r24, r18
    46fe:	88 0f       	add	r24, r24
    4700:	99 1f       	adc	r25, r25
    4702:	88 0f       	add	r24, r24
    4704:	99 1f       	adc	r25, r25
    4706:	88 0f       	add	r24, r24
    4708:	99 1f       	adc	r25, r25
    470a:	82 0f       	add	r24, r18
    470c:	93 1f       	adc	r25, r19
    470e:	88 54       	subi	r24, 0x48	; 72
    4710:	99 4f       	sbci	r25, 0xF9	; 249
    4712:	ef 81       	ldd	r30, Y+7	; 0x07
    4714:	f8 85       	ldd	r31, Y+8	; 0x08
    4716:	93 87       	std	Z+11, r25	; 0x0b
    4718:	82 87       	std	Z+10, r24	; 0x0a
    471a:	ef 81       	ldd	r30, Y+7	; 0x07
    471c:	f8 85       	ldd	r31, Y+8	; 0x08
    471e:	86 89       	ldd	r24, Z+22	; 0x16
    4720:	28 2f       	mov	r18, r24
    4722:	30 e0       	ldi	r19, 0x00	; 0
    4724:	c9 01       	movw	r24, r18
    4726:	88 0f       	add	r24, r24
    4728:	99 1f       	adc	r25, r25
    472a:	88 0f       	add	r24, r24
    472c:	99 1f       	adc	r25, r25
    472e:	88 0f       	add	r24, r24
    4730:	99 1f       	adc	r25, r25
    4732:	82 0f       	add	r24, r18
    4734:	93 1f       	adc	r25, r19
    4736:	fc 01       	movw	r30, r24
    4738:	e8 54       	subi	r30, 0x48	; 72
    473a:	f9 4f       	sbci	r31, 0xF9	; 249
    473c:	80 81       	ld	r24, Z
    473e:	8f 5f       	subi	r24, 0xFF	; 255
    4740:	80 83       	st	Z, r24
                         * earliest possible time. */
                        prvResetNextTaskUnblockTime();
                    }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4742:	ef 81       	ldd	r30, Y+7	; 0x07
    4744:	f8 85       	ldd	r31, Y+8	; 0x08
    4746:	96 89       	ldd	r25, Z+22	; 0x16
    4748:	e0 91 a6 06 	lds	r30, 0x06A6
    474c:	f0 91 a7 06 	lds	r31, 0x06A7
    4750:	86 89       	ldd	r24, Z+22	; 0x16
    4752:	89 17       	cp	r24, r25
    4754:	10 f4       	brcc	.+4      	; 0x475a <xTaskGenericNotify+0x35c>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    4756:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    475a:	0f 90       	pop	r0
    475c:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    475e:	8e 81       	ldd	r24, Y+6	; 0x06
    }
    4760:	64 96       	adiw	r28, 0x14	; 20
    4762:	0f b6       	in	r0, 0x3f	; 63
    4764:	f8 94       	cli
    4766:	de bf       	out	0x3e, r29	; 62
    4768:	0f be       	out	0x3f, r0	; 63
    476a:	cd bf       	out	0x3d, r28	; 61
    476c:	cf 91       	pop	r28
    476e:	df 91       	pop	r29
    4770:	1f 91       	pop	r17
    4772:	0f 91       	pop	r16
    4774:	ff 90       	pop	r15
    4776:	ef 90       	pop	r14
    4778:	08 95       	ret

0000477a <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    477a:	cf 92       	push	r12
    477c:	df 92       	push	r13
    477e:	ef 92       	push	r14
    4780:	ff 92       	push	r15
    4782:	0f 93       	push	r16
    4784:	1f 93       	push	r17
    4786:	df 93       	push	r29
    4788:	cf 93       	push	r28
    478a:	cd b7       	in	r28, 0x3d	; 61
    478c:	de b7       	in	r29, 0x3e	; 62
    478e:	69 97       	sbiw	r28, 0x19	; 25
    4790:	0f b6       	in	r0, 0x3f	; 63
    4792:	f8 94       	cli
    4794:	de bf       	out	0x3e, r29	; 62
    4796:	0f be       	out	0x3f, r0	; 63
    4798:	cd bf       	out	0x3d, r28	; 61
    479a:	9d 87       	std	Y+13, r25	; 0x0d
    479c:	8c 87       	std	Y+12, r24	; 0x0c
    479e:	6e 87       	std	Y+14, r22	; 0x0e
    47a0:	2f 87       	std	Y+15, r18	; 0x0f
    47a2:	38 8b       	std	Y+16, r19	; 0x10
    47a4:	49 8b       	std	Y+17, r20	; 0x11
    47a6:	5a 8b       	std	Y+18, r21	; 0x12
    47a8:	0b 8b       	std	Y+19, r16	; 0x13
    47aa:	fd 8a       	std	Y+21, r15	; 0x15
    47ac:	ec 8a       	std	Y+20, r14	; 0x14
    47ae:	df 8a       	std	Y+23, r13	; 0x17
    47b0:	ce 8a       	std	Y+22, r12	; 0x16
        TCB_t * pxTCB;
        uint8_t ucOriginalNotifyState;
        BaseType_t xReturn = pdPASS;
    47b2:	81 e0       	ldi	r24, 0x01	; 1
    47b4:	88 87       	std	Y+8, r24	; 0x08
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    47b6:	8c 85       	ldd	r24, Y+12	; 0x0c
    47b8:	9d 85       	ldd	r25, Y+13	; 0x0d
    47ba:	9b 87       	std	Y+11, r25	; 0x0b
    47bc:	8a 87       	std	Y+10, r24	; 0x0a

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    47be:	1f 82       	std	Y+7, r1	; 0x07
        {
            if( pulPreviousNotificationValue != NULL )
    47c0:	8c 89       	ldd	r24, Y+20	; 0x14
    47c2:	9d 89       	ldd	r25, Y+21	; 0x15
    47c4:	00 97       	sbiw	r24, 0x00	; 0
    47c6:	b9 f0       	breq	.+46     	; 0x47f6 <xTaskGenericNotifyFromISR+0x7c>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    47c8:	8e 85       	ldd	r24, Y+14	; 0x0e
    47ca:	88 2f       	mov	r24, r24
    47cc:	90 e0       	ldi	r25, 0x00	; 0
    47ce:	2a 85       	ldd	r18, Y+10	; 0x0a
    47d0:	3b 85       	ldd	r19, Y+11	; 0x0b
    47d2:	88 0f       	add	r24, r24
    47d4:	99 1f       	adc	r25, r25
    47d6:	88 0f       	add	r24, r24
    47d8:	99 1f       	adc	r25, r25
    47da:	82 0f       	add	r24, r18
    47dc:	93 1f       	adc	r25, r19
    47de:	fc 01       	movw	r30, r24
    47e0:	b1 96       	adiw	r30, 0x21	; 33
    47e2:	80 81       	ld	r24, Z
    47e4:	91 81       	ldd	r25, Z+1	; 0x01
    47e6:	a2 81       	ldd	r26, Z+2	; 0x02
    47e8:	b3 81       	ldd	r27, Z+3	; 0x03
    47ea:	ec 89       	ldd	r30, Y+20	; 0x14
    47ec:	fd 89       	ldd	r31, Y+21	; 0x15
    47ee:	80 83       	st	Z, r24
    47f0:	91 83       	std	Z+1, r25	; 0x01
    47f2:	a2 83       	std	Z+2, r26	; 0x02
    47f4:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    47f6:	8e 85       	ldd	r24, Y+14	; 0x0e
    47f8:	28 2f       	mov	r18, r24
    47fa:	30 e0       	ldi	r19, 0x00	; 0
    47fc:	8a 85       	ldd	r24, Y+10	; 0x0a
    47fe:	9b 85       	ldd	r25, Y+11	; 0x0b
    4800:	82 0f       	add	r24, r18
    4802:	93 1f       	adc	r25, r19
    4804:	fc 01       	movw	r30, r24
    4806:	b5 96       	adiw	r30, 0x25	; 37
    4808:	80 81       	ld	r24, Z
    480a:	89 87       	std	Y+9, r24	; 0x09
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    480c:	8e 85       	ldd	r24, Y+14	; 0x0e
    480e:	28 2f       	mov	r18, r24
    4810:	30 e0       	ldi	r19, 0x00	; 0
    4812:	8a 85       	ldd	r24, Y+10	; 0x0a
    4814:	9b 85       	ldd	r25, Y+11	; 0x0b
    4816:	82 0f       	add	r24, r18
    4818:	93 1f       	adc	r25, r19
    481a:	fc 01       	movw	r30, r24
    481c:	b5 96       	adiw	r30, 0x25	; 37
    481e:	82 e0       	ldi	r24, 0x02	; 2
    4820:	80 83       	st	Z, r24

            switch( eAction )
    4822:	8b 89       	ldd	r24, Y+19	; 0x13
    4824:	28 2f       	mov	r18, r24
    4826:	30 e0       	ldi	r19, 0x00	; 0
    4828:	39 8f       	std	Y+25, r19	; 0x19
    482a:	28 8f       	std	Y+24, r18	; 0x18
    482c:	88 8d       	ldd	r24, Y+24	; 0x18
    482e:	99 8d       	ldd	r25, Y+25	; 0x19
    4830:	82 30       	cpi	r24, 0x02	; 2
    4832:	91 05       	cpc	r25, r1
    4834:	09 f4       	brne	.+2      	; 0x4838 <xTaskGenericNotifyFromISR+0xbe>
    4836:	46 c0       	rjmp	.+140    	; 0x48c4 <xTaskGenericNotifyFromISR+0x14a>
    4838:	28 8d       	ldd	r18, Y+24	; 0x18
    483a:	39 8d       	ldd	r19, Y+25	; 0x19
    483c:	23 30       	cpi	r18, 0x03	; 3
    483e:	31 05       	cpc	r19, r1
    4840:	34 f4       	brge	.+12     	; 0x484e <xTaskGenericNotifyFromISR+0xd4>
    4842:	88 8d       	ldd	r24, Y+24	; 0x18
    4844:	99 8d       	ldd	r25, Y+25	; 0x19
    4846:	81 30       	cpi	r24, 0x01	; 1
    4848:	91 05       	cpc	r25, r1
    484a:	71 f0       	breq	.+28     	; 0x4868 <xTaskGenericNotifyFromISR+0xee>
    484c:	93 c0       	rjmp	.+294    	; 0x4974 <xTaskGenericNotifyFromISR+0x1fa>
    484e:	28 8d       	ldd	r18, Y+24	; 0x18
    4850:	39 8d       	ldd	r19, Y+25	; 0x19
    4852:	23 30       	cpi	r18, 0x03	; 3
    4854:	31 05       	cpc	r19, r1
    4856:	09 f4       	brne	.+2      	; 0x485a <xTaskGenericNotifyFromISR+0xe0>
    4858:	5d c0       	rjmp	.+186    	; 0x4914 <xTaskGenericNotifyFromISR+0x19a>
    485a:	88 8d       	ldd	r24, Y+24	; 0x18
    485c:	99 8d       	ldd	r25, Y+25	; 0x19
    485e:	84 30       	cpi	r24, 0x04	; 4
    4860:	91 05       	cpc	r25, r1
    4862:	09 f4       	brne	.+2      	; 0x4866 <xTaskGenericNotifyFromISR+0xec>
    4864:	6d c0       	rjmp	.+218    	; 0x4940 <xTaskGenericNotifyFromISR+0x1c6>
    4866:	86 c0       	rjmp	.+268    	; 0x4974 <xTaskGenericNotifyFromISR+0x1fa>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    4868:	8e 85       	ldd	r24, Y+14	; 0x0e
    486a:	08 2f       	mov	r16, r24
    486c:	10 e0       	ldi	r17, 0x00	; 0
    486e:	8e 85       	ldd	r24, Y+14	; 0x0e
    4870:	88 2f       	mov	r24, r24
    4872:	90 e0       	ldi	r25, 0x00	; 0
    4874:	2a 85       	ldd	r18, Y+10	; 0x0a
    4876:	3b 85       	ldd	r19, Y+11	; 0x0b
    4878:	88 0f       	add	r24, r24
    487a:	99 1f       	adc	r25, r25
    487c:	88 0f       	add	r24, r24
    487e:	99 1f       	adc	r25, r25
    4880:	82 0f       	add	r24, r18
    4882:	93 1f       	adc	r25, r19
    4884:	fc 01       	movw	r30, r24
    4886:	b1 96       	adiw	r30, 0x21	; 33
    4888:	20 81       	ld	r18, Z
    488a:	31 81       	ldd	r19, Z+1	; 0x01
    488c:	42 81       	ldd	r20, Z+2	; 0x02
    488e:	53 81       	ldd	r21, Z+3	; 0x03
    4890:	8f 85       	ldd	r24, Y+15	; 0x0f
    4892:	98 89       	ldd	r25, Y+16	; 0x10
    4894:	a9 89       	ldd	r26, Y+17	; 0x11
    4896:	ba 89       	ldd	r27, Y+18	; 0x12
    4898:	ba 01       	movw	r22, r20
    489a:	a9 01       	movw	r20, r18
    489c:	48 2b       	or	r20, r24
    489e:	59 2b       	or	r21, r25
    48a0:	6a 2b       	or	r22, r26
    48a2:	7b 2b       	or	r23, r27
    48a4:	2a 85       	ldd	r18, Y+10	; 0x0a
    48a6:	3b 85       	ldd	r19, Y+11	; 0x0b
    48a8:	c8 01       	movw	r24, r16
    48aa:	88 0f       	add	r24, r24
    48ac:	99 1f       	adc	r25, r25
    48ae:	88 0f       	add	r24, r24
    48b0:	99 1f       	adc	r25, r25
    48b2:	82 0f       	add	r24, r18
    48b4:	93 1f       	adc	r25, r19
    48b6:	fc 01       	movw	r30, r24
    48b8:	b1 96       	adiw	r30, 0x21	; 33
    48ba:	40 83       	st	Z, r20
    48bc:	51 83       	std	Z+1, r21	; 0x01
    48be:	62 83       	std	Z+2, r22	; 0x02
    48c0:	73 83       	std	Z+3, r23	; 0x03
    48c2:	58 c0       	rjmp	.+176    	; 0x4974 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    48c4:	8e 85       	ldd	r24, Y+14	; 0x0e
    48c6:	08 2f       	mov	r16, r24
    48c8:	10 e0       	ldi	r17, 0x00	; 0
    48ca:	2a 85       	ldd	r18, Y+10	; 0x0a
    48cc:	3b 85       	ldd	r19, Y+11	; 0x0b
    48ce:	c8 01       	movw	r24, r16
    48d0:	88 0f       	add	r24, r24
    48d2:	99 1f       	adc	r25, r25
    48d4:	88 0f       	add	r24, r24
    48d6:	99 1f       	adc	r25, r25
    48d8:	82 0f       	add	r24, r18
    48da:	93 1f       	adc	r25, r19
    48dc:	fc 01       	movw	r30, r24
    48de:	b1 96       	adiw	r30, 0x21	; 33
    48e0:	80 81       	ld	r24, Z
    48e2:	91 81       	ldd	r25, Z+1	; 0x01
    48e4:	a2 81       	ldd	r26, Z+2	; 0x02
    48e6:	b3 81       	ldd	r27, Z+3	; 0x03
    48e8:	ac 01       	movw	r20, r24
    48ea:	bd 01       	movw	r22, r26
    48ec:	4f 5f       	subi	r20, 0xFF	; 255
    48ee:	5f 4f       	sbci	r21, 0xFF	; 255
    48f0:	6f 4f       	sbci	r22, 0xFF	; 255
    48f2:	7f 4f       	sbci	r23, 0xFF	; 255
    48f4:	2a 85       	ldd	r18, Y+10	; 0x0a
    48f6:	3b 85       	ldd	r19, Y+11	; 0x0b
    48f8:	c8 01       	movw	r24, r16
    48fa:	88 0f       	add	r24, r24
    48fc:	99 1f       	adc	r25, r25
    48fe:	88 0f       	add	r24, r24
    4900:	99 1f       	adc	r25, r25
    4902:	82 0f       	add	r24, r18
    4904:	93 1f       	adc	r25, r19
    4906:	fc 01       	movw	r30, r24
    4908:	b1 96       	adiw	r30, 0x21	; 33
    490a:	40 83       	st	Z, r20
    490c:	51 83       	std	Z+1, r21	; 0x01
    490e:	62 83       	std	Z+2, r22	; 0x02
    4910:	73 83       	std	Z+3, r23	; 0x03
    4912:	30 c0       	rjmp	.+96     	; 0x4974 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4914:	8e 85       	ldd	r24, Y+14	; 0x0e
    4916:	88 2f       	mov	r24, r24
    4918:	90 e0       	ldi	r25, 0x00	; 0
    491a:	2a 85       	ldd	r18, Y+10	; 0x0a
    491c:	3b 85       	ldd	r19, Y+11	; 0x0b
    491e:	88 0f       	add	r24, r24
    4920:	99 1f       	adc	r25, r25
    4922:	88 0f       	add	r24, r24
    4924:	99 1f       	adc	r25, r25
    4926:	82 0f       	add	r24, r18
    4928:	93 1f       	adc	r25, r19
    492a:	fc 01       	movw	r30, r24
    492c:	b1 96       	adiw	r30, 0x21	; 33
    492e:	8f 85       	ldd	r24, Y+15	; 0x0f
    4930:	98 89       	ldd	r25, Y+16	; 0x10
    4932:	a9 89       	ldd	r26, Y+17	; 0x11
    4934:	ba 89       	ldd	r27, Y+18	; 0x12
    4936:	80 83       	st	Z, r24
    4938:	91 83       	std	Z+1, r25	; 0x01
    493a:	a2 83       	std	Z+2, r26	; 0x02
    493c:	b3 83       	std	Z+3, r27	; 0x03
    493e:	1a c0       	rjmp	.+52     	; 0x4974 <xTaskGenericNotifyFromISR+0x1fa>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    4940:	89 85       	ldd	r24, Y+9	; 0x09
    4942:	82 30       	cpi	r24, 0x02	; 2
    4944:	b1 f0       	breq	.+44     	; 0x4972 <xTaskGenericNotifyFromISR+0x1f8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    4946:	8e 85       	ldd	r24, Y+14	; 0x0e
    4948:	88 2f       	mov	r24, r24
    494a:	90 e0       	ldi	r25, 0x00	; 0
    494c:	2a 85       	ldd	r18, Y+10	; 0x0a
    494e:	3b 85       	ldd	r19, Y+11	; 0x0b
    4950:	88 0f       	add	r24, r24
    4952:	99 1f       	adc	r25, r25
    4954:	88 0f       	add	r24, r24
    4956:	99 1f       	adc	r25, r25
    4958:	82 0f       	add	r24, r18
    495a:	93 1f       	adc	r25, r19
    495c:	fc 01       	movw	r30, r24
    495e:	b1 96       	adiw	r30, 0x21	; 33
    4960:	8f 85       	ldd	r24, Y+15	; 0x0f
    4962:	98 89       	ldd	r25, Y+16	; 0x10
    4964:	a9 89       	ldd	r26, Y+17	; 0x11
    4966:	ba 89       	ldd	r27, Y+18	; 0x12
    4968:	80 83       	st	Z, r24
    496a:	91 83       	std	Z+1, r25	; 0x01
    496c:	a2 83       	std	Z+2, r26	; 0x02
    496e:	b3 83       	std	Z+3, r27	; 0x03
    4970:	01 c0       	rjmp	.+2      	; 0x4974 <xTaskGenericNotifyFromISR+0x1fa>
                    }
                    else
                    {
                        /* The value could not be written to the task. */
                        xReturn = pdFAIL;
    4972:	18 86       	std	Y+8, r1	; 0x08

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4974:	89 85       	ldd	r24, Y+9	; 0x09
    4976:	81 30       	cpi	r24, 0x01	; 1
    4978:	09 f0       	breq	.+2      	; 0x497c <xTaskGenericNotifyFromISR+0x202>
    497a:	ee c0       	rjmp	.+476    	; 0x4b58 <xTaskGenericNotifyFromISR+0x3de>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    497c:	80 91 b7 06 	lds	r24, 0x06B7
    4980:	88 23       	and	r24, r24
    4982:	09 f0       	breq	.+2      	; 0x4986 <xTaskGenericNotifyFromISR+0x20c>
    4984:	a4 c0       	rjmp	.+328    	; 0x4ace <xTaskGenericNotifyFromISR+0x354>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    4986:	ea 85       	ldd	r30, Y+10	; 0x0a
    4988:	fb 85       	ldd	r31, Y+11	; 0x0b
    498a:	82 85       	ldd	r24, Z+10	; 0x0a
    498c:	93 85       	ldd	r25, Z+11	; 0x0b
    498e:	9e 83       	std	Y+6, r25	; 0x06
    4990:	8d 83       	std	Y+5, r24	; 0x05
    4992:	ea 85       	ldd	r30, Y+10	; 0x0a
    4994:	fb 85       	ldd	r31, Y+11	; 0x0b
    4996:	a4 81       	ldd	r26, Z+4	; 0x04
    4998:	b5 81       	ldd	r27, Z+5	; 0x05
    499a:	ea 85       	ldd	r30, Y+10	; 0x0a
    499c:	fb 85       	ldd	r31, Y+11	; 0x0b
    499e:	86 81       	ldd	r24, Z+6	; 0x06
    49a0:	97 81       	ldd	r25, Z+7	; 0x07
    49a2:	15 96       	adiw	r26, 0x05	; 5
    49a4:	9c 93       	st	X, r25
    49a6:	8e 93       	st	-X, r24
    49a8:	14 97       	sbiw	r26, 0x04	; 4
    49aa:	ea 85       	ldd	r30, Y+10	; 0x0a
    49ac:	fb 85       	ldd	r31, Y+11	; 0x0b
    49ae:	a6 81       	ldd	r26, Z+6	; 0x06
    49b0:	b7 81       	ldd	r27, Z+7	; 0x07
    49b2:	ea 85       	ldd	r30, Y+10	; 0x0a
    49b4:	fb 85       	ldd	r31, Y+11	; 0x0b
    49b6:	84 81       	ldd	r24, Z+4	; 0x04
    49b8:	95 81       	ldd	r25, Z+5	; 0x05
    49ba:	13 96       	adiw	r26, 0x03	; 3
    49bc:	9c 93       	st	X, r25
    49be:	8e 93       	st	-X, r24
    49c0:	12 97       	sbiw	r26, 0x02	; 2
    49c2:	ed 81       	ldd	r30, Y+5	; 0x05
    49c4:	fe 81       	ldd	r31, Y+6	; 0x06
    49c6:	21 81       	ldd	r18, Z+1	; 0x01
    49c8:	32 81       	ldd	r19, Z+2	; 0x02
    49ca:	8a 85       	ldd	r24, Y+10	; 0x0a
    49cc:	9b 85       	ldd	r25, Y+11	; 0x0b
    49ce:	02 96       	adiw	r24, 0x02	; 2
    49d0:	28 17       	cp	r18, r24
    49d2:	39 07       	cpc	r19, r25
    49d4:	41 f4       	brne	.+16     	; 0x49e6 <xTaskGenericNotifyFromISR+0x26c>
    49d6:	ea 85       	ldd	r30, Y+10	; 0x0a
    49d8:	fb 85       	ldd	r31, Y+11	; 0x0b
    49da:	86 81       	ldd	r24, Z+6	; 0x06
    49dc:	97 81       	ldd	r25, Z+7	; 0x07
    49de:	ed 81       	ldd	r30, Y+5	; 0x05
    49e0:	fe 81       	ldd	r31, Y+6	; 0x06
    49e2:	92 83       	std	Z+2, r25	; 0x02
    49e4:	81 83       	std	Z+1, r24	; 0x01
    49e6:	ea 85       	ldd	r30, Y+10	; 0x0a
    49e8:	fb 85       	ldd	r31, Y+11	; 0x0b
    49ea:	13 86       	std	Z+11, r1	; 0x0b
    49ec:	12 86       	std	Z+10, r1	; 0x0a
    49ee:	ed 81       	ldd	r30, Y+5	; 0x05
    49f0:	fe 81       	ldd	r31, Y+6	; 0x06
    49f2:	80 81       	ld	r24, Z
    49f4:	81 50       	subi	r24, 0x01	; 1
    49f6:	ed 81       	ldd	r30, Y+5	; 0x05
    49f8:	fe 81       	ldd	r31, Y+6	; 0x06
    49fa:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    49fc:	ea 85       	ldd	r30, Y+10	; 0x0a
    49fe:	fb 85       	ldd	r31, Y+11	; 0x0b
    4a00:	96 89       	ldd	r25, Z+22	; 0x16
    4a02:	80 91 ac 06 	lds	r24, 0x06AC
    4a06:	89 17       	cp	r24, r25
    4a08:	28 f4       	brcc	.+10     	; 0x4a14 <xTaskGenericNotifyFromISR+0x29a>
    4a0a:	ea 85       	ldd	r30, Y+10	; 0x0a
    4a0c:	fb 85       	ldd	r31, Y+11	; 0x0b
    4a0e:	86 89       	ldd	r24, Z+22	; 0x16
    4a10:	80 93 ac 06 	sts	0x06AC, r24
    4a14:	ea 85       	ldd	r30, Y+10	; 0x0a
    4a16:	fb 85       	ldd	r31, Y+11	; 0x0b
    4a18:	86 89       	ldd	r24, Z+22	; 0x16
    4a1a:	28 2f       	mov	r18, r24
    4a1c:	30 e0       	ldi	r19, 0x00	; 0
    4a1e:	c9 01       	movw	r24, r18
    4a20:	88 0f       	add	r24, r24
    4a22:	99 1f       	adc	r25, r25
    4a24:	88 0f       	add	r24, r24
    4a26:	99 1f       	adc	r25, r25
    4a28:	88 0f       	add	r24, r24
    4a2a:	99 1f       	adc	r25, r25
    4a2c:	82 0f       	add	r24, r18
    4a2e:	93 1f       	adc	r25, r19
    4a30:	fc 01       	movw	r30, r24
    4a32:	e8 54       	subi	r30, 0x48	; 72
    4a34:	f9 4f       	sbci	r31, 0xF9	; 249
    4a36:	81 81       	ldd	r24, Z+1	; 0x01
    4a38:	92 81       	ldd	r25, Z+2	; 0x02
    4a3a:	9c 83       	std	Y+4, r25	; 0x04
    4a3c:	8b 83       	std	Y+3, r24	; 0x03
    4a3e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4a40:	fb 85       	ldd	r31, Y+11	; 0x0b
    4a42:	8b 81       	ldd	r24, Y+3	; 0x03
    4a44:	9c 81       	ldd	r25, Y+4	; 0x04
    4a46:	95 83       	std	Z+5, r25	; 0x05
    4a48:	84 83       	std	Z+4, r24	; 0x04
    4a4a:	eb 81       	ldd	r30, Y+3	; 0x03
    4a4c:	fc 81       	ldd	r31, Y+4	; 0x04
    4a4e:	84 81       	ldd	r24, Z+4	; 0x04
    4a50:	95 81       	ldd	r25, Z+5	; 0x05
    4a52:	ea 85       	ldd	r30, Y+10	; 0x0a
    4a54:	fb 85       	ldd	r31, Y+11	; 0x0b
    4a56:	97 83       	std	Z+7, r25	; 0x07
    4a58:	86 83       	std	Z+6, r24	; 0x06
    4a5a:	eb 81       	ldd	r30, Y+3	; 0x03
    4a5c:	fc 81       	ldd	r31, Y+4	; 0x04
    4a5e:	04 80       	ldd	r0, Z+4	; 0x04
    4a60:	f5 81       	ldd	r31, Z+5	; 0x05
    4a62:	e0 2d       	mov	r30, r0
    4a64:	8a 85       	ldd	r24, Y+10	; 0x0a
    4a66:	9b 85       	ldd	r25, Y+11	; 0x0b
    4a68:	02 96       	adiw	r24, 0x02	; 2
    4a6a:	93 83       	std	Z+3, r25	; 0x03
    4a6c:	82 83       	std	Z+2, r24	; 0x02
    4a6e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4a70:	9b 85       	ldd	r25, Y+11	; 0x0b
    4a72:	02 96       	adiw	r24, 0x02	; 2
    4a74:	eb 81       	ldd	r30, Y+3	; 0x03
    4a76:	fc 81       	ldd	r31, Y+4	; 0x04
    4a78:	95 83       	std	Z+5, r25	; 0x05
    4a7a:	84 83       	std	Z+4, r24	; 0x04
    4a7c:	ea 85       	ldd	r30, Y+10	; 0x0a
    4a7e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4a80:	86 89       	ldd	r24, Z+22	; 0x16
    4a82:	28 2f       	mov	r18, r24
    4a84:	30 e0       	ldi	r19, 0x00	; 0
    4a86:	c9 01       	movw	r24, r18
    4a88:	88 0f       	add	r24, r24
    4a8a:	99 1f       	adc	r25, r25
    4a8c:	88 0f       	add	r24, r24
    4a8e:	99 1f       	adc	r25, r25
    4a90:	88 0f       	add	r24, r24
    4a92:	99 1f       	adc	r25, r25
    4a94:	82 0f       	add	r24, r18
    4a96:	93 1f       	adc	r25, r19
    4a98:	88 54       	subi	r24, 0x48	; 72
    4a9a:	99 4f       	sbci	r25, 0xF9	; 249
    4a9c:	ea 85       	ldd	r30, Y+10	; 0x0a
    4a9e:	fb 85       	ldd	r31, Y+11	; 0x0b
    4aa0:	93 87       	std	Z+11, r25	; 0x0b
    4aa2:	82 87       	std	Z+10, r24	; 0x0a
    4aa4:	ea 85       	ldd	r30, Y+10	; 0x0a
    4aa6:	fb 85       	ldd	r31, Y+11	; 0x0b
    4aa8:	86 89       	ldd	r24, Z+22	; 0x16
    4aaa:	28 2f       	mov	r18, r24
    4aac:	30 e0       	ldi	r19, 0x00	; 0
    4aae:	c9 01       	movw	r24, r18
    4ab0:	88 0f       	add	r24, r24
    4ab2:	99 1f       	adc	r25, r25
    4ab4:	88 0f       	add	r24, r24
    4ab6:	99 1f       	adc	r25, r25
    4ab8:	88 0f       	add	r24, r24
    4aba:	99 1f       	adc	r25, r25
    4abc:	82 0f       	add	r24, r18
    4abe:	93 1f       	adc	r25, r19
    4ac0:	fc 01       	movw	r30, r24
    4ac2:	e8 54       	subi	r30, 0x48	; 72
    4ac4:	f9 4f       	sbci	r31, 0xF9	; 249
    4ac6:	80 81       	ld	r24, Z
    4ac8:	8f 5f       	subi	r24, 0xFF	; 255
    4aca:	80 83       	st	Z, r24
    4acc:	30 c0       	rjmp	.+96     	; 0x4b2e <xTaskGenericNotifyFromISR+0x3b4>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4ace:	80 91 f3 06 	lds	r24, 0x06F3
    4ad2:	90 91 f4 06 	lds	r25, 0x06F4
    4ad6:	9a 83       	std	Y+2, r25	; 0x02
    4ad8:	89 83       	std	Y+1, r24	; 0x01
    4ada:	ea 85       	ldd	r30, Y+10	; 0x0a
    4adc:	fb 85       	ldd	r31, Y+11	; 0x0b
    4ade:	89 81       	ldd	r24, Y+1	; 0x01
    4ae0:	9a 81       	ldd	r25, Y+2	; 0x02
    4ae2:	97 87       	std	Z+15, r25	; 0x0f
    4ae4:	86 87       	std	Z+14, r24	; 0x0e
    4ae6:	e9 81       	ldd	r30, Y+1	; 0x01
    4ae8:	fa 81       	ldd	r31, Y+2	; 0x02
    4aea:	84 81       	ldd	r24, Z+4	; 0x04
    4aec:	95 81       	ldd	r25, Z+5	; 0x05
    4aee:	ea 85       	ldd	r30, Y+10	; 0x0a
    4af0:	fb 85       	ldd	r31, Y+11	; 0x0b
    4af2:	91 8b       	std	Z+17, r25	; 0x11
    4af4:	80 8b       	std	Z+16, r24	; 0x10
    4af6:	e9 81       	ldd	r30, Y+1	; 0x01
    4af8:	fa 81       	ldd	r31, Y+2	; 0x02
    4afa:	04 80       	ldd	r0, Z+4	; 0x04
    4afc:	f5 81       	ldd	r31, Z+5	; 0x05
    4afe:	e0 2d       	mov	r30, r0
    4b00:	8a 85       	ldd	r24, Y+10	; 0x0a
    4b02:	9b 85       	ldd	r25, Y+11	; 0x0b
    4b04:	0c 96       	adiw	r24, 0x0c	; 12
    4b06:	93 83       	std	Z+3, r25	; 0x03
    4b08:	82 83       	std	Z+2, r24	; 0x02
    4b0a:	8a 85       	ldd	r24, Y+10	; 0x0a
    4b0c:	9b 85       	ldd	r25, Y+11	; 0x0b
    4b0e:	0c 96       	adiw	r24, 0x0c	; 12
    4b10:	e9 81       	ldd	r30, Y+1	; 0x01
    4b12:	fa 81       	ldd	r31, Y+2	; 0x02
    4b14:	95 83       	std	Z+5, r25	; 0x05
    4b16:	84 83       	std	Z+4, r24	; 0x04
    4b18:	ea 85       	ldd	r30, Y+10	; 0x0a
    4b1a:	fb 85       	ldd	r31, Y+11	; 0x0b
    4b1c:	82 ef       	ldi	r24, 0xF2	; 242
    4b1e:	96 e0       	ldi	r25, 0x06	; 6
    4b20:	95 8b       	std	Z+21, r25	; 0x15
    4b22:	84 8b       	std	Z+20, r24	; 0x14
    4b24:	80 91 f2 06 	lds	r24, 0x06F2
    4b28:	8f 5f       	subi	r24, 0xFF	; 255
    4b2a:	80 93 f2 06 	sts	0x06F2, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4b2e:	ea 85       	ldd	r30, Y+10	; 0x0a
    4b30:	fb 85       	ldd	r31, Y+11	; 0x0b
    4b32:	96 89       	ldd	r25, Z+22	; 0x16
    4b34:	e0 91 a6 06 	lds	r30, 0x06A6
    4b38:	f0 91 a7 06 	lds	r31, 0x06A7
    4b3c:	86 89       	ldd	r24, Z+22	; 0x16
    4b3e:	89 17       	cp	r24, r25
    4b40:	58 f4       	brcc	.+22     	; 0x4b58 <xTaskGenericNotifyFromISR+0x3de>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    4b42:	8e 89       	ldd	r24, Y+22	; 0x16
    4b44:	9f 89       	ldd	r25, Y+23	; 0x17
    4b46:	00 97       	sbiw	r24, 0x00	; 0
    4b48:	21 f0       	breq	.+8      	; 0x4b52 <xTaskGenericNotifyFromISR+0x3d8>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    4b4a:	ee 89       	ldd	r30, Y+22	; 0x16
    4b4c:	ff 89       	ldd	r31, Y+23	; 0x17
    4b4e:	81 e0       	ldi	r24, 0x01	; 1
    4b50:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    4b52:	81 e0       	ldi	r24, 0x01	; 1
    4b54:	80 93 b0 06 	sts	0x06B0, r24
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    4b58:	88 85       	ldd	r24, Y+8	; 0x08
    }
    4b5a:	69 96       	adiw	r28, 0x19	; 25
    4b5c:	0f b6       	in	r0, 0x3f	; 63
    4b5e:	f8 94       	cli
    4b60:	de bf       	out	0x3e, r29	; 62
    4b62:	0f be       	out	0x3f, r0	; 63
    4b64:	cd bf       	out	0x3d, r28	; 61
    4b66:	cf 91       	pop	r28
    4b68:	df 91       	pop	r29
    4b6a:	1f 91       	pop	r17
    4b6c:	0f 91       	pop	r16
    4b6e:	ff 90       	pop	r15
    4b70:	ef 90       	pop	r14
    4b72:	df 90       	pop	r13
    4b74:	cf 90       	pop	r12
    4b76:	08 95       	ret

00004b78 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    4b78:	0f 93       	push	r16
    4b7a:	1f 93       	push	r17
    4b7c:	df 93       	push	r29
    4b7e:	cf 93       	push	r28
    4b80:	cd b7       	in	r28, 0x3d	; 61
    4b82:	de b7       	in	r29, 0x3e	; 62
    4b84:	2f 97       	sbiw	r28, 0x0f	; 15
    4b86:	0f b6       	in	r0, 0x3f	; 63
    4b88:	f8 94       	cli
    4b8a:	de bf       	out	0x3e, r29	; 62
    4b8c:	0f be       	out	0x3f, r0	; 63
    4b8e:	cd bf       	out	0x3d, r28	; 61
    4b90:	9c 87       	std	Y+12, r25	; 0x0c
    4b92:	8b 87       	std	Y+11, r24	; 0x0b
    4b94:	6d 87       	std	Y+13, r22	; 0x0d
    4b96:	5f 87       	std	Y+15, r21	; 0x0f
    4b98:	4e 87       	std	Y+14, r20	; 0x0e
         * simple as possible.  More information (albeit Cortex-M specific) is
         * provided on the following link:
         * https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
        portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

        pxTCB = xTaskToNotify;
    4b9a:	8b 85       	ldd	r24, Y+11	; 0x0b
    4b9c:	9c 85       	ldd	r25, Y+12	; 0x0c
    4b9e:	9a 87       	std	Y+10, r25	; 0x0a
    4ba0:	89 87       	std	Y+9, r24	; 0x09

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4ba2:	1f 82       	std	Y+7, r1	; 0x07
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    4ba4:	8d 85       	ldd	r24, Y+13	; 0x0d
    4ba6:	28 2f       	mov	r18, r24
    4ba8:	30 e0       	ldi	r19, 0x00	; 0
    4baa:	89 85       	ldd	r24, Y+9	; 0x09
    4bac:	9a 85       	ldd	r25, Y+10	; 0x0a
    4bae:	82 0f       	add	r24, r18
    4bb0:	93 1f       	adc	r25, r19
    4bb2:	fc 01       	movw	r30, r24
    4bb4:	b5 96       	adiw	r30, 0x25	; 37
    4bb6:	80 81       	ld	r24, Z
    4bb8:	88 87       	std	Y+8, r24	; 0x08
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    4bba:	8d 85       	ldd	r24, Y+13	; 0x0d
    4bbc:	28 2f       	mov	r18, r24
    4bbe:	30 e0       	ldi	r19, 0x00	; 0
    4bc0:	89 85       	ldd	r24, Y+9	; 0x09
    4bc2:	9a 85       	ldd	r25, Y+10	; 0x0a
    4bc4:	82 0f       	add	r24, r18
    4bc6:	93 1f       	adc	r25, r19
    4bc8:	fc 01       	movw	r30, r24
    4bca:	b5 96       	adiw	r30, 0x25	; 37
    4bcc:	82 e0       	ldi	r24, 0x02	; 2
    4bce:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    4bd0:	8d 85       	ldd	r24, Y+13	; 0x0d
    4bd2:	08 2f       	mov	r16, r24
    4bd4:	10 e0       	ldi	r17, 0x00	; 0
    4bd6:	29 85       	ldd	r18, Y+9	; 0x09
    4bd8:	3a 85       	ldd	r19, Y+10	; 0x0a
    4bda:	c8 01       	movw	r24, r16
    4bdc:	88 0f       	add	r24, r24
    4bde:	99 1f       	adc	r25, r25
    4be0:	88 0f       	add	r24, r24
    4be2:	99 1f       	adc	r25, r25
    4be4:	82 0f       	add	r24, r18
    4be6:	93 1f       	adc	r25, r19
    4be8:	fc 01       	movw	r30, r24
    4bea:	b1 96       	adiw	r30, 0x21	; 33
    4bec:	80 81       	ld	r24, Z
    4bee:	91 81       	ldd	r25, Z+1	; 0x01
    4bf0:	a2 81       	ldd	r26, Z+2	; 0x02
    4bf2:	b3 81       	ldd	r27, Z+3	; 0x03
    4bf4:	ac 01       	movw	r20, r24
    4bf6:	bd 01       	movw	r22, r26
    4bf8:	4f 5f       	subi	r20, 0xFF	; 255
    4bfa:	5f 4f       	sbci	r21, 0xFF	; 255
    4bfc:	6f 4f       	sbci	r22, 0xFF	; 255
    4bfe:	7f 4f       	sbci	r23, 0xFF	; 255
    4c00:	29 85       	ldd	r18, Y+9	; 0x09
    4c02:	3a 85       	ldd	r19, Y+10	; 0x0a
    4c04:	c8 01       	movw	r24, r16
    4c06:	88 0f       	add	r24, r24
    4c08:	99 1f       	adc	r25, r25
    4c0a:	88 0f       	add	r24, r24
    4c0c:	99 1f       	adc	r25, r25
    4c0e:	82 0f       	add	r24, r18
    4c10:	93 1f       	adc	r25, r19
    4c12:	fc 01       	movw	r30, r24
    4c14:	b1 96       	adiw	r30, 0x21	; 33
    4c16:	40 83       	st	Z, r20
    4c18:	51 83       	std	Z+1, r21	; 0x01
    4c1a:	62 83       	std	Z+2, r22	; 0x02
    4c1c:	73 83       	std	Z+3, r23	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4c1e:	88 85       	ldd	r24, Y+8	; 0x08
    4c20:	81 30       	cpi	r24, 0x01	; 1
    4c22:	09 f0       	breq	.+2      	; 0x4c26 <vTaskGenericNotifyGiveFromISR+0xae>
    4c24:	ee c0       	rjmp	.+476    	; 0x4e02 <vTaskGenericNotifyGiveFromISR+0x28a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4c26:	80 91 b7 06 	lds	r24, 0x06B7
    4c2a:	88 23       	and	r24, r24
    4c2c:	09 f0       	breq	.+2      	; 0x4c30 <vTaskGenericNotifyGiveFromISR+0xb8>
    4c2e:	a4 c0       	rjmp	.+328    	; 0x4d78 <vTaskGenericNotifyGiveFromISR+0x200>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    4c30:	e9 85       	ldd	r30, Y+9	; 0x09
    4c32:	fa 85       	ldd	r31, Y+10	; 0x0a
    4c34:	82 85       	ldd	r24, Z+10	; 0x0a
    4c36:	93 85       	ldd	r25, Z+11	; 0x0b
    4c38:	9e 83       	std	Y+6, r25	; 0x06
    4c3a:	8d 83       	std	Y+5, r24	; 0x05
    4c3c:	e9 85       	ldd	r30, Y+9	; 0x09
    4c3e:	fa 85       	ldd	r31, Y+10	; 0x0a
    4c40:	a4 81       	ldd	r26, Z+4	; 0x04
    4c42:	b5 81       	ldd	r27, Z+5	; 0x05
    4c44:	e9 85       	ldd	r30, Y+9	; 0x09
    4c46:	fa 85       	ldd	r31, Y+10	; 0x0a
    4c48:	86 81       	ldd	r24, Z+6	; 0x06
    4c4a:	97 81       	ldd	r25, Z+7	; 0x07
    4c4c:	15 96       	adiw	r26, 0x05	; 5
    4c4e:	9c 93       	st	X, r25
    4c50:	8e 93       	st	-X, r24
    4c52:	14 97       	sbiw	r26, 0x04	; 4
    4c54:	e9 85       	ldd	r30, Y+9	; 0x09
    4c56:	fa 85       	ldd	r31, Y+10	; 0x0a
    4c58:	a6 81       	ldd	r26, Z+6	; 0x06
    4c5a:	b7 81       	ldd	r27, Z+7	; 0x07
    4c5c:	e9 85       	ldd	r30, Y+9	; 0x09
    4c5e:	fa 85       	ldd	r31, Y+10	; 0x0a
    4c60:	84 81       	ldd	r24, Z+4	; 0x04
    4c62:	95 81       	ldd	r25, Z+5	; 0x05
    4c64:	13 96       	adiw	r26, 0x03	; 3
    4c66:	9c 93       	st	X, r25
    4c68:	8e 93       	st	-X, r24
    4c6a:	12 97       	sbiw	r26, 0x02	; 2
    4c6c:	ed 81       	ldd	r30, Y+5	; 0x05
    4c6e:	fe 81       	ldd	r31, Y+6	; 0x06
    4c70:	21 81       	ldd	r18, Z+1	; 0x01
    4c72:	32 81       	ldd	r19, Z+2	; 0x02
    4c74:	89 85       	ldd	r24, Y+9	; 0x09
    4c76:	9a 85       	ldd	r25, Y+10	; 0x0a
    4c78:	02 96       	adiw	r24, 0x02	; 2
    4c7a:	28 17       	cp	r18, r24
    4c7c:	39 07       	cpc	r19, r25
    4c7e:	41 f4       	brne	.+16     	; 0x4c90 <vTaskGenericNotifyGiveFromISR+0x118>
    4c80:	e9 85       	ldd	r30, Y+9	; 0x09
    4c82:	fa 85       	ldd	r31, Y+10	; 0x0a
    4c84:	86 81       	ldd	r24, Z+6	; 0x06
    4c86:	97 81       	ldd	r25, Z+7	; 0x07
    4c88:	ed 81       	ldd	r30, Y+5	; 0x05
    4c8a:	fe 81       	ldd	r31, Y+6	; 0x06
    4c8c:	92 83       	std	Z+2, r25	; 0x02
    4c8e:	81 83       	std	Z+1, r24	; 0x01
    4c90:	e9 85       	ldd	r30, Y+9	; 0x09
    4c92:	fa 85       	ldd	r31, Y+10	; 0x0a
    4c94:	13 86       	std	Z+11, r1	; 0x0b
    4c96:	12 86       	std	Z+10, r1	; 0x0a
    4c98:	ed 81       	ldd	r30, Y+5	; 0x05
    4c9a:	fe 81       	ldd	r31, Y+6	; 0x06
    4c9c:	80 81       	ld	r24, Z
    4c9e:	81 50       	subi	r24, 0x01	; 1
    4ca0:	ed 81       	ldd	r30, Y+5	; 0x05
    4ca2:	fe 81       	ldd	r31, Y+6	; 0x06
    4ca4:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    4ca6:	e9 85       	ldd	r30, Y+9	; 0x09
    4ca8:	fa 85       	ldd	r31, Y+10	; 0x0a
    4caa:	96 89       	ldd	r25, Z+22	; 0x16
    4cac:	80 91 ac 06 	lds	r24, 0x06AC
    4cb0:	89 17       	cp	r24, r25
    4cb2:	28 f4       	brcc	.+10     	; 0x4cbe <vTaskGenericNotifyGiveFromISR+0x146>
    4cb4:	e9 85       	ldd	r30, Y+9	; 0x09
    4cb6:	fa 85       	ldd	r31, Y+10	; 0x0a
    4cb8:	86 89       	ldd	r24, Z+22	; 0x16
    4cba:	80 93 ac 06 	sts	0x06AC, r24
    4cbe:	e9 85       	ldd	r30, Y+9	; 0x09
    4cc0:	fa 85       	ldd	r31, Y+10	; 0x0a
    4cc2:	86 89       	ldd	r24, Z+22	; 0x16
    4cc4:	28 2f       	mov	r18, r24
    4cc6:	30 e0       	ldi	r19, 0x00	; 0
    4cc8:	c9 01       	movw	r24, r18
    4cca:	88 0f       	add	r24, r24
    4ccc:	99 1f       	adc	r25, r25
    4cce:	88 0f       	add	r24, r24
    4cd0:	99 1f       	adc	r25, r25
    4cd2:	88 0f       	add	r24, r24
    4cd4:	99 1f       	adc	r25, r25
    4cd6:	82 0f       	add	r24, r18
    4cd8:	93 1f       	adc	r25, r19
    4cda:	fc 01       	movw	r30, r24
    4cdc:	e8 54       	subi	r30, 0x48	; 72
    4cde:	f9 4f       	sbci	r31, 0xF9	; 249
    4ce0:	81 81       	ldd	r24, Z+1	; 0x01
    4ce2:	92 81       	ldd	r25, Z+2	; 0x02
    4ce4:	9c 83       	std	Y+4, r25	; 0x04
    4ce6:	8b 83       	std	Y+3, r24	; 0x03
    4ce8:	e9 85       	ldd	r30, Y+9	; 0x09
    4cea:	fa 85       	ldd	r31, Y+10	; 0x0a
    4cec:	8b 81       	ldd	r24, Y+3	; 0x03
    4cee:	9c 81       	ldd	r25, Y+4	; 0x04
    4cf0:	95 83       	std	Z+5, r25	; 0x05
    4cf2:	84 83       	std	Z+4, r24	; 0x04
    4cf4:	eb 81       	ldd	r30, Y+3	; 0x03
    4cf6:	fc 81       	ldd	r31, Y+4	; 0x04
    4cf8:	84 81       	ldd	r24, Z+4	; 0x04
    4cfa:	95 81       	ldd	r25, Z+5	; 0x05
    4cfc:	e9 85       	ldd	r30, Y+9	; 0x09
    4cfe:	fa 85       	ldd	r31, Y+10	; 0x0a
    4d00:	97 83       	std	Z+7, r25	; 0x07
    4d02:	86 83       	std	Z+6, r24	; 0x06
    4d04:	eb 81       	ldd	r30, Y+3	; 0x03
    4d06:	fc 81       	ldd	r31, Y+4	; 0x04
    4d08:	04 80       	ldd	r0, Z+4	; 0x04
    4d0a:	f5 81       	ldd	r31, Z+5	; 0x05
    4d0c:	e0 2d       	mov	r30, r0
    4d0e:	89 85       	ldd	r24, Y+9	; 0x09
    4d10:	9a 85       	ldd	r25, Y+10	; 0x0a
    4d12:	02 96       	adiw	r24, 0x02	; 2
    4d14:	93 83       	std	Z+3, r25	; 0x03
    4d16:	82 83       	std	Z+2, r24	; 0x02
    4d18:	89 85       	ldd	r24, Y+9	; 0x09
    4d1a:	9a 85       	ldd	r25, Y+10	; 0x0a
    4d1c:	02 96       	adiw	r24, 0x02	; 2
    4d1e:	eb 81       	ldd	r30, Y+3	; 0x03
    4d20:	fc 81       	ldd	r31, Y+4	; 0x04
    4d22:	95 83       	std	Z+5, r25	; 0x05
    4d24:	84 83       	std	Z+4, r24	; 0x04
    4d26:	e9 85       	ldd	r30, Y+9	; 0x09
    4d28:	fa 85       	ldd	r31, Y+10	; 0x0a
    4d2a:	86 89       	ldd	r24, Z+22	; 0x16
    4d2c:	28 2f       	mov	r18, r24
    4d2e:	30 e0       	ldi	r19, 0x00	; 0
    4d30:	c9 01       	movw	r24, r18
    4d32:	88 0f       	add	r24, r24
    4d34:	99 1f       	adc	r25, r25
    4d36:	88 0f       	add	r24, r24
    4d38:	99 1f       	adc	r25, r25
    4d3a:	88 0f       	add	r24, r24
    4d3c:	99 1f       	adc	r25, r25
    4d3e:	82 0f       	add	r24, r18
    4d40:	93 1f       	adc	r25, r19
    4d42:	88 54       	subi	r24, 0x48	; 72
    4d44:	99 4f       	sbci	r25, 0xF9	; 249
    4d46:	e9 85       	ldd	r30, Y+9	; 0x09
    4d48:	fa 85       	ldd	r31, Y+10	; 0x0a
    4d4a:	93 87       	std	Z+11, r25	; 0x0b
    4d4c:	82 87       	std	Z+10, r24	; 0x0a
    4d4e:	e9 85       	ldd	r30, Y+9	; 0x09
    4d50:	fa 85       	ldd	r31, Y+10	; 0x0a
    4d52:	86 89       	ldd	r24, Z+22	; 0x16
    4d54:	28 2f       	mov	r18, r24
    4d56:	30 e0       	ldi	r19, 0x00	; 0
    4d58:	c9 01       	movw	r24, r18
    4d5a:	88 0f       	add	r24, r24
    4d5c:	99 1f       	adc	r25, r25
    4d5e:	88 0f       	add	r24, r24
    4d60:	99 1f       	adc	r25, r25
    4d62:	88 0f       	add	r24, r24
    4d64:	99 1f       	adc	r25, r25
    4d66:	82 0f       	add	r24, r18
    4d68:	93 1f       	adc	r25, r19
    4d6a:	fc 01       	movw	r30, r24
    4d6c:	e8 54       	subi	r30, 0x48	; 72
    4d6e:	f9 4f       	sbci	r31, 0xF9	; 249
    4d70:	80 81       	ld	r24, Z
    4d72:	8f 5f       	subi	r24, 0xFF	; 255
    4d74:	80 83       	st	Z, r24
    4d76:	30 c0       	rjmp	.+96     	; 0x4dd8 <vTaskGenericNotifyGiveFromISR+0x260>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4d78:	80 91 f3 06 	lds	r24, 0x06F3
    4d7c:	90 91 f4 06 	lds	r25, 0x06F4
    4d80:	9a 83       	std	Y+2, r25	; 0x02
    4d82:	89 83       	std	Y+1, r24	; 0x01
    4d84:	e9 85       	ldd	r30, Y+9	; 0x09
    4d86:	fa 85       	ldd	r31, Y+10	; 0x0a
    4d88:	89 81       	ldd	r24, Y+1	; 0x01
    4d8a:	9a 81       	ldd	r25, Y+2	; 0x02
    4d8c:	97 87       	std	Z+15, r25	; 0x0f
    4d8e:	86 87       	std	Z+14, r24	; 0x0e
    4d90:	e9 81       	ldd	r30, Y+1	; 0x01
    4d92:	fa 81       	ldd	r31, Y+2	; 0x02
    4d94:	84 81       	ldd	r24, Z+4	; 0x04
    4d96:	95 81       	ldd	r25, Z+5	; 0x05
    4d98:	e9 85       	ldd	r30, Y+9	; 0x09
    4d9a:	fa 85       	ldd	r31, Y+10	; 0x0a
    4d9c:	91 8b       	std	Z+17, r25	; 0x11
    4d9e:	80 8b       	std	Z+16, r24	; 0x10
    4da0:	e9 81       	ldd	r30, Y+1	; 0x01
    4da2:	fa 81       	ldd	r31, Y+2	; 0x02
    4da4:	04 80       	ldd	r0, Z+4	; 0x04
    4da6:	f5 81       	ldd	r31, Z+5	; 0x05
    4da8:	e0 2d       	mov	r30, r0
    4daa:	89 85       	ldd	r24, Y+9	; 0x09
    4dac:	9a 85       	ldd	r25, Y+10	; 0x0a
    4dae:	0c 96       	adiw	r24, 0x0c	; 12
    4db0:	93 83       	std	Z+3, r25	; 0x03
    4db2:	82 83       	std	Z+2, r24	; 0x02
    4db4:	89 85       	ldd	r24, Y+9	; 0x09
    4db6:	9a 85       	ldd	r25, Y+10	; 0x0a
    4db8:	0c 96       	adiw	r24, 0x0c	; 12
    4dba:	e9 81       	ldd	r30, Y+1	; 0x01
    4dbc:	fa 81       	ldd	r31, Y+2	; 0x02
    4dbe:	95 83       	std	Z+5, r25	; 0x05
    4dc0:	84 83       	std	Z+4, r24	; 0x04
    4dc2:	e9 85       	ldd	r30, Y+9	; 0x09
    4dc4:	fa 85       	ldd	r31, Y+10	; 0x0a
    4dc6:	82 ef       	ldi	r24, 0xF2	; 242
    4dc8:	96 e0       	ldi	r25, 0x06	; 6
    4dca:	95 8b       	std	Z+21, r25	; 0x15
    4dcc:	84 8b       	std	Z+20, r24	; 0x14
    4dce:	80 91 f2 06 	lds	r24, 0x06F2
    4dd2:	8f 5f       	subi	r24, 0xFF	; 255
    4dd4:	80 93 f2 06 	sts	0x06F2, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4dd8:	e9 85       	ldd	r30, Y+9	; 0x09
    4dda:	fa 85       	ldd	r31, Y+10	; 0x0a
    4ddc:	96 89       	ldd	r25, Z+22	; 0x16
    4dde:	e0 91 a6 06 	lds	r30, 0x06A6
    4de2:	f0 91 a7 06 	lds	r31, 0x06A7
    4de6:	86 89       	ldd	r24, Z+22	; 0x16
    4de8:	89 17       	cp	r24, r25
    4dea:	58 f4       	brcc	.+22     	; 0x4e02 <vTaskGenericNotifyGiveFromISR+0x28a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    4dec:	8e 85       	ldd	r24, Y+14	; 0x0e
    4dee:	9f 85       	ldd	r25, Y+15	; 0x0f
    4df0:	00 97       	sbiw	r24, 0x00	; 0
    4df2:	21 f0       	breq	.+8      	; 0x4dfc <vTaskGenericNotifyGiveFromISR+0x284>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    4df4:	ee 85       	ldd	r30, Y+14	; 0x0e
    4df6:	ff 85       	ldd	r31, Y+15	; 0x0f
    4df8:	81 e0       	ldi	r24, 0x01	; 1
    4dfa:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    4dfc:	81 e0       	ldi	r24, 0x01	; 1
    4dfe:	80 93 b0 06 	sts	0x06B0, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    4e02:	2f 96       	adiw	r28, 0x0f	; 15
    4e04:	0f b6       	in	r0, 0x3f	; 63
    4e06:	f8 94       	cli
    4e08:	de bf       	out	0x3e, r29	; 62
    4e0a:	0f be       	out	0x3f, r0	; 63
    4e0c:	cd bf       	out	0x3d, r28	; 61
    4e0e:	cf 91       	pop	r28
    4e10:	df 91       	pop	r29
    4e12:	1f 91       	pop	r17
    4e14:	0f 91       	pop	r16
    4e16:	08 95       	ret

00004e18 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    4e18:	df 93       	push	r29
    4e1a:	cf 93       	push	r28
    4e1c:	cd b7       	in	r28, 0x3d	; 61
    4e1e:	de b7       	in	r29, 0x3e	; 62
    4e20:	28 97       	sbiw	r28, 0x08	; 8
    4e22:	0f b6       	in	r0, 0x3f	; 63
    4e24:	f8 94       	cli
    4e26:	de bf       	out	0x3e, r29	; 62
    4e28:	0f be       	out	0x3f, r0	; 63
    4e2a:	cd bf       	out	0x3d, r28	; 61
    4e2c:	9d 83       	std	Y+5, r25	; 0x05
    4e2e:	8c 83       	std	Y+4, r24	; 0x04
    4e30:	6e 83       	std	Y+6, r22	; 0x06

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    4e32:	8c 81       	ldd	r24, Y+4	; 0x04
    4e34:	9d 81       	ldd	r25, Y+5	; 0x05
    4e36:	00 97       	sbiw	r24, 0x00	; 0
    4e38:	39 f4       	brne	.+14     	; 0x4e48 <xTaskGenericNotifyStateClear+0x30>
    4e3a:	80 91 a6 06 	lds	r24, 0x06A6
    4e3e:	90 91 a7 06 	lds	r25, 0x06A7
    4e42:	98 87       	std	Y+8, r25	; 0x08
    4e44:	8f 83       	std	Y+7, r24	; 0x07
    4e46:	04 c0       	rjmp	.+8      	; 0x4e50 <xTaskGenericNotifyStateClear+0x38>
    4e48:	8c 81       	ldd	r24, Y+4	; 0x04
    4e4a:	9d 81       	ldd	r25, Y+5	; 0x05
    4e4c:	98 87       	std	Y+8, r25	; 0x08
    4e4e:	8f 83       	std	Y+7, r24	; 0x07
    4e50:	8f 81       	ldd	r24, Y+7	; 0x07
    4e52:	98 85       	ldd	r25, Y+8	; 0x08
    4e54:	9b 83       	std	Y+3, r25	; 0x03
    4e56:	8a 83       	std	Y+2, r24	; 0x02

        taskENTER_CRITICAL();
    4e58:	0f b6       	in	r0, 0x3f	; 63
    4e5a:	f8 94       	cli
    4e5c:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    4e5e:	8e 81       	ldd	r24, Y+6	; 0x06
    4e60:	28 2f       	mov	r18, r24
    4e62:	30 e0       	ldi	r19, 0x00	; 0
    4e64:	8a 81       	ldd	r24, Y+2	; 0x02
    4e66:	9b 81       	ldd	r25, Y+3	; 0x03
    4e68:	82 0f       	add	r24, r18
    4e6a:	93 1f       	adc	r25, r19
    4e6c:	fc 01       	movw	r30, r24
    4e6e:	b5 96       	adiw	r30, 0x25	; 37
    4e70:	80 81       	ld	r24, Z
    4e72:	82 30       	cpi	r24, 0x02	; 2
    4e74:	69 f4       	brne	.+26     	; 0x4e90 <xTaskGenericNotifyStateClear+0x78>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    4e76:	8e 81       	ldd	r24, Y+6	; 0x06
    4e78:	28 2f       	mov	r18, r24
    4e7a:	30 e0       	ldi	r19, 0x00	; 0
    4e7c:	8a 81       	ldd	r24, Y+2	; 0x02
    4e7e:	9b 81       	ldd	r25, Y+3	; 0x03
    4e80:	82 0f       	add	r24, r18
    4e82:	93 1f       	adc	r25, r19
    4e84:	fc 01       	movw	r30, r24
    4e86:	b5 96       	adiw	r30, 0x25	; 37
    4e88:	10 82       	st	Z, r1
                xReturn = pdPASS;
    4e8a:	81 e0       	ldi	r24, 0x01	; 1
    4e8c:	89 83       	std	Y+1, r24	; 0x01
    4e8e:	01 c0       	rjmp	.+2      	; 0x4e92 <xTaskGenericNotifyStateClear+0x7a>
            }
            else
            {
                xReturn = pdFAIL;
    4e90:	19 82       	std	Y+1, r1	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    4e92:	0f 90       	pop	r0
    4e94:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    4e96:	89 81       	ldd	r24, Y+1	; 0x01
    }
    4e98:	28 96       	adiw	r28, 0x08	; 8
    4e9a:	0f b6       	in	r0, 0x3f	; 63
    4e9c:	f8 94       	cli
    4e9e:	de bf       	out	0x3e, r29	; 62
    4ea0:	0f be       	out	0x3f, r0	; 63
    4ea2:	cd bf       	out	0x3d, r28	; 61
    4ea4:	cf 91       	pop	r28
    4ea6:	df 91       	pop	r29
    4ea8:	08 95       	ret

00004eaa <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    4eaa:	0f 93       	push	r16
    4eac:	1f 93       	push	r17
    4eae:	df 93       	push	r29
    4eb0:	cf 93       	push	r28
    4eb2:	cd b7       	in	r28, 0x3d	; 61
    4eb4:	de b7       	in	r29, 0x3e	; 62
    4eb6:	2f 97       	sbiw	r28, 0x0f	; 15
    4eb8:	0f b6       	in	r0, 0x3f	; 63
    4eba:	f8 94       	cli
    4ebc:	de bf       	out	0x3e, r29	; 62
    4ebe:	0f be       	out	0x3f, r0	; 63
    4ec0:	cd bf       	out	0x3d, r28	; 61
    4ec2:	98 87       	std	Y+8, r25	; 0x08
    4ec4:	8f 83       	std	Y+7, r24	; 0x07
    4ec6:	69 87       	std	Y+9, r22	; 0x09
    4ec8:	2a 87       	std	Y+10, r18	; 0x0a
    4eca:	3b 87       	std	Y+11, r19	; 0x0b
    4ecc:	4c 87       	std	Y+12, r20	; 0x0c
    4ece:	5d 87       	std	Y+13, r21	; 0x0d
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    4ed0:	8f 81       	ldd	r24, Y+7	; 0x07
    4ed2:	98 85       	ldd	r25, Y+8	; 0x08
    4ed4:	00 97       	sbiw	r24, 0x00	; 0
    4ed6:	39 f4       	brne	.+14     	; 0x4ee6 <ulTaskGenericNotifyValueClear+0x3c>
    4ed8:	80 91 a6 06 	lds	r24, 0x06A6
    4edc:	90 91 a7 06 	lds	r25, 0x06A7
    4ee0:	9f 87       	std	Y+15, r25	; 0x0f
    4ee2:	8e 87       	std	Y+14, r24	; 0x0e
    4ee4:	04 c0       	rjmp	.+8      	; 0x4eee <ulTaskGenericNotifyValueClear+0x44>
    4ee6:	8f 81       	ldd	r24, Y+7	; 0x07
    4ee8:	98 85       	ldd	r25, Y+8	; 0x08
    4eea:	9f 87       	std	Y+15, r25	; 0x0f
    4eec:	8e 87       	std	Y+14, r24	; 0x0e
    4eee:	8e 85       	ldd	r24, Y+14	; 0x0e
    4ef0:	9f 85       	ldd	r25, Y+15	; 0x0f
    4ef2:	9e 83       	std	Y+6, r25	; 0x06
    4ef4:	8d 83       	std	Y+5, r24	; 0x05

        taskENTER_CRITICAL();
    4ef6:	0f b6       	in	r0, 0x3f	; 63
    4ef8:	f8 94       	cli
    4efa:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    4efc:	89 85       	ldd	r24, Y+9	; 0x09
    4efe:	88 2f       	mov	r24, r24
    4f00:	90 e0       	ldi	r25, 0x00	; 0
    4f02:	2d 81       	ldd	r18, Y+5	; 0x05
    4f04:	3e 81       	ldd	r19, Y+6	; 0x06
    4f06:	88 0f       	add	r24, r24
    4f08:	99 1f       	adc	r25, r25
    4f0a:	88 0f       	add	r24, r24
    4f0c:	99 1f       	adc	r25, r25
    4f0e:	82 0f       	add	r24, r18
    4f10:	93 1f       	adc	r25, r19
    4f12:	fc 01       	movw	r30, r24
    4f14:	b1 96       	adiw	r30, 0x21	; 33
    4f16:	80 81       	ld	r24, Z
    4f18:	91 81       	ldd	r25, Z+1	; 0x01
    4f1a:	a2 81       	ldd	r26, Z+2	; 0x02
    4f1c:	b3 81       	ldd	r27, Z+3	; 0x03
    4f1e:	89 83       	std	Y+1, r24	; 0x01
    4f20:	9a 83       	std	Y+2, r25	; 0x02
    4f22:	ab 83       	std	Y+3, r26	; 0x03
    4f24:	bc 83       	std	Y+4, r27	; 0x04
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    4f26:	89 85       	ldd	r24, Y+9	; 0x09
    4f28:	08 2f       	mov	r16, r24
    4f2a:	10 e0       	ldi	r17, 0x00	; 0
    4f2c:	89 85       	ldd	r24, Y+9	; 0x09
    4f2e:	88 2f       	mov	r24, r24
    4f30:	90 e0       	ldi	r25, 0x00	; 0
    4f32:	2d 81       	ldd	r18, Y+5	; 0x05
    4f34:	3e 81       	ldd	r19, Y+6	; 0x06
    4f36:	88 0f       	add	r24, r24
    4f38:	99 1f       	adc	r25, r25
    4f3a:	88 0f       	add	r24, r24
    4f3c:	99 1f       	adc	r25, r25
    4f3e:	82 0f       	add	r24, r18
    4f40:	93 1f       	adc	r25, r19
    4f42:	fc 01       	movw	r30, r24
    4f44:	b1 96       	adiw	r30, 0x21	; 33
    4f46:	20 81       	ld	r18, Z
    4f48:	31 81       	ldd	r19, Z+1	; 0x01
    4f4a:	42 81       	ldd	r20, Z+2	; 0x02
    4f4c:	53 81       	ldd	r21, Z+3	; 0x03
    4f4e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4f50:	9b 85       	ldd	r25, Y+11	; 0x0b
    4f52:	ac 85       	ldd	r26, Y+12	; 0x0c
    4f54:	bd 85       	ldd	r27, Y+13	; 0x0d
    4f56:	80 95       	com	r24
    4f58:	90 95       	com	r25
    4f5a:	a0 95       	com	r26
    4f5c:	b0 95       	com	r27
    4f5e:	ba 01       	movw	r22, r20
    4f60:	a9 01       	movw	r20, r18
    4f62:	48 23       	and	r20, r24
    4f64:	59 23       	and	r21, r25
    4f66:	6a 23       	and	r22, r26
    4f68:	7b 23       	and	r23, r27
    4f6a:	2d 81       	ldd	r18, Y+5	; 0x05
    4f6c:	3e 81       	ldd	r19, Y+6	; 0x06
    4f6e:	c8 01       	movw	r24, r16
    4f70:	88 0f       	add	r24, r24
    4f72:	99 1f       	adc	r25, r25
    4f74:	88 0f       	add	r24, r24
    4f76:	99 1f       	adc	r25, r25
    4f78:	82 0f       	add	r24, r18
    4f7a:	93 1f       	adc	r25, r19
    4f7c:	fc 01       	movw	r30, r24
    4f7e:	b1 96       	adiw	r30, 0x21	; 33
    4f80:	40 83       	st	Z, r20
    4f82:	51 83       	std	Z+1, r21	; 0x01
    4f84:	62 83       	std	Z+2, r22	; 0x02
    4f86:	73 83       	std	Z+3, r23	; 0x03
        }
        taskEXIT_CRITICAL();
    4f88:	0f 90       	pop	r0
    4f8a:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    4f8c:	89 81       	ldd	r24, Y+1	; 0x01
    4f8e:	9a 81       	ldd	r25, Y+2	; 0x02
    4f90:	ab 81       	ldd	r26, Y+3	; 0x03
    4f92:	bc 81       	ldd	r27, Y+4	; 0x04
    }
    4f94:	bc 01       	movw	r22, r24
    4f96:	cd 01       	movw	r24, r26
    4f98:	2f 96       	adiw	r28, 0x0f	; 15
    4f9a:	0f b6       	in	r0, 0x3f	; 63
    4f9c:	f8 94       	cli
    4f9e:	de bf       	out	0x3e, r29	; 62
    4fa0:	0f be       	out	0x3f, r0	; 63
    4fa2:	cd bf       	out	0x3d, r28	; 61
    4fa4:	cf 91       	pop	r28
    4fa6:	df 91       	pop	r29
    4fa8:	1f 91       	pop	r17
    4faa:	0f 91       	pop	r16
    4fac:	08 95       	ret

00004fae <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    4fae:	df 93       	push	r29
    4fb0:	cf 93       	push	r28
    4fb2:	cd b7       	in	r28, 0x3d	; 61
    4fb4:	de b7       	in	r29, 0x3e	; 62
    4fb6:	27 97       	sbiw	r28, 0x07	; 7
    4fb8:	0f b6       	in	r0, 0x3f	; 63
    4fba:	f8 94       	cli
    4fbc:	de bf       	out	0x3e, r29	; 62
    4fbe:	0f be       	out	0x3f, r0	; 63
    4fc0:	cd bf       	out	0x3d, r28	; 61
    4fc2:	9e 83       	std	Y+6, r25	; 0x06
    4fc4:	8d 83       	std	Y+5, r24	; 0x05
    4fc6:	6f 83       	std	Y+7, r22	; 0x07
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    4fc8:	80 91 aa 06 	lds	r24, 0x06AA
    4fcc:	90 91 ab 06 	lds	r25, 0x06AB
    4fd0:	9a 83       	std	Y+2, r25	; 0x02
    4fd2:	89 83       	std	Y+1, r24	; 0x01
        }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4fd4:	80 91 a6 06 	lds	r24, 0x06A6
    4fd8:	90 91 a7 06 	lds	r25, 0x06A7
    4fdc:	02 96       	adiw	r24, 0x02	; 2
    4fde:	0e 94 ab 0a 	call	0x1556	; 0x1556 <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
        {
            /* Calculate the time at which the task should be woken if the event
             * does not occur.  This may overflow but this doesn't matter, the kernel
             * will manage it correctly. */
            xTimeToWake = xConstTickCount + xTicksToWait;
    4fe2:	29 81       	ldd	r18, Y+1	; 0x01
    4fe4:	3a 81       	ldd	r19, Y+2	; 0x02
    4fe6:	8d 81       	ldd	r24, Y+5	; 0x05
    4fe8:	9e 81       	ldd	r25, Y+6	; 0x06
    4fea:	82 0f       	add	r24, r18
    4fec:	93 1f       	adc	r25, r19
    4fee:	9c 83       	std	Y+4, r25	; 0x04
    4ff0:	8b 83       	std	Y+3, r24	; 0x03

            /* The list item will be inserted in wake time order. */
            listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    4ff2:	e0 91 a6 06 	lds	r30, 0x06A6
    4ff6:	f0 91 a7 06 	lds	r31, 0x06A7
    4ffa:	8b 81       	ldd	r24, Y+3	; 0x03
    4ffc:	9c 81       	ldd	r25, Y+4	; 0x04
    4ffe:	93 83       	std	Z+3, r25	; 0x03
    5000:	82 83       	std	Z+2, r24	; 0x02

            if( xTimeToWake < xConstTickCount )
    5002:	2b 81       	ldd	r18, Y+3	; 0x03
    5004:	3c 81       	ldd	r19, Y+4	; 0x04
    5006:	89 81       	ldd	r24, Y+1	; 0x01
    5008:	9a 81       	ldd	r25, Y+2	; 0x02
    500a:	28 17       	cp	r18, r24
    500c:	39 07       	cpc	r19, r25
    500e:	70 f4       	brcc	.+28     	; 0x502c <prvAddCurrentTaskToDelayedList+0x7e>
            {
                /* Wake time has overflowed.  Place this item in the overflow list. */
                vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5010:	80 91 f0 06 	lds	r24, 0x06F0
    5014:	90 91 f1 06 	lds	r25, 0x06F1
    5018:	20 91 a6 06 	lds	r18, 0x06A6
    501c:	30 91 a7 06 	lds	r19, 0x06A7
    5020:	2e 5f       	subi	r18, 0xFE	; 254
    5022:	3f 4f       	sbci	r19, 0xFF	; 255
    5024:	b9 01       	movw	r22, r18
    5026:	0e 94 3f 0a 	call	0x147e	; 0x147e <vListInsert>
    502a:	1e c0       	rjmp	.+60     	; 0x5068 <prvAddCurrentTaskToDelayedList+0xba>
            }
            else
            {
                /* The wake time has not overflowed, so the current block list is used. */
                vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    502c:	40 91 ee 06 	lds	r20, 0x06EE
    5030:	50 91 ef 06 	lds	r21, 0x06EF
    5034:	80 91 a6 06 	lds	r24, 0x06A6
    5038:	90 91 a7 06 	lds	r25, 0x06A7
    503c:	9c 01       	movw	r18, r24
    503e:	2e 5f       	subi	r18, 0xFE	; 254
    5040:	3f 4f       	sbci	r19, 0xFF	; 255
    5042:	ca 01       	movw	r24, r20
    5044:	b9 01       	movw	r22, r18
    5046:	0e 94 3f 0a 	call	0x147e	; 0x147e <vListInsert>

                /* If the task entering the blocked state was placed at the head of the
                 * list of blocked tasks then xNextTaskUnblockTime needs to be updated
                 * too. */
                if( xTimeToWake < xNextTaskUnblockTime )
    504a:	20 91 b3 06 	lds	r18, 0x06B3
    504e:	30 91 b4 06 	lds	r19, 0x06B4
    5052:	8b 81       	ldd	r24, Y+3	; 0x03
    5054:	9c 81       	ldd	r25, Y+4	; 0x04
    5056:	82 17       	cp	r24, r18
    5058:	93 07       	cpc	r25, r19
    505a:	30 f4       	brcc	.+12     	; 0x5068 <prvAddCurrentTaskToDelayedList+0xba>
                {
                    xNextTaskUnblockTime = xTimeToWake;
    505c:	8b 81       	ldd	r24, Y+3	; 0x03
    505e:	9c 81       	ldd	r25, Y+4	; 0x04
    5060:	90 93 b4 06 	sts	0x06B4, r25
    5064:	80 93 b3 06 	sts	0x06B3, r24

            /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
            ( void ) xCanBlockIndefinitely;
        }
    #endif /* INCLUDE_vTaskSuspend */
}
    5068:	27 96       	adiw	r28, 0x07	; 7
    506a:	0f b6       	in	r0, 0x3f	; 63
    506c:	f8 94       	cli
    506e:	de bf       	out	0x3e, r29	; 62
    5070:	0f be       	out	0x3f, r0	; 63
    5072:	cd bf       	out	0x3d, r28	; 61
    5074:	cf 91       	pop	r28
    5076:	df 91       	pop	r29
    5078:	08 95       	ret

0000507a <xTimerCreateTimerTask>:
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

    BaseType_t xTimerCreateTimerTask( void )
    {
    507a:	ef 92       	push	r14
    507c:	ff 92       	push	r15
    507e:	0f 93       	push	r16
    5080:	df 93       	push	r29
    5082:	cf 93       	push	r28
    5084:	0f 92       	push	r0
    5086:	cd b7       	in	r28, 0x3d	; 61
    5088:	de b7       	in	r29, 0x3e	; 62
        BaseType_t xReturn = pdFAIL;
    508a:	19 82       	std	Y+1, r1	; 0x01

        /* This function is called when the scheduler is started if
         * configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
         * timer service task has been created/initialised.  If timers have already
         * been created then the initialisation will already have been performed. */
        prvCheckForValidListAndQueue();
    508c:	0e 94 fc 2c 	call	0x59f8	; 0x59f8 <prvCheckForValidListAndQueue>

        if( xTimerQueue != NULL )
    5090:	80 91 04 07 	lds	r24, 0x0704
    5094:	90 91 05 07 	lds	r25, 0x0705
    5098:	00 97       	sbiw	r24, 0x00	; 0
    509a:	81 f0       	breq	.+32     	; 0x50bc <xTimerCreateTimerTask+0x42>
                        xReturn = pdPASS;
                    }
                }
            #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
                {
                    xReturn = xTaskCreate( prvTimerTask,
    509c:	8e e8       	ldi	r24, 0x8E	; 142
    509e:	9a e2       	ldi	r25, 0x2A	; 42
    50a0:	25 e6       	ldi	r18, 0x65	; 101
    50a2:	30 e0       	ldi	r19, 0x00	; 0
    50a4:	e6 e0       	ldi	r30, 0x06	; 6
    50a6:	f7 e0       	ldi	r31, 0x07	; 7
    50a8:	b9 01       	movw	r22, r18
    50aa:	45 e5       	ldi	r20, 0x55	; 85
    50ac:	50 e0       	ldi	r21, 0x00	; 0
    50ae:	20 e0       	ldi	r18, 0x00	; 0
    50b0:	30 e0       	ldi	r19, 0x00	; 0
    50b2:	03 e0       	ldi	r16, 0x03	; 3
    50b4:	7f 01       	movw	r14, r30
    50b6:	0e 94 4d 14 	call	0x289a	; 0x289a <xTaskCreate>
    50ba:	89 83       	std	Y+1, r24	; 0x01
        {
            mtCOVERAGE_TEST_MARKER();
        }

        configASSERT( xReturn );
        return xReturn;
    50bc:	89 81       	ldd	r24, Y+1	; 0x01
    }
    50be:	0f 90       	pop	r0
    50c0:	cf 91       	pop	r28
    50c2:	df 91       	pop	r29
    50c4:	0f 91       	pop	r16
    50c6:	ff 90       	pop	r15
    50c8:	ef 90       	pop	r14
    50ca:	08 95       	ret

000050cc <xTimerCreate>:
        TimerHandle_t xTimerCreate( const char * const pcTimerName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                                    const TickType_t xTimerPeriodInTicks,
                                    const UBaseType_t uxAutoReload,
                                    void * const pvTimerID,
                                    TimerCallbackFunction_t pxCallbackFunction )
        {
    50cc:	ef 92       	push	r14
    50ce:	ff 92       	push	r15
    50d0:	0f 93       	push	r16
    50d2:	1f 93       	push	r17
    50d4:	df 93       	push	r29
    50d6:	cf 93       	push	r28
    50d8:	cd b7       	in	r28, 0x3d	; 61
    50da:	de b7       	in	r29, 0x3e	; 62
    50dc:	2b 97       	sbiw	r28, 0x0b	; 11
    50de:	0f b6       	in	r0, 0x3f	; 63
    50e0:	f8 94       	cli
    50e2:	de bf       	out	0x3e, r29	; 62
    50e4:	0f be       	out	0x3f, r0	; 63
    50e6:	cd bf       	out	0x3d, r28	; 61
    50e8:	9c 83       	std	Y+4, r25	; 0x04
    50ea:	8b 83       	std	Y+3, r24	; 0x03
    50ec:	7e 83       	std	Y+6, r23	; 0x06
    50ee:	6d 83       	std	Y+5, r22	; 0x05
    50f0:	4f 83       	std	Y+7, r20	; 0x07
    50f2:	39 87       	std	Y+9, r19	; 0x09
    50f4:	28 87       	std	Y+8, r18	; 0x08
    50f6:	1b 87       	std	Y+11, r17	; 0x0b
    50f8:	0a 87       	std	Y+10, r16	; 0x0a
            Timer_t * pxNewTimer;

            pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
    50fa:	83 e1       	ldi	r24, 0x13	; 19
    50fc:	90 e0       	ldi	r25, 0x00	; 0
    50fe:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    5102:	9a 83       	std	Y+2, r25	; 0x02
    5104:	89 83       	std	Y+1, r24	; 0x01

            if( pxNewTimer != NULL )
    5106:	89 81       	ldd	r24, Y+1	; 0x01
    5108:	9a 81       	ldd	r25, Y+2	; 0x02
    510a:	00 97       	sbiw	r24, 0x00	; 0
    510c:	99 f0       	breq	.+38     	; 0x5134 <xTimerCreate+0x68>
            {
                /* Status is thus far zero as the timer is not created statically
                 * and has not been started.  The auto-reload bit may get set in
                 * prvInitialiseNewTimer. */
                pxNewTimer->ucStatus = 0x00;
    510e:	e9 81       	ldd	r30, Y+1	; 0x01
    5110:	fa 81       	ldd	r31, Y+2	; 0x02
    5112:	12 8a       	std	Z+18, r1	; 0x12
                prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
    5114:	8b 81       	ldd	r24, Y+3	; 0x03
    5116:	9c 81       	ldd	r25, Y+4	; 0x04
    5118:	2d 81       	ldd	r18, Y+5	; 0x05
    511a:	3e 81       	ldd	r19, Y+6	; 0x06
    511c:	e8 85       	ldd	r30, Y+8	; 0x08
    511e:	f9 85       	ldd	r31, Y+9	; 0x09
    5120:	aa 85       	ldd	r26, Y+10	; 0x0a
    5122:	bb 85       	ldd	r27, Y+11	; 0x0b
    5124:	e9 80       	ldd	r14, Y+1	; 0x01
    5126:	fa 80       	ldd	r15, Y+2	; 0x02
    5128:	b9 01       	movw	r22, r18
    512a:	4f 81       	ldd	r20, Y+7	; 0x07
    512c:	9f 01       	movw	r18, r30
    512e:	8d 01       	movw	r16, r26
    5130:	0e 94 a9 28 	call	0x5152	; 0x5152 <prvInitialiseNewTimer>
            }

            return pxNewTimer;
    5134:	89 81       	ldd	r24, Y+1	; 0x01
    5136:	9a 81       	ldd	r25, Y+2	; 0x02
        }
    5138:	2b 96       	adiw	r28, 0x0b	; 11
    513a:	0f b6       	in	r0, 0x3f	; 63
    513c:	f8 94       	cli
    513e:	de bf       	out	0x3e, r29	; 62
    5140:	0f be       	out	0x3f, r0	; 63
    5142:	cd bf       	out	0x3d, r28	; 61
    5144:	cf 91       	pop	r28
    5146:	df 91       	pop	r29
    5148:	1f 91       	pop	r17
    514a:	0f 91       	pop	r16
    514c:	ff 90       	pop	r15
    514e:	ef 90       	pop	r14
    5150:	08 95       	ret

00005152 <prvInitialiseNewTimer>:
                                       const TickType_t xTimerPeriodInTicks,
                                       const UBaseType_t uxAutoReload,
                                       void * const pvTimerID,
                                       TimerCallbackFunction_t pxCallbackFunction,
                                       Timer_t * pxNewTimer )
    {
    5152:	ef 92       	push	r14
    5154:	ff 92       	push	r15
    5156:	0f 93       	push	r16
    5158:	1f 93       	push	r17
    515a:	df 93       	push	r29
    515c:	cf 93       	push	r28
    515e:	cd b7       	in	r28, 0x3d	; 61
    5160:	de b7       	in	r29, 0x3e	; 62
    5162:	2b 97       	sbiw	r28, 0x0b	; 11
    5164:	0f b6       	in	r0, 0x3f	; 63
    5166:	f8 94       	cli
    5168:	de bf       	out	0x3e, r29	; 62
    516a:	0f be       	out	0x3f, r0	; 63
    516c:	cd bf       	out	0x3d, r28	; 61
    516e:	9a 83       	std	Y+2, r25	; 0x02
    5170:	89 83       	std	Y+1, r24	; 0x01
    5172:	7c 83       	std	Y+4, r23	; 0x04
    5174:	6b 83       	std	Y+3, r22	; 0x03
    5176:	4d 83       	std	Y+5, r20	; 0x05
    5178:	3f 83       	std	Y+7, r19	; 0x07
    517a:	2e 83       	std	Y+6, r18	; 0x06
    517c:	19 87       	std	Y+9, r17	; 0x09
    517e:	08 87       	std	Y+8, r16	; 0x08
    5180:	fb 86       	std	Y+11, r15	; 0x0b
    5182:	ea 86       	std	Y+10, r14	; 0x0a
        /* 0 is not a valid value for xTimerPeriodInTicks. */
        configASSERT( ( xTimerPeriodInTicks > 0 ) );

        /* Ensure the infrastructure used by the timer service task has been
         * created/initialised. */
        prvCheckForValidListAndQueue();
    5184:	0e 94 fc 2c 	call	0x59f8	; 0x59f8 <prvCheckForValidListAndQueue>

        /* Initialise the timer structure members using the function
         * parameters. */
        pxNewTimer->pcTimerName = pcTimerName;
    5188:	ea 85       	ldd	r30, Y+10	; 0x0a
    518a:	fb 85       	ldd	r31, Y+11	; 0x0b
    518c:	89 81       	ldd	r24, Y+1	; 0x01
    518e:	9a 81       	ldd	r25, Y+2	; 0x02
    5190:	91 83       	std	Z+1, r25	; 0x01
    5192:	80 83       	st	Z, r24
        pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    5194:	ea 85       	ldd	r30, Y+10	; 0x0a
    5196:	fb 85       	ldd	r31, Y+11	; 0x0b
    5198:	8b 81       	ldd	r24, Y+3	; 0x03
    519a:	9c 81       	ldd	r25, Y+4	; 0x04
    519c:	95 87       	std	Z+13, r25	; 0x0d
    519e:	84 87       	std	Z+12, r24	; 0x0c
        pxNewTimer->pvTimerID = pvTimerID;
    51a0:	ea 85       	ldd	r30, Y+10	; 0x0a
    51a2:	fb 85       	ldd	r31, Y+11	; 0x0b
    51a4:	8e 81       	ldd	r24, Y+6	; 0x06
    51a6:	9f 81       	ldd	r25, Y+7	; 0x07
    51a8:	97 87       	std	Z+15, r25	; 0x0f
    51aa:	86 87       	std	Z+14, r24	; 0x0e
        pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    51ac:	ea 85       	ldd	r30, Y+10	; 0x0a
    51ae:	fb 85       	ldd	r31, Y+11	; 0x0b
    51b0:	88 85       	ldd	r24, Y+8	; 0x08
    51b2:	99 85       	ldd	r25, Y+9	; 0x09
    51b4:	91 8b       	std	Z+17, r25	; 0x11
    51b6:	80 8b       	std	Z+16, r24	; 0x10
        vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    51b8:	8a 85       	ldd	r24, Y+10	; 0x0a
    51ba:	9b 85       	ldd	r25, Y+11	; 0x0b
    51bc:	02 96       	adiw	r24, 0x02	; 2
    51be:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <vListInitialiseItem>

        if( uxAutoReload != pdFALSE )
    51c2:	8d 81       	ldd	r24, Y+5	; 0x05
    51c4:	88 23       	and	r24, r24
    51c6:	39 f0       	breq	.+14     	; 0x51d6 <prvInitialiseNewTimer+0x84>
        {
            pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    51c8:	ea 85       	ldd	r30, Y+10	; 0x0a
    51ca:	fb 85       	ldd	r31, Y+11	; 0x0b
    51cc:	82 89       	ldd	r24, Z+18	; 0x12
    51ce:	84 60       	ori	r24, 0x04	; 4
    51d0:	ea 85       	ldd	r30, Y+10	; 0x0a
    51d2:	fb 85       	ldd	r31, Y+11	; 0x0b
    51d4:	82 8b       	std	Z+18, r24	; 0x12
        }

        traceTIMER_CREATE( pxNewTimer );
    }
    51d6:	2b 96       	adiw	r28, 0x0b	; 11
    51d8:	0f b6       	in	r0, 0x3f	; 63
    51da:	f8 94       	cli
    51dc:	de bf       	out	0x3e, r29	; 62
    51de:	0f be       	out	0x3f, r0	; 63
    51e0:	cd bf       	out	0x3d, r28	; 61
    51e2:	cf 91       	pop	r28
    51e4:	df 91       	pop	r29
    51e6:	1f 91       	pop	r17
    51e8:	0f 91       	pop	r16
    51ea:	ff 90       	pop	r15
    51ec:	ef 90       	pop	r14
    51ee:	08 95       	ret

000051f0 <xTimerGenericCommand>:
    BaseType_t xTimerGenericCommand( TimerHandle_t xTimer,
                                     const BaseType_t xCommandID,
                                     const TickType_t xOptionalValue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const TickType_t xTicksToWait )
    {
    51f0:	0f 93       	push	r16
    51f2:	1f 93       	push	r17
    51f4:	df 93       	push	r29
    51f6:	cf 93       	push	r28
    51f8:	cd b7       	in	r28, 0x3d	; 61
    51fa:	de b7       	in	r29, 0x3e	; 62
    51fc:	2f 97       	sbiw	r28, 0x0f	; 15
    51fe:	0f b6       	in	r0, 0x3f	; 63
    5200:	f8 94       	cli
    5202:	de bf       	out	0x3e, r29	; 62
    5204:	0f be       	out	0x3f, r0	; 63
    5206:	cd bf       	out	0x3d, r28	; 61
    5208:	98 87       	std	Y+8, r25	; 0x08
    520a:	8f 83       	std	Y+7, r24	; 0x07
    520c:	69 87       	std	Y+9, r22	; 0x09
    520e:	5b 87       	std	Y+11, r21	; 0x0b
    5210:	4a 87       	std	Y+10, r20	; 0x0a
    5212:	3d 87       	std	Y+13, r19	; 0x0d
    5214:	2c 87       	std	Y+12, r18	; 0x0c
    5216:	1f 87       	std	Y+15, r17	; 0x0f
    5218:	0e 87       	std	Y+14, r16	; 0x0e
        BaseType_t xReturn = pdFAIL;
    521a:	19 82       	std	Y+1, r1	; 0x01

        configASSERT( xTimer );

        /* Send a message to the timer service task to perform a particular action
         * on a particular timer definition. */
        if( xTimerQueue != NULL )
    521c:	80 91 04 07 	lds	r24, 0x0704
    5220:	90 91 05 07 	lds	r25, 0x0705
    5224:	00 97       	sbiw	r24, 0x00	; 0
    5226:	e9 f1       	breq	.+122    	; 0x52a2 <xTimerGenericCommand+0xb2>
        {
            /* Send a command to the timer service task to start the xTimer timer. */
            xMessage.xMessageID = xCommandID;
    5228:	89 85       	ldd	r24, Y+9	; 0x09
    522a:	8a 83       	std	Y+2, r24	; 0x02
            xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    522c:	8a 85       	ldd	r24, Y+10	; 0x0a
    522e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5230:	9c 83       	std	Y+4, r25	; 0x04
    5232:	8b 83       	std	Y+3, r24	; 0x03
            xMessage.u.xTimerParameters.pxTimer = xTimer;
    5234:	8f 81       	ldd	r24, Y+7	; 0x07
    5236:	98 85       	ldd	r25, Y+8	; 0x08
    5238:	9e 83       	std	Y+6, r25	; 0x06
    523a:	8d 83       	std	Y+5, r24	; 0x05

            if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    523c:	89 85       	ldd	r24, Y+9	; 0x09
    523e:	86 30       	cpi	r24, 0x06	; 6
    5240:	14 f5       	brge	.+68     	; 0x5286 <xTimerGenericCommand+0x96>
            {
                if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    5242:	0e 94 12 20 	call	0x4024	; 0x4024 <xTaskGetSchedulerState>
    5246:	82 30       	cpi	r24, 0x02	; 2
    5248:	79 f4       	brne	.+30     	; 0x5268 <xTimerGenericCommand+0x78>
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    524a:	80 91 04 07 	lds	r24, 0x0704
    524e:	90 91 05 07 	lds	r25, 0x0705
    5252:	9e 01       	movw	r18, r28
    5254:	2e 5f       	subi	r18, 0xFE	; 254
    5256:	3f 4f       	sbci	r19, 0xFF	; 255
    5258:	4e 85       	ldd	r20, Y+14	; 0x0e
    525a:	5f 85       	ldd	r21, Y+15	; 0x0f
    525c:	b9 01       	movw	r22, r18
    525e:	20 e0       	ldi	r18, 0x00	; 0
    5260:	0e 94 51 0c 	call	0x18a2	; 0x18a2 <xQueueGenericSend>
    5264:	89 83       	std	Y+1, r24	; 0x01
    5266:	1d c0       	rjmp	.+58     	; 0x52a2 <xTimerGenericCommand+0xb2>
                }
                else
                {
                    xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    5268:	80 91 04 07 	lds	r24, 0x0704
    526c:	90 91 05 07 	lds	r25, 0x0705
    5270:	9e 01       	movw	r18, r28
    5272:	2e 5f       	subi	r18, 0xFE	; 254
    5274:	3f 4f       	sbci	r19, 0xFF	; 255
    5276:	b9 01       	movw	r22, r18
    5278:	40 e0       	ldi	r20, 0x00	; 0
    527a:	50 e0       	ldi	r21, 0x00	; 0
    527c:	20 e0       	ldi	r18, 0x00	; 0
    527e:	0e 94 51 0c 	call	0x18a2	; 0x18a2 <xQueueGenericSend>
    5282:	89 83       	std	Y+1, r24	; 0x01
    5284:	0e c0       	rjmp	.+28     	; 0x52a2 <xTimerGenericCommand+0xb2>
                }
            }
            else
            {
                xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    5286:	80 91 04 07 	lds	r24, 0x0704
    528a:	90 91 05 07 	lds	r25, 0x0705
    528e:	9e 01       	movw	r18, r28
    5290:	2e 5f       	subi	r18, 0xFE	; 254
    5292:	3f 4f       	sbci	r19, 0xFF	; 255
    5294:	4c 85       	ldd	r20, Y+12	; 0x0c
    5296:	5d 85       	ldd	r21, Y+13	; 0x0d
    5298:	b9 01       	movw	r22, r18
    529a:	20 e0       	ldi	r18, 0x00	; 0
    529c:	0e 94 fd 0c 	call	0x19fa	; 0x19fa <xQueueGenericSendFromISR>
    52a0:	89 83       	std	Y+1, r24	; 0x01
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xReturn;
    52a2:	89 81       	ldd	r24, Y+1	; 0x01
    }
    52a4:	2f 96       	adiw	r28, 0x0f	; 15
    52a6:	0f b6       	in	r0, 0x3f	; 63
    52a8:	f8 94       	cli
    52aa:	de bf       	out	0x3e, r29	; 62
    52ac:	0f be       	out	0x3f, r0	; 63
    52ae:	cd bf       	out	0x3d, r28	; 61
    52b0:	cf 91       	pop	r28
    52b2:	df 91       	pop	r29
    52b4:	1f 91       	pop	r17
    52b6:	0f 91       	pop	r16
    52b8:	08 95       	ret

000052ba <xTimerGetTimerDaemonTaskHandle>:
/*-----------------------------------------------------------*/

    TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
    {
    52ba:	df 93       	push	r29
    52bc:	cf 93       	push	r28
    52be:	cd b7       	in	r28, 0x3d	; 61
    52c0:	de b7       	in	r29, 0x3e	; 62
        /* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
         * started, then xTimerTaskHandle will be NULL. */
        configASSERT( ( xTimerTaskHandle != NULL ) );
        return xTimerTaskHandle;
    52c2:	80 91 06 07 	lds	r24, 0x0706
    52c6:	90 91 07 07 	lds	r25, 0x0707
    }
    52ca:	cf 91       	pop	r28
    52cc:	df 91       	pop	r29
    52ce:	08 95       	ret

000052d0 <xTimerGetPeriod>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetPeriod( TimerHandle_t xTimer )
    {
    52d0:	df 93       	push	r29
    52d2:	cf 93       	push	r28
    52d4:	00 d0       	rcall	.+0      	; 0x52d6 <xTimerGetPeriod+0x6>
    52d6:	00 d0       	rcall	.+0      	; 0x52d8 <xTimerGetPeriod+0x8>
    52d8:	cd b7       	in	r28, 0x3d	; 61
    52da:	de b7       	in	r29, 0x3e	; 62
    52dc:	9c 83       	std	Y+4, r25	; 0x04
    52de:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    52e0:	8b 81       	ldd	r24, Y+3	; 0x03
    52e2:	9c 81       	ldd	r25, Y+4	; 0x04
    52e4:	9a 83       	std	Y+2, r25	; 0x02
    52e6:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->xTimerPeriodInTicks;
    52e8:	e9 81       	ldd	r30, Y+1	; 0x01
    52ea:	fa 81       	ldd	r31, Y+2	; 0x02
    52ec:	84 85       	ldd	r24, Z+12	; 0x0c
    52ee:	95 85       	ldd	r25, Z+13	; 0x0d
    }
    52f0:	0f 90       	pop	r0
    52f2:	0f 90       	pop	r0
    52f4:	0f 90       	pop	r0
    52f6:	0f 90       	pop	r0
    52f8:	cf 91       	pop	r28
    52fa:	df 91       	pop	r29
    52fc:	08 95       	ret

000052fe <vTimerSetReloadMode>:
/*-----------------------------------------------------------*/

    void vTimerSetReloadMode( TimerHandle_t xTimer,
                              const UBaseType_t uxAutoReload )
    {
    52fe:	df 93       	push	r29
    5300:	cf 93       	push	r28
    5302:	00 d0       	rcall	.+0      	; 0x5304 <vTimerSetReloadMode+0x6>
    5304:	00 d0       	rcall	.+0      	; 0x5306 <vTimerSetReloadMode+0x8>
    5306:	0f 92       	push	r0
    5308:	cd b7       	in	r28, 0x3d	; 61
    530a:	de b7       	in	r29, 0x3e	; 62
    530c:	9c 83       	std	Y+4, r25	; 0x04
    530e:	8b 83       	std	Y+3, r24	; 0x03
    5310:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * pxTimer = xTimer;
    5312:	8b 81       	ldd	r24, Y+3	; 0x03
    5314:	9c 81       	ldd	r25, Y+4	; 0x04
    5316:	9a 83       	std	Y+2, r25	; 0x02
    5318:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    531a:	0f b6       	in	r0, 0x3f	; 63
    531c:	f8 94       	cli
    531e:	0f 92       	push	r0
        {
            if( uxAutoReload != pdFALSE )
    5320:	8d 81       	ldd	r24, Y+5	; 0x05
    5322:	88 23       	and	r24, r24
    5324:	41 f0       	breq	.+16     	; 0x5336 <vTimerSetReloadMode+0x38>
            {
                pxTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    5326:	e9 81       	ldd	r30, Y+1	; 0x01
    5328:	fa 81       	ldd	r31, Y+2	; 0x02
    532a:	82 89       	ldd	r24, Z+18	; 0x12
    532c:	84 60       	ori	r24, 0x04	; 4
    532e:	e9 81       	ldd	r30, Y+1	; 0x01
    5330:	fa 81       	ldd	r31, Y+2	; 0x02
    5332:	82 8b       	std	Z+18, r24	; 0x12
    5334:	07 c0       	rjmp	.+14     	; 0x5344 <vTimerSetReloadMode+0x46>
            }
            else
            {
                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_AUTORELOAD );
    5336:	e9 81       	ldd	r30, Y+1	; 0x01
    5338:	fa 81       	ldd	r31, Y+2	; 0x02
    533a:	82 89       	ldd	r24, Z+18	; 0x12
    533c:	8b 7f       	andi	r24, 0xFB	; 251
    533e:	e9 81       	ldd	r30, Y+1	; 0x01
    5340:	fa 81       	ldd	r31, Y+2	; 0x02
    5342:	82 8b       	std	Z+18, r24	; 0x12
            }
        }
        taskEXIT_CRITICAL();
    5344:	0f 90       	pop	r0
    5346:	0f be       	out	0x3f, r0	; 63
    }
    5348:	0f 90       	pop	r0
    534a:	0f 90       	pop	r0
    534c:	0f 90       	pop	r0
    534e:	0f 90       	pop	r0
    5350:	0f 90       	pop	r0
    5352:	cf 91       	pop	r28
    5354:	df 91       	pop	r29
    5356:	08 95       	ret

00005358 <uxTimerGetReloadMode>:
/*-----------------------------------------------------------*/

    UBaseType_t uxTimerGetReloadMode( TimerHandle_t xTimer )
    {
    5358:	df 93       	push	r29
    535a:	cf 93       	push	r28
    535c:	00 d0       	rcall	.+0      	; 0x535e <uxTimerGetReloadMode+0x6>
    535e:	00 d0       	rcall	.+0      	; 0x5360 <uxTimerGetReloadMode+0x8>
    5360:	0f 92       	push	r0
    5362:	cd b7       	in	r28, 0x3d	; 61
    5364:	de b7       	in	r29, 0x3e	; 62
    5366:	9d 83       	std	Y+5, r25	; 0x05
    5368:	8c 83       	std	Y+4, r24	; 0x04
        Timer_t * pxTimer = xTimer;
    536a:	8c 81       	ldd	r24, Y+4	; 0x04
    536c:	9d 81       	ldd	r25, Y+5	; 0x05
    536e:	9b 83       	std	Y+3, r25	; 0x03
    5370:	8a 83       	std	Y+2, r24	; 0x02
        UBaseType_t uxReturn;

        configASSERT( xTimer );
        taskENTER_CRITICAL();
    5372:	0f b6       	in	r0, 0x3f	; 63
    5374:	f8 94       	cli
    5376:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) == 0 )
    5378:	ea 81       	ldd	r30, Y+2	; 0x02
    537a:	fb 81       	ldd	r31, Y+3	; 0x03
    537c:	82 89       	ldd	r24, Z+18	; 0x12
    537e:	88 2f       	mov	r24, r24
    5380:	90 e0       	ldi	r25, 0x00	; 0
    5382:	84 70       	andi	r24, 0x04	; 4
    5384:	90 70       	andi	r25, 0x00	; 0
    5386:	00 97       	sbiw	r24, 0x00	; 0
    5388:	11 f4       	brne	.+4      	; 0x538e <uxTimerGetReloadMode+0x36>
            {
                /* Not an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdFALSE;
    538a:	19 82       	std	Y+1, r1	; 0x01
    538c:	02 c0       	rjmp	.+4      	; 0x5392 <uxTimerGetReloadMode+0x3a>
            }
            else
            {
                /* Is an auto-reload timer. */
                uxReturn = ( UBaseType_t ) pdTRUE;
    538e:	81 e0       	ldi	r24, 0x01	; 1
    5390:	89 83       	std	Y+1, r24	; 0x01
            }
        }
        taskEXIT_CRITICAL();
    5392:	0f 90       	pop	r0
    5394:	0f be       	out	0x3f, r0	; 63

        return uxReturn;
    5396:	89 81       	ldd	r24, Y+1	; 0x01
    }
    5398:	0f 90       	pop	r0
    539a:	0f 90       	pop	r0
    539c:	0f 90       	pop	r0
    539e:	0f 90       	pop	r0
    53a0:	0f 90       	pop	r0
    53a2:	cf 91       	pop	r28
    53a4:	df 91       	pop	r29
    53a6:	08 95       	ret

000053a8 <xTimerGetExpiryTime>:
/*-----------------------------------------------------------*/

    TickType_t xTimerGetExpiryTime( TimerHandle_t xTimer )
    {
    53a8:	df 93       	push	r29
    53aa:	cf 93       	push	r28
    53ac:	00 d0       	rcall	.+0      	; 0x53ae <xTimerGetExpiryTime+0x6>
    53ae:	00 d0       	rcall	.+0      	; 0x53b0 <xTimerGetExpiryTime+0x8>
    53b0:	00 d0       	rcall	.+0      	; 0x53b2 <xTimerGetExpiryTime+0xa>
    53b2:	cd b7       	in	r28, 0x3d	; 61
    53b4:	de b7       	in	r29, 0x3e	; 62
    53b6:	9e 83       	std	Y+6, r25	; 0x06
    53b8:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * pxTimer = xTimer;
    53ba:	8d 81       	ldd	r24, Y+5	; 0x05
    53bc:	9e 81       	ldd	r25, Y+6	; 0x06
    53be:	9c 83       	std	Y+4, r25	; 0x04
    53c0:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xReturn;

        configASSERT( xTimer );
        xReturn = listGET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ) );
    53c2:	eb 81       	ldd	r30, Y+3	; 0x03
    53c4:	fc 81       	ldd	r31, Y+4	; 0x04
    53c6:	82 81       	ldd	r24, Z+2	; 0x02
    53c8:	93 81       	ldd	r25, Z+3	; 0x03
    53ca:	9a 83       	std	Y+2, r25	; 0x02
    53cc:	89 83       	std	Y+1, r24	; 0x01
        return xReturn;
    53ce:	89 81       	ldd	r24, Y+1	; 0x01
    53d0:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    53d2:	26 96       	adiw	r28, 0x06	; 6
    53d4:	0f b6       	in	r0, 0x3f	; 63
    53d6:	f8 94       	cli
    53d8:	de bf       	out	0x3e, r29	; 62
    53da:	0f be       	out	0x3f, r0	; 63
    53dc:	cd bf       	out	0x3d, r28	; 61
    53de:	cf 91       	pop	r28
    53e0:	df 91       	pop	r29
    53e2:	08 95       	ret

000053e4 <pcTimerGetName>:
/*-----------------------------------------------------------*/

    const char * pcTimerGetName( TimerHandle_t xTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    {
    53e4:	df 93       	push	r29
    53e6:	cf 93       	push	r28
    53e8:	00 d0       	rcall	.+0      	; 0x53ea <pcTimerGetName+0x6>
    53ea:	00 d0       	rcall	.+0      	; 0x53ec <pcTimerGetName+0x8>
    53ec:	cd b7       	in	r28, 0x3d	; 61
    53ee:	de b7       	in	r29, 0x3e	; 62
    53f0:	9c 83       	std	Y+4, r25	; 0x04
    53f2:	8b 83       	std	Y+3, r24	; 0x03
        Timer_t * pxTimer = xTimer;
    53f4:	8b 81       	ldd	r24, Y+3	; 0x03
    53f6:	9c 81       	ldd	r25, Y+4	; 0x04
    53f8:	9a 83       	std	Y+2, r25	; 0x02
    53fa:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );
        return pxTimer->pcTimerName;
    53fc:	e9 81       	ldd	r30, Y+1	; 0x01
    53fe:	fa 81       	ldd	r31, Y+2	; 0x02
    5400:	80 81       	ld	r24, Z
    5402:	91 81       	ldd	r25, Z+1	; 0x01
    }
    5404:	0f 90       	pop	r0
    5406:	0f 90       	pop	r0
    5408:	0f 90       	pop	r0
    540a:	0f 90       	pop	r0
    540c:	cf 91       	pop	r28
    540e:	df 91       	pop	r29
    5410:	08 95       	ret

00005412 <prvReloadTimer>:
/*-----------------------------------------------------------*/

    static void prvReloadTimer( Timer_t * const pxTimer,
                                TickType_t xExpiredTime,
                                const TickType_t xTimeNow )
    {
    5412:	df 93       	push	r29
    5414:	cf 93       	push	r28
    5416:	00 d0       	rcall	.+0      	; 0x5418 <prvReloadTimer+0x6>
    5418:	00 d0       	rcall	.+0      	; 0x541a <prvReloadTimer+0x8>
    541a:	00 d0       	rcall	.+0      	; 0x541c <prvReloadTimer+0xa>
    541c:	cd b7       	in	r28, 0x3d	; 61
    541e:	de b7       	in	r29, 0x3e	; 62
    5420:	9a 83       	std	Y+2, r25	; 0x02
    5422:	89 83       	std	Y+1, r24	; 0x01
    5424:	7c 83       	std	Y+4, r23	; 0x04
    5426:	6b 83       	std	Y+3, r22	; 0x03
    5428:	5e 83       	std	Y+6, r21	; 0x06
    542a:	4d 83       	std	Y+5, r20	; 0x05
    542c:	12 c0       	rjmp	.+36     	; 0x5452 <prvReloadTimer+0x40>
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
        {
            /* Advance the expiry time. */
            xExpiredTime += pxTimer->xTimerPeriodInTicks;
    542e:	e9 81       	ldd	r30, Y+1	; 0x01
    5430:	fa 81       	ldd	r31, Y+2	; 0x02
    5432:	24 85       	ldd	r18, Z+12	; 0x0c
    5434:	35 85       	ldd	r19, Z+13	; 0x0d
    5436:	8b 81       	ldd	r24, Y+3	; 0x03
    5438:	9c 81       	ldd	r25, Y+4	; 0x04
    543a:	82 0f       	add	r24, r18
    543c:	93 1f       	adc	r25, r19
    543e:	9c 83       	std	Y+4, r25	; 0x04
    5440:	8b 83       	std	Y+3, r24	; 0x03

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    5442:	e9 81       	ldd	r30, Y+1	; 0x01
    5444:	fa 81       	ldd	r31, Y+2	; 0x02
    5446:	00 88       	ldd	r0, Z+16	; 0x10
    5448:	f1 89       	ldd	r31, Z+17	; 0x11
    544a:	e0 2d       	mov	r30, r0
    544c:	89 81       	ldd	r24, Y+1	; 0x01
    544e:	9a 81       	ldd	r25, Y+2	; 0x02
    5450:	09 95       	icall
                                const TickType_t xTimeNow )
    {
        /* Insert the timer into the appropriate list for the next expiry time.
         * If the next expiry time has already passed, advance the expiry time,
         * call the callback function, and try again. */
        while( prvInsertTimerInActiveList( pxTimer, ( xExpiredTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xExpiredTime ) != pdFALSE )
    5452:	e9 81       	ldd	r30, Y+1	; 0x01
    5454:	fa 81       	ldd	r31, Y+2	; 0x02
    5456:	24 85       	ldd	r18, Z+12	; 0x0c
    5458:	35 85       	ldd	r19, Z+13	; 0x0d
    545a:	8b 81       	ldd	r24, Y+3	; 0x03
    545c:	9c 81       	ldd	r25, Y+4	; 0x04
    545e:	a9 01       	movw	r20, r18
    5460:	48 0f       	add	r20, r24
    5462:	59 1f       	adc	r21, r25
    5464:	89 81       	ldd	r24, Y+1	; 0x01
    5466:	9a 81       	ldd	r25, Y+2	; 0x02
    5468:	2d 81       	ldd	r18, Y+5	; 0x05
    546a:	3e 81       	ldd	r19, Y+6	; 0x06
    546c:	eb 81       	ldd	r30, Y+3	; 0x03
    546e:	fc 81       	ldd	r31, Y+4	; 0x04
    5470:	ba 01       	movw	r22, r20
    5472:	a9 01       	movw	r20, r18
    5474:	9f 01       	movw	r18, r30
    5476:	0e 94 5f 2b 	call	0x56be	; 0x56be <prvInsertTimerInActiveList>
    547a:	88 23       	and	r24, r24
    547c:	c1 f6       	brne	.-80     	; 0x542e <prvReloadTimer+0x1c>

            /* Call the timer callback. */
            traceTIMER_EXPIRED( pxTimer );
            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
        }
    }
    547e:	26 96       	adiw	r28, 0x06	; 6
    5480:	0f b6       	in	r0, 0x3f	; 63
    5482:	f8 94       	cli
    5484:	de bf       	out	0x3e, r29	; 62
    5486:	0f be       	out	0x3f, r0	; 63
    5488:	cd bf       	out	0x3d, r28	; 61
    548a:	cf 91       	pop	r28
    548c:	df 91       	pop	r29
    548e:	08 95       	ret

00005490 <prvProcessExpiredTimer>:
/*-----------------------------------------------------------*/

    static void prvProcessExpiredTimer( const TickType_t xNextExpireTime,
                                        const TickType_t xTimeNow )
    {
    5490:	df 93       	push	r29
    5492:	cf 93       	push	r28
    5494:	00 d0       	rcall	.+0      	; 0x5496 <prvProcessExpiredTimer+0x6>
    5496:	00 d0       	rcall	.+0      	; 0x5498 <prvProcessExpiredTimer+0x8>
    5498:	00 d0       	rcall	.+0      	; 0x549a <prvProcessExpiredTimer+0xa>
    549a:	cd b7       	in	r28, 0x3d	; 61
    549c:	de b7       	in	r29, 0x3e	; 62
    549e:	9c 83       	std	Y+4, r25	; 0x04
    54a0:	8b 83       	std	Y+3, r24	; 0x03
    54a2:	7e 83       	std	Y+6, r23	; 0x06
    54a4:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    54a6:	e0 91 1c 07 	lds	r30, 0x071C
    54aa:	f0 91 1d 07 	lds	r31, 0x071D
    54ae:	05 80       	ldd	r0, Z+5	; 0x05
    54b0:	f6 81       	ldd	r31, Z+6	; 0x06
    54b2:	e0 2d       	mov	r30, r0
    54b4:	86 81       	ldd	r24, Z+6	; 0x06
    54b6:	97 81       	ldd	r25, Z+7	; 0x07
    54b8:	9a 83       	std	Y+2, r25	; 0x02
    54ba:	89 83       	std	Y+1, r24	; 0x01

        /* Remove the timer from the list of active timers.  A check has already
         * been performed to ensure the list is not empty. */

        ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    54bc:	89 81       	ldd	r24, Y+1	; 0x01
    54be:	9a 81       	ldd	r25, Y+2	; 0x02
    54c0:	02 96       	adiw	r24, 0x02	; 2
    54c2:	0e 94 ab 0a 	call	0x1556	; 0x1556 <uxListRemove>

        /* If the timer is an auto-reload timer then calculate the next
         * expiry time and re-insert the timer in the list of active timers. */
        if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    54c6:	e9 81       	ldd	r30, Y+1	; 0x01
    54c8:	fa 81       	ldd	r31, Y+2	; 0x02
    54ca:	82 89       	ldd	r24, Z+18	; 0x12
    54cc:	88 2f       	mov	r24, r24
    54ce:	90 e0       	ldi	r25, 0x00	; 0
    54d0:	84 70       	andi	r24, 0x04	; 4
    54d2:	90 70       	andi	r25, 0x00	; 0
    54d4:	00 97       	sbiw	r24, 0x00	; 0
    54d6:	51 f0       	breq	.+20     	; 0x54ec <prvProcessExpiredTimer+0x5c>
        {
            prvReloadTimer( pxTimer, xNextExpireTime, xTimeNow );
    54d8:	89 81       	ldd	r24, Y+1	; 0x01
    54da:	9a 81       	ldd	r25, Y+2	; 0x02
    54dc:	2b 81       	ldd	r18, Y+3	; 0x03
    54de:	3c 81       	ldd	r19, Y+4	; 0x04
    54e0:	4d 81       	ldd	r20, Y+5	; 0x05
    54e2:	5e 81       	ldd	r21, Y+6	; 0x06
    54e4:	b9 01       	movw	r22, r18
    54e6:	0e 94 09 2a 	call	0x5412	; 0x5412 <prvReloadTimer>
    54ea:	07 c0       	rjmp	.+14     	; 0x54fa <prvProcessExpiredTimer+0x6a>
        }
        else
        {
            pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    54ec:	e9 81       	ldd	r30, Y+1	; 0x01
    54ee:	fa 81       	ldd	r31, Y+2	; 0x02
    54f0:	82 89       	ldd	r24, Z+18	; 0x12
    54f2:	8e 7f       	andi	r24, 0xFE	; 254
    54f4:	e9 81       	ldd	r30, Y+1	; 0x01
    54f6:	fa 81       	ldd	r31, Y+2	; 0x02
    54f8:	82 8b       	std	Z+18, r24	; 0x12
        }

        /* Call the timer callback. */
        traceTIMER_EXPIRED( pxTimer );
        pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    54fa:	e9 81       	ldd	r30, Y+1	; 0x01
    54fc:	fa 81       	ldd	r31, Y+2	; 0x02
    54fe:	00 88       	ldd	r0, Z+16	; 0x10
    5500:	f1 89       	ldd	r31, Z+17	; 0x11
    5502:	e0 2d       	mov	r30, r0
    5504:	89 81       	ldd	r24, Y+1	; 0x01
    5506:	9a 81       	ldd	r25, Y+2	; 0x02
    5508:	09 95       	icall
    }
    550a:	26 96       	adiw	r28, 0x06	; 6
    550c:	0f b6       	in	r0, 0x3f	; 63
    550e:	f8 94       	cli
    5510:	de bf       	out	0x3e, r29	; 62
    5512:	0f be       	out	0x3f, r0	; 63
    5514:	cd bf       	out	0x3d, r28	; 61
    5516:	cf 91       	pop	r28
    5518:	df 91       	pop	r29
    551a:	08 95       	ret

0000551c <prvTimerTask>:
/*-----------------------------------------------------------*/

    static portTASK_FUNCTION( prvTimerTask, pvParameters )
    {
    551c:	df 93       	push	r29
    551e:	cf 93       	push	r28
    5520:	00 d0       	rcall	.+0      	; 0x5522 <prvTimerTask+0x6>
    5522:	00 d0       	rcall	.+0      	; 0x5524 <prvTimerTask+0x8>
    5524:	0f 92       	push	r0
    5526:	cd b7       	in	r28, 0x3d	; 61
    5528:	de b7       	in	r29, 0x3e	; 62
    552a:	9d 83       	std	Y+5, r25	; 0x05
    552c:	8c 83       	std	Y+4, r24	; 0x04

        for( ; ; )
        {
            /* Query the timers list to see if it contains any timers, and if so,
             * obtain the time at which the next timer will expire. */
            xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    552e:	ce 01       	movw	r24, r28
    5530:	03 96       	adiw	r24, 0x03	; 3
    5532:	0e 94 fd 2a 	call	0x55fa	; 0x55fa <prvGetNextExpireTime>
    5536:	9a 83       	std	Y+2, r25	; 0x02
    5538:	89 83       	std	Y+1, r24	; 0x01

            /* If a timer has expired, process it.  Otherwise, block this task
             * until either a timer does expire, or a command is received. */
            prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    553a:	2b 81       	ldd	r18, Y+3	; 0x03
    553c:	89 81       	ldd	r24, Y+1	; 0x01
    553e:	9a 81       	ldd	r25, Y+2	; 0x02
    5540:	62 2f       	mov	r22, r18
    5542:	0e 94 a6 2a 	call	0x554c	; 0x554c <prvProcessTimerOrBlockTask>

            /* Empty the command queue. */
            prvProcessReceivedCommands();
    5546:	0e 94 c7 2b 	call	0x578e	; 0x578e <prvProcessReceivedCommands>
    554a:	f1 cf       	rjmp	.-30     	; 0x552e <prvTimerTask+0x12>

0000554c <prvProcessTimerOrBlockTask>:
    }
/*-----------------------------------------------------------*/

    static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime,
                                            BaseType_t xListWasEmpty )
    {
    554c:	df 93       	push	r29
    554e:	cf 93       	push	r28
    5550:	00 d0       	rcall	.+0      	; 0x5552 <prvProcessTimerOrBlockTask+0x6>
    5552:	00 d0       	rcall	.+0      	; 0x5554 <prvProcessTimerOrBlockTask+0x8>
    5554:	00 d0       	rcall	.+0      	; 0x5556 <prvProcessTimerOrBlockTask+0xa>
    5556:	cd b7       	in	r28, 0x3d	; 61
    5558:	de b7       	in	r29, 0x3e	; 62
    555a:	9d 83       	std	Y+5, r25	; 0x05
    555c:	8c 83       	std	Y+4, r24	; 0x04
    555e:	6e 83       	std	Y+6, r22	; 0x06
        TickType_t xTimeNow;
        BaseType_t xTimerListsWereSwitched;

        vTaskSuspendAll();
    5560:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <vTaskSuspendAll>
            /* Obtain the time now to make an assessment as to whether the timer
             * has expired or not.  If obtaining the time causes the lists to switch
             * then don't process this timer as any timers that remained in the list
             * when the lists were switched will have been processed within the
             * prvSampleTimeNow() function. */
            xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    5564:	ce 01       	movw	r24, r28
    5566:	03 96       	adiw	r24, 0x03	; 3
    5568:	0e 94 31 2b 	call	0x5662	; 0x5662 <prvSampleTimeNow>
    556c:	9a 83       	std	Y+2, r25	; 0x02
    556e:	89 83       	std	Y+1, r24	; 0x01

            if( xTimerListsWereSwitched == pdFALSE )
    5570:	8b 81       	ldd	r24, Y+3	; 0x03
    5572:	88 23       	and	r24, r24
    5574:	b9 f5       	brne	.+110    	; 0x55e4 <prvProcessTimerOrBlockTask+0x98>
            {
                /* The tick count has not overflowed, has the timer expired? */
                if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    5576:	8e 81       	ldd	r24, Y+6	; 0x06
    5578:	88 23       	and	r24, r24
    557a:	89 f4       	brne	.+34     	; 0x559e <prvProcessTimerOrBlockTask+0x52>
    557c:	2c 81       	ldd	r18, Y+4	; 0x04
    557e:	3d 81       	ldd	r19, Y+5	; 0x05
    5580:	89 81       	ldd	r24, Y+1	; 0x01
    5582:	9a 81       	ldd	r25, Y+2	; 0x02
    5584:	82 17       	cp	r24, r18
    5586:	93 07       	cpc	r25, r19
    5588:	50 f0       	brcs	.+20     	; 0x559e <prvProcessTimerOrBlockTask+0x52>
                {
                    ( void ) xTaskResumeAll();
    558a:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>
                    prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    558e:	8c 81       	ldd	r24, Y+4	; 0x04
    5590:	9d 81       	ldd	r25, Y+5	; 0x05
    5592:	29 81       	ldd	r18, Y+1	; 0x01
    5594:	3a 81       	ldd	r19, Y+2	; 0x02
    5596:	b9 01       	movw	r22, r18
    5598:	0e 94 48 2a 	call	0x5490	; 0x5490 <prvProcessExpiredTimer>
    559c:	25 c0       	rjmp	.+74     	; 0x55e8 <prvProcessTimerOrBlockTask+0x9c>
                     * time has not been reached yet.  This task should therefore
                     * block to wait for the next expire time or a command to be
                     * received - whichever comes first.  The following line cannot
                     * be reached unless xNextExpireTime > xTimeNow, except in the
                     * case when the current timer list is empty. */
                    if( xListWasEmpty != pdFALSE )
    559e:	8e 81       	ldd	r24, Y+6	; 0x06
    55a0:	88 23       	and	r24, r24
    55a2:	51 f0       	breq	.+20     	; 0x55b8 <prvProcessTimerOrBlockTask+0x6c>
                    {
                        /* The current timer list is empty - is the overflow list
                         * also empty? */
                        xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    55a4:	e0 91 1e 07 	lds	r30, 0x071E
    55a8:	f0 91 1f 07 	lds	r31, 0x071F
    55ac:	80 81       	ld	r24, Z
    55ae:	1e 82       	std	Y+6, r1	; 0x06
    55b0:	88 23       	and	r24, r24
    55b2:	11 f4       	brne	.+4      	; 0x55b8 <prvProcessTimerOrBlockTask+0x6c>
    55b4:	81 e0       	ldi	r24, 0x01	; 1
    55b6:	8e 83       	std	Y+6, r24	; 0x06
                    }

                    vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    55b8:	40 91 04 07 	lds	r20, 0x0704
    55bc:	50 91 05 07 	lds	r21, 0x0705
    55c0:	2c 81       	ldd	r18, Y+4	; 0x04
    55c2:	3d 81       	ldd	r19, Y+5	; 0x05
    55c4:	89 81       	ldd	r24, Y+1	; 0x01
    55c6:	9a 81       	ldd	r25, Y+2	; 0x02
    55c8:	28 1b       	sub	r18, r24
    55ca:	39 0b       	sbc	r19, r25
    55cc:	ca 01       	movw	r24, r20
    55ce:	b9 01       	movw	r22, r18
    55d0:	4e 81       	ldd	r20, Y+6	; 0x06
    55d2:	0e 94 0a 14 	call	0x2814	; 0x2814 <vQueueWaitForMessageRestricted>

                    if( xTaskResumeAll() == pdFALSE )
    55d6:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>
    55da:	88 23       	and	r24, r24
    55dc:	29 f4       	brne	.+10     	; 0x55e8 <prvProcessTimerOrBlockTask+0x9c>
                    {
                        /* Yield to wait for either a command to arrive, or the
                         * block time to expire.  If a command arrived between the
                         * critical section being exited and this yield then the yield
                         * will not cause the task to block. */
                        portYIELD_WITHIN_API();
    55de:	0e 94 88 02 	call	0x510	; 0x510 <vPortYield>
    55e2:	02 c0       	rjmp	.+4      	; 0x55e8 <prvProcessTimerOrBlockTask+0x9c>
                    }
                }
            }
            else
            {
                ( void ) xTaskResumeAll();
    55e4:	0e 94 aa 17 	call	0x2f54	; 0x2f54 <xTaskResumeAll>
            }
        }
    }
    55e8:	26 96       	adiw	r28, 0x06	; 6
    55ea:	0f b6       	in	r0, 0x3f	; 63
    55ec:	f8 94       	cli
    55ee:	de bf       	out	0x3e, r29	; 62
    55f0:	0f be       	out	0x3f, r0	; 63
    55f2:	cd bf       	out	0x3d, r28	; 61
    55f4:	cf 91       	pop	r28
    55f6:	df 91       	pop	r29
    55f8:	08 95       	ret

000055fa <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

    static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    {
    55fa:	df 93       	push	r29
    55fc:	cf 93       	push	r28
    55fe:	00 d0       	rcall	.+0      	; 0x5600 <prvGetNextExpireTime+0x6>
    5600:	00 d0       	rcall	.+0      	; 0x5602 <prvGetNextExpireTime+0x8>
    5602:	0f 92       	push	r0
    5604:	cd b7       	in	r28, 0x3d	; 61
    5606:	de b7       	in	r29, 0x3e	; 62
    5608:	9c 83       	std	Y+4, r25	; 0x04
    560a:	8b 83       	std	Y+3, r24	; 0x03
         * the timer with the nearest expiry time will expire.  If there are no
         * active timers then just set the next expire time to 0.  That will cause
         * this task to unblock when the tick count overflows, at which point the
         * timer lists will be switched and the next expiry time can be
         * re-assessed.  */
        *pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    560c:	e0 91 1c 07 	lds	r30, 0x071C
    5610:	f0 91 1d 07 	lds	r31, 0x071D
    5614:	80 81       	ld	r24, Z
    5616:	1d 82       	std	Y+5, r1	; 0x05
    5618:	88 23       	and	r24, r24
    561a:	11 f4       	brne	.+4      	; 0x5620 <prvGetNextExpireTime+0x26>
    561c:	81 e0       	ldi	r24, 0x01	; 1
    561e:	8d 83       	std	Y+5, r24	; 0x05
    5620:	eb 81       	ldd	r30, Y+3	; 0x03
    5622:	fc 81       	ldd	r31, Y+4	; 0x04
    5624:	8d 81       	ldd	r24, Y+5	; 0x05
    5626:	80 83       	st	Z, r24

        if( *pxListWasEmpty == pdFALSE )
    5628:	eb 81       	ldd	r30, Y+3	; 0x03
    562a:	fc 81       	ldd	r31, Y+4	; 0x04
    562c:	80 81       	ld	r24, Z
    562e:	88 23       	and	r24, r24
    5630:	61 f4       	brne	.+24     	; 0x564a <prvGetNextExpireTime+0x50>
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    5632:	e0 91 1c 07 	lds	r30, 0x071C
    5636:	f0 91 1d 07 	lds	r31, 0x071D
    563a:	05 80       	ldd	r0, Z+5	; 0x05
    563c:	f6 81       	ldd	r31, Z+6	; 0x06
    563e:	e0 2d       	mov	r30, r0
    5640:	80 81       	ld	r24, Z
    5642:	91 81       	ldd	r25, Z+1	; 0x01
    5644:	9a 83       	std	Y+2, r25	; 0x02
    5646:	89 83       	std	Y+1, r24	; 0x01
    5648:	02 c0       	rjmp	.+4      	; 0x564e <prvGetNextExpireTime+0x54>
        }
        else
        {
            /* Ensure the task unblocks when the tick count rolls over. */
            xNextExpireTime = ( TickType_t ) 0U;
    564a:	1a 82       	std	Y+2, r1	; 0x02
    564c:	19 82       	std	Y+1, r1	; 0x01
        }

        return xNextExpireTime;
    564e:	89 81       	ldd	r24, Y+1	; 0x01
    5650:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    5652:	0f 90       	pop	r0
    5654:	0f 90       	pop	r0
    5656:	0f 90       	pop	r0
    5658:	0f 90       	pop	r0
    565a:	0f 90       	pop	r0
    565c:	cf 91       	pop	r28
    565e:	df 91       	pop	r29
    5660:	08 95       	ret

00005662 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

    static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    {
    5662:	df 93       	push	r29
    5664:	cf 93       	push	r28
    5666:	00 d0       	rcall	.+0      	; 0x5668 <prvSampleTimeNow+0x6>
    5668:	00 d0       	rcall	.+0      	; 0x566a <prvSampleTimeNow+0x8>
    566a:	cd b7       	in	r28, 0x3d	; 61
    566c:	de b7       	in	r29, 0x3e	; 62
    566e:	9c 83       	std	Y+4, r25	; 0x04
    5670:	8b 83       	std	Y+3, r24	; 0x03
        TickType_t xTimeNow;
        PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

        xTimeNow = xTaskGetTickCount();
    5672:	0e 94 fa 18 	call	0x31f4	; 0x31f4 <xTaskGetTickCount>
    5676:	9a 83       	std	Y+2, r25	; 0x02
    5678:	89 83       	std	Y+1, r24	; 0x01

        if( xTimeNow < xLastTime )
    567a:	20 91 08 07 	lds	r18, 0x0708
    567e:	30 91 09 07 	lds	r19, 0x0709
    5682:	89 81       	ldd	r24, Y+1	; 0x01
    5684:	9a 81       	ldd	r25, Y+2	; 0x02
    5686:	82 17       	cp	r24, r18
    5688:	93 07       	cpc	r25, r19
    568a:	38 f4       	brcc	.+14     	; 0x569a <prvSampleTimeNow+0x38>
        {
            prvSwitchTimerLists();
    568c:	0e 94 c2 2c 	call	0x5984	; 0x5984 <prvSwitchTimerLists>
            *pxTimerListsWereSwitched = pdTRUE;
    5690:	eb 81       	ldd	r30, Y+3	; 0x03
    5692:	fc 81       	ldd	r31, Y+4	; 0x04
    5694:	81 e0       	ldi	r24, 0x01	; 1
    5696:	80 83       	st	Z, r24
    5698:	03 c0       	rjmp	.+6      	; 0x56a0 <prvSampleTimeNow+0x3e>
        }
        else
        {
            *pxTimerListsWereSwitched = pdFALSE;
    569a:	eb 81       	ldd	r30, Y+3	; 0x03
    569c:	fc 81       	ldd	r31, Y+4	; 0x04
    569e:	10 82       	st	Z, r1
        }

        xLastTime = xTimeNow;
    56a0:	89 81       	ldd	r24, Y+1	; 0x01
    56a2:	9a 81       	ldd	r25, Y+2	; 0x02
    56a4:	90 93 09 07 	sts	0x0709, r25
    56a8:	80 93 08 07 	sts	0x0708, r24

        return xTimeNow;
    56ac:	89 81       	ldd	r24, Y+1	; 0x01
    56ae:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    56b0:	0f 90       	pop	r0
    56b2:	0f 90       	pop	r0
    56b4:	0f 90       	pop	r0
    56b6:	0f 90       	pop	r0
    56b8:	cf 91       	pop	r28
    56ba:	df 91       	pop	r29
    56bc:	08 95       	ret

000056be <prvInsertTimerInActiveList>:

    static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer,
                                                  const TickType_t xNextExpiryTime,
                                                  const TickType_t xTimeNow,
                                                  const TickType_t xCommandTime )
    {
    56be:	df 93       	push	r29
    56c0:	cf 93       	push	r28
    56c2:	cd b7       	in	r28, 0x3d	; 61
    56c4:	de b7       	in	r29, 0x3e	; 62
    56c6:	29 97       	sbiw	r28, 0x09	; 9
    56c8:	0f b6       	in	r0, 0x3f	; 63
    56ca:	f8 94       	cli
    56cc:	de bf       	out	0x3e, r29	; 62
    56ce:	0f be       	out	0x3f, r0	; 63
    56d0:	cd bf       	out	0x3d, r28	; 61
    56d2:	9b 83       	std	Y+3, r25	; 0x03
    56d4:	8a 83       	std	Y+2, r24	; 0x02
    56d6:	7d 83       	std	Y+5, r23	; 0x05
    56d8:	6c 83       	std	Y+4, r22	; 0x04
    56da:	5f 83       	std	Y+7, r21	; 0x07
    56dc:	4e 83       	std	Y+6, r20	; 0x06
    56de:	39 87       	std	Y+9, r19	; 0x09
    56e0:	28 87       	std	Y+8, r18	; 0x08
        BaseType_t xProcessTimerNow = pdFALSE;
    56e2:	19 82       	std	Y+1, r1	; 0x01

        listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    56e4:	ea 81       	ldd	r30, Y+2	; 0x02
    56e6:	fb 81       	ldd	r31, Y+3	; 0x03
    56e8:	8c 81       	ldd	r24, Y+4	; 0x04
    56ea:	9d 81       	ldd	r25, Y+5	; 0x05
    56ec:	93 83       	std	Z+3, r25	; 0x03
    56ee:	82 83       	std	Z+2, r24	; 0x02
        listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    56f0:	ea 81       	ldd	r30, Y+2	; 0x02
    56f2:	fb 81       	ldd	r31, Y+3	; 0x03
    56f4:	8a 81       	ldd	r24, Y+2	; 0x02
    56f6:	9b 81       	ldd	r25, Y+3	; 0x03
    56f8:	91 87       	std	Z+9, r25	; 0x09
    56fa:	80 87       	std	Z+8, r24	; 0x08

        if( xNextExpiryTime <= xTimeNow )
    56fc:	2c 81       	ldd	r18, Y+4	; 0x04
    56fe:	3d 81       	ldd	r19, Y+5	; 0x05
    5700:	8e 81       	ldd	r24, Y+6	; 0x06
    5702:	9f 81       	ldd	r25, Y+7	; 0x07
    5704:	82 17       	cp	r24, r18
    5706:	93 07       	cpc	r25, r19
    5708:	e0 f0       	brcs	.+56     	; 0x5742 <prvInsertTimerInActiveList+0x84>
        {
            /* Has the expiry time elapsed between the command to start/reset a
             * timer was issued, and the time the command was processed? */
            if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    570a:	2e 81       	ldd	r18, Y+6	; 0x06
    570c:	3f 81       	ldd	r19, Y+7	; 0x07
    570e:	88 85       	ldd	r24, Y+8	; 0x08
    5710:	99 85       	ldd	r25, Y+9	; 0x09
    5712:	28 1b       	sub	r18, r24
    5714:	39 0b       	sbc	r19, r25
    5716:	ea 81       	ldd	r30, Y+2	; 0x02
    5718:	fb 81       	ldd	r31, Y+3	; 0x03
    571a:	84 85       	ldd	r24, Z+12	; 0x0c
    571c:	95 85       	ldd	r25, Z+13	; 0x0d
    571e:	28 17       	cp	r18, r24
    5720:	39 07       	cpc	r19, r25
    5722:	18 f0       	brcs	.+6      	; 0x572a <prvInsertTimerInActiveList+0x6c>
            {
                /* The time between a command being issued and the command being
                 * processed actually exceeds the timers period.  */
                xProcessTimerNow = pdTRUE;
    5724:	81 e0       	ldi	r24, 0x01	; 1
    5726:	89 83       	std	Y+1, r24	; 0x01
    5728:	28 c0       	rjmp	.+80     	; 0x577a <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    572a:	80 91 1e 07 	lds	r24, 0x071E
    572e:	90 91 1f 07 	lds	r25, 0x071F
    5732:	2a 81       	ldd	r18, Y+2	; 0x02
    5734:	3b 81       	ldd	r19, Y+3	; 0x03
    5736:	2e 5f       	subi	r18, 0xFE	; 254
    5738:	3f 4f       	sbci	r19, 0xFF	; 255
    573a:	b9 01       	movw	r22, r18
    573c:	0e 94 3f 0a 	call	0x147e	; 0x147e <vListInsert>
    5740:	1c c0       	rjmp	.+56     	; 0x577a <prvInsertTimerInActiveList+0xbc>
            }
        }
        else
        {
            if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    5742:	2e 81       	ldd	r18, Y+6	; 0x06
    5744:	3f 81       	ldd	r19, Y+7	; 0x07
    5746:	88 85       	ldd	r24, Y+8	; 0x08
    5748:	99 85       	ldd	r25, Y+9	; 0x09
    574a:	28 17       	cp	r18, r24
    574c:	39 07       	cpc	r19, r25
    574e:	50 f4       	brcc	.+20     	; 0x5764 <prvInsertTimerInActiveList+0xa6>
    5750:	2c 81       	ldd	r18, Y+4	; 0x04
    5752:	3d 81       	ldd	r19, Y+5	; 0x05
    5754:	88 85       	ldd	r24, Y+8	; 0x08
    5756:	99 85       	ldd	r25, Y+9	; 0x09
    5758:	28 17       	cp	r18, r24
    575a:	39 07       	cpc	r19, r25
    575c:	18 f0       	brcs	.+6      	; 0x5764 <prvInsertTimerInActiveList+0xa6>
            {
                /* If, since the command was issued, the tick count has overflowed
                 * but the expiry time has not, then the timer must have already passed
                 * its expiry time and should be processed immediately. */
                xProcessTimerNow = pdTRUE;
    575e:	81 e0       	ldi	r24, 0x01	; 1
    5760:	89 83       	std	Y+1, r24	; 0x01
    5762:	0b c0       	rjmp	.+22     	; 0x577a <prvInsertTimerInActiveList+0xbc>
            }
            else
            {
                vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    5764:	80 91 1c 07 	lds	r24, 0x071C
    5768:	90 91 1d 07 	lds	r25, 0x071D
    576c:	2a 81       	ldd	r18, Y+2	; 0x02
    576e:	3b 81       	ldd	r19, Y+3	; 0x03
    5770:	2e 5f       	subi	r18, 0xFE	; 254
    5772:	3f 4f       	sbci	r19, 0xFF	; 255
    5774:	b9 01       	movw	r22, r18
    5776:	0e 94 3f 0a 	call	0x147e	; 0x147e <vListInsert>
            }
        }

        return xProcessTimerNow;
    577a:	89 81       	ldd	r24, Y+1	; 0x01
    }
    577c:	29 96       	adiw	r28, 0x09	; 9
    577e:	0f b6       	in	r0, 0x3f	; 63
    5780:	f8 94       	cli
    5782:	de bf       	out	0x3e, r29	; 62
    5784:	0f be       	out	0x3f, r0	; 63
    5786:	cd bf       	out	0x3d, r28	; 61
    5788:	cf 91       	pop	r28
    578a:	df 91       	pop	r29
    578c:	08 95       	ret

0000578e <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

    static void prvProcessReceivedCommands( void )
    {
    578e:	df 93       	push	r29
    5790:	cf 93       	push	r28
    5792:	cd b7       	in	r28, 0x3d	; 61
    5794:	de b7       	in	r29, 0x3e	; 62
    5796:	2c 97       	sbiw	r28, 0x0c	; 12
    5798:	0f b6       	in	r0, 0x3f	; 63
    579a:	f8 94       	cli
    579c:	de bf       	out	0x3e, r29	; 62
    579e:	0f be       	out	0x3f, r0	; 63
    57a0:	cd bf       	out	0x3d, r28	; 61
    57a2:	d8 c0       	rjmp	.+432    	; 0x5954 <prvProcessReceivedCommands+0x1c6>
                }
            #endif /* INCLUDE_xTimerPendFunctionCall */

            /* Commands that are positive are timer commands rather than pended
             * function calls. */
            if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    57a4:	8d 81       	ldd	r24, Y+5	; 0x05
    57a6:	88 23       	and	r24, r24
    57a8:	0c f4       	brge	.+2      	; 0x57ac <prvProcessReceivedCommands+0x1e>
    57aa:	d4 c0       	rjmp	.+424    	; 0x5954 <prvProcessReceivedCommands+0x1c6>
            {
                /* The messages uses the xTimerParameters member to work on a
                 * software timer. */
                pxTimer = xMessage.u.xTimerParameters.pxTimer;
    57ac:	88 85       	ldd	r24, Y+8	; 0x08
    57ae:	99 85       	ldd	r25, Y+9	; 0x09
    57b0:	9c 83       	std	Y+4, r25	; 0x04
    57b2:	8b 83       	std	Y+3, r24	; 0x03

                if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    57b4:	eb 81       	ldd	r30, Y+3	; 0x03
    57b6:	fc 81       	ldd	r31, Y+4	; 0x04
    57b8:	82 85       	ldd	r24, Z+10	; 0x0a
    57ba:	93 85       	ldd	r25, Z+11	; 0x0b
    57bc:	00 97       	sbiw	r24, 0x00	; 0
    57be:	29 f0       	breq	.+10     	; 0x57ca <prvProcessReceivedCommands+0x3c>
                {
                    /* The timer is in a list, remove it. */
                    ( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    57c0:	8b 81       	ldd	r24, Y+3	; 0x03
    57c2:	9c 81       	ldd	r25, Y+4	; 0x04
    57c4:	02 96       	adiw	r24, 0x02	; 2
    57c6:	0e 94 ab 0a 	call	0x1556	; 0x1556 <uxListRemove>
                 *  it must be present in the function call.  prvSampleTimeNow() must be
                 *  called after the message is received from xTimerQueue so there is no
                 *  possibility of a higher priority task adding a message to the message
                 *  queue with a time that is ahead of the timer daemon task (because it
                 *  pre-empted the timer daemon task after the xTimeNow value was set). */
                xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    57ca:	ce 01       	movw	r24, r28
    57cc:	0a 96       	adiw	r24, 0x0a	; 10
    57ce:	0e 94 31 2b 	call	0x5662	; 0x5662 <prvSampleTimeNow>
    57d2:	9a 83       	std	Y+2, r25	; 0x02
    57d4:	89 83       	std	Y+1, r24	; 0x01

                switch( xMessage.xMessageID )
    57d6:	8d 81       	ldd	r24, Y+5	; 0x05
    57d8:	28 2f       	mov	r18, r24
    57da:	33 27       	eor	r19, r19
    57dc:	27 fd       	sbrc	r18, 7
    57de:	30 95       	com	r19
    57e0:	3c 87       	std	Y+12, r19	; 0x0c
    57e2:	2b 87       	std	Y+11, r18	; 0x0b
    57e4:	8b 85       	ldd	r24, Y+11	; 0x0b
    57e6:	9c 85       	ldd	r25, Y+12	; 0x0c
    57e8:	85 30       	cpi	r24, 0x05	; 5
    57ea:	91 05       	cpc	r25, r1
    57ec:	09 f4       	brne	.+2      	; 0x57f0 <prvProcessReceivedCommands+0x62>
    57ee:	9d c0       	rjmp	.+314    	; 0x592a <prvProcessReceivedCommands+0x19c>
    57f0:	2b 85       	ldd	r18, Y+11	; 0x0b
    57f2:	3c 85       	ldd	r19, Y+12	; 0x0c
    57f4:	26 30       	cpi	r18, 0x06	; 6
    57f6:	31 05       	cpc	r19, r1
    57f8:	9c f4       	brge	.+38     	; 0x5820 <prvProcessReceivedCommands+0x92>
    57fa:	8b 85       	ldd	r24, Y+11	; 0x0b
    57fc:	9c 85       	ldd	r25, Y+12	; 0x0c
    57fe:	83 30       	cpi	r24, 0x03	; 3
    5800:	91 05       	cpc	r25, r1
    5802:	09 f4       	brne	.+2      	; 0x5806 <prvProcessReceivedCommands+0x78>
    5804:	68 c0       	rjmp	.+208    	; 0x58d6 <prvProcessReceivedCommands+0x148>
    5806:	2b 85       	ldd	r18, Y+11	; 0x0b
    5808:	3c 85       	ldd	r19, Y+12	; 0x0c
    580a:	24 30       	cpi	r18, 0x04	; 4
    580c:	31 05       	cpc	r19, r1
    580e:	0c f0       	brlt	.+2      	; 0x5812 <prvProcessReceivedCommands+0x84>
    5810:	6a c0       	rjmp	.+212    	; 0x58e6 <prvProcessReceivedCommands+0x158>
    5812:	8b 85       	ldd	r24, Y+11	; 0x0b
    5814:	9c 85       	ldd	r25, Y+12	; 0x0c
    5816:	81 30       	cpi	r24, 0x01	; 1
    5818:	91 05       	cpc	r25, r1
    581a:	0c f4       	brge	.+2      	; 0x581e <prvProcessReceivedCommands+0x90>
    581c:	9b c0       	rjmp	.+310    	; 0x5954 <prvProcessReceivedCommands+0x1c6>
    581e:	12 c0       	rjmp	.+36     	; 0x5844 <prvProcessReceivedCommands+0xb6>
    5820:	2b 85       	ldd	r18, Y+11	; 0x0b
    5822:	3c 85       	ldd	r19, Y+12	; 0x0c
    5824:	28 30       	cpi	r18, 0x08	; 8
    5826:	31 05       	cpc	r19, r1
    5828:	09 f4       	brne	.+2      	; 0x582c <prvProcessReceivedCommands+0x9e>
    582a:	55 c0       	rjmp	.+170    	; 0x58d6 <prvProcessReceivedCommands+0x148>
    582c:	8b 85       	ldd	r24, Y+11	; 0x0b
    582e:	9c 85       	ldd	r25, Y+12	; 0x0c
    5830:	88 30       	cpi	r24, 0x08	; 8
    5832:	91 05       	cpc	r25, r1
    5834:	3c f0       	brlt	.+14     	; 0x5844 <prvProcessReceivedCommands+0xb6>
    5836:	2b 85       	ldd	r18, Y+11	; 0x0b
    5838:	3c 85       	ldd	r19, Y+12	; 0x0c
    583a:	29 30       	cpi	r18, 0x09	; 9
    583c:	31 05       	cpc	r19, r1
    583e:	09 f4       	brne	.+2      	; 0x5842 <prvProcessReceivedCommands+0xb4>
    5840:	52 c0       	rjmp	.+164    	; 0x58e6 <prvProcessReceivedCommands+0x158>
    5842:	88 c0       	rjmp	.+272    	; 0x5954 <prvProcessReceivedCommands+0x1c6>
                    case tmrCOMMAND_START:
                    case tmrCOMMAND_START_FROM_ISR:
                    case tmrCOMMAND_RESET:
                    case tmrCOMMAND_RESET_FROM_ISR:
                        /* Start or restart a timer. */
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    5844:	eb 81       	ldd	r30, Y+3	; 0x03
    5846:	fc 81       	ldd	r31, Y+4	; 0x04
    5848:	82 89       	ldd	r24, Z+18	; 0x12
    584a:	81 60       	ori	r24, 0x01	; 1
    584c:	eb 81       	ldd	r30, Y+3	; 0x03
    584e:	fc 81       	ldd	r31, Y+4	; 0x04
    5850:	82 8b       	std	Z+18, r24	; 0x12

                        if( prvInsertTimerInActiveList( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    5852:	2e 81       	ldd	r18, Y+6	; 0x06
    5854:	3f 81       	ldd	r19, Y+7	; 0x07
    5856:	eb 81       	ldd	r30, Y+3	; 0x03
    5858:	fc 81       	ldd	r31, Y+4	; 0x04
    585a:	84 85       	ldd	r24, Z+12	; 0x0c
    585c:	95 85       	ldd	r25, Z+13	; 0x0d
    585e:	a9 01       	movw	r20, r18
    5860:	48 0f       	add	r20, r24
    5862:	59 1f       	adc	r21, r25
    5864:	ee 81       	ldd	r30, Y+6	; 0x06
    5866:	ff 81       	ldd	r31, Y+7	; 0x07
    5868:	8b 81       	ldd	r24, Y+3	; 0x03
    586a:	9c 81       	ldd	r25, Y+4	; 0x04
    586c:	29 81       	ldd	r18, Y+1	; 0x01
    586e:	3a 81       	ldd	r19, Y+2	; 0x02
    5870:	ba 01       	movw	r22, r20
    5872:	a9 01       	movw	r20, r18
    5874:	9f 01       	movw	r18, r30
    5876:	0e 94 5f 2b 	call	0x56be	; 0x56be <prvInsertTimerInActiveList>
    587a:	88 23       	and	r24, r24
    587c:	09 f4       	brne	.+2      	; 0x5880 <prvProcessReceivedCommands+0xf2>
    587e:	6a c0       	rjmp	.+212    	; 0x5954 <prvProcessReceivedCommands+0x1c6>
                        {
                            /* The timer expired before it was added to the active
                             * timer list.  Process it now. */
                            if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    5880:	eb 81       	ldd	r30, Y+3	; 0x03
    5882:	fc 81       	ldd	r31, Y+4	; 0x04
    5884:	82 89       	ldd	r24, Z+18	; 0x12
    5886:	88 2f       	mov	r24, r24
    5888:	90 e0       	ldi	r25, 0x00	; 0
    588a:	84 70       	andi	r24, 0x04	; 4
    588c:	90 70       	andi	r25, 0x00	; 0
    588e:	00 97       	sbiw	r24, 0x00	; 0
    5890:	91 f0       	breq	.+36     	; 0x58b6 <prvProcessReceivedCommands+0x128>
                            {
                                prvReloadTimer( pxTimer, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow );
    5892:	2e 81       	ldd	r18, Y+6	; 0x06
    5894:	3f 81       	ldd	r19, Y+7	; 0x07
    5896:	eb 81       	ldd	r30, Y+3	; 0x03
    5898:	fc 81       	ldd	r31, Y+4	; 0x04
    589a:	84 85       	ldd	r24, Z+12	; 0x0c
    589c:	95 85       	ldd	r25, Z+13	; 0x0d
    589e:	a9 01       	movw	r20, r18
    58a0:	48 0f       	add	r20, r24
    58a2:	59 1f       	adc	r21, r25
    58a4:	8b 81       	ldd	r24, Y+3	; 0x03
    58a6:	9c 81       	ldd	r25, Y+4	; 0x04
    58a8:	29 81       	ldd	r18, Y+1	; 0x01
    58aa:	3a 81       	ldd	r19, Y+2	; 0x02
    58ac:	ba 01       	movw	r22, r20
    58ae:	a9 01       	movw	r20, r18
    58b0:	0e 94 09 2a 	call	0x5412	; 0x5412 <prvReloadTimer>
    58b4:	07 c0       	rjmp	.+14     	; 0x58c4 <prvProcessReceivedCommands+0x136>
                            }
                            else
                            {
                                pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    58b6:	eb 81       	ldd	r30, Y+3	; 0x03
    58b8:	fc 81       	ldd	r31, Y+4	; 0x04
    58ba:	82 89       	ldd	r24, Z+18	; 0x12
    58bc:	8e 7f       	andi	r24, 0xFE	; 254
    58be:	eb 81       	ldd	r30, Y+3	; 0x03
    58c0:	fc 81       	ldd	r31, Y+4	; 0x04
    58c2:	82 8b       	std	Z+18, r24	; 0x12
                            }

                            /* Call the timer callback. */
                            traceTIMER_EXPIRED( pxTimer );
                            pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    58c4:	eb 81       	ldd	r30, Y+3	; 0x03
    58c6:	fc 81       	ldd	r31, Y+4	; 0x04
    58c8:	00 88       	ldd	r0, Z+16	; 0x10
    58ca:	f1 89       	ldd	r31, Z+17	; 0x11
    58cc:	e0 2d       	mov	r30, r0
    58ce:	8b 81       	ldd	r24, Y+3	; 0x03
    58d0:	9c 81       	ldd	r25, Y+4	; 0x04
    58d2:	09 95       	icall
    58d4:	3f c0       	rjmp	.+126    	; 0x5954 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_STOP:
                    case tmrCOMMAND_STOP_FROM_ISR:
                        /* The timer has already been removed from the active list. */
                        pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    58d6:	eb 81       	ldd	r30, Y+3	; 0x03
    58d8:	fc 81       	ldd	r31, Y+4	; 0x04
    58da:	82 89       	ldd	r24, Z+18	; 0x12
    58dc:	8e 7f       	andi	r24, 0xFE	; 254
    58de:	eb 81       	ldd	r30, Y+3	; 0x03
    58e0:	fc 81       	ldd	r31, Y+4	; 0x04
    58e2:	82 8b       	std	Z+18, r24	; 0x12
    58e4:	37 c0       	rjmp	.+110    	; 0x5954 <prvProcessReceivedCommands+0x1c6>
                        break;

                    case tmrCOMMAND_CHANGE_PERIOD:
                    case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR:
                        pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    58e6:	eb 81       	ldd	r30, Y+3	; 0x03
    58e8:	fc 81       	ldd	r31, Y+4	; 0x04
    58ea:	82 89       	ldd	r24, Z+18	; 0x12
    58ec:	81 60       	ori	r24, 0x01	; 1
    58ee:	eb 81       	ldd	r30, Y+3	; 0x03
    58f0:	fc 81       	ldd	r31, Y+4	; 0x04
    58f2:	82 8b       	std	Z+18, r24	; 0x12
                        pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    58f4:	8e 81       	ldd	r24, Y+6	; 0x06
    58f6:	9f 81       	ldd	r25, Y+7	; 0x07
    58f8:	eb 81       	ldd	r30, Y+3	; 0x03
    58fa:	fc 81       	ldd	r31, Y+4	; 0x04
    58fc:	95 87       	std	Z+13, r25	; 0x0d
    58fe:	84 87       	std	Z+12, r24	; 0x0c
                         * be longer or shorter than the old one.  The command time is
                         * therefore set to the current time, and as the period cannot
                         * be zero the next expiry time can only be in the future,
                         * meaning (unlike for the xTimerStart() case above) there is
                         * no fail case that needs to be handled here. */
                        ( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    5900:	eb 81       	ldd	r30, Y+3	; 0x03
    5902:	fc 81       	ldd	r31, Y+4	; 0x04
    5904:	24 85       	ldd	r18, Z+12	; 0x0c
    5906:	35 85       	ldd	r19, Z+13	; 0x0d
    5908:	89 81       	ldd	r24, Y+1	; 0x01
    590a:	9a 81       	ldd	r25, Y+2	; 0x02
    590c:	a9 01       	movw	r20, r18
    590e:	48 0f       	add	r20, r24
    5910:	59 1f       	adc	r21, r25
    5912:	8b 81       	ldd	r24, Y+3	; 0x03
    5914:	9c 81       	ldd	r25, Y+4	; 0x04
    5916:	29 81       	ldd	r18, Y+1	; 0x01
    5918:	3a 81       	ldd	r19, Y+2	; 0x02
    591a:	e9 81       	ldd	r30, Y+1	; 0x01
    591c:	fa 81       	ldd	r31, Y+2	; 0x02
    591e:	ba 01       	movw	r22, r20
    5920:	a9 01       	movw	r20, r18
    5922:	9f 01       	movw	r18, r30
    5924:	0e 94 5f 2b 	call	0x56be	; 0x56be <prvInsertTimerInActiveList>
    5928:	15 c0       	rjmp	.+42     	; 0x5954 <prvProcessReceivedCommands+0x1c6>
                        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
                            {
                                /* The timer has already been removed from the active list,
                                 * just free up the memory if the memory was dynamically
                                 * allocated. */
                                if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    592a:	eb 81       	ldd	r30, Y+3	; 0x03
    592c:	fc 81       	ldd	r31, Y+4	; 0x04
    592e:	82 89       	ldd	r24, Z+18	; 0x12
    5930:	88 2f       	mov	r24, r24
    5932:	90 e0       	ldi	r25, 0x00	; 0
    5934:	82 70       	andi	r24, 0x02	; 2
    5936:	90 70       	andi	r25, 0x00	; 0
    5938:	00 97       	sbiw	r24, 0x00	; 0
    593a:	29 f4       	brne	.+10     	; 0x5946 <prvProcessReceivedCommands+0x1b8>
                                {
                                    vPortFree( pxTimer );
    593c:	8b 81       	ldd	r24, Y+3	; 0x03
    593e:	9c 81       	ldd	r25, Y+4	; 0x04
    5940:	0e 94 a3 00 	call	0x146	; 0x146 <vPortFree>
    5944:	07 c0       	rjmp	.+14     	; 0x5954 <prvProcessReceivedCommands+0x1c6>
                                }
                                else
                                {
                                    pxTimer->ucStatus &= ( ( uint8_t ) ~tmrSTATUS_IS_ACTIVE );
    5946:	eb 81       	ldd	r30, Y+3	; 0x03
    5948:	fc 81       	ldd	r31, Y+4	; 0x04
    594a:	82 89       	ldd	r24, Z+18	; 0x12
    594c:	8e 7f       	andi	r24, 0xFE	; 254
    594e:	eb 81       	ldd	r30, Y+3	; 0x03
    5950:	fc 81       	ldd	r31, Y+4	; 0x04
    5952:	82 8b       	std	Z+18, r24	; 0x12
        DaemonTaskMessage_t xMessage;
        Timer_t * pxTimer;
        BaseType_t xTimerListsWereSwitched;
        TickType_t xTimeNow;

        while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    5954:	80 91 04 07 	lds	r24, 0x0704
    5958:	90 91 05 07 	lds	r25, 0x0705
    595c:	9e 01       	movw	r18, r28
    595e:	2b 5f       	subi	r18, 0xFB	; 251
    5960:	3f 4f       	sbci	r19, 0xFF	; 255
    5962:	b9 01       	movw	r22, r18
    5964:	40 e0       	ldi	r20, 0x00	; 0
    5966:	50 e0       	ldi	r21, 0x00	; 0
    5968:	0e 94 aa 0d 	call	0x1b54	; 0x1b54 <xQueueReceive>
    596c:	88 23       	and	r24, r24
    596e:	09 f0       	breq	.+2      	; 0x5972 <prvProcessReceivedCommands+0x1e4>
    5970:	19 cf       	rjmp	.-462    	; 0x57a4 <prvProcessReceivedCommands+0x16>
                        /* Don't expect to get here. */
                        break;
                }
            }
        }
    }
    5972:	2c 96       	adiw	r28, 0x0c	; 12
    5974:	0f b6       	in	r0, 0x3f	; 63
    5976:	f8 94       	cli
    5978:	de bf       	out	0x3e, r29	; 62
    597a:	0f be       	out	0x3f, r0	; 63
    597c:	cd bf       	out	0x3d, r28	; 61
    597e:	cf 91       	pop	r28
    5980:	df 91       	pop	r29
    5982:	08 95       	ret

00005984 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

    static void prvSwitchTimerLists( void )
    {
    5984:	df 93       	push	r29
    5986:	cf 93       	push	r28
    5988:	00 d0       	rcall	.+0      	; 0x598a <prvSwitchTimerLists+0x6>
    598a:	00 d0       	rcall	.+0      	; 0x598c <prvSwitchTimerLists+0x8>
    598c:	cd b7       	in	r28, 0x3d	; 61
    598e:	de b7       	in	r29, 0x3e	; 62
    5990:	11 c0       	rjmp	.+34     	; 0x59b4 <prvSwitchTimerLists+0x30>
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
        {
            xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    5992:	e0 91 1c 07 	lds	r30, 0x071C
    5996:	f0 91 1d 07 	lds	r31, 0x071D
    599a:	05 80       	ldd	r0, Z+5	; 0x05
    599c:	f6 81       	ldd	r31, Z+6	; 0x06
    599e:	e0 2d       	mov	r30, r0
    59a0:	80 81       	ld	r24, Z
    59a2:	91 81       	ldd	r25, Z+1	; 0x01
    59a4:	9c 83       	std	Y+4, r25	; 0x04
    59a6:	8b 83       	std	Y+3, r24	; 0x03

            /* Process the expired timer.  For auto-reload timers, be careful to
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
    59a8:	8b 81       	ldd	r24, Y+3	; 0x03
    59aa:	9c 81       	ldd	r25, Y+4	; 0x04
    59ac:	6f ef       	ldi	r22, 0xFF	; 255
    59ae:	7f ef       	ldi	r23, 0xFF	; 255
    59b0:	0e 94 48 2a 	call	0x5490	; 0x5490 <prvProcessExpiredTimer>

        /* The tick count has overflowed.  The timer lists must be switched.
         * If there are any timers still referenced from the current timer list
         * then they must have expired and should be processed before the lists
         * are switched. */
        while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    59b4:	e0 91 1c 07 	lds	r30, 0x071C
    59b8:	f0 91 1d 07 	lds	r31, 0x071D
    59bc:	80 81       	ld	r24, Z
    59be:	88 23       	and	r24, r24
    59c0:	41 f7       	brne	.-48     	; 0x5992 <prvSwitchTimerLists+0xe>
             * process only expirations that occur on the current list.  Further
             * expirations must wait until after the lists are switched. */
            prvProcessExpiredTimer( xNextExpireTime, tmrMAX_TIME_BEFORE_OVERFLOW );
        }

        pxTemp = pxCurrentTimerList;
    59c2:	80 91 1c 07 	lds	r24, 0x071C
    59c6:	90 91 1d 07 	lds	r25, 0x071D
    59ca:	9a 83       	std	Y+2, r25	; 0x02
    59cc:	89 83       	std	Y+1, r24	; 0x01
        pxCurrentTimerList = pxOverflowTimerList;
    59ce:	80 91 1e 07 	lds	r24, 0x071E
    59d2:	90 91 1f 07 	lds	r25, 0x071F
    59d6:	90 93 1d 07 	sts	0x071D, r25
    59da:	80 93 1c 07 	sts	0x071C, r24
        pxOverflowTimerList = pxTemp;
    59de:	89 81       	ldd	r24, Y+1	; 0x01
    59e0:	9a 81       	ldd	r25, Y+2	; 0x02
    59e2:	90 93 1f 07 	sts	0x071F, r25
    59e6:	80 93 1e 07 	sts	0x071E, r24
    }
    59ea:	0f 90       	pop	r0
    59ec:	0f 90       	pop	r0
    59ee:	0f 90       	pop	r0
    59f0:	0f 90       	pop	r0
    59f2:	cf 91       	pop	r28
    59f4:	df 91       	pop	r29
    59f6:	08 95       	ret

000059f8 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

    static void prvCheckForValidListAndQueue( void )
    {
    59f8:	df 93       	push	r29
    59fa:	cf 93       	push	r28
    59fc:	cd b7       	in	r28, 0x3d	; 61
    59fe:	de b7       	in	r29, 0x3e	; 62
        /* Check that the list from which active timers are referenced, and the
         * queue used to communicate with the timer service, have been
         * initialised. */
        taskENTER_CRITICAL();
    5a00:	0f b6       	in	r0, 0x3f	; 63
    5a02:	f8 94       	cli
    5a04:	0f 92       	push	r0
        {
            if( xTimerQueue == NULL )
    5a06:	80 91 04 07 	lds	r24, 0x0704
    5a0a:	90 91 05 07 	lds	r25, 0x0705
    5a0e:	00 97       	sbiw	r24, 0x00	; 0
    5a10:	e9 f4       	brne	.+58     	; 0x5a4c <prvCheckForValidListAndQueue+0x54>
            {
                vListInitialise( &xActiveTimerList1 );
    5a12:	8a e0       	ldi	r24, 0x0A	; 10
    5a14:	97 e0       	ldi	r25, 0x07	; 7
    5a16:	0e 94 c1 09 	call	0x1382	; 0x1382 <vListInitialise>
                vListInitialise( &xActiveTimerList2 );
    5a1a:	83 e1       	ldi	r24, 0x13	; 19
    5a1c:	97 e0       	ldi	r25, 0x07	; 7
    5a1e:	0e 94 c1 09 	call	0x1382	; 0x1382 <vListInitialise>
                pxCurrentTimerList = &xActiveTimerList1;
    5a22:	8a e0       	ldi	r24, 0x0A	; 10
    5a24:	97 e0       	ldi	r25, 0x07	; 7
    5a26:	90 93 1d 07 	sts	0x071D, r25
    5a2a:	80 93 1c 07 	sts	0x071C, r24
                pxOverflowTimerList = &xActiveTimerList2;
    5a2e:	83 e1       	ldi	r24, 0x13	; 19
    5a30:	97 e0       	ldi	r25, 0x07	; 7
    5a32:	90 93 1f 07 	sts	0x071F, r25
    5a36:	80 93 1e 07 	sts	0x071E, r24

                        xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
                    }
                #else
                    {
                        xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    5a3a:	8a e0       	ldi	r24, 0x0A	; 10
    5a3c:	65 e0       	ldi	r22, 0x05	; 5
    5a3e:	40 e0       	ldi	r20, 0x00	; 0
    5a40:	0e 94 a2 0b 	call	0x1744	; 0x1744 <xQueueGenericCreate>
    5a44:	90 93 05 07 	sts	0x0705, r25
    5a48:	80 93 04 07 	sts	0x0704, r24
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    5a4c:	0f 90       	pop	r0
    5a4e:	0f be       	out	0x3f, r0	; 63
    }
    5a50:	cf 91       	pop	r28
    5a52:	df 91       	pop	r29
    5a54:	08 95       	ret

00005a56 <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

    BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
    {
    5a56:	df 93       	push	r29
    5a58:	cf 93       	push	r28
    5a5a:	00 d0       	rcall	.+0      	; 0x5a5c <xTimerIsTimerActive+0x6>
    5a5c:	00 d0       	rcall	.+0      	; 0x5a5e <xTimerIsTimerActive+0x8>
    5a5e:	0f 92       	push	r0
    5a60:	cd b7       	in	r28, 0x3d	; 61
    5a62:	de b7       	in	r29, 0x3e	; 62
    5a64:	9d 83       	std	Y+5, r25	; 0x05
    5a66:	8c 83       	std	Y+4, r24	; 0x04
        BaseType_t xReturn;
        Timer_t * pxTimer = xTimer;
    5a68:	8c 81       	ldd	r24, Y+4	; 0x04
    5a6a:	9d 81       	ldd	r25, Y+5	; 0x05
    5a6c:	9a 83       	std	Y+2, r25	; 0x02
    5a6e:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        /* Is the timer in the list of active timers? */
        taskENTER_CRITICAL();
    5a70:	0f b6       	in	r0, 0x3f	; 63
    5a72:	f8 94       	cli
    5a74:	0f 92       	push	r0
        {
            if( ( pxTimer->ucStatus & tmrSTATUS_IS_ACTIVE ) == 0 )
    5a76:	e9 81       	ldd	r30, Y+1	; 0x01
    5a78:	fa 81       	ldd	r31, Y+2	; 0x02
    5a7a:	82 89       	ldd	r24, Z+18	; 0x12
    5a7c:	88 2f       	mov	r24, r24
    5a7e:	90 e0       	ldi	r25, 0x00	; 0
    5a80:	81 70       	andi	r24, 0x01	; 1
    5a82:	90 70       	andi	r25, 0x00	; 0
    5a84:	00 97       	sbiw	r24, 0x00	; 0
    5a86:	11 f4       	brne	.+4      	; 0x5a8c <xTimerIsTimerActive+0x36>
            {
                xReturn = pdFALSE;
    5a88:	1b 82       	std	Y+3, r1	; 0x03
    5a8a:	02 c0       	rjmp	.+4      	; 0x5a90 <xTimerIsTimerActive+0x3a>
            }
            else
            {
                xReturn = pdTRUE;
    5a8c:	81 e0       	ldi	r24, 0x01	; 1
    5a8e:	8b 83       	std	Y+3, r24	; 0x03
            }
        }
        taskEXIT_CRITICAL();
    5a90:	0f 90       	pop	r0
    5a92:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    5a94:	8b 81       	ldd	r24, Y+3	; 0x03
    } /*lint !e818 Can't be pointer to const due to the typedef. */
    5a96:	0f 90       	pop	r0
    5a98:	0f 90       	pop	r0
    5a9a:	0f 90       	pop	r0
    5a9c:	0f 90       	pop	r0
    5a9e:	0f 90       	pop	r0
    5aa0:	cf 91       	pop	r28
    5aa2:	df 91       	pop	r29
    5aa4:	08 95       	ret

00005aa6 <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

    void * pvTimerGetTimerID( const TimerHandle_t xTimer )
    {
    5aa6:	df 93       	push	r29
    5aa8:	cf 93       	push	r28
    5aaa:	00 d0       	rcall	.+0      	; 0x5aac <pvTimerGetTimerID+0x6>
    5aac:	00 d0       	rcall	.+0      	; 0x5aae <pvTimerGetTimerID+0x8>
    5aae:	00 d0       	rcall	.+0      	; 0x5ab0 <pvTimerGetTimerID+0xa>
    5ab0:	cd b7       	in	r28, 0x3d	; 61
    5ab2:	de b7       	in	r29, 0x3e	; 62
    5ab4:	9e 83       	std	Y+6, r25	; 0x06
    5ab6:	8d 83       	std	Y+5, r24	; 0x05
        Timer_t * const pxTimer = xTimer;
    5ab8:	8d 81       	ldd	r24, Y+5	; 0x05
    5aba:	9e 81       	ldd	r25, Y+6	; 0x06
    5abc:	9c 83       	std	Y+4, r25	; 0x04
    5abe:	8b 83       	std	Y+3, r24	; 0x03
        void * pvReturn;

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    5ac0:	0f b6       	in	r0, 0x3f	; 63
    5ac2:	f8 94       	cli
    5ac4:	0f 92       	push	r0
        {
            pvReturn = pxTimer->pvTimerID;
    5ac6:	eb 81       	ldd	r30, Y+3	; 0x03
    5ac8:	fc 81       	ldd	r31, Y+4	; 0x04
    5aca:	86 85       	ldd	r24, Z+14	; 0x0e
    5acc:	97 85       	ldd	r25, Z+15	; 0x0f
    5ace:	9a 83       	std	Y+2, r25	; 0x02
    5ad0:	89 83       	std	Y+1, r24	; 0x01
        }
        taskEXIT_CRITICAL();
    5ad2:	0f 90       	pop	r0
    5ad4:	0f be       	out	0x3f, r0	; 63

        return pvReturn;
    5ad6:	89 81       	ldd	r24, Y+1	; 0x01
    5ad8:	9a 81       	ldd	r25, Y+2	; 0x02
    }
    5ada:	26 96       	adiw	r28, 0x06	; 6
    5adc:	0f b6       	in	r0, 0x3f	; 63
    5ade:	f8 94       	cli
    5ae0:	de bf       	out	0x3e, r29	; 62
    5ae2:	0f be       	out	0x3f, r0	; 63
    5ae4:	cd bf       	out	0x3d, r28	; 61
    5ae6:	cf 91       	pop	r28
    5ae8:	df 91       	pop	r29
    5aea:	08 95       	ret

00005aec <vTimerSetTimerID>:
/*-----------------------------------------------------------*/

    void vTimerSetTimerID( TimerHandle_t xTimer,
                           void * pvNewID )
    {
    5aec:	df 93       	push	r29
    5aee:	cf 93       	push	r28
    5af0:	00 d0       	rcall	.+0      	; 0x5af2 <vTimerSetTimerID+0x6>
    5af2:	00 d0       	rcall	.+0      	; 0x5af4 <vTimerSetTimerID+0x8>
    5af4:	00 d0       	rcall	.+0      	; 0x5af6 <vTimerSetTimerID+0xa>
    5af6:	cd b7       	in	r28, 0x3d	; 61
    5af8:	de b7       	in	r29, 0x3e	; 62
    5afa:	9c 83       	std	Y+4, r25	; 0x04
    5afc:	8b 83       	std	Y+3, r24	; 0x03
    5afe:	7e 83       	std	Y+6, r23	; 0x06
    5b00:	6d 83       	std	Y+5, r22	; 0x05
        Timer_t * const pxTimer = xTimer;
    5b02:	8b 81       	ldd	r24, Y+3	; 0x03
    5b04:	9c 81       	ldd	r25, Y+4	; 0x04
    5b06:	9a 83       	std	Y+2, r25	; 0x02
    5b08:	89 83       	std	Y+1, r24	; 0x01

        configASSERT( xTimer );

        taskENTER_CRITICAL();
    5b0a:	0f b6       	in	r0, 0x3f	; 63
    5b0c:	f8 94       	cli
    5b0e:	0f 92       	push	r0
        {
            pxTimer->pvTimerID = pvNewID;
    5b10:	e9 81       	ldd	r30, Y+1	; 0x01
    5b12:	fa 81       	ldd	r31, Y+2	; 0x02
    5b14:	8d 81       	ldd	r24, Y+5	; 0x05
    5b16:	9e 81       	ldd	r25, Y+6	; 0x06
    5b18:	97 87       	std	Z+15, r25	; 0x0f
    5b1a:	86 87       	std	Z+14, r24	; 0x0e
        }
        taskEXIT_CRITICAL();
    5b1c:	0f 90       	pop	r0
    5b1e:	0f be       	out	0x3f, r0	; 63
    }
    5b20:	26 96       	adiw	r28, 0x06	; 6
    5b22:	0f b6       	in	r0, 0x3f	; 63
    5b24:	f8 94       	cli
    5b26:	de bf       	out	0x3e, r29	; 62
    5b28:	0f be       	out	0x3f, r0	; 63
    5b2a:	cd bf       	out	0x3d, r28	; 61
    5b2c:	cf 91       	pop	r28
    5b2e:	df 91       	pop	r29
    5b30:	08 95       	ret

00005b32 <DIO_SetPinDir>:


#include "DIO.h"

void DIO_SetPinDir(uint8_t port ,uint8_t pin, uint8_t dir)
{
    5b32:	df 93       	push	r29
    5b34:	cf 93       	push	r28
    5b36:	cd b7       	in	r28, 0x3d	; 61
    5b38:	de b7       	in	r29, 0x3e	; 62
    5b3a:	2d 97       	sbiw	r28, 0x0d	; 13
    5b3c:	0f b6       	in	r0, 0x3f	; 63
    5b3e:	f8 94       	cli
    5b40:	de bf       	out	0x3e, r29	; 62
    5b42:	0f be       	out	0x3f, r0	; 63
    5b44:	cd bf       	out	0x3d, r28	; 61
    5b46:	89 83       	std	Y+1, r24	; 0x01
    5b48:	6a 83       	std	Y+2, r22	; 0x02
    5b4a:	4b 83       	std	Y+3, r20	; 0x03
	switch (port)
    5b4c:	89 81       	ldd	r24, Y+1	; 0x01
    5b4e:	28 2f       	mov	r18, r24
    5b50:	30 e0       	ldi	r19, 0x00	; 0
    5b52:	3d 87       	std	Y+13, r19	; 0x0d
    5b54:	2c 87       	std	Y+12, r18	; 0x0c
    5b56:	8c 85       	ldd	r24, Y+12	; 0x0c
    5b58:	9d 85       	ldd	r25, Y+13	; 0x0d
    5b5a:	81 30       	cpi	r24, 0x01	; 1
    5b5c:	91 05       	cpc	r25, r1
    5b5e:	09 f4       	brne	.+2      	; 0x5b62 <DIO_SetPinDir+0x30>
    5b60:	44 c0       	rjmp	.+136    	; 0x5bea <DIO_SetPinDir+0xb8>
    5b62:	2c 85       	ldd	r18, Y+12	; 0x0c
    5b64:	3d 85       	ldd	r19, Y+13	; 0x0d
    5b66:	22 30       	cpi	r18, 0x02	; 2
    5b68:	31 05       	cpc	r19, r1
    5b6a:	2c f4       	brge	.+10     	; 0x5b76 <DIO_SetPinDir+0x44>
    5b6c:	8c 85       	ldd	r24, Y+12	; 0x0c
    5b6e:	9d 85       	ldd	r25, Y+13	; 0x0d
    5b70:	00 97       	sbiw	r24, 0x00	; 0
    5b72:	71 f0       	breq	.+28     	; 0x5b90 <DIO_SetPinDir+0x5e>
    5b74:	c2 c0       	rjmp	.+388    	; 0x5cfa <DIO_SetPinDir+0x1c8>
    5b76:	2c 85       	ldd	r18, Y+12	; 0x0c
    5b78:	3d 85       	ldd	r19, Y+13	; 0x0d
    5b7a:	22 30       	cpi	r18, 0x02	; 2
    5b7c:	31 05       	cpc	r19, r1
    5b7e:	09 f4       	brne	.+2      	; 0x5b82 <DIO_SetPinDir+0x50>
    5b80:	62 c0       	rjmp	.+196    	; 0x5c46 <DIO_SetPinDir+0x114>
    5b82:	8c 85       	ldd	r24, Y+12	; 0x0c
    5b84:	9d 85       	ldd	r25, Y+13	; 0x0d
    5b86:	83 30       	cpi	r24, 0x03	; 3
    5b88:	91 05       	cpc	r25, r1
    5b8a:	09 f4       	brne	.+2      	; 0x5b8e <DIO_SetPinDir+0x5c>
    5b8c:	89 c0       	rjmp	.+274    	; 0x5ca0 <DIO_SetPinDir+0x16e>
    5b8e:	b5 c0       	rjmp	.+362    	; 0x5cfa <DIO_SetPinDir+0x1c8>
	{
		case DIO_PORTA:
		(dir == OUTPUT)? (SET_BIT(DDRA,pin)):(CLR_BIT(DDRA,pin));
    5b90:	8b 81       	ldd	r24, Y+3	; 0x03
    5b92:	83 30       	cpi	r24, 0x03	; 3
    5b94:	a9 f4       	brne	.+42     	; 0x5bc0 <DIO_SetPinDir+0x8e>
    5b96:	aa e3       	ldi	r26, 0x3A	; 58
    5b98:	b0 e0       	ldi	r27, 0x00	; 0
    5b9a:	ea e3       	ldi	r30, 0x3A	; 58
    5b9c:	f0 e0       	ldi	r31, 0x00	; 0
    5b9e:	80 81       	ld	r24, Z
    5ba0:	48 2f       	mov	r20, r24
    5ba2:	8a 81       	ldd	r24, Y+2	; 0x02
    5ba4:	28 2f       	mov	r18, r24
    5ba6:	30 e0       	ldi	r19, 0x00	; 0
    5ba8:	81 e0       	ldi	r24, 0x01	; 1
    5baa:	90 e0       	ldi	r25, 0x00	; 0
    5bac:	02 2e       	mov	r0, r18
    5bae:	02 c0       	rjmp	.+4      	; 0x5bb4 <DIO_SetPinDir+0x82>
    5bb0:	88 0f       	add	r24, r24
    5bb2:	99 1f       	adc	r25, r25
    5bb4:	0a 94       	dec	r0
    5bb6:	e2 f7       	brpl	.-8      	; 0x5bb0 <DIO_SetPinDir+0x7e>
    5bb8:	84 2b       	or	r24, r20
    5bba:	8c 93       	st	X, r24
    5bbc:	9c 91       	ld	r25, X
    5bbe:	9d c0       	rjmp	.+314    	; 0x5cfa <DIO_SetPinDir+0x1c8>
    5bc0:	aa e3       	ldi	r26, 0x3A	; 58
    5bc2:	b0 e0       	ldi	r27, 0x00	; 0
    5bc4:	ea e3       	ldi	r30, 0x3A	; 58
    5bc6:	f0 e0       	ldi	r31, 0x00	; 0
    5bc8:	80 81       	ld	r24, Z
    5bca:	48 2f       	mov	r20, r24
    5bcc:	8a 81       	ldd	r24, Y+2	; 0x02
    5bce:	28 2f       	mov	r18, r24
    5bd0:	30 e0       	ldi	r19, 0x00	; 0
    5bd2:	81 e0       	ldi	r24, 0x01	; 1
    5bd4:	90 e0       	ldi	r25, 0x00	; 0
    5bd6:	02 c0       	rjmp	.+4      	; 0x5bdc <DIO_SetPinDir+0xaa>
    5bd8:	88 0f       	add	r24, r24
    5bda:	99 1f       	adc	r25, r25
    5bdc:	2a 95       	dec	r18
    5bde:	e2 f7       	brpl	.-8      	; 0x5bd8 <DIO_SetPinDir+0xa6>
    5be0:	80 95       	com	r24
    5be2:	84 23       	and	r24, r20
    5be4:	8c 93       	st	X, r24
    5be6:	2c 91       	ld	r18, X
    5be8:	88 c0       	rjmp	.+272    	; 0x5cfa <DIO_SetPinDir+0x1c8>
		break;

		case DIO_PORTB:
		(dir == OUTPUT)? (SET_BIT(DDRB,pin)):(CLR_BIT(DDRB,pin));
    5bea:	8b 81       	ldd	r24, Y+3	; 0x03
    5bec:	83 30       	cpi	r24, 0x03	; 3
    5bee:	a9 f4       	brne	.+42     	; 0x5c1a <DIO_SetPinDir+0xe8>
    5bf0:	a7 e3       	ldi	r26, 0x37	; 55
    5bf2:	b0 e0       	ldi	r27, 0x00	; 0
    5bf4:	e7 e3       	ldi	r30, 0x37	; 55
    5bf6:	f0 e0       	ldi	r31, 0x00	; 0
    5bf8:	80 81       	ld	r24, Z
    5bfa:	48 2f       	mov	r20, r24
    5bfc:	8a 81       	ldd	r24, Y+2	; 0x02
    5bfe:	28 2f       	mov	r18, r24
    5c00:	30 e0       	ldi	r19, 0x00	; 0
    5c02:	81 e0       	ldi	r24, 0x01	; 1
    5c04:	90 e0       	ldi	r25, 0x00	; 0
    5c06:	02 2e       	mov	r0, r18
    5c08:	02 c0       	rjmp	.+4      	; 0x5c0e <DIO_SetPinDir+0xdc>
    5c0a:	88 0f       	add	r24, r24
    5c0c:	99 1f       	adc	r25, r25
    5c0e:	0a 94       	dec	r0
    5c10:	e2 f7       	brpl	.-8      	; 0x5c0a <DIO_SetPinDir+0xd8>
    5c12:	84 2b       	or	r24, r20
    5c14:	8c 93       	st	X, r24
    5c16:	3c 91       	ld	r19, X
    5c18:	70 c0       	rjmp	.+224    	; 0x5cfa <DIO_SetPinDir+0x1c8>
    5c1a:	a7 e3       	ldi	r26, 0x37	; 55
    5c1c:	b0 e0       	ldi	r27, 0x00	; 0
    5c1e:	e7 e3       	ldi	r30, 0x37	; 55
    5c20:	f0 e0       	ldi	r31, 0x00	; 0
    5c22:	80 81       	ld	r24, Z
    5c24:	48 2f       	mov	r20, r24
    5c26:	8a 81       	ldd	r24, Y+2	; 0x02
    5c28:	28 2f       	mov	r18, r24
    5c2a:	30 e0       	ldi	r19, 0x00	; 0
    5c2c:	81 e0       	ldi	r24, 0x01	; 1
    5c2e:	90 e0       	ldi	r25, 0x00	; 0
    5c30:	02 2e       	mov	r0, r18
    5c32:	02 c0       	rjmp	.+4      	; 0x5c38 <DIO_SetPinDir+0x106>
    5c34:	88 0f       	add	r24, r24
    5c36:	99 1f       	adc	r25, r25
    5c38:	0a 94       	dec	r0
    5c3a:	e2 f7       	brpl	.-8      	; 0x5c34 <DIO_SetPinDir+0x102>
    5c3c:	80 95       	com	r24
    5c3e:	84 23       	and	r24, r20
    5c40:	8c 93       	st	X, r24
    5c42:	8c 91       	ld	r24, X
    5c44:	5a c0       	rjmp	.+180    	; 0x5cfa <DIO_SetPinDir+0x1c8>
		break;

		case DIO_PORTC:
		(dir == OUTPUT)? (SET_BIT(DDRC,pin)):(CLR_BIT(DDRC,pin));
    5c46:	8b 81       	ldd	r24, Y+3	; 0x03
    5c48:	83 30       	cpi	r24, 0x03	; 3
    5c4a:	a9 f4       	brne	.+42     	; 0x5c76 <DIO_SetPinDir+0x144>
    5c4c:	a4 e3       	ldi	r26, 0x34	; 52
    5c4e:	b0 e0       	ldi	r27, 0x00	; 0
    5c50:	e4 e3       	ldi	r30, 0x34	; 52
    5c52:	f0 e0       	ldi	r31, 0x00	; 0
    5c54:	80 81       	ld	r24, Z
    5c56:	48 2f       	mov	r20, r24
    5c58:	8a 81       	ldd	r24, Y+2	; 0x02
    5c5a:	28 2f       	mov	r18, r24
    5c5c:	30 e0       	ldi	r19, 0x00	; 0
    5c5e:	81 e0       	ldi	r24, 0x01	; 1
    5c60:	90 e0       	ldi	r25, 0x00	; 0
    5c62:	02 2e       	mov	r0, r18
    5c64:	02 c0       	rjmp	.+4      	; 0x5c6a <DIO_SetPinDir+0x138>
    5c66:	88 0f       	add	r24, r24
    5c68:	99 1f       	adc	r25, r25
    5c6a:	0a 94       	dec	r0
    5c6c:	e2 f7       	brpl	.-8      	; 0x5c66 <DIO_SetPinDir+0x134>
    5c6e:	84 2b       	or	r24, r20
    5c70:	8c 93       	st	X, r24
    5c72:	9c 91       	ld	r25, X
    5c74:	42 c0       	rjmp	.+132    	; 0x5cfa <DIO_SetPinDir+0x1c8>
    5c76:	a4 e3       	ldi	r26, 0x34	; 52
    5c78:	b0 e0       	ldi	r27, 0x00	; 0
    5c7a:	e4 e3       	ldi	r30, 0x34	; 52
    5c7c:	f0 e0       	ldi	r31, 0x00	; 0
    5c7e:	80 81       	ld	r24, Z
    5c80:	48 2f       	mov	r20, r24
    5c82:	8a 81       	ldd	r24, Y+2	; 0x02
    5c84:	28 2f       	mov	r18, r24
    5c86:	30 e0       	ldi	r19, 0x00	; 0
    5c88:	81 e0       	ldi	r24, 0x01	; 1
    5c8a:	90 e0       	ldi	r25, 0x00	; 0
    5c8c:	02 c0       	rjmp	.+4      	; 0x5c92 <DIO_SetPinDir+0x160>
    5c8e:	88 0f       	add	r24, r24
    5c90:	99 1f       	adc	r25, r25
    5c92:	2a 95       	dec	r18
    5c94:	e2 f7       	brpl	.-8      	; 0x5c8e <DIO_SetPinDir+0x15c>
    5c96:	80 95       	com	r24
    5c98:	84 23       	and	r24, r20
    5c9a:	8c 93       	st	X, r24
    5c9c:	2c 91       	ld	r18, X
    5c9e:	2d c0       	rjmp	.+90     	; 0x5cfa <DIO_SetPinDir+0x1c8>
		break;

		case DIO_PORTD:
		(dir == OUTPUT)? (SET_BIT(DDRD,pin)):(CLR_BIT(DDRD,pin));
    5ca0:	8b 81       	ldd	r24, Y+3	; 0x03
    5ca2:	83 30       	cpi	r24, 0x03	; 3
    5ca4:	a9 f4       	brne	.+42     	; 0x5cd0 <DIO_SetPinDir+0x19e>
    5ca6:	a1 e3       	ldi	r26, 0x31	; 49
    5ca8:	b0 e0       	ldi	r27, 0x00	; 0
    5caa:	e1 e3       	ldi	r30, 0x31	; 49
    5cac:	f0 e0       	ldi	r31, 0x00	; 0
    5cae:	80 81       	ld	r24, Z
    5cb0:	48 2f       	mov	r20, r24
    5cb2:	8a 81       	ldd	r24, Y+2	; 0x02
    5cb4:	28 2f       	mov	r18, r24
    5cb6:	30 e0       	ldi	r19, 0x00	; 0
    5cb8:	81 e0       	ldi	r24, 0x01	; 1
    5cba:	90 e0       	ldi	r25, 0x00	; 0
    5cbc:	02 2e       	mov	r0, r18
    5cbe:	02 c0       	rjmp	.+4      	; 0x5cc4 <DIO_SetPinDir+0x192>
    5cc0:	88 0f       	add	r24, r24
    5cc2:	99 1f       	adc	r25, r25
    5cc4:	0a 94       	dec	r0
    5cc6:	e2 f7       	brpl	.-8      	; 0x5cc0 <DIO_SetPinDir+0x18e>
    5cc8:	84 2b       	or	r24, r20
    5cca:	8c 93       	st	X, r24
    5ccc:	3c 91       	ld	r19, X
    5cce:	15 c0       	rjmp	.+42     	; 0x5cfa <DIO_SetPinDir+0x1c8>
    5cd0:	a1 e3       	ldi	r26, 0x31	; 49
    5cd2:	b0 e0       	ldi	r27, 0x00	; 0
    5cd4:	e1 e3       	ldi	r30, 0x31	; 49
    5cd6:	f0 e0       	ldi	r31, 0x00	; 0
    5cd8:	80 81       	ld	r24, Z
    5cda:	48 2f       	mov	r20, r24
    5cdc:	8a 81       	ldd	r24, Y+2	; 0x02
    5cde:	28 2f       	mov	r18, r24
    5ce0:	30 e0       	ldi	r19, 0x00	; 0
    5ce2:	81 e0       	ldi	r24, 0x01	; 1
    5ce4:	90 e0       	ldi	r25, 0x00	; 0
    5ce6:	02 2e       	mov	r0, r18
    5ce8:	02 c0       	rjmp	.+4      	; 0x5cee <DIO_SetPinDir+0x1bc>
    5cea:	88 0f       	add	r24, r24
    5cec:	99 1f       	adc	r25, r25
    5cee:	0a 94       	dec	r0
    5cf0:	e2 f7       	brpl	.-8      	; 0x5cea <DIO_SetPinDir+0x1b8>
    5cf2:	80 95       	com	r24
    5cf4:	84 23       	and	r24, r20
    5cf6:	8c 93       	st	X, r24
    5cf8:	8c 91       	ld	r24, X
		break;
	}
}
    5cfa:	2d 96       	adiw	r28, 0x0d	; 13
    5cfc:	0f b6       	in	r0, 0x3f	; 63
    5cfe:	f8 94       	cli
    5d00:	de bf       	out	0x3e, r29	; 62
    5d02:	0f be       	out	0x3f, r0	; 63
    5d04:	cd bf       	out	0x3d, r28	; 61
    5d06:	cf 91       	pop	r28
    5d08:	df 91       	pop	r29
    5d0a:	08 95       	ret

00005d0c <DIO_SetPinVal>:


void DIO_SetPinVal(uint8_t port ,uint8_t pin , uint8_t val)
{
    5d0c:	df 93       	push	r29
    5d0e:	cf 93       	push	r28
    5d10:	cd b7       	in	r28, 0x3d	; 61
    5d12:	de b7       	in	r29, 0x3e	; 62
    5d14:	2d 97       	sbiw	r28, 0x0d	; 13
    5d16:	0f b6       	in	r0, 0x3f	; 63
    5d18:	f8 94       	cli
    5d1a:	de bf       	out	0x3e, r29	; 62
    5d1c:	0f be       	out	0x3f, r0	; 63
    5d1e:	cd bf       	out	0x3d, r28	; 61
    5d20:	89 83       	std	Y+1, r24	; 0x01
    5d22:	6a 83       	std	Y+2, r22	; 0x02
    5d24:	4b 83       	std	Y+3, r20	; 0x03
	switch (port)
    5d26:	89 81       	ldd	r24, Y+1	; 0x01
    5d28:	28 2f       	mov	r18, r24
    5d2a:	30 e0       	ldi	r19, 0x00	; 0
    5d2c:	3d 87       	std	Y+13, r19	; 0x0d
    5d2e:	2c 87       	std	Y+12, r18	; 0x0c
    5d30:	8c 85       	ldd	r24, Y+12	; 0x0c
    5d32:	9d 85       	ldd	r25, Y+13	; 0x0d
    5d34:	81 30       	cpi	r24, 0x01	; 1
    5d36:	91 05       	cpc	r25, r1
    5d38:	09 f4       	brne	.+2      	; 0x5d3c <DIO_SetPinVal+0x30>
    5d3a:	44 c0       	rjmp	.+136    	; 0x5dc4 <DIO_SetPinVal+0xb8>
    5d3c:	2c 85       	ldd	r18, Y+12	; 0x0c
    5d3e:	3d 85       	ldd	r19, Y+13	; 0x0d
    5d40:	22 30       	cpi	r18, 0x02	; 2
    5d42:	31 05       	cpc	r19, r1
    5d44:	2c f4       	brge	.+10     	; 0x5d50 <DIO_SetPinVal+0x44>
    5d46:	8c 85       	ldd	r24, Y+12	; 0x0c
    5d48:	9d 85       	ldd	r25, Y+13	; 0x0d
    5d4a:	00 97       	sbiw	r24, 0x00	; 0
    5d4c:	71 f0       	breq	.+28     	; 0x5d6a <DIO_SetPinVal+0x5e>
    5d4e:	c2 c0       	rjmp	.+388    	; 0x5ed4 <DIO_SetPinVal+0x1c8>
    5d50:	2c 85       	ldd	r18, Y+12	; 0x0c
    5d52:	3d 85       	ldd	r19, Y+13	; 0x0d
    5d54:	22 30       	cpi	r18, 0x02	; 2
    5d56:	31 05       	cpc	r19, r1
    5d58:	09 f4       	brne	.+2      	; 0x5d5c <DIO_SetPinVal+0x50>
    5d5a:	62 c0       	rjmp	.+196    	; 0x5e20 <DIO_SetPinVal+0x114>
    5d5c:	8c 85       	ldd	r24, Y+12	; 0x0c
    5d5e:	9d 85       	ldd	r25, Y+13	; 0x0d
    5d60:	83 30       	cpi	r24, 0x03	; 3
    5d62:	91 05       	cpc	r25, r1
    5d64:	09 f4       	brne	.+2      	; 0x5d68 <DIO_SetPinVal+0x5c>
    5d66:	89 c0       	rjmp	.+274    	; 0x5e7a <DIO_SetPinVal+0x16e>
    5d68:	b5 c0       	rjmp	.+362    	; 0x5ed4 <DIO_SetPinVal+0x1c8>
	{
		case DIO_PORTA:
		(val == HIGH)? (SET_BIT(PORTA,pin)):(CLR_BIT(PORTA,pin));
    5d6a:	8b 81       	ldd	r24, Y+3	; 0x03
    5d6c:	81 30       	cpi	r24, 0x01	; 1
    5d6e:	a9 f4       	brne	.+42     	; 0x5d9a <DIO_SetPinVal+0x8e>
    5d70:	ab e3       	ldi	r26, 0x3B	; 59
    5d72:	b0 e0       	ldi	r27, 0x00	; 0
    5d74:	eb e3       	ldi	r30, 0x3B	; 59
    5d76:	f0 e0       	ldi	r31, 0x00	; 0
    5d78:	80 81       	ld	r24, Z
    5d7a:	48 2f       	mov	r20, r24
    5d7c:	8a 81       	ldd	r24, Y+2	; 0x02
    5d7e:	28 2f       	mov	r18, r24
    5d80:	30 e0       	ldi	r19, 0x00	; 0
    5d82:	81 e0       	ldi	r24, 0x01	; 1
    5d84:	90 e0       	ldi	r25, 0x00	; 0
    5d86:	02 2e       	mov	r0, r18
    5d88:	02 c0       	rjmp	.+4      	; 0x5d8e <DIO_SetPinVal+0x82>
    5d8a:	88 0f       	add	r24, r24
    5d8c:	99 1f       	adc	r25, r25
    5d8e:	0a 94       	dec	r0
    5d90:	e2 f7       	brpl	.-8      	; 0x5d8a <DIO_SetPinVal+0x7e>
    5d92:	84 2b       	or	r24, r20
    5d94:	8c 93       	st	X, r24
    5d96:	9c 91       	ld	r25, X
    5d98:	9d c0       	rjmp	.+314    	; 0x5ed4 <DIO_SetPinVal+0x1c8>
    5d9a:	ab e3       	ldi	r26, 0x3B	; 59
    5d9c:	b0 e0       	ldi	r27, 0x00	; 0
    5d9e:	eb e3       	ldi	r30, 0x3B	; 59
    5da0:	f0 e0       	ldi	r31, 0x00	; 0
    5da2:	80 81       	ld	r24, Z
    5da4:	48 2f       	mov	r20, r24
    5da6:	8a 81       	ldd	r24, Y+2	; 0x02
    5da8:	28 2f       	mov	r18, r24
    5daa:	30 e0       	ldi	r19, 0x00	; 0
    5dac:	81 e0       	ldi	r24, 0x01	; 1
    5dae:	90 e0       	ldi	r25, 0x00	; 0
    5db0:	02 c0       	rjmp	.+4      	; 0x5db6 <DIO_SetPinVal+0xaa>
    5db2:	88 0f       	add	r24, r24
    5db4:	99 1f       	adc	r25, r25
    5db6:	2a 95       	dec	r18
    5db8:	e2 f7       	brpl	.-8      	; 0x5db2 <DIO_SetPinVal+0xa6>
    5dba:	80 95       	com	r24
    5dbc:	84 23       	and	r24, r20
    5dbe:	8c 93       	st	X, r24
    5dc0:	2c 91       	ld	r18, X
    5dc2:	88 c0       	rjmp	.+272    	; 0x5ed4 <DIO_SetPinVal+0x1c8>
		break;

		case DIO_PORTB:
		(val == HIGH)? (SET_BIT(PORTB,pin)):(CLR_BIT(PORTB,pin));
    5dc4:	8b 81       	ldd	r24, Y+3	; 0x03
    5dc6:	81 30       	cpi	r24, 0x01	; 1
    5dc8:	a9 f4       	brne	.+42     	; 0x5df4 <DIO_SetPinVal+0xe8>
    5dca:	a8 e3       	ldi	r26, 0x38	; 56
    5dcc:	b0 e0       	ldi	r27, 0x00	; 0
    5dce:	e8 e3       	ldi	r30, 0x38	; 56
    5dd0:	f0 e0       	ldi	r31, 0x00	; 0
    5dd2:	80 81       	ld	r24, Z
    5dd4:	48 2f       	mov	r20, r24
    5dd6:	8a 81       	ldd	r24, Y+2	; 0x02
    5dd8:	28 2f       	mov	r18, r24
    5dda:	30 e0       	ldi	r19, 0x00	; 0
    5ddc:	81 e0       	ldi	r24, 0x01	; 1
    5dde:	90 e0       	ldi	r25, 0x00	; 0
    5de0:	02 2e       	mov	r0, r18
    5de2:	02 c0       	rjmp	.+4      	; 0x5de8 <DIO_SetPinVal+0xdc>
    5de4:	88 0f       	add	r24, r24
    5de6:	99 1f       	adc	r25, r25
    5de8:	0a 94       	dec	r0
    5dea:	e2 f7       	brpl	.-8      	; 0x5de4 <DIO_SetPinVal+0xd8>
    5dec:	84 2b       	or	r24, r20
    5dee:	8c 93       	st	X, r24
    5df0:	3c 91       	ld	r19, X
    5df2:	70 c0       	rjmp	.+224    	; 0x5ed4 <DIO_SetPinVal+0x1c8>
    5df4:	a8 e3       	ldi	r26, 0x38	; 56
    5df6:	b0 e0       	ldi	r27, 0x00	; 0
    5df8:	e8 e3       	ldi	r30, 0x38	; 56
    5dfa:	f0 e0       	ldi	r31, 0x00	; 0
    5dfc:	80 81       	ld	r24, Z
    5dfe:	48 2f       	mov	r20, r24
    5e00:	8a 81       	ldd	r24, Y+2	; 0x02
    5e02:	28 2f       	mov	r18, r24
    5e04:	30 e0       	ldi	r19, 0x00	; 0
    5e06:	81 e0       	ldi	r24, 0x01	; 1
    5e08:	90 e0       	ldi	r25, 0x00	; 0
    5e0a:	02 2e       	mov	r0, r18
    5e0c:	02 c0       	rjmp	.+4      	; 0x5e12 <DIO_SetPinVal+0x106>
    5e0e:	88 0f       	add	r24, r24
    5e10:	99 1f       	adc	r25, r25
    5e12:	0a 94       	dec	r0
    5e14:	e2 f7       	brpl	.-8      	; 0x5e0e <DIO_SetPinVal+0x102>
    5e16:	80 95       	com	r24
    5e18:	84 23       	and	r24, r20
    5e1a:	8c 93       	st	X, r24
    5e1c:	8c 91       	ld	r24, X
    5e1e:	5a c0       	rjmp	.+180    	; 0x5ed4 <DIO_SetPinVal+0x1c8>
		break;

		case DIO_PORTC:
		(val == HIGH)? (SET_BIT(PORTC,pin)):(CLR_BIT(PORTC,pin));
    5e20:	8b 81       	ldd	r24, Y+3	; 0x03
    5e22:	81 30       	cpi	r24, 0x01	; 1
    5e24:	a9 f4       	brne	.+42     	; 0x5e50 <DIO_SetPinVal+0x144>
    5e26:	a5 e3       	ldi	r26, 0x35	; 53
    5e28:	b0 e0       	ldi	r27, 0x00	; 0
    5e2a:	e5 e3       	ldi	r30, 0x35	; 53
    5e2c:	f0 e0       	ldi	r31, 0x00	; 0
    5e2e:	80 81       	ld	r24, Z
    5e30:	48 2f       	mov	r20, r24
    5e32:	8a 81       	ldd	r24, Y+2	; 0x02
    5e34:	28 2f       	mov	r18, r24
    5e36:	30 e0       	ldi	r19, 0x00	; 0
    5e38:	81 e0       	ldi	r24, 0x01	; 1
    5e3a:	90 e0       	ldi	r25, 0x00	; 0
    5e3c:	02 2e       	mov	r0, r18
    5e3e:	02 c0       	rjmp	.+4      	; 0x5e44 <DIO_SetPinVal+0x138>
    5e40:	88 0f       	add	r24, r24
    5e42:	99 1f       	adc	r25, r25
    5e44:	0a 94       	dec	r0
    5e46:	e2 f7       	brpl	.-8      	; 0x5e40 <DIO_SetPinVal+0x134>
    5e48:	84 2b       	or	r24, r20
    5e4a:	8c 93       	st	X, r24
    5e4c:	9c 91       	ld	r25, X
    5e4e:	42 c0       	rjmp	.+132    	; 0x5ed4 <DIO_SetPinVal+0x1c8>
    5e50:	a5 e3       	ldi	r26, 0x35	; 53
    5e52:	b0 e0       	ldi	r27, 0x00	; 0
    5e54:	e5 e3       	ldi	r30, 0x35	; 53
    5e56:	f0 e0       	ldi	r31, 0x00	; 0
    5e58:	80 81       	ld	r24, Z
    5e5a:	48 2f       	mov	r20, r24
    5e5c:	8a 81       	ldd	r24, Y+2	; 0x02
    5e5e:	28 2f       	mov	r18, r24
    5e60:	30 e0       	ldi	r19, 0x00	; 0
    5e62:	81 e0       	ldi	r24, 0x01	; 1
    5e64:	90 e0       	ldi	r25, 0x00	; 0
    5e66:	02 c0       	rjmp	.+4      	; 0x5e6c <DIO_SetPinVal+0x160>
    5e68:	88 0f       	add	r24, r24
    5e6a:	99 1f       	adc	r25, r25
    5e6c:	2a 95       	dec	r18
    5e6e:	e2 f7       	brpl	.-8      	; 0x5e68 <DIO_SetPinVal+0x15c>
    5e70:	80 95       	com	r24
    5e72:	84 23       	and	r24, r20
    5e74:	8c 93       	st	X, r24
    5e76:	2c 91       	ld	r18, X
    5e78:	2d c0       	rjmp	.+90     	; 0x5ed4 <DIO_SetPinVal+0x1c8>
		break;

		case DIO_PORTD:
		(val == HIGH)? (SET_BIT(PORTD,pin)):(CLR_BIT(PORTD,pin));
    5e7a:	8b 81       	ldd	r24, Y+3	; 0x03
    5e7c:	81 30       	cpi	r24, 0x01	; 1
    5e7e:	a9 f4       	brne	.+42     	; 0x5eaa <DIO_SetPinVal+0x19e>
    5e80:	a2 e3       	ldi	r26, 0x32	; 50
    5e82:	b0 e0       	ldi	r27, 0x00	; 0
    5e84:	e2 e3       	ldi	r30, 0x32	; 50
    5e86:	f0 e0       	ldi	r31, 0x00	; 0
    5e88:	80 81       	ld	r24, Z
    5e8a:	48 2f       	mov	r20, r24
    5e8c:	8a 81       	ldd	r24, Y+2	; 0x02
    5e8e:	28 2f       	mov	r18, r24
    5e90:	30 e0       	ldi	r19, 0x00	; 0
    5e92:	81 e0       	ldi	r24, 0x01	; 1
    5e94:	90 e0       	ldi	r25, 0x00	; 0
    5e96:	02 2e       	mov	r0, r18
    5e98:	02 c0       	rjmp	.+4      	; 0x5e9e <DIO_SetPinVal+0x192>
    5e9a:	88 0f       	add	r24, r24
    5e9c:	99 1f       	adc	r25, r25
    5e9e:	0a 94       	dec	r0
    5ea0:	e2 f7       	brpl	.-8      	; 0x5e9a <DIO_SetPinVal+0x18e>
    5ea2:	84 2b       	or	r24, r20
    5ea4:	8c 93       	st	X, r24
    5ea6:	3c 91       	ld	r19, X
    5ea8:	15 c0       	rjmp	.+42     	; 0x5ed4 <DIO_SetPinVal+0x1c8>
    5eaa:	a2 e3       	ldi	r26, 0x32	; 50
    5eac:	b0 e0       	ldi	r27, 0x00	; 0
    5eae:	e2 e3       	ldi	r30, 0x32	; 50
    5eb0:	f0 e0       	ldi	r31, 0x00	; 0
    5eb2:	80 81       	ld	r24, Z
    5eb4:	48 2f       	mov	r20, r24
    5eb6:	8a 81       	ldd	r24, Y+2	; 0x02
    5eb8:	28 2f       	mov	r18, r24
    5eba:	30 e0       	ldi	r19, 0x00	; 0
    5ebc:	81 e0       	ldi	r24, 0x01	; 1
    5ebe:	90 e0       	ldi	r25, 0x00	; 0
    5ec0:	02 2e       	mov	r0, r18
    5ec2:	02 c0       	rjmp	.+4      	; 0x5ec8 <DIO_SetPinVal+0x1bc>
    5ec4:	88 0f       	add	r24, r24
    5ec6:	99 1f       	adc	r25, r25
    5ec8:	0a 94       	dec	r0
    5eca:	e2 f7       	brpl	.-8      	; 0x5ec4 <DIO_SetPinVal+0x1b8>
    5ecc:	80 95       	com	r24
    5ece:	84 23       	and	r24, r20
    5ed0:	8c 93       	st	X, r24
    5ed2:	8c 91       	ld	r24, X
		break;
	}
}
    5ed4:	2d 96       	adiw	r28, 0x0d	; 13
    5ed6:	0f b6       	in	r0, 0x3f	; 63
    5ed8:	f8 94       	cli
    5eda:	de bf       	out	0x3e, r29	; 62
    5edc:	0f be       	out	0x3f, r0	; 63
    5ede:	cd bf       	out	0x3d, r28	; 61
    5ee0:	cf 91       	pop	r28
    5ee2:	df 91       	pop	r29
    5ee4:	08 95       	ret

00005ee6 <DIO_GetPinVal>:


uint8_t  DIO_GetPinVal(uint8_t port ,uint8_t pin)
{
    5ee6:	df 93       	push	r29
    5ee8:	cf 93       	push	r28
    5eea:	00 d0       	rcall	.+0      	; 0x5eec <DIO_GetPinVal+0x6>
    5eec:	00 d0       	rcall	.+0      	; 0x5eee <DIO_GetPinVal+0x8>
    5eee:	00 d0       	rcall	.+0      	; 0x5ef0 <DIO_GetPinVal+0xa>
    5ef0:	cd b7       	in	r28, 0x3d	; 61
    5ef2:	de b7       	in	r29, 0x3e	; 62
    5ef4:	89 83       	std	Y+1, r24	; 0x01
    5ef6:	6a 83       	std	Y+2, r22	; 0x02
	switch(port)
    5ef8:	89 81       	ldd	r24, Y+1	; 0x01
    5efa:	28 2f       	mov	r18, r24
    5efc:	30 e0       	ldi	r19, 0x00	; 0
    5efe:	3d 83       	std	Y+5, r19	; 0x05
    5f00:	2c 83       	std	Y+4, r18	; 0x04
    5f02:	4c 81       	ldd	r20, Y+4	; 0x04
    5f04:	5d 81       	ldd	r21, Y+5	; 0x05
    5f06:	41 30       	cpi	r20, 0x01	; 1
    5f08:	51 05       	cpc	r21, r1
    5f0a:	49 f1       	breq	.+82     	; 0x5f5e <DIO_GetPinVal+0x78>
    5f0c:	8c 81       	ldd	r24, Y+4	; 0x04
    5f0e:	9d 81       	ldd	r25, Y+5	; 0x05
    5f10:	82 30       	cpi	r24, 0x02	; 2
    5f12:	91 05       	cpc	r25, r1
    5f14:	34 f4       	brge	.+12     	; 0x5f22 <DIO_GetPinVal+0x3c>
    5f16:	2c 81       	ldd	r18, Y+4	; 0x04
    5f18:	3d 81       	ldd	r19, Y+5	; 0x05
    5f1a:	21 15       	cp	r18, r1
    5f1c:	31 05       	cpc	r19, r1
    5f1e:	61 f0       	breq	.+24     	; 0x5f38 <DIO_GetPinVal+0x52>
    5f20:	57 c0       	rjmp	.+174    	; 0x5fd0 <DIO_GetPinVal+0xea>
    5f22:	4c 81       	ldd	r20, Y+4	; 0x04
    5f24:	5d 81       	ldd	r21, Y+5	; 0x05
    5f26:	42 30       	cpi	r20, 0x02	; 2
    5f28:	51 05       	cpc	r21, r1
    5f2a:	61 f1       	breq	.+88     	; 0x5f84 <DIO_GetPinVal+0x9e>
    5f2c:	8c 81       	ldd	r24, Y+4	; 0x04
    5f2e:	9d 81       	ldd	r25, Y+5	; 0x05
    5f30:	83 30       	cpi	r24, 0x03	; 3
    5f32:	91 05       	cpc	r25, r1
    5f34:	d1 f1       	breq	.+116    	; 0x5faa <DIO_GetPinVal+0xc4>
    5f36:	4c c0       	rjmp	.+152    	; 0x5fd0 <DIO_GetPinVal+0xea>
	{
		case  DIO_PORTA :
			return GET_BIT(PINA,pin);
    5f38:	e9 e3       	ldi	r30, 0x39	; 57
    5f3a:	f0 e0       	ldi	r31, 0x00	; 0
    5f3c:	80 81       	ld	r24, Z
    5f3e:	28 2f       	mov	r18, r24
    5f40:	30 e0       	ldi	r19, 0x00	; 0
    5f42:	8a 81       	ldd	r24, Y+2	; 0x02
    5f44:	88 2f       	mov	r24, r24
    5f46:	90 e0       	ldi	r25, 0x00	; 0
    5f48:	a9 01       	movw	r20, r18
    5f4a:	02 c0       	rjmp	.+4      	; 0x5f50 <DIO_GetPinVal+0x6a>
    5f4c:	55 95       	asr	r21
    5f4e:	47 95       	ror	r20
    5f50:	8a 95       	dec	r24
    5f52:	e2 f7       	brpl	.-8      	; 0x5f4c <DIO_GetPinVal+0x66>
    5f54:	ca 01       	movw	r24, r20
    5f56:	58 2f       	mov	r21, r24
    5f58:	51 70       	andi	r21, 0x01	; 1
    5f5a:	5b 83       	std	Y+3, r21	; 0x03
    5f5c:	3a c0       	rjmp	.+116    	; 0x5fd2 <DIO_GetPinVal+0xec>
			break;
		case  DIO_PORTB :
			return GET_BIT(PINB,pin);
    5f5e:	e6 e3       	ldi	r30, 0x36	; 54
    5f60:	f0 e0       	ldi	r31, 0x00	; 0
    5f62:	80 81       	ld	r24, Z
    5f64:	28 2f       	mov	r18, r24
    5f66:	30 e0       	ldi	r19, 0x00	; 0
    5f68:	8a 81       	ldd	r24, Y+2	; 0x02
    5f6a:	88 2f       	mov	r24, r24
    5f6c:	90 e0       	ldi	r25, 0x00	; 0
    5f6e:	a9 01       	movw	r20, r18
    5f70:	02 c0       	rjmp	.+4      	; 0x5f76 <DIO_GetPinVal+0x90>
    5f72:	55 95       	asr	r21
    5f74:	47 95       	ror	r20
    5f76:	8a 95       	dec	r24
    5f78:	e2 f7       	brpl	.-8      	; 0x5f72 <DIO_GetPinVal+0x8c>
    5f7a:	ca 01       	movw	r24, r20
    5f7c:	58 2f       	mov	r21, r24
    5f7e:	51 70       	andi	r21, 0x01	; 1
    5f80:	5b 83       	std	Y+3, r21	; 0x03
    5f82:	27 c0       	rjmp	.+78     	; 0x5fd2 <DIO_GetPinVal+0xec>
			break;
		case  DIO_PORTC :
			return GET_BIT(PINC,pin);
    5f84:	e3 e3       	ldi	r30, 0x33	; 51
    5f86:	f0 e0       	ldi	r31, 0x00	; 0
    5f88:	80 81       	ld	r24, Z
    5f8a:	28 2f       	mov	r18, r24
    5f8c:	30 e0       	ldi	r19, 0x00	; 0
    5f8e:	8a 81       	ldd	r24, Y+2	; 0x02
    5f90:	88 2f       	mov	r24, r24
    5f92:	90 e0       	ldi	r25, 0x00	; 0
    5f94:	a9 01       	movw	r20, r18
    5f96:	02 c0       	rjmp	.+4      	; 0x5f9c <DIO_GetPinVal+0xb6>
    5f98:	55 95       	asr	r21
    5f9a:	47 95       	ror	r20
    5f9c:	8a 95       	dec	r24
    5f9e:	e2 f7       	brpl	.-8      	; 0x5f98 <DIO_GetPinVal+0xb2>
    5fa0:	ca 01       	movw	r24, r20
    5fa2:	58 2f       	mov	r21, r24
    5fa4:	51 70       	andi	r21, 0x01	; 1
    5fa6:	5b 83       	std	Y+3, r21	; 0x03
    5fa8:	14 c0       	rjmp	.+40     	; 0x5fd2 <DIO_GetPinVal+0xec>
			break;
		case  DIO_PORTD :
			return GET_BIT(PIND,pin);
    5faa:	e0 e3       	ldi	r30, 0x30	; 48
    5fac:	f0 e0       	ldi	r31, 0x00	; 0
    5fae:	80 81       	ld	r24, Z
    5fb0:	28 2f       	mov	r18, r24
    5fb2:	30 e0       	ldi	r19, 0x00	; 0
    5fb4:	8a 81       	ldd	r24, Y+2	; 0x02
    5fb6:	88 2f       	mov	r24, r24
    5fb8:	90 e0       	ldi	r25, 0x00	; 0
    5fba:	a9 01       	movw	r20, r18
    5fbc:	02 c0       	rjmp	.+4      	; 0x5fc2 <DIO_GetPinVal+0xdc>
    5fbe:	55 95       	asr	r21
    5fc0:	47 95       	ror	r20
    5fc2:	8a 95       	dec	r24
    5fc4:	e2 f7       	brpl	.-8      	; 0x5fbe <DIO_GetPinVal+0xd8>
    5fc6:	ca 01       	movw	r24, r20
    5fc8:	58 2f       	mov	r21, r24
    5fca:	51 70       	andi	r21, 0x01	; 1
    5fcc:	5b 83       	std	Y+3, r21	; 0x03
    5fce:	01 c0       	rjmp	.+2      	; 0x5fd2 <DIO_GetPinVal+0xec>
    5fd0:	02 c0       	rjmp	.+4      	; 0x5fd6 <DIO_GetPinVal+0xf0>
			break;
	}
}
    5fd2:	8b 81       	ldd	r24, Y+3	; 0x03
    5fd4:	8e 83       	std	Y+6, r24	; 0x06
    5fd6:	8e 81       	ldd	r24, Y+6	; 0x06
    5fd8:	26 96       	adiw	r28, 0x06	; 6
    5fda:	0f b6       	in	r0, 0x3f	; 63
    5fdc:	f8 94       	cli
    5fde:	de bf       	out	0x3e, r29	; 62
    5fe0:	0f be       	out	0x3f, r0	; 63
    5fe2:	cd bf       	out	0x3d, r28	; 61
    5fe4:	cf 91       	pop	r28
    5fe6:	df 91       	pop	r29
    5fe8:	08 95       	ret

00005fea <DIO_TogPinVal>:


void  DIO_TogPinVal(uint8_t port ,uint8_t pin)
{
    5fea:	df 93       	push	r29
    5fec:	cf 93       	push	r28
    5fee:	00 d0       	rcall	.+0      	; 0x5ff0 <DIO_TogPinVal+0x6>
    5ff0:	00 d0       	rcall	.+0      	; 0x5ff2 <DIO_TogPinVal+0x8>
    5ff2:	cd b7       	in	r28, 0x3d	; 61
    5ff4:	de b7       	in	r29, 0x3e	; 62
    5ff6:	89 83       	std	Y+1, r24	; 0x01
    5ff8:	6a 83       	std	Y+2, r22	; 0x02
	switch(port)
    5ffa:	89 81       	ldd	r24, Y+1	; 0x01
    5ffc:	28 2f       	mov	r18, r24
    5ffe:	30 e0       	ldi	r19, 0x00	; 0
    6000:	3c 83       	std	Y+4, r19	; 0x04
    6002:	2b 83       	std	Y+3, r18	; 0x03
    6004:	8b 81       	ldd	r24, Y+3	; 0x03
    6006:	9c 81       	ldd	r25, Y+4	; 0x04
    6008:	81 30       	cpi	r24, 0x01	; 1
    600a:	91 05       	cpc	r25, r1
    600c:	49 f1       	breq	.+82     	; 0x6060 <DIO_TogPinVal+0x76>
    600e:	2b 81       	ldd	r18, Y+3	; 0x03
    6010:	3c 81       	ldd	r19, Y+4	; 0x04
    6012:	22 30       	cpi	r18, 0x02	; 2
    6014:	31 05       	cpc	r19, r1
    6016:	2c f4       	brge	.+10     	; 0x6022 <DIO_TogPinVal+0x38>
    6018:	8b 81       	ldd	r24, Y+3	; 0x03
    601a:	9c 81       	ldd	r25, Y+4	; 0x04
    601c:	00 97       	sbiw	r24, 0x00	; 0
    601e:	61 f0       	breq	.+24     	; 0x6038 <DIO_TogPinVal+0x4e>
    6020:	5a c0       	rjmp	.+180    	; 0x60d6 <DIO_TogPinVal+0xec>
    6022:	2b 81       	ldd	r18, Y+3	; 0x03
    6024:	3c 81       	ldd	r19, Y+4	; 0x04
    6026:	22 30       	cpi	r18, 0x02	; 2
    6028:	31 05       	cpc	r19, r1
    602a:	71 f1       	breq	.+92     	; 0x6088 <DIO_TogPinVal+0x9e>
    602c:	8b 81       	ldd	r24, Y+3	; 0x03
    602e:	9c 81       	ldd	r25, Y+4	; 0x04
    6030:	83 30       	cpi	r24, 0x03	; 3
    6032:	91 05       	cpc	r25, r1
    6034:	e9 f1       	breq	.+122    	; 0x60b0 <DIO_TogPinVal+0xc6>
    6036:	4f c0       	rjmp	.+158    	; 0x60d6 <DIO_TogPinVal+0xec>
	{
		case  DIO_PORTA :	TOG_BIT(PORTA,pin);
    6038:	ab e3       	ldi	r26, 0x3B	; 59
    603a:	b0 e0       	ldi	r27, 0x00	; 0
    603c:	eb e3       	ldi	r30, 0x3B	; 59
    603e:	f0 e0       	ldi	r31, 0x00	; 0
    6040:	80 81       	ld	r24, Z
    6042:	48 2f       	mov	r20, r24
    6044:	8a 81       	ldd	r24, Y+2	; 0x02
    6046:	28 2f       	mov	r18, r24
    6048:	30 e0       	ldi	r19, 0x00	; 0
    604a:	81 e0       	ldi	r24, 0x01	; 1
    604c:	90 e0       	ldi	r25, 0x00	; 0
    604e:	02 2e       	mov	r0, r18
    6050:	02 c0       	rjmp	.+4      	; 0x6056 <DIO_TogPinVal+0x6c>
    6052:	88 0f       	add	r24, r24
    6054:	99 1f       	adc	r25, r25
    6056:	0a 94       	dec	r0
    6058:	e2 f7       	brpl	.-8      	; 0x6052 <DIO_TogPinVal+0x68>
    605a:	84 27       	eor	r24, r20
    605c:	8c 93       	st	X, r24
    605e:	3b c0       	rjmp	.+118    	; 0x60d6 <DIO_TogPinVal+0xec>
		break;
		case  DIO_PORTB :   TOG_BIT(PORTB,pin);
    6060:	a8 e3       	ldi	r26, 0x38	; 56
    6062:	b0 e0       	ldi	r27, 0x00	; 0
    6064:	e8 e3       	ldi	r30, 0x38	; 56
    6066:	f0 e0       	ldi	r31, 0x00	; 0
    6068:	80 81       	ld	r24, Z
    606a:	48 2f       	mov	r20, r24
    606c:	8a 81       	ldd	r24, Y+2	; 0x02
    606e:	28 2f       	mov	r18, r24
    6070:	30 e0       	ldi	r19, 0x00	; 0
    6072:	81 e0       	ldi	r24, 0x01	; 1
    6074:	90 e0       	ldi	r25, 0x00	; 0
    6076:	02 2e       	mov	r0, r18
    6078:	02 c0       	rjmp	.+4      	; 0x607e <DIO_TogPinVal+0x94>
    607a:	88 0f       	add	r24, r24
    607c:	99 1f       	adc	r25, r25
    607e:	0a 94       	dec	r0
    6080:	e2 f7       	brpl	.-8      	; 0x607a <DIO_TogPinVal+0x90>
    6082:	84 27       	eor	r24, r20
    6084:	8c 93       	st	X, r24
    6086:	27 c0       	rjmp	.+78     	; 0x60d6 <DIO_TogPinVal+0xec>
		break;
		case  DIO_PORTC :   TOG_BIT(PORTC,pin);
    6088:	a5 e3       	ldi	r26, 0x35	; 53
    608a:	b0 e0       	ldi	r27, 0x00	; 0
    608c:	e5 e3       	ldi	r30, 0x35	; 53
    608e:	f0 e0       	ldi	r31, 0x00	; 0
    6090:	80 81       	ld	r24, Z
    6092:	48 2f       	mov	r20, r24
    6094:	8a 81       	ldd	r24, Y+2	; 0x02
    6096:	28 2f       	mov	r18, r24
    6098:	30 e0       	ldi	r19, 0x00	; 0
    609a:	81 e0       	ldi	r24, 0x01	; 1
    609c:	90 e0       	ldi	r25, 0x00	; 0
    609e:	02 2e       	mov	r0, r18
    60a0:	02 c0       	rjmp	.+4      	; 0x60a6 <DIO_TogPinVal+0xbc>
    60a2:	88 0f       	add	r24, r24
    60a4:	99 1f       	adc	r25, r25
    60a6:	0a 94       	dec	r0
    60a8:	e2 f7       	brpl	.-8      	; 0x60a2 <DIO_TogPinVal+0xb8>
    60aa:	84 27       	eor	r24, r20
    60ac:	8c 93       	st	X, r24
    60ae:	13 c0       	rjmp	.+38     	; 0x60d6 <DIO_TogPinVal+0xec>
		break;
		case  DIO_PORTD :   TOG_BIT(PORTD,pin);
    60b0:	a2 e3       	ldi	r26, 0x32	; 50
    60b2:	b0 e0       	ldi	r27, 0x00	; 0
    60b4:	e2 e3       	ldi	r30, 0x32	; 50
    60b6:	f0 e0       	ldi	r31, 0x00	; 0
    60b8:	80 81       	ld	r24, Z
    60ba:	48 2f       	mov	r20, r24
    60bc:	8a 81       	ldd	r24, Y+2	; 0x02
    60be:	28 2f       	mov	r18, r24
    60c0:	30 e0       	ldi	r19, 0x00	; 0
    60c2:	81 e0       	ldi	r24, 0x01	; 1
    60c4:	90 e0       	ldi	r25, 0x00	; 0
    60c6:	02 2e       	mov	r0, r18
    60c8:	02 c0       	rjmp	.+4      	; 0x60ce <DIO_TogPinVal+0xe4>
    60ca:	88 0f       	add	r24, r24
    60cc:	99 1f       	adc	r25, r25
    60ce:	0a 94       	dec	r0
    60d0:	e2 f7       	brpl	.-8      	; 0x60ca <DIO_TogPinVal+0xe0>
    60d2:	84 27       	eor	r24, r20
    60d4:	8c 93       	st	X, r24
		break;
	}
}
    60d6:	0f 90       	pop	r0
    60d8:	0f 90       	pop	r0
    60da:	0f 90       	pop	r0
    60dc:	0f 90       	pop	r0
    60de:	cf 91       	pop	r28
    60e0:	df 91       	pop	r29
    60e2:	08 95       	ret

000060e4 <GIE>:


#include "INT.h"

void GIE()
{
    60e4:	df 93       	push	r29
    60e6:	cf 93       	push	r28
    60e8:	cd b7       	in	r28, 0x3d	; 61
    60ea:	de b7       	in	r29, 0x3e	; 62
    SET_BIT(SREG,I_BIT);
    60ec:	af e5       	ldi	r26, 0x5F	; 95
    60ee:	b0 e0       	ldi	r27, 0x00	; 0
    60f0:	ef e5       	ldi	r30, 0x5F	; 95
    60f2:	f0 e0       	ldi	r31, 0x00	; 0
    60f4:	80 81       	ld	r24, Z
    60f6:	80 68       	ori	r24, 0x80	; 128
    60f8:	8c 93       	st	X, r24
}
    60fa:	cf 91       	pop	r28
    60fc:	df 91       	pop	r29
    60fe:	08 95       	ret

00006100 <GID>:
void GID()
{
    6100:	df 93       	push	r29
    6102:	cf 93       	push	r28
    6104:	cd b7       	in	r28, 0x3d	; 61
    6106:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG,I_BIT);
    6108:	af e5       	ldi	r26, 0x5F	; 95
    610a:	b0 e0       	ldi	r27, 0x00	; 0
    610c:	ef e5       	ldi	r30, 0x5F	; 95
    610e:	f0 e0       	ldi	r31, 0x00	; 0
    6110:	80 81       	ld	r24, Z
    6112:	8f 77       	andi	r24, 0x7F	; 127
    6114:	8c 93       	st	X, r24
}
    6116:	cf 91       	pop	r28
    6118:	df 91       	pop	r29
    611a:	08 95       	ret

0000611c <Timer0_INIT>:


#include "TIMER.h"

void Timer0_INIT()
{
    611c:	df 93       	push	r29
    611e:	cf 93       	push	r28
    6120:	cd b7       	in	r28, 0x3d	; 61
    6122:	de b7       	in	r29, 0x3e	; 62
	GIE();
    6124:	0e 94 72 30 	call	0x60e4	; 0x60e4 <GIE>
	SET_BIT(TCCR0,WGM00);
	CLR_BIT(TCCR0,WGM01);
	SET_BIT(DDRB,3);//set OC0 as OUTPUT PIN

	#elif (TIMER0_MODE == CTC_MODE)
	SET_BIT(TIMSK,OCIE0);
    6128:	a9 e5       	ldi	r26, 0x59	; 89
    612a:	b0 e0       	ldi	r27, 0x00	; 0
    612c:	e9 e5       	ldi	r30, 0x59	; 89
    612e:	f0 e0       	ldi	r31, 0x00	; 0
    6130:	80 81       	ld	r24, Z
    6132:	82 60       	ori	r24, 0x02	; 2
    6134:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,WGM00);
    6136:	a3 e5       	ldi	r26, 0x53	; 83
    6138:	b0 e0       	ldi	r27, 0x00	; 0
    613a:	e3 e5       	ldi	r30, 0x53	; 83
    613c:	f0 e0       	ldi	r31, 0x00	; 0
    613e:	80 81       	ld	r24, Z
    6140:	8f 7b       	andi	r24, 0xBF	; 191
    6142:	8c 93       	st	X, r24
	SET_BIT(TCCR0,WGM01);
    6144:	a3 e5       	ldi	r26, 0x53	; 83
    6146:	b0 e0       	ldi	r27, 0x00	; 0
    6148:	e3 e5       	ldi	r30, 0x53	; 83
    614a:	f0 e0       	ldi	r31, 0x00	; 0
    614c:	80 81       	ld	r24, Z
    614e:	88 60       	ori	r24, 0x08	; 8
    6150:	8c 93       	st	X, r24
	SET_BIT(TCCR0,WGM00);
	SET_BIT(TCCR0,WGM01);
	SET_BIT(DDRB,3);//set OC0 as OUTPUT PIN

	#endif
}
    6152:	cf 91       	pop	r28
    6154:	df 91       	pop	r29
    6156:	08 95       	ret

00006158 <Timer0_Start>:

void Timer0_Start()
{
    6158:	df 93       	push	r29
    615a:	cf 93       	push	r28
    615c:	cd b7       	in	r28, 0x3d	; 61
    615e:	de b7       	in	r29, 0x3e	; 62
	switch(TIMER0_FREQ)
	{
		case PRE_1024:
		{
			SET_BIT(TCCR0,CS00);
    6160:	a3 e5       	ldi	r26, 0x53	; 83
    6162:	b0 e0       	ldi	r27, 0x00	; 0
    6164:	e3 e5       	ldi	r30, 0x53	; 83
    6166:	f0 e0       	ldi	r31, 0x00	; 0
    6168:	80 81       	ld	r24, Z
    616a:	81 60       	ori	r24, 0x01	; 1
    616c:	8c 93       	st	X, r24
			CLR_BIT(TCCR0,CS01);
    616e:	a3 e5       	ldi	r26, 0x53	; 83
    6170:	b0 e0       	ldi	r27, 0x00	; 0
    6172:	e3 e5       	ldi	r30, 0x53	; 83
    6174:	f0 e0       	ldi	r31, 0x00	; 0
    6176:	80 81       	ld	r24, Z
    6178:	8d 7f       	andi	r24, 0xFD	; 253
    617a:	8c 93       	st	X, r24
			SET_BIT(TCCR0,CS02);
    617c:	a3 e5       	ldi	r26, 0x53	; 83
    617e:	b0 e0       	ldi	r27, 0x00	; 0
    6180:	e3 e5       	ldi	r30, 0x53	; 83
    6182:	f0 e0       	ldi	r31, 0x00	; 0
    6184:	80 81       	ld	r24, Z
    6186:	84 60       	ori	r24, 0x04	; 4
    6188:	8c 93       	st	X, r24
			SET_BIT(TCCR0,CS00);
			CLR_BIT(TCCR0,CS01);
			CLR_BIT(TCCR0,CS02);
		} break;
	}
}
    618a:	cf 91       	pop	r28
    618c:	df 91       	pop	r29
    618e:	08 95       	ret

00006190 <Timer0_Stop>:

void Timer0_Stop()
{
    6190:	df 93       	push	r29
    6192:	cf 93       	push	r28
    6194:	cd b7       	in	r28, 0x3d	; 61
    6196:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TCCR0,CS00);
    6198:	a3 e5       	ldi	r26, 0x53	; 83
    619a:	b0 e0       	ldi	r27, 0x00	; 0
    619c:	e3 e5       	ldi	r30, 0x53	; 83
    619e:	f0 e0       	ldi	r31, 0x00	; 0
    61a0:	80 81       	ld	r24, Z
    61a2:	8e 7f       	andi	r24, 0xFE	; 254
    61a4:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,CS01);
    61a6:	a3 e5       	ldi	r26, 0x53	; 83
    61a8:	b0 e0       	ldi	r27, 0x00	; 0
    61aa:	e3 e5       	ldi	r30, 0x53	; 83
    61ac:	f0 e0       	ldi	r31, 0x00	; 0
    61ae:	80 81       	ld	r24, Z
    61b0:	8d 7f       	andi	r24, 0xFD	; 253
    61b2:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,CS02);
    61b4:	a3 e5       	ldi	r26, 0x53	; 83
    61b6:	b0 e0       	ldi	r27, 0x00	; 0
    61b8:	e3 e5       	ldi	r30, 0x53	; 83
    61ba:	f0 e0       	ldi	r31, 0x00	; 0
    61bc:	80 81       	ld	r24, Z
    61be:	8b 7f       	andi	r24, 0xFB	; 251
    61c0:	8c 93       	st	X, r24
}
    61c2:	cf 91       	pop	r28
    61c4:	df 91       	pop	r29
    61c6:	08 95       	ret

000061c8 <TIMER0_PWM_Stop>:

void TIMER0_PWM_Stop(void)
{
    61c8:	df 93       	push	r29
    61ca:	cf 93       	push	r28
    61cc:	cd b7       	in	r28, 0x3d	; 61
    61ce:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TCCR0,COM00);
    61d0:	a3 e5       	ldi	r26, 0x53	; 83
    61d2:	b0 e0       	ldi	r27, 0x00	; 0
    61d4:	e3 e5       	ldi	r30, 0x53	; 83
    61d6:	f0 e0       	ldi	r31, 0x00	; 0
    61d8:	80 81       	ld	r24, Z
    61da:	8f 7e       	andi	r24, 0xEF	; 239
    61dc:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,COM01);
    61de:	a3 e5       	ldi	r26, 0x53	; 83
    61e0:	b0 e0       	ldi	r27, 0x00	; 0
    61e2:	e3 e5       	ldi	r30, 0x53	; 83
    61e4:	f0 e0       	ldi	r31, 0x00	; 0
    61e6:	80 81       	ld	r24, Z
    61e8:	8f 7d       	andi	r24, 0xDF	; 223
    61ea:	8c 93       	st	X, r24
}
    61ec:	cf 91       	pop	r28
    61ee:	df 91       	pop	r29
    61f0:	08 95       	ret

000061f2 <TIMER0_PWM_Start>:

void TIMER0_PWM_Start(void)
{
    61f2:	df 93       	push	r29
    61f4:	cf 93       	push	r28
    61f6:	cd b7       	in	r28, 0x3d	; 61
    61f8:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TCCR0,COM00);
    61fa:	a3 e5       	ldi	r26, 0x53	; 83
    61fc:	b0 e0       	ldi	r27, 0x00	; 0
    61fe:	e3 e5       	ldi	r30, 0x53	; 83
    6200:	f0 e0       	ldi	r31, 0x00	; 0
    6202:	80 81       	ld	r24, Z
    6204:	8f 7e       	andi	r24, 0xEF	; 239
    6206:	8c 93       	st	X, r24
	SET_BIT(TCCR0,COM01);
    6208:	a3 e5       	ldi	r26, 0x53	; 83
    620a:	b0 e0       	ldi	r27, 0x00	; 0
    620c:	e3 e5       	ldi	r30, 0x53	; 83
    620e:	f0 e0       	ldi	r31, 0x00	; 0
    6210:	80 81       	ld	r24, Z
    6212:	80 62       	ori	r24, 0x20	; 32
    6214:	8c 93       	st	X, r24
}
    6216:	cf 91       	pop	r28
    6218:	df 91       	pop	r29
    621a:	08 95       	ret

0000621c <Timer0_SET_DUTY_CYCLE>:

void Timer0_SET_DUTY_CYCLE (uint8_t percentage)
{
    621c:	df 93       	push	r29
    621e:	cf 93       	push	r28
    6220:	0f 92       	push	r0
    6222:	cd b7       	in	r28, 0x3d	; 61
    6224:	de b7       	in	r29, 0x3e	; 62
    6226:	89 83       	std	Y+1, r24	; 0x01
	if (percentage <= 0)
    6228:	89 81       	ldd	r24, Y+1	; 0x01
    622a:	88 23       	and	r24, r24
    622c:	21 f4       	brne	.+8      	; 0x6236 <Timer0_SET_DUTY_CYCLE+0x1a>
	{
		OCR0 = 0;
    622e:	ec e5       	ldi	r30, 0x5C	; 92
    6230:	f0 e0       	ldi	r31, 0x00	; 0
    6232:	10 82       	st	Z, r1
    6234:	17 c0       	rjmp	.+46     	; 0x6264 <Timer0_SET_DUTY_CYCLE+0x48>
	}

	else if (percentage >= 100)
    6236:	89 81       	ldd	r24, Y+1	; 0x01
    6238:	84 36       	cpi	r24, 0x64	; 100
    623a:	28 f0       	brcs	.+10     	; 0x6246 <Timer0_SET_DUTY_CYCLE+0x2a>
	{
		OCR0 = 255;
    623c:	ec e5       	ldi	r30, 0x5C	; 92
    623e:	f0 e0       	ldi	r31, 0x00	; 0
    6240:	8f ef       	ldi	r24, 0xFF	; 255
    6242:	80 83       	st	Z, r24
    6244:	0f c0       	rjmp	.+30     	; 0x6264 <Timer0_SET_DUTY_CYCLE+0x48>
	}

	else
	{
		OCR0 = (uint8_t) (((percentage * 256)/100)-1);
    6246:	ec e5       	ldi	r30, 0x5C	; 92
    6248:	f0 e0       	ldi	r31, 0x00	; 0
    624a:	89 81       	ldd	r24, Y+1	; 0x01
    624c:	88 2f       	mov	r24, r24
    624e:	90 e0       	ldi	r25, 0x00	; 0
    6250:	98 2f       	mov	r25, r24
    6252:	88 27       	eor	r24, r24
    6254:	24 e6       	ldi	r18, 0x64	; 100
    6256:	30 e0       	ldi	r19, 0x00	; 0
    6258:	b9 01       	movw	r22, r18
    625a:	0e 94 03 33 	call	0x6606	; 0x6606 <__divmodhi4>
    625e:	cb 01       	movw	r24, r22
    6260:	81 50       	subi	r24, 0x01	; 1
    6262:	80 83       	st	Z, r24
	}
}
    6264:	0f 90       	pop	r0
    6266:	cf 91       	pop	r28
    6268:	df 91       	pop	r29
    626a:	08 95       	ret

0000626c <main>:
void toggle_led_mode(void);

TaskHandle_t task2ptr;

int main(void)
{
    626c:	ef 92       	push	r14
    626e:	ff 92       	push	r15
    6270:	0f 93       	push	r16
    6272:	1f 93       	push	r17
    6274:	df 93       	push	r29
    6276:	cf 93       	push	r28
    6278:	cd b7       	in	r28, 0x3d	; 61
    627a:	de b7       	in	r29, 0x3e	; 62
/*	xTimerStart(xTimer, 10 );
	xTimerStart(xTimer2, 50 );
	xTimerStart(xTimer3, 100 );
*/
//	xTaskCreate(vState_machine,"first",configMINIMAL_STACK_SIZE,NULL,1,&task1ptr);
	xButtonTimer = xTimerCreate
    627c:	e3 ea       	ldi	r30, 0xA3	; 163
    627e:	f1 e3       	ldi	r31, 0x31	; 49
    6280:	8d e6       	ldi	r24, 0x6D	; 109
    6282:	90 e0       	ldi	r25, 0x00	; 0
    6284:	6a e0       	ldi	r22, 0x0A	; 10
    6286:	70 e0       	ldi	r23, 0x00	; 0
    6288:	41 e0       	ldi	r20, 0x01	; 1
    628a:	20 e0       	ldi	r18, 0x00	; 0
    628c:	30 e0       	ldi	r19, 0x00	; 0
    628e:	8f 01       	movw	r16, r30
    6290:	0e 94 66 28 	call	0x50cc	; 0x50cc <xTimerCreate>
    6294:	90 93 23 07 	sts	0x0723, r25
    6298:	80 93 22 07 	sts	0x0722, r24
	                     ( void * ) 0,
	                     /* Each timer calls the same callback when
	                     it expires. */
						 get_readings
	                   );
	xLedBlinkingTimer = xTimerCreate
    629c:	e0 e9       	ldi	r30, 0x90	; 144
    629e:	f1 e3       	ldi	r31, 0x31	; 49
    62a0:	8a e7       	ldi	r24, 0x7A	; 122
    62a2:	90 e0       	ldi	r25, 0x00	; 0
    62a4:	64 ef       	ldi	r22, 0xF4	; 244
    62a6:	71 e0       	ldi	r23, 0x01	; 1
    62a8:	41 e0       	ldi	r20, 0x01	; 1
    62aa:	20 e0       	ldi	r18, 0x00	; 0
    62ac:	30 e0       	ldi	r19, 0x00	; 0
    62ae:	8f 01       	movw	r16, r30
    62b0:	0e 94 66 28 	call	0x50cc	; 0x50cc <xTimerCreate>
    62b4:	90 93 25 07 	sts	0x0725, r25
    62b8:	80 93 24 07 	sts	0x0724, r24
		                     ( void * ) 0,
		                     /* Each timer calls the same callback when
		                     it expires. */
							 toggle_led_mode
		                   );
	xTaskCreate(vState_machine,"first",configMINIMAL_STACK_SIZE,NULL,1,&task1ptr);
    62bc:	8a e4       	ldi	r24, 0x4A	; 74
    62be:	92 e3       	ldi	r25, 0x32	; 50
    62c0:	24 e8       	ldi	r18, 0x84	; 132
    62c2:	30 e0       	ldi	r19, 0x00	; 0
    62c4:	ee e2       	ldi	r30, 0x2E	; 46
    62c6:	f7 e0       	ldi	r31, 0x07	; 7
    62c8:	b9 01       	movw	r22, r18
    62ca:	45 e5       	ldi	r20, 0x55	; 85
    62cc:	50 e0       	ldi	r21, 0x00	; 0
    62ce:	20 e0       	ldi	r18, 0x00	; 0
    62d0:	30 e0       	ldi	r19, 0x00	; 0
    62d2:	01 e0       	ldi	r16, 0x01	; 1
    62d4:	7f 01       	movw	r14, r30
    62d6:	0e 94 4d 14 	call	0x289a	; 0x289a <xTaskCreate>
	xTimerStart(xButtonTimer, 10 );
    62da:	00 91 22 07 	lds	r16, 0x0722
    62de:	10 91 23 07 	lds	r17, 0x0723
    62e2:	0e 94 fa 18 	call	0x31f4	; 0x31f4 <xTaskGetTickCount>
    62e6:	9c 01       	movw	r18, r24
    62e8:	c8 01       	movw	r24, r16
    62ea:	61 e0       	ldi	r22, 0x01	; 1
    62ec:	a9 01       	movw	r20, r18
    62ee:	20 e0       	ldi	r18, 0x00	; 0
    62f0:	30 e0       	ldi	r19, 0x00	; 0
    62f2:	0a e0       	ldi	r16, 0x0A	; 10
    62f4:	10 e0       	ldi	r17, 0x00	; 0
    62f6:	0e 94 f8 28 	call	0x51f0	; 0x51f0 <xTimerGenericCommand>
	xTimerStart(xLedBlinkingTimer, 20 );
    62fa:	00 91 24 07 	lds	r16, 0x0724
    62fe:	10 91 25 07 	lds	r17, 0x0725
    6302:	0e 94 fa 18 	call	0x31f4	; 0x31f4 <xTaskGetTickCount>
    6306:	9c 01       	movw	r18, r24
    6308:	c8 01       	movw	r24, r16
    630a:	61 e0       	ldi	r22, 0x01	; 1
    630c:	a9 01       	movw	r20, r18
    630e:	20 e0       	ldi	r18, 0x00	; 0
    6310:	30 e0       	ldi	r19, 0x00	; 0
    6312:	04 e1       	ldi	r16, 0x14	; 20
    6314:	10 e0       	ldi	r17, 0x00	; 0
    6316:	0e 94 f8 28 	call	0x51f0	; 0x51f0 <xTimerGenericCommand>
	vTaskStartScheduler();
    631a:	0e 94 57 17 	call	0x2eae	; 0x2eae <vTaskStartScheduler>
    631e:	ff cf       	rjmp	.-2      	; 0x631e <main+0xb2>

00006320 <toggle_led_mode>:
	}*/
	/*	vTaskDelayUntil( &xLastWakeTime, xPeriod );*/

/*}*/

void toggle_led_mode(void){
    6320:	df 93       	push	r29
    6322:	cf 93       	push	r28
    6324:	0f 92       	push	r0
    6326:	cd b7       	in	r28, 0x3d	; 61
    6328:	de b7       	in	r29, 0x3e	; 62
//	while(1){
		led_mode = !led_mode;
    632a:	80 91 26 07 	lds	r24, 0x0726
    632e:	19 82       	std	Y+1, r1	; 0x01
    6330:	88 23       	and	r24, r24
    6332:	11 f4       	brne	.+4      	; 0x6338 <toggle_led_mode+0x18>
    6334:	81 e0       	ldi	r24, 0x01	; 1
    6336:	89 83       	std	Y+1, r24	; 0x01
    6338:	89 81       	ldd	r24, Y+1	; 0x01
    633a:	80 93 26 07 	sts	0x0726, r24
//	}

}
    633e:	0f 90       	pop	r0
    6340:	cf 91       	pop	r28
    6342:	df 91       	pop	r29
    6344:	08 95       	ret

00006346 <get_readings>:
void get_readings(void)
{
    6346:	df 93       	push	r29
    6348:	cf 93       	push	r28
    634a:	00 d0       	rcall	.+0      	; 0x634c <get_readings+0x6>
    634c:	0f 92       	push	r0
    634e:	cd b7       	in	r28, 0x3d	; 61
    6350:	de b7       	in	r29, 0x3e	; 62


//	while(1)
//	{

		ignition_button = READ_IGNITON(); ////
    6352:	0e 94 9f 32 	call	0x653e	; 0x653e <READ_IGNITON>
    6356:	80 93 29 07 	sts	0x0729, r24
//		DIO_SetPinVal(DIO_PORTC , Pin4 , HIGH);
//		ignition_button = 1; ////
		if(ignition_button){
    635a:	80 91 29 07 	lds	r24, 0x0729
    635e:	88 23       	and	r24, r24
    6360:	09 f4       	brne	.+2      	; 0x6364 <get_readings+0x1e>
    6362:	92 c0       	rjmp	.+292    	; 0x6488 <get_readings+0x142>
			uint8_t hazard_data = READ_HAZARD_Button();
    6364:	0e 94 b3 32 	call	0x6566	; 0x6566 <READ_HAZARD_Button>
    6368:	8b 83       	std	Y+3, r24	; 0x03
//			hazard_data=1;
			uint8_t right_data = READ_RIGHT_Button();
    636a:	0e 94 c7 32 	call	0x658e	; 0x658e <READ_RIGHT_Button>
    636e:	8a 83       	std	Y+2, r24	; 0x02
//			char right_data = 0;
			uint8_t left_data = READ_LEFT_Button();
    6370:	0e 94 db 32 	call	0x65b6	; 0x65b6 <READ_LEFT_Button>
    6374:	89 83       	std	Y+1, r24	; 0x01
			if(hazard_data){////
    6376:	8b 81       	ldd	r24, Y+3	; 0x03
    6378:	88 23       	and	r24, r24
    637a:	29 f1       	breq	.+74     	; 0x63c6 <get_readings+0x80>
				hazzred_button_pressed_counter++;
    637c:	80 91 27 07 	lds	r24, 0x0727
    6380:	90 91 28 07 	lds	r25, 0x0728
    6384:	01 96       	adiw	r24, 0x01	; 1
    6386:	90 93 28 07 	sts	0x0728, r25
    638a:	80 93 27 07 	sts	0x0727, r24
				right_button_pressed_counter=0;
    638e:	10 92 34 07 	sts	0x0734, r1
    6392:	10 92 33 07 	sts	0x0733, r1
				left_button_pressed_counter=0;
    6396:	10 92 32 07 	sts	0x0732, r1
    639a:	10 92 31 07 	sts	0x0731, r1

				if(!(hazzred_button_pressed_counter%10)){
    639e:	80 91 27 07 	lds	r24, 0x0727
    63a2:	90 91 28 07 	lds	r25, 0x0728
    63a6:	2a e0       	ldi	r18, 0x0A	; 10
    63a8:	30 e0       	ldi	r19, 0x00	; 0
    63aa:	b9 01       	movw	r22, r18
    63ac:	0e 94 03 33 	call	0x6606	; 0x6606 <__divmodhi4>
    63b0:	00 97       	sbiw	r24, 0x00	; 0
    63b2:	09 f0       	breq	.+2      	; 0x63b6 <get_readings+0x70>
    63b4:	69 c0       	rjmp	.+210    	; 0x6488 <get_readings+0x142>
					Hazzred_button = 1;
    63b6:	81 e0       	ldi	r24, 0x01	; 1
    63b8:	80 93 30 07 	sts	0x0730, r24
					L_button = 0;
    63bc:	10 92 2d 07 	sts	0x072D, r1
					R_button = 0;
    63c0:	10 92 2a 07 	sts	0x072A, r1
    63c4:	61 c0       	rjmp	.+194    	; 0x6488 <get_readings+0x142>

//					DIO_SetPinVal(DIO_PORTC , Pin6 , HIGH);
				}
			}
			else if(right_data){////
    63c6:	8a 81       	ldd	r24, Y+2	; 0x02
    63c8:	88 23       	and	r24, r24
    63ca:	29 f1       	breq	.+74     	; 0x6416 <get_readings+0xd0>
				right_button_pressed_counter++;
    63cc:	80 91 33 07 	lds	r24, 0x0733
    63d0:	90 91 34 07 	lds	r25, 0x0734
    63d4:	01 96       	adiw	r24, 0x01	; 1
    63d6:	90 93 34 07 	sts	0x0734, r25
    63da:	80 93 33 07 	sts	0x0733, r24
				hazzred_button_pressed_counter=0;
    63de:	10 92 28 07 	sts	0x0728, r1
    63e2:	10 92 27 07 	sts	0x0727, r1
				left_button_pressed_counter=0;
    63e6:	10 92 32 07 	sts	0x0732, r1
    63ea:	10 92 31 07 	sts	0x0731, r1
				if(!(right_button_pressed_counter%10)){
    63ee:	80 91 33 07 	lds	r24, 0x0733
    63f2:	90 91 34 07 	lds	r25, 0x0734
    63f6:	2a e0       	ldi	r18, 0x0A	; 10
    63f8:	30 e0       	ldi	r19, 0x00	; 0
    63fa:	b9 01       	movw	r22, r18
    63fc:	0e 94 03 33 	call	0x6606	; 0x6606 <__divmodhi4>
    6400:	00 97       	sbiw	r24, 0x00	; 0
    6402:	09 f0       	breq	.+2      	; 0x6406 <get_readings+0xc0>
    6404:	41 c0       	rjmp	.+130    	; 0x6488 <get_readings+0x142>
					R_button = 1;
    6406:	81 e0       	ldi	r24, 0x01	; 1
    6408:	80 93 2a 07 	sts	0x072A, r24
					Hazzred_button = 0;
    640c:	10 92 30 07 	sts	0x0730, r1
					L_button = 0;
    6410:	10 92 2d 07 	sts	0x072D, r1
    6414:	39 c0       	rjmp	.+114    	; 0x6488 <get_readings+0x142>
				}
			}
			else if(left_data){////
    6416:	89 81       	ldd	r24, Y+1	; 0x01
    6418:	88 23       	and	r24, r24
    641a:	21 f1       	breq	.+72     	; 0x6464 <get_readings+0x11e>
				left_button_pressed_counter++;
    641c:	80 91 31 07 	lds	r24, 0x0731
    6420:	90 91 32 07 	lds	r25, 0x0732
    6424:	01 96       	adiw	r24, 0x01	; 1
    6426:	90 93 32 07 	sts	0x0732, r25
    642a:	80 93 31 07 	sts	0x0731, r24
				hazzred_button_pressed_counter=0;
    642e:	10 92 28 07 	sts	0x0728, r1
    6432:	10 92 27 07 	sts	0x0727, r1
				right_button_pressed_counter=0;
    6436:	10 92 34 07 	sts	0x0734, r1
    643a:	10 92 33 07 	sts	0x0733, r1
				if(!(left_button_pressed_counter%10)){
    643e:	80 91 31 07 	lds	r24, 0x0731
    6442:	90 91 32 07 	lds	r25, 0x0732
    6446:	2a e0       	ldi	r18, 0x0A	; 10
    6448:	30 e0       	ldi	r19, 0x00	; 0
    644a:	b9 01       	movw	r22, r18
    644c:	0e 94 03 33 	call	0x6606	; 0x6606 <__divmodhi4>
    6450:	00 97       	sbiw	r24, 0x00	; 0
    6452:	d1 f4       	brne	.+52     	; 0x6488 <get_readings+0x142>
					L_button = 1;
    6454:	81 e0       	ldi	r24, 0x01	; 1
    6456:	80 93 2d 07 	sts	0x072D, r24
					R_button = 0;
    645a:	10 92 2a 07 	sts	0x072A, r1
					Hazzred_button = 0;
    645e:	10 92 30 07 	sts	0x0730, r1
    6462:	12 c0       	rjmp	.+36     	; 0x6488 <get_readings+0x142>

				}
			}
			else{
				hazzred_button_pressed_counter=0;
    6464:	10 92 28 07 	sts	0x0728, r1
    6468:	10 92 27 07 	sts	0x0727, r1
				right_button_pressed_counter=0;
    646c:	10 92 34 07 	sts	0x0734, r1
    6470:	10 92 33 07 	sts	0x0733, r1
				left_button_pressed_counter=0;
    6474:	10 92 32 07 	sts	0x0732, r1
    6478:	10 92 31 07 	sts	0x0731, r1
				L_button = 0;
    647c:	10 92 2d 07 	sts	0x072D, r1
				R_button = 0;
    6480:	10 92 2a 07 	sts	0x072A, r1
				Hazzred_button = 0;
    6484:	10 92 30 07 	sts	0x0730, r1
			}
		}
//	}
}
    6488:	0f 90       	pop	r0
    648a:	0f 90       	pop	r0
    648c:	0f 90       	pop	r0
    648e:	cf 91       	pop	r28
    6490:	df 91       	pop	r29
    6492:	08 95       	ret

00006494 <vState_machine>:


void vState_machine(void)
{
    6494:	df 93       	push	r29
    6496:	cf 93       	push	r28
    6498:	cd b7       	in	r28, 0x3d	; 61
    649a:	de b7       	in	r29, 0x3e	; 62
	while(1)
	{

		if(ignition_button){
    649c:	80 91 29 07 	lds	r24, 0x0729
    64a0:	88 23       	and	r24, r24
    64a2:	e1 f3       	breq	.-8      	; 0x649c <vState_machine+0x8>

//			DIO_SetPinVal(DIO_PORTC , Pin6 , HIGH);
			if(Hazzred_button){
    64a4:	80 91 30 07 	lds	r24, 0x0730
    64a8:	88 23       	and	r24, r24
    64aa:	29 f0       	breq	.+10     	; 0x64b6 <vState_machine+0x22>
//				DIO_SetPinVal(DIO_PORTC , Pin6 , HIGH);
				vBlink_Right();
    64ac:	0e 94 73 32 	call	0x64e6	; 0x64e6 <vBlink_Right>
				Blink_LEFT();
    64b0:	0e 94 89 32 	call	0x6512	; 0x6512 <Blink_LEFT>
    64b4:	f3 cf       	rjmp	.-26     	; 0x649c <vState_machine+0x8>
//				DIO_SetPinVal(DIO_PORTC , Pin3 , HIGH);
			}
			else if(R_button ){
    64b6:	80 91 2a 07 	lds	r24, 0x072A
    64ba:	88 23       	and	r24, r24
    64bc:	41 f0       	breq	.+16     	; 0x64ce <vState_machine+0x3a>
				DIO_SetPinVal(DIO_PORTC , Pin3 , LOW);
    64be:	82 e0       	ldi	r24, 0x02	; 2
    64c0:	63 e0       	ldi	r22, 0x03	; 3
    64c2:	40 e0       	ldi	r20, 0x00	; 0
    64c4:	0e 94 86 2e 	call	0x5d0c	; 0x5d0c <DIO_SetPinVal>
				vBlink_Right();
    64c8:	0e 94 73 32 	call	0x64e6	; 0x64e6 <vBlink_Right>
    64cc:	e7 cf       	rjmp	.-50     	; 0x649c <vState_machine+0x8>


			}
			else if(L_button ){
    64ce:	80 91 2d 07 	lds	r24, 0x072D
    64d2:	88 23       	and	r24, r24
    64d4:	19 f3       	breq	.-58     	; 0x649c <vState_machine+0x8>
				DIO_SetPinVal(DIO_PORTC , Pin6, LOW);
    64d6:	82 e0       	ldi	r24, 0x02	; 2
    64d8:	66 e0       	ldi	r22, 0x06	; 6
    64da:	40 e0       	ldi	r20, 0x00	; 0
    64dc:	0e 94 86 2e 	call	0x5d0c	; 0x5d0c <DIO_SetPinVal>
				Blink_LEFT();
    64e0:	0e 94 89 32 	call	0x6512	; 0x6512 <Blink_LEFT>
    64e4:	db cf       	rjmp	.-74     	; 0x649c <vState_machine+0x8>

000064e6 <vBlink_Right>:
			}
		}

	}
}
void vBlink_Right(void ){
    64e6:	df 93       	push	r29
    64e8:	cf 93       	push	r28
    64ea:	cd b7       	in	r28, 0x3d	; 61
    64ec:	de b7       	in	r29, 0x3e	; 62

//	while(1){
//		DIO_SetPinVal(DIO_PORTC , Pin6 , HIGH);
		if(led_mode){
    64ee:	80 91 26 07 	lds	r24, 0x0726
    64f2:	88 23       	and	r24, r24
    64f4:	31 f0       	breq	.+12     	; 0x6502 <vBlink_Right+0x1c>
			/*TIMER1_PWM_STOP();*/
			DIO_SetPinVal(DIO_PORTC , Pin6 , HIGH);
    64f6:	82 e0       	ldi	r24, 0x02	; 2
    64f8:	66 e0       	ldi	r22, 0x06	; 6
    64fa:	41 e0       	ldi	r20, 0x01	; 1
    64fc:	0e 94 86 2e 	call	0x5d0c	; 0x5d0c <DIO_SetPinVal>
    6500:	05 c0       	rjmp	.+10     	; 0x650c <vBlink_Right+0x26>
		}else{
			/*TIMER1_PWM_START();*/
			DIO_SetPinVal(DIO_PORTC , Pin6 , LOW);
    6502:	82 e0       	ldi	r24, 0x02	; 2
    6504:	66 e0       	ldi	r22, 0x06	; 6
    6506:	40 e0       	ldi	r20, 0x00	; 0
    6508:	0e 94 86 2e 	call	0x5d0c	; 0x5d0c <DIO_SetPinVal>
//		vTaskDelay( 400 );
//		led_mode= !led_mode;
	}


}
    650c:	cf 91       	pop	r28
    650e:	df 91       	pop	r29
    6510:	08 95       	ret

00006512 <Blink_LEFT>:

void Blink_LEFT(void){
    6512:	df 93       	push	r29
    6514:	cf 93       	push	r28
    6516:	cd b7       	in	r28, 0x3d	; 61
    6518:	de b7       	in	r29, 0x3e	; 62
//		TIMER0_PWM_Stop();
//	}else{
//		TIMER0_PWM_Start();
//	}
//		DIO_SetPinVal(DIO_PORTC , Pin3 , HIGH);
		if(led_mode){
    651a:	80 91 26 07 	lds	r24, 0x0726
    651e:	88 23       	and	r24, r24
    6520:	31 f0       	breq	.+12     	; 0x652e <Blink_LEFT+0x1c>
			/*TIMER1_PWM_STOP();*/
			DIO_SetPinVal(DIO_PORTC , Pin3 , HIGH);
    6522:	82 e0       	ldi	r24, 0x02	; 2
    6524:	63 e0       	ldi	r22, 0x03	; 3
    6526:	41 e0       	ldi	r20, 0x01	; 1
    6528:	0e 94 86 2e 	call	0x5d0c	; 0x5d0c <DIO_SetPinVal>
    652c:	05 c0       	rjmp	.+10     	; 0x6538 <Blink_LEFT+0x26>
		}else{
			/*TIMER1_PWM_START();*/
			DIO_SetPinVal(DIO_PORTC , Pin3 , LOW);
    652e:	82 e0       	ldi	r24, 0x02	; 2
    6530:	63 e0       	ldi	r22, 0x03	; 3
    6532:	40 e0       	ldi	r20, 0x00	; 0
    6534:	0e 94 86 2e 	call	0x5d0c	; 0x5d0c <DIO_SetPinVal>
		}
//	}
}
    6538:	cf 91       	pop	r28
    653a:	df 91       	pop	r29
    653c:	08 95       	ret

0000653e <READ_IGNITON>:
uint8_t READ_IGNITON(void){
    653e:	df 93       	push	r29
    6540:	cf 93       	push	r28
    6542:	0f 92       	push	r0
    6544:	cd b7       	in	r28, 0x3d	; 61
    6546:	de b7       	in	r29, 0x3e	; 62

	DIO_SetPinDir(DIO_PORTA ,Pin0, INPUT);
    6548:	80 e0       	ldi	r24, 0x00	; 0
    654a:	60 e0       	ldi	r22, 0x00	; 0
    654c:	42 e0       	ldi	r20, 0x02	; 2
    654e:	0e 94 99 2d 	call	0x5b32	; 0x5b32 <DIO_SetPinDir>
	uint8_t IGNITION_data = DIO_GetPinVal(DIO_PORTA ,Pin0) ;
    6552:	80 e0       	ldi	r24, 0x00	; 0
    6554:	60 e0       	ldi	r22, 0x00	; 0
    6556:	0e 94 73 2f 	call	0x5ee6	; 0x5ee6 <DIO_GetPinVal>
    655a:	89 83       	std	Y+1, r24	; 0x01
	return IGNITION_data;
    655c:	89 81       	ldd	r24, Y+1	; 0x01
}
    655e:	0f 90       	pop	r0
    6560:	cf 91       	pop	r28
    6562:	df 91       	pop	r29
    6564:	08 95       	ret

00006566 <READ_HAZARD_Button>:
uint8_t READ_HAZARD_Button(void){
    6566:	df 93       	push	r29
    6568:	cf 93       	push	r28
    656a:	0f 92       	push	r0
    656c:	cd b7       	in	r28, 0x3d	; 61
    656e:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTA ,Pin1, INPUT);
    6570:	80 e0       	ldi	r24, 0x00	; 0
    6572:	61 e0       	ldi	r22, 0x01	; 1
    6574:	42 e0       	ldi	r20, 0x02	; 2
    6576:	0e 94 99 2d 	call	0x5b32	; 0x5b32 <DIO_SetPinDir>
	uint8_t HAZARD_data = DIO_GetPinVal(DIO_PORTA ,Pin1) ;
    657a:	80 e0       	ldi	r24, 0x00	; 0
    657c:	61 e0       	ldi	r22, 0x01	; 1
    657e:	0e 94 73 2f 	call	0x5ee6	; 0x5ee6 <DIO_GetPinVal>
    6582:	89 83       	std	Y+1, r24	; 0x01

	 }else{
	 return unpressed;
	 }
	 */
	return HAZARD_data;
    6584:	89 81       	ldd	r24, Y+1	; 0x01
}
    6586:	0f 90       	pop	r0
    6588:	cf 91       	pop	r28
    658a:	df 91       	pop	r29
    658c:	08 95       	ret

0000658e <READ_RIGHT_Button>:
uint8_t READ_RIGHT_Button(void){
    658e:	df 93       	push	r29
    6590:	cf 93       	push	r28
    6592:	0f 92       	push	r0
    6594:	cd b7       	in	r28, 0x3d	; 61
    6596:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTA ,Pin2, INPUT);
    6598:	80 e0       	ldi	r24, 0x00	; 0
    659a:	62 e0       	ldi	r22, 0x02	; 2
    659c:	42 e0       	ldi	r20, 0x02	; 2
    659e:	0e 94 99 2d 	call	0x5b32	; 0x5b32 <DIO_SetPinDir>
	uint8_t right_data  = DIO_GetPinVal(DIO_PORTA ,Pin2) ;
    65a2:	80 e0       	ldi	r24, 0x00	; 0
    65a4:	62 e0       	ldi	r22, 0x02	; 2
    65a6:	0e 94 73 2f 	call	0x5ee6	; 0x5ee6 <DIO_GetPinVal>
    65aa:	89 83       	std	Y+1, r24	; 0x01
	return right_data ;
    65ac:	89 81       	ldd	r24, Y+1	; 0x01
}
    65ae:	0f 90       	pop	r0
    65b0:	cf 91       	pop	r28
    65b2:	df 91       	pop	r29
    65b4:	08 95       	ret

000065b6 <READ_LEFT_Button>:
uint8_t READ_LEFT_Button(void){
    65b6:	df 93       	push	r29
    65b8:	cf 93       	push	r28
    65ba:	0f 92       	push	r0
    65bc:	cd b7       	in	r28, 0x3d	; 61
    65be:	de b7       	in	r29, 0x3e	; 62
	DIO_SetPinDir(DIO_PORTA ,Pin3, INPUT);
    65c0:	80 e0       	ldi	r24, 0x00	; 0
    65c2:	63 e0       	ldi	r22, 0x03	; 3
    65c4:	42 e0       	ldi	r20, 0x02	; 2
    65c6:	0e 94 99 2d 	call	0x5b32	; 0x5b32 <DIO_SetPinDir>
	uint8_t right_data  = DIO_GetPinVal(DIO_PORTA ,Pin3) ;
    65ca:	80 e0       	ldi	r24, 0x00	; 0
    65cc:	63 e0       	ldi	r22, 0x03	; 3
    65ce:	0e 94 73 2f 	call	0x5ee6	; 0x5ee6 <DIO_GetPinVal>
    65d2:	89 83       	std	Y+1, r24	; 0x01
	return right_data;
    65d4:	89 81       	ldd	r24, Y+1	; 0x01

}
    65d6:	0f 90       	pop	r0
    65d8:	cf 91       	pop	r28
    65da:	df 91       	pop	r29
    65dc:	08 95       	ret

000065de <__udivmodhi4>:
    65de:	aa 1b       	sub	r26, r26
    65e0:	bb 1b       	sub	r27, r27
    65e2:	51 e1       	ldi	r21, 0x11	; 17
    65e4:	07 c0       	rjmp	.+14     	; 0x65f4 <__udivmodhi4_ep>

000065e6 <__udivmodhi4_loop>:
    65e6:	aa 1f       	adc	r26, r26
    65e8:	bb 1f       	adc	r27, r27
    65ea:	a6 17       	cp	r26, r22
    65ec:	b7 07       	cpc	r27, r23
    65ee:	10 f0       	brcs	.+4      	; 0x65f4 <__udivmodhi4_ep>
    65f0:	a6 1b       	sub	r26, r22
    65f2:	b7 0b       	sbc	r27, r23

000065f4 <__udivmodhi4_ep>:
    65f4:	88 1f       	adc	r24, r24
    65f6:	99 1f       	adc	r25, r25
    65f8:	5a 95       	dec	r21
    65fa:	a9 f7       	brne	.-22     	; 0x65e6 <__udivmodhi4_loop>
    65fc:	80 95       	com	r24
    65fe:	90 95       	com	r25
    6600:	bc 01       	movw	r22, r24
    6602:	cd 01       	movw	r24, r26
    6604:	08 95       	ret

00006606 <__divmodhi4>:
    6606:	97 fb       	bst	r25, 7
    6608:	09 2e       	mov	r0, r25
    660a:	07 26       	eor	r0, r23
    660c:	0a d0       	rcall	.+20     	; 0x6622 <__divmodhi4_neg1>
    660e:	77 fd       	sbrc	r23, 7
    6610:	04 d0       	rcall	.+8      	; 0x661a <__divmodhi4_neg2>
    6612:	e5 df       	rcall	.-54     	; 0x65de <__udivmodhi4>
    6614:	06 d0       	rcall	.+12     	; 0x6622 <__divmodhi4_neg1>
    6616:	00 20       	and	r0, r0
    6618:	1a f4       	brpl	.+6      	; 0x6620 <__divmodhi4_exit>

0000661a <__divmodhi4_neg2>:
    661a:	70 95       	com	r23
    661c:	61 95       	neg	r22
    661e:	7f 4f       	sbci	r23, 0xFF	; 255

00006620 <__divmodhi4_exit>:
    6620:	08 95       	ret

00006622 <__divmodhi4_neg1>:
    6622:	f6 f7       	brtc	.-4      	; 0x6620 <__divmodhi4_exit>
    6624:	90 95       	com	r25
    6626:	81 95       	neg	r24
    6628:	9f 4f       	sbci	r25, 0xFF	; 255
    662a:	08 95       	ret

0000662c <memcpy>:
    662c:	fb 01       	movw	r30, r22
    662e:	dc 01       	movw	r26, r24
    6630:	02 c0       	rjmp	.+4      	; 0x6636 <memcpy+0xa>
    6632:	01 90       	ld	r0, Z+
    6634:	0d 92       	st	X+, r0
    6636:	41 50       	subi	r20, 0x01	; 1
    6638:	50 40       	sbci	r21, 0x00	; 0
    663a:	d8 f7       	brcc	.-10     	; 0x6632 <memcpy+0x6>
    663c:	08 95       	ret

0000663e <memset>:
    663e:	dc 01       	movw	r26, r24
    6640:	01 c0       	rjmp	.+2      	; 0x6644 <memset+0x6>
    6642:	6d 93       	st	X+, r22
    6644:	41 50       	subi	r20, 0x01	; 1
    6646:	50 40       	sbci	r21, 0x00	; 0
    6648:	e0 f7       	brcc	.-8      	; 0x6642 <memset+0x4>
    664a:	08 95       	ret

0000664c <_exit>:
    664c:	f8 94       	cli

0000664e <__stop_program>:
    664e:	ff cf       	rjmp	.-2      	; 0x664e <__stop_program>
